(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var App, ImmutableData, React, Song, UndoHistory;

ImmutableData = require('./util/immutable_data');

UndoHistory = require('./util/undo_history');

React = require('react/addons');

Song = require('./models/song');

App = require('./ui/app');

if ("development" === 'development') {
  (require('build-status')).client();
  window.React = React;
  window.App = App;
  window.Song = Song;
  window.Track = require('./models/track');
  window.DrumSampler = require('./models/drum_sampler');
  window.BasicSampler = require('./models/basic_sampler');
  window.TrackSelection = require('./ui/track_selection');
  window.Meter = require('./ui/meter');
  window.PianoRoll = require('./ui/piano_roll');
  window.GridLines = require('./ui/piano_roll/grid_lines');
  window.Keys = require('./ui/piano_roll/keys');
  window.Notes = require('./ui/piano_roll/notes');
  window.PlaybackMarker = require('./ui/piano_roll/playback_marker');
  window.Selection = require('./ui/piano_roll/selection');
}

document.addEventListener('DOMContentLoaded', function() {
  return require('./default_song')(function(songData) {
    var song;
    song = new Song;
    return ImmutableData.create(songData, function(data, history) {
      if ("development" === 'development') {
        window.data = data;
      }
      song.update(data);
      return React.renderComponent(App({
        data: data,
        song: song,
        history: history
      }), document.body);
    });
  });
});



},{"./default_song":2,"./models/basic_sampler":13,"./models/drum_sampler":14,"./models/song":20,"./models/track":21,"./ui/app":24,"./ui/meter":35,"./ui/piano_roll":43,"./ui/piano_roll/grid_lines":44,"./ui/piano_roll/keys":45,"./ui/piano_roll/notes":49,"./ui/piano_roll/playback_marker":50,"./ui/piano_roll/selection":51,"./ui/track_selection":57,"./util/immutable_data":64,"./util/undo_history":70,"build-status":74,"react/addons":78}],2:[function(require,module,exports){
var async, b2a, bass, callbacks, cuid, data, decoder, fs, hat, kick, loaded, sequences, snare;

async = require('async');



b2a = require('base64-arraybuffer');

cuid = require('cuid');

decoder = require('./dsp/global_context');

sequences = require('./sequences');

loaded = false;

data = null;

callbacks = [];

module.exports = function(cb) {
  if (loaded) {
    return cb(data);
  } else {
    return callbacks.push(cb);
  }
};

bass = b2a.decode("UklGRixjAQBXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQhjAQD6/wUA+f8EAPv/AgD/////AQD9/wIA/f8DAP3/AgD+/wEA//8AAAEA/P8EAPv/BAD+/wAAAAD/////AgD//wEAAAD+/wMA/f8DAP7/AQD//wAAAgD//wIA/f8DAP7/AwD//wAAAQAAAAEAAQAAAAIA//8CAP//AQD/////AAAAAAAA/v8DAPz/BAD9/wIA/////wAAAAAAAP7/AgD8/wMA/f8BAP//AQD+/wEA/v///wEA/f8BAP3/AQD8/wIA+/8CAPz/AAD+///////9/wIA+f8FAPr/AgD8/wAA/v/+/wEA+/8BAPr/AwD5/wIA+/8AAP//+/8CAPr/AQD5/wIA+f8BAPr//v/7////+v8BAPr//v/8//z//v/5/wIA9v8DAPX/AQD4/wAA+P////r//P/9//n//v/7//v//P/8//z/+//+//r////5//7/+/////v//f/9//z//f////r/AgD5/wEA/P/9/wIA+f8EAPr/AQD9/wAA/P8DAPv/BAD8/wAAAQD8/wYA+f8IAPn/BwD7/wYA/f8EAAEAAQADAP//BgD9/wcA/v8EAAMAAAAHAP//BAACAAMABAADAAMAAgAEAAIABwD//wkA//8IAP//CQD//wgAAgAEAAYAAQAIAAAACAAAAAkAAAAHAAMABgAEAAMABgACAAgAAAAHAAEABgAEAAIACAD//wkAAAAFAAYAAAAGAAIABAACAAMABAABAAYAAAAEAAIABAAAAAYA//8GAP//BwD9/wgA/f8HAP3/BwD+/wYA/v8FAAAAAwABAAEABAABAAEAAgACAAEAAQACAP//BAD//wIAAQABAAAAAwD+/wMAAAABAAEAAAADAP3/BwD6/wUA/v8CAP//AQABAAAAAgD+/wMA/f8FAPz/BAD+/wIA//8CAP3/BAD+/wAAAgD+/wEAAgD9/wQA+/8GAPr/CAD4/wgA+v8FAP3/AwD//wAAAgABAAAAAgAAAAIAAAACAP//AwD//wIA//8DAP3/BQD8/wEAAQD//wIA//8BAAAAAQAAAAAAAQD//wIA/v8DAP7/AgD+/wMA/f8DAP//AQD9/wIAAAAAAAEA/v8AAAEAAAD+/wEAAAD//wIA+/8FAPn/BQD6/wQA/v///wIA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zBa4GJYaUxzzHWgftCDEIZsiMyOPI78j0iPWI9YjziPHI7sjsCOlI5cjiyN/I3MjZiNaI0wjQSM1IyYjHSMLIwgj8iLuItsi0iLGIrgiriKgIpUihiJ/Im0iaSJUIk8iPyI1IigiHSIRIgUi+iHvIeEh2CHIIcAhsSGmIZwhjSGGIXghbyFhIVkhSCFCITQhJiEeIRAhBiH7IO4g5CDZIM0gwCC4IKcgoiCSIIkgfyBuIGogVyBUIEAgPSAsICQgGSAJIAMg9h/oH+Qfzx/QH7kfuB+kH58fkx+GH38fcB9oH1sfUR9GHzofMB8mHxkfDx8GH/ce8h7iHtoezB7GHuke9B/WIIEgAyH5H6shhQqT4SHZIdda16vWU9cT2CfoCP5kDKwUhRiWGowbyRxgHewd/R0rHhUeKh4UHh4eCR4JHvYd9R3gHeEdyh3LHbgdsx2jHZ0dkB2HHXsdcR1nHVsdUR1HHTsdNB0kHSAdEB0KHfsc9hzmHOEc0hzKHL8cthyqHKIclByPHIAceRxuHGMcWRxPHEYcORw1HCIcIhwNHAsc/Rv0G+ob3xvWG8wbwxu2G68bpRuZG5IbhRt8G3MbaBtfG1YbShtBGzgbLBsmGxkbDxsHG/sa9BroGuAa1RrMGsEauBquGqQanBqQGokafhpyGm0aXRpbGkwaQxo8GjAaJhogGhIaCxoBGvcZ8BkcGjAb7BuOGxQcAxuxHEcDUd202fjXA9kM2LbY1Nbt1nPW4taZ1vDWu9b11tnWBdf91iPXGtdB1znXXtde13zXgNeh16PXxtfK1+fX89cM2BjYNdg92F3YZtiD2JTYqtjC2NPY79gD2R3ZONlP2W7Zhtmo2cbZ6NkN2jPaXtqN2sTa/tpK253bCNyG3B/d1d2n3pTflOCw4dXiE+RV5afm/edi6eDqo+x07vXvf/HP8oTzwu1m4ePbetsM2ynb/NrZ2nrak9p/2qTamNq42q/ay9rI2uPa4dr82vraE9sV2yrbNds/21HbV9tq23TbgNuR25fbq9uz28Tbzdvc2+fb99v/2xLcF9wq3DPcQtxN3FvcZ9x03IDcj9yZ3KjcstzC3Mzc2tzo3PLcAt0M3RrdKd0x3UPdSd1f3WTdeN1+3ZHdmt2q3bfdwt3S3dzd7t333QveE94m3jTeQd5W3mLeeN6I3pzert7F3tTe797+3hjf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");

kick = b2a.decode("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fQCDAH0AeAB5AGoAdABjAG0AYABpAGcAagBrAGgAYwBeAGIAWQBaAFQAXABYAFMATQBKAEkAPABFADoAQAA0ADwAMAA8ADIAMQAsACsAIwAmACcAHQAhABYAFQAeABsAFgAQABkAGQAdABMAEwAQAAwADQAIAA8ABwADAP7/AQD5////8//9//f/AAD3//D/7v/n/+n/7//y/+7/5P/k/+H/1//X/9b/2f/a/9z/1P/c/9//3//W/8//zv/K/9P/zP/O/9D/y//T/8z/x//E/73/xv/A/8D/vP+//7r/uv++/73/wP+u/77/vP+9/7T/uP+4/7f/s/+t/7//uv+5/6r/sv+r/7D/sv+w/7L/rv+z/67/q/+m/6f/oP+p/53/of+d/6P/p/+n/5v/nf+c/5D/k/+L/43/lP+R/5P/hv+O/4z/jv+P/5n/lP+S/4b/jv+M/4H/fP+D/4f/gv+F/3z/gf+F/4H/iv+C/4D/hP9//37/ef92/3j/fv95/3z/fP93/3n/ef+D/4b/hP98/3n/e/93/4D/bv90/3T/dv93/3D/cf90/3D/bP9z/2n/cP9x/3T/cv90/3T/cv92/23/af9j/2H/Zv9i/2r/ZP9q/2b/af9i/27/av9m/2r/Yv9d/2P/Wv9j/17/Xf9b/13/Uv9Q/1f/V/9V/1n/T/9X/07/U/9L/1b/U/9O/1v/UP9N/0f/TP9S/1f/U/9W/0r/Tf9S/07/TP9O/0//SP9J/0P/Tf9I/0z/R/9H/0b/Rf9K/0z/S/9E/0v/Rv9O/0n/UP9F/0j/R/9K/0n/Rv9G/0P/Qv9N/1L/Uv9T/0z/Sv9U/0n/UP9J/0b/Tf9L/1f/S/9V/03/T/9L/0j/Qv9M/03/T/9R/0//Vv9d/1n/Vf9U/1T/Uv9V/1f/Vf9Z/1X/Vv9V/1//V/9d/1j/YP9i/13/Xf9e/17/ZP9j/2v/Zf9s/2//cP9y/3L/bP9p/2L/av9s/3P/cf9u/2X/Zv9v/3b/eP9+/3T/c/9u/27/eP93/3r/fP97/4L/fv+K/4L/ff+A/4L/f/+D/4T/g/+O/4T/if9//4P/h/+L/4r/hv+C/4z/i/+K/43/hP+L/47/kf+M/5T/jv+J/5v/lP+Y/4//jf+Q/47/oP+d/5j/kf+g/5v/ov+d/6b/oP+j/6P/qP+k/6D/pP+j/6P/p/+j/57/qv+j/67/rv+0/6f/rP+u/7n/tf+9/7r/tP+9/7j/t/+7/73/uv+4/7j/v//B/8H/xf/D/77/v//B/8H/vf/A/7//xP/L/8L/zv/G/8H/zP/M/83/zP/I/9D/2P/c/9j/1//U/9H/1v/X/9r/3//i/+P/2P/a/9z/3f/f/9T/3v/X/+T/4//U/9f/3//c/9r/3f/i/+T/1//i/9b/4//k/+P/5P/v/+f/7P/u/+//6//u//P/7v/z//L/7f/p/+f/6//w//X/9P/x//n/8P/y//H/7//z//L/8//z/+//7f/s//r/+v/z//r/7P/5//P//P/y//X/8v/4//f/+f/5//n/+P/7//z/AwAAAAAAAgD+//j/BQAAAAYA+P8AAPf/AgD//wAA/f8EAAQA+/8BAPz//P/3//z///8BAPb/BQAJAAMADAD8/wQAAAAMAAMADgAIAAwAAwAEAPv/AAAKAAoACwACAAMAAgAKAAIACAD//wQAAgAEAAgACQAOAAYAEQAMAA8ADgAHAA4ACwATAAsADwAPABIAEAAKAA4ABwALAAkADAAOAAgA//8IAAYADAANAA0ACAAIAAwABwAMAAIABwAHAAwACwASAA8AFgASABQADgAMAA4ADgAWABYAFAARABAAEQALAA0ADAANAA4AGwAYABIACgANABMAEgAXABkADAAPAAsAEgAPABIAEAAPABAAEwAVABIAFwAXAAsAFAAMAAwABgABAAEAAgAFAAMACwD7/wQA/P8EAP3//v/4//v/+P/9/wMAAgD+/wIA/f8IAAEAAQD//wMA/v8FAAUACQABAAMABQABAAEA/v8CAAQAAAACAPf/AwABAP///v8EAAAABAAEAP/////+/wYA/f8GAAEA/v/9//z/+v/1/wIA+f/9//f/AgD6//z//f/+//f////5//f/+v/6//T//f/6//f/+P/x//L/9P/w//T/9P/7//b/+f/0//b/9f/6//T//P/w//3/8//3//f/AQD8//r/9v/x//X/9v/3//b/9v/6//T/9f/y//X/8//1//P/+P/5//b/9v/2//L/9f/0//f/9P/3//T/+f/0//L/9P/0//j/9//1//L/8v/2/+//9//w//X/7v/v//T/8v/0//D/9f/t/+//7P/r//L/6//w/+//7v/u/+v/8//x//P/9P/z//P/9P/0//P/8v/1/+7/8v/v//T/8f/x//D/7//v//L/8//z//H/8P/0/+7/9P/v//b/8P/0//D/9v/0//b/8//z//L/7//0/+3/8//w//b/8f/x//X/7//1//D/8v/y//H/9f/3//L/9v/v//j/8//3//X/8//3//D/9P/u//T/8v/y//H/8v/1//L/9f/0//f/9//1//f/9//3//j/8//1//T/9f/0//b/9P/1//T/9v/3//T/9f/1//X/9v/2//f/9//2//b/+P/3//f/+P/2//n/9v/3//f/9v/5//T/+v/1//n/+P/5//v/9f/+//X/+//5//r/+//5//v/9//9//f//v/4//z/+P/+//j//v/5//z/+//6////+P8BAPf////6//7/+v////f/AgD4/wEA/P////v/AQD5/wEA+/////z////9//7////8/wIA+/8CAP3///8BAP3/AQD/////AQD/////AgA=");

snare = b2a.decode("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zP/Q//T/GAADAMv/tf/X/yAAKgAWAOT/2f/c/+n/yP+7/+3/EQAMABgAGgAHANr/1v/l//b/+v/0/+3/6P8BABIA/f/V/8j/3v/x//X/+v/y/+3/2//c/97/6f8CAP7/3P/X/+3/FwARAPr/+//7//b/4P/U/9b/5P/f//f/CwD+/+D/1f8BABwABQDY/9D/+/8pAAkA4P/Y//P//v/v/+//BgD3/9D/y//t//7//f8DAAgA9P/M/8T/8v8SAAkA7//w/w4AEwACAPH/4P/w/w4ACAD8/wEADwD+/+r/6v/7/wkAAwDp/+T/4//3/+n/1//V//H/HQAOAPT/4v/U/9T/6f/3/w0AGQABAPD/9P8FAAcABQAFAPT/8f/n//r/+//x/+j/9f/9//P/9P/2/wgABgD+//r/DQAEAN3/0P/e/+z//P////z/EAAQAPv/3f/Y/9X/7/8PABIADgAEAAgA+P/r/9j/7v///wsA/f8NABMABAD2/+r/AAAhACIA8P/Q/9H/9f/+/+z/7P/z//P/4f/w/wUAEAAGAP3/9f/r/+n/7v/r//D/AAASAAIA8f/q/+z/9P/6/+X/4//r//b/8P/l/9r/5P/+/wMA5P/R/9L/9/8hABUA/f/k//b/8//3//P/9//n/9z/7v8PAA4A/f/1/+//9P//////9P/x//f/8P/t/+D/4v/s//f/+P/b/8X/4v8NABIA+//0/+//9f8CABAAAgDx/+3/4P/f/9r/7f8CAAYA+f/z//n////9//7/BwD+/+n/5//p/+n/9v/1//f/8v/7/+3/8f8FAAEA+v/m/9//0v/Q//z/EQASAAEA/v/1/+v/4//s//z/BAAKAAYA/f/5//f//f/6//j/8f/s/+n/5P/i/+z//v8GAPj/9f8EAP///v8GAAUA9P/t//L/4//T/9v/5f/z//7/9P/m//P/9//9//L/8P/0//v/DwAFAPP/3//k/+T/AQD+/+7/3P/j//b/GgANAOv/3P/p/xAADQADAAEA+v/f/+D/5f/9////BAD4/+r/3//n//D/+f/6//n/6//m/97/6f/o/+7/5f/l/9z/9f8OAAYA5f/V/97/BQAIAPL/6P/u/+f/4P/n/wUADgD+//X//v/5//H/9P/6//L/8P/6/+z/5v/i/+7/AQD///b/2P/V/9z//v/2/+f/4//3//D/7v/j/+3/BgARAPP/5//f//H/7P/p/+n/+/8BAAEA+P/w/+v/9v/+//P/7P/k/+P/9//7//r/6//m//X/CQAJAPL/6v/x/wEADQABAPr/8v/t/+b/5//j//L/AgAHAP//+f/z//n//P/6/+7/+P/+//T/7f/r/+z///8EAP3/7f/u//D/+/8AAP///f8DAAsA+P/5/+j/6f/g//j/+f/3//X/+f/4//H/5P/f/+//BAAMAP3/+P/p/+3/AAAPAAoA9f/v/+7/+v/3//n/7/8JAAwAAADm/+r/8f/6//f/8v8BAAQA/P/8//v/BAD//wUA/P8AAPX/9P/t/+//6v/8/wYABgDx/+3//v8BAPf/8P8BAAYABAD3//b/9v/0//D/8P8FAAsACQDx//T/+f8EAAEAAQAFAPf/7//y//j//v/7////7//o/+P/8v/+/wEA+//z/+//9//z//b/5f/2//T/+f/1//7/BAD8//H/5//x//r/BQD2//H/8f/7/wEA/v/1//T/8f/t//D/+P/7//v/7v/u//b/AQD3/+3/9v/3///////9/+7/6P/x/wMACgDz/+j/5//1//3/+v/5//P/9v/3//f/8//6//7/AgD2//b/7v/1//D////4//j/9P////j/6//r/+r/8f/5/wQA9P/x/+//+f/9//r/5//o/+//+v/5//7/9P/t/+z/9v8DAP/////u/+3/7P/u//f/+//4//f/+f/y//r/8P/v//b/9v/1/+r/8v/v//X/8f/v//D/+P/2//f/5//q/+3//f/7//b/8//2//n/8//y//P/8//r//f/9f/v/+j/7f/8//z/+f/v//D/8//4//j/8f/v//T/9//3//T//P/6//D/6//t/+3/8v/t/+v/4//m//H/8f/q/+j/7P/6/wEA+f/r/+n/6v/x//L/8v/2/+//8P/3//v////0/+//6//x//j//v/s/+z/8P/2//v/8//3//P/6v/p/+n/9P8AAP//+P/q/+z/7f/1//v//v/z//L/7v/0//H/9f/6//f/9v/w/+//7//9//7/BgD+//b/9P/u//j/9v/7//D/8//3/wEA/f/w//D/8/8FAAIA/P/1//b/9f/y//f/+v////3/+v/6//f/9v/2//r/+P8CAP3/9v/p/+z/8//7//v/+f/9//b/9P/8/wAAAAD5//n//v/8//L/9//z/wEA+v8DAAIA+P/z/+7//P8BAAAABQD6//b/5//v//7///8GAPr/AwD3//f/8f/5//v/AAD9//r/+P/6//X/+f/0//f/+v/8//r/7f/4//v/DAD8//z/8//9//n/9//1//L//v8DAAIA/P/0//X/9//3//7/9f/9//n/8//0//D/9//3//7/+v/6//3/+v/6//f//f/x//n/8//+//n/9P/y//T/9v/+/wIA+f/u/+z/9//9/wAA9//z//L/9//6//j/+f/6//T//f/y//r/8v/5//n/+//8/wMA9f/w/+3/8P////j/+f/0//T/+P/1//f/+P/0//r/8f/8//X/9v/w//L/+v/6//r/8v/y//T/9P/8//b/8v/3//P/+//0//j/8v/6//X////1//T/8//z//v/9P/6//z/+//4//D/9P/v//b/+f/7//3//f/0/+7/8f/4/wEA/f/0//H/9//3//r/9v/w//3/9f/5//L/+v/z//n/7f/4//X//P/4/+//9f/4////+v/5//X/9//2//f/+v/z//T/9P/3//r/8v/4//T/+P/7//X//v/3//X/9v/w//r/9P/5//X/9v/7//f/+P/0//b/9//z//T/8//6//j/9v/0//P/8v////X/9//y//j/9P/0//b/7//9//T/+v/y//f/8//0//b/+f/+//b/8//0//r/+//6//f/+f/1//f/8v/2//X/9v/2//X/9v/0//j/9f/4//X/+f/z//L/8f/z//T//v/6//f/8P/x//X/9//5//L/+f/1//f/+v/6//X/9P/y//3/+P/5//n/9f/5//X/9P/3//b/+//4//X/+f/2//n/+v/5//L/9f/2//v/+P/9//r//P/4//T/8v/1//z/AAD6//j/+P/2/wAA+//3//X/9v////r/9v/5//v//f/7//T//P/2/wMA+v/5//T/9P/4//r/+f/3//z/+P/9//X/9//z//z/+v/+//T/9//0////+f/6//j/8v/2//X//f8DAPn/9f/y//j//v/9//b/9v/1//n/+/////j/+f/w//r/9v/8//n/+f/5//f//P/3//v/+v/7//v/+v/1//v/9f/+//z/8//2//L//f/8//7/9v/2//X//f8AAPv/+P/3//f////6//r/+f/6//v//P/3//j/+v/8/wEA/f/7//T////6//7/+v/5//f//P/2//7/9//7/////v////f//P/2//7/+//5//v/+//4//3/+P/9//n/+//3//z/+P8AAPr////3//X/+v/1/wAA/P/+//r/9v/3//v//P////z//P/0//v/+P8AAPz//f/5//v//P/+//r/+P/2//r/+//5//r/+v/5//f/+//6//z/+//3//v/9//3//f/+v/8//3/+v/5//r/9//3//n//P/8//f/+P/4//v/+v/6//j//f/0//7/+v/8//n/+v/6//f/+f/3//r/+P/4//n/+f/5//f/8//5//j/+//2//n/9//7//b/+//4//r/9//1//r/+P/3//z/+f/7//n/+f/4//j/+v/3////9v/9//X/+f/3//n/9//6//r/9f/4//X//P/6//j/9f/5//n//f/4//j/8//4//L/+f/4//v/+P/2//f/9v/3//f/8//5//P/+v/1//n/9f/4//n/9P/5//D/+P/0//r/9f/2//X/+P/0//X/9f/2//n/9f/1//r/9P/5//D//f/0//v/9v/4//b/9P/3//j/9//2//X/+v/4//b/9v/2//T/9v/1//X/9v/2//n/8//5//L/9//z//f/9f/7//H/+P/1//b/9v/4//X/+f/1//f/+P/3//f/9//5//X/+P/3//7/+v/5//f/+f/7//f/+f/3//f//P/7//7/+P/7//X//P/6//r/AAD5//3/+v/4//7/+P8AAPv//v/9//z/+v/8//n////9//v/+f/6//7/AQD8//j/+//7//7//v/+//z/+v/4//3/////////+v////v//f/7//7//f/+//z/+//8//7/+//+//3//P/6//3/+/////3/+f/9//v//v/5//v//f/8//3/+f/9//v//f/5//3/+P/+//r//P/6//z//P////3/+v/8//n////8/////P/7//v//f/9//7/+v/6//z//f/7//3/+v/8//r//P/7//3/+//8//n//P/4//7/+v/9//j//P/9//v//f/5//3/+//5//z/+v/8//v/+v/9//z/+f/9//f//f/7//v//P/3//z/+v/7//z//P/4//r//f/3////8//8//r/+f/8//j//P/7//n/+v/7//j////3////9v/6//r/+//7//r/+v/6//n/+f/6//f//f/5//v/9v/7//b//P/5//j//P/0//r/9//6//r/+//2//r/9//7//j/+v/5//r//P/5//r/+f/6//r/+//7//v/9//7//f/+//5//r/+P/9//j/+f/4//n/+v/8//n/+v/4//7/+f/+//f/+f/5//z/+v/9//f/+//3//r/+//6//n/+f/7//n//P/1//r/9//9//v/+v/5//n/+//5//v/+P/8//r/+//6//r/+f/5//v/+P/9//j//P/5//r/+//6//v//P/4//z/+f/7//r/+//5//r/+//6//v/+//4//r/+v/4//3/+v/8//j/+v/4//z/+v/8//r/+f/8//r//v/4//v/+P/+//n/AAD2//7/+v/5//r/+f/7//r/+//6//z/+f/8//b//P/6/wAA+f/8//n/+v/5//r//P/9//z/+//7//z/+v/8//r//P/6//3//f/6//z//P/+//7/+P/+//n/AgD6//3/+v/8//r//v/6/wEA+/8AAPr//f/8//v//f/8//3/+//+//n//v/5//v//P/9//z//f/5//3/+v/7//3//v/6////9/8AAPj/+v/9//n////+//j/AAD3/wAA/P/6//3/+v/9//r//P/9//3/+/////n//v/7//v//f/8//n//v/7//z//P/8//v//P/8//n//f/5//3//P/6//7/+v/8//z/+v/+//z/+//9//n//v/6//z//f/6//z//P/5//3/+//+//r////5//z/+v/7//3/+//8//n/+//9//j//f/6//r//P/7//3/+P/+//b/AQD6//z/+//6//z//P/8//r//P/8//3//P/5//3/+f8AAPz//f/+//n//P/8//v////6//7/+f/6//z//P////n//v/6//3/+//6//3/+/////v//P/9//z//P/+//z//P/8//3//P/+//z/+/////v//f/7//3/+/////z//P////r//f/7//3////8//3//P/9//z////7////+//7//3//P/+//3//v/5////+P8DAPn/AAD6//z////8////+//8//v/+/////v//v/6//7//P/9//r////6////+v/+//v/+//+//v//f/7//r////5////+f////r////4////+P8AAPn//v/7//z//P/6//3//P/7//z/+//8//7/+f/9//r//f/8//7/+f////n//P/9//j/AAD2//7/+P////v//f/9//n//v/4//z/+//7//z/+v/8//n//f/4//3/+f/8//3//P/7//v//P/6//3/+//5////+f////j//v/5//z//f/8//r//P/6//z/+v/9//j/AAD3////9//+//f//f/5//r//f/5//7/+P/+//f/AAD5//3/+v/7//v//P/7//r//f/3////+P/9//n//f/7//n//v/4//3/+P/8//n//f/6//3//P/8//z/+v/9//v//P/8//3/+v////n/AAD5//7/+//9//7//v/8/wAA+//+//7/+v8BAPn/AgD6////AAD7/wIA+v8BAP3//f8AAPv//v/8////AQD9/////f///////f////3////9/////f////z/AgD7/wIA/P////z////9/wIA/v/8/wIA+P8EAPn/AQD+/wAA/P8AAPz/AAD8/wAA+/8FAPv/AgD8//7////9/wAA/v/+/wIA+v8CAPr/AAD8/wAA/f8AAP7////8/////v8AAP3//v/9/wAA/P8AAPv/AQD9/////v/9//7//v/9/wAA/f8AAP3//f////v/AgD7/////f/9//7//v/+//3//P8AAPv/AgD6/wAA/f/+/////P8AAPv/AQD8//7//v/+//3////8/////f////z////7/wAA/P/+//7//P////3//v/8//3//f////7//f////z//f/+//z////+//z//v/9//3////8//7//f/9/////f/9//7//f/+//3//f/9//3//v/8//7//f/9//3//f/+//7/+/8AAPv/AAD8//7//v/+//7//f/9//3//f/9//3//f/8//3//v/+//7//f/+//v/AAD7/////f/8//3//v/9////+//9//7//P8AAPr/AAD6/wAA+//+//3//f/+//v/AAD6/wAA+v8AAP3//f/9/////f/+////+f8BAPv//f8AAPv////+//v/AgD4/wEA/P/+////+/////v/AQD6/wAA+/8AAPz/AAD7//7////7/wAA/f/+/wAA+/8AAPv/AAD8//3/AAD6/wEA/P/+/////P////v/AAD9//7////8//7/AAD7/wIA+//+//7//v/+//7//f////z/AQD6/wIA+/8AAP3//v////z////9//7//v/+//7////8/wAA/f/+/wAA/P8BAPr/AgD5/wIA/P8AAP3/AQD7/////f//////AAD8/wEA/P8AAP7//v/9/////P8BAP3////+/////f8AAPz/AQD6/wIA/P8CAPz/AgD7/wAA/v/9/wEA/f/+/////f8AAP3////9/////f8BAPv/AQD8/wEA/f8AAP3///8AAPz/AAD///3/AQD9/wAA/v8AAP3///8AAPz/AwD7/wIA+v8DAPr/AwD9////AAD7/wIA/P8CAPv/AwD6/wIA/f/9/wIA+/8AAP3/AAD9/////v/+/wEA/f///wAA/f8BAP3///////3/AQD9/wAA/f8AAP7/AAD9/////v///////v/////////+///////9/wAA/P8BAP7//v8AAP3/AAD9/////v/////////+/////f8BAP3/AAD+//7////+/////v8AAPz/AQD8/wEA/v////7//v8AAP7///////7/AAD9/wAA/f8AAP7//v8AAP3/AQD+/wAA/v/+/wAA/f8AAAAA/P8CAPz/AAABAPv/AwD8/wEA///9/wIA/P8CAP3/AAD//////v8BAP3/AQD+////AAD+/wAA/v//////AAD9/wIA/P8BAP///////wAA/P8EAPr/AwD9////AQD9/wEA/P8CAP3///8CAPr/BAD7/wEA/v8BAPz/AgD9/wAA/v8AAP7/AQD7/wQA+v8EAPz///8AAP7/AAD+////AAD+/wAA/f8CAP3/AAAAAP3/AgD9//7/AgD8/wEA/v/+/wEA/P8BAP7/AAD///3/AQD9/wIA/f///wAA/v8AAP////////7/AQD9/wAAAAD9/wEA/f8AAP/////+/wEA+/8FAPj/BQD8/wAAAAD+//////8AAP7///8AAPz/AwD7/wMA/P8AAP////////////8AAP7/AQD8/wEA/v8AAP//AAD8/wMA+v8FAPn/BAD8/wAA////////AAD+/wAA/v8AAP7/AAD///////////7/AQD+/wAA/v8BAP3/AgD9/wEA////////AAD/////AQD+/wAAAAD9/wIA/v///wEA/f8BAP////8BAP3/AQD//wAAAAD+/wIA/f8CAP3/AgD+/wEA/v8AAAEA/f8DAP3/AAABAP3/AwD+////AQD+/wEA//8BAP7/AgD9/wIA/////wEA/v8CAP3/AwD9/wEAAAD//wAAAgD8/wQA+/8FAPv/BQD7/wMA/////wEA/v8DAP3/AgD+/wEAAAD//wAAAQD+/wIA/v8BAAAA//8AAAEA//8BAP7/AQAAAAAAAAD//wEA//8CAPz/BAD9/wIA/////wIA/v8BAAAA/v8EAPz/AgD//wAAAQD/////AgD+/wIA/v8BAP//AQD//wAAAAAAAAEA/v8CAP7/AQABAP7/AgD+/wIA/////wMA/P8EAP3/AgD+/wIA//8BAP//AAAAAAEA//8BAA==");

hat = b2a.decode("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m/+V/wEADwESApcBjAF6Af3/j/9kAJIBgAGyAP//2QDYAe0BWwEiADz/6P9jALIAJQGiAbkBSQF0AEwAygA/AO//IQCaAPYABAG2AKMADAGpAc4A1gCQAbQAOQAvAF4AYABgAFoAxgBsAdgBGQBL/zQAaAGTALn+/v5j/xoAAwF+AWMB+QC0AKIAhgAaABUAoQAPASkB9ABpAD0A9f+2/9oAPwG7AMkA6gCsAHL/EwCFAR4C/gFAAWEACAAKAC4AzQAHAQ4BZQGrAKL/Gv9QAFgBUQE3AOL/zgCaASgBVABMAT0ARv87AHYB0gE7AbAAfgCxAIMAhAB7APX/eQBjAeQBeQAh/0D/OABJAZkB/wBVADwApAA8ASkBNADw/24APQFHAR0BzQDv/3EAeAGVASgB0ADdAGgB2QAo/z7/dgC7ASICwQG4AIP/j/9WAJYAiAHJAVEBSwBiACEB2QBMAPP/gwD6AEEBEgFeAIX/R/8lAE4BlAEOAHv/7//d//4A4AGxAdAApwBLAcoAXQCLABYBXgECARYAev/k/0YBHALiAc0Acf8J/+7/vgCOAeABygHCAMn/3v+iAJYB+AG9ACgAdgCgAE8ARABdAV0BrADX/0cAJQGNAXEAp/+v//f/cAC5AGQAEwGlAYUBuQBZANQAxwC8AKoAjwB3AMIAZwFYAecAbgAZAEUAvgDVAKkAfQCuAM8AzgCJAH8A5AB+AVwATP91/3sABAHAAPT/CQC7ANIA4QCwAJoAtP8DAHkBdQF3AU4BMgC1/xQAnQBDAV4BogD4APoAaABEANwAhQHnAE8A+v/Q/6sAYwFeAQ8BigA0AIMAAgFNASQBpgBKAKMAVwAxAJAA7gD+AOYA7ADsALUA+P8x/2n/PAEdAesAiwHTABYA0f/gAN0ASwDWAAABqwAQAPb/UgDfAPcA8AD5APwAAwH2ADUBnAAoANoAnQG3AQYBPgF6APH+zf/kACkBlABXAKYADAEGAZ0ASwDB/y4AOQF6AUEB1wBwAMIAAgF0AOf/FAAkAWABEwFkAEsAAAAAANQAQAEWAagARwAfACcAdgB9AGEAMAE8AbIAQgBcAJcAhgDyAAABhAANATEBwQAxADMAngChABsBLAFAABcAnwA4AfIAnQCcAKMAYgAzAAQBQwH7AFAApgDUAHIAFwBXAOkACwFvAJL/Sv+bAMUBkAFiATMBEwF2AEsAhQCqAH4AXADIAG0BdAGcAFAAZwCJACUBLAG9AGUArAAIAZ0AUQA5AEUAxgAIAc4AOgA+ANgABQHVAG0AkABPAF8ABwHzAGcApv/Z/5oARQH1AM0AsgC7AJoAigDKACABPgEBAQoAeP/v/wQBcwEbATIARAByAOX/bQAEAQQBpAChAOgAqgDXABoB3gB4AHYA3gCJAGYAwgCvAM4ADwHCAIYAjgD0AL8ABgAJ/xb/VACLAXoB8QBaAMH/6f+xAIABSAGSABIAEwCLABIBNQHdAEoAeACxAOgAJAG7AEoANwAUAFQA8wBEAfgAWwAlAKsAFgGnAIkAygA4AUUB8wBkAN0A9wCoALEAmACUAA4BCgGHAIb/9/+cAN0A+gBYAV0BYACo/9D/wgBmAW4BAQEcAM7/WADYAOcApQDZAPMAAAHsAF0ANgAAARgBwQBSAIcA2QAMAdIApQChAOMA7wD6ACoBDAGjAAoASQCeAKMALQA/AKUA5wC/AKAA0QDqALoAWQBQAIwA2QDrAM0AlwCOAJ0ArABxAKkA5ADkAH0AWQCFAJgAkQBsAFsASAC8AFABHAFpALz/cf8aAAUBNgEEAZoAJgBHAMsAJAHwAG4AFAAFATABowDw/10AEAHVAJ4AWgBDAKQAwwB+AIsAhgBjAGsAwAD/AO8AmgBgAFIAtgC8AF0AIQCAACwBIQH2ALYAtACnAKoArgCAAGIAdQD+AOgAWgA0AD4AjwDiANEAlwB/AH4AdgBvAJ8AvgDOANoA6ADKAH4AcwBrACMAGgBMAMIAXwF7ASYBfgBAAGwAfwBlAFgAtQD8ACcBEAF0AP7/4/+IAIwAawClAPMA8ACKAGwAjgDlANkA0QC4AIQAggCTAIgAsADdANYA6wD9APIANQHYACAAr//4/54AvQA3ASkBkAAwAEoA2QCaALMA2AC/ALsAyQDdAM0AtwCeAL8AvACNAK8AxwC+AJcAeQBtAGAAtADzAOwAiwBNAEoAFQAfAHMAFwH7AIoAFACOABIBCQFoAE4A4wDiAMwAmwCGAHwAlACuAIIAPAAdAKEA+ADdAMUAagBHAK4A3gDJAHMAqADEAIsAdQA9ABEAtgAwARIBPAArAKwA/wDOAGQAAwDa/xoApQDLAMMAoQCOAJIApACtAMEAwACKAIkAngCnAK8AlAB/AKYAwADYAMsAtwCXAIAAeQCIAKIAsQCUAG8AbQCIALkAtQCeAIkAqQDDALIAlgB6AHoAjwDIANAA1wDlALkAfQBCAEYAagCYAIYAuADrAJ4AdwBaAHcARwBaAMUADAHgAFUATADDADAB3gBdABcANADFAAgB3gCeAFoAVACqAAsBFQHaAHkAVgCEAKwApgCNAL4A5wDgAN4AxgCeAJIAIQDz/48A5QD1AMMAgQBWAGcApAC/AKgArACQAIgAgwCtAMcAvgBuAJYA+ADlAJoAXACXALoAtgBsAFkAeQC4AL4AowB/AHUAlwC8AIkAcwBPAEsASwCLAO4AkwBLAE4AxADOAKwAnACEAHoAggCVAJAAfACCAKQAzAC+AJsAYwAQAHEA5AD0ALgAewAyAE8AdwCbANgAswBvAGgAiACpAJwAegB2AKEAVgBOAIMAxgDPAKwAkgBgAGcApgCyAKcAlQCkAIwAVgBbAFsAZACaAKkAsgCXAJQAegBcAHgAoQCoAHQAcACOAJ4AegBzAJ0AmwCOAIgA0ADSAJQAZQB6ALAApgC6ALIAjgB+AGgAZgByAKUAtQBwAEUAXwCNANEA5QCkAIYAfwCPAHwAiQCqAMUAzgC5AH0AawCTAOAA8QD+AOsApwBpAEsAiwCLAI0AhgCeAKcAlgCHAG8AWABuAJAAoQB+AKIAvwCiAHcAlADkALsAlwCLAJQAmQCeAIAAagBvAJQAowCYAJQAlQCWAIAALQAgAG8A8ADvAL4AfAB+AF4AFwBZALEA2wDvANIAlgBPAFAAeQCRAHEATQB2AKoAowBtAJAAugCqAHAAagB9AHkAZwCGALgAkABmAHQAnQCkAJQAbgB1AIoApgB+AF0AYACdAM8AzwCPAHgAnAC7AIQAUAB0AMEAxwCXAHAAcgCNAJQAlwCPAMgAugCmAHwAggCjAKUAmQCXAJwAtQCJAE4APgB2AJ8AlQCOAKMA0QCdAIYAgwBdAFUAcQCOALgA0wC8AKMAeQBKAFMAZgBkAJUAsgCtAI4AcABxAIgAlQCpALQAkwCUALEAqQB/AHIAogCuAJAAaABuAJkAnwBtAE0AVwBhAIQAnQCGAJ0AmwB+AF0AZgCLAIgAgAB2AJUAnQCSAKEAngB9ADwASwCIANIAyQCgAHQAbACHAJQAkQB/AHgAjQBrAFAARQB6AKMAuACnAJUAdQB2AHYAbABoAIQAlgCjAK8AoQCIAIQAdgBwAHUAdwBqAIUAkACVAJIAjwCLAIsAiwCGAIgAggCIAJEAfgCHAI4AmQCQAKQAtwCHAHAAdwB8AIkAiwB+AIUAdQBgAJAAjwBoAG4AmQCzAKQApgCOAGIAYgCCAJoArwCtAJkAiQBQAEgAfgCaAI4AfwCRAJMAkAB1AIAAkQCGAHcAeQB+AIcAmgDLAJ0AaABNAFYAegCYAJsAigB7ALMAngB5AFEAdQCZAKQAhABvAG0AjgChAKUAqACKAIkAlAB+AG8AiwCAAH8AbQCXAIIAcgBZAHQAhgBzAIMAlgCvAGAAXgB0AH4AWABbAI0AkACJAGoAcgB8AIEAgwBuAGIAbQCIAIUAigBhAGYAbQBdAFoAdgBiAHQAlgC5AJYAegCHAIgAdgBbAGYAgQCbAKUAigB3AHgAjACMAH0AgACFAIkAewBwAFkAcwB3AGMAiQCCAHMAcACKAIcAZwBSAG8AlgClAJIAaQBoAGIAgQCRAJkAhABqAGUAaQBoAGEAbwCKAKAAlgCJAHUAdgByAGgAbwCDAKEAmQCbAI4AiwBrAF4AcgCYAJkAkACPAI8AfgBkAHYAhwCSAIgAcQBoAGMAagB5AHoAfwB1AGwAaAB5AJIAlgCCAF8AewCSAJUAegBvAGwAcwB8AHkAcwBtAG4AXgBuAHwAkQBvAGsAigCNAI8AcABxAFQAWwByAIAAeQCGAI0AhQCAAGwAcQBzAHQAhgCRAIsAfACAAH4AhAB7AHsAiwBqAEwAXwCFAIMAWwB6AIQAaABVAGgAcwB8AIIAkwCOAIkAjAB1AGQAbQB1AIoAgAB6AGsAbQBvAIcAgwCIAG0AZwBhAGkAcwB4AI8AlACNAHkAawB+AIcAcABqAGwAcwB/AIwAlQB1AF4AXgCBAIkAfgBtAGcAawB2AHQAcgBqAG4AeQB2AHYAXABfAHsAnQCiAIUAWABPAGoAkAB9AGQAWgBUAGkAkQCjAIgAcwBpAHUAcQCDAHYAeQB3AHEAbABoAG4AcgBcAG4AcgBwAGYAXABnAFwAbQCBAIEAeQBoAGIAYABeAFkAaQCIAI8AjQBtAF0AUgBtAHkAcgBpAGAAbwBxAHcAcABmAHMAfABqAGIAbwBvAHUAdACBAGQAXgBZAHUAbQBmAGUAVABfAFwAfAB+AHUAfQByAFsAZQBUAFUAaQB2AH0AcQBsAG4AbQBuAGsAawByAGkAYgBgAGoAdQB4AHgAYwBcAFcAZQByAHEAcABnAGIAcQCGAIgAbABkAGsAZQBxAIkAdwB9AH4AgABvAGQAcwBvAG0AVwBMAFMAbACKAHwAagBaAGcAbwBiAGoAYgBcAFIAaQB4AHoAdQBoAGQAcwB9AHQAbgB5AH4AawBoAGgAcQB+AIUAbgBZAFEAYwBmAHEAcwB6AG4AbABmAGwAaQBfAGcAdgB5AHsAewB4AGoAYQBXAGsAaQBcAGYAZwBhAGQAXwBqAG0AdAB1AGkAXgBnAGsAawBwAHYAbQBqAFoAbwBqAG0AbQBbAFsAXQBwAHMAbABkAHMAbwByAGgAbwBvAGwAcQBvAHEAbwBxAGgAXABfAGcAeQBvAGMAYwBcAGQAcgBtAF0AUwBXAGoAbgBlAGAAbABsAG4AWABkAGYAbwByAHEAcgBdAGgAbAB8AHEAZQBlAGUAbwByAHAAawBqAHIAZgBjAFkAYABgAHAAdQB2AHYAaQBgAF0AaABfAG4AcgBtAFoAXQBjAHgAbABoAGwAWwBcAFkAbABvAGwAZgBmAGgAbQBwAHMAaQBZAFkAcgB6AGoAawBkAGsAbgBtAGoAWQBXAFgAZwBlAGsAagBhAF0AWQBpAGIAbgBuAHIAWgBMAE8AZQBqAHEAeQBvAGYAYwBfAFgAUgBcAGwAbABgAFUATABPAFkAXwBoAGIAVQBeAF4AZwBjAG0AcwBpAGkAXABmAFAAYABqAHIAbABeAE4ATwBnAGMAbQBmAGEASwBCAD0ASQBUAHEAgQBuAFEATQBgAG0AaABoAF0AWQBSAFIAUgBbAGQAbgBrAGQAVQBiAF4AYgBeAHcAaABcAFYAZgBzAF4AWABPAGAAYQBXAEoAVABpAHAAZQBZAFUAWABaAFgAawB8AHsAZABRAFYAZQBuAG0AZQBjAFoASAA9AEYAXABqAF4AVQBcAF4AXgBVAHAAcwByAHYAZgBYAF4AVgBuAHAAZwBhAF4AVQBUAGsAdgBmAFQAWABlAF8ASgBiAE0AVgBcAFoATwBCAEwAVABdAF8AVQBRAE8AUABiAFIAVQBOAFcAYgBYAFYAQgBNAEkAVQBVAFgAXwBSAF0AUgBaAFQAUQBVAFYAVABeAGEAXwBSAFkAXABfAFIAUwBVAF8AWgBXAE4AVABUAF0AVgBdAFMAVABKAFUAWABeAFcAWQBRAF0AWQBUAFsAUwBWAFEAWABVAFUASQBRAFYAWQBhAF4AVQBVAFsAXgBaAFMAUQBMAFkAWgBaAFMAUABUAFMAXgBVAFkAWwBYAFEAWQBYAF0AWgBXAEkATABNAEoAVQBOAEoARgBNAE8AUQBXAF4AWgBXAE8AWQBaAFkAWABNAFQASwBdAEkAVQBXAFwAXQBPAEcAQgBLAE4AWwBRAFoASgBUAEIAUgBPAGAAXgBQAE4ASABQAFYAWQBYAFYASgBLAEIAWwBXAFIAUwBFAFYATABWAE4AWQBYAFoAVQBSAFoATQBUAE4AUgBVAFUATQBaAFYAXgBTAFYAUwBKAEoASQBSAFMATQBRAEsASABJAEoASQBHAEsAVQBPAFkASABMAE8ATwBQAE0ATwBMAEwAVwBPAFMAVABMAFIATwBYAEoAUgBPAF0AUgBPAE0AUgBKAFUASwBSAEYATgBZAFoAWgBLAFAAUABdAFIAUABOAEwASwBGAEsAQABBAEUARwBJAEwAUwBQAE8ATQBGAEkASABKAFEAVwBIAEUAUABIAFEASwBVAEQAUwBIAFkAVwBSAFQASwBNAEYARwBHAE0AQABIAEIASAA+AEcARgBMAEkAUwBPAEsARQA+AEoARgBXAEIASQA/AEIAQAA/AEgASQBTAFEASQBAAD4ATwBWAFEAVABIAEYAOwA5ADoAPQBDAEIAQwBQAE4ATwBIAEMASwBIAEgAOAA8ADoAQABDAEUAQgBFADgAOABEAEcATQBEAEYAQgBGAEkAOQBBAEAASABBAD4ARABEAEoAUgBNAFQATgBVAEcATQBHAEgAUgBIAEcAOwBDAEgAQgA/AEIARQBXAD0ARAA5AEwAQQBWAFEASwA9AEMARwBSAFYARgA+ADYAPQBAAEwATwBMAEAAQwA9AEYAUABNAEoARQA9AD8APwBBAEkATABMAEEAPwBGADwAQQBCAEkAQwBHAEgATAA9ADsAPQA9AD4ASABFAEAAPABIAEcASQBLAEoARABFADoARABDAEwAUgBKAEoAQwBEAEEASgBNAEwARAA/AEAAQQBKAEYARQBDAEQARgBIAEkAPwA7AEkARQBGAEYATAA/AEUARgBCAEUAQABIAD0ARgA+AEEAPwBFAEQAPAA6ADoAPwBJAFMARwBEAEAAQwBEAEIARABGAD4ARwBCADwAQwBGAEsASQBDAEoAQABCAEYAQQA9ADoARwA/AEQAOQA3AD8APgBGAEEAQgBDAD0ARgBEAEgARgBAAE8APwBDAD0AQwBCADwAOABCADwARgBEAEMAQAA9AEEAPAA+ADkAQwA9AD0AQABEAEAARwA4AEAAOwBAADwARABEAD8APQBAAD0APQA8ADoAPwA5AD8AQQBCAEAAPQBFAEsATABDADoANgA7ADEAOwAxADMANwA7ADgAOAA6ADsANQBDADkAQQAxAD4ANwAzADsAPgBCAEAAPAAzADkAMgA1ADQAPAA6AD4AQwBDAEQAQgA/AEAANQA1AC0AOQAxAC4AMQAwADoANgA9ADkAOgA5ADkANQA+ADsAQQBGAEAAQgA/ADwAMwAzAC4AOAAyADwAMQA4ADoAOAA3ADsANwA+ADcAPAA9ADwAMgAyAD4ARABLAEEATQA/AEIAQABDAD8AQQA/AD8AOwA8ADgAOgA8ADoANAA8AC0ANwA2ADUAOQAzADgAOgA/AD0ANgA8AEMAOQBBAEAAPQA5ADMAPwA6AEQAPwBDADwAQAA6AEAAPwA5ADUAMgAuACkAKAA2ADAANQApAC4AKQAwADYALgAxACoALwArADQAKgAvADIALgAvADAAKgAzAC8ANAArACoALAAtADAAKgArACoALgAsADEAMQAuADAAOAA1AEcANQA5AC4AOQAyADYAMAAyADAAOQA1ADYANAAvADUAMQA2AC8AKwAxACsANQAyAC4ANQA1ADoALAAqACoAMQApACsAMwAxADIAMwAxADUANAA5ADYALgAwAC0AKgAyADYALAAtACkALwAyADUAMgA3ADEANAAkACUAJgAyACsAKgArACUALwAqADMAMAAyACwAJwArAC4AKAAyACsAKgApADAALAA5AC8AMwAvADkALQAtACAALQAqAC4AKgA4ADAAKwAlAB8AIQAqACwAJwAmAC0AKwAwADAAHQAoACsALQAtADAAKwAsACkAKgAyAC0AMQA0AC8AMQAoAC0ANQAyAC8ALQArACwALgAlAC0AJQAwAC4AMgAwADgALQAuACAALgAuACkAJwAoACEAMAApACoALgAzACoAKgAsACwAKAAmACsAGQAmACYALwAqACgALgAqACcANAAnAC8ALgA1ADQANAAzACoAKAAjACEAIwAhAB4AIQAlACwALAAsAC4AJgAnACoAJwAmACoAJAAqACgAJAAmACQAJgAwACsALQAzACwALgAjACcAIwAhACIAIAAkACIAHAAbACEAIAAUAB8AJQAhACYAIwArAB4AIQAeADAAKQAvACYALgArACkAJQAgAB0AIQAgACMAHwAmACQALAAnACcAIAAeACEAIgAhABwAIgAgACUAIwAfACIAHgAlACIAIgAXACAAHQAfABgAIQAqAC0AKwAmACcAIgAnACQAKAAkACkAKgAjACQAHAAlACIAHgAXABcAFQAWABQAFQAQABQAEwAZABgAHQAdAB0AEAAYABYAHQAYACMAIQAoABsAIgAbACEAGAAgAB0AIwAiAB8AGQAhABsAIQAeACIAIwAfABoAHQAcACEAHQAcABwAHwAeABwAHwAbABYAFgAdABYAIgAfACUAGgAkACMAIAAeABwAGQAjAB0AJAAaACAAIgAmACAAHwATABwAGwAeABoAFQAcABcAGAAWABUAGQAXABIAGAAZABsAGgAXABoAFQAdABcAGgAWABMAEgAaABgAFgAUABEAFQATABMADgATABIAGAAVABoAEQAWABUAGgAWAB0AEwAaABYAGgAYABYAGAATABcADwAZABMAGgAUABgAEgAVAA0AFQAOABQADgAWABAAFQARABYAFQAUABYADwAPABAAEgAaABQAEAAPAA8ADgARAA0AEwAPABcADgAZAA0AGAARABgADwAWABAAHQARABMACgANABMADgAVAAoAEQASAAsADAAQABMAFQAPABQADQASAAgAEAAKABEAEAANABEADQATABEAEQALAAsAEwALABkADQAcAAsAEwAJABQADAAUAAoAEAAPAAwADQADAA4ACgAJAA8ABAAMAAoADQAPAAkADAATAAgADwAHABMADwANAAwACwALAAoADQAMAA4ACwAPAAsAEgAJAA0ABQAPAAoADQAIAAoADQALAA0ACgAIAA0ACAANAAwABwANAAsADgAJAAkACgAGAAwACQAIAAsABwAPAAcADwAMAAwACQAIAAgABwAFAAgACgAIAAsACQALAAsACQALAAkACwAIAAcACwAHAAsABQAMAAoADAAJAAkACgAJAAwABgAKAAcACwAKAA8ACQAMAAUABwAGAAQACQAFAAgABwAHAAoABwAKAAMABwAFAAcACgACAAcAAwAJAAcACAAHAAQACAAJAAcACAAHAAUACQAGAAcACAAJAAgACAAHAAUABwADAAoAAQAJAAIACQADAAgABgAHAAYABQAEAAUABgAGAAUABwAFAAgABAAHAAQABwAEAAQABAAFAAQABQAEAAEABQACAAMAAgABAAMAAQADAAIAAgACAAIAAgADAAEAAgACAAAAAgABAAIAAAAFAAAAAwAEAP7/BgD//wUAAAACAAEAAQADAAEAAQAFAPz/BwD9/wQAAAABAAAAAgAAAAMA/v8GAPv/BgD+/wEAAgD//wAAAgAAAAMA/f8EAP3/BAAAAAAAAgAAAAEAAQABAP//AwD9/wQA/f8DAP7/AgD+/wIA//8AAAEA//8BAAAA/v8=");

async.parallel({
  bass: function(cb) {
    return decoder.decodeAudioData(bass, function(buffer) {
      return cb(null, buffer);
    });
  },
  kick: function(cb) {
    return decoder.decodeAudioData(kick, function(buffer) {
      return cb(null, buffer);
    });
  },
  snare: function(cb) {
    return decoder.decodeAudioData(snare, function(buffer) {
      return cb(null, buffer);
    });
  },
  hat: function(cb) {
    return decoder.decodeAudioData(hat, function(buffer) {
      return cb(null, buffer);
    });
  }
}, function(err, results) {
  var cb, _i, _len, _results;
  data = {
    _id: cuid(),
    bpm: 120,
    playing: false,
    recording: false,
    position: 0,
    tracks: [
      {
        _id: cuid(),
        name: 'Analog Synth',
        meterLevel: 0,
        sequence: {
          _id: cuid(),
          loopSize: 8,
          notes: sequences.terje
        },
        effects: [],
        instrument: {
          _id: cuid(),
          _type: 'AnalogSynthesizer',
          level: 1,
          pan: 0.5,
          polyphony: 3,
          maxPolyphony: 6,
          volumeEnv: {
            a: 0,
            d: 0.25,
            s: 0,
            r: 0.5
          },
          filterEnv: {
            a: 0,
            d: 0.25,
            s: 0.2,
            r: 0.5
          },
          filter: {
            type: 'LP',
            freq: 0.27,
            res: 0.05,
            env: 0.45
          },
          osc1: {
            waveform: 'saw',
            level: 0.5,
            pitch: 0.5,
            tune: 0.5
          },
          osc2: {
            waveform: 'saw',
            level: 0.5,
            pitch: 0.5,
            tune: 0.5
          }
        }
      }, {
        _id: cuid(),
        name: 'Drum Synthesizer',
        meterLevel: 0,
        sequence: {
          _id: cuid(),
          loopSize: 4,
          notes: {}
        },
        effects: [],
        instrument: {
          _id: cuid(),
          _type: 'DrumSynthesizer',
          level: 0.5,
          pan: 0.5,
          drums: [
            {
              id: 1,
              key: 0,
              name: 'Kick',
              level: 1,
              hp: 0,
              decay: 0.35,
              noise: 0.001,
              pitch: 0,
              bend: 0.39,
              fm: 1,
              fmDecay: 0.05,
              fmFreq: 0.02
            }, {
              id: 2,
              key: 1,
              name: 'Snare',
              level: 0.5,
              hp: 0.22,
              decay: 0.1,
              noise: 0.8,
              pitch: 0.1,
              bend: 0,
              fm: 0,
              fmDecay: 0,
              fmFreq: 0
            }, {
              id: 3,
              key: 2,
              name: 'HH1',
              level: 0.05,
              hp: 1,
              decay: 0.07,
              noise: 0.8,
              pitch: 0.4,
              bend: 0,
              fm: 1,
              fmDecay: 0.4,
              fmFreq: 0
            }, {
              id: 4,
              key: 3,
              name: 'HH2',
              level: 0.2,
              hp: 0.6,
              decay: 0.22,
              noise: 1,
              pitch: 0.5,
              bend: 0,
              fm: 0,
              fmDecay: 0,
              fmFreq: 0
            }
          ]
        }
      }
    ]
  };
  _results = [];
  for (_i = 0, _len = callbacks.length; _i < _len; _i++) {
    cb = callbacks[_i];
    _results.push(cb(data));
  }
  return _results;
});



},{"./dsp/global_context":5,"./sequences":22,"async":71,"base64-arraybuffer":72,"cuid":76}],3:[function(require,module,exports){
var AudioRecorder, context, workerScript;

context = require('./global_context');

workerScript = URL.createObjectURL(new Blob([
  '(', (function(window) {
    var buffers, clear, getSampleData, length, record;
    buffers = [];
    length = 0;
    record = function(inputBuffer) {
      buffers.push(inputBuffer);
      return length += inputBuffer.length;
    };
    clear = function() {
      buffers = [];
      return length = 0;
    };
    getSampleData = function() {
      var buffer, i, max, offset, sampleData, v, value, _i, _j, _k, _len, _len1, _len2;
      sampleData = new Float32Array(length);
      offset = 0;
      for (_i = 0, _len = buffers.length; _i < _len; _i++) {
        buffer = buffers[_i];
        sampleData.set(buffer, offset);
        offset += buffer.length;
      }
      max = -Infinity;
      for (i = _j = 0, _len1 = sampleData.length; _j < _len1; i = ++_j) {
        value = sampleData[i];
        v = Math.abs(value);
        if (v > max) {
          max = v;
        }
      }
      for (i = _k = 0, _len2 = sampleData.length; _k < _len2; i = ++_k) {
        value = sampleData[i];
        sampleData[i] = value / max;
      }
      return window.postMessage(sampleData);
    };
    return window.onmessage = function(e) {
      switch (e.data.command) {
        case 'record':
          return record(e.data.buffer);
        case 'clear':
          return clear();
        case 'getSampleData':
          return getSampleData();
      }
    };
  }).toString(), ')(this)'
], {
  type: 'application/javascript'
}));

module.exports = AudioRecorder = (function() {
  function AudioRecorder(input) {
    this.input = input;
    this.recorder = context.createScriptProcessor(4096, 1, 1);
    this.recording = false;
    this.worker = new Worker(workerScript);
    this.recorder.onaudioprocess = (function(_this) {
      return function(e) {
        if (!_this.recording) {
          return;
        }
        return _this.worker.postMessage({
          command: 'record',
          buffer: e.inputBuffer.getChannelData(0)
        });
      };
    })(this);
    this.worker.onmessage = (function(_this) {
      return function(e) {
        if (typeof _this.currentCallback === "function") {
          _this.currentCallback(e.data);
        }
        return _this.currentCallback = null;
      };
    })(this);
    this.input.connect(this.recorder);
    this.recorder.connect(context.destination);
  }

  AudioRecorder.prototype.record = function() {
    this.recording = true;
    return this;
  };

  AudioRecorder.prototype.stop = function() {
    this.recording = false;
    return this;
  };

  AudioRecorder.prototype.clear = function() {
    this.worker.postMessage({
      command: 'clear'
    });
    return this;
  };

  AudioRecorder.prototype.getSampleData = function(callback) {
    this.currentCallback = callback;
    this.worker.postMessage({
      command: 'getSampleData'
    });
    return this;
  };

  return AudioRecorder;

})();



},{"./global_context":5}],4:[function(require,module,exports){
var minEnvValue;

minEnvValue = 0.01;

module.exports = function(env, note, time) {
  var a, d, elapsed, l, r, s;
  elapsed = time - note.time;
  a = Math.max(minEnvValue, env.a);
  d = Math.max(minEnvValue, env.d);
  s = env.s;
  r = Math.max(minEnvValue, env.r);
  l = elapsed > a + d ? l = s : elapsed > a ? l = s + (1 - s) * (a + d - elapsed) / d : elapsed / a;
  if (elapsed > note.len) {
    l = l * (r + note.len - elapsed) / r;
  }
  return Math.max(0, l);
};



},{}],5:[function(require,module,exports){
module.exports = new (window.webkitAudioContext || window.AudioContext);



},{}],6:[function(require,module,exports){
var A, bandwidth, beta, dbGain, e, maxFreq, sampleRate, sinh, tau;

sampleRate = 48000;

maxFreq = 12000;

dbGain = 12;

bandwidth = 1;

A = Math.pow(10, dbGain / 40);

e = Math.log(2);

tau = 2 * Math.PI;

beta = Math.sqrt(2 * A);

sinh = function(x) {
  var y;
  y = Math.exp(x);
  return (y - 1 / y) / 2;
};

module.exports = function() {
  var a0, a1, a2, a3, a4, alpha, cs, freq, lastCutoff, omega, sn, x1, x2, y1, y2;
  a0 = a1 = a2 = a3 = a4 = x1 = x2 = y1 = y2 = 0;
  freq = omega = sn = alpha = 0;
  cs = 1;
  lastCutoff = 0;
  return function(sample, cutoff) {
    var aa0, aa1, aa2, b0, b1, b2, oldCutoff, result, s;
    if (cutoff !== lastCutoff) {
      oldCutoff = cutoff;
      freq = cutoff * maxFreq;
      omega = tau * freq / sampleRate;
      sn = Math.sin(omega);
      cs = Math.cos(omega);
      alpha = sn * sinh(e / 2 * bandwidth * omega / sn);
      b0 = (1 + cs) / 2;
      b1 = -(1 + cs);
      b2 = (1 + cs) / 2;
      aa0 = 1 + alpha;
      aa1 = -2 * cs;
      aa2 = 1 - alpha;
      a0 = b0 / aa0;
      a1 = b1 / aa0;
      a2 = b2 / aa0;
      a3 = aa1 / aa0;
      a4 = aa2 / aa0;
    }
    s = Math.max(-1, Math.min(1, sample));
    result = a0 * s + a1 * x1 + a2 * x2 - a3 * y1 - a4 * y2;
    x2 = x1;
    x1 = s;
    y2 = y1;
    y1 = result;
    return result;
  };
};



},{}],7:[function(require,module,exports){
module.exports = function(sampleData, transpose, samplesElapsed, offset, loopActive, loopPoint) {
  var i, i1, i2, l;
  if (offset == null) {
    offset = 0;
  }
  if (loopActive == null) {
    loopActive = false;
  }
  i = samplesElapsed * Math.pow(2, transpose / 12);
  i1 = Math.floor(i);
  if (loopActive) {
    i1 = i1 % (loopPoint - offset);
  }
  i2 = i1 + 1;
  l = i % 1;
  return sampleData[offset + i1] * (1 - l) + sampleData[offset + i2] * l;
};



},{}],8:[function(require,module,exports){
var sampleRate;

sampleRate = 48000;

module.exports = function() {
  var k, oldx, oldy1, oldy2, oldy3, p, r, t1, t2, x, y1, y2, y3, y4;
  y1 = y2 = y3 = y4 = oldx = oldy1 = oldy2 = oldy3 = 0;
  p = k = t1 = t2 = r = x = null;
  return function(sample, cutoff, res) {
    var freq;
    freq = 20 * Math.pow(10, 3 * cutoff);
    freq = freq / sampleRate;
    p = freq * (1.8 - (0.8 * freq));
    k = 2 * Math.sin(freq * Math.PI / 2) - 1;
    t1 = (1 - p) * 1.386249;
    t2 = 12 + t1 * t1;
    r = res * 0.57 * (t2 + 6 * t1) / (t2 - 6 * t1);
    x = sample - r * y4;
    y1 = x * p + oldx * p - k * y1;
    y2 = y1 * p + oldy1 * p - k * y2;
    y3 = y2 * p + oldy2 * p - k * y3;
    y4 = y3 * p + oldy3 * p - k * y4;
    y4 -= (y4 * y4 * y4) / 6;
    oldx = x;
    oldy1 = y1;
    oldy2 = y2;
    oldy3 = y3;
    return y4;
  };
};



},{}],9:[function(require,module,exports){
var tau;

tau = Math.PI * 2;

module.exports = {
  sine: function(time, frequency) {
    return Math.sin(time * tau * frequency);
  },
  square: function(time, frequency) {
    if (((time % (1 / frequency)) * frequency) % 1 > 0.5) {
      return 1;
    } else {
      return -1;
    }
  },
  saw: function(time, frequency) {
    return 1 - 2 * (((time % (1 / frequency)) * frequency) % 1);
  },
  noise: function() {
    return 2 * Math.random() - 1;
  }
};



},{}],10:[function(require,module,exports){
module.exports = function(decay, elapsed) {
  if (elapsed > decay) {
    return 0;
  } else {
    return 1 - elapsed / decay;
  }
};



},{}],11:[function(require,module,exports){
var bufferSize;

bufferSize = 4096;

module.exports = function(context, fn) {
  var Context, bufferStartAbsolute, bufferStartRelative, self;
  if (typeof context === 'function') {
    Context = window.AudioContext || window.webkitAudioContext;
    if (!Context) {
      throw new Error('AudioContext not supported');
    }
    fn = context;
    context = new Context();
  }
  self = context.createScriptProcessor(bufferSize, 1, 1);
  self.fn = fn;
  self.i = self.t = 0;
  self.sampleRate = context.sampleRate;
  self.duration = Infinity;
  self.playing = false;
  bufferStartAbsolute = null;
  bufferStartRelative = null;
  self.onaudioprocess = function(e) {
    var i, output, _i;
    bufferStartAbsolute = Date.now();
    bufferStartRelative = self.t;
    output = e.outputBuffer.getChannelData(0);
    for (i = _i = 0; 0 <= bufferSize ? _i < bufferSize : _i > bufferSize; i = 0 <= bufferSize ? ++_i : --_i) {
      self.t = self.i / self.sampleRate;
      self.i += 1;
      output[i] = self.fn(self.t, self.i);
    }
    return output;
  };
  self.getTime = function() {
    if (bufferStartRelative != null) {
      return bufferStartRelative + (Date.now() - bufferStartAbsolute) / 1000;
    } else {
      return self.t;
    }
  };
  self.seek = function(time) {
    bufferStartAbsolute = null;
    bufferStartRelative = null;
    self.i = Math.floor(time * self.sampleRate);
    return self.t = time;
  };
  self.play = function(opts) {
    if (self.playing) {
      return;
    }
    self.connect(self.context.destination);
    self.playing = true;
    return setTimeout((function() {
      return this.node.disconnect();
    }), 100000000000);
  };
  self.stop = function() {
    bufferStartAbsolute = null;
    bufferStartRelative = null;
    self.playing = false;
    return self.disconnect();
  };
  self.reset = function() {
    return self.i = self.t = 0;
  };
  return self;
};



},{}],12:[function(require,module,exports){
var AnalogSynthesizer, Instrument, RingBuffer, envelope, highpassFilter, lowpassFilter, oscillators,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Instrument = require('./instrument');

RingBuffer = require('../util/ring_buffer');

lowpassFilter = require('../dsp/lowpass_filter');

highpassFilter = require('../dsp/highpass_filter');

envelope = require('../dsp/envelope');

oscillators = require('../dsp/oscillators');

module.exports = AnalogSynthesizer = (function(_super) {
  var frequency, tune;

  __extends(AnalogSynthesizer, _super);

  function AnalogSynthesizer() {
    return AnalogSynthesizer.__super__.constructor.apply(this, arguments);
  }

  AnalogSynthesizer.defaults = {
    _type: 'AnalogSynthesizer',
    level: 0.5,
    pan: 0.5,
    polyphony: 3,
    maxPolyphony: 6,
    volumeEnv: {
      a: 0,
      d: 0.25,
      s: 0,
      r: 0.5
    },
    filterEnv: {
      a: 0,
      d: 0.25,
      s: 0.2,
      r: 0.5
    },
    filter: {
      type: 'LP',
      freq: 0.27,
      res: 0.05,
      env: 0.45
    },
    osc1: {
      waveform: 'saw',
      level: 0.5,
      pitch: 0.5,
      tune: 0.5
    },
    osc2: {
      waveform: 'saw',
      level: 0.5,
      pitch: 0.5,
      tune: 0.5
    }
  };

  AnalogSynthesizer.createState = function(instrument) {
    var i;
    AnalogSynthesizer.__super__.constructor.createState.call(this, instrument);
    return this.state[instrument._id].filters = {
      LP: (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = instrument.maxPolyphony; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(lowpassFilter());
        }
        return _results;
      })(),
      HP: (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = instrument.maxPolyphony; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(highpassFilter());
        }
        return _results;
      })(),
      none: (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = instrument.maxPolyphony; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(function(sample) {
            return sample;
          });
        }
        return _results;
      })()
    };
  };

  tune = 440;

  frequency = function(key) {
    return tune * Math.pow(2, (key - 69) / 12);
  };

  AnalogSynthesizer.sample = function(instrument, time, i) {
    var r;
    if (this.state.level === 0) {
      return 0;
    }
    if (this.state[instrument._id] == null) {
      return 0;
    }
    r = Math.max(0.01, instrument.volumeEnv.r);
    return instrument.level * this.state[instrument._id].notes.reduce((function(_this) {
      return function(memo, note, index) {
        var cutoff, filter, osc1Freq, osc2Freq, sample;
        if (note == null) {
          return memo;
        }
        if (!(note.len + r > time - note.time)) {
          return memo;
        }
        osc1Freq = frequency(note.key + instrument.osc1.tune - 0.5 + Math.round(24 * (instrument.osc1.pitch - 0.5)));
        osc2Freq = frequency(note.key + instrument.osc2.tune - 0.5 + Math.round(24 * (instrument.osc2.pitch - 0.5)));
        sample = envelope(instrument.volumeEnv, note, time) * (instrument.osc1.level * oscillators[instrument.osc1.waveform](time, osc1Freq) + instrument.osc2.level * oscillators[instrument.osc2.waveform](time, osc2Freq));
        cutoff = Math.min(1, instrument.filter.freq + instrument.filter.env * envelope(instrument.filterEnv, note, time));
        filter = _this.state[instrument._id].filters[instrument.filter.type][index];
        sample = filter(sample, cutoff, instrument.filter.res);
        return memo + sample;
      };
    })(this), 0);
  };

  return AnalogSynthesizer;

})(Instrument);



},{"../dsp/envelope":4,"../dsp/highpass_filter":6,"../dsp/lowpass_filter":8,"../dsp/oscillators":9,"../util/ring_buffer":68,"./instrument":16}],13:[function(require,module,exports){
var BasicSampler, Instrument, RingBuffer, envelope, highpassFilter, linearInterpolator, logSample, lowpassFilter,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Instrument = require('./instrument');

RingBuffer = require('../util/ring_buffer');

linearInterpolator = require('../dsp/linear_interpolator');

lowpassFilter = require('../dsp/lowpass_filter');

highpassFilter = require('../dsp/highpass_filter');

envelope = require('../dsp/envelope');

logSample = require('../util/log_sample');

module.exports = BasicSampler = (function(_super) {
  __extends(BasicSampler, _super);

  function BasicSampler() {
    return BasicSampler.__super__.constructor.apply(this, arguments);
  }

  BasicSampler.defaults = {
    _type: 'BasicSampler',
    level: 0.5,
    pan: 0.5,
    polyphony: 1,
    maxPolyphony: 6,
    rootKey: 60,
    sampleData: null,
    sampleName: '',
    start: 0.3,
    loopActive: 'loop',
    loop: 0.7,
    tune: 0.5,
    volumeEnv: {
      a: 0,
      d: 0.25,
      s: 1,
      r: 0.5
    },
    filterEnv: {
      a: 0,
      d: 0.25,
      s: 1,
      r: 0.5
    },
    filter: {
      type: 'none',
      freq: 0.27,
      res: 0.05,
      env: 0.45
    }
  };

  BasicSampler.createState = function(instrument) {
    var i;
    BasicSampler.__super__.constructor.createState.call(this, instrument);
    return this.state[instrument._id].filters = {
      LP: (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = instrument.maxPolyphony; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(lowpassFilter());
        }
        return _results;
      })(),
      HP: (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = instrument.maxPolyphony; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(highpassFilter());
        }
        return _results;
      })(),
      none: (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = instrument.maxPolyphony; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(function(sample) {
            return sample;
          });
        }
        return _results;
      })()
    };
  };

  BasicSampler.sample = function(instrument, time, i) {
    var r;
    if (instrument.level === 0) {
      return 0;
    }
    if (this.state[instrument._id] == null) {
      return 0;
    }
    if (instrument.sampleData == null) {
      return 0;
    }
    r = Math.max(0.01, instrument.volumeEnv.r);
    return instrument.level * this.state[instrument._id].notes.reduce((function(_this) {
      return function(memo, note, index) {
        var cutoff, filter, loopPoint, offset, sample, samplesElapsed, transpose;
        if (note == null) {
          return memo;
        }
        if (!(note.len + r > time - note.time)) {
          return memo;
        }
        transpose = note.key - instrument.rootKey + instrument.tune - 0.5;
        samplesElapsed = i - note.i;
        offset = Math.floor(instrument.start * instrument.sampleData.length);
        loopPoint = Math.floor(instrument.loop * instrument.sampleData.length);
        sample = linearInterpolator(instrument.sampleData, transpose, samplesElapsed, offset, instrument.loopActive === 'loop', loopPoint);
        sample = envelope(instrument.volumeEnv, note, time) * (sample || 0);
        cutoff = Math.min(1, instrument.filter.freq + instrument.filter.env * envelope(instrument.filterEnv, note, time));
        filter = _this.state[instrument._id].filters[instrument.filter.type][index];
        sample = filter(sample, cutoff, instrument.filter.res);
        return memo + sample;
      };
    })(this), 0);
  };

  return BasicSampler;

})(Instrument);



},{"../dsp/envelope":4,"../dsp/highpass_filter":6,"../dsp/linear_interpolator":7,"../dsp/lowpass_filter":8,"../util/log_sample":66,"../util/ring_buffer":68,"./instrument":16}],14:[function(require,module,exports){
var DrumSampler, Instrument, envelope, linearInterpolator, logSample,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Instrument = require('./instrument');

envelope = require('../dsp/envelope');

linearInterpolator = require('../dsp/linear_interpolator');

logSample = require('../util/log_sample');

module.exports = DrumSampler = (function(_super) {
  __extends(DrumSampler, _super);

  function DrumSampler() {
    return DrumSampler.__super__.constructor.apply(this, arguments);
  }

  DrumSampler.defaults = {
    _type: 'DrumSampler',
    level: 0.5,
    pan: 0.5,
    drums: [
      {
        name: 'Drum 1',
        sampleData: null,
        sampleName: '',
        transpose: 0,
        level: 1,
        start: 0,
        key: 0,
        volumeEnv: {
          a: 0,
          d: 1,
          s: 1,
          r: 1
        }
      }
    ]
  };

  DrumSampler.defaultDrum = function(drums) {
    return {
      name: "Drum " + (drums.length + 1),
      sampleData: null,
      sampleName: '',
      transpose: 0,
      level: 1,
      start: 0,
      key: (function(_this) {
        return function() {
          var key;
          key = 0;
          while (drums.some(function(drum) {
              return drum.key === key;
            })) {
            key += 1;
          }
          return key;
        };
      })(this)(),
      volumeEnv: {
        a: 0,
        d: 1,
        s: 1,
        r: 1
      }
    };
  };

  DrumSampler.createState = function(instrument) {
    return this.state[instrument._id] = {
      notes: {}
    };
  };

  DrumSampler.sample = function(instrument, time, i) {
    if (instrument.level === 0) {
      return 0;
    }
    if (this.state[instrument._id] == null) {
      return 0;
    }
    return instrument.level * instrument.drums.reduce((function(_this) {
      return function(memo, drum) {
        var note, offset, sample, samplesElapsed;
        if (drum.sampleData == null) {
          return memo;
        }
        note = _this.state[instrument._id].notes[drum.key];
        if (note == null) {
          return memo;
        }
        samplesElapsed = i - note.i;
        offset = Math.floor(drum.start * drum.sampleData.length);
        if (samplesElapsed + offset > drum.sampleData.length) {
          return memo;
        }
        sample = linearInterpolator(drum.sampleData, drum.transpose, samplesElapsed, offset);
        return memo + drum.level * envelope(drum.volumeEnv, note, time) * (sample || 0);
      };
    })(this), 0);
  };

  DrumSampler.tick = function(instrument, time, i, beat, bps, notesOn) {
    if (this.state[instrument._id] == null) {
      this.createState(instrument);
    }
    return notesOn.forEach((function(_this) {
      return function(note) {
        return _this.state[instrument._id].notes[note.key] = {
          time: time,
          i: i,
          len: note.length / bps
        };
      };
    })(this));
  };

  return DrumSampler;

})(Instrument);



},{"../dsp/envelope":4,"../dsp/linear_interpolator":7,"../util/log_sample":66,"./instrument":16}],15:[function(require,module,exports){
var DrumSynthesizer, Instrument, cuid, highpassFilter, logSample, oscillators, simpleEnvelope,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Instrument = require('./instrument');

highpassFilter = require('../dsp/highpass_filter');

simpleEnvelope = require('../dsp/simple_envelope');

oscillators = require('../dsp/oscillators');

logSample = require('../util/log_sample');

cuid = require('cuid');

module.exports = DrumSynthesizer = (function(_super) {
  var freqScale, maxFreq, minFreq;

  __extends(DrumSynthesizer, _super);

  function DrumSynthesizer() {
    return DrumSynthesizer.__super__.constructor.apply(this, arguments);
  }

  minFreq = 60;

  maxFreq = 3000;

  freqScale = maxFreq - minFreq;

  DrumSynthesizer.defaults = {
    level: 0.5,
    pan: 0.5,
    drums: [
      {
        key: 0,
        name: 'Kick',
        level: 1,
        hp: 0,
        decay: 0.35,
        noise: 0.001,
        pitch: 0,
        bend: 0.39,
        fm: 1,
        fmDecay: 0.05,
        fmFreq: 0.02
      }, {
        key: 1,
        name: 'Snare',
        level: 0.5,
        hp: 0.22,
        decay: 0.1,
        noise: 0.8,
        pitch: 0.1,
        bend: 0,
        fm: 0,
        fmDecay: 0,
        fmFreq: 0
      }, {
        key: 2,
        name: 'HH1',
        level: 0.05,
        hp: 1,
        decay: 0.07,
        noise: 0.8,
        pitch: 0.4,
        bend: 0,
        fm: 1,
        fmDecay: 0.4,
        fmFreq: 0
      }, {
        key: 3,
        name: 'HH2',
        level: 0.2,
        hp: 0.6,
        decay: 0.22,
        noise: 1,
        pitch: 0.5,
        bend: 0,
        fm: 0,
        fmDecay: 0,
        fmFreq: 0
      }
    ]
  };

  DrumSynthesizer.defaultDrum = function(drums) {
    return {
      key: (function(_this) {
        return function() {
          var key;
          key = 0;
          while (drums.some(function(drum) {
              return drum.key === key;
            })) {
            key += 1;
          }
          return key;
        };
      })(this)(),
      name: "Drum " + (drums.length + 1),
      level: 0.5,
      hp: 0,
      decay: 0.5,
      noise: 0.5,
      pitch: 0.5,
      bend: 0,
      fm: 0,
      fmDecay: 0,
      fmFreq: 0
    };
  };

  DrumSynthesizer.createState = function(instrument) {
    var i;
    return this.state[instrument._id] = {
      notes: {},
      filters: (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; _i < 127; i = ++_i) {
          _results.push(highpassFilter());
        }
        return _results;
      })()
    };
  };

  DrumSynthesizer.sample = function(instrument, time, i) {
    if (instrument.level === 0) {
      return 0;
    }
    if (this.state[instrument._id] == null) {
      return 0;
    }
    return instrument.level * instrument.drums.reduce((function(_this) {
      return function(memo, drum) {
        var elapsed, env, freq, note, sample, signal;
        note = _this.state[instrument._id].notes[drum.key];
        if (note == null) {
          return memo;
        }
        elapsed = time - note.time;
        if (elapsed > drum.decay) {
          return memo;
        }
        env = simpleEnvelope(drum.decay, elapsed);
        freq = minFreq + drum.pitch * freqScale;
        if (drum.bend) {
          freq = (2 - drum.bend + drum.bend * env) / 2 * freq;
        }
        if (drum.fm > 0) {
          signal = oscillators.sine(elapsed, minFreq + drum.fmFreq * freqScale);
          freq += drum.fm * signal * simpleEnvelope(drum.fmDecay + 0.01, elapsed);
        }
        sample = (1 - drum.noise) * oscillators.sine(elapsed, freq) + drum.noise * oscillators.noise();
        if (drum.hp > 0) {
          sample = _this.state[instrument._id].filters[drum.key](sample, drum.hp);
        }
        return memo + drum.level * env * sample;
      };
    })(this), 0);
  };

  DrumSynthesizer.tick = function(instrument, time, i, beat, bps, notesOn) {
    if (this.state[instrument._id] == null) {
      this.createState(instrument);
    }
    return notesOn.forEach((function(_this) {
      return function(note) {
        return _this.state[instrument._id].notes[note.key] = {
          time: time,
          i: i,
          len: note.length / bps
        };
      };
    })(this));
  };

  return DrumSynthesizer;

})(Instrument);



},{"../dsp/highpass_filter":6,"../dsp/oscillators":9,"../dsp/simple_envelope":10,"../util/log_sample":66,"./instrument":16,"cuid":76}],16:[function(require,module,exports){
var Instrument, Model, RingBuffer,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Model = require('./model');

RingBuffer = require('../util/ring_buffer');

module.exports = Instrument = (function(_super) {
  __extends(Instrument, _super);

  function Instrument() {
    return Instrument.__super__.constructor.apply(this, arguments);
  }

  Instrument.state = {};

  Instrument.createState = function(instrument) {
    return this.state[instrument._id] = {
      notes: new RingBuffer(instrument.maxPolyphony, Array, instrument.polyphony)
    };
  };

  Instrument.releaseState = function(instrument) {
    return delete this.state[instrument._id];
  };

  Instrument.sample = function(instrument, time, i) {
    return 0;
  };

  Instrument.tick = function(instrument, time, i, beat, bps, notesOn) {
    var state;
    if (this.state[instrument._id] == null) {
      this.createState(instrument);
    }
    state = this.state[instrument._id];
    if (instrument.polyphony !== state.notes.length) {
      state.notes.resize(instrument.polyphony);
    }
    return notesOn.forEach((function(_this) {
      return function(note) {
        return state.notes.push({
          time: time,
          i: i,
          key: note.key,
          len: note.length / bps
        });
      };
    })(this));
  };

  return Instrument;

})(Model);



},{"../util/ring_buffer":68,"./model":18}],17:[function(require,module,exports){
var Instrument, LoopSampler, RingBuffer,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Instrument = require('./instrument');

RingBuffer = require('../util/ring_buffer');

module.exports = LoopSampler = (function(_super) {
  __extends(LoopSampler, _super);

  function LoopSampler() {
    return LoopSampler.__super__.constructor.apply(this, arguments);
  }

  LoopSampler.prototype.defaults = {
    level: 0.5,
    polyphony: 1,
    slices: []
  };

  return LoopSampler;

})(Instrument);



},{"../util/ring_buffer":68,"./instrument":16}],18:[function(require,module,exports){
var Model, cuid, deepMerge;

deepMerge = require('../util/deep_merge');

cuid = require('cuid');

module.exports = Model = (function() {
  function Model() {}

  Model.defaults = {};

  Model.build = function(data) {
    var defaults;
    if (data == null) {
      data = {};
    }
    if (data._id == null) {
      data._id = cuid();
    }
    defaults = typeof this.defaults === 'function' ? this.defaults() : this.defaults;
    return deepMerge(defaults, data);
  };

  return Model;

})();



},{"../util/deep_merge":63,"cuid":76}],19:[function(require,module,exports){
var Model, Sequence,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Model = require('./model');

module.exports = Sequence = (function(_super) {
  __extends(Sequence, _super);

  function Sequence() {
    return Sequence.__super__.constructor.apply(this, arguments);
  }

  Sequence.defaults = {
    loopSize: 4,
    notes: {}
  };

  Sequence.notesOn = function(sequence, beat, lastBeat) {
    var bar, id, lastBar, note, result, _ref;
    bar = Math.floor(beat / sequence.loopSize);
    lastBar = Math.floor(lastBeat / sequence.loopSize);
    beat = beat % sequence.loopSize;
    lastBeat = lastBeat % sequence.loopSize;
    result = [];
    _ref = sequence.notes;
    for (id in _ref) {
      note = _ref[id];
      if (note.start < beat && (note.start >= lastBeat || bar > lastBar)) {
        result.push(note);
      }
    }
    return result;
  };

  return Sequence;

})(Model);



},{"./model":18}],20:[function(require,module,exports){
var Song, Track, webaudio,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

webaudio = require('../dsp/webaudio');

window.context = require('../dsp/global_context');

Track = require('./track');

module.exports = Song = (function() {
  var clip, clockRatio, meterDecay;

  clockRatio = 50;

  meterDecay = 0.05;

  clip = function(sample) {
    return Math.max(0, Math.min(2, sample + 1)) - 1;
  };

  function Song() {
    this.frame = __bind(this.frame, this);
    this.sample = __bind(this.sample, this);
    this.stop = __bind(this.stop, this);
    this.pause = __bind(this.pause, this);
    this.play = __bind(this.play, this);
    this.audio = webaudio(context, this.sample);
    this.lastBeat = 0;
    requestAnimationFrame(this.frame);
  }

  Song.prototype.update = function(cursor) {
    this.cursor = cursor;
    return this.data = cursor.get();
  };

  Song.prototype.play = function() {
    this.audio.play();
    return this.cursor.set('playing', true);
  };

  Song.prototype.pause = function() {
    this.audio.stop();
    return this.cursor.set('playing', false);
  };

  Song.prototype.stop = function() {
    this.audio.stop();
    this.audio.reset();
    return this.cursor.batched((function(_this) {
      return function() {
        _this.cursor.set('playing', false);
        return _this.cursor.set('position', 0);
      };
    })(this));
  };

  Song.prototype.seek = function(beat) {
    this.cursor.set('position', beat);
    return this.audio.seek(beat * 60 / this.data.bpm);
  };

  Song.prototype.sample = function(time, i) {
    var _ref;
    if (!((_ref = this.data) != null ? _ref.playing : void 0)) {
      return 0;
    }
    if (i % clockRatio === 0) {
      this.tick(time, i);
    }
    return clip(this.data.tracks.reduce(function(memo, track) {
      return memo + Track.sample(track, time, i);
    }, 0));
  };

  Song.prototype.tick = function(time, i) {
    var beat, bps;
    bps = this.data.bpm / 60;
    beat = time * bps;
    this.data.tracks.forEach((function(_this) {
      return function(track) {
        return Track.tick(track, time, i, beat, _this.lastBeat, bps);
      };
    })(this));
    return this.lastBeat = beat;
  };

  Song.prototype.frame = function() {
    var id, level, _ref;
    this.cursor.batched((function(_this) {
      return function() {
        var meterLevel, track, trackIndex, _ref;
        _ref = _this.data.tracks;
        for (trackIndex in _ref) {
          track = _ref[trackIndex];
          meterLevel = Track.meterLevels[track._id] || 0;
          _this.cursor.set(['tracks', trackIndex, 'meterLevel'], meterLevel || 0);
        }
        return _this.cursor.set('position', _this.audio.getTime() * _this.data.bpm / 60);
      };
    })(this));
    _ref = Track.meterLevels;
    for (id in _ref) {
      level = _ref[id];
      Track.meterLevels[id] = level - meterDecay;
      if (Track.meterLevels[id] < 0) {
        delete Track.meterLevels[id];
      }
    }
    return requestAnimationFrame(this.frame);
  };

  return Song;

})();



},{"../dsp/global_context":5,"../dsp/webaudio":11,"./track":21}],21:[function(require,module,exports){
var Model, Sequence, Track, instrumentTypes, logSample,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Model = require('./model');

Sequence = require('./sequence');

logSample = require('../util/log_sample');

instrumentTypes = {
  AnalogSynthesizer: require('./analog_synthesizer'),
  BasicSampler: require('./basic_sampler'),
  DrumSampler: require('./drum_sampler'),
  DrumSynthesizer: require('./drum_synthesizer'),
  LoopSampler: require('./loop_sampler')
};

module.exports = Track = (function(_super) {
  __extends(Track, _super);

  function Track() {
    return Track.__super__.constructor.apply(this, arguments);
  }

  Track.defaults = function() {
    return {
      name: 'Track',
      meterLevel: 0,
      sequence: Sequence.build(),
      effects: []
    };
  };

  Track.meterLevels = {};

  Track.sample = function(track, time, i) {
    var Instrument, id, sample;
    Instrument = instrumentTypes[track.instrument._type];
    sample = Instrument.sample(track.instrument, time, i);
    sample = track.effects.reduce(function(sample, effect) {
      return Effect.sample(effect, time, i, sample);
    }, sample);
    id = track._id;
    if ((this.meterLevels[id] == null) || isNaN(this.meterLevels[id]) || sample > this.meterLevels[id]) {
      this.meterLevels[id] = sample;
    }
    return sample;
  };

  Track.tick = function(track, time, i, beat, lastBeat, bps) {
    var Instrument, notesOn;
    Instrument = instrumentTypes[track.instrument._type];
    notesOn = Sequence.notesOn(track.sequence, beat, lastBeat);
    Instrument.tick(track.instrument, time, i, beat, bps, notesOn);
    return track.effects.forEach(function(e) {
      return e.tick(time, beat, bps);
    });
  };

  return Track;

})(Model);



},{"../util/log_sample":66,"./analog_synthesizer":12,"./basic_sampler":13,"./drum_sampler":14,"./drum_synthesizer":15,"./loop_sampler":17,"./model":18,"./sequence":19}],22:[function(require,module,exports){
module.exports = {
  fourfour: {
    0: {
      id: '0',
      key: 0,
      start: 0,
      length: 1 / 4
    },
    1: {
      id: '1',
      key: 0,
      start: 1,
      length: 1 / 4
    },
    2: {
      id: '2',
      key: 0,
      start: 2,
      length: 1 / 4
    },
    3: {
      id: '3',
      key: 0,
      start: 3,
      length: 1 / 4
    }
  },
  beat: {
    0: {
      id: '0',
      key: 0,
      start: 0,
      length: 1 / 4
    },
    1: {
      id: '1',
      key: 0,
      start: 1,
      length: 1 / 4
    },
    2: {
      id: '2',
      key: 0,
      start: 2,
      length: 1 / 4
    },
    3: {
      id: '3',
      key: 0,
      start: 3,
      length: 1 / 4
    },
    4: {
      id: '4',
      key: 2,
      start: 1 / 2,
      length: 1 / 4
    },
    5: {
      id: '5',
      key: 2,
      start: 3 / 2,
      length: 1 / 4
    },
    6: {
      id: '6',
      key: 2,
      start: 5 / 2,
      length: 1 / 4
    },
    7: {
      id: '7',
      key: 2,
      start: 7 / 2,
      length: 1 / 4
    },
    8: {
      id: '8',
      key: 1,
      start: 1,
      length: 1 / 4
    },
    9: {
      id: '9',
      key: 1,
      start: 3,
      length: 1 / 4
    }
  },
  chords: {
    0: {
      id: '0',
      key: 60,
      start: 0,
      length: 1 / 4
    },
    1: {
      id: '1',
      key: 63,
      start: 0,
      length: 1 / 4
    },
    2: {
      id: '2',
      key: 67,
      start: 0,
      length: 1 / 4
    },
    3: {
      id: '3',
      key: 60,
      start: 1 / 2,
      length: 1 / 4
    },
    4: {
      id: '4',
      key: 63,
      start: 1 / 2,
      length: 1 / 4
    },
    5: {
      id: '5',
      key: 67,
      start: 1 / 2,
      length: 1 / 4
    }
  },
  simple: {
    0: {
      id: '0',
      key: 60,
      start: 0,
      length: 1 / 4
    },
    1: {
      id: '1',
      key: 63,
      start: 1 / 2,
      length: 1 / 4
    },
    2: {
      id: '2',
      key: 67,
      start: 2 / 2,
      length: 1 / 4
    },
    3: {
      id: '3',
      key: 63,
      start: 3 / 2,
      length: 1 / 4
    },
    4: {
      id: '4',
      key: 60,
      start: 4 / 2,
      length: 1 / 4
    },
    5: {
      id: '5',
      key: 65,
      start: 5 / 2,
      length: 1 / 4
    },
    6: {
      id: '6',
      key: 70,
      start: 6 / 2,
      length: 1 / 4
    },
    7: {
      id: '7',
      key: 65,
      start: 7 / 2,
      length: 1 / 4
    }
  },
  bass: {
    0: {
      id: '0',
      key: 48,
      start: 2 / 4,
      length: 1 / 4
    },
    1: {
      id: '1',
      key: 48,
      start: 3 / 4,
      length: 1 / 4
    },
    2: {
      id: '2',
      key: 48,
      start: 6 / 4,
      length: 1 / 4
    },
    3: {
      id: '3',
      key: 48,
      start: 7 / 4,
      length: 1 / 4
    },
    4: {
      id: '4',
      key: 50,
      start: 10 / 4,
      length: 1 / 4
    },
    5: {
      id: '5',
      key: 50,
      start: 11 / 4,
      length: 1 / 4
    },
    6: {
      id: '6',
      key: 51,
      start: 14 / 4,
      length: 1 / 4
    },
    7: {
      id: '7',
      key: 51,
      start: 15 / 4,
      length: 1 / 4
    }
  },
  terje: {
    0: {
      id: '0',
      key: 45,
      start: 0 / 4,
      length: 1 / 4
    },
    1: {
      id: '1',
      key: 62,
      start: 1 / 4,
      length: 1 / 4
    },
    2: {
      id: '2',
      key: 57,
      start: 2 / 4,
      length: 1 / 4
    },
    3: {
      id: '3',
      key: 74,
      start: 3 / 4,
      length: 1 / 4
    },
    4: {
      id: '4',
      key: 45,
      start: 4 / 4,
      length: 1 / 4
    },
    5: {
      id: '5',
      key: 62,
      start: 5 / 4,
      length: 1 / 4
    },
    6: {
      id: '6',
      key: 57,
      start: 6 / 4,
      length: 1 / 4
    },
    7: {
      id: '7',
      key: 74,
      start: 7 / 4,
      length: 1 / 4
    },
    8: {
      id: '8',
      key: 45,
      start: 8 / 4,
      length: 1 / 4
    },
    9: {
      id: '9',
      key: 64,
      start: 9 / 4,
      length: 1 / 4
    },
    10: {
      id: '10',
      key: 57,
      start: 10 / 4,
      length: 1 / 4
    },
    11: {
      id: '11',
      key: 76,
      start: 11 / 4,
      length: 1 / 4
    },
    12: {
      id: '12',
      key: 45,
      start: 12 / 4,
      length: 1 / 4
    },
    13: {
      id: '13',
      key: 67,
      start: 13 / 4,
      length: 1 / 4
    },
    14: {
      id: '14',
      key: 57,
      start: 14 / 4,
      length: 1 / 4
    },
    15: {
      id: '15',
      key: 79,
      start: 15 / 4,
      length: 1 / 4
    },
    16: {
      id: '16',
      key: 47,
      start: 16 / 4,
      length: 1 / 4
    },
    17: {
      id: '17',
      key: 64,
      start: 17 / 4,
      length: 1 / 4
    },
    18: {
      id: '18',
      key: 59,
      start: 18 / 4,
      length: 1 / 4
    },
    19: {
      id: '19',
      key: 76,
      start: 19 / 4,
      length: 1 / 4
    },
    20: {
      id: '20',
      key: 47,
      start: 20 / 4,
      length: 1 / 4
    },
    21: {
      id: '21',
      key: 67,
      start: 21 / 4,
      length: 1 / 4
    },
    22: {
      id: '22',
      key: 59,
      start: 22 / 4,
      length: 1 / 4
    },
    23: {
      id: '23',
      key: 79,
      start: 23 / 4,
      length: 1 / 4
    },
    24: {
      id: '24',
      key: 48,
      start: 24 / 4,
      length: 1 / 4
    },
    25: {
      id: '25',
      key: 69,
      start: 25 / 4,
      length: 1 / 4
    },
    26: {
      id: '26',
      key: 60,
      start: 26 / 4,
      length: 1 / 4
    },
    27: {
      id: '27',
      key: 81,
      start: 27 / 4,
      length: 1 / 4
    },
    28: {
      id: '28',
      key: 48,
      start: 28 / 4,
      length: 1 / 4
    },
    29: {
      id: '29',
      key: 67,
      start: 29 / 4,
      length: 1 / 4
    },
    30: {
      id: '30',
      key: 60,
      start: 30 / 4,
      length: 1 / 4
    },
    31: {
      id: '31',
      key: 79,
      start: 31 / 4,
      length: 1 / 4
    }
  }
};



},{}],23:[function(require,module,exports){
var Envelope, Filter, Oscillator, React, Slider;

React = require('react');

Slider = require('./slider');

Envelope = require('./envelope');

Filter = require('./filter');

Oscillator = require('./oscillator');

module.exports = React.createClass({
  render: function() {
    var i, instrument, options;
    instrument = this.props.instrument;
    options = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 1; _i <= 6; i = ++_i) {
        _results.push(React.DOM.option({
          "key": i,
          "value": i
        }, i));
      }
      return _results;
    })();
    return React.DOM.div({
      "className": "ui analog"
    }, React.DOM.div({
      "className": "column channel"
    }, Slider({
      "label": "Level",
      "value": instrument.get('level'),
      "onChange": instrument.bind('level')
    }), React.DOM.div({
      "className": "ui"
    }, React.DOM.select({
      "onChange": instrument.bind('polyphony', function(e) {
        return parseInt(e.target.value);
      }),
      "value": instrument.get('polyphony')
    }, options), React.DOM.label(null, "Poly"))), React.DOM.div({
      "className": "column"
    }, Envelope({
      "label": "Volume Env",
      "env": instrument.cursor('volumeEnv')
    })), React.DOM.div({
      "className": "column"
    }, Envelope({
      "label": "Filter Env",
      "env": instrument.cursor('filterEnv')
    })), React.DOM.div({
      "className": "column oscillators"
    }, Filter({
      "label": "Filter",
      "filter": instrument.cursor('filter')
    }), Oscillator({
      "label": "Osc 1",
      "osc": instrument.cursor('osc1')
    }), Oscillator({
      "label": "Osc 2",
      "osc": instrument.cursor('osc2')
    })));
  }
});



},{"./envelope":29,"./filter":30,"./oscillator":42,"./slider":56,"react":237}],24:[function(require,module,exports){
var AnalogSynthesizerControl, BasicSamplerControl, DrumSamplerControl, DrumSynthesizerControl, KeyboardInteraction, LoopSamplerControl, Modal, PianoRoll, PlaybackControl, React, ReactCSSTransitionGroup, TrackSelection;

React = require('react/addons');

PlaybackControl = require('./playback_control');

TrackSelection = require('./track_selection');

PianoRoll = require('./piano_roll');

BasicSamplerControl = require('./basic_sampler_control');

AnalogSynthesizerControl = require('./analog_synthesizer_control');

DrumSynthesizerControl = require('./drum_synthesizer_control');

DrumSamplerControl = require('./drum_sampler_control');

LoopSamplerControl = require('./loop_sampler_control');

Modal = require('./modal');

KeyboardInteraction = require('./mixins/keyboard_interaction');

ReactCSSTransitionGroup = React.addons.CSSTransitionGroup;

module.exports = React.createClass({
  mixins: [KeyboardInteraction],
  propTypes: {
    data: React.PropTypes.object.isRequired
  },
  getInitialState: function() {
    return {
      selectedTrack: 0,
      modalContent: null
    };
  },
  launchModal: function(modalContent) {
    this.props.data.set('playing', false);
    return this.setState({
      modalContent: modalContent
    });
  },
  dismissModal: function() {
    return this.setState({
      modalContent: null
    });
  },
  render: function() {
    var controlClass, instrument, instrumentControl, modal, sequence, track;
    track = this.props.data.cursor(['tracks', this.state.selectedTrack]);
    if (track) {
      sequence = track.cursor('sequence');
      instrument = track.cursor('instrument');
      controlClass = (function() {
        switch (instrument.get('_type')) {
          case 'BasicSampler':
            return BasicSamplerControl;
          case 'AnalogSynthesizer':
            return AnalogSynthesizerControl;
          case 'DrumSynthesizer':
            return DrumSynthesizerControl;
          case 'DrumSampler':
            return DrumSamplerControl;
          case 'LoopSampler':
            return LoopSamplerControl;
          default:
            return null;
        }
      })();
      if (controlClass != null) {
        instrumentControl = controlClass({
          "key": track.get('_id'),
          "instrument": instrument,
          "app": this
        });
      }
    }
    if (this.state.modalContent != null) {
      modal = Modal({
        "key": 'm'
      }, this.state.modalContent);
    }
    return React.DOM.div({
      "className": "app"
    }, React.DOM.div({
      "className": "row playback"
    }, PlaybackControl({
      "data": this.props.data,
      "song": this.props.song
    })), React.DOM.div({
      "className": "row main"
    }, React.DOM.div({
      "className": "column sidebar"
    }, TrackSelection({
      "tracks": this.props.data.cursor('tracks'),
      "selectedTrack": this.state.selectedTrack,
      "selectTrack": ((function(_this) {
        return function(v) {
          return _this.setState({
            selectedTrack: parseInt(v)
          });
        };
      })(this))
    })), React.DOM.div({
      "className": "column main"
    }, React.DOM.div({
      "className": "row sequence"
    }, PianoRoll({
      "data": this.props.data,
      "song": this.props.song,
      "sequence": sequence
    })), React.DOM.div({
      "className": "row instrument"
    }, instrumentControl))), ReactCSSTransitionGroup({
      "transitionName": "modal"
    }, modal));
  }
});



},{"./analog_synthesizer_control":23,"./basic_sampler_control":25,"./drum_sampler_control":27,"./drum_synthesizer_control":28,"./loop_sampler_control":33,"./mixins/keyboard_interaction":37,"./modal":41,"./piano_roll":43,"./playback_control":52,"./track_selection":57,"react/addons":78}],25:[function(require,module,exports){
var Chooser, Envelope, Filter, Knob, React, SampleControl, Slider, keyOptions;

React = require('react/addons');

Knob = require('./knob');

Chooser = require('./chooser');

Slider = require('./slider');

SampleControl = require('./sample_control');

Envelope = require('./envelope');

Filter = require('./filter');

keyOptions = require('../util/key_options');

module.exports = React.createClass({
  getInitialState: function() {
    return {
      buffer: null
    };
  },
  setStart: function(value) {
    return this.props.instrument.merge({
      start: value,
      loop: Math.max(value, this.props.instrument.get('loop'))
    });
  },
  setLoop: function(value) {
    return this.props.instrument.merge({
      loop: value,
      start: Math.min(value, this.props.instrument.get('start'))
    });
  },
  render: function() {
    var i, instrument, options;
    instrument = this.props.instrument;
    options = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 1; _i <= 6; i = ++_i) {
        _results.push(React.DOM.option({
          "key": i,
          "value": i
        }, i));
      }
      return _results;
    })();
    return React.DOM.div({
      "className": "ui basic-sampler"
    }, React.DOM.div({
      "className": "column channel"
    }, Slider({
      "label": "Level",
      "value": instrument.get('level'),
      "onChange": instrument.bind('level')
    }), React.DOM.div({
      "className": "ui"
    }, React.DOM.select({
      "value": instrument.get('polyphony'),
      "onChange": instrument.bind('polyphony', function(e) {
        return parseInt(e.target.value);
      })
    }, options), React.DOM.label(null, "Poly"))), React.DOM.div({
      "className": "column"
    }, SampleControl({
      "label": "Sample",
      "app": this.props.app,
      "sampler": instrument
    })), React.DOM.div({
      "className": "column envelope"
    }, Envelope({
      "label": "Volume Env",
      "env": instrument.cursor('volumeEnv')
    })), React.DOM.div({
      "className": "column envelope"
    }, Envelope({
      "label": "Filter Env",
      "env": instrument.cursor('filterEnv')
    })), React.DOM.div({
      "className": "column controls"
    }, Filter({
      "label": "Filter",
      "filter": instrument.cursor('filter')
    }), React.DOM.div({
      "className": "row sample"
    }, React.DOM.div({
      "className": "ui"
    }, React.DOM.select({
      "value": instrument.get('rootKey'),
      "onChange": instrument.bind('rootKey', function(e) {
        return parseInt(e.target.value);
      })
    }, keyOptions()), React.DOM.label(null, "Root")), Knob({
      "label": "Tune",
      "value": instrument.get('tune'),
      "onChange": instrument.bind('tune')
    })), React.DOM.div({
      "className": "row sample"
    }, Chooser({
      "options": ['loop', 'off'],
      "value": instrument.get('loopActive'),
      "onChange": instrument.bind('loopActive')
    }), Knob({
      "label": "Loop",
      "value": instrument.get('loop'),
      "disabled": instrument.get('loopActive') === 'off',
      "onChange": this.setLoop
    }), Knob({
      "label": "Start",
      "value": instrument.get('start'),
      "onChange": this.setStart
    }))));
  }
});



},{"../util/key_options":65,"./chooser":26,"./envelope":29,"./filter":30,"./knob":31,"./sample_control":54,"./slider":56,"react/addons":78}],26:[function(require,module,exports){
var React;

React = require('react');

module.exports = React.createClass({
  propTypes: {
    onChange: React.PropTypes.func.isRequired,
    options: React.PropTypes.array.isRequired,
    value: React.PropTypes.string.isRequired
  },
  onClickValue: function(value) {
    return this.props.onChange(e.target.dataset.value);
  },
  render: function() {
    return React.DOM.div({
      "className": "ui chooser"
    }, this.props.options.map((function(_this) {
      return function(v, i) {
        return React.DOM.div({
          "key": i,
          "className": 'option' + (v === _this.props.value ? ' selected' : ''),
          "onClick": (function() {
            return _this.props.onChange(v);
          })
        }, v);
      };
    })(this)));
  }
});



},{"react":237}],27:[function(require,module,exports){
var Drum, DrumSampler, Envelope, Knob, ListControl, React, SampleControl, Slider, Sortable, Updatable, keyOptions, transposeOptions;

React = require('react/addons');

Updatable = require('./mixins/updatable');

Sortable = require('./mixins/sortable');

Knob = require('./knob');

Slider = require('./slider');

ListControl = require('./list_control');

SampleControl = require('./sample_control');

Envelope = require('./envelope');

keyOptions = require('../util/key_options');

transposeOptions = require('../util/transpose_options');

DrumSampler = require('../models/drum_sampler');

Drum = React.createClass({
  mixins: [React.addons.PureRenderMixin, Sortable],
  render: function() {
    var drum;
    drum = this.props.drum;
    if (!drum) {
      return React.DOM.div({
        "className": "drum"
      });
    }
    return React.DOM.div({
      "className": "drum"
    }, React.DOM.div({
      "className": "column"
    }, SampleControl({
      "label": "Sample",
      "app": this.props.app,
      "sampler": drum
    })), React.DOM.div({
      "className": "column envelope"
    }, Envelope({
      "label": "Volume Env",
      "env": drum.cursor('volumeEnv')
    })), React.DOM.div({
      "className": "column control"
    }, Knob({
      "label": "Level",
      "value": drum.get('level'),
      "onChange": drum.bind('level')
    }), React.DOM.div({
      "className": "ui"
    }, React.DOM.select({
      "value": drum.get('transpose'),
      "onChange": drum.bind('transpose', function(e) {
        return parseInt(e.target.value);
      })
    }, transposeOptions()), React.DOM.label(null, "Transpose")), React.DOM.div({
      "className": "ui"
    }, React.DOM.select({
      "value": drum.get('key'),
      "onChange": drum.bind('key', function(e) {
        return parseInt(e.target.value);
      })
    }, keyOptions()), React.DOM.label(null, "Trigger"))));
  }
});

module.exports = React.createClass({
  mixins: [React.addons.PureRenderMixin],
  getInitialState: function() {
    return {
      activeDrum: 0
    };
  },
  onAddDrum: function() {
    var drum, drums, index;
    drums = this.props.instrument.get('drums');
    drum = DrumSampler.defaultDrum(drums);
    index = drums.length;
    this.props.instrument.set(['drums', index], drum);
    return this.setState({
      activeDrum: index
    });
  },
  onRemoveDrum: function() {
    var drums;
    drums = this.props.instrument.get('drums').slice(0);
    drums.splice(this.state.activeDrum, 1);
    this.props.instrument.set('drums', drums);
    return this.setState({
      activeDrum: Math.min(this.state.activeDrum, drums.length - 1)
    });
  },
  render: function() {
    var instrument;
    instrument = this.props.instrument;
    return React.DOM.div({
      "className": "ui drum-sampler"
    }, React.DOM.div({
      "className": "column channel"
    }, Slider({
      "label": "Level",
      "value": instrument.get('level'),
      "onChange": instrument.bind('level')
    })), ListControl({
      "options": instrument.get('drums'),
      "selectedIndex": this.state.activeDrum,
      "onSelect": ((function(_this) {
        return function(activeDrum) {
          return _this.setState({
            activeDrum: activeDrum
          });
        };
      })(this)),
      "onSort": instrument.bind('drums'),
      "onAdd": this.onAddDrum,
      "onRemove": this.onRemoveDrum
    }), Drum({
      "drum": instrument.cursor(['drums', this.state.activeDrum]),
      "app": this.props.app
    }));
  }
});



},{"../models/drum_sampler":14,"../util/key_options":65,"../util/transpose_options":69,"./envelope":29,"./knob":31,"./list_control":32,"./mixins/sortable":39,"./mixins/updatable":40,"./sample_control":54,"./slider":56,"react/addons":78}],28:[function(require,module,exports){
var Drum, DrumSynthesizer, Knob, ListControl, React, Slider, Updatable, keyOptions;

React = require('react');

Updatable = require('./mixins/updatable');

Knob = require('./knob');

Slider = require('./slider');

ListControl = require('./list_control');

keyOptions = require('../util/key_options');

DrumSynthesizer = require('../models/drum_synthesizer');

Drum = React.createClass({
  render: function() {
    var drum;
    drum = this.props.drum.get();
    return React.DOM.div({
      "className": 'drum'
    }, React.DOM.div({
      "className": 'column attrs'
    }, Knob({
      "label": "Level",
      "value": drum.level,
      "onChange": this.props.drum.bind('level')
    }), Knob({
      "label": "Pitch",
      "value": drum.pitch,
      "onChange": this.props.drum.bind('pitch')
    }), Knob({
      "label": "FM",
      "value": drum.fm,
      "onChange": this.props.drum.bind('fm')
    }), Knob({
      "label": "Dcy",
      "value": drum.decay,
      "onChange": this.props.drum.bind('decay')
    }), Knob({
      "label": "Bend",
      "value": drum.bend,
      "onChange": this.props.drum.bind('bend')
    }), Knob({
      "label": "MDcy",
      "value": drum.fmDecay,
      "onChange": this.props.drum.bind('fmDecay')
    }), Knob({
      "label": "Noise",
      "value": drum.noise,
      "onChange": this.props.drum.bind('noise')
    }), Knob({
      "label": "HP",
      "value": drum.hp,
      "onChange": this.props.drum.bind('hp')
    }), Knob({
      "label": "MFrq",
      "value": drum.fmFreq,
      "onChange": this.props.drum.bind('fmFreq')
    })), React.DOM.div({
      "className": "column control"
    }, React.DOM.div({
      "className": "ui"
    }, React.DOM.select({
      "value": drum.key,
      "onChange": this.props.drum.bind('key', function(e) {
        return parseInt(e.target.value);
      })
    }, keyOptions()), React.DOM.label(null, "Trigger"))));
  }
});

module.exports = React.createClass({
  mixins: [React.addons.PureRenderMixin],
  getInitialState: function() {
    return {
      activeDrum: 0
    };
  },
  onAddDrum: function() {
    var drum, drums, index;
    drums = this.props.instrument.get('drums');
    drum = DrumSynthesizer.defaultDrum(drums);
    index = drums.length;
    this.props.instrument.set(['drums', index], drum);
    return this.setState({
      activeDrum: index
    });
  },
  onRemoveDrum: function() {
    var drums;
    drums = this.props.instrument.get('drums').slice(0);
    drums.splice(this.state.activeDrum, 1);
    this.props.instrument.set('drums', drums);
    return this.setState({
      activeDrum: Math.min(this.state.activeDrum, drums.length - 1)
    });
  },
  render: function() {
    var instrument;
    instrument = this.props.instrument;
    return React.DOM.div({
      "className": "ui drum-synthesizer"
    }, React.DOM.div({
      "className": "column channel"
    }, Slider({
      "label": "Level",
      "value": instrument.get('level'),
      "onChange": instrument.bind('level')
    })), ListControl({
      "options": instrument.get('drums'),
      "selectedIndex": this.state.activeDrum,
      "onSelect": ((function(_this) {
        return function(activeDrum) {
          return _this.setState({
            activeDrum: activeDrum
          });
        };
      })(this)),
      "onSort": instrument.bind('drums'),
      "onAdd": this.onAddDrum,
      "onRemove": this.onRemoveDrum
    }), Drum({
      "drum": instrument.cursor(['drums', this.state.activeDrum])
    }));
  }
});



},{"../models/drum_synthesizer":15,"../util/key_options":65,"./knob":31,"./list_control":32,"./mixins/updatable":40,"./slider":56,"react":237}],29:[function(require,module,exports){
var Draggable, Knob, React, SizeMeasurable;

React = require('react');

SizeMeasurable = require('./mixins/size_measurable');

Draggable = require('./mixins/draggable');

Knob = require('./knob');

module.exports = React.createClass({
  mixins: [SizeMeasurable, Draggable],
  propTypes: {
    label: React.PropTypes.string.isRequired,
    env: React.PropTypes.object.isRequired,
    dotRadius: React.PropTypes.number,
    margin: React.PropTypes.number
  },
  getInitialState: function() {
    return {
      dragTarget: null
    };
  },
  getDefaultProps: function() {
    return {
      dotRadius: 5,
      margin: 4
    };
  },
  buildLines: function() {
    var className, d, dots, env, h, lines, m, p, p1, p2, p3, p4, p5, w, _i, _len, _ref;
    lines = [];
    dots = [];
    m = this.props.margin + this.props.dotRadius;
    w = this.state.width - 2 * m;
    h = this.state.height - 2 * m;
    env = this.props.env.get();
    p1 = {
      x: 0,
      y: h
    };
    p2 = {
      x: w / 3 * env.a,
      y: 0
    };
    p3 = {
      x: p2.x + w / 3 * env.d,
      y: h * (1 - env.s)
    };
    p4 = {
      x: w * 2 / 3,
      y: h * (1 - env.s)
    };
    p5 = {
      x: w * (2 + env.r) / 3,
      y: h
    };
    _ref = [p1, p2, p3, p4, p5];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      p = _ref[_i];
      p.x += m;
      p.y += m;
    }
    d = 'M ' + [p1, p2, p3, p4, p5].map(function(p) {
      return "" + p.x + " " + p.y;
    }).join(' L ');
    lines.push(React.DOM.path({
      "key": "p",
      "d": d
    }));
    className = this.state.dragTarget === 'attack' ? 'active' : '';
    dots.push(React.DOM.circle({
      "key": "a",
      "className": className,
      "cx": p2.x,
      "cy": p2.y,
      "r": this.props.dotRadius,
      "onMouseDown": this.onMouseDownAttack
    }));
    className = this.state.dragTarget === 'decay' ? 'active' : '';
    dots.push(React.DOM.circle({
      "key": "d",
      "className": className,
      "cx": p3.x,
      "cy": p3.y,
      "r": this.props.dotRadius,
      "onMouseDown": this.onMouseDownDecay
    }));
    className = this.state.dragTarget === 'release' ? 'active' : '';
    dots.push(React.DOM.circle({
      "key": "r",
      "className": className,
      "cx": p5.x,
      "cy": p5.y,
      "r": this.props.dotRadius,
      "onMouseDown": this.onMouseDownRelease
    }));
    return lines.concat(dots);
  },
  onMouseDownAttack: function(e) {
    this.initialValue = this.props.env.get('a');
    this.setState({
      dragTarget: 'attack'
    });
    return this.draggableOnMouseDown(e);
  },
  onMouseDownDecay: function(e) {
    this.initialValue = {
      d: this.props.env.get('d'),
      s: this.props.env.get('s')
    };
    this.setState({
      dragTarget: 'decay'
    });
    return this.draggableOnMouseDown(e);
  },
  onMouseDownRelease: function(e) {
    this.initialValue = this.props.env.get('r');
    this.setState({
      dragTarget: 'release'
    });
    return this.draggableOnMouseDown(e);
  },
  onDrag: function(delta) {
    var a, changes, d, h, k, m, r, s, v, w;
    m = this.props.margin + this.props.dotRadius;
    w = (this.state.width - 2 * m) / 3;
    h = this.state.height - 2 * m;
    if (this.state.dragTarget === 'attack') {
      a = this.initialValue + delta.x / w;
      changes = {
        a: a
      };
    } else if (this.state.dragTarget === 'decay') {
      d = this.initialValue.d + delta.x / w;
      s = this.initialValue.s + delta.y / h;
      changes = {
        d: d,
        s: s
      };
    } else if (this.state.dragTarget === 'release') {
      r = this.initialValue + delta.x / w;
      changes = {
        r: r
      };
    }
    for (k in changes) {
      v = changes[k];
      changes[k] = Math.max(0, Math.min(1, v));
    }
    return this.props.env.merge(changes);
  },
  onDragEnd: function() {
    this.initialValue = null;
    return this.setState({
      dragTarget: null
    });
  },
  render: function() {
    var env, lines;
    env = this.props.env;
    if (this.state.width > 0) {
      lines = this.buildLines();
    }
    return React.DOM.div({
      "className": 'ui envelope'
    }, React.DOM.div({
      "className": 'control',
      "ref": 'container'
    }, React.DOM.svg({
      "width": this.state.width,
      "height": this.state.height
    }, lines)), React.DOM.div({
      "className": 'knobs'
    }, React.DOM.div({
      "className": 'group'
    }, Knob({
      "label": 'A',
      "value": env.get('a'),
      "onChange": env.bind('a')
    }), Knob({
      "label": 'D',
      "value": env.get('d'),
      "onChange": env.bind('d')
    })), React.DOM.div({
      "className": 'group'
    }, Knob({
      "label": 'S',
      "value": env.get('s'),
      "onChange": env.bind('s')
    }), Knob({
      "label": 'R',
      "value": env.get('r'),
      "onChange": env.bind('r')
    }))), React.DOM.label(null, this.props.label));
  }
});



},{"./knob":31,"./mixins/draggable":36,"./mixins/size_measurable":38,"react":237}],30:[function(require,module,exports){
var Chooser, Knob, React;

React = require('react');

Chooser = require('./chooser');

Knob = require('./knob');

module.exports = React.createClass({
  propTypes: {
    filter: React.PropTypes.object.isRequired,
    label: React.PropTypes.string.isRequired
  },
  render: function() {
    var filter;
    filter = this.props.filter;
    return React.DOM.div({
      "className": "ui filter"
    }, Chooser({
      "options": ['LP', 'HP', 'none'],
      "value": filter.get('type'),
      "onChange": filter.bind('type')
    }), Knob({
      "label": "Freq",
      "value": filter.get('freq'),
      "onChange": filter.bind('freq')
    }), Knob({
      "label": "Res",
      "value": filter.get('res'),
      "onChange": filter.bind('res')
    }), Knob({
      "label": "Env",
      "value": filter.get('env'),
      "onChange": filter.bind('env')
    }), React.DOM.label(null, this.props.label));
  }
});



},{"./chooser":26,"./knob":31,"react":237}],31:[function(require,module,exports){
var Draggable, React;

React = require('react');

Draggable = require('./mixins/draggable');

module.exports = React.createClass({
  range: 100,
  mixins: [Draggable],
  propTypes: {
    value: React.PropTypes.number.isRequired,
    onChange: React.PropTypes.func.isRequired,
    disabled: React.PropTypes.bool
  },
  getInitialState: function() {
    return {
      active: false
    };
  },
  getDefaultProps: function() {
    return {
      value: 0.5,
      disabled: false
    };
  },
  onDragStart: function() {
    this.initalValue = this.props.value;
    return this.setState({
      active: true
    });
  },
  onDrag: function(delta) {
    var downRange, upRange, value;
    if (this.props.disabled) {
      return;
    }
    upRange = Math.min(this.range, this.dragStartPosition.y - window.scrollY);
    downRange = Math.min(this.range, window.innerHeight + window.scrollY - this.dragStartPosition.y);
    if (delta.y < 0) {
      value = Math.max(0, this.initalValue * (downRange + delta.y) / downRange);
    } else {
      value = Math.min(1, this.initalValue + (1 - this.initalValue) * delta.y / upRange);
    }
    return this.props.onChange(value);
  },
  onDragEnd: function() {
    this.initalValue = null;
    return this.setState({
      active: false
    });
  },
  preventDefault: function(e) {
    e.preventDefault();
    return e.stopPropagation();
  },
  render: function() {
    var className, style;
    style = {
      '-webkit-transform': "rotate(" + ((this.props.value - 0.5) * 300) + "deg)"
    };
    className = 'ui knob';
    if (this.state.active) {
      className += ' active';
    }
    if (this.props.disabled) {
      className += ' disabled';
    }
    return React.DOM.div({
      "className": className,
      "draggable": true,
      "onDragStart": this.preventDefault
    }, React.DOM.div({
      "className": "control"
    }, React.DOM.div({
      "className": "handle",
      "style": style,
      "onMouseDown": this.draggableOnMouseDown
    })), React.DOM.label(null, this.props.label));
  }
});



},{"./mixins/draggable":36,"react":237}],32:[function(require,module,exports){
var ListOption, React, Sortable;

React = require('react/addons');

Sortable = require('./mixins/sortable');

ListOption = React.createClass({
  mixins: [Sortable, React.addons.PureRenderMixin],
  render: function() {
    var className;
    className = 'option';
    if (this.props.selected) {
      className += ' selected';
    }
    if (this.isDragging()) {
      className += ' dragging';
    }
    return React.DOM.div({
      "className": className,
      "onClick": this.props.selectOption,
      "draggable": true,
      "onDragStart": this.dragStart,
      "onDragEnd": this.dragEnd,
      "onDragOver": this.dragOver,
      "data-id": this.props.key
    }, this.props.name);
  }
});

module.exports = React.createClass({
  mixins: [React.addons.PureRenderMixin],
  getInitialState: function() {
    return {
      dragging: null
    };
  },
  onRemove: function() {
    return this.props.onRemove(this.props.selectedIndex);
  },
  sort: function(items, dragging) {
    this.props.onSort(items);
    if (dragging != null) {
      this.props.onSelect(dragging);
    }
    return this.setState({
      dragging: dragging
    });
  },
  render: function() {
    var options;
    options = this.props.options.map((function(_this) {
      return function(option, i) {
        return ListOption({
          "key": i,
          "name": option.name,
          "selected": i === _this.props.selectedIndex,
          "selectOption": (function() {
            return _this.props.onSelect(i);
          }),
          "sort": _this.sort,
          "items": _this.props.options,
          "dragging": _this.state.dragging
        });
      };
    })(this));
    return React.DOM.div({
      "className": "ui list-control"
    }, React.DOM.div({
      "className": "list"
    }, options), React.DOM.div({
      "className": "controls"
    }, React.DOM.div({
      "className": "icon icon-plus pull-right",
      "onClick": this.props.onAdd
    }), React.DOM.div({
      "className": "icon icon-minus pull-left",
      "onClick": this.onRemove
    })));
  }
});



},{"./mixins/sortable":39,"react/addons":78}],33:[function(require,module,exports){
var Envelope, Knob, React, SampleControl, Slider;

React = require('react');

Knob = require('./knob');

Slider = require('./slider');

SampleControl = require('./sample_control');

Envelope = require('./envelope');

module.exports = React.createClass({
  setPolyphony: function(e) {
    return this.props.instrument.setPolyphony(parseInt(e.target.value));
  },
  render: function() {
    var i, options;
    options = (function() {
      var _i, _ref, _results;
      _results = [];
      for (i = _i = 1, _ref = this.props.instrument.maxPolyphony; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        _results.push(React.DOM.option({
          "key": i,
          "value": i
        }, i));
      }
      return _results;
    }).call(this);
    return React.DOM.div({
      "className": "ui loop-sampler"
    }, React.DOM.div({
      "className": "column channel"
    }, Slider({
      "label": "Level",
      "value": this.state.level,
      "onChange": this.props.instrument.createSetterFor('level')
    }), React.DOM.div({
      "className": "ui"
    }, React.DOM.select({
      "onChange": this.setPolyphony,
      "value": this.state.polyphony
    }, options), React.DOM.label(null, "Poly"))));
  }
});



},{"./envelope":29,"./knob":31,"./sample_control":54,"./slider":56,"react":237}],34:[function(require,module,exports){
var React;

React = require('react');

module.exports = React.createClass({
  onClickOption: function(e) {
    e.stopPropagation();
    return this.props.onSelect(e.target.dataset.option);
  },
  render: function() {
    var i, option, options;
    options = (function() {
      var _i, _len, _ref, _results;
      _ref = this.props.options;
      _results = [];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        option = _ref[i];
        _results.push((function(_this) {
          return function(option) {
            return React.DOM.div({
              "key": i,
              "className": "option",
              "onClick": _this.onClickOption,
              "data-option": option
            }, option);
          };
        })(this)(option));
      }
      return _results;
    }).call(this);
    return React.DOM.div({
      "className": "ui menu",
      "style": {
        display: this.props.open ? 'block' : 'none'
      }
    }, options);
  }
});



},{"react":237}],35:[function(require,module,exports){
var React;

React = require('react');

module.exports = React.createClass({
  propTypes: {
    level: React.PropTypes.number.isRequired,
    steps: React.PropTypes.number
  },
  getDefaultProps: function() {
    return {
      steps: 6
    };
  },
  render: function() {
    var className, i, level, steps;
    level = Math.ceil(this.props.level * this.props.steps);
    steps = (function() {
      var _i, _ref, _results;
      _results = [];
      for (i = _i = 1, _ref = this.props.steps; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        className = i <= level ? 'on' : '';
        _results.push(React.DOM.div({
          "key": i,
          "className": className
        }));
      }
      return _results;
    }).call(this);
    return React.DOM.div({
      "className": "ui meter"
    }, steps);
  }
});



},{"react":237}],36:[function(require,module,exports){
module.exports = {
  draggableOnMouseDown: function(e) {
    window.addEventListener('mousemove', this.draggableOnMouseMove);
    window.addEventListener('mouseup', this.draggableOnMouseUp);
    this.dragStartPosition = {
      x: e.clientX,
      y: e.clientY
    };
    return typeof this.onDragStart === "function" ? this.onDragStart(this.dragStartPosition, e) : void 0;
  },
  draggableOnMouseMove: function(e) {
    var x, y;
    x = e.clientX - this.dragStartPosition.x;
    y = this.dragStartPosition.y - e.clientY;
    return typeof this.onDrag === "function" ? this.onDrag({
      x: x,
      y: y
    }, e) : void 0;
  },
  draggableOnMouseUp: function(e) {
    window.removeEventListener('mousemove', this.draggableOnMouseMove);
    window.removeEventListener('mouseup', this.draggableOnMouseUp);
    this.mouseDownPosition = null;
    this.initialValue = null;
    return typeof this.onDragEnd === "function" ? this.onDragEnd(e) : void 0;
  }
};



},{}],37:[function(require,module,exports){
var Keyboard;

Keyboard = require('keyboardjs');

module.exports = {
  componentDidMount: function() {
    return this.keyBindings = [Keyboard.on('space', this.onSpaceKey), Keyboard.on('command + z', this.undo), Keyboard.on('command + shift + z', this.redo)];
  },
  componentWillUnmount: function() {
    var binding, _i, _len, _ref, _results;
    _ref = this.keyBindings;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      binding = _ref[_i];
      _results.push(binding.clear());
    }
    return _results;
  },
  onSpaceKey: function(e) {
    e.preventDefault();
    if (this.props.data.get('playing')) {
      return this.props.song.pause();
    } else {
      return this.props.song.play();
    }
  },
  undo: function(e) {
    console.log("HERE");
    console.log(this.props.history);
    return this.props.history.undo();
  },
  redo: function() {
    return this.props.history.redo();
  }
};



},{"keyboardjs":77}],38:[function(require,module,exports){
module.exports = {
  getInitialState: function() {
    return {
      height: 0,
      width: 0
    };
  },
  updateDimensions: function(e) {
    var el;
    el = this.refs.container.getDOMNode();
    return this.setState({
      width: el.clientWidth,
      height: el.clientHeight
    });
  },
  componentDidMount: function() {
    this.updateDimensions();
    return window.addEventListener('resize', this.updateDimensions);
  },
  componentWillUnmount: function() {
    return window.removeEventListener('resize', this.updateDimensions);
  }
};



},{}],39:[function(require,module,exports){
module.exports = {
  dragStart: function(e) {
    this.props.updateDragging(parseInt(e.currentTarget.dataset.id));
    this.props.selectTrack(parseInt(e.currentTarget.dataset.id));
    e.dataTransfer.effectAllowed = 'move';
    return e.dataTransfer.setData('text/html', null);
  },
  dragEnd: function() {
    return this.props.updateDragging(null);
  },
  dragOver: function(e) {
    var append, from, height, items, over, relX, relY, to;
    e.preventDefault();
    over = e.currentTarget;
    relX = e.clientX - over.getBoundingClientRect().left;
    relY = e.clientY - over.getBoundingClientRect().top;
    height = over.offsetHeight / 2;
    append = relY > height;
    from = this.props.dragging;
    to = Number(over.dataset.id);
    if (append) {
      to += 1;
    }
    if (from < to) {
      to -= 1;
    }
    if (from === to) {
      return;
    }
    items = this.props.items.get().slice(0);
    items.splice(to, 0, items.splice(from, 1)[0]);
    this.props.items.set([], items);
    this.props.updateDragging(to);
    return this.props.selectTrack(to);
  },
  isDragging: function() {
    return this.props.dragging === this.props.index;
  }
};



},{}],40:[function(require,module,exports){
module.exports = {
  update: function(prop, pre) {
    return (function(_this) {
      return function(value) {
        var obj;
        obj = {};
        obj[prop] = pre ? pre(value) : value;
        return _this.setState(obj);
      };
    })(this);
  },
  updateTo: function(values) {
    return (function(_this) {
      return function() {
        return _this.setState(values);
      };
    })(this);
  }
};



},{}],41:[function(require,module,exports){
var React;

React = require('react');

module.exports = React.createClass({
  render: function() {
    return React.DOM.div(null, React.DOM.div({
      "className": "modal-backdrop"
    }), React.DOM.div({
      "className": "modal-body"
    }, this.props.children));
  }
});



},{"react":237}],42:[function(require,module,exports){
var Chooser, Knob, React;

React = require('react');

Chooser = require('./chooser');

Knob = require('./knob');

module.exports = React.createClass({
  propTypes: {
    osc: React.PropTypes.object.isRequired,
    label: React.PropTypes.string.isRequired
  },
  render: function() {
    var osc;
    osc = this.props.osc;
    return React.DOM.div({
      "className": "ui oscillator"
    }, Chooser({
      "options": ['sine', 'square', 'saw'],
      "value": osc.get('waveform'),
      "onChange": osc.bind('waveform')
    }), Knob({
      "label": "Level",
      "value": osc.get('level'),
      "onChange": osc.bind('level')
    }), Knob({
      "label": "Pitch",
      "value": osc.get('pitch'),
      "onChange": osc.bind('pitch')
    }), Knob({
      "label": "Tune",
      "value": osc.get('tune'),
      "onChange": osc.bind('tune')
    }), React.DOM.label(null, this.props.label));
  }
});



},{"./chooser":26,"./knob":31,"react":237}],43:[function(require,module,exports){
var Draggable, GridLines, KeyboardInteraction, Keys, MouseInteraction, Notes, OverrideScrolling, PlaybackMarker, React, ScaleHandle, Selection, SizeMeasurable;

React = require('react');

SizeMeasurable = require('./mixins/size_measurable');

Draggable = require('./mixins/draggable');

OverrideScrolling = require('./piano_roll/mixins/override_scrolling');

MouseInteraction = require('./piano_roll/mixins/mouse_interaction');

KeyboardInteraction = require('./piano_roll/mixins/keyboard_interaction');

ScaleHandle = require('./scale_handle');

GridLines = require('./piano_roll/grid_lines');

Keys = require('./piano_roll/keys');

Notes = require('./piano_roll/notes');

PlaybackMarker = require('./piano_roll/playback_marker');

Selection = require('./piano_roll/selection');

module.exports = React.createClass({
  mixins: [SizeMeasurable, Draggable, OverrideScrolling, MouseInteraction, KeyboardInteraction, React.addons.PureRenderMixin],
  propTypes: {
    data: React.PropTypes.object.isRequired,
    sequence: React.PropTypes.object.isRequired
  },
  getInitialState: function() {
    return {
      selectedNotes: [],
      quantization: 4,
      lineWidth: 1.5,
      keyWidth: 40,
      resizeHandleWidth: 10
    };
  },
  updateLoopSize: function(e) {
    var value;
    value = parseFloat(e.target.value);
    this.props.sequence.set('loopSize', value);
    return this.setState({
      xScale: value
    });
  },
  updateQuantization: function(e) {
    var value;
    value = parseFloat(e.target.value);
    return this.setState({
      quantization: value
    });
  },
  updateXScale: function(scale) {
    var loopSize, xScale, xScroll;
    loopSize = this.props.sequence.get('loopSize');
    xScale = Math.round(scale * this.state.quantization) / this.state.quantization;
    xScale = Math.min(loopSize, xScale);
    xScroll = Math.min(this.state.xScroll, loopSize - xScale);
    return this.setState({
      xScale: xScale,
      xScroll: xScroll
    });
  },
  updateYScale: function(scale) {
    var yScale, yScroll;
    yScale = Math.round(scale);
    yScroll = Math.min(this.state.yScroll, 128 - this.state.yScale);
    return this.setState({
      yScale: yScale,
      yScroll: yScroll
    });
  },
  updateNotes: function(changes) {
    var changedNotes, ends, keys, loopSize, maxEnd, maxKey, minKey, minStart, notes, starts, stateChanges;
    notes = this.props.sequence.get('notes');
    loopSize = this.props.sequence.get('loopSize');
    changedNotes = Object.keys(changes).map((function(_this) {
      return function(id) {
        return {
          key: changes[id].key != null ? changes[id].key : notes[id].key,
          start: changes[id].start != null ? changes[id].start : notes[id].start,
          length: changes[id].length != null ? changes[id].length : notes[id].length
        };
      };
    })(this));
    keys = changedNotes.map(function(note) {
      return note.key;
    });
    starts = changedNotes.map(function(note) {
      return note.start;
    });
    ends = changedNotes.map(function(note) {
      return note.start + note.length;
    });
    minKey = Math.min.apply(null, keys);
    maxKey = Math.max.apply(null, keys);
    minStart = Math.min.apply(null, starts);
    maxEnd = Math.max.apply(null, ends);
    if (minKey < 0 || maxKey > 127) {
      return false;
    }
    if (minStart < 0 || maxEnd > loopSize) {
      return false;
    }
    stateChanges = {};
    if (minKey < this.state.yScroll && maxKey <= this.state.yScroll + this.state.yScale) {
      stateChanges.yScroll = minKey;
    }
    if (maxKey >= this.state.yScroll + this.state.yScale && minKey > this.state.yScroll) {
      stateChanges.yScroll = maxKey - this.state.yScale + 1;
    }
    if (minStart < this.state.xScroll && maxEnd <= this.state.xScroll + this.state.xScale) {
      stateChanges.xScroll = minStart;
    }
    if (maxEnd >= this.state.xScroll + this.state.xScale && minStart > this.state.xScroll) {
      stateChanges.xScroll = maxEnd - this.state.xScale;
    }
    this.props.sequence.merge({
      notes: changes
    }, true);
    return this.setState(stateChanges);
  },
  render: function() {
    var gridWidth, innerStyle, outerStyle;
    outerStyle = {
      width: this.state.width + 2 * this.state.scrollPadding,
      height: this.state.height + 2 * this.state.scrollPadding
    };
    innerStyle = {
      top: this.state.scrollPadding,
      left: this.state.scrollPadding
    };
    gridWidth = Math.max(0, this.state.width - this.state.keyWidth);
    return React.DOM.div({
      "className": "ui piano-roll"
    }, React.DOM.div({
      "className": "body",
      "ref": 'container',
      "onScroll": this.overrideScrolling
    }, React.DOM.div({
      "className": "outer",
      "style": outerStyle
    }, React.DOM.div({
      "className": "inner",
      "style": innerStyle
    }, Keys({
      "width": this.state.keyWidth - this.state.lineWidth,
      "height": this.state.height,
      "yScroll": this.state.yScroll,
      "yScale": this.state.yScale,
      "keyWidth": this.state.keyWidth,
      "onClick": this.onClickKeys
    }), React.DOM.div({
      "className": 'grid',
      "ref": 'grid'
    }, React.DOM.svg({
      "width": gridWidth,
      "height": this.state.height,
      "onMouseDown": this.onMouseDownGrid,
      "onMouseUp": this.onMouseUpGrid,
      "onClick": this.onClickGrid,
      "onDoubleClick": this.onDoubleClickGrid
    }, PlaybackMarker({
      "position": this.props.data.get('position'),
      "loopSize": this.props.sequence.get('loopSize'),
      "width": gridWidth,
      "height": this.state.height,
      "xScroll": this.state.xScroll,
      "xScale": this.state.xScale,
      "quantization": this.state.quantization
    }), GridLines({
      "width": gridWidth,
      "height": this.state.height,
      "yScale": this.state.yScale,
      "xScale": this.state.xScale,
      "yScroll": this.state.yScroll,
      "xScroll": this.state.xScroll,
      "quantization": this.state.quantization
    }), Selection({
      "selectionOrigin": this.state.selectionOrigin,
      "selectionPosition": this.state.selectionPosition,
      "width": gridWidth,
      "height": this.state.height,
      "yScale": this.state.yScale,
      "xScale": this.state.xScale,
      "yScroll": this.state.yScroll,
      "xScroll": this.state.xScroll,
      "quantization": this.state.quantization
    }), Notes({
      "notes": this.props.sequence.get('notes'),
      "selectedNotes": this.state.selectedNotes,
      "dragOriginalValue": this.originalValue,
      "translateTarget": this.state.translateTarget,
      "resizeTarget": this.state.resizeTarget,
      "width": gridWidth,
      "height": this.state.height,
      "yScale": this.state.yScale,
      "xScale": this.state.xScale,
      "yScroll": this.state.yScroll,
      "xScroll": this.state.xScroll,
      "lineWidth": this.state.lineWidth,
      "quantization": this.state.quantization,
      "onMouseDown": this.onMouseDownNote,
      "onMouseMove": this.onMouseMoveNote,
      "onMouseOut": this.onMouseOutNote,
      "onDoubleClick": this.onDoubleClickNote
    })))))), React.DOM.div({
      "className": "view-controls"
    }, React.DOM.div({
      "className": "setting"
    }, React.DOM.label(null, "Grid"), React.DOM.select({
      "value": this.state.quantization,
      "onChange": this.updateQuantization
    }, React.DOM.option({
      "value": "1"
    }, "1"), React.DOM.option({
      "value": "2"
    }, "1\x2F2"), React.DOM.option({
      "value": "3"
    }, "1\x2F3"), React.DOM.option({
      "value": "4"
    }, "1\x2F4"), React.DOM.option({
      "value": "6"
    }, "1\x2F6"), React.DOM.option({
      "value": "8"
    }, "1\x2F8"), React.DOM.option({
      "value": "12"
    }, "1\x2F12"), React.DOM.option({
      "value": "16"
    }, "1\x2F16"))), React.DOM.div({
      "className": "setting"
    }, React.DOM.label(null, "Length"), React.DOM.select({
      "value": this.props.sequence.get('loopSize'),
      "onChange": this.updateLoopSize
    }, React.DOM.option({
      "value": "1"
    }, "1"), React.DOM.option({
      "value": "2"
    }, "2"), React.DOM.option({
      "value": "4"
    }, "4"), React.DOM.option({
      "value": "8"
    }, "8"), React.DOM.option({
      "value": "16"
    }, "16"), React.DOM.option({
      "value": "32"
    }, "32"), React.DOM.option({
      "value": "64"
    }, "64"))), ScaleHandle({
      "min": this.state.minYScale,
      "max": this.state.maxYScale,
      "value": this.state.yScale,
      "onChange": this.updateYScale
    }, React.DOM.span({
      "className": "icon icon-arrow-up"
    }), React.DOM.span({
      "className": "icon icon-arrow-down"
    })), ScaleHandle({
      "min": this.state.minXScale,
      "max": this.state.maxXScale,
      "value": this.state.xScale,
      "onChange": this.updateXScale
    }, React.DOM.span({
      "className": "icon icon-arrow-left"
    }), React.DOM.span({
      "className": "icon icon-arrow-right"
    }))));
  }
});



},{"./mixins/draggable":36,"./mixins/size_measurable":38,"./piano_roll/grid_lines":44,"./piano_roll/keys":45,"./piano_roll/mixins/keyboard_interaction":46,"./piano_roll/mixins/mouse_interaction":47,"./piano_roll/mixins/override_scrolling":48,"./piano_roll/notes":49,"./piano_roll/playback_marker":50,"./piano_roll/selection":51,"./scale_handle":55,"react":237}],44:[function(require,module,exports){
var React, keyPattern;

React = require('react/addons');

keyPattern = [true, false, true, false, true, true, false, true, false, true, false, true];

module.exports = React.createClass({
  mixins: [React.addons.PureRenderMixin],
  propTypes: {
    width: React.PropTypes.number.isRequired,
    height: React.PropTypes.number.isRequired,
    yScale: React.PropTypes.number.isRequired,
    xScale: React.PropTypes.number.isRequired,
    yScroll: React.PropTypes.number.isRequired,
    xScroll: React.PropTypes.number.isRequired,
    quantization: React.PropTypes.number.isRequired
  },
  render: function() {
    var col, cols, els, height, i, maxCol, maxRow, minCol, minRow, quantization, row, rows, squareHeight, squareWidth, width, x, y, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _n, _o, _results, _results1;
    width = this.props.width;
    height = this.props.height;
    squareHeight = height / this.props.yScale;
    quantization = this.props.quantization;
    cols = this.props.xScale * quantization;
    squareWidth = width / cols;
    els = [];
    minRow = this.props.yScroll;
    maxRow = minRow + this.props.yScale;
    rows = (function() {
      _results = [];
      for (var _i = minRow; minRow <= maxRow ? _i < maxRow : _i > maxRow; minRow <= maxRow ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this);
    minCol = this.props.xScroll * quantization;
    maxCol = minCol + this.props.xScale * quantization;
    cols = (function() {
      _results1 = [];
      for (var _j = minCol; minCol <= maxCol ? _j < maxCol : _j > maxCol; minCol <= maxCol ? _j++ : _j--){ _results1.push(_j); }
      return _results1;
    }).apply(this);
    for (i = _k = 0, _len = rows.length; _k < _len; i = ++_k) {
      row = rows[i];
      if (!keyPattern[row % 12]) {
        y = height - (i + 1) * squareHeight;
        els.push(React.DOM.rect({
          "key": 's' + i,
          "x": 0.,
          "y": y,
          "width": width,
          "height": squareHeight,
          "className": 'shade'
        }));
      }
    }
    for (i = _l = 0, _len1 = rows.length; _l < _len1; i = ++_l) {
      row = rows[i];
      if (row % 12 === 5) {
        y = (rows.length - i) * squareHeight;
        els.push(React.DOM.line({
          "key": 'h' + i,
          "x1": 0.,
          "y1": y,
          "x2": width,
          "y2": y
        }));
      }
    }
    for (i = _m = 0, _len2 = cols.length; _m < _len2; i = ++_m) {
      col = cols[i];
      if (col % quantization !== 0) {
        x = i * squareWidth;
        els.push(React.DOM.line({
          "key": 'v' + i,
          "x1": x,
          "y1": 0.,
          "x2": x,
          "y2": height
        }));
      }
    }
    for (i = _n = 0, _len3 = rows.length; _n < _len3; i = ++_n) {
      row = rows[i];
      if (row % 12 === 0) {
        y = (rows.length - i) * squareHeight;
        els.push(React.DOM.line({
          "key": 'hs' + i,
          "x1": 0.,
          "y1": y,
          "x2": width,
          "y2": y,
          "className": 'strong'
        }));
      }
    }
    for (i = _o = 0, _len4 = cols.length; _o < _len4; i = ++_o) {
      col = cols[i];
      if (i !== 0 && col % quantization === 0) {
        x = i * squareWidth;
        els.push(React.DOM.line({
          "key": 'vs' + i,
          "x1": x,
          "y1": 0.,
          "x2": x,
          "y2": height,
          "className": 'strong'
        }));
      }
    }
    return React.DOM.g(null, els);
  }
});



},{"react/addons":78}],45:[function(require,module,exports){
var React, keyPattern;

React = require('react/addons');

keyPattern = [true, false, true, false, true, true, false, true, false, true, false, true];

module.exports = React.createClass({
  mixins: [React.addons.PureRenderMixin],
  propTypes: {
    height: React.PropTypes.number.isRequired,
    yScroll: React.PropTypes.number.isRequired,
    yScale: React.PropTypes.number.isRequired,
    keyWidth: React.PropTypes.number.isRequired
  },
  render: function() {
    var els, height, i, keyHeight, keyWidth, maxRow, minRow, row, rows, text, y, _i, _j, _k, _len, _len1, _results;
    height = this.props.height;
    keyHeight = height / this.props.yScale;
    keyWidth = this.props.keyWidth;
    els = [];
    minRow = this.props.yScroll;
    maxRow = minRow + this.props.yScale;
    rows = (function() {
      _results = [];
      for (var _i = minRow; minRow <= maxRow ? _i < maxRow : _i > maxRow; minRow <= maxRow ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this);
    for (i = _j = 0, _len = rows.length; _j < _len; i = ++_j) {
      row = rows[i];
      if (!keyPattern[row % 12]) {
        y = height - (i + 1) * keyHeight;
        text = null;
        els.push(React.DOM.rect({
          "key": 'k' + i,
          "x": 0.,
          "y": y,
          "width": keyWidth,
          "height": keyHeight
        }));
      }
    }
    for (i = _k = 0, _len1 = rows.length; _k < _len1; i = ++_k) {
      row = rows[i];
      if (row % 12 === 0) {
        y = height - (i + 0.5) * keyHeight;
        text = "C " + (Math.floor(row / 12) - 2);
        els.push(React.DOM.text({
          "key": 't' + i,
          "x": keyWidth - 4,
          "y": y
        }, text));
      }
    }
    return React.DOM.div({
      "className": 'keys'
    }, React.DOM.svg({
      "width": keyWidth,
      "height": height,
      "onClick": this.props.onClick
    }, els));
  }
});



},{"react/addons":78}],46:[function(require,module,exports){
var Keyboard,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

Keyboard = require('keyboardjs');

module.exports = {
  componentDidMount: function() {
    return this.keyBindings = [Keyboard.on('backspace', this.onBackspaceKey), Keyboard.on('left, right, up, down', this.onArrowKey)];
  },
  componentWillUnmount: function() {
    var binding, _i, _len, _ref, _results;
    _ref = this.keyBindings;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      binding = _ref[_i];
      _results.push(binding.clear());
    }
    return _results;
  },
  onBackspaceKey: function(e) {
    e.preventDefault();
    return this.props.sequence.batched((function(_this) {
      return function() {
        var id, _i, _len, _ref, _results;
        _ref = _this.state.selectedNotes;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          id = _ref[_i];
          _results.push(_this.props.sequence["delete"](['notes', id]));
        }
        return _results;
      };
    })(this));
  },
  onArrowKey: function(e) {
    var changes, distance, id, note, _i, _len, _ref;
    e.preventDefault();
    changes = {};
    _ref = this.state.selectedNotes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      id = _ref[_i];
      note = this.props.sequence.get(['notes', id]);
      if (e.keyCode === 37) {
        changes[id] = {
          start: note.start - 1 / this.state.quantization
        };
      } else if (e.keyCode === 38) {
        distance = __indexOf.call(Keyboard.activeKeys(), 'shift') >= 0 ? 12 : 1;
        changes[id] = {
          key: note.key + distance
        };
      } else if (e.keyCode === 39) {
        changes[id] = {
          start: note.start + 1 / this.state.quantization
        };
      } else if (e.keyCode === 40) {
        distance = __indexOf.call(Keyboard.activeKeys(), 'shift') >= 0 ? 12 : 1;
        changes[id] = {
          key: note.key - distance
        };
      }
    }
    return this.updateNotes(changes);
  }
};



},{"keyboardjs":77}],47:[function(require,module,exports){
var Keyboard, Pointer, cuid,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

Keyboard = require('keyboardjs');

Pointer = require('../../../util/pointer');

cuid = require('cuid');

module.exports = {
  getInitialState: function() {
    return {
      selectionOrigin: null,
      selectionPosition: null,
      resizeTarget: null,
      resizeDirection: null,
      translateTarget: null
    };
  },
  getRelativePosition: function(_arg) {
    var height, key, left, start, top, width, x, y, _ref;
    x = _arg.x, y = _arg.y;
    _ref = this.refs.grid.getDOMNode().getBoundingClientRect(), top = _ref.top, left = _ref.left;
    height = this.state.height;
    width = this.state.width - this.state.keyWidth;
    key = Math.floor((height - y + top) / height * this.state.yScale) + this.state.yScroll;
    start = Math.floor((x - left) / width * this.state.xScale * this.state.quantization) / this.state.quantization + this.state.xScroll;
    return {
      key: key,
      start: start
    };
  },
  notesSelectedBy: function(from, to) {
    var id, key, length, maxKey, maxStart, minEnd, minKey, notes, start, _ref, _ref1;
    minKey = Math.min(from.key, to.key);
    maxKey = Math.max(from.key, to.key);
    minEnd = Math.min(from.start, to.start);
    maxStart = Math.max(from.start, to.start);
    notes = [];
    _ref = this.props.sequence.get('notes');
    for (id in _ref) {
      _ref1 = _ref[id], key = _ref1.key, start = _ref1.start, length = _ref1.length;
      if (key >= minKey && key <= maxKey && start + length > minEnd && start <= maxStart) {
        notes.push(id);
      }
    }
    return notes;
  },
  onClickKeys: function(e) {},
  onMouseDownGrid: function(e) {
    if (__indexOf.call(Keyboard.activeKeys(), 'shift') < 0) {
      this.setState({
        selectedNotes: []
      });
    }
    this.draggableOnMouseDown(e);
    return this.setState({
      selectionOrigin: this.getRelativePosition({
        x: e.clientX,
        y: e.clientY
      })
    });
  },
  onClickGrid: function(e) {},
  onDoubleClickGrid: function(e) {
    var changes, id, key, start, _ref;
    _ref = this.getRelativePosition({
      x: e.clientX,
      y: e.clientY
    }), key = _ref.key, start = _ref.start;
    id = cuid();
    changes = {};
    changes[id] = {
      id: id,
      key: key,
      start: start,
      length: 1 / this.state.quantization
    };
    return this.props.sequence.merge({
      notes: changes
    });
  },
  onMouseMoveNote: function(e) {
    var handleSize, position;
    position = e.target.getBoundingClientRect();
    handleSize = Math.max(0, Math.min(this.state.resizeHandleWidth, (position.width - this.state.resizeHandleWidth) / 2));
    if (position.left > e.clientX - handleSize) {
      return this.noteHoverCursor = Pointer.set('w-resize', 1, this.noteHoverCursor);
    } else if (position.right < e.clientX + handleSize) {
      return this.noteHoverCursor = Pointer.set('e-resize', 1, this.noteHoverCursor);
    } else {
      return Pointer.clear(this.noteHoverCursor);
    }
  },
  onMouseOutNote: function(e) {
    return Pointer.clear(this.noteHoverCursor);
  },
  onMouseDownNote: function(e) {
    var handleSize, id, note, noteId, position, selectedNotes, stateChanges, _ref;
    e.stopPropagation();
    id = e.target.dataset.id;
    position = e.target.getBoundingClientRect();
    if (__indexOf.call(Keyboard.activeKeys(), 'shift') >= 0) {
      selectedNotes = this.state.selectedNotes.slice(0);
      if (__indexOf.call(this.state.selectedNotes, id) >= 0) {
        selectedNotes.splice(selectedNotes.indexOf(id), 1);
      } else {
        selectedNotes.push(id);
      }
    } else {
      if (__indexOf.call(this.state.selectedNotes, id) < 0) {
        selectedNotes = [id];
      } else {
        selectedNotes = this.state.selectedNotes;
      }
    }
    stateChanges = {
      selectedNotes: selectedNotes
    };
    this.draggableOnMouseDown(e);
    this.originalValue = {};
    _ref = this.props.sequence.get('notes');
    for (noteId in _ref) {
      note = _ref[noteId];
      if (selectedNotes.indexOf(noteId) >= 0) {
        this.originalValue[noteId] = note;
      }
    }
    this.dragOrigin = this.props.sequence.get(['notes', id]);
    handleSize = Math.max(0, Math.min(this.state.resizeHandleWidth, (position.width - this.state.resizeHandleWidth) / 2));
    if (position.left > e.clientX - handleSize) {
      stateChanges.resizeTarget = id;
      stateChanges.resizeDirection = 'left';
      this.dragActionCursor = Pointer.set('w-resize', 2, this.dragActionCursor);
    } else if (position.right < e.clientX + handleSize) {
      stateChanges.resizeTarget = id;
      stateChanges.resizeDirection = 'right';
      this.dragActionCursor = Pointer.set('e-resize', 2, this.dragActionCursor);
    } else {
      stateChanges.translateTarget = id;
      this.dragActionCursor = Pointer.set('move', 2, this.dragActionCursor);
    }
    return this.setState(stateChanges);
  },
  onDoubleClickNote: function(e) {
    e.stopPropagation();
    return this.props.sequence["delete"](['notes', e.target.dataset.id]);
  },
  onDrag: function(delta, e) {
    var i, id, keyDelta, minLength, note, notes, position, start, startDelta, _ref, _ref1, _ref2;
    position = this.getRelativePosition({
      x: e.clientX,
      y: e.clientY
    });
    if (this.state.selectionOrigin != null) {
      return this.setState({
        selectionPosition: position
      });
    } else {
      keyDelta = position.key - this.dragOrigin.key;
      startDelta = position.start - this.dragOrigin.start;
      notes = {};
      if (this.state.translateTarget != null) {
        _ref = this.originalValue;
        for (id in _ref) {
          note = _ref[id];
          notes[id] = {
            key: note.key + keyDelta,
            start: note.start + startDelta
          };
        }
      }
      if (this.state.resizeTarget != null) {
        minLength = 1 / this.state.quantization;
        if (this.state.resizeDirection === 'right') {
          _ref1 = this.originalValue;
          for (id in _ref1) {
            note = _ref1[id];
            notes[id] = {
              length: Math.max(minLength, note.length + startDelta - this.dragOrigin.length + minLength)
            };
          }
        }
        if (this.state.resizeDirection === 'left') {
          _ref2 = this.originalValue;
          for (i in _ref2) {
            note = _ref2[i];
            start = note.start + startDelta;
            start = Math.max(0, start);
            start = Math.min(start, note.start + note.length - minLength);
            notes[i] = {
              start: start,
              length: note.start + note.length - start
            };
          }
        }
      }
      return this.updateNotes(notes);
    }
  },
  onDragEnd: function(e) {
    var changes, id, key, length, position, selectedNotes, start, stateChanges, _ref, _ref1;
    if ((this.originalValue != null) && __indexOf.call(Keyboard.activeKeys(), 'alt') >= 0) {
      changes = {};
      _ref = this.originalValue;
      for (id in _ref) {
        _ref1 = _ref[id], key = _ref1.key, start = _ref1.start, length = _ref1.length;
        id = cuid();
        changes[id] = {
          id: id,
          key: key,
          start: start,
          length: length
        };
      }
      this.props.sequence.merge({
        notes: changes
      });
    }
    stateChanges = {
      translateTarget: null,
      resizeTarget: null,
      resizeDirection: null,
      selectionOrigin: null,
      selectionPosition: null
    };
    if (this.state.selectionOrigin != null) {
      position = this.getRelativePosition({
        x: e.clientX,
        y: e.clientY
      });
      selectedNotes = this.notesSelectedBy(this.state.selectionOrigin, position);
      if (__indexOf.call(Keyboard.activeKeys(), 'shift') >= 0) {
        selectedNotes = this.state.selectedNotes.slice(0).concat(selectedNotes);
      }
      stateChanges.selectedNotes = selectedNotes;
    }
    this.setState(stateChanges);
    this.originalValue = null;
    this.dragOrigin = null;
    return Pointer.clear(this.dragActionCursor);
  }
};



},{"../../../util/pointer":67,"cuid":76,"keyboardjs":77}],48:[function(require,module,exports){
module.exports = {
  getInitialState: function() {
    return {
      xScale: 1,
      yScale: 12,
      xScroll: 0,
      yScroll: 0,
      minXScale: 1,
      maxXScale: 64,
      minYScale: 12,
      maxYScale: 128,
      scrollPadding: 500
    };
  },
  componentDidMount: function() {
    var el;
    el = this.refs.container.getDOMNode();
    setTimeout((function(_this) {
      return function() {
        el.scrollTop = _this.state.scrollPadding;
        return el.scrollLeft = _this.state.scrollPadding;
      };
    })(this));
    this.scrollDeltaY = 0;
    this.scrollDeltaX = 0;
    return this.autoScaleViewport(this.props.sequence);
  },
  componentWillReceiveProps: function(nextProps) {
    if (nextProps.sequence.get('_id') !== this.props.sequence.get('_id')) {
      return this.autoScaleViewport(nextProps.sequence);
    }
  },
  autoScaleViewport: function(sequence) {
    var id, maxKey, minKey, note, size, _ref;
    minKey = 128;
    maxKey = 0;
    _ref = sequence.get('notes');
    for (id in _ref) {
      note = _ref[id];
      if (!note) {
        return;
      }
      if (note.key < minKey) {
        minKey = note.key;
      }
      if (note.key > maxKey) {
        maxKey = note.key;
      }
    }
    size = Math.max(this.state.minYScale, maxKey - minKey) + 12;
    return this.setState({
      xScroll: 0,
      xScale: sequence.get('loopSize'),
      yScroll: Math.max(0, Math.ceil((minKey + maxKey - size) / 2)),
      yScale: size
    });
  },
  overrideScrolling: function(e) {
    var el, loopSize, quanta, xQuantum, xScroll, yQuantum, yScroll;
    e.preventDefault();
    e.stopPropagation();
    el = e.target;
    xQuantum = this.state.width / this.state.xScale / this.state.quantization;
    yQuantum = this.state.height / this.state.yScale;
    loopSize = this.props.sequence.get('loopSize');
    this.scrollDeltaX += el.scrollLeft - this.state.scrollPadding;
    this.scrollDeltaY += this.state.scrollPadding - el.scrollTop;
    el.scrollTop = el.scrollLeft = this.state.scrollPadding;
    if (Math.abs(this.scrollDeltaX) > xQuantum) {
      quanta = (this.scrollDeltaX > 0 ? Math.floor : Math.ceil)(this.scrollDeltaX / xQuantum);
      this.scrollDeltaX -= quanta * xQuantum;
      xScroll = Math.min(Math.max(0, this.state.xScroll + quanta / this.state.quantization), loopSize - this.state.xScale);
    }
    if (Math.abs(this.scrollDeltaY) > yQuantum) {
      quanta = (this.scrollDeltaX > 0 ? Math.floor : Math.ceil)(this.scrollDeltaY / yQuantum);
      this.scrollDeltaY -= quanta * yQuantum;
      yScroll = Math.min(Math.max(0, this.state.yScroll + quanta), 128 - this.state.yScale);
    }
    if ((xScroll != null) || (yScroll != null)) {
      return this.setState({
        xScroll: xScroll != null ? xScroll : this.state.xScroll,
        yScroll: yScroll != null ? yScroll : this.state.yScroll
      });
    }
  }
};



},{}],49:[function(require,module,exports){
var Keyboard, React,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

React = require('react/addons');

Keyboard = require('keyboardjs');

module.exports = React.createClass({
  mixins: [React.addons.PureRenderMixin],
  getDefaultProps: function() {
    return {
      radius: 0
    };
  },
  propTypes: {
    notes: React.PropTypes.object.isRequired,
    selectedNotes: React.PropTypes.array.isRequired,
    dragOriginalValue: React.PropTypes.object,
    translateTarget: React.PropTypes.string,
    resizeTarget: React.PropTypes.string,
    width: React.PropTypes.number.isRequired,
    height: React.PropTypes.number.isRequired,
    lineWidth: React.PropTypes.number.isRequired,
    yScale: React.PropTypes.number.isRequired,
    xScale: React.PropTypes.number.isRequired,
    yScroll: React.PropTypes.number.isRequired,
    xScroll: React.PropTypes.number.isRequired,
    quantization: React.PropTypes.number.isRequired,
    onMouseDown: React.PropTypes.func,
    onMouseMove: React.PropTypes.func,
    onMouseOut: React.PropTypes.func,
    onClick: React.PropTypes.func,
    onDoubleClick: React.PropTypes.func
  },
  noteOnScreen: function(note) {
    return note.start <= this.props.xScroll + this.props.xScale && note.start + note.length >= this.props.xScroll && note.key >= this.props.yScroll && note.key <= this.props.yScroll + this.props.yScale;
  },
  render: function() {
    var className, cols, els, h, height, id, lineWidth, maxCol, maxRow, minCol, minRow, note, quantization, rows, squareHeight, squareWidth, w, width, x, y, _i, _j, _ref, _ref1, _ref2, _results, _results1;
    if (!(this.props.width > 0 && this.props.height > 0)) {
      return React.DOM.g(null);
    }
    width = this.props.width;
    height = this.props.height;
    lineWidth = this.props.lineWidth;
    squareHeight = height / this.props.yScale;
    quantization = this.props.quantization;
    cols = this.props.xScale * quantization;
    squareWidth = width / cols;
    els = [];
    minRow = this.props.yScroll;
    maxRow = minRow + this.props.yScale;
    rows = (function() {
      _results = [];
      for (var _i = minRow; minRow <= maxRow ? _i < maxRow : _i > maxRow; minRow <= maxRow ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this);
    minCol = this.props.xScroll * quantization;
    maxCol = minCol + this.props.xScale * quantization;
    cols = (function() {
      _results1 = [];
      for (var _j = minCol; minCol <= maxCol ? _j < maxCol : _j > maxCol; minCol <= maxCol ? _j++ : _j--){ _results1.push(_j); }
      return _results1;
    }).apply(this);
    if ((this.props.translateTarget != null) && __indexOf.call(Keyboard.activeKeys(), 'alt') >= 0) {
      _ref = this.props.dragOriginalValue;
      for (id in _ref) {
        note = _ref[id];
        if (!this.noteOnScreen(note)) {
          continue;
        }
        x = (note.start - this.props.xScroll) * squareWidth * quantization + lineWidth / 2;
        y = (this.props.yScale + this.props.yScroll - note.key - 1) * squareHeight + lineWidth / 2;
        w = squareWidth * note.length * this.props.quantization - this.props.lineWidth;
        h = squareHeight - this.props.lineWidth;
        els.push(React.DOM.rect({
          "className": "ghost note",
          "key": 'g' + id,
          "x": x,
          "y": y,
          "width": w,
          "height": h,
          "rx": this.props.radius,
          "ry": this.props.radius
        }));
      }
    }
    _ref1 = this.props.notes;
    for (id in _ref1) {
      note = _ref1[id];
      if (!this.noteOnScreen(note)) {
        continue;
      }
      x = (note.start - this.props.xScroll) * squareWidth * this.props.quantization + lineWidth / 2;
      y = (this.props.yScale + this.props.yScroll - note.key - 1) * squareHeight + lineWidth / 2;
      w = squareWidth * note.length * this.props.quantization - lineWidth;
      h = squareHeight - lineWidth;
      className = 'note';
      if (_ref2 = note.id, __indexOf.call(this.props.selectedNotes, _ref2) >= 0) {
        className += ' selected';
      }
      if (this.props.translateTarget === note.id || this.props.resizeTarget === note.id) {
        className += ' active';
      }
      els.push(React.DOM.rect({
        "className": className,
        "key": 'n' + id,
        "x": x,
        "y": y,
        "width": w,
        "height": h,
        "rx": this.props.radius,
        "ry": this.props.radius,
        "data-id": id,
        "onMouseDown": this.props.onMouseDown,
        "onMouseMove": this.props.onMouseMove,
        "onMouseOut": this.props.onMouseOut,
        "onClick": this.props.onClick,
        "onDoubleClick": this.props.onDoubleClick
      }));
    }
    return React.DOM.g(null, els);
  }
});



},{"keyboardjs":77,"react/addons":78}],50:[function(require,module,exports){
var React;

React = require('react/addons');

module.exports = React.createClass({
  mixins: [React.addons.PureRenderMixin],
  propTypes: {
    position: React.PropTypes.number.isRequired,
    loopSize: React.PropTypes.number.isRequired,
    width: React.PropTypes.number.isRequired,
    height: React.PropTypes.number.isRequired,
    xScale: React.PropTypes.number.isRequired,
    xScroll: React.PropTypes.number.isRequired,
    quantization: React.PropTypes.number.isRequired
  },
  render: function() {
    var cols, el, height, position, squareWidth, width, x;
    width = this.props.width;
    height = this.props.height;
    position = this.props.position % this.props.loopSize;
    cols = this.props.xScale * this.props.quantization;
    squareWidth = width / cols;
    if (position >= this.props.xScroll && position <= this.props.xScroll + this.props.xScale) {
      x = Math.floor(position * this.props.quantization) * squareWidth;
      el = React.DOM.rect({
        "className": "playback",
        "key": 'pb',
        "x": x,
        "y": 0.,
        "width": 3.,
        "height": height
      });
    }
    return React.DOM.g(null, el);
  }
});



},{"react/addons":78}],51:[function(require,module,exports){
var React;

React = require('react/addons');

module.exports = React.createClass({
  mixins: [React.addons.PureRenderMixin],
  propTypes: {
    selectionOrigin: React.PropTypes.object,
    selectionPosition: React.PropTypes.object,
    width: React.PropTypes.number.isRequired,
    height: React.PropTypes.number.isRequired,
    yScale: React.PropTypes.number.isRequired,
    xScale: React.PropTypes.number.isRequired,
    yScroll: React.PropTypes.number.isRequired,
    xScroll: React.PropTypes.number.isRequired,
    quantization: React.PropTypes.number.isRequired
  },
  render: function() {
    var beatWidth, cols, el, fromBeat, fromKey, h, height, keyWidth, quantization, selectionOrigin, selectionPosition, squareHeight, squareWidth, w, width, x, y;
    width = this.props.width;
    height = this.props.height;
    selectionOrigin = this.props.selectionOrigin;
    selectionPosition = this.props.selectionPosition;
    squareHeight = height / this.props.yScale;
    quantization = this.props.quantization;
    cols = this.props.xScale * quantization;
    squareWidth = width / cols;
    if ((selectionOrigin != null) && (selectionPosition != null)) {
      fromKey = Math.max(selectionOrigin.key, selectionPosition.key);
      keyWidth = Math.abs(selectionOrigin.key - selectionPosition.key);
      fromBeat = Math.min(selectionOrigin.start, selectionPosition.start);
      beatWidth = Math.abs(selectionOrigin.start - selectionPosition.start);
      x = (fromBeat - this.props.xScroll) * quantization * squareWidth;
      y = (this.props.yScale + this.props.yScroll - fromKey - 1) * squareHeight;
      w = (beatWidth * quantization + 1) * squareWidth;
      h = (keyWidth + 1) * squareHeight;
      el = React.DOM.rect({
        "className": 'selection',
        "key": 'sel',
        "x": x,
        "y": y,
        "width": w,
        "height": h
      });
    }
    return React.DOM.g(null, el);
  }
});



},{"react/addons":78}],52:[function(require,module,exports){
var React, ScaleHandle;

React = require('react');

ScaleHandle = require('./scale_handle');

module.exports = React.createClass({
  mixins: [React.addons.PureRenderMixin],
  propTypes: {
    data: React.PropTypes.object.isRequired,
    song: React.PropTypes.object.isRequired
  },
  render: function() {
    var i, playing;
    playing = this.props.data.get('playing');
    return React.DOM.div({
      "className": "ui playback-control"
    }, React.DOM.div({
      "className": "group playback"
    }, React.DOM.div({
      "className": "icon icon-play" + (playing ? ' active' : ''),
      "onClick": (playing ? this.props.song.pause : this.props.song.play)
    }), React.DOM.div({
      "className": "icon icon-record",
      "onClick": this.props.song.record
    }), React.DOM.div({
      "className": "icon icon-stop",
      "onClick": this.props.song.stop
    })), React.DOM.div({
      "className": "group tempo"
    }, React.DOM.select({
      "value": this.props.data.get('bpm'),
      "onChange": this.props.data.bind('bpm', function(e) {
        return parseInt(e.target.value);
      })
    }, (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 200; _i >= 20; i = --_i) {
        _results.push(React.DOM.option({
          "key": i,
          "value": i
        }, i, " bpm"));
      }
      return _results;
    })())), React.DOM.div({
      "className": "logo"
    }, "sinesaw"), React.DOM.div({
      "className": "group menu"
    }, React.DOM.div({
      "className": "icon icon-air"
    })));
  }
});



},{"./scale_handle":55,"react":237}],53:[function(require,module,exports){
var AudioRecorder, Meter, React, Waveform, context, defaultState, meterDecay;

React = require('react/addons');

Waveform = require('./waveform');

Meter = require('./meter');

AudioRecorder = require('../dsp/audio_recorder');

context = require('../dsp/global_context');

defaultState = {
  sampleData: null,
  error: null,
  active: false,
  playing: false,
  cropStart: 0,
  cropEnd: 1
};

meterDecay = 0.0005;

module.exports = React.createClass({
  getInitialState: function() {
    return defaultState;
  },
  onClick: function() {
    if (this.state.active) {
      return this.stop();
    } else if (this.state.sampleData == null) {
      return this.record();
    }
  },
  setCropStart: function(value) {
    return this.setState({
      cropStart: value,
      cropEnd: Math.max(value, this.state.cropStart)
    });
  },
  setCropEnd: function(value) {
    return this.setState({
      cropEnd: value,
      cropStart: Math.min(value, this.state.cropEnd)
    });
  },
  croppedSampleData: function() {
    var length;
    length = this.state.sampleData.length;
    return this.state.sampleData.subarray(Math.floor(this.state.cropStart * length), Math.floor(this.state.cropEnd * length));
  },
  record: function() {
    if (this.state.active) {
      return;
    }
    this.clear();
    return navigator.webkitGetUserMedia({
      audio: true
    }, (function(_this) {
      return function(localMediaStream) {
        var input, recorder;
        input = context.createMediaStreamSource(localMediaStream);
        recorder = new AudioRecorder(input);
        recorder.record();
        return _this.setState({
          recorder: recorder,
          active: true
        });
      };
    })(this), (function(_this) {
      return function(errorCode) {
        return _this.setState({
          error: 'Unable to access microphone'
        });
      };
    })(this));
  },
  stop: function() {
    if (!this.state.active) {
      return;
    }
    if (this.state.player) {
      this.state.player.onended = false;
      this.state.player.stop();
    }
    return this.state.recorder.stop().getSampleData((function(_this) {
      return function(sampleData) {
        return _this.setState({
          recorder: null,
          sampleData: sampleData,
          error: null,
          active: false,
          playing: false
        });
      };
    })(this));
  },
  play: function() {
    var audioBuffer, data, player;
    if (this.state.player) {
      this.state.player.onended = null;
      this.state.player.stop();
      this.state.player.disconnect(context.destination);
    }
    data = this.croppedSampleData();
    player = context.createBufferSource();
    player.connect(context.destination);
    audioBuffer = context.createBuffer(1, data.length, context.sampleRate);
    audioBuffer.getChannelData(0).set(data);
    player.buffer = audioBuffer;
    player.onended = (function(_this) {
      return function() {
        return _this.setState({
          playing: false
        });
      };
    })(this);
    player.start();
    return this.setState({
      player: player,
      playing: true
    });
  },
  clear: function() {
    return this.setState(defaultState);
  },
  confirm: function() {
    return this.props.onConfirm(this.croppedSampleData());
  },
  render: function() {
    var instruction, leftButtons, message, rightButtons, waveform;
    leftButtons = [
      React.DOM.div({
        "className": "icon icon-record " + (this.state.active ? ' active' : ''),
        "key": "r",
        "onClick": (this.state.active ? this.stop : this.record)
      })
    ];
    rightButtons = [
      React.DOM.div({
        "className": "icon icon-cross",
        "key": "c",
        "onClick": this.props.onCancel
      })
    ];
    if (this.state.sampleData != null) {
      waveform = Waveform({
        "sampleData": this.state.sampleData,
        "selectionStart": this.state.cropStart,
        "selectionEnd": this.state.cropEnd,
        "markers": {
          start: {
            value: this.state.cropStart,
            onChange: (function(_this) {
              return function(cropStart) {
                return _this.setState({
                  cropStart: cropStart
                });
              };
            })(this)
          },
          end: {
            value: this.state.cropEnd,
            onChange: (function(_this) {
              return function(cropEnd) {
                return _this.setState({
                  cropEnd: cropEnd
                });
              };
            })(this)
          }
        }
      });
      leftButtons.push(React.DOM.div({
        "className": "icon icon-play " + (this.state.playing ? ' active' : ''),
        "key": "p",
        "onClick": (this.state.playing ? this.stop : this.play)
      }));
      rightButtons.push(React.DOM.div({
        "className": "icon icon-checkmark",
        "key": "s",
        "onClick": this.confirm
      }));
    } else {
      message = this.state.error != null ? this.state.error : this.state.active ? 'Recording, click to stop' : 'Click to record';
      instruction = React.DOM.div({
        "className": "instruction"
      }, message);
    }
    return React.DOM.div({
      "className": "ui record-control"
    }, React.DOM.div({
      "className": "row sample"
    }, React.DOM.div({
      "className": "display",
      "onClick": this.onClick
    }, waveform, instruction)), React.DOM.div({
      "className": "row controls"
    }, React.DOM.div({
      "className": "left"
    }, leftButtons), React.DOM.div({
      "className": "right"
    }, rightButtons)));
  }
});



},{"../dsp/audio_recorder":3,"../dsp/global_context":5,"./meter":35,"./waveform":58,"react/addons":78}],54:[function(require,module,exports){
var React, RecordControl, Waveform, decoder;

React = require('react/addons');

Waveform = require('./waveform');

RecordControl = require('./record_control');

decoder = require('../dsp/global_context');

module.exports = React.createClass({
  range: 300,
  dragTypeDistance: 10,
  getDefaultProps: function() {
    return {
      sampleStart: 0
    };
  },
  triggerFileInput: function() {
    return this.refs.input.getDOMNode().click();
  },
  onFileSelect: function() {
    var file, reader;
    file = this.refs.input.getDOMNode().files[0];
    if (file != null) {
      reader = new FileReader;
      reader.onload = (function(_this) {
        return function(e) {
          return decoder.decodeAudioData(e.target.result, function(buffer) {
            var sampleData;
            sampleData = buffer.getChannelData(0);
            return _this.props.sampler.update(function(sampler) {
              return sampler.merge({
                sampleName: file.name,
                sampleData: sampleData
              });
            });
          });
        };
      })(this);
      return reader.readAsArrayBuffer(file);
    }
  },
  clear: function() {
    return this.props.sampler.update(function(sampler) {
      return sampler.merge({
        sampleName: null,
        sampleData: null
      });
    });
  },
  recordSample: function() {
    return this.props.app.launchModal(RecordControl({
      "onCancel": this.props.app.dismissModal,
      "onConfirm": ((function(_this) {
        return function(sampleData) {
          _this.props.sampler.merge({
            sampleName: 'recording.wav',
            sampleData: sampleData
          });
          return _this.props.app.dismissModal();
        };
      })(this))
    }));
  },
  setStart: function(value) {
    return this.props.sampler.merge({
      start: value,
      loop: Math.max(value, this.props.sampler.get('loop'))
    });
  },
  setLoop: function(value) {
    return this.props.sampler.merge({
      loop: value,
      start: Math.min(value, this.props.sampler.get('start'))
    });
  },
  render: function() {
    var loopActive, loopValue, markers, sampleData, sampleStart, sampler;
    sampler = this.props.sampler;
    sampleStart = sampler.get('start');
    loopActive = sampler.get('loopActive');
    loopValue = sampler.get('loop');
    sampleData = sampler.get('sampleData');
    markers = {};
    if (sampleStart != null) {
      markers.start = {
        value: sampleStart,
        onChange: this.setStart
      };
    }
    if (loopActive === 'loop') {
      markers.loop = {
        value: loopValue,
        onChange: this.setLoop
      };
    }
    return React.DOM.div({
      "className": "ui sample-control"
    }, React.DOM.input({
      "type": "file",
      "ref": "input",
      "onChange": this.onFileSelect
    }), React.DOM.div({
      "className": "display",
      "ref": "container",
      "onClick": (sampleData != null ? null : this.triggerFileInput)
    }, (sampleData != null ? null : React.DOM.div({
      "className": "instruction"
    }, "click to upload")), Waveform({
      "sampleData": sampleData,
      "selectionStart": sampleStart || 0,
      "selectionEnd": (loopActive === 'loop' ? loopValue : 1),
      "markers": markers
    })), React.DOM.div({
      "className": "controls"
    }, React.DOM.div({
      "className": "control",
      "onClick": this.triggerFileInput
    }, React.DOM.div({
      "className": "icon icon-arrow-up"
    })), React.DOM.div({
      "className": "control",
      "onClick": this.recordSample
    }, React.DOM.div({
      "className": "icon icon-record"
    })), React.DOM.div({
      "className": "control",
      "onClick": this.clear
    }, React.DOM.div({
      "className": "icon icon-cross"
    })), React.DOM.div({
      "className": "file-name"
    }, this.props.sampleName)), React.DOM.label(null, this.props.label));
  }
});



},{"../dsp/global_context":5,"./record_control":53,"./waveform":58,"react/addons":78}],55:[function(require,module,exports){
var Draggable, React;

React = require('react');

Draggable = require('./mixins/draggable');

module.exports = React.createClass({
  range: 300,
  mixins: [Draggable],
  getInitialState: function() {
    return {
      active: false
    };
  },
  onDragStart: function() {
    this.initialValue = (this.props.value - this.props.min) / (this.props.max - this.props.min);
    return this.setState({
      active: true
    });
  },
  onDrag: function(delta) {
    var downRange, upRange, value;
    upRange = Math.min(this.range, this.dragStartPosition.y - window.scrollY);
    downRange = Math.min(this.range, window.innerHeight + window.scrollY - this.dragStartPosition.y);
    if (delta.y < 0) {
      value = Math.max(0, this.initialValue * (downRange + delta.y) / downRange);
    } else {
      value = Math.min(1, this.initialValue + (1 - this.initialValue) * delta.y / upRange);
    }
    value = 1 * this.props.min + value * (this.props.max - this.props.min);
    return this.props.onChange(value);
  },
  onDragEnd: function() {
    this.initialValue = null;
    return this.setState({
      action: false
    });
  },
  render: function() {
    var className;
    className = 'ui scale-handle';
    if (this.state.active) {
      className += ' active';
    }
    return React.DOM.div({
      "className": className,
      "onMouseDown": this.draggableOnMouseDown
    }, this.props.children);
  }
});



},{"./mixins/draggable":36,"react":237}],56:[function(require,module,exports){
var Draggable, React, SizeMeasurable;

React = require('react');

SizeMeasurable = require('./mixins/size_measurable');

Draggable = require('./mixins/draggable');

module.exports = React.createClass({
  mixins: [SizeMeasurable, Draggable],
  propTypes: {
    value: React.PropTypes.number.isRequired,
    onChange: React.PropTypes.func.isRequired,
    disabled: React.PropTypes.bool
  },
  getInitialState: function() {
    return {
      active: false
    };
  },
  onDragStart: function() {
    this.initalValue = this.props.value;
    return this.setState({
      active: true
    });
  },
  onDrag: function(delta) {
    var value;
    if (this.props.disabled) {
      return;
    }
    value = this.initalValue + delta.y / this.state.height;
    value = Math.max(0, Math.min(value, 1));
    return this.props.onChange(value);
  },
  onDragEnd: function() {
    this.initalValue = null;
    return this.setState({
      active: false
    });
  },
  render: function() {
    var className, style;
    style = {
      top: "" + (100 * (1 - this.props.value)) + "%"
    };
    className = 'ui slider';
    if (this.state.active) {
      className += ' active';
    }
    if (this.props.disabled) {
      className += ' disabled';
    }
    return React.DOM.div({
      "className": className
    }, React.DOM.div({
      "className": "control",
      "ref": "container"
    }, React.DOM.div({
      "className": "track"
    }), React.DOM.div({
      "className": "handle",
      "style": style,
      "onMouseDown": this.draggableOnMouseDown
    })), React.DOM.label(null, this.props.label));
  }
});



},{"./mixins/draggable":36,"./mixins/size_measurable":38,"react":237}],57:[function(require,module,exports){
var AnalogSynthesizer, BasicSampler, DrumSampler, DrumSynthesizer, Knob, LoopSampler, Menu, Meter, React, ReactCSSTransitionGroup, Sortable, Track, TrackRow;

React = require('react/addons');

Sortable = require('./mixins/sortable');

Knob = require('./knob');

Meter = require('./meter');

Menu = require('./menu');

DrumSampler = require('../models/drum_sampler');

BasicSampler = require('../models/basic_sampler');

LoopSampler = require('../models/loop_sampler');

AnalogSynthesizer = require('../models/analog_synthesizer');

DrumSynthesizer = require('../models/drum_synthesizer');

Track = require('../models/track');

ReactCSSTransitionGroup = React.addons.CSSTransitionGroup;

TrackRow = React.createClass({
  mixins: [React.addons.PureRenderMixin, Sortable],
  render: function() {
    var className, instrument, track;
    track = this.props.track;
    instrument = track.cursor('instrument');
    className = 'track';
    if (this.props.selected) {
      className += ' selected';
    }
    if (this.isDragging()) {
      className += ' dragging';
    }
    return React.DOM.div({
      "className": className,
      "onClick": this.props.selectTrack,
      "draggable": true,
      "onDragStart": this.dragStart,
      "onDragEnd": this.dragEnd,
      "onDragOver": this.dragOver,
      "data-id": this.props.index
    }, React.DOM.div({
      "className": 'name'
    }, track.get('name')), Knob({
      "label": "Level",
      "value": instrument.get('level'),
      "onChange": instrument.bind('level')
    }), Meter({
      "level": track.get('meterLevel')
    }));
  }
});

module.exports = React.createClass({
  propTypes: {
    tracks: React.PropTypes.object.isRequired,
    selectedTrack: React.PropTypes.number.isRequired,
    selectTrack: React.PropTypes.func.isRequired
  },
  trackTypes: {
    'Drum Sampler': DrumSampler,
    'Basic Sampler': BasicSampler,
    'Loop Sampler': LoopSampler,
    'Analog Synth': AnalogSynthesizer,
    'Drum Synth': DrumSynthesizer
  },
  getInitialState: function() {
    return {
      menuOpen: false,
      dragging: null
    };
  },
  componentDidMount: function() {
    return window.addEventListener('click', this.closeMenu);
  },
  componentWillUnmount: function() {
    return window.removeEventListener('click', this.closeMenu);
  },
  closeMenu: function() {
    if (this.state.menuOpen) {
      return this.setState({
        menuOpen: false
      });
    }
  },
  toggleMenu: function(e) {
    e.stopPropagation();
    return this.setState({
      menuOpen: !this.state.menuOpen
    });
  },
  addTrack: function(name) {
    var index, track;
    track = Track.build({
      name: name,
      instrument: this.trackTypes[name].build()
    });
    index = this.props.tracks.get().length;
    this.props.tracks.set([index], track);
    this.props.selectTrack(index);
    return this.setState({
      menuOpen: false
    });
  },
  removeTrack: function() {
    var index, tracks;
    tracks = this.props.tracks.get().slice(0);
    tracks.splice(this.props.selectedTrack, 1);
    index = Math.max(0, Math.min(this.props.selectedTrack, tracks.length - 1));
    this.props.selectTrack(index);
    return this.props.tracks.set([], tracks);
  },
  render: function() {
    var tracks;
    tracks = this.props.tracks.get();
    return React.DOM.div({
      "className": 'ui track-selection'
    }, React.DOM.div({
      "className": "tracks"
    }, ReactCSSTransitionGroup({
      "transitionName": "track"
    }, tracks.map((function(_this) {
      return function(track, i) {
        return TrackRow({
          "key": track._id,
          "index": i,
          "track": _this.props.tracks.cursor(i),
          "selected": parseInt(_this.props.selectedTrack) === parseInt(i),
          "selectTrack": (function() {
            return _this.props.selectTrack(i);
          }),
          "dragging": _this.state.dragging,
          "updateDragging": (function(dragging) {
            return _this.setState({
              dragging: dragging
            });
          }),
          "items": _this.props.tracks
        });
      };
    })(this)))), React.DOM.div({
      "className": "controls"
    }, Menu({
      "options": Object.keys(this.trackTypes),
      "onSelect": this.addTrack,
      "open": this.state.menuOpen
    }), React.DOM.div({
      "className": "icon icon-plus pull-right",
      "onClick": this.toggleMenu
    }), React.DOM.div({
      "className": "icon icon-minus pull-left",
      "onClick": this.removeTrack
    })));
  }
});



},{"../models/analog_synthesizer":12,"../models/basic_sampler":13,"../models/drum_sampler":14,"../models/drum_synthesizer":15,"../models/loop_sampler":17,"../models/track":21,"./knob":31,"./menu":34,"./meter":35,"./mixins/sortable":39,"react/addons":78}],58:[function(require,module,exports){
var Draggable, Marker, React, SizeMeasurable, Visualization;

React = require('react/addons');

SizeMeasurable = require('./mixins/size_measurable');

Draggable = require('./mixins/draggable');

Marker = require('./waveform/marker');

Visualization = require('./waveform/visualization');

module.exports = React.createClass({
  mixins: [React.addons.PureRenderMixin, SizeMeasurable, Draggable],
  propTypes: {
    sampleData: React.PropTypes.object,
    markers: React.PropTypes.object,
    selectionStart: React.PropTypes.number,
    selectionEnd: React.PropTypes.number,
    marginTop: React.PropTypes.number,
    marginBottom: React.PropTypes.number
  },
  range: 300,
  dragTypeDistance: 10,
  getInitialState: function() {
    return {
      windowCenter: 0.5,
      windowSize: 1
    };
  },
  getDefaultProps: function() {
    return {
      marginTop: 2,
      marginBottom: 2
    };
  },
  validateWindowCenter: function(center) {
    var halfSize;
    halfSize = this.state.windowSize / 2;
    if (center < halfSize) {
      return halfSize;
    } else if (center > 1 - halfSize) {
      return 1 - halfSize;
    } else {
      return center;
    }
  },
  onDragStart: function() {
    var relativePosition;
    this.initialWindowSize = this.state.windowSize;
    this.initialWindowCenter = this.state.windowCenter;
    relativePosition = (this.dragStartPosition.x - this.getDOMNode().getBoundingClientRect().left) / this.state.width;
    return this.initialPosition = this.state.windowCenter + this.state.windowSize * (relativePosition - 0.5);
  },
  onDragEnd: function() {
    this.dragType = null;
    this.initialWindowSize = null;
    this.initialWindowCenter = null;
    return this.initialPosition = null;
  },
  onDrag: function(delta) {
    var center, downRange, minValue, size, upRange;
    if (this.dragType === 'scale') {
      upRange = Math.min(this.range, this.dragStartPosition.y - window.scrollY);
      downRange = Math.min(this.range, window.innerHeight + window.scrollY - this.dragStartPosition.y);
      if (delta.y < 0) {
        minValue = Math.min(1, this.state.width / this.props.sampleData.length);
        size = Math.max(minValue, this.initialWindowSize * (downRange + delta.y) / downRange);
      } else {
        size = Math.min(1, this.initialWindowSize + (1 - this.initialWindowSize) * delta.y / upRange);
      }
      center = this.initialPosition - size / this.initialWindowSize * (this.initialPosition - this.initialWindowCenter);
      return this.setState({
        windowSize: size,
        windowCenter: this.validateWindowCenter(center)
      });
    } else if (this.dragType === 'pan') {
      center = this.initialWindowCenter - delta.x / this.state.width * this.initialWindowSize;
      return this.setState({
        windowCenter: this.validateWindowCenter(center)
      });
    } else {
      if (Math.abs(delta.x) > this.dragTypeDistance) {
        return this.dragType = 'pan';
      } else if (Math.abs(delta.y) > this.dragTypeDistance) {
        return this.dragType = 'scale';
      }
    }
  },
  render: function() {
    var data, markers, name, postSelection, preSelection, resolution, sampleData, selection, selectionEnd, selectionStart, sliceSize, windowSize, windowStart, _ref;
    if ((this.props.sampleData != null) && this.state.width > 0) {
      sampleData = this.props.sampleData;
      resolution = this.state.width / 2;
      windowSize = Math.max(1, Math.floor(this.state.windowSize * sampleData.length));
      sliceSize = windowSize / resolution;
      windowStart = Math.floor(this.state.windowCenter * sampleData.length - windowSize / 2);
      selectionStart = Math.floor((this.props.selectionStart * sampleData.length - windowStart) / sliceSize);
      selectionEnd = Math.ceil((this.props.selectionEnd * sampleData.length - windowStart) / sliceSize);
      if (selectionStart > 1) {
        preSelection = Visualization({
          "sampleData": sampleData,
          "resolution": resolution,
          "sliceSize": sliceSize,
          "windowStart": windowStart,
          "fromSlice": 0.,
          "toSlice": Math.min(resolution, selectionStart),
          "width": this.state.width,
          "height": this.state.height,
          "marginTop": this.props.marginTop,
          "marginBottom": this.props.marginBottom
        });
      }
      if (selectionStart !== selectionEnd) {
        selection = Visualization({
          "sampleData": sampleData,
          "resolution": resolution,
          "sliceSize": sliceSize,
          "windowStart": windowStart,
          "fromSlice": Math.max(0, selectionStart),
          "toSlice": Math.min(resolution, selectionEnd),
          "width": this.state.width,
          "height": this.state.height,
          "marginTop": this.props.marginTop,
          "marginBottom": this.props.marginBottom,
          "selection": true
        });
      }
      if (selectionEnd < resolution) {
        postSelection = Visualization({
          "sampleData": sampleData,
          "resolution": resolution,
          "sliceSize": sliceSize,
          "windowStart": windowStart,
          "fromSlice": Math.max(0, selectionEnd),
          "toSlice": resolution,
          "width": this.state.width,
          "height": this.state.height,
          "marginTop": this.props.marginTop,
          "marginBottom": this.props.marginBottom
        });
      }
      markers = [];
      if (this.props.markers != null) {
        _ref = this.props.markers;
        for (name in _ref) {
          data = _ref[name];
          markers.push(Marker({
            "key": name,
            "name": name,
            "value": data.value,
            "onChange": data.onChange,
            "parentWidth": this.state.width,
            "parentHeight": this.state.height,
            "windowSize": this.state.windowSize,
            "windowCenter": this.state.windowCenter
          }));
        }
      }
    }
    return React.DOM.div({
      "className": "ui waveform",
      "ref": "container"
    }, React.DOM.svg({
      "width": this.state.width,
      "height": this.state.height,
      "onMouseDown": (this.props.sampleData != null ? this.draggableOnMouseDown : null)
    }, preSelection, selection, postSelection, markers));
  }
});



},{"./mixins/draggable":36,"./mixins/size_measurable":38,"./waveform/marker":59,"./waveform/visualization":60,"react/addons":78}],59:[function(require,module,exports){
var Draggable, React;

React = require('react/addons');

Draggable = require('../mixins/draggable');

module.exports = React.createClass({
  mixins: [Draggable, React.addons.PureRenderMixin],
  propTypes: {
    name: React.PropTypes.string,
    value: React.PropTypes.number,
    parentWidth: React.PropTypes.number,
    parentHeight: React.PropTypes.number,
    windowSize: React.PropTypes.number,
    windowCenter: React.PropTypes.number,
    width: React.PropTypes.number,
    radius: React.PropTypes.number
  },
  getDefaultProps: function() {
    return {
      radius: 2,
      width: 4
    };
  },
  getInitialState: function() {
    return {
      dragActive: false
    };
  },
  onDragStart: function(dragStartPosition, e) {
    e.stopPropagation();
    return this.setState({
      dragInitialValue: this.props.value
    });
  },
  onDragEnd: function() {
    return this.setState({
      dragInitialValue: null
    });
  },
  onDrag: function(delta) {
    var value;
    value = Math.max(0, Math.min(1, this.state.dragInitialValue + delta.x / this.props.parentWidth * this.props.windowSize));
    return this.props.onChange(value);
  },
  render: function() {
    var className, windowEnd, windowStart, x;
    windowStart = this.props.windowCenter - this.props.windowSize / 2;
    windowEnd = this.props.windowCenter + this.props.windowSize / 2;
    if (!(this.props.value >= windowStart && this.props.value <= windowEnd)) {
      return React.DOM.g(null);
    }
    x = (this.props.value - windowStart) / this.props.windowSize * this.props.parentWidth - this.props.width / 2;
    x = Math.max(0, Math.min(this.props.parentWidth - this.props.width, x));
    className = "marker " + this.props.name;
    if (this.state.dragInitialValue != null) {
      className += ' active';
    }
    return React.DOM.g(null, React.DOM.rect({
      "className": className,
      "x": x,
      "y": 0.,
      "width": this.props.width,
      "height": this.props.parentHeight,
      "rx": this.props.radius,
      "ry": this.props.radius,
      "onMouseDown": this.draggableOnMouseDown
    }));
  }
});



},{"../mixins/draggable":36,"react/addons":78}],60:[function(require,module,exports){
var React;

React = require('react/addons');

module.exports = React.createClass({
  mixins: [React.addons.PureRenderMixin],
  render: function() {
    var bottom, className, d, fromSlice, height, i, j, points, resolution, sampleData, sliceEnd, sliceSize, sliceStart, toSlice, top, v, width, windowStart, x, y, _i, _j, _ref, _ref1;
    sampleData = this.props.sampleData;
    resolution = this.props.resolution;
    sliceSize = this.props.sliceSize;
    windowStart = this.props.windowStart;
    fromSlice = this.props.fromSlice;
    toSlice = this.props.toSlice;
    width = this.props.width;
    height = this.props.height - this.props.marginTop - this.props.marginBottom;
    top = this.props.marginBottom;
    bottom = this.props.height - this.props.marginBottom;
    points = [];
    points.push("" + (fromSlice * width / resolution) + " " + bottom);
    for (i = _i = fromSlice; fromSlice <= toSlice ? _i <= toSlice : _i >= toSlice; i = fromSlice <= toSlice ? ++_i : --_i) {
      sliceStart = i * sliceSize + windowStart;
      sliceEnd = sliceStart + sliceSize;
      x = i * width / resolution;
      y = 0;
      for (j = _j = _ref = Math.floor(sliceStart), _ref1 = Math.floor(sliceEnd); _ref <= _ref1 ? _j < _ref1 : _j > _ref1; j = _ref <= _ref1 ? ++_j : --_j) {
        v = Math.abs(sampleData[j]);
        if (v > y) {
          y = v;
        }
      }
      y = (((1 - y) * height) || 0) + top;
      points.push("" + x + " " + y);
    }
    points.push("" + x + " " + bottom);
    d = "M " + (points.join(' L '));
    if (this.props.selection) {
      className = 'selection';
    }
    return React.DOM.path({
      "className": className,
      "d": d
    });
  }
});



},{"react/addons":78}],61:[function(require,module,exports){
module.exports = function(wait, func) {
  var args, context, later, timeout, timestamp;
  timeout = args = context = timestamp = null;
  later = function() {
    var last, result;
    last = Date.now() - timestamp;
    if (last < wait && last > 0) {
      return timeout = setTimeout(later, wait - last);
    } else {
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) {
        return context = args = null;
      }
    }
  };
  return function() {
    context = this;
    args = arguments;
    timestamp = Date.now();
    return timeout = setTimeout(later, wait);
  };
};



},{}],62:[function(require,module,exports){
var deepFreeze;

module.exports = deepFreeze = function(o) {
  var prop, _i, _len, _ref;
  if (!(o instanceof Object)) {
    return o;
  }
  _ref = Object.getOwnPropertyNames(o);
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    prop = _ref[_i];
    if (o.hasOwnProperty(prop) && (o[prop] != null) && (typeof o[prop] === 'object' || typeof o[prop] === 'function') && !o[prop] instanceof Float32Array && !Object.isFrozen(o[prop])) {
      deepFreeze(o[prop]);
    }
  }
  return Object.freeze(o);
};



},{}],63:[function(require,module,exports){
var deepMerge, isObject;

isObject = function(o) {
  return (o != null) && toString.call(o) === '[object Object]';
};

module.exports = deepMerge = function(src, data) {
  var dst, key;
  dst = Array.isArray(src) ? [] : {};
  for (key in src) {
    dst[key] = src[key];
  }
  for (key in data) {
    if (isObject(data[key]) && isObject(src[key])) {
      dst[key] = deepMerge(src[key], data[key]);
    } else {
      dst[key] = data[key];
    }
  }
  return dst;
};



},{}],64:[function(require,module,exports){
var Cache, UndoHistory, deepFreeze, deepMerge, isEmpty;

deepFreeze = require('./deep_freeze');

deepMerge = require('./deep_merge');

UndoHistory = require('./undo_history');

isEmpty = function(o) {
  var k, v;
  for (k in o) {
    v = o[k];
    if (o.hasOwnProperty(k)) {
      return false;
    }
  }
  return true;
};

Cache = (function() {
  var clearObject;

  function Cache() {
    this.root = {
      children: {}
    };
  }

  Cache.prototype.get = function(path) {
    var key, target, _i, _len;
    target = this.root;
    for (_i = 0, _len = path.length; _i < _len; _i++) {
      key = path[_i];
      target = target.children[key];
      if (target == null) {
        return void 0;
      }
    }
    return target.cursor;
  };

  Cache.prototype.store = function(cursor) {
    var key, target, _base, _i, _len, _ref;
    target = this.root;
    _ref = cursor.path;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      key = _ref[_i];
      (_base = target.children)[key] || (_base[key] = {
        children: {}
      });
      target = target.children[key];
    }
    return target.cursor = cursor;
  };

  Cache.prototype.clearPath = function(path) {
    var i, key, nodes, target, _i, _len;
    target = this.root;
    nodes = [];
    for (i = _i = 0, _len = path.length; _i < _len; i = ++_i) {
      key = path[i];
      if (target.children[key] == null) {
        break;
      }
      target = target.children[key];
      nodes.push(target);
      delete target.cursor;
    }
    return this.root;
  };

  clearObject = function(node, changes) {
    var child, k;
    for (k in changes) {
      if ((child = node.children[k]) != null) {
        delete child.cursor;
        clearObject(child, changes[k]);
      }
    }
    return node;
  };

  Cache.prototype.clearObject = function(path, obj) {
    var key, target, _i, _len;
    target = this.root;
    for (_i = 0, _len = path.length; _i < _len; _i++) {
      key = path[_i];
      target = target.children[key];
      if (target == null) {
        return;
      }
    }
    return clearObject(target, obj);
  };

  return Cache;

})();

module.exports = {
  create: function(inputData, onChange) {
    var Cursor, batched, cache, data, history, update;
    cache = new Cache;
    history = new UndoHistory;
    data = deepFreeze(inputData);
    batched = false;
    Cursor = (function() {
      function Cursor(path) {
        this.path = path != null ? path : [];
      }

      Cursor.prototype.cursor = function(path) {
        var cached, cursor, fullPath;
        if (path == null) {
          path = [];
        }
        fullPath = this.path.concat(path);
        if ((cached = cache.get(fullPath)) != null) {
          return cached;
        }
        cursor = new Cursor(fullPath);
        cache.store(cursor);
        return cursor;
      };

      Cursor.prototype.get = function(path) {
        var key, target, _i, _len, _ref;
        if (path == null) {
          path = [];
        }
        target = data;
        _ref = this.path.concat(path);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          key = _ref[_i];
          target = target[key];
          if (target == null) {
            return void 0;
          }
        }
        return target;
      };

      Cursor.prototype.modifyAt = function(path, modifier, historic) {
        var fullPath, k, key, newData, target, updated, v, _i, _len, _ref, _ref1;
        fullPath = this.path.concat(path);
        newData = target = {};
        for (k in data) {
          v = data[k];
          target[k] = v;
        }
        _ref = fullPath.slice(0, -1);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          key = _ref[_i];
          updated = Array.isArray(target[key]) ? [] : {};
          _ref1 = target[key];
          for (k in _ref1) {
            v = _ref1[k];
            updated[k] = v;
          }
          target[key] = updated;
          Object.freeze(target);
          target = target[key];
        }
        modifier(target, fullPath.slice(-1));
        Object.freeze(target);
        cache.clearPath(fullPath);
        return update(newData, historic);
      };

      Cursor.prototype.set = function(path, value, historic) {
        if (historic == null) {
          historic = false;
        }
        if (arguments.length === 1) {
          value = path;
          path = [];
        }
        if (this.path.length > 0 || path.length > 0) {
          return this.modifyAt(path, function(target, key) {
            return target[key] = deepFreeze(value);
          }, historic);
        } else {
          return update(value);
        }
      };

      Cursor.prototype["delete"] = function(path) {
        if (this.path.length > 0 || path.length > 0) {
          return this.modifyAt(path, function(target, key) {
            return delete target[key];
          }, historic);
        } else {
          return update(void 0);
        }
      };

      Cursor.prototype.merge = function(newData, historic) {
        if (historic == null) {
          historic = false;
        }
        cache.clearObject(this.path, newData);
        return this.set([], deepMerge(this.get(), deepFreeze(newData)), historic);
      };

      Cursor.prototype.bind = function(path, pre, historic) {
        if (historic == null) {
          historic = false;
        }
        return (function(_this) {
          return function(v) {
            return _this.set(path, (pre ? pre(v) : v), historic);
          };
        })(this);
      };

      Cursor.prototype.has = function(path) {
        return this.get(path) != null;
      };

      Cursor.prototype.batched = function(cb, historic) {
        if (historic == null) {
          historic = false;
        }
        batched = true;
        cb();
        batched = false;
        return update(data, historic);
      };

      return Cursor;

    })();
    update = function(newData, historic) {
      var cursor;
      data = newData;
      if (!batched) {
        cursor = new Cursor();
        if (historic) {
          history.update(cursor);
        }
        return onChange(cursor, history);
      }
    };
    return onChange(new Cursor(), history);
  }
};



},{"./deep_freeze":62,"./deep_merge":63,"./undo_history":70}],65:[function(require,module,exports){
var React, keys;

React = require('react');

keys = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

module.exports = function() {
  var i, note, octave, _i, _results;
  _results = [];
  for (i = _i = 127; _i >= 0; i = --_i) {
    octave = Math.floor(i / 12) - 2;
    note = keys[i % 12];
    _results.push(React.DOM.option({
      "key": i,
      "value": i
    }, "" + note + octave));
  }
  return _results;
};



},{"react":237}],66:[function(require,module,exports){
var i;

i = 0;

module.exports = function(v) {
  if (i === 0) {
    console.log(v);
  }
  return i = (i + 1) % 7000;
};



},{}],67:[function(require,module,exports){
var actions, apply, nextId;

nextId = 0;

actions = {};

apply = function() {
  var action, id, max;
  max = null;
  for (id in actions) {
    action = actions[id];
    if ((max == null) || action.priority > actions[max].priority) {
      max = id;
    }
  }
  return document.body.style.cursor = max ? actions[max].value : 'default';
};

module.exports = {
  set: function(value, priority, id) {
    id || (id = nextId += 1);
    actions[id] = {
      value: value,
      priority: priority
    };
    apply();
    return id;
  },
  clear: function(id) {
    delete actions[id];
    return apply();
  }
};



},{}],68:[function(require,module,exports){
var RingBuffer;

module.exports = RingBuffer = (function() {
  function RingBuffer(maxLength, Type, length) {
    this.maxLength = maxLength;
    this.Type = Type != null ? Type : Float32Array;
    this.length = length;
    this.length || (this.length = this.maxLength);
    this.array = new Type(this.maxLength);
    this.pos = 0;
  }

  RingBuffer.prototype.reset = function() {
    this.array = new this.Type(this.maxLength);
    return this;
  };

  RingBuffer.prototype.resize = function(length) {
    this.length = length;
    if (this.pos >= this.length) {
      return this.pos = 0;
    }
  };

  RingBuffer.prototype.push = function(el) {
    this.array[this.pos] = el;
    this.pos += 1;
    if (this.pos === this.length) {
      this.pos = 0;
    }
    return this;
  };

  RingBuffer.prototype.forEach = function(fn) {
    var i, len;
    for (i = this.pos, len = this.length; i < len; i++) {
      fn(this.array[i], i);
    }
    for (i = 0, len = this.pos; i < len; i++) {
      fn(this.array[i], i);
    };
    return this;
  };

  RingBuffer.prototype.reduce = function(fn, memo) {
    if (memo == null) {
      memo = 0;
    }
    this.forEach(function(el, i) {
      return memo = fn(memo, el, i);
    });
    return memo;
  };

  return RingBuffer;

})();



},{}],69:[function(require,module,exports){
var React;

React = require('react');

module.exports = function() {
  var i, _i, _results;
  _results = [];
  for (i = _i = 24; _i >= -24; i = --_i) {
    _results.push(React.DOM.option({
      "key": i,
      "value": i
    }, i));
  }
  return _results;
};



},{"react":237}],70:[function(require,module,exports){
var UndoHistory, debounce;

debounce = require('./debounce');

module.exports = UndoHistory = (function() {
  function UndoHistory(size, interval) {
    this.size = size != null ? size : 100;
    this.interval = interval != null ? interval : 300;
    this.undos = [];
    this.redos = [];
    this.cursor = null;
    this.data = null;
    this.record = debounce(this.interval, (function(_this) {
      return function() {
        return _this.undos.push(_this.cursor.get());
      };
    })(this));
  }

  UndoHistory.prototype.update = function(newCursor) {
    if (this.cursor === newCursor) {
      return;
    }
    this.cursor = newCursor;
    this.data = this.cursor.get();
    return this.record();
  };

  UndoHistory.prototype.undo = function() {
    console.log('here');
    if (!(this.undos.length > 0)) {
      return;
    }
    this.redos.push(this.data);
    if (this.redos.length > this.size) {
      this.redos.shift();
    }
    console.log(this.data);
    this.data = this.undos.pop();
    console.log(this.data);
    return this.cursor.set(this.data);
  };

  UndoHistory.prototype.redo = function() {
    if (!(this.redos.length > 0)) {
      return;
    }
    this.undos.push(this.data);
    if (this.undos.length > this.size) {
      this.undos.shift();
    }
    this.data = this.redos.pop();
    return this.cursor.set(this.data);
  };

  return UndoHistory;

})();



},{"./debounce":61}],71:[function(require,module,exports){
(function (process){
/*!
 * async
 * https://github.com/caolan/async
 *
 * Copyright 2010-2014 Caolan McMahon
 * Released under the MIT license
 */
/*jshint onevar: false, indent:4 */
/*global setImmediate: false, setTimeout: false, console: false */
(function () {

    var async = {};

    // global on the server, window in the browser
    var root, previous_async;

    root = this;
    if (root != null) {
      previous_async = root.async;
    }

    async.noConflict = function () {
        root.async = previous_async;
        return async;
    };

    function only_once(fn) {
        var called = false;
        return function() {
            if (called) throw new Error("Callback was already called.");
            called = true;
            fn.apply(root, arguments);
        }
    }

    //// cross-browser compatiblity functions ////

    var _toString = Object.prototype.toString;

    var _isArray = Array.isArray || function (obj) {
        return _toString.call(obj) === '[object Array]';
    };

    var _each = function (arr, iterator) {
        if (arr.forEach) {
            return arr.forEach(iterator);
        }
        for (var i = 0; i < arr.length; i += 1) {
            iterator(arr[i], i, arr);
        }
    };

    var _map = function (arr, iterator) {
        if (arr.map) {
            return arr.map(iterator);
        }
        var results = [];
        _each(arr, function (x, i, a) {
            results.push(iterator(x, i, a));
        });
        return results;
    };

    var _reduce = function (arr, iterator, memo) {
        if (arr.reduce) {
            return arr.reduce(iterator, memo);
        }
        _each(arr, function (x, i, a) {
            memo = iterator(memo, x, i, a);
        });
        return memo;
    };

    var _keys = function (obj) {
        if (Object.keys) {
            return Object.keys(obj);
        }
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    };

    //// exported async module functions ////

    //// nextTick implementation with browser-compatible fallback ////
    if (typeof process === 'undefined' || !(process.nextTick)) {
        if (typeof setImmediate === 'function') {
            async.nextTick = function (fn) {
                // not a direct alias for IE10 compatibility
                setImmediate(fn);
            };
            async.setImmediate = async.nextTick;
        }
        else {
            async.nextTick = function (fn) {
                setTimeout(fn, 0);
            };
            async.setImmediate = async.nextTick;
        }
    }
    else {
        async.nextTick = process.nextTick;
        if (typeof setImmediate !== 'undefined') {
            async.setImmediate = function (fn) {
              // not a direct alias for IE10 compatibility
              setImmediate(fn);
            };
        }
        else {
            async.setImmediate = async.nextTick;
        }
    }

    async.each = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        _each(arr, function (x) {
            iterator(x, only_once(done) );
        });
        function done(err) {
          if (err) {
              callback(err);
              callback = function () {};
          }
          else {
              completed += 1;
              if (completed >= arr.length) {
                  callback();
              }
          }
        }
    };
    async.forEach = async.each;

    async.eachSeries = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        var iterate = function () {
            iterator(arr[completed], function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback();
                    }
                    else {
                        iterate();
                    }
                }
            });
        };
        iterate();
    };
    async.forEachSeries = async.eachSeries;

    async.eachLimit = function (arr, limit, iterator, callback) {
        var fn = _eachLimit(limit);
        fn.apply(null, [arr, iterator, callback]);
    };
    async.forEachLimit = async.eachLimit;

    var _eachLimit = function (limit) {

        return function (arr, iterator, callback) {
            callback = callback || function () {};
            if (!arr.length || limit <= 0) {
                return callback();
            }
            var completed = 0;
            var started = 0;
            var running = 0;

            (function replenish () {
                if (completed >= arr.length) {
                    return callback();
                }

                while (running < limit && started < arr.length) {
                    started += 1;
                    running += 1;
                    iterator(arr[started - 1], function (err) {
                        if (err) {
                            callback(err);
                            callback = function () {};
                        }
                        else {
                            completed += 1;
                            running -= 1;
                            if (completed >= arr.length) {
                                callback();
                            }
                            else {
                                replenish();
                            }
                        }
                    });
                }
            })();
        };
    };


    var doParallel = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.each].concat(args));
        };
    };
    var doParallelLimit = function(limit, fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [_eachLimit(limit)].concat(args));
        };
    };
    var doSeries = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.eachSeries].concat(args));
        };
    };


    var _asyncMap = function (eachfn, arr, iterator, callback) {
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        if (!callback) {
            eachfn(arr, function (x, callback) {
                iterator(x.value, function (err) {
                    callback(err);
                });
            });
        } else {
            var results = [];
            eachfn(arr, function (x, callback) {
                iterator(x.value, function (err, v) {
                    results[x.index] = v;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };
    async.map = doParallel(_asyncMap);
    async.mapSeries = doSeries(_asyncMap);
    async.mapLimit = function (arr, limit, iterator, callback) {
        return _mapLimit(limit)(arr, iterator, callback);
    };

    var _mapLimit = function(limit) {
        return doParallelLimit(limit, _asyncMap);
    };

    // reduce only has a series version, as doing reduce in parallel won't
    // work in many situations.
    async.reduce = function (arr, memo, iterator, callback) {
        async.eachSeries(arr, function (x, callback) {
            iterator(memo, x, function (err, v) {
                memo = v;
                callback(err);
            });
        }, function (err) {
            callback(err, memo);
        });
    };
    // inject alias
    async.inject = async.reduce;
    // foldl alias
    async.foldl = async.reduce;

    async.reduceRight = function (arr, memo, iterator, callback) {
        var reversed = _map(arr, function (x) {
            return x;
        }).reverse();
        async.reduce(reversed, memo, iterator, callback);
    };
    // foldr alias
    async.foldr = async.reduceRight;

    var _filter = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.filter = doParallel(_filter);
    async.filterSeries = doSeries(_filter);
    // select alias
    async.select = async.filter;
    async.selectSeries = async.filterSeries;

    var _reject = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (!v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.reject = doParallel(_reject);
    async.rejectSeries = doSeries(_reject);

    var _detect = function (eachfn, arr, iterator, main_callback) {
        eachfn(arr, function (x, callback) {
            iterator(x, function (result) {
                if (result) {
                    main_callback(x);
                    main_callback = function () {};
                }
                else {
                    callback();
                }
            });
        }, function (err) {
            main_callback();
        });
    };
    async.detect = doParallel(_detect);
    async.detectSeries = doSeries(_detect);

    async.some = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (v) {
                    main_callback(true);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(false);
        });
    };
    // any alias
    async.any = async.some;

    async.every = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (!v) {
                    main_callback(false);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(true);
        });
    };
    // all alias
    async.all = async.every;

    async.sortBy = function (arr, iterator, callback) {
        async.map(arr, function (x, callback) {
            iterator(x, function (err, criteria) {
                if (err) {
                    callback(err);
                }
                else {
                    callback(null, {value: x, criteria: criteria});
                }
            });
        }, function (err, results) {
            if (err) {
                return callback(err);
            }
            else {
                var fn = function (left, right) {
                    var a = left.criteria, b = right.criteria;
                    return a < b ? -1 : a > b ? 1 : 0;
                };
                callback(null, _map(results.sort(fn), function (x) {
                    return x.value;
                }));
            }
        });
    };

    async.auto = function (tasks, callback) {
        callback = callback || function () {};
        var keys = _keys(tasks);
        var remainingTasks = keys.length
        if (!remainingTasks) {
            return callback();
        }

        var results = {};

        var listeners = [];
        var addListener = function (fn) {
            listeners.unshift(fn);
        };
        var removeListener = function (fn) {
            for (var i = 0; i < listeners.length; i += 1) {
                if (listeners[i] === fn) {
                    listeners.splice(i, 1);
                    return;
                }
            }
        };
        var taskComplete = function () {
            remainingTasks--
            _each(listeners.slice(0), function (fn) {
                fn();
            });
        };

        addListener(function () {
            if (!remainingTasks) {
                var theCallback = callback;
                // prevent final callback from calling itself if it errors
                callback = function () {};

                theCallback(null, results);
            }
        });

        _each(keys, function (k) {
            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];
            var taskCallback = function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                    args = args[0];
                }
                if (err) {
                    var safeResults = {};
                    _each(_keys(results), function(rkey) {
                        safeResults[rkey] = results[rkey];
                    });
                    safeResults[k] = args;
                    callback(err, safeResults);
                    // stop subsequent errors hitting callback multiple times
                    callback = function () {};
                }
                else {
                    results[k] = args;
                    async.setImmediate(taskComplete);
                }
            };
            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
            var ready = function () {
                return _reduce(requires, function (a, x) {
                    return (a && results.hasOwnProperty(x));
                }, true) && !results.hasOwnProperty(k);
            };
            if (ready()) {
                task[task.length - 1](taskCallback, results);
            }
            else {
                var listener = function () {
                    if (ready()) {
                        removeListener(listener);
                        task[task.length - 1](taskCallback, results);
                    }
                };
                addListener(listener);
            }
        });
    };

    async.retry = function(times, task, callback) {
        var DEFAULT_TIMES = 5;
        var attempts = [];
        // Use defaults if times not passed
        if (typeof times === 'function') {
            callback = task;
            task = times;
            times = DEFAULT_TIMES;
        }
        // Make sure times is a number
        times = parseInt(times, 10) || DEFAULT_TIMES;
        var wrappedTask = function(wrappedCallback, wrappedResults) {
            var retryAttempt = function(task, finalAttempt) {
                return function(seriesCallback) {
                    task(function(err, result){
                        seriesCallback(!err || finalAttempt, {err: err, result: result});
                    }, wrappedResults);
                };
            };
            while (times) {
                attempts.push(retryAttempt(task, !(times-=1)));
            }
            async.series(attempts, function(done, data){
                data = data[data.length - 1];
                (wrappedCallback || callback)(data.err, data.result);
            });
        }
        // If a callback is passed, run this as a controll flow
        return callback ? wrappedTask() : wrappedTask
    };

    async.waterfall = function (tasks, callback) {
        callback = callback || function () {};
        if (!_isArray(tasks)) {
          var err = new Error('First argument to waterfall must be an array of functions');
          return callback(err);
        }
        if (!tasks.length) {
            return callback();
        }
        var wrapIterator = function (iterator) {
            return function (err) {
                if (err) {
                    callback.apply(null, arguments);
                    callback = function () {};
                }
                else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    var next = iterator.next();
                    if (next) {
                        args.push(wrapIterator(next));
                    }
                    else {
                        args.push(callback);
                    }
                    async.setImmediate(function () {
                        iterator.apply(null, args);
                    });
                }
            };
        };
        wrapIterator(async.iterator(tasks))();
    };

    var _parallel = function(eachfn, tasks, callback) {
        callback = callback || function () {};
        if (_isArray(tasks)) {
            eachfn.map(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            eachfn.each(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.parallel = function (tasks, callback) {
        _parallel({ map: async.map, each: async.each }, tasks, callback);
    };

    async.parallelLimit = function(tasks, limit, callback) {
        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
    };

    async.series = function (tasks, callback) {
        callback = callback || function () {};
        if (_isArray(tasks)) {
            async.mapSeries(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            async.eachSeries(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.iterator = function (tasks) {
        var makeCallback = function (index) {
            var fn = function () {
                if (tasks.length) {
                    tasks[index].apply(null, arguments);
                }
                return fn.next();
            };
            fn.next = function () {
                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
            };
            return fn;
        };
        return makeCallback(0);
    };

    async.apply = function (fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
            return fn.apply(
                null, args.concat(Array.prototype.slice.call(arguments))
            );
        };
    };

    var _concat = function (eachfn, arr, fn, callback) {
        var r = [];
        eachfn(arr, function (x, cb) {
            fn(x, function (err, y) {
                r = r.concat(y || []);
                cb(err);
            });
        }, function (err) {
            callback(err, r);
        });
    };
    async.concat = doParallel(_concat);
    async.concatSeries = doSeries(_concat);

    async.whilst = function (test, iterator, callback) {
        if (test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.whilst(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doWhilst = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            var args = Array.prototype.slice.call(arguments, 1);
            if (test.apply(null, args)) {
                async.doWhilst(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.until = function (test, iterator, callback) {
        if (!test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.until(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doUntil = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            var args = Array.prototype.slice.call(arguments, 1);
            if (!test.apply(null, args)) {
                async.doUntil(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.queue = function (worker, concurrency) {
        if (concurrency === undefined) {
            concurrency = 1;
        }
        function _insert(q, data, pos, callback) {
          if (!q.started){
            q.started = true;
          }
          if (!_isArray(data)) {
              data = [data];
          }
          if(data.length == 0) {
             // call drain immediately if there are no tasks
             return async.setImmediate(function() {
                 if (q.drain) {
                     q.drain();
                 }
             });
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  callback: typeof callback === 'function' ? callback : null
              };

              if (pos) {
                q.tasks.unshift(item);
              } else {
                q.tasks.push(item);
              }

              if (q.saturated && q.tasks.length === q.concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }

        var workers = 0;
        var q = {
            tasks: [],
            concurrency: concurrency,
            saturated: null,
            empty: null,
            drain: null,
            started: false,
            paused: false,
            push: function (data, callback) {
              _insert(q, data, false, callback);
            },
            kill: function () {
              q.drain = null;
              q.tasks = [];
            },
            unshift: function (data, callback) {
              _insert(q, data, true, callback);
            },
            process: function () {
                if (!q.paused && workers < q.concurrency && q.tasks.length) {
                    var task = q.tasks.shift();
                    if (q.empty && q.tasks.length === 0) {
                        q.empty();
                    }
                    workers += 1;
                    var next = function () {
                        workers -= 1;
                        if (task.callback) {
                            task.callback.apply(task, arguments);
                        }
                        if (q.drain && q.tasks.length + workers === 0) {
                            q.drain();
                        }
                        q.process();
                    };
                    var cb = only_once(next);
                    worker(task.data, cb);
                }
            },
            length: function () {
                return q.tasks.length;
            },
            running: function () {
                return workers;
            },
            idle: function() {
                return q.tasks.length + workers === 0;
            },
            pause: function () {
                if (q.paused === true) { return; }
                q.paused = true;
                q.process();
            },
            resume: function () {
                if (q.paused === false) { return; }
                q.paused = false;
                q.process();
            }
        };
        return q;
    };
    
    async.priorityQueue = function (worker, concurrency) {
        
        function _compareTasks(a, b){
          return a.priority - b.priority;
        };
        
        function _binarySearch(sequence, item, compare) {
          var beg = -1,
              end = sequence.length - 1;
          while (beg < end) {
            var mid = beg + ((end - beg + 1) >>> 1);
            if (compare(item, sequence[mid]) >= 0) {
              beg = mid;
            } else {
              end = mid - 1;
            }
          }
          return beg;
        }
        
        function _insert(q, data, priority, callback) {
          if (!q.started){
            q.started = true;
          }
          if (!_isArray(data)) {
              data = [data];
          }
          if(data.length == 0) {
             // call drain immediately if there are no tasks
             return async.setImmediate(function() {
                 if (q.drain) {
                     q.drain();
                 }
             });
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  priority: priority,
                  callback: typeof callback === 'function' ? callback : null
              };
              
              q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);

              if (q.saturated && q.tasks.length === q.concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }
        
        // Start with a normal queue
        var q = async.queue(worker, concurrency);
        
        // Override push to accept second parameter representing priority
        q.push = function (data, priority, callback) {
          _insert(q, data, priority, callback);
        };
        
        // Remove unshift function
        delete q.unshift;

        return q;
    };

    async.cargo = function (worker, payload) {
        var working     = false,
            tasks       = [];

        var cargo = {
            tasks: tasks,
            payload: payload,
            saturated: null,
            empty: null,
            drain: null,
            drained: true,
            push: function (data, callback) {
                if (!_isArray(data)) {
                    data = [data];
                }
                _each(data, function(task) {
                    tasks.push({
                        data: task,
                        callback: typeof callback === 'function' ? callback : null
                    });
                    cargo.drained = false;
                    if (cargo.saturated && tasks.length === payload) {
                        cargo.saturated();
                    }
                });
                async.setImmediate(cargo.process);
            },
            process: function process() {
                if (working) return;
                if (tasks.length === 0) {
                    if(cargo.drain && !cargo.drained) cargo.drain();
                    cargo.drained = true;
                    return;
                }

                var ts = typeof payload === 'number'
                            ? tasks.splice(0, payload)
                            : tasks.splice(0, tasks.length);

                var ds = _map(ts, function (task) {
                    return task.data;
                });

                if(cargo.empty) cargo.empty();
                working = true;
                worker(ds, function () {
                    working = false;

                    var args = arguments;
                    _each(ts, function (data) {
                        if (data.callback) {
                            data.callback.apply(null, args);
                        }
                    });

                    process();
                });
            },
            length: function () {
                return tasks.length;
            },
            running: function () {
                return working;
            }
        };
        return cargo;
    };

    var _console_fn = function (name) {
        return function (fn) {
            var args = Array.prototype.slice.call(arguments, 1);
            fn.apply(null, args.concat([function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (typeof console !== 'undefined') {
                    if (err) {
                        if (console.error) {
                            console.error(err);
                        }
                    }
                    else if (console[name]) {
                        _each(args, function (x) {
                            console[name](x);
                        });
                    }
                }
            }]));
        };
    };
    async.log = _console_fn('log');
    async.dir = _console_fn('dir');
    /*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/

    async.memoize = function (fn, hasher) {
        var memo = {};
        var queues = {};
        hasher = hasher || function (x) {
            return x;
        };
        var memoized = function () {
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            var key = hasher.apply(null, args);
            if (key in memo) {
                async.nextTick(function () {
                    callback.apply(null, memo[key]);
                });
            }
            else if (key in queues) {
                queues[key].push(callback);
            }
            else {
                queues[key] = [callback];
                fn.apply(null, args.concat([function () {
                    memo[key] = arguments;
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                      q[i].apply(null, arguments);
                    }
                }]));
            }
        };
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
    };

    async.unmemoize = function (fn) {
      return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
      };
    };

    async.times = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.map(counter, iterator, callback);
    };

    async.timesSeries = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.mapSeries(counter, iterator, callback);
    };

    async.seq = function (/* functions... */) {
        var fns = arguments;
        return function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            async.reduce(fns, args, function (newargs, fn, cb) {
                fn.apply(that, newargs.concat([function () {
                    var err = arguments[0];
                    var nextargs = Array.prototype.slice.call(arguments, 1);
                    cb(err, nextargs);
                }]))
            },
            function (err, results) {
                callback.apply(that, [err].concat(results));
            });
        };
    };

    async.compose = function (/* functions... */) {
      return async.seq.apply(null, Array.prototype.reverse.call(arguments));
    };

    var _applyEach = function (eachfn, fns /*args...*/) {
        var go = function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            return eachfn(fns, function (fn, cb) {
                fn.apply(that, args.concat([cb]));
            },
            callback);
        };
        if (arguments.length > 2) {
            var args = Array.prototype.slice.call(arguments, 2);
            return go.apply(this, args);
        }
        else {
            return go;
        }
    };
    async.applyEach = doParallel(_applyEach);
    async.applyEachSeries = doSeries(_applyEach);

    async.forever = function (fn, callback) {
        function next(err) {
            if (err) {
                if (callback) {
                    return callback(err);
                }
                throw err;
            }
            fn(next);
        }
        next();
    };

    // Node.js
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = async;
    }
    // AMD / RequireJS
    else if (typeof define !== 'undefined' && define.amd) {
        define([], function () {
            return async;
        });
    }
    // included directly via <script> tag
    else {
        root.async = async;
    }

}());

}).call(this,require('_process'))
},{"_process":73}],72:[function(require,module,exports){
/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */
(function(chars){
  "use strict";

  exports.encode = function(arraybuffer) {
    var bytes = new Uint8Array(arraybuffer),
    i, len = bytes.length, base64 = "";

    for (i = 0; i < len; i+=3) {
      base64 += chars[bytes[i] >> 2];
      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
      base64 += chars[bytes[i + 2] & 63];
    }

    if ((len % 3) === 2) {
      base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + "==";
    }

    return base64;
  };

  exports.decode =  function(base64) {
    var bufferLength = base64.length * 0.75,
    len = base64.length, i, p = 0,
    encoded1, encoded2, encoded3, encoded4;

    if (base64[base64.length - 1] === "=") {
      bufferLength--;
      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }

    var arraybuffer = new ArrayBuffer(bufferLength),
    bytes = new Uint8Array(arraybuffer);

    for (i = 0; i < len; i+=4) {
      encoded1 = chars.indexOf(base64[i]);
      encoded2 = chars.indexOf(base64[i+1]);
      encoded3 = chars.indexOf(base64[i+2]);
      encoded4 = chars.indexOf(base64[i+3]);

      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }

    return arraybuffer;
  };
})("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");

},{}],73:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],74:[function(require,module,exports){
module.exports = {

  server: function() {
    var WebSocketServer = require('ws').Server;
    var wss = new WebSocketServer({port: 8087});
    var lastMessage = 'done';

    wss.on('connection', function(ws) {
      if (lastMessage != 'done') {
        ws.send(lastMessage);
      };
    });

    return {
      send: function(message) {
        lastMessage = message;
        wss.clients.forEach(function(client){
          try {
            client.send(message);
          } catch (e) {}
        });
      }
    }
  },

  client: function() {
    var WebSocket = require('ws');
    var ws = new WebSocket('ws://localhost:8087');
    ws.onmessage = function(event) {
      if (event.data == 'done') {
        window.location.reload();
      } else {
        var classes = Array.prototype.slice.call(document.body.classList, 0);
        classes.forEach(function(className) {
          if (className.match(/$build-status-/)) {
            document.body.classList.remove(className);
          }
        });

        document.body.classList.add('build-status-' + event.data);
      }
    };
  }

};

},{"ws":75}],75:[function(require,module,exports){

/**
 * Module dependencies.
 */

var global = (function() { return this; })();

/**
 * WebSocket constructor.
 */

var WebSocket = global.WebSocket || global.MozWebSocket;

/**
 * Module exports.
 */

module.exports = WebSocket ? ws : null;

/**
 * WebSocket constructor.
 *
 * The third `opts` options object gets ignored in web browsers, since it's
 * non-standard, and throws a TypeError if passed to the constructor.
 * See: https://github.com/einaros/ws/issues/227
 *
 * @param {String} uri
 * @param {Array} protocols (optional)
 * @param {Object) opts (optional)
 * @api public
 */

function ws(uri, protocols, opts) {
  var instance;
  if (protocols) {
    instance = new WebSocket(uri, protocols);
  } else {
    instance = new WebSocket(uri);
  }
  return instance;
}

if (WebSocket) ws.prototype = WebSocket.prototype;

},{}],76:[function(require,module,exports){
/**
 * cuid.js
 * Collision-resistant UID generator for browsers and node.
 * Sequential for fast db lookups and recency sorting.
 * Safe for element IDs and server-side lookups.
 *
 * Extracted from CLCTR
 * 
 * Copyright (c) Eric Elliott 2012
 * MIT License
 */

/*global window, navigator, document, require, process, module */
(function (app) {
  'use strict';
  var namespace = 'cuid',
    c = 0,
    blockSize = 4,
    base = 36,
    discreteValues = Math.pow(base, blockSize),

    pad = function pad(num, size) {
      var s = "000000000" + num;
      return s.substr(s.length-size);
    },

    randomBlock = function randomBlock() {
      return pad((Math.random() *
            discreteValues << 0)
            .toString(base), blockSize);
    },

    safeCounter = function () {
      c = (c < discreteValues) ? c : 0;
      c++; // this is not subliminal
      return c - 1;
    },

    api = function cuid() {
      // Starting with a lowercase letter makes
      // it HTML element ID friendly.
      var letter = 'c', // hard-coded allows for sequential access

        // timestamp
        // warning: this exposes the exact date and time
        // that the uid was created.
        timestamp = (new Date().getTime()).toString(base),

        // Prevent same-machine collisions.
        counter,

        // A few chars to generate distinct ids for different
        // clients (so different computers are far less
        // likely to generate the same id)
        fingerprint = api.fingerprint(),

        // Grab some more chars from Math.random()
        random = randomBlock() + randomBlock();

        counter = pad(safeCounter().toString(base), blockSize);

      return  (letter + timestamp + counter + fingerprint + random);
    };

  api.slug = function slug() {
    var date = new Date().getTime().toString(36),
      counter,
      print = api.fingerprint().slice(0,1) +
        api.fingerprint().slice(-1),
      random = randomBlock().slice(-2);

      counter = safeCounter().toString(36).slice(-4);

    return date.slice(-2) + 
      counter + print + random;
  };

  api.globalCount = function globalCount() {
    // We want to cache the results of this
    var cache = (function calc() {
        var i,
          count = 0;

        for (i in window) {
          count++;
        }

        return count;
      }());

    api.globalCount = function () { return cache; };
    return cache;
  };

  api.fingerprint = function browserPrint() {
    return pad((navigator.mimeTypes.length +
      navigator.userAgent.length).toString(36) +
      api.globalCount().toString(36), 4);
  };

  // don't change anything from here down.
  if (app.register) {
    app.register(namespace, api);
  } else if (typeof module !== 'undefined') {
    module.exports = api;
  } else {
    app[namespace] = api;
  }

}(this.applitude || this));

},{}],77:[function(require,module,exports){
/**
 * Title: KeyboardJS
 * Version: v0.4.1
 * Description: KeyboardJS is a flexible and easy to use keyboard binding
 * library.
 * Author: Robert Hurst.
 *
 * Copyright 2011, Robert William Hurst
 * Licenced under the BSD License.
 * See https://raw.github.com/RobertWHurst/KeyboardJS/master/license.txt
 */
(function(context, factory) {

	//INDEXOF POLLYFILL
	[].indexOf||(Array.prototype.indexOf=function(a,b,c){for(c=this.length,b=(c+~~b)%c;b<c&&(!(b in this)||this[b]!==a);b++);return b^c?b:-1;});

	//AMD
	if(typeof define === 'function' && define.amd) { define(constructAMD); }

	//CommonJS
	else if(typeof module !== 'undefined') {constructCommonJS()}

	//GLOBAL
	else { constructGlobal(); }

	/**
	 * Construct AMD version of the library
	 */
	function constructAMD() {

		//create a library instance
		return init();

		//spawns a library instance
		function init() {
			var library;
			library = factory('amd');
			library.fork = init;
			return library;
		}
	}

	/**
	 * Construct CommonJS version of the library
	 */
	function constructCommonJS() {

		//create a library instance
		module.exports = init();

		return;

		//spawns a library instance
		function init() {
			var library;
			library = factory('CommonJS');
			library.fork = init;
			return library;

		}

	}

	/**
	 * Construct a Global version of the library
	 */
	function constructGlobal() {
		var library;

		//create a library instance
		library = init();
		library.noConflict('KeyboardJS', 'k');

		//spawns a library instance
		function init() {
			var library, namespaces = [], previousValues = {};

			library = factory('global');
			library.fork = init;
			library.noConflict = noConflict;
			return library;

			//sets library namespaces
			function noConflict(    ) {
				var args, nI, newNamespaces;

				newNamespaces = Array.prototype.slice.apply(arguments);

				for(nI = 0; nI < namespaces.length; nI += 1) {
					if(typeof previousValues[namespaces[nI]] === 'undefined') {
						delete context[namespaces[nI]];
					} else {
						context[namespaces[nI]] = previousValues[namespaces[nI]];
					}
				}

				previousValues = {};

				for(nI = 0; nI < newNamespaces.length; nI += 1) {
					if(typeof newNamespaces[nI] !== 'string') {
						throw new Error('Cannot replace namespaces. All new namespaces must be strings.');
					}
					previousValues[newNamespaces[nI]] = context[newNamespaces[nI]];
					context[newNamespaces[nI]] = library;
				}

				namespaces = newNamespaces;

				return namespaces;
			}
		}
	}

})(this, function(env) {
	var KeyboardJS = {}, locales = {}, locale, map, macros, activeKeys = [], bindings = [], activeBindings = [],
	activeMacros = [], aI, usLocale;


	///////////////////////
	// DEFUALT US LOCALE //
	///////////////////////

	//define US locale
	//If you create a new locale please submit it as a pull request or post
	// it in the issue tracker at
	// http://github.com/RobertWhurst/KeyboardJS/issues/
	usLocale = {
		"map": {

			//general
			"3": ["cancel"],
			"8": ["backspace"],
			"9": ["tab"],
			"12": ["clear"],
			"13": ["enter"],
			"16": ["shift"],
			"17": ["ctrl"],
			"18": ["alt", "menu"],
			"19": ["pause", "break"],
			"20": ["capslock"],
			"27": ["escape", "esc"],
			"32": ["space", "spacebar"],
			"33": ["pageup"],
			"34": ["pagedown"],
			"35": ["end"],
			"36": ["home"],
			"37": ["left"],
			"38": ["up"],
			"39": ["right"],
			"40": ["down"],
			"41": ["select"],
			"42": ["printscreen"],
			"43": ["execute"],
			"44": ["snapshot"],
			"45": ["insert", "ins"],
			"46": ["delete", "del"],
			"47": ["help"],
			"91": ["command", "windows", "win", "super", "leftcommand", "leftwindows", "leftwin", "leftsuper"],
			"92": ["command", "windows", "win", "super", "rightcommand", "rightwindows", "rightwin", "rightsuper"],
			"145": ["scrolllock", "scroll"],
			"186": ["semicolon", ";"],
			"187": ["equal", "equalsign", "="],
			"188": ["comma", ","],
			"189": ["dash", "-"],
			"190": ["period", "."],
			"191": ["slash", "forwardslash", "/"],
			"192": ["graveaccent", "`"],
			"219": ["openbracket", "["],
			"220": ["backslash", "\\"],
			"221": ["closebracket", "]"],
			"222": ["apostrophe", "'"],

			//0-9
			"48": ["zero", "0"],
			"49": ["one", "1"],
			"50": ["two", "2"],
			"51": ["three", "3"],
			"52": ["four", "4"],
			"53": ["five", "5"],
			"54": ["six", "6"],
			"55": ["seven", "7"],
			"56": ["eight", "8"],
			"57": ["nine", "9"],

			//numpad
			"96": ["numzero", "num0"],
			"97": ["numone", "num1"],
			"98": ["numtwo", "num2"],
			"99": ["numthree", "num3"],
			"100": ["numfour", "num4"],
			"101": ["numfive", "num5"],
			"102": ["numsix", "num6"],
			"103": ["numseven", "num7"],
			"104": ["numeight", "num8"],
			"105": ["numnine", "num9"],
			"106": ["nummultiply", "num*"],
			"107": ["numadd", "num+"],
			"108": ["numenter"],
			"109": ["numsubtract", "num-"],
			"110": ["numdecimal", "num."],
			"111": ["numdevide", "num/"],
			"144": ["numlock", "num"],

			//function keys
			"112": ["f1"],
			"113": ["f2"],
			"114": ["f3"],
			"115": ["f4"],
			"116": ["f5"],
			"117": ["f6"],
			"118": ["f7"],
			"119": ["f8"],
			"120": ["f9"],
			"121": ["f10"],
			"122": ["f11"],
			"123": ["f12"]
		},
		"macros": [

			//secondary key symbols
			['shift + `', ["tilde", "~"]],
			['shift + 1', ["exclamation", "exclamationpoint", "!"]],
			['shift + 2', ["at", "@"]],
			['shift + 3', ["number", "#"]],
			['shift + 4', ["dollar", "dollars", "dollarsign", "$"]],
			['shift + 5', ["percent", "%"]],
			['shift + 6', ["caret", "^"]],
			['shift + 7', ["ampersand", "and", "&"]],
			['shift + 8', ["asterisk", "*"]],
			['shift + 9', ["openparen", "("]],
			['shift + 0', ["closeparen", ")"]],
			['shift + -', ["underscore", "_"]],
			['shift + =', ["plus", "+"]],
			['shift + (', ["opencurlybrace", "opencurlybracket", "{"]],
			['shift + )', ["closecurlybrace", "closecurlybracket", "}"]],
			['shift + \\', ["verticalbar", "|"]],
			['shift + ;', ["colon", ":"]],
			['shift + \'', ["quotationmark", "\""]],
			['shift + !,', ["openanglebracket", "<"]],
			['shift + .', ["closeanglebracket", ">"]],
			['shift + /', ["questionmark", "?"]]
		]
	};
	//a-z and A-Z
	for (aI = 65; aI <= 90; aI += 1) {
		usLocale.map[aI] = String.fromCharCode(aI + 32);
		usLocale.macros.push(['shift + ' + String.fromCharCode(aI + 32) + ', capslock + ' + String.fromCharCode(aI + 32), [String.fromCharCode(aI)]]);
	}
	registerLocale('us', usLocale);
	getSetLocale('us');


	//////////
	// INIT //
	//////////

	//enable the library
	enable();


	/////////
	// API //
	/////////

	//assemble the library and return it
	KeyboardJS.enable = enable;
	KeyboardJS.disable = disable;
	KeyboardJS.activeKeys = getActiveKeys;
	KeyboardJS.on = createBinding;
	KeyboardJS.clear = removeBindingByKeyCombo;
	KeyboardJS.clear.key = removeBindingByKeyName;
	KeyboardJS.locale = getSetLocale;
	KeyboardJS.locale.register = registerLocale;
	KeyboardJS.macro = createMacro;
	KeyboardJS.macro.remove = removeMacro;
	KeyboardJS.key = {};
	KeyboardJS.key.name = getKeyName;
	KeyboardJS.key.code = getKeyCode;
	KeyboardJS.combo = {};
	KeyboardJS.combo.active = isSatisfiedCombo;
	KeyboardJS.combo.parse = parseKeyCombo;
	KeyboardJS.combo.stringify = stringifyKeyCombo;
	return KeyboardJS;


	//////////////////////
	// INSTANCE METHODS //
	//////////////////////

	/**
	 * Enables KeyboardJS
	 */
	function enable() {
		if(window.addEventListener) {
			document.addEventListener('keydown', keydown, false);
			document.addEventListener('keyup', keyup, false);
			window.addEventListener('blur', reset, false);
			window.addEventListener('webkitfullscreenchange', reset, false);
			window.addEventListener('mozfullscreenchange', reset, false);
		} else if(window.attachEvent) {
			document.attachEvent('onkeydown', keydown);
			document.attachEvent('onkeyup', keyup);
			window.attachEvent('onblur', reset);
		}
	}

	/**
	 * Exits all active bindings and disables KeyboardJS
	 */
	function disable() {
		reset();
		if(window.removeEventListener) {
			document.removeEventListener('keydown', keydown, false);
			document.removeEventListener('keyup', keyup, false);
			window.removeEventListener('blur', reset, false);
			window.removeEventListener('webkitfullscreenchange', reset, false);
			window.removeEventListener('mozfullscreenchange', reset, false);
		} else if(window.detachEvent) {
			document.detachEvent('onkeydown', keydown);
			document.detachEvent('onkeyup', keyup);
			window.detachEvent('onblur', reset);
		}
	}


	////////////////////
	// EVENT HANDLERS //
	////////////////////

	/**
	 * Exits all active bindings. Optionally passes an event to all binding
	 *  handlers.
	 * @param  {KeyboardEvent}	event	[Optional]
	 */
	function reset(event) {
		activeKeys = [];
		pruneMacros();
		pruneBindings(event);
	}

	/**
	 * Key down event handler.
	 * @param  {KeyboardEvent}	event
	 */
	function keydown(event) {
		var keyNames, keyName, kI;
		keyNames = getKeyName(event.keyCode);
		if(keyNames.length < 1) { return; }
		event.isRepeat = false;
		for(kI = 0; kI < keyNames.length; kI += 1) {
		    keyName = keyNames[kI];
		    if (getActiveKeys().indexOf(keyName) != -1)
		        event.isRepeat = true;
			addActiveKey(keyName);
		}
		executeMacros();
		executeBindings(event);
	}

	/**
	 * Key up event handler.
	 * @param  {KeyboardEvent} event
	 */
	function keyup(event) {
		var keyNames, kI;
		keyNames = getKeyName(event.keyCode);
		if(keyNames.length < 1) { return; }
		for(kI = 0; kI < keyNames.length; kI += 1) {
			removeActiveKey(keyNames[kI]);
		}
		pruneMacros();
		pruneBindings(event);
	}

	/**
	 * Accepts a key code and returns the key names defined by the current
	 *  locale.
	 * @param  {Number}	keyCode
	 * @return {Array}	keyNames	An array of key names defined for the key
	 *  code as defined by the current locale.
	 */
	function getKeyName(keyCode) {
		return map[keyCode] || [];
	}

	/**
	 * Accepts a key name and returns the key code defined by the current
	 *  locale.
	 * @param  {Number}	keyName
	 * @return {Number|false}
	 */
	function getKeyCode(keyName) {
		var keyCode;
		for(keyCode in map) {
			if(!map.hasOwnProperty(keyCode)) { continue; }
			if(map[keyCode].indexOf(keyName) > -1) { return keyCode; }
		}
		return false;
	}


	////////////
	// MACROS //
	////////////

	/**
	 * Accepts a key combo and an array of key names to inject once the key
	 *  combo is satisfied.
	 * @param  {String}	combo
	 * @param  {Array}	injectedKeys
	 */
	function createMacro(combo, injectedKeys) {
		if(typeof combo !== 'string' && (typeof combo !== 'object' || typeof combo.push !== 'function')) {
			throw new Error("Cannot create macro. The combo must be a string or array.");
		}
		if(typeof injectedKeys !== 'object' || typeof injectedKeys.push !== 'function') {
			throw new Error("Cannot create macro. The injectedKeys must be an array.");
		}
		macros.push([combo, injectedKeys]);
	}

	/**
	 * Accepts a key combo and clears any and all macros bound to that key
	 * combo.
	 * @param  {String} combo
	 */
	function removeMacro(combo) {
		var macro;
		if(typeof combo !== 'string' && (typeof combo !== 'object' || typeof combo.push !== 'function')) { throw new Error("Cannot remove macro. The combo must be a string or array."); }
		for(mI = 0; mI < macros.length; mI += 1) {
			macro = macros[mI];
			if(compareCombos(combo, macro[0])) {
				removeActiveKey(macro[1]);
				macros.splice(mI, 1);
				break;
			}
		}
	}

	/**
	 * Executes macros against the active keys. Each macro's key combo is
	 *  checked and if found to be satisfied, the macro's key names are injected
	 *  into active keys.
	 */
	function executeMacros() {
		var mI, combo, kI;
		for(mI = 0; mI < macros.length; mI += 1) {
			combo = parseKeyCombo(macros[mI][0]);
			if(activeMacros.indexOf(macros[mI]) === -1 && isSatisfiedCombo(combo)) {
				activeMacros.push(macros[mI]);
				for(kI = 0; kI < macros[mI][1].length; kI += 1) {
					addActiveKey(macros[mI][1][kI]);
				}
			}
		}
	}

	/**
	 * Prunes active macros. Checks each active macro's key combo and if found
	 *  to no longer to be satisfied, each of the macro's key names are removed
	 *  from active keys.
	 */
	function pruneMacros() {
		var mI, combo, kI;
		for(mI = 0; mI < activeMacros.length; mI += 1) {
			combo = parseKeyCombo(activeMacros[mI][0]);
			if(isSatisfiedCombo(combo) === false) {
				for(kI = 0; kI < activeMacros[mI][1].length; kI += 1) {
					removeActiveKey(activeMacros[mI][1][kI]);
				}
				activeMacros.splice(mI, 1);
				mI -= 1;
			}
		}
	}


	//////////////
	// BINDINGS //
	//////////////

	/**
	 * Creates a binding object, and, if provided, binds a key down hander and
	 *  a key up handler. Returns a binding object that emits keyup and
	 *  keydown events.
	 * @param  {String}		keyCombo
	 * @param  {Function}	keyDownCallback	[Optional]
	 * @param  {Function}	keyUpCallback	[Optional]
	 * @return {Object}		binding
	 */
	function createBinding(keyCombo, keyDownCallback, keyUpCallback) {
		var api = {}, binding, subBindings = [], bindingApi = {}, kI,
		subCombo;

		//break the combo down into a combo array
		if(typeof keyCombo === 'string') {
			keyCombo = parseKeyCombo(keyCombo);
		}

		//bind each sub combo contained within the combo string
		for(kI = 0; kI < keyCombo.length; kI += 1) {
			binding = {};

			//stringify the combo again
			subCombo = stringifyKeyCombo([keyCombo[kI]]);

			//validate the sub combo
			if(typeof subCombo !== 'string') { throw new Error('Failed to bind key combo. The key combo must be string.'); }

			//create the binding
			binding.keyCombo = subCombo;
			binding.keyDownCallback = [];
			binding.keyUpCallback = [];

			//inject the key down and key up callbacks if given
			if(keyDownCallback) { binding.keyDownCallback.push(keyDownCallback); }
			if(keyUpCallback) { binding.keyUpCallback.push(keyUpCallback); }

			//stash the new binding
			bindings.push(binding);
			subBindings.push(binding);
		}

		//build the binding api
		api.clear = clear;
		api.on = on;
		return api;

		/**
		 * Clears the binding
		 */
		function clear() {
			var bI;
			for(bI = 0; bI < subBindings.length; bI += 1) {
				bindings.splice(bindings.indexOf(subBindings[bI]), 1);
			}
		}

		/**
		 * Accepts an event name. and any number of callbacks. When the event is
		 *  emitted, all callbacks are executed. Available events are key up and
		 *  key down.
		 * @param  {String}	eventName
		 * @return {Object}	subBinding
		 */
		function on(eventName    ) {
			var api = {}, callbacks, cI, bI;

			//validate event name
			if(typeof eventName !== 'string') { throw new Error('Cannot bind callback. The event name must be a string.'); }
			if(eventName !== 'keyup' && eventName !== 'keydown') { throw new Error('Cannot bind callback. The event name must be a "keyup" or "keydown".'); }

			//gather the callbacks
			callbacks = Array.prototype.slice.apply(arguments, [1]);

			//stash each the new binding
			for(cI = 0; cI < callbacks.length; cI += 1) {
				if(typeof callbacks[cI] === 'function') {
					if(eventName === 'keyup') {
						for(bI = 0; bI < subBindings.length; bI += 1) {
							subBindings[bI].keyUpCallback.push(callbacks[cI]);
						}
					} else if(eventName === 'keydown') {
						for(bI = 0; bI < subBindings.length; bI += 1) {
							subBindings[bI].keyDownCallback.push(callbacks[cI]);
						}
					}
				}
			}

			//construct and return the sub binding api
			api.clear = clear;
			return api;

			/**
			 * Clears the binding
			 */
			function clear() {
				var cI, bI;
				for(cI = 0; cI < callbacks.length; cI += 1) {
					if(typeof callbacks[cI] === 'function') {
						if(eventName === 'keyup') {
							for(bI = 0; bI < subBindings.length; bI += 1) {
								subBindings[bI].keyUpCallback.splice(subBindings[bI].keyUpCallback.indexOf(callbacks[cI]), 1);
							}
						} else {
							for(bI = 0; bI < subBindings.length; bI += 1) {
								subBindings[bI].keyDownCallback.splice(subBindings[bI].keyDownCallback.indexOf(callbacks[cI]), 1);
							}
						}
					}
				}
			}
		}
	}

	/**
	 * Clears all binding attached to a given key combo. Key name order does not
	 * matter as long as the key combos equate.
	 * @param  {String}	keyCombo
	 */
	function removeBindingByKeyCombo(keyCombo) {
		var bI, binding, keyName;
		for(bI = 0; bI < bindings.length; bI += 1) {
			binding = bindings[bI];
			if(compareCombos(keyCombo, binding.keyCombo)) {
				bindings.splice(bI, 1); bI -= 1;
			}
		}
	}

	/**
	 * Clears all binding attached to key combos containing a given key name.
	 * @param  {String}	keyName
	 */
	function removeBindingByKeyName(keyName) {
		var bI, kI, binding;
		if(keyName) {
			for(bI = 0; bI < bindings.length; bI += 1) {
				binding = bindings[bI];
				for(kI = 0; kI < binding.keyCombo.length; kI += 1) {
					if(binding.keyCombo[kI].indexOf(keyName) > -1) {
						bindings.splice(bI, 1); bI -= 1;
						break;
					}
				}
			}
		} else {
			bindings = [];
		}
	}

	/**
	 * Executes bindings that are active. Only allows the keys to be used once
	 *  as to prevent binding overlap.
	 * @param  {KeyboardEvent}	event	The keyboard event.
	 */
	function executeBindings(event) {
		var bI, sBI, binding, bindingKeys, remainingKeys, cI, killEventBubble, kI, bindingKeysSatisfied,
		index, sortedBindings = [], bindingWeight;

		remainingKeys = [].concat(activeKeys);
		for(bI = 0; bI < bindings.length; bI += 1) {
			bindingWeight = extractComboKeys(bindings[bI].keyCombo).length;
			if(!sortedBindings[bindingWeight]) { sortedBindings[bindingWeight] = []; }
			sortedBindings[bindingWeight].push(bindings[bI]);
		}
		for(sBI = sortedBindings.length - 1; sBI >= 0; sBI -= 1) {
			if(!sortedBindings[sBI]) { continue; }
			for(bI = 0; bI < sortedBindings[sBI].length; bI += 1) {
				binding = sortedBindings[sBI][bI];
				bindingKeys = extractComboKeys(binding.keyCombo);
				bindingKeysSatisfied = true;
				for(kI = 0; kI < bindingKeys.length; kI += 1) {
					if(remainingKeys.indexOf(bindingKeys[kI]) === -1) {
						bindingKeysSatisfied = false;
						break;
					}
				}
				if(bindingKeysSatisfied && isSatisfiedCombo(binding.keyCombo)) {
					activeBindings.push(binding);
					for(kI = 0; kI < bindingKeys.length; kI += 1) {
						index = remainingKeys.indexOf(bindingKeys[kI]);
						if(index > -1) {
							remainingKeys.splice(index, 1);
							kI -= 1;
						}
					}
					for(cI = 0; cI < binding.keyDownCallback.length; cI += 1) {
						if (binding.keyDownCallback[cI](event, getActiveKeys(), binding.keyCombo) === false) {
							killEventBubble = true;
						}
					}
					if(killEventBubble === true) {
						event.preventDefault();
						event.stopPropagation();
					}
				}
			}
		}
	}

	/**
	 * Removes bindings that are no longer satisfied by the active keys. Also
	 *  fires the key up callbacks.
	 * @param  {KeyboardEvent}	event
	 */
	function pruneBindings(event) {
		var bI, cI, binding, killEventBubble;
		for(bI = 0; bI < activeBindings.length; bI += 1) {
			binding = activeBindings[bI];
			if(isSatisfiedCombo(binding.keyCombo) === false) {
				for(cI = 0; cI < binding.keyUpCallback.length; cI += 1) {
					if (binding.keyUpCallback[cI](event, getActiveKeys(), binding.keyCombo) === false) {
						killEventBubble = true;
					}
				}
				if(killEventBubble === true) {
					event.preventDefault();
					event.stopPropagation();
				}
				activeBindings.splice(bI, 1);
				bI -= 1;
			}
		}
	}


	///////////////////
	// COMBO STRINGS //
	///////////////////

	/**
	 * Compares two key combos returning true when they are functionally
	 *  equivalent.
	 * @param  {String}	keyComboArrayA keyCombo A key combo string or array.
	 * @param  {String}	keyComboArrayB keyCombo A key combo string or array.
	 * @return {Boolean}
	 */
	function compareCombos(keyComboArrayA, keyComboArrayB) {
		var cI, sI, kI;
		keyComboArrayA = parseKeyCombo(keyComboArrayA);
		keyComboArrayB = parseKeyCombo(keyComboArrayB);
		if(keyComboArrayA.length !== keyComboArrayB.length) { return false; }
		for(cI = 0; cI < keyComboArrayA.length; cI += 1) {
			if(keyComboArrayA[cI].length !== keyComboArrayB[cI].length) { return false; }
			for(sI = 0; sI < keyComboArrayA[cI].length; sI += 1) {
				if(keyComboArrayA[cI][sI].length !== keyComboArrayB[cI][sI].length) { return false; }
				for(kI = 0; kI < keyComboArrayA[cI][sI].length; kI += 1) {
					if(keyComboArrayB[cI][sI].indexOf(keyComboArrayA[cI][sI][kI]) === -1) { return false; }
				}
			}
		}
		return true;
	}

	/**
	 * Checks to see if a key combo string or key array is satisfied by the
	 *  currently active keys. It does not take into account spent keys.
	 * @param  {String}	keyCombo	A key combo string or array.
	 * @return {Boolean}
	 */
	function isSatisfiedCombo(keyCombo) {
		var cI, sI, stage, kI, stageOffset = 0, index, comboMatches;
		keyCombo = parseKeyCombo(keyCombo);
		for(cI = 0; cI < keyCombo.length; cI += 1) {
			comboMatches = true;
			stageOffset = 0;
			for(sI = 0; sI < keyCombo[cI].length; sI += 1) {
				stage = [].concat(keyCombo[cI][sI]);
				for(kI = stageOffset; kI < activeKeys.length; kI += 1) {
					index = stage.indexOf(activeKeys[kI]);
					if(index > -1) {
						stage.splice(index, 1);
						stageOffset = kI;
					}
				}
				if(stage.length !== 0) { comboMatches = false; break; }
			}
			if(comboMatches) { return true; }
		}
		return false;
	}

	/**
	 * Accepts a key combo array or string and returns a flat array containing all keys referenced by
	 * the key combo.
	 * @param  {String}	keyCombo	A key combo string or array.
	 * @return {Array}
	 */
	function extractComboKeys(keyCombo) {
		var cI, sI, kI, keys = [];
		keyCombo = parseKeyCombo(keyCombo);
		for(cI = 0; cI < keyCombo.length; cI += 1) {
			for(sI = 0; sI < keyCombo[cI].length; sI += 1) {
				keys = keys.concat(keyCombo[cI][sI]);
			}
		}
		return keys;
	}

	/**
	 * Parses a key combo string into a 3 dimensional array.
	 * - Level 1 - sub combos.
	 * - Level 2 - combo stages. A stage is a set of key name pairs that must
	 *  be satisfied in the order they are defined.
	 * - Level 3 - each key name to the stage.
	 * @param  {String|Array}	keyCombo	A key combo string.
	 * @return {Array}
	 */
	function parseKeyCombo(keyCombo) {
		var s = keyCombo, i = 0, op = 0, ws = false, nc = false, combos = [], combo = [], stage = [], key = '';

		if(typeof keyCombo === 'object' && typeof keyCombo.push === 'function') { return keyCombo; }
		if(typeof keyCombo !== 'string') { throw new Error('Cannot parse "keyCombo" because its type is "' + (typeof keyCombo) + '". It must be a "string".'); }

		//remove leading whitespace
		while(s.charAt(i) === ' ') { i += 1; }
		while(true) {
			if(s.charAt(i) === ' ') {
				//white space & next combo op
				while(s.charAt(i) === ' ') { i += 1; }
				ws = true;
			} else if(s.charAt(i) === ',') {
				if(op || nc) { throw new Error('Failed to parse key combo. Unexpected , at character index ' + i + '.'); }
				nc = true;
				i += 1;
			} else if(s.charAt(i) === '+') {
				//next key
				if(key.length) { stage.push(key); key = ''; }
				if(op || nc) { throw new Error('Failed to parse key combo. Unexpected + at character index ' + i + '.'); }
				op = true;
				i += 1;
			} else if(s.charAt(i) === '>') {
				//next stage op
				if(key.length) { stage.push(key); key = ''; }
				if(stage.length) { combo.push(stage); stage = []; }
				if(op || nc) { throw new Error('Failed to parse key combo. Unexpected > at character index ' + i + '.'); }
				op = true;
				i += 1;
			} else if(i < s.length - 1 && s.charAt(i) === '!' && (s.charAt(i + 1) === '>' || s.charAt(i + 1) === ',' || s.charAt(i + 1) === '+')) {
				key += s.charAt(i + 1);
				op = false;
				ws = false;
				nc = false;
				i += 2;
			} else if(i < s.length && s.charAt(i) !== '+' && s.charAt(i) !== '>' && s.charAt(i) !== ',' && s.charAt(i) !== ' ') {
				//end combo
				if(op === false && ws === true || nc === true) {
					if(key.length) { stage.push(key); key = ''; }
					if(stage.length) { combo.push(stage); stage = []; }
					if(combo.length) { combos.push(combo); combo = []; }
				}
				op = false;
				ws = false;
				nc = false;
				//key
				while(i < s.length && s.charAt(i) !== '+' && s.charAt(i) !== '>' && s.charAt(i) !== ',' && s.charAt(i) !== ' ') {
					key += s.charAt(i);
					i += 1;
				}
			} else {
				//unknown char
				i += 1;
				continue;
			}
			//end of combos string
			if(i >= s.length) {
				if(key.length) { stage.push(key); key = ''; }
				if(stage.length) { combo.push(stage); stage = []; }
				if(combo.length) { combos.push(combo); combo = []; }
				break;
			}
		}
		return combos;
	}

	/**
	 * Stringifys a key combo.
	 * @param  {Array|String}	keyComboArray	A key combo array. If a key
	 *  combo string is given it will be returned.
	 * @return {String}
	 */
	function stringifyKeyCombo(keyComboArray) {
		var cI, ccI, output = [];
		if(typeof keyComboArray === 'string') { return keyComboArray; }
		if(typeof keyComboArray !== 'object' || typeof keyComboArray.push !== 'function') { throw new Error('Cannot stringify key combo.'); }
		for(cI = 0; cI < keyComboArray.length; cI += 1) {
			output[cI] = [];
			for(ccI = 0; ccI < keyComboArray[cI].length; ccI += 1) {
				output[cI][ccI] = keyComboArray[cI][ccI].join(' + ');
			}
			output[cI] = output[cI].join(' > ');
		}
		return output.join(' ');
	}


	/////////////////
	// ACTIVE KEYS //
	/////////////////

	/**
	 * Returns the a copy of the active keys array.
	 * @return {Array}
	 */
	function getActiveKeys() {
		return [].concat(activeKeys);
	}

	/**
	 * Adds a key to the active keys array, but only if it has not already been
	 *  added.
	 * @param {String}	keyName	The key name string.
	 */
	function addActiveKey(keyName) {
		if(keyName.match(/\s/)) { throw new Error('Cannot add key name ' + keyName + ' to active keys because it contains whitespace.'); }
		if(activeKeys.indexOf(keyName) > -1) { return; }
		activeKeys.push(keyName);
	}

	/**
	 * Removes a key from the active keys array.
	 * @param  {String}	keyNames	The key name string.
	 */
	function removeActiveKey(keyName) {
		var keyCode = getKeyCode(keyName);
		if(keyCode === '91' || keyCode === '92') { activeKeys = []; } //remove all key on release of super.
		else { activeKeys.splice(activeKeys.indexOf(keyName), 1); }
	}


	/////////////
	// LOCALES //
	/////////////

	/**
	 * Registers a new locale. This is useful if you would like to add support for a new keyboard layout. It could also be useful for
	 * alternative key names. For example if you program games you could create a locale for your key mappings. Instead of key 65 mapped
	 * to 'a' you could map it to 'jump'.
	 * @param  {String}	localeName	The name of the new locale.
	 * @param  {Object}	localeMap	The locale map.
	 */
	function registerLocale(localeName, localeMap) {

		//validate arguments
		if(typeof localeName !== 'string') { throw new Error('Cannot register new locale. The locale name must be a string.'); }
		if(typeof localeMap !== 'object') { throw new Error('Cannot register ' + localeName + ' locale. The locale map must be an object.'); }
		if(typeof localeMap.map !== 'object') { throw new Error('Cannot register ' + localeName + ' locale. The locale map is invalid.'); }

		//stash the locale
		if(!localeMap.macros) { localeMap.macros = []; }
		locales[localeName] = localeMap;
	}

	/**
	 * Swaps the current locale.
	 * @param  {String}	localeName	The locale to activate.
	 * @return {Object}
	 */
	function getSetLocale(localeName) {

		//if a new locale is given then set it
		if(localeName) {
			if(typeof localeName !== 'string') { throw new Error('Cannot set locale. The locale name must be a string.'); }
			if(!locales[localeName]) { throw new Error('Cannot set locale to ' + localeName + ' because it does not exist. If you would like to submit a ' + localeName + ' locale map for KeyboardJS please submit it at https://github.com/RobertWHurst/KeyboardJS/issues.'); }

			//set the current map and macros
			map = locales[localeName].map;
			macros = locales[localeName].macros;

			//set the current locale
			locale = localeName;
		}

		//return the current locale
		return locale;
	}
});

},{}],78:[function(require,module,exports){
module.exports = require('./lib/ReactWithAddons');

},{"./lib/ReactWithAddons":166}],79:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule AutoFocusMixin
 * @typechecks static-only
 */

"use strict";

var focusNode = require("./focusNode");

var AutoFocusMixin = {
  componentDidMount: function() {
    if (this.props.autoFocus) {
      focusNode(this.getDOMNode());
    }
  }
};

module.exports = AutoFocusMixin;

},{"./focusNode":198}],80:[function(require,module,exports){
/**
 * Copyright 2013 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule BeforeInputEventPlugin
 * @typechecks static-only
 */

"use strict";

var EventConstants = require("./EventConstants");
var EventPropagators = require("./EventPropagators");
var ExecutionEnvironment = require("./ExecutionEnvironment");
var SyntheticInputEvent = require("./SyntheticInputEvent");

var keyOf = require("./keyOf");

var canUseTextInputEvent = (
  ExecutionEnvironment.canUseDOM &&
  'TextEvent' in window &&
  !('documentMode' in document || isPresto())
);

/**
 * Opera <= 12 includes TextEvent in window, but does not fire
 * text input events. Rely on keypress instead.
 */
function isPresto() {
  var opera = window.opera;
  return (
    typeof opera === 'object' &&
    typeof opera.version === 'function' &&
    parseInt(opera.version(), 10) <= 12
  );
}

var SPACEBAR_CODE = 32;
var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);

var topLevelTypes = EventConstants.topLevelTypes;

// Events and their corresponding property names.
var eventTypes = {
  beforeInput: {
    phasedRegistrationNames: {
      bubbled: keyOf({onBeforeInput: null}),
      captured: keyOf({onBeforeInputCapture: null})
    },
    dependencies: [
      topLevelTypes.topCompositionEnd,
      topLevelTypes.topKeyPress,
      topLevelTypes.topTextInput,
      topLevelTypes.topPaste
    ]
  }
};

// Track characters inserted via keypress and composition events.
var fallbackChars = null;

/**
 * Return whether a native keypress event is assumed to be a command.
 * This is required because Firefox fires `keypress` events for key commands
 * (cut, copy, select-all, etc.) even though no character is inserted.
 */
function isKeypressCommand(nativeEvent) {
  return (
    (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
    // ctrlKey && altKey is equivalent to AltGr, and is not a command.
    !(nativeEvent.ctrlKey && nativeEvent.altKey)
  );
}

/**
 * Create an `onBeforeInput` event to match
 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
 *
 * This event plugin is based on the native `textInput` event
 * available in Chrome, Safari, Opera, and IE. This event fires after
 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
 *
 * `beforeInput` is spec'd but not implemented in any browsers, and
 * the `input` event does not provide any useful information about what has
 * actually been added, contrary to the spec. Thus, `textInput` is the best
 * available event to identify the characters that have actually been inserted
 * into the target node.
 */
var BeforeInputEventPlugin = {

  eventTypes: eventTypes,

  /**
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function(
      topLevelType,
      topLevelTarget,
      topLevelTargetID,
      nativeEvent) {

    var chars;

    if (canUseTextInputEvent) {
      switch (topLevelType) {
        case topLevelTypes.topKeyPress:
          /**
           * If native `textInput` events are available, our goal is to make
           * use of them. However, there is a special case: the spacebar key.
           * In Webkit, preventing default on a spacebar `textInput` event
           * cancels character insertion, but it *also* causes the browser
           * to fall back to its default spacebar behavior of scrolling the
           * page.
           *
           * Tracking at:
           * https://code.google.com/p/chromium/issues/detail?id=355103
           *
           * To avoid this issue, use the keypress event as if no `textInput`
           * event is available.
           */
          var which = nativeEvent.which;
          if (which !== SPACEBAR_CODE) {
            return;
          }

          chars = String.fromCharCode(which);
          break;

        case topLevelTypes.topTextInput:
          // Record the characters to be added to the DOM.
          chars = nativeEvent.data;

          // If it's a spacebar character, assume that we have already handled
          // it at the keypress level and bail immediately.
          if (chars === SPACEBAR_CHAR) {
            return;
          }

          // Otherwise, carry on.
          break;

        default:
          // For other native event types, do nothing.
          return;
      }
    } else {
      switch (topLevelType) {
        case topLevelTypes.topPaste:
          // If a paste event occurs after a keypress, throw out the input
          // chars. Paste events should not lead to BeforeInput events.
          fallbackChars = null;
          break;
        case topLevelTypes.topKeyPress:
          /**
           * As of v27, Firefox may fire keypress events even when no character
           * will be inserted. A few possibilities:
           *
           * - `which` is `0`. Arrow keys, Esc key, etc.
           *
           * - `which` is the pressed key code, but no char is available.
           *   Ex: 'AltGr + d` in Polish. There is no modified character for
           *   this key combination and no character is inserted into the
           *   document, but FF fires the keypress for char code `100` anyway.
           *   No `input` event will occur.
           *
           * - `which` is the pressed key code, but a command combination is
           *   being used. Ex: `Cmd+C`. No character is inserted, and no
           *   `input` event will occur.
           */
          if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
            fallbackChars = String.fromCharCode(nativeEvent.which);
          }
          break;
        case topLevelTypes.topCompositionEnd:
          fallbackChars = nativeEvent.data;
          break;
      }

      // If no changes have occurred to the fallback string, no relevant
      // event has fired and we're done.
      if (fallbackChars === null) {
        return;
      }

      chars = fallbackChars;
    }

    // If no characters are being inserted, no BeforeInput event should
    // be fired.
    if (!chars) {
      return;
    }

    var event = SyntheticInputEvent.getPooled(
      eventTypes.beforeInput,
      topLevelTargetID,
      nativeEvent
    );

    event.data = chars;
    fallbackChars = null;
    EventPropagators.accumulateTwoPhaseDispatches(event);
    return event;
  }
};

module.exports = BeforeInputEventPlugin;

},{"./EventConstants":94,"./EventPropagators":99,"./ExecutionEnvironment":100,"./SyntheticInputEvent":176,"./keyOf":219}],81:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule CSSCore
 * @typechecks
 */

var invariant = require("./invariant");

/**
 * The CSSCore module specifies the API (and implements most of the methods)
 * that should be used when dealing with the display of elements (via their
 * CSS classes and visibility on screen. It is an API focused on mutating the
 * display and not reading it as no logical state should be encoded in the
 * display of elements.
 */

var CSSCore = {

  /**
   * Adds the class passed in to the element if it doesn't already have it.
   *
   * @param {DOMElement} element the element to set the class on
   * @param {string} className the CSS className
   * @return {DOMElement} the element passed in
   */
  addClass: function(element, className) {
    ("production" !== process.env.NODE_ENV ? invariant(
      !/\s/.test(className),
      'CSSCore.addClass takes only a single class name. "%s" contains ' +
      'multiple classes.', className
    ) : invariant(!/\s/.test(className)));

    if (className) {
      if (element.classList) {
        element.classList.add(className);
      } else if (!CSSCore.hasClass(element, className)) {
        element.className = element.className + ' ' + className;
      }
    }
    return element;
  },

  /**
   * Removes the class passed in from the element
   *
   * @param {DOMElement} element the element to set the class on
   * @param {string} className the CSS className
   * @return {DOMElement} the element passed in
   */
  removeClass: function(element, className) {
    ("production" !== process.env.NODE_ENV ? invariant(
      !/\s/.test(className),
      'CSSCore.removeClass takes only a single class name. "%s" contains ' +
      'multiple classes.', className
    ) : invariant(!/\s/.test(className)));

    if (className) {
      if (element.classList) {
        element.classList.remove(className);
      } else if (CSSCore.hasClass(element, className)) {
        element.className = element.className
          .replace(new RegExp('(^|\\s)' + className + '(?:\\s|$)', 'g'), '$1')
          .replace(/\s+/g, ' ') // multiple spaces to one
          .replace(/^\s*|\s*$/g, ''); // trim the ends
      }
    }
    return element;
  },

  /**
   * Helper to add or remove a class from an element based on a condition.
   *
   * @param {DOMElement} element the element to set the class on
   * @param {string} className the CSS className
   * @param {*} bool condition to whether to add or remove the class
   * @return {DOMElement} the element passed in
   */
  conditionClass: function(element, className, bool) {
    return (bool ? CSSCore.addClass : CSSCore.removeClass)(element, className);
  },

  /**
   * Tests whether the element has the class specified.
   *
   * @param {DOMNode|DOMWindow} element the element to set the class on
   * @param {string} className the CSS className
   * @returns {boolean} true if the element has the class, false if not
   */
  hasClass: function(element, className) {
    ("production" !== process.env.NODE_ENV ? invariant(
      !/\s/.test(className),
      'CSS.hasClass takes only a single class name.'
    ) : invariant(!/\s/.test(className)));
    if (element.classList) {
      return !!className && element.classList.contains(className);
    }
    return (' ' + element.className + ' ').indexOf(' ' + className + ' ') > -1;
  }

};

module.exports = CSSCore;

}).call(this,require('_process'))
},{"./invariant":212,"_process":73}],82:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule CSSProperty
 */

"use strict";

/**
 * CSS properties which accept numbers but are not in units of "px".
 */
var isUnitlessNumber = {
  columnCount: true,
  fillOpacity: true,
  flex: true,
  flexGrow: true,
  flexShrink: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  widows: true,
  zIndex: true,
  zoom: true
};

/**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */
function prefixKey(prefix, key) {
  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
}

/**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */
var prefixes = ['Webkit', 'ms', 'Moz', 'O'];

// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
// infinite loop, because it iterates over the newly added props too.
Object.keys(isUnitlessNumber).forEach(function(prop) {
  prefixes.forEach(function(prefix) {
    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
  });
});

/**
 * Most style properties can be unset by doing .style[prop] = '' but IE8
 * doesn't like doing that with shorthand properties so for the properties that
 * IE8 breaks on, which are listed here, we instead unset each of the
 * individual properties. See http://bugs.jquery.com/ticket/12385.
 * The 4-value 'clock' properties like margin, padding, border-width seem to
 * behave without any problems. Curiously, list-style works too without any
 * special prodding.
 */
var shorthandPropertyExpansions = {
  background: {
    backgroundImage: true,
    backgroundPosition: true,
    backgroundRepeat: true,
    backgroundColor: true
  },
  border: {
    borderWidth: true,
    borderStyle: true,
    borderColor: true
  },
  borderBottom: {
    borderBottomWidth: true,
    borderBottomStyle: true,
    borderBottomColor: true
  },
  borderLeft: {
    borderLeftWidth: true,
    borderLeftStyle: true,
    borderLeftColor: true
  },
  borderRight: {
    borderRightWidth: true,
    borderRightStyle: true,
    borderRightColor: true
  },
  borderTop: {
    borderTopWidth: true,
    borderTopStyle: true,
    borderTopColor: true
  },
  font: {
    fontStyle: true,
    fontVariant: true,
    fontWeight: true,
    fontSize: true,
    lineHeight: true,
    fontFamily: true
  }
};

var CSSProperty = {
  isUnitlessNumber: isUnitlessNumber,
  shorthandPropertyExpansions: shorthandPropertyExpansions
};

module.exports = CSSProperty;

},{}],83:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule CSSPropertyOperations
 * @typechecks static-only
 */

"use strict";

var CSSProperty = require("./CSSProperty");

var dangerousStyleValue = require("./dangerousStyleValue");
var hyphenateStyleName = require("./hyphenateStyleName");
var memoizeStringOnly = require("./memoizeStringOnly");

var processStyleName = memoizeStringOnly(function(styleName) {
  return hyphenateStyleName(styleName);
});

/**
 * Operations for dealing with CSS properties.
 */
var CSSPropertyOperations = {

  /**
   * Serializes a mapping of style properties for use as inline styles:
   *
   *   > createMarkupForStyles({width: '200px', height: 0})
   *   "width:200px;height:0;"
   *
   * Undefined values are ignored so that declarative programming is easier.
   * The result should be HTML-escaped before insertion into the DOM.
   *
   * @param {object} styles
   * @return {?string}
   */
  createMarkupForStyles: function(styles) {
    var serialized = '';
    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }
      var styleValue = styles[styleName];
      if (styleValue != null) {
        serialized += processStyleName(styleName) + ':';
        serialized += dangerousStyleValue(styleName, styleValue) + ';';
      }
    }
    return serialized || null;
  },

  /**
   * Sets the value for multiple styles on a node.  If a value is specified as
   * '' (empty string), the corresponding style property will be unset.
   *
   * @param {DOMElement} node
   * @param {object} styles
   */
  setValueForStyles: function(node, styles) {
    var style = node.style;
    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }
      var styleValue = dangerousStyleValue(styleName, styles[styleName]);
      if (styleValue) {
        style[styleName] = styleValue;
      } else {
        var expansion = CSSProperty.shorthandPropertyExpansions[styleName];
        if (expansion) {
          // Shorthand property that IE8 won't like unsetting, so unset each
          // component to placate it
          for (var individualStyleName in expansion) {
            style[individualStyleName] = '';
          }
        } else {
          style[styleName] = '';
        }
      }
    }
  }

};

module.exports = CSSPropertyOperations;

},{"./CSSProperty":82,"./dangerousStyleValue":193,"./hyphenateStyleName":210,"./memoizeStringOnly":221}],84:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule CallbackQueue
 */

"use strict";

var PooledClass = require("./PooledClass");

var invariant = require("./invariant");
var mixInto = require("./mixInto");

/**
 * A specialized pseudo-event module to help keep track of components waiting to
 * be notified when their DOM representations are available for use.
 *
 * This implements `PooledClass`, so you should never need to instantiate this.
 * Instead, use `CallbackQueue.getPooled()`.
 *
 * @class ReactMountReady
 * @implements PooledClass
 * @internal
 */
function CallbackQueue() {
  this._callbacks = null;
  this._contexts = null;
}

mixInto(CallbackQueue, {

  /**
   * Enqueues a callback to be invoked when `notifyAll` is invoked.
   *
   * @param {function} callback Invoked when `notifyAll` is invoked.
   * @param {?object} context Context to call `callback` with.
   * @internal
   */
  enqueue: function(callback, context) {
    this._callbacks = this._callbacks || [];
    this._contexts = this._contexts || [];
    this._callbacks.push(callback);
    this._contexts.push(context);
  },

  /**
   * Invokes all enqueued callbacks and clears the queue. This is invoked after
   * the DOM representation of a component has been created or updated.
   *
   * @internal
   */
  notifyAll: function() {
    var callbacks = this._callbacks;
    var contexts = this._contexts;
    if (callbacks) {
      ("production" !== process.env.NODE_ENV ? invariant(
        callbacks.length === contexts.length,
        "Mismatched list of contexts in callback queue"
      ) : invariant(callbacks.length === contexts.length));
      this._callbacks = null;
      this._contexts = null;
      for (var i = 0, l = callbacks.length; i < l; i++) {
        callbacks[i].call(contexts[i]);
      }
      callbacks.length = 0;
      contexts.length = 0;
    }
  },

  /**
   * Resets the internal queue.
   *
   * @internal
   */
  reset: function() {
    this._callbacks = null;
    this._contexts = null;
  },

  /**
   * `PooledClass` looks for this.
   */
  destructor: function() {
    this.reset();
  }

});

PooledClass.addPoolingTo(CallbackQueue);

module.exports = CallbackQueue;

}).call(this,require('_process'))
},{"./PooledClass":106,"./invariant":212,"./mixInto":225,"_process":73}],85:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ChangeEventPlugin
 */

"use strict";

var EventConstants = require("./EventConstants");
var EventPluginHub = require("./EventPluginHub");
var EventPropagators = require("./EventPropagators");
var ExecutionEnvironment = require("./ExecutionEnvironment");
var ReactUpdates = require("./ReactUpdates");
var SyntheticEvent = require("./SyntheticEvent");

var isEventSupported = require("./isEventSupported");
var isTextInputElement = require("./isTextInputElement");
var keyOf = require("./keyOf");

var topLevelTypes = EventConstants.topLevelTypes;

var eventTypes = {
  change: {
    phasedRegistrationNames: {
      bubbled: keyOf({onChange: null}),
      captured: keyOf({onChangeCapture: null})
    },
    dependencies: [
      topLevelTypes.topBlur,
      topLevelTypes.topChange,
      topLevelTypes.topClick,
      topLevelTypes.topFocus,
      topLevelTypes.topInput,
      topLevelTypes.topKeyDown,
      topLevelTypes.topKeyUp,
      topLevelTypes.topSelectionChange
    ]
  }
};

/**
 * For IE shims
 */
var activeElement = null;
var activeElementID = null;
var activeElementValue = null;
var activeElementValueProp = null;

/**
 * SECTION: handle `change` event
 */
function shouldUseChangeEvent(elem) {
  return (
    elem.nodeName === 'SELECT' ||
    (elem.nodeName === 'INPUT' && elem.type === 'file')
  );
}

var doesChangeEventBubble = false;
if (ExecutionEnvironment.canUseDOM) {
  // See `handleChange` comment below
  doesChangeEventBubble = isEventSupported('change') && (
    !('documentMode' in document) || document.documentMode > 8
  );
}

function manualDispatchChangeEvent(nativeEvent) {
  var event = SyntheticEvent.getPooled(
    eventTypes.change,
    activeElementID,
    nativeEvent
  );
  EventPropagators.accumulateTwoPhaseDispatches(event);

  // If change and propertychange bubbled, we'd just bind to it like all the
  // other events and have it go through ReactBrowserEventEmitter. Since it
  // doesn't, we manually listen for the events and so we have to enqueue and
  // process the abstract event manually.
  //
  // Batching is necessary here in order to ensure that all event handlers run
  // before the next rerender (including event handlers attached to ancestor
  // elements instead of directly on the input). Without this, controlled
  // components don't work properly in conjunction with event bubbling because
  // the component is rerendered and the value reverted before all the event
  // handlers can run. See https://github.com/facebook/react/issues/708.
  ReactUpdates.batchedUpdates(runEventInBatch, event);
}

function runEventInBatch(event) {
  EventPluginHub.enqueueEvents(event);
  EventPluginHub.processEventQueue();
}

function startWatchingForChangeEventIE8(target, targetID) {
  activeElement = target;
  activeElementID = targetID;
  activeElement.attachEvent('onchange', manualDispatchChangeEvent);
}

function stopWatchingForChangeEventIE8() {
  if (!activeElement) {
    return;
  }
  activeElement.detachEvent('onchange', manualDispatchChangeEvent);
  activeElement = null;
  activeElementID = null;
}

function getTargetIDForChangeEvent(
    topLevelType,
    topLevelTarget,
    topLevelTargetID) {
  if (topLevelType === topLevelTypes.topChange) {
    return topLevelTargetID;
  }
}
function handleEventsForChangeEventIE8(
    topLevelType,
    topLevelTarget,
    topLevelTargetID) {
  if (topLevelType === topLevelTypes.topFocus) {
    // stopWatching() should be a noop here but we call it just in case we
    // missed a blur event somehow.
    stopWatchingForChangeEventIE8();
    startWatchingForChangeEventIE8(topLevelTarget, topLevelTargetID);
  } else if (topLevelType === topLevelTypes.topBlur) {
    stopWatchingForChangeEventIE8();
  }
}


/**
 * SECTION: handle `input` event
 */
var isInputEventSupported = false;
if (ExecutionEnvironment.canUseDOM) {
  // IE9 claims to support the input event but fails to trigger it when
  // deleting text, so we ignore its input events
  isInputEventSupported = isEventSupported('input') && (
    !('documentMode' in document) || document.documentMode > 9
  );
}

/**
 * (For old IE.) Replacement getter/setter for the `value` property that gets
 * set on the active element.
 */
var newValueProp =  {
  get: function() {
    return activeElementValueProp.get.call(this);
  },
  set: function(val) {
    // Cast to a string so we can do equality checks.
    activeElementValue = '' + val;
    activeElementValueProp.set.call(this, val);
  }
};

/**
 * (For old IE.) Starts tracking propertychange events on the passed-in element
 * and override the value property so that we can distinguish user events from
 * value changes in JS.
 */
function startWatchingForValueChange(target, targetID) {
  activeElement = target;
  activeElementID = targetID;
  activeElementValue = target.value;
  activeElementValueProp = Object.getOwnPropertyDescriptor(
    target.constructor.prototype,
    'value'
  );

  Object.defineProperty(activeElement, 'value', newValueProp);
  activeElement.attachEvent('onpropertychange', handlePropertyChange);
}

/**
 * (For old IE.) Removes the event listeners from the currently-tracked element,
 * if any exists.
 */
function stopWatchingForValueChange() {
  if (!activeElement) {
    return;
  }

  // delete restores the original property definition
  delete activeElement.value;
  activeElement.detachEvent('onpropertychange', handlePropertyChange);

  activeElement = null;
  activeElementID = null;
  activeElementValue = null;
  activeElementValueProp = null;
}

/**
 * (For old IE.) Handles a propertychange event, sending a `change` event if
 * the value of the active element has changed.
 */
function handlePropertyChange(nativeEvent) {
  if (nativeEvent.propertyName !== 'value') {
    return;
  }
  var value = nativeEvent.srcElement.value;
  if (value === activeElementValue) {
    return;
  }
  activeElementValue = value;

  manualDispatchChangeEvent(nativeEvent);
}

/**
 * If a `change` event should be fired, returns the target's ID.
 */
function getTargetIDForInputEvent(
    topLevelType,
    topLevelTarget,
    topLevelTargetID) {
  if (topLevelType === topLevelTypes.topInput) {
    // In modern browsers (i.e., not IE8 or IE9), the input event is exactly
    // what we want so fall through here and trigger an abstract event
    return topLevelTargetID;
  }
}

// For IE8 and IE9.
function handleEventsForInputEventIE(
    topLevelType,
    topLevelTarget,
    topLevelTargetID) {
  if (topLevelType === topLevelTypes.topFocus) {
    // In IE8, we can capture almost all .value changes by adding a
    // propertychange handler and looking for events with propertyName
    // equal to 'value'
    // In IE9, propertychange fires for most input events but is buggy and
    // doesn't fire when text is deleted, but conveniently, selectionchange
    // appears to fire in all of the remaining cases so we catch those and
    // forward the event if the value has changed
    // In either case, we don't want to call the event handler if the value
    // is changed from JS so we redefine a setter for `.value` that updates
    // our activeElementValue variable, allowing us to ignore those changes
    //
    // stopWatching() should be a noop here but we call it just in case we
    // missed a blur event somehow.
    stopWatchingForValueChange();
    startWatchingForValueChange(topLevelTarget, topLevelTargetID);
  } else if (topLevelType === topLevelTypes.topBlur) {
    stopWatchingForValueChange();
  }
}

// For IE8 and IE9.
function getTargetIDForInputEventIE(
    topLevelType,
    topLevelTarget,
    topLevelTargetID) {
  if (topLevelType === topLevelTypes.topSelectionChange ||
      topLevelType === topLevelTypes.topKeyUp ||
      topLevelType === topLevelTypes.topKeyDown) {
    // On the selectionchange event, the target is just document which isn't
    // helpful for us so just check activeElement instead.
    //
    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
    // propertychange on the first input event after setting `value` from a
    // script and fires only keydown, keypress, keyup. Catching keyup usually
    // gets it and catching keydown lets us fire an event for the first
    // keystroke if user does a key repeat (it'll be a little delayed: right
    // before the second keystroke). Other input methods (e.g., paste) seem to
    // fire selectionchange normally.
    if (activeElement && activeElement.value !== activeElementValue) {
      activeElementValue = activeElement.value;
      return activeElementID;
    }
  }
}


/**
 * SECTION: handle `click` event
 */
function shouldUseClickEvent(elem) {
  // Use the `click` event to detect changes to checkbox and radio inputs.
  // This approach works across all browsers, whereas `change` does not fire
  // until `blur` in IE8.
  return (
    elem.nodeName === 'INPUT' &&
    (elem.type === 'checkbox' || elem.type === 'radio')
  );
}

function getTargetIDForClickEvent(
    topLevelType,
    topLevelTarget,
    topLevelTargetID) {
  if (topLevelType === topLevelTypes.topClick) {
    return topLevelTargetID;
  }
}

/**
 * This plugin creates an `onChange` event that normalizes change events
 * across form elements. This event fires at a time when it's possible to
 * change the element's value without seeing a flicker.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - select
 */
var ChangeEventPlugin = {

  eventTypes: eventTypes,

  /**
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function(
      topLevelType,
      topLevelTarget,
      topLevelTargetID,
      nativeEvent) {

    var getTargetIDFunc, handleEventFunc;
    if (shouldUseChangeEvent(topLevelTarget)) {
      if (doesChangeEventBubble) {
        getTargetIDFunc = getTargetIDForChangeEvent;
      } else {
        handleEventFunc = handleEventsForChangeEventIE8;
      }
    } else if (isTextInputElement(topLevelTarget)) {
      if (isInputEventSupported) {
        getTargetIDFunc = getTargetIDForInputEvent;
      } else {
        getTargetIDFunc = getTargetIDForInputEventIE;
        handleEventFunc = handleEventsForInputEventIE;
      }
    } else if (shouldUseClickEvent(topLevelTarget)) {
      getTargetIDFunc = getTargetIDForClickEvent;
    }

    if (getTargetIDFunc) {
      var targetID = getTargetIDFunc(
        topLevelType,
        topLevelTarget,
        topLevelTargetID
      );
      if (targetID) {
        var event = SyntheticEvent.getPooled(
          eventTypes.change,
          targetID,
          nativeEvent
        );
        EventPropagators.accumulateTwoPhaseDispatches(event);
        return event;
      }
    }

    if (handleEventFunc) {
      handleEventFunc(
        topLevelType,
        topLevelTarget,
        topLevelTargetID
      );
    }
  }

};

module.exports = ChangeEventPlugin;

},{"./EventConstants":94,"./EventPluginHub":96,"./EventPropagators":99,"./ExecutionEnvironment":100,"./ReactUpdates":165,"./SyntheticEvent":174,"./isEventSupported":213,"./isTextInputElement":215,"./keyOf":219}],86:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ClientReactRootIndex
 * @typechecks
 */

"use strict";

var nextReactRootIndex = 0;

var ClientReactRootIndex = {
  createReactRootIndex: function() {
    return nextReactRootIndex++;
  }
};

module.exports = ClientReactRootIndex;

},{}],87:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule CompositionEventPlugin
 * @typechecks static-only
 */

"use strict";

var EventConstants = require("./EventConstants");
var EventPropagators = require("./EventPropagators");
var ExecutionEnvironment = require("./ExecutionEnvironment");
var ReactInputSelection = require("./ReactInputSelection");
var SyntheticCompositionEvent = require("./SyntheticCompositionEvent");

var getTextContentAccessor = require("./getTextContentAccessor");
var keyOf = require("./keyOf");

var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
var START_KEYCODE = 229;

var useCompositionEvent = (
  ExecutionEnvironment.canUseDOM &&
  'CompositionEvent' in window
);

// In IE9+, we have access to composition events, but the data supplied
// by the native compositionend event may be incorrect. In Korean, for example,
// the compositionend event contains only one character regardless of
// how many characters have been composed since compositionstart.
// We therefore use the fallback data while still using the native
// events as triggers.
var useFallbackData = (
  !useCompositionEvent ||
  (
    'documentMode' in document &&
    document.documentMode > 8 &&
    document.documentMode <= 11
  )
);

var topLevelTypes = EventConstants.topLevelTypes;
var currentComposition = null;

// Events and their corresponding property names.
var eventTypes = {
  compositionEnd: {
    phasedRegistrationNames: {
      bubbled: keyOf({onCompositionEnd: null}),
      captured: keyOf({onCompositionEndCapture: null})
    },
    dependencies: [
      topLevelTypes.topBlur,
      topLevelTypes.topCompositionEnd,
      topLevelTypes.topKeyDown,
      topLevelTypes.topKeyPress,
      topLevelTypes.topKeyUp,
      topLevelTypes.topMouseDown
    ]
  },
  compositionStart: {
    phasedRegistrationNames: {
      bubbled: keyOf({onCompositionStart: null}),
      captured: keyOf({onCompositionStartCapture: null})
    },
    dependencies: [
      topLevelTypes.topBlur,
      topLevelTypes.topCompositionStart,
      topLevelTypes.topKeyDown,
      topLevelTypes.topKeyPress,
      topLevelTypes.topKeyUp,
      topLevelTypes.topMouseDown
    ]
  },
  compositionUpdate: {
    phasedRegistrationNames: {
      bubbled: keyOf({onCompositionUpdate: null}),
      captured: keyOf({onCompositionUpdateCapture: null})
    },
    dependencies: [
      topLevelTypes.topBlur,
      topLevelTypes.topCompositionUpdate,
      topLevelTypes.topKeyDown,
      topLevelTypes.topKeyPress,
      topLevelTypes.topKeyUp,
      topLevelTypes.topMouseDown
    ]
  }
};

/**
 * Translate native top level events into event types.
 *
 * @param {string} topLevelType
 * @return {object}
 */
function getCompositionEventType(topLevelType) {
  switch (topLevelType) {
    case topLevelTypes.topCompositionStart:
      return eventTypes.compositionStart;
    case topLevelTypes.topCompositionEnd:
      return eventTypes.compositionEnd;
    case topLevelTypes.topCompositionUpdate:
      return eventTypes.compositionUpdate;
  }
}

/**
 * Does our fallback best-guess model think this event signifies that
 * composition has begun?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackStart(topLevelType, nativeEvent) {
  return (
    topLevelType === topLevelTypes.topKeyDown &&
    nativeEvent.keyCode === START_KEYCODE
  );
}

/**
 * Does our fallback mode think that this event is the end of composition?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackEnd(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case topLevelTypes.topKeyUp:
      // Command keys insert or clear IME input.
      return (END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1);
    case topLevelTypes.topKeyDown:
      // Expect IME keyCode on each keydown. If we get any other
      // code we must have exited earlier.
      return (nativeEvent.keyCode !== START_KEYCODE);
    case topLevelTypes.topKeyPress:
    case topLevelTypes.topMouseDown:
    case topLevelTypes.topBlur:
      // Events are not possible without cancelling IME.
      return true;
    default:
      return false;
  }
}

/**
 * Helper class stores information about selection and document state
 * so we can figure out what changed at a later date.
 *
 * @param {DOMEventTarget} root
 */
function FallbackCompositionState(root) {
  this.root = root;
  this.startSelection = ReactInputSelection.getSelection(root);
  this.startValue = this.getText();
}

/**
 * Get current text of input.
 *
 * @return {string}
 */
FallbackCompositionState.prototype.getText = function() {
  return this.root.value || this.root[getTextContentAccessor()];
};

/**
 * Text that has changed since the start of composition.
 *
 * @return {string}
 */
FallbackCompositionState.prototype.getData = function() {
  var endValue = this.getText();
  var prefixLength = this.startSelection.start;
  var suffixLength = this.startValue.length - this.startSelection.end;

  return endValue.substr(
    prefixLength,
    endValue.length - suffixLength - prefixLength
  );
};

/**
 * This plugin creates `onCompositionStart`, `onCompositionUpdate` and
 * `onCompositionEnd` events on inputs, textareas and contentEditable
 * nodes.
 */
var CompositionEventPlugin = {

  eventTypes: eventTypes,

  /**
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function(
      topLevelType,
      topLevelTarget,
      topLevelTargetID,
      nativeEvent) {

    var eventType;
    var data;

    if (useCompositionEvent) {
      eventType = getCompositionEventType(topLevelType);
    } else if (!currentComposition) {
      if (isFallbackStart(topLevelType, nativeEvent)) {
        eventType = eventTypes.compositionStart;
      }
    } else if (isFallbackEnd(topLevelType, nativeEvent)) {
      eventType = eventTypes.compositionEnd;
    }

    if (useFallbackData) {
      // The current composition is stored statically and must not be
      // overwritten while composition continues.
      if (!currentComposition && eventType === eventTypes.compositionStart) {
        currentComposition = new FallbackCompositionState(topLevelTarget);
      } else if (eventType === eventTypes.compositionEnd) {
        if (currentComposition) {
          data = currentComposition.getData();
          currentComposition = null;
        }
      }
    }

    if (eventType) {
      var event = SyntheticCompositionEvent.getPooled(
        eventType,
        topLevelTargetID,
        nativeEvent
      );
      if (data) {
        // Inject data generated from fallback path into the synthetic event.
        // This matches the property of native CompositionEventInterface.
        event.data = data;
      }
      EventPropagators.accumulateTwoPhaseDispatches(event);
      return event;
    }
  }
};

module.exports = CompositionEventPlugin;

},{"./EventConstants":94,"./EventPropagators":99,"./ExecutionEnvironment":100,"./ReactInputSelection":141,"./SyntheticCompositionEvent":172,"./getTextContentAccessor":207,"./keyOf":219}],88:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule DOMChildrenOperations
 * @typechecks static-only
 */

"use strict";

var Danger = require("./Danger");
var ReactMultiChildUpdateTypes = require("./ReactMultiChildUpdateTypes");

var getTextContentAccessor = require("./getTextContentAccessor");
var invariant = require("./invariant");

/**
 * The DOM property to use when setting text content.
 *
 * @type {string}
 * @private
 */
var textContentAccessor = getTextContentAccessor();

/**
 * Inserts `childNode` as a child of `parentNode` at the `index`.
 *
 * @param {DOMElement} parentNode Parent node in which to insert.
 * @param {DOMElement} childNode Child node to insert.
 * @param {number} index Index at which to insert the child.
 * @internal
 */
function insertChildAt(parentNode, childNode, index) {
  // By exploiting arrays returning `undefined` for an undefined index, we can
  // rely exclusively on `insertBefore(node, null)` instead of also using
  // `appendChild(node)`. However, using `undefined` is not allowed by all
  // browsers so we must replace it with `null`.
  parentNode.insertBefore(
    childNode,
    parentNode.childNodes[index] || null
  );
}

var updateTextContent;
if (textContentAccessor === 'textContent') {
  /**
   * Sets the text content of `node` to `text`.
   *
   * @param {DOMElement} node Node to change
   * @param {string} text New text content
   */
  updateTextContent = function(node, text) {
    node.textContent = text;
  };
} else {
  /**
   * Sets the text content of `node` to `text`.
   *
   * @param {DOMElement} node Node to change
   * @param {string} text New text content
   */
  updateTextContent = function(node, text) {
    // In order to preserve newlines correctly, we can't use .innerText to set
    // the contents (see #1080), so we empty the element then append a text node
    while (node.firstChild) {
      node.removeChild(node.firstChild);
    }
    if (text) {
      var doc = node.ownerDocument || document;
      node.appendChild(doc.createTextNode(text));
    }
  };
}

/**
 * Operations for updating with DOM children.
 */
var DOMChildrenOperations = {

  dangerouslyReplaceNodeWithMarkup: Danger.dangerouslyReplaceNodeWithMarkup,

  updateTextContent: updateTextContent,

  /**
   * Updates a component's children by processing a series of updates. The
   * update configurations are each expected to have a `parentNode` property.
   *
   * @param {array<object>} updates List of update configurations.
   * @param {array<string>} markupList List of markup strings.
   * @internal
   */
  processUpdates: function(updates, markupList) {
    var update;
    // Mapping from parent IDs to initial child orderings.
    var initialChildren = null;
    // List of children that will be moved or removed.
    var updatedChildren = null;

    for (var i = 0; update = updates[i]; i++) {
      if (update.type === ReactMultiChildUpdateTypes.MOVE_EXISTING ||
          update.type === ReactMultiChildUpdateTypes.REMOVE_NODE) {
        var updatedIndex = update.fromIndex;
        var updatedChild = update.parentNode.childNodes[updatedIndex];
        var parentID = update.parentID;

        ("production" !== process.env.NODE_ENV ? invariant(
          updatedChild,
          'processUpdates(): Unable to find child %s of element. This ' +
          'probably means the DOM was unexpectedly mutated (e.g., by the ' +
          'browser), usually due to forgetting a <tbody> when using tables, ' +
          'nesting <p> or <a> tags, or using non-SVG elements in an <svg> '+
          'parent. Try inspecting the child nodes of the element with React ' +
          'ID `%s`.',
          updatedIndex,
          parentID
        ) : invariant(updatedChild));

        initialChildren = initialChildren || {};
        initialChildren[parentID] = initialChildren[parentID] || [];
        initialChildren[parentID][updatedIndex] = updatedChild;

        updatedChildren = updatedChildren || [];
        updatedChildren.push(updatedChild);
      }
    }

    var renderedMarkup = Danger.dangerouslyRenderMarkup(markupList);

    // Remove updated children first so that `toIndex` is consistent.
    if (updatedChildren) {
      for (var j = 0; j < updatedChildren.length; j++) {
        updatedChildren[j].parentNode.removeChild(updatedChildren[j]);
      }
    }

    for (var k = 0; update = updates[k]; k++) {
      switch (update.type) {
        case ReactMultiChildUpdateTypes.INSERT_MARKUP:
          insertChildAt(
            update.parentNode,
            renderedMarkup[update.markupIndex],
            update.toIndex
          );
          break;
        case ReactMultiChildUpdateTypes.MOVE_EXISTING:
          insertChildAt(
            update.parentNode,
            initialChildren[update.parentID][update.fromIndex],
            update.toIndex
          );
          break;
        case ReactMultiChildUpdateTypes.TEXT_CONTENT:
          updateTextContent(
            update.parentNode,
            update.textContent
          );
          break;
        case ReactMultiChildUpdateTypes.REMOVE_NODE:
          // Already removed by the for-loop above.
          break;
      }
    }
  }

};

module.exports = DOMChildrenOperations;

}).call(this,require('_process'))
},{"./Danger":91,"./ReactMultiChildUpdateTypes":147,"./getTextContentAccessor":207,"./invariant":212,"_process":73}],89:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule DOMProperty
 * @typechecks static-only
 */

/*jslint bitwise: true */

"use strict";

var invariant = require("./invariant");

var DOMPropertyInjection = {
  /**
   * Mapping from normalized, camelcased property names to a configuration that
   * specifies how the associated DOM property should be accessed or rendered.
   */
  MUST_USE_ATTRIBUTE: 0x1,
  MUST_USE_PROPERTY: 0x2,
  HAS_SIDE_EFFECTS: 0x4,
  HAS_BOOLEAN_VALUE: 0x8,
  HAS_NUMERIC_VALUE: 0x10,
  HAS_POSITIVE_NUMERIC_VALUE: 0x20 | 0x10,
  HAS_OVERLOADED_BOOLEAN_VALUE: 0x40,

  /**
   * Inject some specialized knowledge about the DOM. This takes a config object
   * with the following properties:
   *
   * isCustomAttribute: function that given an attribute name will return true
   * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*
   * attributes where it's impossible to enumerate all of the possible
   * attribute names,
   *
   * Properties: object mapping DOM property name to one of the
   * DOMPropertyInjection constants or null. If your attribute isn't in here,
   * it won't get written to the DOM.
   *
   * DOMAttributeNames: object mapping React attribute name to the DOM
   * attribute name. Attribute names not specified use the **lowercase**
   * normalized name.
   *
   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
   * Property names not specified use the normalized name.
   *
   * DOMMutationMethods: Properties that require special mutation methods. If
   * `value` is undefined, the mutation method should unset the property.
   *
   * @param {object} domPropertyConfig the config as described above.
   */
  injectDOMPropertyConfig: function(domPropertyConfig) {
    var Properties = domPropertyConfig.Properties || {};
    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
    var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};

    if (domPropertyConfig.isCustomAttribute) {
      DOMProperty._isCustomAttributeFunctions.push(
        domPropertyConfig.isCustomAttribute
      );
    }

    for (var propName in Properties) {
      ("production" !== process.env.NODE_ENV ? invariant(
        !DOMProperty.isStandardName.hasOwnProperty(propName),
        'injectDOMPropertyConfig(...): You\'re trying to inject DOM property ' +
        '\'%s\' which has already been injected. You may be accidentally ' +
        'injecting the same DOM property config twice, or you may be ' +
        'injecting two configs that have conflicting property names.',
        propName
      ) : invariant(!DOMProperty.isStandardName.hasOwnProperty(propName)));

      DOMProperty.isStandardName[propName] = true;

      var lowerCased = propName.toLowerCase();
      DOMProperty.getPossibleStandardName[lowerCased] = propName;

      if (DOMAttributeNames.hasOwnProperty(propName)) {
        var attributeName = DOMAttributeNames[propName];
        DOMProperty.getPossibleStandardName[attributeName] = propName;
        DOMProperty.getAttributeName[propName] = attributeName;
      } else {
        DOMProperty.getAttributeName[propName] = lowerCased;
      }

      DOMProperty.getPropertyName[propName] =
        DOMPropertyNames.hasOwnProperty(propName) ?
          DOMPropertyNames[propName] :
          propName;

      if (DOMMutationMethods.hasOwnProperty(propName)) {
        DOMProperty.getMutationMethod[propName] = DOMMutationMethods[propName];
      } else {
        DOMProperty.getMutationMethod[propName] = null;
      }

      var propConfig = Properties[propName];
      DOMProperty.mustUseAttribute[propName] =
        propConfig & DOMPropertyInjection.MUST_USE_ATTRIBUTE;
      DOMProperty.mustUseProperty[propName] =
        propConfig & DOMPropertyInjection.MUST_USE_PROPERTY;
      DOMProperty.hasSideEffects[propName] =
        propConfig & DOMPropertyInjection.HAS_SIDE_EFFECTS;
      DOMProperty.hasBooleanValue[propName] =
        propConfig & DOMPropertyInjection.HAS_BOOLEAN_VALUE;
      DOMProperty.hasNumericValue[propName] =
        propConfig & DOMPropertyInjection.HAS_NUMERIC_VALUE;
      DOMProperty.hasPositiveNumericValue[propName] =
        propConfig & DOMPropertyInjection.HAS_POSITIVE_NUMERIC_VALUE;
      DOMProperty.hasOverloadedBooleanValue[propName] =
        propConfig & DOMPropertyInjection.HAS_OVERLOADED_BOOLEAN_VALUE;

      ("production" !== process.env.NODE_ENV ? invariant(
        !DOMProperty.mustUseAttribute[propName] ||
          !DOMProperty.mustUseProperty[propName],
        'DOMProperty: Cannot require using both attribute and property: %s',
        propName
      ) : invariant(!DOMProperty.mustUseAttribute[propName] ||
        !DOMProperty.mustUseProperty[propName]));
      ("production" !== process.env.NODE_ENV ? invariant(
        DOMProperty.mustUseProperty[propName] ||
          !DOMProperty.hasSideEffects[propName],
        'DOMProperty: Properties that have side effects must use property: %s',
        propName
      ) : invariant(DOMProperty.mustUseProperty[propName] ||
        !DOMProperty.hasSideEffects[propName]));
      ("production" !== process.env.NODE_ENV ? invariant(
        !!DOMProperty.hasBooleanValue[propName] +
          !!DOMProperty.hasNumericValue[propName] +
          !!DOMProperty.hasOverloadedBooleanValue[propName] <= 1,
        'DOMProperty: Value can be one of boolean, overloaded boolean, or ' +
        'numeric value, but not a combination: %s',
        propName
      ) : invariant(!!DOMProperty.hasBooleanValue[propName] +
        !!DOMProperty.hasNumericValue[propName] +
        !!DOMProperty.hasOverloadedBooleanValue[propName] <= 1));
    }
  }
};
var defaultValueCache = {};

/**
 * DOMProperty exports lookup objects that can be used like functions:
 *
 *   > DOMProperty.isValid['id']
 *   true
 *   > DOMProperty.isValid['foobar']
 *   undefined
 *
 * Although this may be confusing, it performs better in general.
 *
 * @see http://jsperf.com/key-exists
 * @see http://jsperf.com/key-missing
 */
var DOMProperty = {

  ID_ATTRIBUTE_NAME: 'data-reactid',

  /**
   * Checks whether a property name is a standard property.
   * @type {Object}
   */
  isStandardName: {},

  /**
   * Mapping from lowercase property names to the properly cased version, used
   * to warn in the case of missing properties.
   * @type {Object}
   */
  getPossibleStandardName: {},

  /**
   * Mapping from normalized names to attribute names that differ. Attribute
   * names are used when rendering markup or with `*Attribute()`.
   * @type {Object}
   */
  getAttributeName: {},

  /**
   * Mapping from normalized names to properties on DOM node instances.
   * (This includes properties that mutate due to external factors.)
   * @type {Object}
   */
  getPropertyName: {},

  /**
   * Mapping from normalized names to mutation methods. This will only exist if
   * mutation cannot be set simply by the property or `setAttribute()`.
   * @type {Object}
   */
  getMutationMethod: {},

  /**
   * Whether the property must be accessed and mutated as an object property.
   * @type {Object}
   */
  mustUseAttribute: {},

  /**
   * Whether the property must be accessed and mutated using `*Attribute()`.
   * (This includes anything that fails `<propName> in <element>`.)
   * @type {Object}
   */
  mustUseProperty: {},

  /**
   * Whether or not setting a value causes side effects such as triggering
   * resources to be loaded or text selection changes. We must ensure that
   * the value is only set if it has changed.
   * @type {Object}
   */
  hasSideEffects: {},

  /**
   * Whether the property should be removed when set to a falsey value.
   * @type {Object}
   */
  hasBooleanValue: {},

  /**
   * Whether the property must be numeric or parse as a
   * numeric and should be removed when set to a falsey value.
   * @type {Object}
   */
  hasNumericValue: {},

  /**
   * Whether the property must be positive numeric or parse as a positive
   * numeric and should be removed when set to a falsey value.
   * @type {Object}
   */
  hasPositiveNumericValue: {},

  /**
   * Whether the property can be used as a flag as well as with a value. Removed
   * when strictly equal to false; present without a value when strictly equal
   * to true; present with a value otherwise.
   * @type {Object}
   */
  hasOverloadedBooleanValue: {},

  /**
   * All of the isCustomAttribute() functions that have been injected.
   */
  _isCustomAttributeFunctions: [],

  /**
   * Checks whether a property name is a custom attribute.
   * @method
   */
  isCustomAttribute: function(attributeName) {
    for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
      var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
      if (isCustomAttributeFn(attributeName)) {
        return true;
      }
    }
    return false;
  },

  /**
   * Returns the default property value for a DOM property (i.e., not an
   * attribute). Most default values are '' or false, but not all. Worse yet,
   * some (in particular, `type`) vary depending on the type of element.
   *
   * TODO: Is it better to grab all the possible properties when creating an
   * element to avoid having to create the same element twice?
   */
  getDefaultValueForProperty: function(nodeName, prop) {
    var nodeDefaults = defaultValueCache[nodeName];
    var testElement;
    if (!nodeDefaults) {
      defaultValueCache[nodeName] = nodeDefaults = {};
    }
    if (!(prop in nodeDefaults)) {
      testElement = document.createElement(nodeName);
      nodeDefaults[prop] = testElement[prop];
    }
    return nodeDefaults[prop];
  },

  injection: DOMPropertyInjection
};

module.exports = DOMProperty;

}).call(this,require('_process'))
},{"./invariant":212,"_process":73}],90:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule DOMPropertyOperations
 * @typechecks static-only
 */

"use strict";

var DOMProperty = require("./DOMProperty");

var escapeTextForBrowser = require("./escapeTextForBrowser");
var memoizeStringOnly = require("./memoizeStringOnly");
var warning = require("./warning");

function shouldIgnoreValue(name, value) {
  return value == null ||
    (DOMProperty.hasBooleanValue[name] && !value) ||
    (DOMProperty.hasNumericValue[name] && isNaN(value)) ||
    (DOMProperty.hasPositiveNumericValue[name] && (value < 1)) ||
    (DOMProperty.hasOverloadedBooleanValue[name] && value === false);
}

var processAttributeNameAndPrefix = memoizeStringOnly(function(name) {
  return escapeTextForBrowser(name) + '="';
});

if ("production" !== process.env.NODE_ENV) {
  var reactProps = {
    children: true,
    dangerouslySetInnerHTML: true,
    key: true,
    ref: true
  };
  var warnedProperties = {};

  var warnUnknownProperty = function(name) {
    if (reactProps.hasOwnProperty(name) && reactProps[name] ||
        warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
      return;
    }

    warnedProperties[name] = true;
    var lowerCasedName = name.toLowerCase();

    // data-* attributes should be lowercase; suggest the lowercase version
    var standardName = (
      DOMProperty.isCustomAttribute(lowerCasedName) ?
        lowerCasedName :
      DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ?
        DOMProperty.getPossibleStandardName[lowerCasedName] :
        null
    );

    // For now, only warn when we have a suggested correction. This prevents
    // logging too much when using transferPropsTo.
    ("production" !== process.env.NODE_ENV ? warning(
      standardName == null,
      'Unknown DOM property ' + name + '. Did you mean ' + standardName + '?'
    ) : null);

  };
}

/**
 * Operations for dealing with DOM properties.
 */
var DOMPropertyOperations = {

  /**
   * Creates markup for the ID property.
   *
   * @param {string} id Unescaped ID.
   * @return {string} Markup string.
   */
  createMarkupForID: function(id) {
    return processAttributeNameAndPrefix(DOMProperty.ID_ATTRIBUTE_NAME) +
      escapeTextForBrowser(id) + '"';
  },

  /**
   * Creates markup for a property.
   *
   * @param {string} name
   * @param {*} value
   * @return {?string} Markup string, or null if the property was invalid.
   */
  createMarkupForProperty: function(name, value) {
    if (DOMProperty.isStandardName.hasOwnProperty(name) &&
        DOMProperty.isStandardName[name]) {
      if (shouldIgnoreValue(name, value)) {
        return '';
      }
      var attributeName = DOMProperty.getAttributeName[name];
      if (DOMProperty.hasBooleanValue[name] ||
          (DOMProperty.hasOverloadedBooleanValue[name] && value === true)) {
        return escapeTextForBrowser(attributeName);
      }
      return processAttributeNameAndPrefix(attributeName) +
        escapeTextForBrowser(value) + '"';
    } else if (DOMProperty.isCustomAttribute(name)) {
      if (value == null) {
        return '';
      }
      return processAttributeNameAndPrefix(name) +
        escapeTextForBrowser(value) + '"';
    } else if ("production" !== process.env.NODE_ENV) {
      warnUnknownProperty(name);
    }
    return null;
  },

  /**
   * Sets the value for a property on a node.
   *
   * @param {DOMElement} node
   * @param {string} name
   * @param {*} value
   */
  setValueForProperty: function(node, name, value) {
    if (DOMProperty.isStandardName.hasOwnProperty(name) &&
        DOMProperty.isStandardName[name]) {
      var mutationMethod = DOMProperty.getMutationMethod[name];
      if (mutationMethod) {
        mutationMethod(node, value);
      } else if (shouldIgnoreValue(name, value)) {
        this.deleteValueForProperty(node, name);
      } else if (DOMProperty.mustUseAttribute[name]) {
        node.setAttribute(DOMProperty.getAttributeName[name], '' + value);
      } else {
        var propName = DOMProperty.getPropertyName[name];
        if (!DOMProperty.hasSideEffects[name] || node[propName] !== value) {
          node[propName] = value;
        }
      }
    } else if (DOMProperty.isCustomAttribute(name)) {
      if (value == null) {
        node.removeAttribute(name);
      } else {
        node.setAttribute(name, '' + value);
      }
    } else if ("production" !== process.env.NODE_ENV) {
      warnUnknownProperty(name);
    }
  },

  /**
   * Deletes the value for a property on a node.
   *
   * @param {DOMElement} node
   * @param {string} name
   */
  deleteValueForProperty: function(node, name) {
    if (DOMProperty.isStandardName.hasOwnProperty(name) &&
        DOMProperty.isStandardName[name]) {
      var mutationMethod = DOMProperty.getMutationMethod[name];
      if (mutationMethod) {
        mutationMethod(node, undefined);
      } else if (DOMProperty.mustUseAttribute[name]) {
        node.removeAttribute(DOMProperty.getAttributeName[name]);
      } else {
        var propName = DOMProperty.getPropertyName[name];
        var defaultValue = DOMProperty.getDefaultValueForProperty(
          node.nodeName,
          propName
        );
        if (!DOMProperty.hasSideEffects[name] ||
            node[propName] !== defaultValue) {
          node[propName] = defaultValue;
        }
      }
    } else if (DOMProperty.isCustomAttribute(name)) {
      node.removeAttribute(name);
    } else if ("production" !== process.env.NODE_ENV) {
      warnUnknownProperty(name);
    }
  }

};

module.exports = DOMPropertyOperations;

}).call(this,require('_process'))
},{"./DOMProperty":89,"./escapeTextForBrowser":196,"./memoizeStringOnly":221,"./warning":236,"_process":73}],91:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule Danger
 * @typechecks static-only
 */

/*jslint evil: true, sub: true */

"use strict";

var ExecutionEnvironment = require("./ExecutionEnvironment");

var createNodesFromMarkup = require("./createNodesFromMarkup");
var emptyFunction = require("./emptyFunction");
var getMarkupWrap = require("./getMarkupWrap");
var invariant = require("./invariant");

var OPEN_TAG_NAME_EXP = /^(<[^ \/>]+)/;
var RESULT_INDEX_ATTR = 'data-danger-index';

/**
 * Extracts the `nodeName` from a string of markup.
 *
 * NOTE: Extracting the `nodeName` does not require a regular expression match
 * because we make assumptions about React-generated markup (i.e. there are no
 * spaces surrounding the opening tag and there is at least one attribute).
 *
 * @param {string} markup String of markup.
 * @return {string} Node name of the supplied markup.
 * @see http://jsperf.com/extract-nodename
 */
function getNodeName(markup) {
  return markup.substring(1, markup.indexOf(' '));
}

var Danger = {

  /**
   * Renders markup into an array of nodes. The markup is expected to render
   * into a list of root nodes. Also, the length of `resultList` and
   * `markupList` should be the same.
   *
   * @param {array<string>} markupList List of markup strings to render.
   * @return {array<DOMElement>} List of rendered nodes.
   * @internal
   */
  dangerouslyRenderMarkup: function(markupList) {
    ("production" !== process.env.NODE_ENV ? invariant(
      ExecutionEnvironment.canUseDOM,
      'dangerouslyRenderMarkup(...): Cannot render markup in a Worker ' +
      'thread. This is likely a bug in the framework. Please report ' +
      'immediately.'
    ) : invariant(ExecutionEnvironment.canUseDOM));
    var nodeName;
    var markupByNodeName = {};
    // Group markup by `nodeName` if a wrap is necessary, else by '*'.
    for (var i = 0; i < markupList.length; i++) {
      ("production" !== process.env.NODE_ENV ? invariant(
        markupList[i],
        'dangerouslyRenderMarkup(...): Missing markup.'
      ) : invariant(markupList[i]));
      nodeName = getNodeName(markupList[i]);
      nodeName = getMarkupWrap(nodeName) ? nodeName : '*';
      markupByNodeName[nodeName] = markupByNodeName[nodeName] || [];
      markupByNodeName[nodeName][i] = markupList[i];
    }
    var resultList = [];
    var resultListAssignmentCount = 0;
    for (nodeName in markupByNodeName) {
      if (!markupByNodeName.hasOwnProperty(nodeName)) {
        continue;
      }
      var markupListByNodeName = markupByNodeName[nodeName];

      // This for-in loop skips the holes of the sparse array. The order of
      // iteration should follow the order of assignment, which happens to match
      // numerical index order, but we don't rely on that.
      for (var resultIndex in markupListByNodeName) {
        if (markupListByNodeName.hasOwnProperty(resultIndex)) {
          var markup = markupListByNodeName[resultIndex];

          // Push the requested markup with an additional RESULT_INDEX_ATTR
          // attribute.  If the markup does not start with a < character, it
          // will be discarded below (with an appropriate console.error).
          markupListByNodeName[resultIndex] = markup.replace(
            OPEN_TAG_NAME_EXP,
            // This index will be parsed back out below.
            '$1 ' + RESULT_INDEX_ATTR + '="' + resultIndex + '" '
          );
        }
      }

      // Render each group of markup with similar wrapping `nodeName`.
      var renderNodes = createNodesFromMarkup(
        markupListByNodeName.join(''),
        emptyFunction // Do nothing special with <script> tags.
      );

      for (i = 0; i < renderNodes.length; ++i) {
        var renderNode = renderNodes[i];
        if (renderNode.hasAttribute &&
            renderNode.hasAttribute(RESULT_INDEX_ATTR)) {

          resultIndex = +renderNode.getAttribute(RESULT_INDEX_ATTR);
          renderNode.removeAttribute(RESULT_INDEX_ATTR);

          ("production" !== process.env.NODE_ENV ? invariant(
            !resultList.hasOwnProperty(resultIndex),
            'Danger: Assigning to an already-occupied result index.'
          ) : invariant(!resultList.hasOwnProperty(resultIndex)));

          resultList[resultIndex] = renderNode;

          // This should match resultList.length and markupList.length when
          // we're done.
          resultListAssignmentCount += 1;

        } else if ("production" !== process.env.NODE_ENV) {
          console.error(
            "Danger: Discarding unexpected node:",
            renderNode
          );
        }
      }
    }

    // Although resultList was populated out of order, it should now be a dense
    // array.
    ("production" !== process.env.NODE_ENV ? invariant(
      resultListAssignmentCount === resultList.length,
      'Danger: Did not assign to every index of resultList.'
    ) : invariant(resultListAssignmentCount === resultList.length));

    ("production" !== process.env.NODE_ENV ? invariant(
      resultList.length === markupList.length,
      'Danger: Expected markup to render %s nodes, but rendered %s.',
      markupList.length,
      resultList.length
    ) : invariant(resultList.length === markupList.length));

    return resultList;
  },

  /**
   * Replaces a node with a string of markup at its current position within its
   * parent. The markup must render into a single root node.
   *
   * @param {DOMElement} oldChild Child node to replace.
   * @param {string} markup Markup to render in place of the child node.
   * @internal
   */
  dangerouslyReplaceNodeWithMarkup: function(oldChild, markup) {
    ("production" !== process.env.NODE_ENV ? invariant(
      ExecutionEnvironment.canUseDOM,
      'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a ' +
      'worker thread. This is likely a bug in the framework. Please report ' +
      'immediately.'
    ) : invariant(ExecutionEnvironment.canUseDOM));
    ("production" !== process.env.NODE_ENV ? invariant(markup, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : invariant(markup));
    ("production" !== process.env.NODE_ENV ? invariant(
      oldChild.tagName.toLowerCase() !== 'html',
      'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the ' +
      '<html> node. This is because browser quirks make this unreliable ' +
      'and/or slow. If you want to render to the root you must use ' +
      'server rendering. See renderComponentToString().'
    ) : invariant(oldChild.tagName.toLowerCase() !== 'html'));

    var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
    oldChild.parentNode.replaceChild(newChild, oldChild);
  }

};

module.exports = Danger;

}).call(this,require('_process'))
},{"./ExecutionEnvironment":100,"./createNodesFromMarkup":191,"./emptyFunction":194,"./getMarkupWrap":204,"./invariant":212,"_process":73}],92:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule DefaultEventPluginOrder
 */

"use strict";

 var keyOf = require("./keyOf");

/**
 * Module that is injectable into `EventPluginHub`, that specifies a
 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
 * plugins, without having to package every one of them. This is better than
 * having plugins be ordered in the same order that they are injected because
 * that ordering would be influenced by the packaging order.
 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
 */
var DefaultEventPluginOrder = [
  keyOf({ResponderEventPlugin: null}),
  keyOf({SimpleEventPlugin: null}),
  keyOf({TapEventPlugin: null}),
  keyOf({EnterLeaveEventPlugin: null}),
  keyOf({ChangeEventPlugin: null}),
  keyOf({SelectEventPlugin: null}),
  keyOf({CompositionEventPlugin: null}),
  keyOf({BeforeInputEventPlugin: null}),
  keyOf({AnalyticsEventPlugin: null}),
  keyOf({MobileSafariClickEventPlugin: null})
];

module.exports = DefaultEventPluginOrder;

},{"./keyOf":219}],93:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule EnterLeaveEventPlugin
 * @typechecks static-only
 */

"use strict";

var EventConstants = require("./EventConstants");
var EventPropagators = require("./EventPropagators");
var SyntheticMouseEvent = require("./SyntheticMouseEvent");

var ReactMount = require("./ReactMount");
var keyOf = require("./keyOf");

var topLevelTypes = EventConstants.topLevelTypes;
var getFirstReactDOM = ReactMount.getFirstReactDOM;

var eventTypes = {
  mouseEnter: {
    registrationName: keyOf({onMouseEnter: null}),
    dependencies: [
      topLevelTypes.topMouseOut,
      topLevelTypes.topMouseOver
    ]
  },
  mouseLeave: {
    registrationName: keyOf({onMouseLeave: null}),
    dependencies: [
      topLevelTypes.topMouseOut,
      topLevelTypes.topMouseOver
    ]
  }
};

var extractedEvents = [null, null];

var EnterLeaveEventPlugin = {

  eventTypes: eventTypes,

  /**
   * For almost every interaction we care about, there will be both a top-level
   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
   * we do not extract duplicate events. However, moving the mouse into the
   * browser from outside will not fire a `mouseout` event. In this case, we use
   * the `mouseover` top-level event.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function(
      topLevelType,
      topLevelTarget,
      topLevelTargetID,
      nativeEvent) {
    if (topLevelType === topLevelTypes.topMouseOver &&
        (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
      return null;
    }
    if (topLevelType !== topLevelTypes.topMouseOut &&
        topLevelType !== topLevelTypes.topMouseOver) {
      // Must not be a mouse in or mouse out - ignoring.
      return null;
    }

    var win;
    if (topLevelTarget.window === topLevelTarget) {
      // `topLevelTarget` is probably a window object.
      win = topLevelTarget;
    } else {
      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
      var doc = topLevelTarget.ownerDocument;
      if (doc) {
        win = doc.defaultView || doc.parentWindow;
      } else {
        win = window;
      }
    }

    var from, to;
    if (topLevelType === topLevelTypes.topMouseOut) {
      from = topLevelTarget;
      to =
        getFirstReactDOM(nativeEvent.relatedTarget || nativeEvent.toElement) ||
        win;
    } else {
      from = win;
      to = topLevelTarget;
    }

    if (from === to) {
      // Nothing pertains to our managed components.
      return null;
    }

    var fromID = from ? ReactMount.getID(from) : '';
    var toID = to ? ReactMount.getID(to) : '';

    var leave = SyntheticMouseEvent.getPooled(
      eventTypes.mouseLeave,
      fromID,
      nativeEvent
    );
    leave.type = 'mouseleave';
    leave.target = from;
    leave.relatedTarget = to;

    var enter = SyntheticMouseEvent.getPooled(
      eventTypes.mouseEnter,
      toID,
      nativeEvent
    );
    enter.type = 'mouseenter';
    enter.target = to;
    enter.relatedTarget = from;

    EventPropagators.accumulateEnterLeaveDispatches(leave, enter, fromID, toID);

    extractedEvents[0] = leave;
    extractedEvents[1] = enter;

    return extractedEvents;
  }

};

module.exports = EnterLeaveEventPlugin;

},{"./EventConstants":94,"./EventPropagators":99,"./ReactMount":145,"./SyntheticMouseEvent":178,"./keyOf":219}],94:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule EventConstants
 */

"use strict";

var keyMirror = require("./keyMirror");

var PropagationPhases = keyMirror({bubbled: null, captured: null});

/**
 * Types of raw signals from the browser caught at the top level.
 */
var topLevelTypes = keyMirror({
  topBlur: null,
  topChange: null,
  topClick: null,
  topCompositionEnd: null,
  topCompositionStart: null,
  topCompositionUpdate: null,
  topContextMenu: null,
  topCopy: null,
  topCut: null,
  topDoubleClick: null,
  topDrag: null,
  topDragEnd: null,
  topDragEnter: null,
  topDragExit: null,
  topDragLeave: null,
  topDragOver: null,
  topDragStart: null,
  topDrop: null,
  topError: null,
  topFocus: null,
  topInput: null,
  topKeyDown: null,
  topKeyPress: null,
  topKeyUp: null,
  topLoad: null,
  topMouseDown: null,
  topMouseMove: null,
  topMouseOut: null,
  topMouseOver: null,
  topMouseUp: null,
  topPaste: null,
  topReset: null,
  topScroll: null,
  topSelectionChange: null,
  topSubmit: null,
  topTextInput: null,
  topTouchCancel: null,
  topTouchEnd: null,
  topTouchMove: null,
  topTouchStart: null,
  topWheel: null
});

var EventConstants = {
  topLevelTypes: topLevelTypes,
  PropagationPhases: PropagationPhases
};

module.exports = EventConstants;

},{"./keyMirror":218}],95:[function(require,module,exports){
(function (process){
/**
 * @providesModule EventListener
 * @typechecks
 */

var emptyFunction = require("./emptyFunction");

/**
 * Upstream version of event listener. Does not take into account specific
 * nature of platform.
 */
var EventListener = {
  /**
   * Listen to DOM events during the bubble phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  listen: function(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, false);
      return {
        remove: function() {
          target.removeEventListener(eventType, callback, false);
        }
      };
    } else if (target.attachEvent) {
      target.attachEvent('on' + eventType, callback);
      return {
        remove: function() {
          target.detachEvent('on' + eventType, callback);
        }
      };
    }
  },

  /**
   * Listen to DOM events during the capture phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  capture: function(target, eventType, callback) {
    if (!target.addEventListener) {
      if ("production" !== process.env.NODE_ENV) {
        console.error(
          'Attempted to listen to events during the capture phase on a ' +
          'browser that does not support the capture phase. Your application ' +
          'will not receive some events.'
        );
      }
      return {
        remove: emptyFunction
      };
    } else {
      target.addEventListener(eventType, callback, true);
      return {
        remove: function() {
          target.removeEventListener(eventType, callback, true);
        }
      };
    }
  },

  registerDefault: function() {}
};

module.exports = EventListener;

}).call(this,require('_process'))
},{"./emptyFunction":194,"_process":73}],96:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule EventPluginHub
 */

"use strict";

var EventPluginRegistry = require("./EventPluginRegistry");
var EventPluginUtils = require("./EventPluginUtils");

var accumulate = require("./accumulate");
var forEachAccumulated = require("./forEachAccumulated");
var invariant = require("./invariant");
var isEventSupported = require("./isEventSupported");
var monitorCodeUse = require("./monitorCodeUse");

/**
 * Internal store for event listeners
 */
var listenerBank = {};

/**
 * Internal queue of events that have accumulated their dispatches and are
 * waiting to have their dispatches executed.
 */
var eventQueue = null;

/**
 * Dispatches an event and releases it back into the pool, unless persistent.
 *
 * @param {?object} event Synthetic event to be dispatched.
 * @private
 */
var executeDispatchesAndRelease = function(event) {
  if (event) {
    var executeDispatch = EventPluginUtils.executeDispatch;
    // Plugins can provide custom behavior when dispatching events.
    var PluginModule = EventPluginRegistry.getPluginModuleForEvent(event);
    if (PluginModule && PluginModule.executeDispatch) {
      executeDispatch = PluginModule.executeDispatch;
    }
    EventPluginUtils.executeDispatchesInOrder(event, executeDispatch);

    if (!event.isPersistent()) {
      event.constructor.release(event);
    }
  }
};

/**
 * - `InstanceHandle`: [required] Module that performs logical traversals of DOM
 *   hierarchy given ids of the logical DOM elements involved.
 */
var InstanceHandle = null;

function validateInstanceHandle() {
  var invalid = !InstanceHandle||
    !InstanceHandle.traverseTwoPhase ||
    !InstanceHandle.traverseEnterLeave;
  if (invalid) {
    throw new Error('InstanceHandle not injected before use!');
  }
}

/**
 * This is a unified interface for event plugins to be installed and configured.
 *
 * Event plugins can implement the following properties:
 *
 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
 *     Required. When a top-level event is fired, this method is expected to
 *     extract synthetic events that will in turn be queued and dispatched.
 *
 *   `eventTypes` {object}
 *     Optional, plugins that fire events must publish a mapping of registration
 *     names that are used to register listeners. Values of this mapping must
 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
 *
 *   `executeDispatch` {function(object, function, string)}
 *     Optional, allows plugins to override how an event gets dispatched. By
 *     default, the listener is simply invoked.
 *
 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
 *
 * @public
 */
var EventPluginHub = {

  /**
   * Methods for injecting dependencies.
   */
  injection: {

    /**
     * @param {object} InjectedMount
     * @public
     */
    injectMount: EventPluginUtils.injection.injectMount,

    /**
     * @param {object} InjectedInstanceHandle
     * @public
     */
    injectInstanceHandle: function(InjectedInstanceHandle) {
      InstanceHandle = InjectedInstanceHandle;
      if ("production" !== process.env.NODE_ENV) {
        validateInstanceHandle();
      }
    },

    getInstanceHandle: function() {
      if ("production" !== process.env.NODE_ENV) {
        validateInstanceHandle();
      }
      return InstanceHandle;
    },

    /**
     * @param {array} InjectedEventPluginOrder
     * @public
     */
    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,

    /**
     * @param {object} injectedNamesToPlugins Map from names to plugin modules.
     */
    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName

  },

  eventNameDispatchConfigs: EventPluginRegistry.eventNameDispatchConfigs,

  registrationNameModules: EventPluginRegistry.registrationNameModules,

  /**
   * Stores `listener` at `listenerBank[registrationName][id]`. Is idempotent.
   *
   * @param {string} id ID of the DOM element.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @param {?function} listener The callback to store.
   */
  putListener: function(id, registrationName, listener) {
    ("production" !== process.env.NODE_ENV ? invariant(
      !listener || typeof listener === 'function',
      'Expected %s listener to be a function, instead got type %s',
      registrationName, typeof listener
    ) : invariant(!listener || typeof listener === 'function'));

    if ("production" !== process.env.NODE_ENV) {
      // IE8 has no API for event capturing and the `onScroll` event doesn't
      // bubble.
      if (registrationName === 'onScroll' &&
          !isEventSupported('scroll', true)) {
        monitorCodeUse('react_no_scroll_event');
        console.warn('This browser doesn\'t support the `onScroll` event');
      }
    }
    var bankForRegistrationName =
      listenerBank[registrationName] || (listenerBank[registrationName] = {});
    bankForRegistrationName[id] = listener;
  },

  /**
   * @param {string} id ID of the DOM element.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @return {?function} The stored callback.
   */
  getListener: function(id, registrationName) {
    var bankForRegistrationName = listenerBank[registrationName];
    return bankForRegistrationName && bankForRegistrationName[id];
  },

  /**
   * Deletes a listener from the registration bank.
   *
   * @param {string} id ID of the DOM element.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   */
  deleteListener: function(id, registrationName) {
    var bankForRegistrationName = listenerBank[registrationName];
    if (bankForRegistrationName) {
      delete bankForRegistrationName[id];
    }
  },

  /**
   * Deletes all listeners for the DOM element with the supplied ID.
   *
   * @param {string} id ID of the DOM element.
   */
  deleteAllListeners: function(id) {
    for (var registrationName in listenerBank) {
      delete listenerBank[registrationName][id];
    }
  },

  /**
   * Allows registered plugins an opportunity to extract events from top-level
   * native browser events.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @internal
   */
  extractEvents: function(
      topLevelType,
      topLevelTarget,
      topLevelTargetID,
      nativeEvent) {
    var events;
    var plugins = EventPluginRegistry.plugins;
    for (var i = 0, l = plugins.length; i < l; i++) {
      // Not every plugin in the ordering may be loaded at runtime.
      var possiblePlugin = plugins[i];
      if (possiblePlugin) {
        var extractedEvents = possiblePlugin.extractEvents(
          topLevelType,
          topLevelTarget,
          topLevelTargetID,
          nativeEvent
        );
        if (extractedEvents) {
          events = accumulate(events, extractedEvents);
        }
      }
    }
    return events;
  },

  /**
   * Enqueues a synthetic event that should be dispatched when
   * `processEventQueue` is invoked.
   *
   * @param {*} events An accumulation of synthetic events.
   * @internal
   */
  enqueueEvents: function(events) {
    if (events) {
      eventQueue = accumulate(eventQueue, events);
    }
  },

  /**
   * Dispatches all synthetic events on the event queue.
   *
   * @internal
   */
  processEventQueue: function() {
    // Set `eventQueue` to null before processing it so that we can tell if more
    // events get enqueued while processing.
    var processingEventQueue = eventQueue;
    eventQueue = null;
    forEachAccumulated(processingEventQueue, executeDispatchesAndRelease);
    ("production" !== process.env.NODE_ENV ? invariant(
      !eventQueue,
      'processEventQueue(): Additional events were enqueued while processing ' +
      'an event queue. Support for this has not yet been implemented.'
    ) : invariant(!eventQueue));
  },

  /**
   * These are needed for tests only. Do not use!
   */
  __purge: function() {
    listenerBank = {};
  },

  __getListenerBank: function() {
    return listenerBank;
  }

};

module.exports = EventPluginHub;

}).call(this,require('_process'))
},{"./EventPluginRegistry":97,"./EventPluginUtils":98,"./accumulate":184,"./forEachAccumulated":199,"./invariant":212,"./isEventSupported":213,"./monitorCodeUse":226,"_process":73}],97:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule EventPluginRegistry
 * @typechecks static-only
 */

"use strict";

var invariant = require("./invariant");

/**
 * Injectable ordering of event plugins.
 */
var EventPluginOrder = null;

/**
 * Injectable mapping from names to event plugin modules.
 */
var namesToPlugins = {};

/**
 * Recomputes the plugin list using the injected plugins and plugin ordering.
 *
 * @private
 */
function recomputePluginOrdering() {
  if (!EventPluginOrder) {
    // Wait until an `EventPluginOrder` is injected.
    return;
  }
  for (var pluginName in namesToPlugins) {
    var PluginModule = namesToPlugins[pluginName];
    var pluginIndex = EventPluginOrder.indexOf(pluginName);
    ("production" !== process.env.NODE_ENV ? invariant(
      pluginIndex > -1,
      'EventPluginRegistry: Cannot inject event plugins that do not exist in ' +
      'the plugin ordering, `%s`.',
      pluginName
    ) : invariant(pluginIndex > -1));
    if (EventPluginRegistry.plugins[pluginIndex]) {
      continue;
    }
    ("production" !== process.env.NODE_ENV ? invariant(
      PluginModule.extractEvents,
      'EventPluginRegistry: Event plugins must implement an `extractEvents` ' +
      'method, but `%s` does not.',
      pluginName
    ) : invariant(PluginModule.extractEvents));
    EventPluginRegistry.plugins[pluginIndex] = PluginModule;
    var publishedEvents = PluginModule.eventTypes;
    for (var eventName in publishedEvents) {
      ("production" !== process.env.NODE_ENV ? invariant(
        publishEventForPlugin(
          publishedEvents[eventName],
          PluginModule,
          eventName
        ),
        'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.',
        eventName,
        pluginName
      ) : invariant(publishEventForPlugin(
        publishedEvents[eventName],
        PluginModule,
        eventName
      )));
    }
  }
}

/**
 * Publishes an event so that it can be dispatched by the supplied plugin.
 *
 * @param {object} dispatchConfig Dispatch configuration for the event.
 * @param {object} PluginModule Plugin publishing the event.
 * @return {boolean} True if the event was successfully published.
 * @private
 */
function publishEventForPlugin(dispatchConfig, PluginModule, eventName) {
  ("production" !== process.env.NODE_ENV ? invariant(
    !EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName),
    'EventPluginHub: More than one plugin attempted to publish the same ' +
    'event name, `%s`.',
    eventName
  ) : invariant(!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName)));
  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;

  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
  if (phasedRegistrationNames) {
    for (var phaseName in phasedRegistrationNames) {
      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
        var phasedRegistrationName = phasedRegistrationNames[phaseName];
        publishRegistrationName(
          phasedRegistrationName,
          PluginModule,
          eventName
        );
      }
    }
    return true;
  } else if (dispatchConfig.registrationName) {
    publishRegistrationName(
      dispatchConfig.registrationName,
      PluginModule,
      eventName
    );
    return true;
  }
  return false;
}

/**
 * Publishes a registration name that is used to identify dispatched events and
 * can be used with `EventPluginHub.putListener` to register listeners.
 *
 * @param {string} registrationName Registration name to add.
 * @param {object} PluginModule Plugin publishing the event.
 * @private
 */
function publishRegistrationName(registrationName, PluginModule, eventName) {
  ("production" !== process.env.NODE_ENV ? invariant(
    !EventPluginRegistry.registrationNameModules[registrationName],
    'EventPluginHub: More than one plugin attempted to publish the same ' +
    'registration name, `%s`.',
    registrationName
  ) : invariant(!EventPluginRegistry.registrationNameModules[registrationName]));
  EventPluginRegistry.registrationNameModules[registrationName] = PluginModule;
  EventPluginRegistry.registrationNameDependencies[registrationName] =
    PluginModule.eventTypes[eventName].dependencies;
}

/**
 * Registers plugins so that they can extract and dispatch events.
 *
 * @see {EventPluginHub}
 */
var EventPluginRegistry = {

  /**
   * Ordered list of injected plugins.
   */
  plugins: [],

  /**
   * Mapping from event name to dispatch config
   */
  eventNameDispatchConfigs: {},

  /**
   * Mapping from registration name to plugin module
   */
  registrationNameModules: {},

  /**
   * Mapping from registration name to event name
   */
  registrationNameDependencies: {},

  /**
   * Injects an ordering of plugins (by plugin name). This allows the ordering
   * to be decoupled from injection of the actual plugins so that ordering is
   * always deterministic regardless of packaging, on-the-fly injection, etc.
   *
   * @param {array} InjectedEventPluginOrder
   * @internal
   * @see {EventPluginHub.injection.injectEventPluginOrder}
   */
  injectEventPluginOrder: function(InjectedEventPluginOrder) {
    ("production" !== process.env.NODE_ENV ? invariant(
      !EventPluginOrder,
      'EventPluginRegistry: Cannot inject event plugin ordering more than ' +
      'once. You are likely trying to load more than one copy of React.'
    ) : invariant(!EventPluginOrder));
    // Clone the ordering so it cannot be dynamically mutated.
    EventPluginOrder = Array.prototype.slice.call(InjectedEventPluginOrder);
    recomputePluginOrdering();
  },

  /**
   * Injects plugins to be used by `EventPluginHub`. The plugin names must be
   * in the ordering injected by `injectEventPluginOrder`.
   *
   * Plugins can be injected as part of page initialization or on-the-fly.
   *
   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
   * @internal
   * @see {EventPluginHub.injection.injectEventPluginsByName}
   */
  injectEventPluginsByName: function(injectedNamesToPlugins) {
    var isOrderingDirty = false;
    for (var pluginName in injectedNamesToPlugins) {
      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
        continue;
      }
      var PluginModule = injectedNamesToPlugins[pluginName];
      if (!namesToPlugins.hasOwnProperty(pluginName) ||
          namesToPlugins[pluginName] !== PluginModule) {
        ("production" !== process.env.NODE_ENV ? invariant(
          !namesToPlugins[pluginName],
          'EventPluginRegistry: Cannot inject two different event plugins ' +
          'using the same name, `%s`.',
          pluginName
        ) : invariant(!namesToPlugins[pluginName]));
        namesToPlugins[pluginName] = PluginModule;
        isOrderingDirty = true;
      }
    }
    if (isOrderingDirty) {
      recomputePluginOrdering();
    }
  },

  /**
   * Looks up the plugin for the supplied event.
   *
   * @param {object} event A synthetic event.
   * @return {?object} The plugin that created the supplied event.
   * @internal
   */
  getPluginModuleForEvent: function(event) {
    var dispatchConfig = event.dispatchConfig;
    if (dispatchConfig.registrationName) {
      return EventPluginRegistry.registrationNameModules[
        dispatchConfig.registrationName
      ] || null;
    }
    for (var phase in dispatchConfig.phasedRegistrationNames) {
      if (!dispatchConfig.phasedRegistrationNames.hasOwnProperty(phase)) {
        continue;
      }
      var PluginModule = EventPluginRegistry.registrationNameModules[
        dispatchConfig.phasedRegistrationNames[phase]
      ];
      if (PluginModule) {
        return PluginModule;
      }
    }
    return null;
  },

  /**
   * Exposed for unit testing.
   * @private
   */
  _resetEventPlugins: function() {
    EventPluginOrder = null;
    for (var pluginName in namesToPlugins) {
      if (namesToPlugins.hasOwnProperty(pluginName)) {
        delete namesToPlugins[pluginName];
      }
    }
    EventPluginRegistry.plugins.length = 0;

    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
    for (var eventName in eventNameDispatchConfigs) {
      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
        delete eventNameDispatchConfigs[eventName];
      }
    }

    var registrationNameModules = EventPluginRegistry.registrationNameModules;
    for (var registrationName in registrationNameModules) {
      if (registrationNameModules.hasOwnProperty(registrationName)) {
        delete registrationNameModules[registrationName];
      }
    }
  }

};

module.exports = EventPluginRegistry;

}).call(this,require('_process'))
},{"./invariant":212,"_process":73}],98:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule EventPluginUtils
 */

"use strict";

var EventConstants = require("./EventConstants");

var invariant = require("./invariant");

/**
 * Injected dependencies:
 */

/**
 * - `Mount`: [required] Module that can convert between React dom IDs and
 *   actual node references.
 */
var injection = {
  Mount: null,
  injectMount: function(InjectedMount) {
    injection.Mount = InjectedMount;
    if ("production" !== process.env.NODE_ENV) {
      ("production" !== process.env.NODE_ENV ? invariant(
        InjectedMount && InjectedMount.getNode,
        'EventPluginUtils.injection.injectMount(...): Injected Mount module ' +
        'is missing getNode.'
      ) : invariant(InjectedMount && InjectedMount.getNode));
    }
  }
};

var topLevelTypes = EventConstants.topLevelTypes;

function isEndish(topLevelType) {
  return topLevelType === topLevelTypes.topMouseUp ||
         topLevelType === topLevelTypes.topTouchEnd ||
         topLevelType === topLevelTypes.topTouchCancel;
}

function isMoveish(topLevelType) {
  return topLevelType === topLevelTypes.topMouseMove ||
         topLevelType === topLevelTypes.topTouchMove;
}
function isStartish(topLevelType) {
  return topLevelType === topLevelTypes.topMouseDown ||
         topLevelType === topLevelTypes.topTouchStart;
}


var validateEventDispatches;
if ("production" !== process.env.NODE_ENV) {
  validateEventDispatches = function(event) {
    var dispatchListeners = event._dispatchListeners;
    var dispatchIDs = event._dispatchIDs;

    var listenersIsArr = Array.isArray(dispatchListeners);
    var idsIsArr = Array.isArray(dispatchIDs);
    var IDsLen = idsIsArr ? dispatchIDs.length : dispatchIDs ? 1 : 0;
    var listenersLen = listenersIsArr ?
      dispatchListeners.length :
      dispatchListeners ? 1 : 0;

    ("production" !== process.env.NODE_ENV ? invariant(
      idsIsArr === listenersIsArr && IDsLen === listenersLen,
      'EventPluginUtils: Invalid `event`.'
    ) : invariant(idsIsArr === listenersIsArr && IDsLen === listenersLen));
  };
}

/**
 * Invokes `cb(event, listener, id)`. Avoids using call if no scope is
 * provided. The `(listener,id)` pair effectively forms the "dispatch" but are
 * kept separate to conserve memory.
 */
function forEachEventDispatch(event, cb) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchIDs = event._dispatchIDs;
  if ("production" !== process.env.NODE_ENV) {
    validateEventDispatches(event);
  }
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i < dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and IDs are two parallel arrays that are always in sync.
      cb(event, dispatchListeners[i], dispatchIDs[i]);
    }
  } else if (dispatchListeners) {
    cb(event, dispatchListeners, dispatchIDs);
  }
}

/**
 * Default implementation of PluginModule.executeDispatch().
 * @param {SyntheticEvent} SyntheticEvent to handle
 * @param {function} Application-level callback
 * @param {string} domID DOM id to pass to the callback.
 */
function executeDispatch(event, listener, domID) {
  event.currentTarget = injection.Mount.getNode(domID);
  var returnValue = listener(event, domID);
  event.currentTarget = null;
  return returnValue;
}

/**
 * Standard/simple iteration through an event's collected dispatches.
 */
function executeDispatchesInOrder(event, executeDispatch) {
  forEachEventDispatch(event, executeDispatch);
  event._dispatchListeners = null;
  event._dispatchIDs = null;
}

/**
 * Standard/simple iteration through an event's collected dispatches, but stops
 * at the first dispatch execution returning true, and returns that id.
 *
 * @return id of the first dispatch execution who's listener returns true, or
 * null if no listener returned true.
 */
function executeDispatchesInOrderStopAtTrueImpl(event) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchIDs = event._dispatchIDs;
  if ("production" !== process.env.NODE_ENV) {
    validateEventDispatches(event);
  }
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i < dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and IDs are two parallel arrays that are always in sync.
      if (dispatchListeners[i](event, dispatchIDs[i])) {
        return dispatchIDs[i];
      }
    }
  } else if (dispatchListeners) {
    if (dispatchListeners(event, dispatchIDs)) {
      return dispatchIDs;
    }
  }
  return null;
}

/**
 * @see executeDispatchesInOrderStopAtTrueImpl
 */
function executeDispatchesInOrderStopAtTrue(event) {
  var ret = executeDispatchesInOrderStopAtTrueImpl(event);
  event._dispatchIDs = null;
  event._dispatchListeners = null;
  return ret;
}

/**
 * Execution of a "direct" dispatch - there must be at most one dispatch
 * accumulated on the event or it is considered an error. It doesn't really make
 * sense for an event with multiple dispatches (bubbled) to keep track of the
 * return values at each dispatch execution, but it does tend to make sense when
 * dealing with "direct" dispatches.
 *
 * @return The return value of executing the single dispatch.
 */
function executeDirectDispatch(event) {
  if ("production" !== process.env.NODE_ENV) {
    validateEventDispatches(event);
  }
  var dispatchListener = event._dispatchListeners;
  var dispatchID = event._dispatchIDs;
  ("production" !== process.env.NODE_ENV ? invariant(
    !Array.isArray(dispatchListener),
    'executeDirectDispatch(...): Invalid `event`.'
  ) : invariant(!Array.isArray(dispatchListener)));
  var res = dispatchListener ?
    dispatchListener(event, dispatchID) :
    null;
  event._dispatchListeners = null;
  event._dispatchIDs = null;
  return res;
}

/**
 * @param {SyntheticEvent} event
 * @return {bool} True iff number of dispatches accumulated is greater than 0.
 */
function hasDispatches(event) {
  return !!event._dispatchListeners;
}

/**
 * General utilities that are useful in creating custom Event Plugins.
 */
var EventPluginUtils = {
  isEndish: isEndish,
  isMoveish: isMoveish,
  isStartish: isStartish,

  executeDirectDispatch: executeDirectDispatch,
  executeDispatch: executeDispatch,
  executeDispatchesInOrder: executeDispatchesInOrder,
  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
  hasDispatches: hasDispatches,
  injection: injection,
  useTouchEvents: false
};

module.exports = EventPluginUtils;

}).call(this,require('_process'))
},{"./EventConstants":94,"./invariant":212,"_process":73}],99:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule EventPropagators
 */

"use strict";

var EventConstants = require("./EventConstants");
var EventPluginHub = require("./EventPluginHub");

var accumulate = require("./accumulate");
var forEachAccumulated = require("./forEachAccumulated");

var PropagationPhases = EventConstants.PropagationPhases;
var getListener = EventPluginHub.getListener;

/**
 * Some event types have a notion of different registration names for different
 * "phases" of propagation. This finds listeners by a given phase.
 */
function listenerAtPhase(id, event, propagationPhase) {
  var registrationName =
    event.dispatchConfig.phasedRegistrationNames[propagationPhase];
  return getListener(id, registrationName);
}

/**
 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
 * here, allows us to not have to bind or create functions for each event.
 * Mutating the event's members allows us to not have to create a wrapping
 * "dispatch" object that pairs the event with the listener.
 */
function accumulateDirectionalDispatches(domID, upwards, event) {
  if ("production" !== process.env.NODE_ENV) {
    if (!domID) {
      throw new Error('Dispatching id must not be null');
    }
  }
  var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;
  var listener = listenerAtPhase(domID, event, phase);
  if (listener) {
    event._dispatchListeners = accumulate(event._dispatchListeners, listener);
    event._dispatchIDs = accumulate(event._dispatchIDs, domID);
  }
}

/**
 * Collect dispatches (must be entirely collected before dispatching - see unit
 * tests). Lazily allocate the array to conserve memory.  We must loop through
 * each event and perform the traversal for each one. We can not perform a
 * single traversal for the entire collection of events because each event may
 * have a different target.
 */
function accumulateTwoPhaseDispatchesSingle(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    EventPluginHub.injection.getInstanceHandle().traverseTwoPhase(
      event.dispatchMarker,
      accumulateDirectionalDispatches,
      event
    );
  }
}


/**
 * Accumulates without regard to direction, does not look for phased
 * registration names. Same as `accumulateDirectDispatchesSingle` but without
 * requiring that the `dispatchMarker` be the same as the dispatched ID.
 */
function accumulateDispatches(id, ignoredDirection, event) {
  if (event && event.dispatchConfig.registrationName) {
    var registrationName = event.dispatchConfig.registrationName;
    var listener = getListener(id, registrationName);
    if (listener) {
      event._dispatchListeners = accumulate(event._dispatchListeners, listener);
      event._dispatchIDs = accumulate(event._dispatchIDs, id);
    }
  }
}

/**
 * Accumulates dispatches on an `SyntheticEvent`, but only for the
 * `dispatchMarker`.
 * @param {SyntheticEvent} event
 */
function accumulateDirectDispatchesSingle(event) {
  if (event && event.dispatchConfig.registrationName) {
    accumulateDispatches(event.dispatchMarker, null, event);
  }
}

function accumulateTwoPhaseDispatches(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
}

function accumulateEnterLeaveDispatches(leave, enter, fromID, toID) {
  EventPluginHub.injection.getInstanceHandle().traverseEnterLeave(
    fromID,
    toID,
    accumulateDispatches,
    leave,
    enter
  );
}


function accumulateDirectDispatches(events) {
  forEachAccumulated(events, accumulateDirectDispatchesSingle);
}



/**
 * A small set of propagation patterns, each of which will accept a small amount
 * of information, and generate a set of "dispatch ready event objects" - which
 * are sets of events that have already been annotated with a set of dispatched
 * listener functions/ids. The API is designed this way to discourage these
 * propagation strategies from actually executing the dispatches, since we
 * always want to collect the entire set of dispatches before executing event a
 * single one.
 *
 * @constructor EventPropagators
 */
var EventPropagators = {
  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
  accumulateDirectDispatches: accumulateDirectDispatches,
  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
};

module.exports = EventPropagators;

}).call(this,require('_process'))
},{"./EventConstants":94,"./EventPluginHub":96,"./accumulate":184,"./forEachAccumulated":199,"_process":73}],100:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ExecutionEnvironment
 */

/*jslint evil: true */

"use strict";

var canUseDOM = !!(
  typeof window !== 'undefined' &&
  window.document &&
  window.document.createElement
);

/**
 * Simple, lightweight module assisting with the detection and context of
 * Worker. Helps avoid circular dependencies and allows code to reason about
 * whether or not they are in a Worker, even if they never include the main
 * `ReactWorker` dependency.
 */
var ExecutionEnvironment = {

  canUseDOM: canUseDOM,

  canUseWorkers: typeof Worker !== 'undefined',

  canUseEventListeners:
    canUseDOM && !!(window.addEventListener || window.attachEvent),

  canUseViewport: canUseDOM && !!window.screen,

  isInWorker: !canUseDOM // For now, this is true - might change in the future.

};

module.exports = ExecutionEnvironment;

},{}],101:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule HTMLDOMPropertyConfig
 */

/*jslint bitwise: true*/

"use strict";

var DOMProperty = require("./DOMProperty");
var ExecutionEnvironment = require("./ExecutionEnvironment");

var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;
var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
var HAS_SIDE_EFFECTS = DOMProperty.injection.HAS_SIDE_EFFECTS;
var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
var HAS_POSITIVE_NUMERIC_VALUE =
  DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
var HAS_OVERLOADED_BOOLEAN_VALUE =
  DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;

var hasSVG;
if (ExecutionEnvironment.canUseDOM) {
  var implementation = document.implementation;
  hasSVG = (
    implementation &&
    implementation.hasFeature &&
    implementation.hasFeature(
      'http://www.w3.org/TR/SVG11/feature#BasicStructure',
      '1.1'
    )
  );
}


var HTMLDOMPropertyConfig = {
  isCustomAttribute: RegExp.prototype.test.bind(
    /^(data|aria)-[a-z_][a-z\d_.\-]*$/
  ),
  Properties: {
    /**
     * Standard Properties
     */
    accept: null,
    accessKey: null,
    action: null,
    allowFullScreen: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
    allowTransparency: MUST_USE_ATTRIBUTE,
    alt: null,
    async: HAS_BOOLEAN_VALUE,
    autoComplete: null,
    // autoFocus is polyfilled/normalized by AutoFocusMixin
    // autoFocus: HAS_BOOLEAN_VALUE,
    autoPlay: HAS_BOOLEAN_VALUE,
    cellPadding: null,
    cellSpacing: null,
    charSet: MUST_USE_ATTRIBUTE,
    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    // To set className on SVG elements, it's necessary to use .setAttribute;
    // this works on HTML elements too in all browsers except IE8. Conveniently,
    // IE8 doesn't support SVG and so we can simply use the attribute in
    // browsers that support SVG and the property in browsers that don't,
    // regardless of whether the element is HTML or SVG.
    className: hasSVG ? MUST_USE_ATTRIBUTE : MUST_USE_PROPERTY,
    cols: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
    colSpan: null,
    content: null,
    contentEditable: null,
    contextMenu: MUST_USE_ATTRIBUTE,
    controls: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    coords: null,
    crossOrigin: null,
    data: null, // For `<object />` acts as `src`.
    dateTime: MUST_USE_ATTRIBUTE,
    defer: HAS_BOOLEAN_VALUE,
    dir: null,
    disabled: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
    download: HAS_OVERLOADED_BOOLEAN_VALUE,
    draggable: null,
    encType: null,
    form: MUST_USE_ATTRIBUTE,
    formNoValidate: HAS_BOOLEAN_VALUE,
    frameBorder: MUST_USE_ATTRIBUTE,
    height: MUST_USE_ATTRIBUTE,
    hidden: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
    href: null,
    hrefLang: null,
    htmlFor: null,
    httpEquiv: null,
    icon: null,
    id: MUST_USE_PROPERTY,
    label: null,
    lang: null,
    list: null,
    loop: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    max: null,
    maxLength: MUST_USE_ATTRIBUTE,
    mediaGroup: null,
    method: null,
    min: null,
    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    name: null,
    noValidate: HAS_BOOLEAN_VALUE,
    pattern: null,
    placeholder: null,
    poster: null,
    preload: null,
    radioGroup: null,
    readOnly: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    rel: null,
    required: HAS_BOOLEAN_VALUE,
    role: MUST_USE_ATTRIBUTE,
    rows: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
    rowSpan: null,
    sandbox: null,
    scope: null,
    scrollLeft: MUST_USE_PROPERTY,
    scrolling: null,
    scrollTop: MUST_USE_PROPERTY,
    seamless: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    shape: null,
    size: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
    span: HAS_POSITIVE_NUMERIC_VALUE,
    spellCheck: null,
    src: null,
    srcDoc: MUST_USE_PROPERTY,
    srcSet: null,
    start: HAS_NUMERIC_VALUE,
    step: null,
    style: null,
    tabIndex: null,
    target: null,
    title: null,
    type: null,
    useMap: null,
    value: MUST_USE_PROPERTY | HAS_SIDE_EFFECTS,
    width: MUST_USE_ATTRIBUTE,
    wmode: MUST_USE_ATTRIBUTE,

    /**
     * Non-standard Properties
     */
    autoCapitalize: null, // Supported in Mobile Safari for keyboard hints
    autoCorrect: null, // Supported in Mobile Safari for keyboard hints
    itemProp: MUST_USE_ATTRIBUTE, // Microdata: http://schema.org/docs/gs.html
    itemScope: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE, // Microdata: http://schema.org/docs/gs.html
    itemType: MUST_USE_ATTRIBUTE, // Microdata: http://schema.org/docs/gs.html
    property: null // Supports OG in meta tags
  },
  DOMAttributeNames: {
    className: 'class',
    htmlFor: 'for',
    httpEquiv: 'http-equiv'
  },
  DOMPropertyNames: {
    autoCapitalize: 'autocapitalize',
    autoComplete: 'autocomplete',
    autoCorrect: 'autocorrect',
    autoFocus: 'autofocus',
    autoPlay: 'autoplay',
    encType: 'enctype',
    hrefLang: 'hreflang',
    radioGroup: 'radiogroup',
    spellCheck: 'spellcheck',
    srcDoc: 'srcdoc',
    srcSet: 'srcset'
  }
};

module.exports = HTMLDOMPropertyConfig;

},{"./DOMProperty":89,"./ExecutionEnvironment":100}],102:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule LinkedStateMixin
 * @typechecks static-only
 */

"use strict";

var ReactLink = require("./ReactLink");
var ReactStateSetters = require("./ReactStateSetters");

/**
 * A simple mixin around ReactLink.forState().
 */
var LinkedStateMixin = {
  /**
   * Create a ReactLink that's linked to part of this component's state. The
   * ReactLink will have the current value of this.state[key] and will call
   * setState() when a change is requested.
   *
   * @param {string} key state key to update. Note: you may want to use keyOf()
   * if you're using Google Closure Compiler advanced mode.
   * @return {ReactLink} ReactLink instance linking to the state.
   */
  linkState: function(key) {
    return new ReactLink(
      this.state[key],
      ReactStateSetters.createStateKeySetter(this, key)
    );
  }
};

module.exports = LinkedStateMixin;

},{"./ReactLink":143,"./ReactStateSetters":159}],103:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule LinkedValueUtils
 * @typechecks static-only
 */

"use strict";

var ReactPropTypes = require("./ReactPropTypes");

var invariant = require("./invariant");

var hasReadOnlyValue = {
  'button': true,
  'checkbox': true,
  'image': true,
  'hidden': true,
  'radio': true,
  'reset': true,
  'submit': true
};

function _assertSingleLink(input) {
  ("production" !== process.env.NODE_ENV ? invariant(
    input.props.checkedLink == null || input.props.valueLink == null,
    'Cannot provide a checkedLink and a valueLink. If you want to use ' +
    'checkedLink, you probably don\'t want to use valueLink and vice versa.'
  ) : invariant(input.props.checkedLink == null || input.props.valueLink == null));
}
function _assertValueLink(input) {
  _assertSingleLink(input);
  ("production" !== process.env.NODE_ENV ? invariant(
    input.props.value == null && input.props.onChange == null,
    'Cannot provide a valueLink and a value or onChange event. If you want ' +
    'to use value or onChange, you probably don\'t want to use valueLink.'
  ) : invariant(input.props.value == null && input.props.onChange == null));
}

function _assertCheckedLink(input) {
  _assertSingleLink(input);
  ("production" !== process.env.NODE_ENV ? invariant(
    input.props.checked == null && input.props.onChange == null,
    'Cannot provide a checkedLink and a checked property or onChange event. ' +
    'If you want to use checked or onChange, you probably don\'t want to ' +
    'use checkedLink'
  ) : invariant(input.props.checked == null && input.props.onChange == null));
}

/**
 * @param {SyntheticEvent} e change event to handle
 */
function _handleLinkedValueChange(e) {
  /*jshint validthis:true */
  this.props.valueLink.requestChange(e.target.value);
}

/**
  * @param {SyntheticEvent} e change event to handle
  */
function _handleLinkedCheckChange(e) {
  /*jshint validthis:true */
  this.props.checkedLink.requestChange(e.target.checked);
}

/**
 * Provide a linked `value` attribute for controlled forms. You should not use
 * this outside of the ReactDOM controlled form components.
 */
var LinkedValueUtils = {
  Mixin: {
    propTypes: {
      value: function(props, propName, componentName) {
        if (!props[propName] ||
            hasReadOnlyValue[props.type] ||
            props.onChange ||
            props.readOnly ||
            props.disabled) {
          return;
        }
        return new Error(
          'You provided a `value` prop to a form field without an ' +
          '`onChange` handler. This will render a read-only field. If ' +
          'the field should be mutable use `defaultValue`. Otherwise, ' +
          'set either `onChange` or `readOnly`.'
        );
      },
      checked: function(props, propName, componentName) {
        if (!props[propName] ||
            props.onChange ||
            props.readOnly ||
            props.disabled) {
          return;
        }
        return new Error(
          'You provided a `checked` prop to a form field without an ' +
          '`onChange` handler. This will render a read-only field. If ' +
          'the field should be mutable use `defaultChecked`. Otherwise, ' +
          'set either `onChange` or `readOnly`.'
        );
      },
      onChange: ReactPropTypes.func
    }
  },

  /**
   * @param {ReactComponent} input Form component
   * @return {*} current value of the input either from value prop or link.
   */
  getValue: function(input) {
    if (input.props.valueLink) {
      _assertValueLink(input);
      return input.props.valueLink.value;
    }
    return input.props.value;
  },

  /**
   * @param {ReactComponent} input Form component
   * @return {*} current checked status of the input either from checked prop
   *             or link.
   */
  getChecked: function(input) {
    if (input.props.checkedLink) {
      _assertCheckedLink(input);
      return input.props.checkedLink.value;
    }
    return input.props.checked;
  },

  /**
   * @param {ReactComponent} input Form component
   * @return {function} change callback either from onChange prop or link.
   */
  getOnChange: function(input) {
    if (input.props.valueLink) {
      _assertValueLink(input);
      return _handleLinkedValueChange;
    } else if (input.props.checkedLink) {
      _assertCheckedLink(input);
      return _handleLinkedCheckChange;
    }
    return input.props.onChange;
  }
};

module.exports = LinkedValueUtils;

}).call(this,require('_process'))
},{"./ReactPropTypes":153,"./invariant":212,"_process":73}],104:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule LocalEventTrapMixin
 */

"use strict";

var ReactBrowserEventEmitter = require("./ReactBrowserEventEmitter");

var accumulate = require("./accumulate");
var forEachAccumulated = require("./forEachAccumulated");
var invariant = require("./invariant");

function remove(event) {
  event.remove();
}

var LocalEventTrapMixin = {
  trapBubbledEvent:function(topLevelType, handlerBaseName) {
    ("production" !== process.env.NODE_ENV ? invariant(this.isMounted(), 'Must be mounted to trap events') : invariant(this.isMounted()));
    var listener = ReactBrowserEventEmitter.trapBubbledEvent(
      topLevelType,
      handlerBaseName,
      this.getDOMNode()
    );
    this._localEventListeners = accumulate(this._localEventListeners, listener);
  },

  // trapCapturedEvent would look nearly identical. We don't implement that
  // method because it isn't currently needed.

  componentWillUnmount:function() {
    if (this._localEventListeners) {
      forEachAccumulated(this._localEventListeners, remove);
    }
  }
};

module.exports = LocalEventTrapMixin;

}).call(this,require('_process'))
},{"./ReactBrowserEventEmitter":109,"./accumulate":184,"./forEachAccumulated":199,"./invariant":212,"_process":73}],105:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule MobileSafariClickEventPlugin
 * @typechecks static-only
 */

"use strict";

var EventConstants = require("./EventConstants");

var emptyFunction = require("./emptyFunction");

var topLevelTypes = EventConstants.topLevelTypes;

/**
 * Mobile Safari does not fire properly bubble click events on non-interactive
 * elements, which means delegated click listeners do not fire. The workaround
 * for this bug involves attaching an empty click listener on the target node.
 *
 * This particular plugin works around the bug by attaching an empty click
 * listener on `touchstart` (which does fire on every element).
 */
var MobileSafariClickEventPlugin = {

  eventTypes: null,

  /**
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function(
      topLevelType,
      topLevelTarget,
      topLevelTargetID,
      nativeEvent) {
    if (topLevelType === topLevelTypes.topTouchStart) {
      var target = nativeEvent.target;
      if (target && !target.onclick) {
        target.onclick = emptyFunction;
      }
    }
  }

};

module.exports = MobileSafariClickEventPlugin;

},{"./EventConstants":94,"./emptyFunction":194}],106:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule PooledClass
 */

"use strict";

var invariant = require("./invariant");

/**
 * Static poolers. Several custom versions for each potential number of
 * arguments. A completely generic pooler is easy to implement, but would
 * require accessing the `arguments` object. In each of these, `this` refers to
 * the Class itself, not an instance. If any others are needed, simply add them
 * here, or in their own files.
 */
var oneArgumentPooler = function(copyFieldsFrom) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, copyFieldsFrom);
    return instance;
  } else {
    return new Klass(copyFieldsFrom);
  }
};

var twoArgumentPooler = function(a1, a2) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2);
    return instance;
  } else {
    return new Klass(a1, a2);
  }
};

var threeArgumentPooler = function(a1, a2, a3) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3);
    return instance;
  } else {
    return new Klass(a1, a2, a3);
  }
};

var fiveArgumentPooler = function(a1, a2, a3, a4, a5) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4, a5);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4, a5);
  }
};

var standardReleaser = function(instance) {
  var Klass = this;
  ("production" !== process.env.NODE_ENV ? invariant(
    instance instanceof Klass,
    'Trying to release an instance into a pool of a different type.'
  ) : invariant(instance instanceof Klass));
  if (instance.destructor) {
    instance.destructor();
  }
  if (Klass.instancePool.length < Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
};

var DEFAULT_POOL_SIZE = 10;
var DEFAULT_POOLER = oneArgumentPooler;

/**
 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
 * itself (statically) not adding any prototypical fields. Any CopyConstructor
 * you give this may have a `poolSize` property, and will look for a
 * prototypical `destructor` on instances (optional).
 *
 * @param {Function} CopyConstructor Constructor that can be used to reset.
 * @param {Function} pooler Customizable pooler.
 */
var addPoolingTo = function(CopyConstructor, pooler) {
  var NewKlass = CopyConstructor;
  NewKlass.instancePool = [];
  NewKlass.getPooled = pooler || DEFAULT_POOLER;
  if (!NewKlass.poolSize) {
    NewKlass.poolSize = DEFAULT_POOL_SIZE;
  }
  NewKlass.release = standardReleaser;
  return NewKlass;
};

var PooledClass = {
  addPoolingTo: addPoolingTo,
  oneArgumentPooler: oneArgumentPooler,
  twoArgumentPooler: twoArgumentPooler,
  threeArgumentPooler: threeArgumentPooler,
  fiveArgumentPooler: fiveArgumentPooler
};

module.exports = PooledClass;

}).call(this,require('_process'))
},{"./invariant":212,"_process":73}],107:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule React
 */

"use strict";

var DOMPropertyOperations = require("./DOMPropertyOperations");
var EventPluginUtils = require("./EventPluginUtils");
var ReactChildren = require("./ReactChildren");
var ReactComponent = require("./ReactComponent");
var ReactCompositeComponent = require("./ReactCompositeComponent");
var ReactContext = require("./ReactContext");
var ReactCurrentOwner = require("./ReactCurrentOwner");
var ReactDescriptor = require("./ReactDescriptor");
var ReactDOM = require("./ReactDOM");
var ReactDOMComponent = require("./ReactDOMComponent");
var ReactDefaultInjection = require("./ReactDefaultInjection");
var ReactInstanceHandles = require("./ReactInstanceHandles");
var ReactMount = require("./ReactMount");
var ReactMultiChild = require("./ReactMultiChild");
var ReactPerf = require("./ReactPerf");
var ReactPropTypes = require("./ReactPropTypes");
var ReactServerRendering = require("./ReactServerRendering");
var ReactTextComponent = require("./ReactTextComponent");

var onlyChild = require("./onlyChild");

ReactDefaultInjection.inject();

var React = {
  Children: {
    map: ReactChildren.map,
    forEach: ReactChildren.forEach,
    count: ReactChildren.count,
    only: onlyChild
  },
  DOM: ReactDOM,
  PropTypes: ReactPropTypes,
  initializeTouchEvents: function(shouldUseTouch) {
    EventPluginUtils.useTouchEvents = shouldUseTouch;
  },
  createClass: ReactCompositeComponent.createClass,
  createDescriptor: function(type, props, children) {
    var args = Array.prototype.slice.call(arguments, 1);
    return type.apply(null, args);
  },
  constructAndRenderComponent: ReactMount.constructAndRenderComponent,
  constructAndRenderComponentByID: ReactMount.constructAndRenderComponentByID,
  renderComponent: ReactPerf.measure(
    'React',
    'renderComponent',
    ReactMount.renderComponent
  ),
  renderComponentToString: ReactServerRendering.renderComponentToString,
  renderComponentToStaticMarkup:
    ReactServerRendering.renderComponentToStaticMarkup,
  unmountComponentAtNode: ReactMount.unmountComponentAtNode,
  isValidClass: ReactDescriptor.isValidFactory,
  isValidComponent: ReactDescriptor.isValidDescriptor,
  withContext: ReactContext.withContext,
  __internals: {
    Component: ReactComponent,
    CurrentOwner: ReactCurrentOwner,
    DOMComponent: ReactDOMComponent,
    DOMPropertyOperations: DOMPropertyOperations,
    InstanceHandles: ReactInstanceHandles,
    Mount: ReactMount,
    MultiChild: ReactMultiChild,
    TextComponent: ReactTextComponent
  }
};

if ("production" !== process.env.NODE_ENV) {
  var ExecutionEnvironment = require("./ExecutionEnvironment");
  if (ExecutionEnvironment.canUseDOM &&
      window.top === window.self &&
      navigator.userAgent.indexOf('Chrome') > -1) {
    console.debug(
      'Download the React DevTools for a better development experience: ' +
      'http://fb.me/react-devtools'
    );

    var expectedFeatures = [
      // shims
      Array.isArray,
      Array.prototype.every,
      Array.prototype.forEach,
      Array.prototype.indexOf,
      Array.prototype.map,
      Date.now,
      Function.prototype.bind,
      Object.keys,
      String.prototype.split,
      String.prototype.trim,

      // shams
      Object.create,
      Object.freeze
    ];

    for (var i in expectedFeatures) {
      if (!expectedFeatures[i]) {
        console.error(
          'One or more ES5 shim/shams expected by React are not available: ' +
          'http://fb.me/react-warning-polyfills'
        );
        break;
      }
    }
  }
}

// Version exists only in the open-source version of React, not in Facebook's
// internal version.
React.version = '0.11.1';

module.exports = React;

}).call(this,require('_process'))
},{"./DOMPropertyOperations":90,"./EventPluginUtils":98,"./ExecutionEnvironment":100,"./ReactChildren":112,"./ReactComponent":113,"./ReactCompositeComponent":116,"./ReactContext":117,"./ReactCurrentOwner":118,"./ReactDOM":119,"./ReactDOMComponent":121,"./ReactDefaultInjection":131,"./ReactDescriptor":134,"./ReactInstanceHandles":142,"./ReactMount":145,"./ReactMultiChild":146,"./ReactPerf":149,"./ReactPropTypes":153,"./ReactServerRendering":157,"./ReactTextComponent":161,"./onlyChild":227,"_process":73}],108:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactBrowserComponentMixin
 */

"use strict";

var ReactEmptyComponent = require("./ReactEmptyComponent");
var ReactMount = require("./ReactMount");

var invariant = require("./invariant");

var ReactBrowserComponentMixin = {
  /**
   * Returns the DOM node rendered by this component.
   *
   * @return {DOMElement} The root node of this component.
   * @final
   * @protected
   */
  getDOMNode: function() {
    ("production" !== process.env.NODE_ENV ? invariant(
      this.isMounted(),
      'getDOMNode(): A component must be mounted to have a DOM node.'
    ) : invariant(this.isMounted()));
    if (ReactEmptyComponent.isNullComponentID(this._rootNodeID)) {
      return null;
    }
    return ReactMount.getNode(this._rootNodeID);
  }
};

module.exports = ReactBrowserComponentMixin;

}).call(this,require('_process'))
},{"./ReactEmptyComponent":136,"./ReactMount":145,"./invariant":212,"_process":73}],109:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactBrowserEventEmitter
 * @typechecks static-only
 */

"use strict";

var EventConstants = require("./EventConstants");
var EventPluginHub = require("./EventPluginHub");
var EventPluginRegistry = require("./EventPluginRegistry");
var ReactEventEmitterMixin = require("./ReactEventEmitterMixin");
var ViewportMetrics = require("./ViewportMetrics");

var isEventSupported = require("./isEventSupported");
var merge = require("./merge");

/**
 * Summary of `ReactBrowserEventEmitter` event handling:
 *
 *  - Top-level delegation is used to trap most native browser events. This
 *    may only occur in the main thread and is the responsibility of
 *    ReactEventListener, which is injected and can therefore support pluggable
 *    event sources. This is the only work that occurs in the main thread.
 *
 *  - We normalize and de-duplicate events to account for browser quirks. This
 *    may be done in the worker thread.
 *
 *  - Forward these native events (with the associated top-level type used to
 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
 *    to extract any synthetic events.
 *
 *  - The `EventPluginHub` will then process each event by annotating them with
 *    "dispatches", a sequence of listeners and IDs that care about that event.
 *
 *  - The `EventPluginHub` then dispatches the events.
 *
 * Overview of React and the event system:
 *
 * +------------+    .
 * |    DOM     |    .
 * +------------+    .
 *       |           .
 *       v           .
 * +------------+    .
 * | ReactEvent |    .
 * |  Listener  |    .
 * +------------+    .                         +-----------+
 *       |           .               +--------+|SimpleEvent|
 *       |           .               |         |Plugin     |
 * +-----|------+    .               v         +-----------+
 * |     |      |    .    +--------------+                    +------------+
 * |     +-----------.--->|EventPluginHub|                    |    Event   |
 * |            |    .    |              |     +-----------+  | Propagators|
 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
 * |            |    .    |              |     +-----------+  |  utilities |
 * |     +-----------.--->|              |                    +------------+
 * |     |      |    .    +--------------+
 * +-----|------+    .                ^        +-----------+
 *       |           .                |        |Enter/Leave|
 *       +           .                +-------+|Plugin     |
 * +-------------+   .                         +-----------+
 * | application |   .
 * |-------------|   .
 * |             |   .
 * |             |   .
 * +-------------+   .
 *                   .
 *    React Core     .  General Purpose Event Plugin System
 */

var alreadyListeningTo = {};
var isMonitoringScrollValue = false;
var reactTopListenersCounter = 0;

// For events like 'submit' which don't consistently bubble (which we trap at a
// lower node than `document`), binding at `document` would cause duplicate
// events so we don't include them here
var topEventMapping = {
  topBlur: 'blur',
  topChange: 'change',
  topClick: 'click',
  topCompositionEnd: 'compositionend',
  topCompositionStart: 'compositionstart',
  topCompositionUpdate: 'compositionupdate',
  topContextMenu: 'contextmenu',
  topCopy: 'copy',
  topCut: 'cut',
  topDoubleClick: 'dblclick',
  topDrag: 'drag',
  topDragEnd: 'dragend',
  topDragEnter: 'dragenter',
  topDragExit: 'dragexit',
  topDragLeave: 'dragleave',
  topDragOver: 'dragover',
  topDragStart: 'dragstart',
  topDrop: 'drop',
  topFocus: 'focus',
  topInput: 'input',
  topKeyDown: 'keydown',
  topKeyPress: 'keypress',
  topKeyUp: 'keyup',
  topMouseDown: 'mousedown',
  topMouseMove: 'mousemove',
  topMouseOut: 'mouseout',
  topMouseOver: 'mouseover',
  topMouseUp: 'mouseup',
  topPaste: 'paste',
  topScroll: 'scroll',
  topSelectionChange: 'selectionchange',
  topTextInput: 'textInput',
  topTouchCancel: 'touchcancel',
  topTouchEnd: 'touchend',
  topTouchMove: 'touchmove',
  topTouchStart: 'touchstart',
  topWheel: 'wheel'
};

/**
 * To ensure no conflicts with other potential React instances on the page
 */
var topListenersIDKey = "_reactListenersID" + String(Math.random()).slice(2);

function getListeningForDocument(mountAt) {
  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
  // directly.
  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
    mountAt[topListenersIDKey] = reactTopListenersCounter++;
    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
  }
  return alreadyListeningTo[mountAt[topListenersIDKey]];
}

/**
 * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For
 * example:
 *
 *   ReactBrowserEventEmitter.putListener('myID', 'onClick', myFunction);
 *
 * This would allocate a "registration" of `('onClick', myFunction)` on 'myID'.
 *
 * @internal
 */
var ReactBrowserEventEmitter = merge(ReactEventEmitterMixin, {

  /**
   * Injectable event backend
   */
  ReactEventListener: null,

  injection: {
    /**
     * @param {object} ReactEventListener
     */
    injectReactEventListener: function(ReactEventListener) {
      ReactEventListener.setHandleTopLevel(
        ReactBrowserEventEmitter.handleTopLevel
      );
      ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
    }
  },

  /**
   * Sets whether or not any created callbacks should be enabled.
   *
   * @param {boolean} enabled True if callbacks should be enabled.
   */
  setEnabled: function(enabled) {
    if (ReactBrowserEventEmitter.ReactEventListener) {
      ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
    }
  },

  /**
   * @return {boolean} True if callbacks are enabled.
   */
  isEnabled: function() {
    return !!(
      ReactBrowserEventEmitter.ReactEventListener &&
      ReactBrowserEventEmitter.ReactEventListener.isEnabled()
    );
  },

  /**
   * We listen for bubbled touch events on the document object.
   *
   * Firefox v8.01 (and possibly others) exhibited strange behavior when
   * mounting `onmousemove` events at some node that was not the document
   * element. The symptoms were that if your mouse is not moving over something
   * contained within that mount point (for example on the background) the
   * top-level listeners for `onmousemove` won't be called. However, if you
   * register the `mousemove` on the document object, then it will of course
   * catch all `mousemove`s. This along with iOS quirks, justifies restricting
   * top-level listeners to the document object only, at least for these
   * movement types of events and possibly all events.
   *
   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
   *
   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
   * they bubble to document.
   *
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @param {object} contentDocumentHandle Document which owns the container
   */
  listenTo: function(registrationName, contentDocumentHandle) {
    var mountAt = contentDocumentHandle;
    var isListening = getListeningForDocument(mountAt);
    var dependencies = EventPluginRegistry.
      registrationNameDependencies[registrationName];

    var topLevelTypes = EventConstants.topLevelTypes;
    for (var i = 0, l = dependencies.length; i < l; i++) {
      var dependency = dependencies[i];
      if (!(
            isListening.hasOwnProperty(dependency) &&
            isListening[dependency]
          )) {
        if (dependency === topLevelTypes.topWheel) {
          if (isEventSupported('wheel')) {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(
              topLevelTypes.topWheel,
              'wheel',
              mountAt
            );
          } else if (isEventSupported('mousewheel')) {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(
              topLevelTypes.topWheel,
              'mousewheel',
              mountAt
            );
          } else {
            // Firefox needs to capture a different mouse scroll event.
            // @see http://www.quirksmode.org/dom/events/tests/scroll.html
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(
              topLevelTypes.topWheel,
              'DOMMouseScroll',
              mountAt
            );
          }
        } else if (dependency === topLevelTypes.topScroll) {

          if (isEventSupported('scroll', true)) {
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(
              topLevelTypes.topScroll,
              'scroll',
              mountAt
            );
          } else {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(
              topLevelTypes.topScroll,
              'scroll',
              ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE
            );
          }
        } else if (dependency === topLevelTypes.topFocus ||
            dependency === topLevelTypes.topBlur) {

          if (isEventSupported('focus', true)) {
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(
              topLevelTypes.topFocus,
              'focus',
              mountAt
            );
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(
              topLevelTypes.topBlur,
              'blur',
              mountAt
            );
          } else if (isEventSupported('focusin')) {
            // IE has `focusin` and `focusout` events which bubble.
            // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(
              topLevelTypes.topFocus,
              'focusin',
              mountAt
            );
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(
              topLevelTypes.topBlur,
              'focusout',
              mountAt
            );
          }

          // to make sure blur and focus event listeners are only attached once
          isListening[topLevelTypes.topBlur] = true;
          isListening[topLevelTypes.topFocus] = true;
        } else if (topEventMapping.hasOwnProperty(dependency)) {
          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(
            dependency,
            topEventMapping[dependency],
            mountAt
          );
        }

        isListening[dependency] = true;
      }
    }
  },

  trapBubbledEvent: function(topLevelType, handlerBaseName, handle) {
    return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(
      topLevelType,
      handlerBaseName,
      handle
    );
  },

  trapCapturedEvent: function(topLevelType, handlerBaseName, handle) {
    return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(
      topLevelType,
      handlerBaseName,
      handle
    );
  },

  /**
   * Listens to window scroll and resize events. We cache scroll values so that
   * application code can access them without triggering reflows.
   *
   * NOTE: Scroll events do not bubble.
   *
   * @see http://www.quirksmode.org/dom/events/scroll.html
   */
  ensureScrollValueMonitoring: function(){
    if (!isMonitoringScrollValue) {
      var refresh = ViewportMetrics.refreshScrollValues;
      ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
      isMonitoringScrollValue = true;
    }
  },

  eventNameDispatchConfigs: EventPluginHub.eventNameDispatchConfigs,

  registrationNameModules: EventPluginHub.registrationNameModules,

  putListener: EventPluginHub.putListener,

  getListener: EventPluginHub.getListener,

  deleteListener: EventPluginHub.deleteListener,

  deleteAllListeners: EventPluginHub.deleteAllListeners

});

module.exports = ReactBrowserEventEmitter;

},{"./EventConstants":94,"./EventPluginHub":96,"./EventPluginRegistry":97,"./ReactEventEmitterMixin":138,"./ViewportMetrics":183,"./isEventSupported":213,"./merge":222}],110:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @typechecks
 * @providesModule ReactCSSTransitionGroup
 */

"use strict";

var React = require("./React");

var ReactTransitionGroup = require("./ReactTransitionGroup");
var ReactCSSTransitionGroupChild = require("./ReactCSSTransitionGroupChild");

var ReactCSSTransitionGroup = React.createClass({
  displayName: 'ReactCSSTransitionGroup',

  propTypes: {
    transitionName: React.PropTypes.string.isRequired,
    transitionEnter: React.PropTypes.bool,
    transitionLeave: React.PropTypes.bool
  },

  getDefaultProps: function() {
    return {
      transitionEnter: true,
      transitionLeave: true
    };
  },

  _wrapChild: function(child) {
    // We need to provide this childFactory so that
    // ReactCSSTransitionGroupChild can receive updates to name, enter, and
    // leave while it is leaving.
    return ReactCSSTransitionGroupChild(
      {
        name: this.props.transitionName,
        enter: this.props.transitionEnter,
        leave: this.props.transitionLeave
      },
      child
    );
  },

  render: function() {
    return this.transferPropsTo(
      ReactTransitionGroup(
        {childFactory: this._wrapChild},
        this.props.children
      )
    );
  }
});

module.exports = ReactCSSTransitionGroup;

},{"./React":107,"./ReactCSSTransitionGroupChild":111,"./ReactTransitionGroup":164}],111:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @typechecks
 * @providesModule ReactCSSTransitionGroupChild
 */

"use strict";

var React = require("./React");

var CSSCore = require("./CSSCore");
var ReactTransitionEvents = require("./ReactTransitionEvents");

var onlyChild = require("./onlyChild");

// We don't remove the element from the DOM until we receive an animationend or
// transitionend event. If the user screws up and forgets to add an animation
// their node will be stuck in the DOM forever, so we detect if an animation
// does not start and if it doesn't, we just call the end listener immediately.
var TICK = 17;
var NO_EVENT_TIMEOUT = 5000;

var noEventListener = null;


if ("production" !== process.env.NODE_ENV) {
  noEventListener = function() {
    console.warn(
      'transition(): tried to perform an animation without ' +
      'an animationend or transitionend event after timeout (' +
      NO_EVENT_TIMEOUT + 'ms). You should either disable this ' +
      'transition in JS or add a CSS animation/transition.'
    );
  };
}

var ReactCSSTransitionGroupChild = React.createClass({
  displayName: 'ReactCSSTransitionGroupChild',

  transition: function(animationType, finishCallback) {
    var node = this.getDOMNode();
    var className = this.props.name + '-' + animationType;
    var activeClassName = className + '-active';
    var noEventTimeout = null;

    var endListener = function() {
      if ("production" !== process.env.NODE_ENV) {
        clearTimeout(noEventTimeout);
      }

      CSSCore.removeClass(node, className);
      CSSCore.removeClass(node, activeClassName);

      ReactTransitionEvents.removeEndEventListener(node, endListener);

      // Usually this optional callback is used for informing an owner of
      // a leave animation and telling it to remove the child.
      finishCallback && finishCallback();
    };

    ReactTransitionEvents.addEndEventListener(node, endListener);

    CSSCore.addClass(node, className);

    // Need to do this to actually trigger a transition.
    this.queueClass(activeClassName);

    if ("production" !== process.env.NODE_ENV) {
      noEventTimeout = setTimeout(noEventListener, NO_EVENT_TIMEOUT);
    }
  },

  queueClass: function(className) {
    this.classNameQueue.push(className);

    if (!this.timeout) {
      this.timeout = setTimeout(this.flushClassNameQueue, TICK);
    }
  },

  flushClassNameQueue: function() {
    if (this.isMounted()) {
      this.classNameQueue.forEach(
        CSSCore.addClass.bind(CSSCore, this.getDOMNode())
      );
    }
    this.classNameQueue.length = 0;
    this.timeout = null;
  },

  componentWillMount: function() {
    this.classNameQueue = [];
  },

  componentWillUnmount: function() {
    if (this.timeout) {
      clearTimeout(this.timeout);
    }
  },

  componentWillEnter: function(done) {
    if (this.props.enter) {
      this.transition('enter', done);
    } else {
      done();
    }
  },

  componentWillLeave: function(done) {
    if (this.props.leave) {
      this.transition('leave', done);
    } else {
      done();
    }
  },

  render: function() {
    return onlyChild(this.props.children);
  }
});

module.exports = ReactCSSTransitionGroupChild;

}).call(this,require('_process'))
},{"./CSSCore":81,"./React":107,"./ReactTransitionEvents":163,"./onlyChild":227,"_process":73}],112:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactChildren
 */

"use strict";

var PooledClass = require("./PooledClass");

var traverseAllChildren = require("./traverseAllChildren");
var warning = require("./warning");

var twoArgumentPooler = PooledClass.twoArgumentPooler;
var threeArgumentPooler = PooledClass.threeArgumentPooler;

/**
 * PooledClass representing the bookkeeping associated with performing a child
 * traversal. Allows avoiding binding callbacks.
 *
 * @constructor ForEachBookKeeping
 * @param {!function} forEachFunction Function to perform traversal with.
 * @param {?*} forEachContext Context to perform context with.
 */
function ForEachBookKeeping(forEachFunction, forEachContext) {
  this.forEachFunction = forEachFunction;
  this.forEachContext = forEachContext;
}
PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);

function forEachSingleChild(traverseContext, child, name, i) {
  var forEachBookKeeping = traverseContext;
  forEachBookKeeping.forEachFunction.call(
    forEachBookKeeping.forEachContext, child, i);
}

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc.
 * @param {*} forEachContext Context for forEachContext.
 */
function forEachChildren(children, forEachFunc, forEachContext) {
  if (children == null) {
    return children;
  }

  var traverseContext =
    ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
  traverseAllChildren(children, forEachSingleChild, traverseContext);
  ForEachBookKeeping.release(traverseContext);
}

/**
 * PooledClass representing the bookkeeping associated with performing a child
 * mapping. Allows avoiding binding callbacks.
 *
 * @constructor MapBookKeeping
 * @param {!*} mapResult Object containing the ordered map of results.
 * @param {!function} mapFunction Function to perform mapping with.
 * @param {?*} mapContext Context to perform mapping with.
 */
function MapBookKeeping(mapResult, mapFunction, mapContext) {
  this.mapResult = mapResult;
  this.mapFunction = mapFunction;
  this.mapContext = mapContext;
}
PooledClass.addPoolingTo(MapBookKeeping, threeArgumentPooler);

function mapSingleChildIntoContext(traverseContext, child, name, i) {
  var mapBookKeeping = traverseContext;
  var mapResult = mapBookKeeping.mapResult;

  var keyUnique = !mapResult.hasOwnProperty(name);
  ("production" !== process.env.NODE_ENV ? warning(
    keyUnique,
    'ReactChildren.map(...): Encountered two children with the same key, ' +
    '`%s`. Child keys must be unique; when two children share a key, only ' +
    'the first child will be used.',
    name
  ) : null);

  if (keyUnique) {
    var mappedChild =
      mapBookKeeping.mapFunction.call(mapBookKeeping.mapContext, child, i);
    mapResult[name] = mappedChild;
  }
}

/**
 * Maps children that are typically specified as `props.children`.
 *
 * The provided mapFunction(child, key, index) will be called for each
 * leaf child.
 *
 * TODO: This may likely break any calls to `ReactChildren.map` that were
 * previously relying on the fact that we guarded against null children.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} mapFunction.
 * @param {*} mapContext Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }

  var mapResult = {};
  var traverseContext = MapBookKeeping.getPooled(mapResult, func, context);
  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
  MapBookKeeping.release(traverseContext);
  return mapResult;
}

function forEachSingleChildDummy(traverseContext, child, name, i) {
  return null;
}

/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */
function countChildren(children, context) {
  return traverseAllChildren(children, forEachSingleChildDummy, null);
}

var ReactChildren = {
  forEach: forEachChildren,
  map: mapChildren,
  count: countChildren
};

module.exports = ReactChildren;

}).call(this,require('_process'))
},{"./PooledClass":106,"./traverseAllChildren":234,"./warning":236,"_process":73}],113:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactComponent
 */

"use strict";

var ReactDescriptor = require("./ReactDescriptor");
var ReactOwner = require("./ReactOwner");
var ReactUpdates = require("./ReactUpdates");

var invariant = require("./invariant");
var keyMirror = require("./keyMirror");
var merge = require("./merge");

/**
 * Every React component is in one of these life cycles.
 */
var ComponentLifeCycle = keyMirror({
  /**
   * Mounted components have a DOM node representation and are capable of
   * receiving new props.
   */
  MOUNTED: null,
  /**
   * Unmounted components are inactive and cannot receive new props.
   */
  UNMOUNTED: null
});

var injected = false;

/**
 * Optionally injectable environment dependent cleanup hook. (server vs.
 * browser etc). Example: A browser system caches DOM nodes based on component
 * ID and must remove that cache entry when this instance is unmounted.
 *
 * @private
 */
var unmountIDFromEnvironment = null;

/**
 * The "image" of a component tree, is the platform specific (typically
 * serialized) data that represents a tree of lower level UI building blocks.
 * On the web, this "image" is HTML markup which describes a construction of
 * low level `div` and `span` nodes. Other platforms may have different
 * encoding of this "image". This must be injected.
 *
 * @private
 */
var mountImageIntoNode = null;

/**
 * Components are the basic units of composition in React.
 *
 * Every component accepts a set of keyed input parameters known as "props" that
 * are initialized by the constructor. Once a component is mounted, the props
 * can be mutated using `setProps` or `replaceProps`.
 *
 * Every component is capable of the following operations:
 *
 *   `mountComponent`
 *     Initializes the component, renders markup, and registers event listeners.
 *
 *   `receiveComponent`
 *     Updates the rendered DOM nodes to match the given component.
 *
 *   `unmountComponent`
 *     Releases any resources allocated by this component.
 *
 * Components can also be "owned" by other components. Being owned by another
 * component means being constructed by that component. This is different from
 * being the child of a component, which means having a DOM representation that
 * is a child of the DOM representation of that component.
 *
 * @class ReactComponent
 */
var ReactComponent = {

  injection: {
    injectEnvironment: function(ReactComponentEnvironment) {
      ("production" !== process.env.NODE_ENV ? invariant(
        !injected,
        'ReactComponent: injectEnvironment() can only be called once.'
      ) : invariant(!injected));
      mountImageIntoNode = ReactComponentEnvironment.mountImageIntoNode;
      unmountIDFromEnvironment =
        ReactComponentEnvironment.unmountIDFromEnvironment;
      ReactComponent.BackendIDOperations =
        ReactComponentEnvironment.BackendIDOperations;
      injected = true;
    }
  },

  /**
   * @internal
   */
  LifeCycle: ComponentLifeCycle,

  /**
   * Injected module that provides ability to mutate individual properties.
   * Injected into the base class because many different subclasses need access
   * to this.
   *
   * @internal
   */
  BackendIDOperations: null,

  /**
   * Base functionality for every ReactComponent constructor. Mixed into the
   * `ReactComponent` prototype, but exposed statically for easy access.
   *
   * @lends {ReactComponent.prototype}
   */
  Mixin: {

    /**
     * Checks whether or not this component is mounted.
     *
     * @return {boolean} True if mounted, false otherwise.
     * @final
     * @protected
     */
    isMounted: function() {
      return this._lifeCycleState === ComponentLifeCycle.MOUNTED;
    },

    /**
     * Sets a subset of the props.
     *
     * @param {object} partialProps Subset of the next props.
     * @param {?function} callback Called after props are updated.
     * @final
     * @public
     */
    setProps: function(partialProps, callback) {
      // Merge with the pending descriptor if it exists, otherwise with existing
      // descriptor props.
      var descriptor = this._pendingDescriptor || this._descriptor;
      this.replaceProps(
        merge(descriptor.props, partialProps),
        callback
      );
    },

    /**
     * Replaces all of the props.
     *
     * @param {object} props New props.
     * @param {?function} callback Called after props are updated.
     * @final
     * @public
     */
    replaceProps: function(props, callback) {
      ("production" !== process.env.NODE_ENV ? invariant(
        this.isMounted(),
        'replaceProps(...): Can only update a mounted component.'
      ) : invariant(this.isMounted()));
      ("production" !== process.env.NODE_ENV ? invariant(
        this._mountDepth === 0,
        'replaceProps(...): You called `setProps` or `replaceProps` on a ' +
        'component with a parent. This is an anti-pattern since props will ' +
        'get reactively updated when rendered. Instead, change the owner\'s ' +
        '`render` method to pass the correct value as props to the component ' +
        'where it is created.'
      ) : invariant(this._mountDepth === 0));
      // This is a deoptimized path. We optimize for always having a descriptor.
      // This creates an extra internal descriptor.
      this._pendingDescriptor = ReactDescriptor.cloneAndReplaceProps(
        this._pendingDescriptor || this._descriptor,
        props
      );
      ReactUpdates.enqueueUpdate(this, callback);
    },

    /**
     * Schedule a partial update to the props. Only used for internal testing.
     *
     * @param {object} partialProps Subset of the next props.
     * @param {?function} callback Called after props are updated.
     * @final
     * @internal
     */
    _setPropsInternal: function(partialProps, callback) {
      // This is a deoptimized path. We optimize for always having a descriptor.
      // This creates an extra internal descriptor.
      var descriptor = this._pendingDescriptor || this._descriptor;
      this._pendingDescriptor = ReactDescriptor.cloneAndReplaceProps(
        descriptor,
        merge(descriptor.props, partialProps)
      );
      ReactUpdates.enqueueUpdate(this, callback);
    },

    /**
     * Base constructor for all React components.
     *
     * Subclasses that override this method should make sure to invoke
     * `ReactComponent.Mixin.construct.call(this, ...)`.
     *
     * @param {ReactDescriptor} descriptor
     * @internal
     */
    construct: function(descriptor) {
      // This is the public exposed props object after it has been processed
      // with default props. The descriptor's props represents the true internal
      // state of the props.
      this.props = descriptor.props;
      // Record the component responsible for creating this component.
      // This is accessible through the descriptor but we maintain an extra
      // field for compatibility with devtools and as a way to make an
      // incremental update. TODO: Consider deprecating this field.
      this._owner = descriptor._owner;

      // All components start unmounted.
      this._lifeCycleState = ComponentLifeCycle.UNMOUNTED;

      // See ReactUpdates.
      this._pendingCallbacks = null;

      // We keep the old descriptor and a reference to the pending descriptor
      // to track updates.
      this._descriptor = descriptor;
      this._pendingDescriptor = null;
    },

    /**
     * Initializes the component, renders markup, and registers event listeners.
     *
     * NOTE: This does not insert any nodes into the DOM.
     *
     * Subclasses that override this method should make sure to invoke
     * `ReactComponent.Mixin.mountComponent.call(this, ...)`.
     *
     * @param {string} rootID DOM ID of the root node.
     * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
     * @param {number} mountDepth number of components in the owner hierarchy.
     * @return {?string} Rendered markup to be inserted into the DOM.
     * @internal
     */
    mountComponent: function(rootID, transaction, mountDepth) {
      ("production" !== process.env.NODE_ENV ? invariant(
        !this.isMounted(),
        'mountComponent(%s, ...): Can only mount an unmounted component. ' +
        'Make sure to avoid storing components between renders or reusing a ' +
        'single component instance in multiple places.',
        rootID
      ) : invariant(!this.isMounted()));
      var props = this._descriptor.props;
      if (props.ref != null) {
        var owner = this._descriptor._owner;
        ReactOwner.addComponentAsRefTo(this, props.ref, owner);
      }
      this._rootNodeID = rootID;
      this._lifeCycleState = ComponentLifeCycle.MOUNTED;
      this._mountDepth = mountDepth;
      // Effectively: return '';
    },

    /**
     * Releases any resources allocated by `mountComponent`.
     *
     * NOTE: This does not remove any nodes from the DOM.
     *
     * Subclasses that override this method should make sure to invoke
     * `ReactComponent.Mixin.unmountComponent.call(this)`.
     *
     * @internal
     */
    unmountComponent: function() {
      ("production" !== process.env.NODE_ENV ? invariant(
        this.isMounted(),
        'unmountComponent(): Can only unmount a mounted component.'
      ) : invariant(this.isMounted()));
      var props = this.props;
      if (props.ref != null) {
        ReactOwner.removeComponentAsRefFrom(this, props.ref, this._owner);
      }
      unmountIDFromEnvironment(this._rootNodeID);
      this._rootNodeID = null;
      this._lifeCycleState = ComponentLifeCycle.UNMOUNTED;
    },

    /**
     * Given a new instance of this component, updates the rendered DOM nodes
     * as if that instance was rendered instead.
     *
     * Subclasses that override this method should make sure to invoke
     * `ReactComponent.Mixin.receiveComponent.call(this, ...)`.
     *
     * @param {object} nextComponent Next set of properties.
     * @param {ReactReconcileTransaction} transaction
     * @internal
     */
    receiveComponent: function(nextDescriptor, transaction) {
      ("production" !== process.env.NODE_ENV ? invariant(
        this.isMounted(),
        'receiveComponent(...): Can only update a mounted component.'
      ) : invariant(this.isMounted()));
      this._pendingDescriptor = nextDescriptor;
      this.performUpdateIfNecessary(transaction);
    },

    /**
     * If `_pendingDescriptor` is set, update the component.
     *
     * @param {ReactReconcileTransaction} transaction
     * @internal
     */
    performUpdateIfNecessary: function(transaction) {
      if (this._pendingDescriptor == null) {
        return;
      }
      var prevDescriptor = this._descriptor;
      var nextDescriptor = this._pendingDescriptor;
      this._descriptor = nextDescriptor;
      this.props = nextDescriptor.props;
      this._owner = nextDescriptor._owner;
      this._pendingDescriptor = null;
      this.updateComponent(transaction, prevDescriptor);
    },

    /**
     * Updates the component's currently mounted representation.
     *
     * @param {ReactReconcileTransaction} transaction
     * @param {object} prevDescriptor
     * @internal
     */
    updateComponent: function(transaction, prevDescriptor) {
      var nextDescriptor = this._descriptor;

      // If either the owner or a `ref` has changed, make sure the newest owner
      // has stored a reference to `this`, and the previous owner (if different)
      // has forgotten the reference to `this`. We use the descriptor instead
      // of the public this.props because the post processing cannot determine
      // a ref. The ref conceptually lives on the descriptor.

      // TODO: Should this even be possible? The owner cannot change because
      // it's forbidden by shouldUpdateReactComponent. The ref can change
      // if you swap the keys of but not the refs. Reconsider where this check
      // is made. It probably belongs where the key checking and
      // instantiateReactComponent is done.

      if (nextDescriptor._owner !== prevDescriptor._owner ||
          nextDescriptor.props.ref !== prevDescriptor.props.ref) {
        if (prevDescriptor.props.ref != null) {
          ReactOwner.removeComponentAsRefFrom(
            this, prevDescriptor.props.ref, prevDescriptor._owner
          );
        }
        // Correct, even if the owner is the same, and only the ref has changed.
        if (nextDescriptor.props.ref != null) {
          ReactOwner.addComponentAsRefTo(
            this,
            nextDescriptor.props.ref,
            nextDescriptor._owner
          );
        }
      }
    },

    /**
     * Mounts this component and inserts it into the DOM.
     *
     * @param {string} rootID DOM ID of the root node.
     * @param {DOMElement} container DOM element to mount into.
     * @param {boolean} shouldReuseMarkup If true, do not insert markup
     * @final
     * @internal
     * @see {ReactMount.renderComponent}
     */
    mountComponentIntoNode: function(rootID, container, shouldReuseMarkup) {
      var transaction = ReactUpdates.ReactReconcileTransaction.getPooled();
      transaction.perform(
        this._mountComponentIntoNode,
        this,
        rootID,
        container,
        transaction,
        shouldReuseMarkup
      );
      ReactUpdates.ReactReconcileTransaction.release(transaction);
    },

    /**
     * @param {string} rootID DOM ID of the root node.
     * @param {DOMElement} container DOM element to mount into.
     * @param {ReactReconcileTransaction} transaction
     * @param {boolean} shouldReuseMarkup If true, do not insert markup
     * @final
     * @private
     */
    _mountComponentIntoNode: function(
        rootID,
        container,
        transaction,
        shouldReuseMarkup) {
      var markup = this.mountComponent(rootID, transaction, 0);
      mountImageIntoNode(markup, container, shouldReuseMarkup);
    },

    /**
     * Checks if this component is owned by the supplied `owner` component.
     *
     * @param {ReactComponent} owner Component to check.
     * @return {boolean} True if `owners` owns this component.
     * @final
     * @internal
     */
    isOwnedBy: function(owner) {
      return this._owner === owner;
    },

    /**
     * Gets another component, that shares the same owner as this one, by ref.
     *
     * @param {string} ref of a sibling Component.
     * @return {?ReactComponent} the actual sibling Component.
     * @final
     * @internal
     */
    getSiblingByRef: function(ref) {
      var owner = this._owner;
      if (!owner || !owner.refs) {
        return null;
      }
      return owner.refs[ref];
    }
  }
};

module.exports = ReactComponent;

}).call(this,require('_process'))
},{"./ReactDescriptor":134,"./ReactOwner":148,"./ReactUpdates":165,"./invariant":212,"./keyMirror":218,"./merge":222,"_process":73}],114:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactComponentBrowserEnvironment
 */

/*jslint evil: true */

"use strict";

var ReactDOMIDOperations = require("./ReactDOMIDOperations");
var ReactMarkupChecksum = require("./ReactMarkupChecksum");
var ReactMount = require("./ReactMount");
var ReactPerf = require("./ReactPerf");
var ReactReconcileTransaction = require("./ReactReconcileTransaction");

var getReactRootElementInContainer = require("./getReactRootElementInContainer");
var invariant = require("./invariant");
var setInnerHTML = require("./setInnerHTML");


var ELEMENT_NODE_TYPE = 1;
var DOC_NODE_TYPE = 9;


/**
 * Abstracts away all functionality of `ReactComponent` requires knowledge of
 * the browser context.
 */
var ReactComponentBrowserEnvironment = {
  ReactReconcileTransaction: ReactReconcileTransaction,

  BackendIDOperations: ReactDOMIDOperations,

  /**
   * If a particular environment requires that some resources be cleaned up,
   * specify this in the injected Mixin. In the DOM, we would likely want to
   * purge any cached node ID lookups.
   *
   * @private
   */
  unmountIDFromEnvironment: function(rootNodeID) {
    ReactMount.purgeID(rootNodeID);
  },

  /**
   * @param {string} markup Markup string to place into the DOM Element.
   * @param {DOMElement} container DOM Element to insert markup into.
   * @param {boolean} shouldReuseMarkup Should reuse the existing markup in the
   * container if possible.
   */
  mountImageIntoNode: ReactPerf.measure(
    'ReactComponentBrowserEnvironment',
    'mountImageIntoNode',
    function(markup, container, shouldReuseMarkup) {
      ("production" !== process.env.NODE_ENV ? invariant(
        container && (
          container.nodeType === ELEMENT_NODE_TYPE ||
            container.nodeType === DOC_NODE_TYPE
        ),
        'mountComponentIntoNode(...): Target container is not valid.'
      ) : invariant(container && (
        container.nodeType === ELEMENT_NODE_TYPE ||
          container.nodeType === DOC_NODE_TYPE
      )));

      if (shouldReuseMarkup) {
        if (ReactMarkupChecksum.canReuseMarkup(
          markup,
          getReactRootElementInContainer(container))) {
          return;
        } else {
          ("production" !== process.env.NODE_ENV ? invariant(
            container.nodeType !== DOC_NODE_TYPE,
            'You\'re trying to render a component to the document using ' +
            'server rendering but the checksum was invalid. This usually ' +
            'means you rendered a different component type or props on ' +
            'the client from the one on the server, or your render() ' +
            'methods are impure. React cannot handle this case due to ' +
            'cross-browser quirks by rendering at the document root. You ' +
            'should look for environment dependent code in your components ' +
            'and ensure the props are the same client and server side.'
          ) : invariant(container.nodeType !== DOC_NODE_TYPE));

          if ("production" !== process.env.NODE_ENV) {
            console.warn(
              'React attempted to use reuse markup in a container but the ' +
              'checksum was invalid. This generally means that you are ' +
              'using server rendering and the markup generated on the ' +
              'server was not what the client was expecting. React injected ' +
              'new markup to compensate which works but you have lost many ' +
              'of the benefits of server rendering. Instead, figure out ' +
              'why the markup being generated is different on the client ' +
              'or server.'
            );
          }
        }
      }

      ("production" !== process.env.NODE_ENV ? invariant(
        container.nodeType !== DOC_NODE_TYPE,
        'You\'re trying to render a component to the document but ' +
          'you didn\'t use server rendering. We can\'t do this ' +
          'without using server rendering due to cross-browser quirks. ' +
          'See renderComponentToString() for server rendering.'
      ) : invariant(container.nodeType !== DOC_NODE_TYPE));

      setInnerHTML(container, markup);
    }
  )
};

module.exports = ReactComponentBrowserEnvironment;

}).call(this,require('_process'))
},{"./ReactDOMIDOperations":123,"./ReactMarkupChecksum":144,"./ReactMount":145,"./ReactPerf":149,"./ReactReconcileTransaction":155,"./getReactRootElementInContainer":206,"./invariant":212,"./setInnerHTML":230,"_process":73}],115:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
* @providesModule ReactComponentWithPureRenderMixin
*/

"use strict";

var shallowEqual = require("./shallowEqual");

/**
 * If your React component's render function is "pure", e.g. it will render the
 * same result given the same props and state, provide this Mixin for a
 * considerable performance boost.
 *
 * Most React components have pure render functions.
 *
 * Example:
 *
 *   var ReactComponentWithPureRenderMixin =
 *     require('ReactComponentWithPureRenderMixin');
 *   React.createClass({
 *     mixins: [ReactComponentWithPureRenderMixin],
 *
 *     render: function() {
 *       return <div className={this.props.className}>foo</div>;
 *     }
 *   });
 *
 * Note: This only checks shallow equality for props and state. If these contain
 * complex data structures this mixin may have false-negatives for deeper
 * differences. Only mixin to components which have simple props and state, or
 * use `forceUpdate()` when you know deep data structures have changed.
 */
var ReactComponentWithPureRenderMixin = {
  shouldComponentUpdate: function(nextProps, nextState) {
    return !shallowEqual(this.props, nextProps) ||
           !shallowEqual(this.state, nextState);
  }
};

module.exports = ReactComponentWithPureRenderMixin;

},{"./shallowEqual":231}],116:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactCompositeComponent
 */

"use strict";

var ReactComponent = require("./ReactComponent");
var ReactContext = require("./ReactContext");
var ReactCurrentOwner = require("./ReactCurrentOwner");
var ReactDescriptor = require("./ReactDescriptor");
var ReactDescriptorValidator = require("./ReactDescriptorValidator");
var ReactEmptyComponent = require("./ReactEmptyComponent");
var ReactErrorUtils = require("./ReactErrorUtils");
var ReactOwner = require("./ReactOwner");
var ReactPerf = require("./ReactPerf");
var ReactPropTransferer = require("./ReactPropTransferer");
var ReactPropTypeLocations = require("./ReactPropTypeLocations");
var ReactPropTypeLocationNames = require("./ReactPropTypeLocationNames");
var ReactUpdates = require("./ReactUpdates");

var instantiateReactComponent = require("./instantiateReactComponent");
var invariant = require("./invariant");
var keyMirror = require("./keyMirror");
var merge = require("./merge");
var mixInto = require("./mixInto");
var monitorCodeUse = require("./monitorCodeUse");
var mapObject = require("./mapObject");
var shouldUpdateReactComponent = require("./shouldUpdateReactComponent");
var warning = require("./warning");

/**
 * Policies that describe methods in `ReactCompositeComponentInterface`.
 */
var SpecPolicy = keyMirror({
  /**
   * These methods may be defined only once by the class specification or mixin.
   */
  DEFINE_ONCE: null,
  /**
   * These methods may be defined by both the class specification and mixins.
   * Subsequent definitions will be chained. These methods must return void.
   */
  DEFINE_MANY: null,
  /**
   * These methods are overriding the base ReactCompositeComponent class.
   */
  OVERRIDE_BASE: null,
  /**
   * These methods are similar to DEFINE_MANY, except we assume they return
   * objects. We try to merge the keys of the return values of all the mixed in
   * functions. If there is a key conflict we throw.
   */
  DEFINE_MANY_MERGED: null
});


var injectedMixins = [];

/**
 * Composite components are higher-level components that compose other composite
 * or native components.
 *
 * To create a new type of `ReactCompositeComponent`, pass a specification of
 * your new class to `React.createClass`. The only requirement of your class
 * specification is that you implement a `render` method.
 *
 *   var MyComponent = React.createClass({
 *     render: function() {
 *       return <div>Hello World</div>;
 *     }
 *   });
 *
 * The class specification supports a specific protocol of methods that have
 * special meaning (e.g. `render`). See `ReactCompositeComponentInterface` for
 * more the comprehensive protocol. Any other properties and methods in the
 * class specification will available on the prototype.
 *
 * @interface ReactCompositeComponentInterface
 * @internal
 */
var ReactCompositeComponentInterface = {

  /**
   * An array of Mixin objects to include when defining your component.
   *
   * @type {array}
   * @optional
   */
  mixins: SpecPolicy.DEFINE_MANY,

  /**
   * An object containing properties and methods that should be defined on
   * the component's constructor instead of its prototype (static methods).
   *
   * @type {object}
   * @optional
   */
  statics: SpecPolicy.DEFINE_MANY,

  /**
   * Definition of prop types for this component.
   *
   * @type {object}
   * @optional
   */
  propTypes: SpecPolicy.DEFINE_MANY,

  /**
   * Definition of context types for this component.
   *
   * @type {object}
   * @optional
   */
  contextTypes: SpecPolicy.DEFINE_MANY,

  /**
   * Definition of context types this component sets for its children.
   *
   * @type {object}
   * @optional
   */
  childContextTypes: SpecPolicy.DEFINE_MANY,

  // ==== Definition methods ====

  /**
   * Invoked when the component is mounted. Values in the mapping will be set on
   * `this.props` if that prop is not specified (i.e. using an `in` check).
   *
   * This method is invoked before `getInitialState` and therefore cannot rely
   * on `this.state` or use `this.setState`.
   *
   * @return {object}
   * @optional
   */
  getDefaultProps: SpecPolicy.DEFINE_MANY_MERGED,

  /**
   * Invoked once before the component is mounted. The return value will be used
   * as the initial value of `this.state`.
   *
   *   getInitialState: function() {
   *     return {
   *       isOn: false,
   *       fooBaz: new BazFoo()
   *     }
   *   }
   *
   * @return {object}
   * @optional
   */
  getInitialState: SpecPolicy.DEFINE_MANY_MERGED,

  /**
   * @return {object}
   * @optional
   */
  getChildContext: SpecPolicy.DEFINE_MANY_MERGED,

  /**
   * Uses props from `this.props` and state from `this.state` to render the
   * structure of the component.
   *
   * No guarantees are made about when or how often this method is invoked, so
   * it must not have side effects.
   *
   *   render: function() {
   *     var name = this.props.name;
   *     return <div>Hello, {name}!</div>;
   *   }
   *
   * @return {ReactComponent}
   * @nosideeffects
   * @required
   */
  render: SpecPolicy.DEFINE_ONCE,



  // ==== Delegate methods ====

  /**
   * Invoked when the component is initially created and about to be mounted.
   * This may have side effects, but any external subscriptions or data created
   * by this method must be cleaned up in `componentWillUnmount`.
   *
   * @optional
   */
  componentWillMount: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked when the component has been mounted and has a DOM representation.
   * However, there is no guarantee that the DOM node is in the document.
   *
   * Use this as an opportunity to operate on the DOM when the component has
   * been mounted (initialized and rendered) for the first time.
   *
   * @param {DOMElement} rootNode DOM element representing the component.
   * @optional
   */
  componentDidMount: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked before the component receives new props.
   *
   * Use this as an opportunity to react to a prop transition by updating the
   * state using `this.setState`. Current props are accessed via `this.props`.
   *
   *   componentWillReceiveProps: function(nextProps, nextContext) {
   *     this.setState({
   *       likesIncreasing: nextProps.likeCount > this.props.likeCount
   *     });
   *   }
   *
   * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
   * transition may cause a state change, but the opposite is not true. If you
   * need it, you are probably looking for `componentWillUpdate`.
   *
   * @param {object} nextProps
   * @optional
   */
  componentWillReceiveProps: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked while deciding if the component should be updated as a result of
   * receiving new props, state and/or context.
   *
   * Use this as an opportunity to `return false` when you're certain that the
   * transition to the new props/state/context will not require a component
   * update.
   *
   *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
   *     return !equal(nextProps, this.props) ||
   *       !equal(nextState, this.state) ||
   *       !equal(nextContext, this.context);
   *   }
   *
   * @param {object} nextProps
   * @param {?object} nextState
   * @param {?object} nextContext
   * @return {boolean} True if the component should update.
   * @optional
   */
  shouldComponentUpdate: SpecPolicy.DEFINE_ONCE,

  /**
   * Invoked when the component is about to update due to a transition from
   * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
   * and `nextContext`.
   *
   * Use this as an opportunity to perform preparation before an update occurs.
   *
   * NOTE: You **cannot** use `this.setState()` in this method.
   *
   * @param {object} nextProps
   * @param {?object} nextState
   * @param {?object} nextContext
   * @param {ReactReconcileTransaction} transaction
   * @optional
   */
  componentWillUpdate: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked when the component's DOM representation has been updated.
   *
   * Use this as an opportunity to operate on the DOM when the component has
   * been updated.
   *
   * @param {object} prevProps
   * @param {?object} prevState
   * @param {?object} prevContext
   * @param {DOMElement} rootNode DOM element representing the component.
   * @optional
   */
  componentDidUpdate: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked when the component is about to be removed from its parent and have
   * its DOM representation destroyed.
   *
   * Use this as an opportunity to deallocate any external resources.
   *
   * NOTE: There is no `componentDidUnmount` since your component will have been
   * destroyed by that point.
   *
   * @optional
   */
  componentWillUnmount: SpecPolicy.DEFINE_MANY,



  // ==== Advanced methods ====

  /**
   * Updates the component's currently mounted DOM representation.
   *
   * By default, this implements React's rendering and reconciliation algorithm.
   * Sophisticated clients may wish to override this.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   * @overridable
   */
  updateComponent: SpecPolicy.OVERRIDE_BASE

};

/**
 * Mapping from class specification keys to special processing functions.
 *
 * Although these are declared like instance properties in the specification
 * when defining classes using `React.createClass`, they are actually static
 * and are accessible on the constructor instead of the prototype. Despite
 * being static, they must be defined outside of the "statics" key under
 * which all other static methods are defined.
 */
var RESERVED_SPEC_KEYS = {
  displayName: function(Constructor, displayName) {
    Constructor.displayName = displayName;
  },
  mixins: function(Constructor, mixins) {
    if (mixins) {
      for (var i = 0; i < mixins.length; i++) {
        mixSpecIntoComponent(Constructor, mixins[i]);
      }
    }
  },
  childContextTypes: function(Constructor, childContextTypes) {
    validateTypeDef(
      Constructor,
      childContextTypes,
      ReactPropTypeLocations.childContext
    );
    Constructor.childContextTypes = merge(
      Constructor.childContextTypes,
      childContextTypes
    );
  },
  contextTypes: function(Constructor, contextTypes) {
    validateTypeDef(
      Constructor,
      contextTypes,
      ReactPropTypeLocations.context
    );
    Constructor.contextTypes = merge(Constructor.contextTypes, contextTypes);
  },
  /**
   * Special case getDefaultProps which should move into statics but requires
   * automatic merging.
   */
  getDefaultProps: function(Constructor, getDefaultProps) {
    if (Constructor.getDefaultProps) {
      Constructor.getDefaultProps = createMergedResultFunction(
        Constructor.getDefaultProps,
        getDefaultProps
      );
    } else {
      Constructor.getDefaultProps = getDefaultProps;
    }
  },
  propTypes: function(Constructor, propTypes) {
    validateTypeDef(
      Constructor,
      propTypes,
      ReactPropTypeLocations.prop
    );
    Constructor.propTypes = merge(Constructor.propTypes, propTypes);
  },
  statics: function(Constructor, statics) {
    mixStaticSpecIntoComponent(Constructor, statics);
  }
};

function getDeclarationErrorAddendum(component) {
  var owner = component._owner || null;
  if (owner && owner.constructor && owner.constructor.displayName) {
    return ' Check the render method of `' + owner.constructor.displayName +
      '`.';
  }
  return '';
}

function validateTypeDef(Constructor, typeDef, location) {
  for (var propName in typeDef) {
    if (typeDef.hasOwnProperty(propName)) {
      ("production" !== process.env.NODE_ENV ? invariant(
        typeof typeDef[propName] == 'function',
        '%s: %s type `%s` is invalid; it must be a function, usually from ' +
        'React.PropTypes.',
        Constructor.displayName || 'ReactCompositeComponent',
        ReactPropTypeLocationNames[location],
        propName
      ) : invariant(typeof typeDef[propName] == 'function'));
    }
  }
}

function validateMethodOverride(proto, name) {
  var specPolicy = ReactCompositeComponentInterface.hasOwnProperty(name) ?
    ReactCompositeComponentInterface[name] :
    null;

  // Disallow overriding of base class methods unless explicitly allowed.
  if (ReactCompositeComponentMixin.hasOwnProperty(name)) {
    ("production" !== process.env.NODE_ENV ? invariant(
      specPolicy === SpecPolicy.OVERRIDE_BASE,
      'ReactCompositeComponentInterface: You are attempting to override ' +
      '`%s` from your class specification. Ensure that your method names ' +
      'do not overlap with React methods.',
      name
    ) : invariant(specPolicy === SpecPolicy.OVERRIDE_BASE));
  }

  // Disallow defining methods more than once unless explicitly allowed.
  if (proto.hasOwnProperty(name)) {
    ("production" !== process.env.NODE_ENV ? invariant(
      specPolicy === SpecPolicy.DEFINE_MANY ||
      specPolicy === SpecPolicy.DEFINE_MANY_MERGED,
      'ReactCompositeComponentInterface: You are attempting to define ' +
      '`%s` on your component more than once. This conflict may be due ' +
      'to a mixin.',
      name
    ) : invariant(specPolicy === SpecPolicy.DEFINE_MANY ||
    specPolicy === SpecPolicy.DEFINE_MANY_MERGED));
  }
}

function validateLifeCycleOnReplaceState(instance) {
  var compositeLifeCycleState = instance._compositeLifeCycleState;
  ("production" !== process.env.NODE_ENV ? invariant(
    instance.isMounted() ||
      compositeLifeCycleState === CompositeLifeCycle.MOUNTING,
    'replaceState(...): Can only update a mounted or mounting component.'
  ) : invariant(instance.isMounted() ||
    compositeLifeCycleState === CompositeLifeCycle.MOUNTING));
  ("production" !== process.env.NODE_ENV ? invariant(compositeLifeCycleState !== CompositeLifeCycle.RECEIVING_STATE,
    'replaceState(...): Cannot update during an existing state transition ' +
    '(such as within `render`). This could potentially cause an infinite ' +
    'loop so it is forbidden.'
  ) : invariant(compositeLifeCycleState !== CompositeLifeCycle.RECEIVING_STATE));
  ("production" !== process.env.NODE_ENV ? invariant(compositeLifeCycleState !== CompositeLifeCycle.UNMOUNTING,
    'replaceState(...): Cannot update while unmounting component. This ' +
    'usually means you called setState() on an unmounted component.'
  ) : invariant(compositeLifeCycleState !== CompositeLifeCycle.UNMOUNTING));
}

/**
 * Custom version of `mixInto` which handles policy validation and reserved
 * specification keys when building `ReactCompositeComponent` classses.
 */
function mixSpecIntoComponent(Constructor, spec) {
  ("production" !== process.env.NODE_ENV ? invariant(
    !ReactDescriptor.isValidFactory(spec),
    'ReactCompositeComponent: You\'re attempting to ' +
    'use a component class as a mixin. Instead, just use a regular object.'
  ) : invariant(!ReactDescriptor.isValidFactory(spec)));
  ("production" !== process.env.NODE_ENV ? invariant(
    !ReactDescriptor.isValidDescriptor(spec),
    'ReactCompositeComponent: You\'re attempting to ' +
    'use a component as a mixin. Instead, just use a regular object.'
  ) : invariant(!ReactDescriptor.isValidDescriptor(spec)));

  var proto = Constructor.prototype;
  for (var name in spec) {
    var property = spec[name];
    if (!spec.hasOwnProperty(name)) {
      continue;
    }

    validateMethodOverride(proto, name);

    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
      RESERVED_SPEC_KEYS[name](Constructor, property);
    } else {
      // Setup methods on prototype:
      // The following member methods should not be automatically bound:
      // 1. Expected ReactCompositeComponent methods (in the "interface").
      // 2. Overridden methods (that were mixed in).
      var isCompositeComponentMethod =
        ReactCompositeComponentInterface.hasOwnProperty(name);
      var isAlreadyDefined = proto.hasOwnProperty(name);
      var markedDontBind = property && property.__reactDontBind;
      var isFunction = typeof property === 'function';
      var shouldAutoBind =
        isFunction &&
        !isCompositeComponentMethod &&
        !isAlreadyDefined &&
        !markedDontBind;

      if (shouldAutoBind) {
        if (!proto.__reactAutoBindMap) {
          proto.__reactAutoBindMap = {};
        }
        proto.__reactAutoBindMap[name] = property;
        proto[name] = property;
      } else {
        if (isAlreadyDefined) {
          var specPolicy = ReactCompositeComponentInterface[name];

          // These cases should already be caught by validateMethodOverride
          ("production" !== process.env.NODE_ENV ? invariant(
            isCompositeComponentMethod && (
              specPolicy === SpecPolicy.DEFINE_MANY_MERGED ||
              specPolicy === SpecPolicy.DEFINE_MANY
            ),
            'ReactCompositeComponent: Unexpected spec policy %s for key %s ' +
            'when mixing in component specs.',
            specPolicy,
            name
          ) : invariant(isCompositeComponentMethod && (
            specPolicy === SpecPolicy.DEFINE_MANY_MERGED ||
            specPolicy === SpecPolicy.DEFINE_MANY
          )));

          // For methods which are defined more than once, call the existing
          // methods before calling the new property, merging if appropriate.
          if (specPolicy === SpecPolicy.DEFINE_MANY_MERGED) {
            proto[name] = createMergedResultFunction(proto[name], property);
          } else if (specPolicy === SpecPolicy.DEFINE_MANY) {
            proto[name] = createChainedFunction(proto[name], property);
          }
        } else {
          proto[name] = property;
          if ("production" !== process.env.NODE_ENV) {
            // Add verbose displayName to the function, which helps when looking
            // at profiling tools.
            if (typeof property === 'function' && spec.displayName) {
              proto[name].displayName = spec.displayName + '_' + name;
            }
          }
        }
      }
    }
  }
}

function mixStaticSpecIntoComponent(Constructor, statics) {
  if (!statics) {
    return;
  }
  for (var name in statics) {
    var property = statics[name];
    if (!statics.hasOwnProperty(name)) {
      continue;
    }

    var isInherited = name in Constructor;
    var result = property;
    if (isInherited) {
      var existingProperty = Constructor[name];
      var existingType = typeof existingProperty;
      var propertyType = typeof property;
      ("production" !== process.env.NODE_ENV ? invariant(
        existingType === 'function' && propertyType === 'function',
        'ReactCompositeComponent: You are attempting to define ' +
        '`%s` on your component more than once, but that is only supported ' +
        'for functions, which are chained together. This conflict may be ' +
        'due to a mixin.',
        name
      ) : invariant(existingType === 'function' && propertyType === 'function'));
      result = createChainedFunction(existingProperty, property);
    }
    Constructor[name] = result;
  }
}

/**
 * Merge two objects, but throw if both contain the same key.
 *
 * @param {object} one The first object, which is mutated.
 * @param {object} two The second object
 * @return {object} one after it has been mutated to contain everything in two.
 */
function mergeObjectsWithNoDuplicateKeys(one, two) {
  ("production" !== process.env.NODE_ENV ? invariant(
    one && two && typeof one === 'object' && typeof two === 'object',
    'mergeObjectsWithNoDuplicateKeys(): Cannot merge non-objects'
  ) : invariant(one && two && typeof one === 'object' && typeof two === 'object'));

  mapObject(two, function(value, key) {
    ("production" !== process.env.NODE_ENV ? invariant(
      one[key] === undefined,
      'mergeObjectsWithNoDuplicateKeys(): ' +
      'Tried to merge two objects with the same key: %s',
      key
    ) : invariant(one[key] === undefined));
    one[key] = value;
  });
  return one;
}

/**
 * Creates a function that invokes two functions and merges their return values.
 *
 * @param {function} one Function to invoke first.
 * @param {function} two Function to invoke second.
 * @return {function} Function that invokes the two argument functions.
 * @private
 */
function createMergedResultFunction(one, two) {
  return function mergedResult() {
    var a = one.apply(this, arguments);
    var b = two.apply(this, arguments);
    if (a == null) {
      return b;
    } else if (b == null) {
      return a;
    }
    return mergeObjectsWithNoDuplicateKeys(a, b);
  };
}

/**
 * Creates a function that invokes two functions and ignores their return vales.
 *
 * @param {function} one Function to invoke first.
 * @param {function} two Function to invoke second.
 * @return {function} Function that invokes the two argument functions.
 * @private
 */
function createChainedFunction(one, two) {
  return function chainedFunction() {
    one.apply(this, arguments);
    two.apply(this, arguments);
  };
}

/**
 * `ReactCompositeComponent` maintains an auxiliary life cycle state in
 * `this._compositeLifeCycleState` (which can be null).
 *
 * This is different from the life cycle state maintained by `ReactComponent` in
 * `this._lifeCycleState`. The following diagram shows how the states overlap in
 * time. There are times when the CompositeLifeCycle is null - at those times it
 * is only meaningful to look at ComponentLifeCycle alone.
 *
 * Top Row: ReactComponent.ComponentLifeCycle
 * Low Row: ReactComponent.CompositeLifeCycle
 *
 * +-------+------------------------------------------------------+--------+
 * |  UN   |                    MOUNTED                           |   UN   |
 * |MOUNTED|                                                      | MOUNTED|
 * +-------+------------------------------------------------------+--------+
 * |       ^--------+   +------+   +------+   +------+   +--------^        |
 * |       |        |   |      |   |      |   |      |   |        |        |
 * |    0--|MOUNTING|-0-|RECEIV|-0-|RECEIV|-0-|RECEIV|-0-|   UN   |--->0   |
 * |       |        |   |PROPS |   | PROPS|   | STATE|   |MOUNTING|        |
 * |       |        |   |      |   |      |   |      |   |        |        |
 * |       |        |   |      |   |      |   |      |   |        |        |
 * |       +--------+   +------+   +------+   +------+   +--------+        |
 * |       |                                                      |        |
 * +-------+------------------------------------------------------+--------+
 */
var CompositeLifeCycle = keyMirror({
  /**
   * Components in the process of being mounted respond to state changes
   * differently.
   */
  MOUNTING: null,
  /**
   * Components in the process of being unmounted are guarded against state
   * changes.
   */
  UNMOUNTING: null,
  /**
   * Components that are mounted and receiving new props respond to state
   * changes differently.
   */
  RECEIVING_PROPS: null,
  /**
   * Components that are mounted and receiving new state are guarded against
   * additional state changes.
   */
  RECEIVING_STATE: null
});

/**
 * @lends {ReactCompositeComponent.prototype}
 */
var ReactCompositeComponentMixin = {

  /**
   * Base constructor for all composite component.
   *
   * @param {ReactDescriptor} descriptor
   * @final
   * @internal
   */
  construct: function(descriptor) {
    // Children can be either an array or more than one argument
    ReactComponent.Mixin.construct.apply(this, arguments);
    ReactOwner.Mixin.construct.apply(this, arguments);

    this.state = null;
    this._pendingState = null;

    // This is the public post-processed context. The real context and pending
    // context lives on the descriptor.
    this.context = null;

    this._compositeLifeCycleState = null;
  },

  /**
   * Checks whether or not this composite component is mounted.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function() {
    return ReactComponent.Mixin.isMounted.call(this) &&
      this._compositeLifeCycleState !== CompositeLifeCycle.MOUNTING;
  },

  /**
   * Initializes the component, renders markup, and registers event listeners.
   *
   * @param {string} rootID DOM ID of the root node.
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {number} mountDepth number of components in the owner hierarchy
   * @return {?string} Rendered markup to be inserted into the DOM.
   * @final
   * @internal
   */
  mountComponent: ReactPerf.measure(
    'ReactCompositeComponent',
    'mountComponent',
    function(rootID, transaction, mountDepth) {
      ReactComponent.Mixin.mountComponent.call(
        this,
        rootID,
        transaction,
        mountDepth
      );
      this._compositeLifeCycleState = CompositeLifeCycle.MOUNTING;

      if (this.__reactAutoBindMap) {
        this._bindAutoBindMethods();
      }

      this.context = this._processContext(this._descriptor._context);
      this.props = this._processProps(this.props);

      this.state = this.getInitialState ? this.getInitialState() : null;
      ("production" !== process.env.NODE_ENV ? invariant(
        typeof this.state === 'object' && !Array.isArray(this.state),
        '%s.getInitialState(): must return an object or null',
        this.constructor.displayName || 'ReactCompositeComponent'
      ) : invariant(typeof this.state === 'object' && !Array.isArray(this.state)));

      this._pendingState = null;
      this._pendingForceUpdate = false;

      if (this.componentWillMount) {
        this.componentWillMount();
        // When mounting, calls to `setState` by `componentWillMount` will set
        // `this._pendingState` without triggering a re-render.
        if (this._pendingState) {
          this.state = this._pendingState;
          this._pendingState = null;
        }
      }

      this._renderedComponent = instantiateReactComponent(
        this._renderValidatedComponent()
      );

      // Done with mounting, `setState` will now trigger UI changes.
      this._compositeLifeCycleState = null;
      var markup = this._renderedComponent.mountComponent(
        rootID,
        transaction,
        mountDepth + 1
      );
      if (this.componentDidMount) {
        transaction.getReactMountReady().enqueue(this.componentDidMount, this);
      }
      return markup;
    }
  ),

  /**
   * Releases any resources allocated by `mountComponent`.
   *
   * @final
   * @internal
   */
  unmountComponent: function() {
    this._compositeLifeCycleState = CompositeLifeCycle.UNMOUNTING;
    if (this.componentWillUnmount) {
      this.componentWillUnmount();
    }
    this._compositeLifeCycleState = null;

    this._renderedComponent.unmountComponent();
    this._renderedComponent = null;

    ReactComponent.Mixin.unmountComponent.call(this);

    // Some existing components rely on this.props even after they've been
    // destroyed (in event handlers).
    // TODO: this.props = null;
    // TODO: this.state = null;
  },

  /**
   * Sets a subset of the state. Always use this or `replaceState` to mutate
   * state. You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * There is no guarantee that calls to `setState` will run synchronously,
   * as they may eventually be batched together.  You can provide an optional
   * callback that will be executed when the call to setState is actually
   * completed.
   *
   * @param {object} partialState Next partial state to be merged with state.
   * @param {?function} callback Called after state is updated.
   * @final
   * @protected
   */
  setState: function(partialState, callback) {
    ("production" !== process.env.NODE_ENV ? invariant(
      typeof partialState === 'object' || partialState == null,
      'setState(...): takes an object of state variables to update.'
    ) : invariant(typeof partialState === 'object' || partialState == null));
    if ("production" !== process.env.NODE_ENV){
      ("production" !== process.env.NODE_ENV ? warning(
        partialState != null,
        'setState(...): You passed an undefined or null state object; ' +
        'instead, use forceUpdate().'
      ) : null);
    }
    // Merge with `_pendingState` if it exists, otherwise with existing state.
    this.replaceState(
      merge(this._pendingState || this.state, partialState),
      callback
    );
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {object} completeState Next state.
   * @param {?function} callback Called after state is updated.
   * @final
   * @protected
   */
  replaceState: function(completeState, callback) {
    validateLifeCycleOnReplaceState(this);
    this._pendingState = completeState;
    if (this._compositeLifeCycleState !== CompositeLifeCycle.MOUNTING) {
      // If we're in a componentWillMount handler, don't enqueue a rerender
      // because ReactUpdates assumes we're in a browser context (which is wrong
      // for server rendering) and we're about to do a render anyway.
      // TODO: The callback here is ignored when setState is called from
      // componentWillMount. Either fix it or disallow doing so completely in
      // favor of getInitialState.
      ReactUpdates.enqueueUpdate(this, callback);
    }
  },

  /**
   * Filters the context object to only contain keys specified in
   * `contextTypes`, and asserts that they are valid.
   *
   * @param {object} context
   * @return {?object}
   * @private
   */
  _processContext: function(context) {
    var maskedContext = null;
    var contextTypes = this.constructor.contextTypes;
    if (contextTypes) {
      maskedContext = {};
      for (var contextName in contextTypes) {
        maskedContext[contextName] = context[contextName];
      }
      if ("production" !== process.env.NODE_ENV) {
        this._checkPropTypes(
          contextTypes,
          maskedContext,
          ReactPropTypeLocations.context
        );
      }
    }
    return maskedContext;
  },

  /**
   * @param {object} currentContext
   * @return {object}
   * @private
   */
  _processChildContext: function(currentContext) {
    var childContext = this.getChildContext && this.getChildContext();
    var displayName = this.constructor.displayName || 'ReactCompositeComponent';
    if (childContext) {
      ("production" !== process.env.NODE_ENV ? invariant(
        typeof this.constructor.childContextTypes === 'object',
        '%s.getChildContext(): childContextTypes must be defined in order to ' +
        'use getChildContext().',
        displayName
      ) : invariant(typeof this.constructor.childContextTypes === 'object'));
      if ("production" !== process.env.NODE_ENV) {
        this._checkPropTypes(
          this.constructor.childContextTypes,
          childContext,
          ReactPropTypeLocations.childContext
        );
      }
      for (var name in childContext) {
        ("production" !== process.env.NODE_ENV ? invariant(
          name in this.constructor.childContextTypes,
          '%s.getChildContext(): key "%s" is not defined in childContextTypes.',
          displayName,
          name
        ) : invariant(name in this.constructor.childContextTypes));
      }
      return merge(currentContext, childContext);
    }
    return currentContext;
  },

  /**
   * Processes props by setting default values for unspecified props and
   * asserting that the props are valid. Does not mutate its argument; returns
   * a new props object with defaults merged in.
   *
   * @param {object} newProps
   * @return {object}
   * @private
   */
  _processProps: function(newProps) {
    var defaultProps = this.constructor.defaultProps;
    var props;
    if (defaultProps) {
      props = merge(newProps);
      for (var propName in defaultProps) {
        if (typeof props[propName] === 'undefined') {
          props[propName] = defaultProps[propName];
        }
      }
    } else {
      props = newProps;
    }
    if ("production" !== process.env.NODE_ENV) {
      var propTypes = this.constructor.propTypes;
      if (propTypes) {
        this._checkPropTypes(propTypes, props, ReactPropTypeLocations.prop);
      }
    }
    return props;
  },

  /**
   * Assert that the props are valid
   *
   * @param {object} propTypes Map of prop name to a ReactPropType
   * @param {object} props
   * @param {string} location e.g. "prop", "context", "child context"
   * @private
   */
  _checkPropTypes: function(propTypes, props, location) {
    // TODO: Stop validating prop types here and only use the descriptor
    // validation.
    var componentName = this.constructor.displayName;
    for (var propName in propTypes) {
      if (propTypes.hasOwnProperty(propName)) {
        var error =
          propTypes[propName](props, propName, componentName, location);
        if (error instanceof Error) {
          // We may want to extend this logic for similar errors in
          // renderComponent calls, so I'm abstracting it away into
          // a function to minimize refactoring in the future
          var addendum = getDeclarationErrorAddendum(this);
          ("production" !== process.env.NODE_ENV ? warning(false, error.message + addendum) : null);
        }
      }
    }
  },

  /**
   * If any of `_pendingDescriptor`, `_pendingState`, or `_pendingForceUpdate`
   * is set, update the component.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  performUpdateIfNecessary: function(transaction) {
    var compositeLifeCycleState = this._compositeLifeCycleState;
    // Do not trigger a state transition if we are in the middle of mounting or
    // receiving props because both of those will already be doing this.
    if (compositeLifeCycleState === CompositeLifeCycle.MOUNTING ||
        compositeLifeCycleState === CompositeLifeCycle.RECEIVING_PROPS) {
      return;
    }

    if (this._pendingDescriptor == null &&
        this._pendingState == null &&
        !this._pendingForceUpdate) {
      return;
    }

    var nextContext = this.context;
    var nextProps = this.props;
    var nextDescriptor = this._descriptor;
    if (this._pendingDescriptor != null) {
      nextDescriptor = this._pendingDescriptor;
      nextContext = this._processContext(nextDescriptor._context);
      nextProps = this._processProps(nextDescriptor.props);
      this._pendingDescriptor = null;

      this._compositeLifeCycleState = CompositeLifeCycle.RECEIVING_PROPS;
      if (this.componentWillReceiveProps) {
        this.componentWillReceiveProps(nextProps, nextContext);
      }
    }

    this._compositeLifeCycleState = CompositeLifeCycle.RECEIVING_STATE;

    var nextState = this._pendingState || this.state;
    this._pendingState = null;

    try {
      var shouldUpdate =
        this._pendingForceUpdate ||
        !this.shouldComponentUpdate ||
        this.shouldComponentUpdate(nextProps, nextState, nextContext);

      if ("production" !== process.env.NODE_ENV) {
        if (typeof shouldUpdate === "undefined") {
          console.warn(
            (this.constructor.displayName || 'ReactCompositeComponent') +
            '.shouldComponentUpdate(): Returned undefined instead of a ' +
            'boolean value. Make sure to return true or false.'
          );
        }
      }

      if (shouldUpdate) {
        this._pendingForceUpdate = false;
        // Will set `this.props`, `this.state` and `this.context`.
        this._performComponentUpdate(
          nextDescriptor,
          nextProps,
          nextState,
          nextContext,
          transaction
        );
      } else {
        // If it's determined that a component should not update, we still want
        // to set props and state.
        this._descriptor = nextDescriptor;
        this.props = nextProps;
        this.state = nextState;
        this.context = nextContext;

        // Owner cannot change because shouldUpdateReactComponent doesn't allow
        // it. TODO: Remove this._owner completely.
        this._owner = nextDescriptor._owner;
      }
    } finally {
      this._compositeLifeCycleState = null;
    }
  },

  /**
   * Merges new props and state, notifies delegate methods of update and
   * performs update.
   *
   * @param {ReactDescriptor} nextDescriptor Next descriptor
   * @param {object} nextProps Next public object to set as properties.
   * @param {?object} nextState Next object to set as state.
   * @param {?object} nextContext Next public object to set as context.
   * @param {ReactReconcileTransaction} transaction
   * @private
   */
  _performComponentUpdate: function(
    nextDescriptor,
    nextProps,
    nextState,
    nextContext,
    transaction
  ) {
    var prevDescriptor = this._descriptor;
    var prevProps = this.props;
    var prevState = this.state;
    var prevContext = this.context;

    if (this.componentWillUpdate) {
      this.componentWillUpdate(nextProps, nextState, nextContext);
    }

    this._descriptor = nextDescriptor;
    this.props = nextProps;
    this.state = nextState;
    this.context = nextContext;

    // Owner cannot change because shouldUpdateReactComponent doesn't allow
    // it. TODO: Remove this._owner completely.
    this._owner = nextDescriptor._owner;

    this.updateComponent(
      transaction,
      prevDescriptor
    );

    if (this.componentDidUpdate) {
      transaction.getReactMountReady().enqueue(
        this.componentDidUpdate.bind(this, prevProps, prevState, prevContext),
        this
      );
    }
  },

  receiveComponent: function(nextDescriptor, transaction) {
    if (nextDescriptor === this._descriptor &&
        nextDescriptor._owner != null) {
      // Since descriptors are immutable after the owner is rendered,
      // we can do a cheap identity compare here to determine if this is a
      // superfluous reconcile. It's possible for state to be mutable but such
      // change should trigger an update of the owner which would recreate
      // the descriptor. We explicitly check for the existence of an owner since
      // it's possible for a descriptor created outside a composite to be
      // deeply mutated and reused.
      return;
    }

    ReactComponent.Mixin.receiveComponent.call(
      this,
      nextDescriptor,
      transaction
    );
  },

  /**
   * Updates the component's currently mounted DOM representation.
   *
   * By default, this implements React's rendering and reconciliation algorithm.
   * Sophisticated clients may wish to override this.
   *
   * @param {ReactReconcileTransaction} transaction
   * @param {ReactDescriptor} prevDescriptor
   * @internal
   * @overridable
   */
  updateComponent: ReactPerf.measure(
    'ReactCompositeComponent',
    'updateComponent',
    function(transaction, prevParentDescriptor) {
      ReactComponent.Mixin.updateComponent.call(
        this,
        transaction,
        prevParentDescriptor
      );

      var prevComponentInstance = this._renderedComponent;
      var prevDescriptor = prevComponentInstance._descriptor;
      var nextDescriptor = this._renderValidatedComponent();
      if (shouldUpdateReactComponent(prevDescriptor, nextDescriptor)) {
        prevComponentInstance.receiveComponent(nextDescriptor, transaction);
      } else {
        // These two IDs are actually the same! But nothing should rely on that.
        var thisID = this._rootNodeID;
        var prevComponentID = prevComponentInstance._rootNodeID;
        prevComponentInstance.unmountComponent();
        this._renderedComponent = instantiateReactComponent(nextDescriptor);
        var nextMarkup = this._renderedComponent.mountComponent(
          thisID,
          transaction,
          this._mountDepth + 1
        );
        ReactComponent.BackendIDOperations.dangerouslyReplaceNodeWithMarkupByID(
          prevComponentID,
          nextMarkup
        );
      }
    }
  ),

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldUpdateComponent`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {?function} callback Called after update is complete.
   * @final
   * @protected
   */
  forceUpdate: function(callback) {
    var compositeLifeCycleState = this._compositeLifeCycleState;
    ("production" !== process.env.NODE_ENV ? invariant(
      this.isMounted() ||
        compositeLifeCycleState === CompositeLifeCycle.MOUNTING,
      'forceUpdate(...): Can only force an update on mounted or mounting ' +
        'components.'
    ) : invariant(this.isMounted() ||
      compositeLifeCycleState === CompositeLifeCycle.MOUNTING));
    ("production" !== process.env.NODE_ENV ? invariant(
      compositeLifeCycleState !== CompositeLifeCycle.RECEIVING_STATE &&
      compositeLifeCycleState !== CompositeLifeCycle.UNMOUNTING,
      'forceUpdate(...): Cannot force an update while unmounting component ' +
      'or during an existing state transition (such as within `render`).'
    ) : invariant(compositeLifeCycleState !== CompositeLifeCycle.RECEIVING_STATE &&
    compositeLifeCycleState !== CompositeLifeCycle.UNMOUNTING));
    this._pendingForceUpdate = true;
    ReactUpdates.enqueueUpdate(this, callback);
  },

  /**
   * @private
   */
  _renderValidatedComponent: ReactPerf.measure(
    'ReactCompositeComponent',
    '_renderValidatedComponent',
    function() {
      var renderedComponent;
      var previousContext = ReactContext.current;
      ReactContext.current = this._processChildContext(
        this._descriptor._context
      );
      ReactCurrentOwner.current = this;
      try {
        renderedComponent = this.render();
        if (renderedComponent === null || renderedComponent === false) {
          renderedComponent = ReactEmptyComponent.getEmptyComponent();
          ReactEmptyComponent.registerNullComponentID(this._rootNodeID);
        } else {
          ReactEmptyComponent.deregisterNullComponentID(this._rootNodeID);
        }
      } finally {
        ReactContext.current = previousContext;
        ReactCurrentOwner.current = null;
      }
      ("production" !== process.env.NODE_ENV ? invariant(
        ReactDescriptor.isValidDescriptor(renderedComponent),
        '%s.render(): A valid ReactComponent must be returned. You may have ' +
          'returned undefined, an array or some other invalid object.',
        this.constructor.displayName || 'ReactCompositeComponent'
      ) : invariant(ReactDescriptor.isValidDescriptor(renderedComponent)));
      return renderedComponent;
    }
  ),

  /**
   * @private
   */
  _bindAutoBindMethods: function() {
    for (var autoBindKey in this.__reactAutoBindMap) {
      if (!this.__reactAutoBindMap.hasOwnProperty(autoBindKey)) {
        continue;
      }
      var method = this.__reactAutoBindMap[autoBindKey];
      this[autoBindKey] = this._bindAutoBindMethod(ReactErrorUtils.guard(
        method,
        this.constructor.displayName + '.' + autoBindKey
      ));
    }
  },

  /**
   * Binds a method to the component.
   *
   * @param {function} method Method to be bound.
   * @private
   */
  _bindAutoBindMethod: function(method) {
    var component = this;
    var boundMethod = function() {
      return method.apply(component, arguments);
    };
    if ("production" !== process.env.NODE_ENV) {
      boundMethod.__reactBoundContext = component;
      boundMethod.__reactBoundMethod = method;
      boundMethod.__reactBoundArguments = null;
      var componentName = component.constructor.displayName;
      var _bind = boundMethod.bind;
      boundMethod.bind = function(newThis ) {var args=Array.prototype.slice.call(arguments,1);
        // User is trying to bind() an autobound method; we effectively will
        // ignore the value of "this" that the user is trying to use, so
        // let's warn.
        if (newThis !== component && newThis !== null) {
          monitorCodeUse('react_bind_warning', { component: componentName });
          console.warn(
            'bind(): React component methods may only be bound to the ' +
            'component instance. See ' + componentName
          );
        } else if (!args.length) {
          monitorCodeUse('react_bind_warning', { component: componentName });
          console.warn(
            'bind(): You are binding a component method to the component. ' +
            'React does this for you automatically in a high-performance ' +
            'way, so you can safely remove this call. See ' + componentName
          );
          return boundMethod;
        }
        var reboundMethod = _bind.apply(boundMethod, arguments);
        reboundMethod.__reactBoundContext = component;
        reboundMethod.__reactBoundMethod = method;
        reboundMethod.__reactBoundArguments = args;
        return reboundMethod;
      };
    }
    return boundMethod;
  }
};

var ReactCompositeComponentBase = function() {};
mixInto(ReactCompositeComponentBase, ReactComponent.Mixin);
mixInto(ReactCompositeComponentBase, ReactOwner.Mixin);
mixInto(ReactCompositeComponentBase, ReactPropTransferer.Mixin);
mixInto(ReactCompositeComponentBase, ReactCompositeComponentMixin);

/**
 * Module for creating composite components.
 *
 * @class ReactCompositeComponent
 * @extends ReactComponent
 * @extends ReactOwner
 * @extends ReactPropTransferer
 */
var ReactCompositeComponent = {

  LifeCycle: CompositeLifeCycle,

  Base: ReactCompositeComponentBase,

  /**
   * Creates a composite component class given a class specification.
   *
   * @param {object} spec Class specification (which must define `render`).
   * @return {function} Component constructor function.
   * @public
   */
  createClass: function(spec) {
    var Constructor = function(props, owner) {
      this.construct(props, owner);
    };
    Constructor.prototype = new ReactCompositeComponentBase();
    Constructor.prototype.constructor = Constructor;

    injectedMixins.forEach(
      mixSpecIntoComponent.bind(null, Constructor)
    );

    mixSpecIntoComponent(Constructor, spec);

    // Initialize the defaultProps property after all mixins have been merged
    if (Constructor.getDefaultProps) {
      Constructor.defaultProps = Constructor.getDefaultProps();
    }

    ("production" !== process.env.NODE_ENV ? invariant(
      Constructor.prototype.render,
      'createClass(...): Class specification must implement a `render` method.'
    ) : invariant(Constructor.prototype.render));

    if ("production" !== process.env.NODE_ENV) {
      if (Constructor.prototype.componentShouldUpdate) {
        monitorCodeUse(
          'react_component_should_update_warning',
          { component: spec.displayName }
        );
        console.warn(
          (spec.displayName || 'A component') + ' has a method called ' +
          'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' +
          'The name is phrased as a question because the function is ' +
          'expected to return a value.'
         );
      }
    }

    // Reduce time spent doing lookups by setting these on the prototype.
    for (var methodName in ReactCompositeComponentInterface) {
      if (!Constructor.prototype[methodName]) {
        Constructor.prototype[methodName] = null;
      }
    }

    var descriptorFactory = ReactDescriptor.createFactory(Constructor);

    if ("production" !== process.env.NODE_ENV) {
      return ReactDescriptorValidator.createFactory(
        descriptorFactory,
        Constructor.propTypes,
        Constructor.contextTypes
      );
    }

    return descriptorFactory;
  },

  injection: {
    injectMixin: function(mixin) {
      injectedMixins.push(mixin);
    }
  }
};

module.exports = ReactCompositeComponent;

}).call(this,require('_process'))
},{"./ReactComponent":113,"./ReactContext":117,"./ReactCurrentOwner":118,"./ReactDescriptor":134,"./ReactDescriptorValidator":135,"./ReactEmptyComponent":136,"./ReactErrorUtils":137,"./ReactOwner":148,"./ReactPerf":149,"./ReactPropTransferer":150,"./ReactPropTypeLocationNames":151,"./ReactPropTypeLocations":152,"./ReactUpdates":165,"./instantiateReactComponent":211,"./invariant":212,"./keyMirror":218,"./mapObject":220,"./merge":222,"./mixInto":225,"./monitorCodeUse":226,"./shouldUpdateReactComponent":232,"./warning":236,"_process":73}],117:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactContext
 */

"use strict";

var merge = require("./merge");

/**
 * Keeps track of the current context.
 *
 * The context is automatically passed down the component ownership hierarchy
 * and is accessible via `this.context` on ReactCompositeComponents.
 */
var ReactContext = {

  /**
   * @internal
   * @type {object}
   */
  current: {},

  /**
   * Temporarily extends the current context while executing scopedCallback.
   *
   * A typical use case might look like
   *
   *  render: function() {
   *    var children = ReactContext.withContext({foo: 'foo'} () => (
   *
   *    ));
   *    return <div>{children}</div>;
   *  }
   *
   * @param {object} newContext New context to merge into the existing context
   * @param {function} scopedCallback Callback to run with the new context
   * @return {ReactComponent|array<ReactComponent>}
   */
  withContext: function(newContext, scopedCallback) {
    var result;
    var previousContext = ReactContext.current;
    ReactContext.current = merge(previousContext, newContext);
    try {
      result = scopedCallback();
    } finally {
      ReactContext.current = previousContext;
    }
    return result;
  }

};

module.exports = ReactContext;

},{"./merge":222}],118:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactCurrentOwner
 */

"use strict";

/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 *
 * The depth indicate how many composite components are above this render level.
 */
var ReactCurrentOwner = {

  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null

};

module.exports = ReactCurrentOwner;

},{}],119:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactDOM
 * @typechecks static-only
 */

"use strict";

var ReactDescriptor = require("./ReactDescriptor");
var ReactDescriptorValidator = require("./ReactDescriptorValidator");
var ReactDOMComponent = require("./ReactDOMComponent");

var mergeInto = require("./mergeInto");
var mapObject = require("./mapObject");

/**
 * Creates a new React class that is idempotent and capable of containing other
 * React components. It accepts event listeners and DOM properties that are
 * valid according to `DOMProperty`.
 *
 *  - Event listeners: `onClick`, `onMouseDown`, etc.
 *  - DOM properties: `className`, `name`, `title`, etc.
 *
 * The `style` property functions differently from the DOM API. It accepts an
 * object mapping of style properties to values.
 *
 * @param {boolean} omitClose True if the close tag should be omitted.
 * @param {string} tag Tag name (e.g. `div`).
 * @private
 */
function createDOMComponentClass(omitClose, tag) {
  var Constructor = function(descriptor) {
    this.construct(descriptor);
  };
  Constructor.prototype = new ReactDOMComponent(tag, omitClose);
  Constructor.prototype.constructor = Constructor;
  Constructor.displayName = tag;

  var ConvenienceConstructor = ReactDescriptor.createFactory(Constructor);

  if ("production" !== process.env.NODE_ENV) {
    return ReactDescriptorValidator.createFactory(
      ConvenienceConstructor
    );
  }

  return ConvenienceConstructor;
}

/**
 * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
 * This is also accessible via `React.DOM`.
 *
 * @public
 */
var ReactDOM = mapObject({
  a: false,
  abbr: false,
  address: false,
  area: true,
  article: false,
  aside: false,
  audio: false,
  b: false,
  base: true,
  bdi: false,
  bdo: false,
  big: false,
  blockquote: false,
  body: false,
  br: true,
  button: false,
  canvas: false,
  caption: false,
  cite: false,
  code: false,
  col: true,
  colgroup: false,
  data: false,
  datalist: false,
  dd: false,
  del: false,
  details: false,
  dfn: false,
  div: false,
  dl: false,
  dt: false,
  em: false,
  embed: true,
  fieldset: false,
  figcaption: false,
  figure: false,
  footer: false,
  form: false, // NOTE: Injected, see `ReactDOMForm`.
  h1: false,
  h2: false,
  h3: false,
  h4: false,
  h5: false,
  h6: false,
  head: false,
  header: false,
  hr: true,
  html: false,
  i: false,
  iframe: false,
  img: true,
  input: true,
  ins: false,
  kbd: false,
  keygen: true,
  label: false,
  legend: false,
  li: false,
  link: true,
  main: false,
  map: false,
  mark: false,
  menu: false,
  menuitem: false, // NOTE: Close tag should be omitted, but causes problems.
  meta: true,
  meter: false,
  nav: false,
  noscript: false,
  object: false,
  ol: false,
  optgroup: false,
  option: false,
  output: false,
  p: false,
  param: true,
  pre: false,
  progress: false,
  q: false,
  rp: false,
  rt: false,
  ruby: false,
  s: false,
  samp: false,
  script: false,
  section: false,
  select: false,
  small: false,
  source: true,
  span: false,
  strong: false,
  style: false,
  sub: false,
  summary: false,
  sup: false,
  table: false,
  tbody: false,
  td: false,
  textarea: false, // NOTE: Injected, see `ReactDOMTextarea`.
  tfoot: false,
  th: false,
  thead: false,
  time: false,
  title: false,
  tr: false,
  track: true,
  u: false,
  ul: false,
  'var': false,
  video: false,
  wbr: true,

  // SVG
  circle: false,
  defs: false,
  ellipse: false,
  g: false,
  line: false,
  linearGradient: false,
  mask: false,
  path: false,
  pattern: false,
  polygon: false,
  polyline: false,
  radialGradient: false,
  rect: false,
  stop: false,
  svg: false,
  text: false,
  tspan: false
}, createDOMComponentClass);

var injection = {
  injectComponentClasses: function(componentClasses) {
    mergeInto(ReactDOM, componentClasses);
  }
};

ReactDOM.injection = injection;

module.exports = ReactDOM;

}).call(this,require('_process'))
},{"./ReactDOMComponent":121,"./ReactDescriptor":134,"./ReactDescriptorValidator":135,"./mapObject":220,"./mergeInto":224,"_process":73}],120:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactDOMButton
 */

"use strict";

var AutoFocusMixin = require("./AutoFocusMixin");
var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
var ReactCompositeComponent = require("./ReactCompositeComponent");
var ReactDOM = require("./ReactDOM");

var keyMirror = require("./keyMirror");

// Store a reference to the <button> `ReactDOMComponent`.
var button = ReactDOM.button;

var mouseListenerNames = keyMirror({
  onClick: true,
  onDoubleClick: true,
  onMouseDown: true,
  onMouseMove: true,
  onMouseUp: true,
  onClickCapture: true,
  onDoubleClickCapture: true,
  onMouseDownCapture: true,
  onMouseMoveCapture: true,
  onMouseUpCapture: true
});

/**
 * Implements a <button> native component that does not receive mouse events
 * when `disabled` is set.
 */
var ReactDOMButton = ReactCompositeComponent.createClass({
  displayName: 'ReactDOMButton',

  mixins: [AutoFocusMixin, ReactBrowserComponentMixin],

  render: function() {
    var props = {};

    // Copy the props; except the mouse listeners if we're disabled
    for (var key in this.props) {
      if (this.props.hasOwnProperty(key) &&
          (!this.props.disabled || !mouseListenerNames[key])) {
        props[key] = this.props[key];
      }
    }

    return button(props, this.props.children);
  }

});

module.exports = ReactDOMButton;

},{"./AutoFocusMixin":79,"./ReactBrowserComponentMixin":108,"./ReactCompositeComponent":116,"./ReactDOM":119,"./keyMirror":218}],121:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactDOMComponent
 * @typechecks static-only
 */

"use strict";

var CSSPropertyOperations = require("./CSSPropertyOperations");
var DOMProperty = require("./DOMProperty");
var DOMPropertyOperations = require("./DOMPropertyOperations");
var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
var ReactComponent = require("./ReactComponent");
var ReactBrowserEventEmitter = require("./ReactBrowserEventEmitter");
var ReactMount = require("./ReactMount");
var ReactMultiChild = require("./ReactMultiChild");
var ReactPerf = require("./ReactPerf");

var escapeTextForBrowser = require("./escapeTextForBrowser");
var invariant = require("./invariant");
var keyOf = require("./keyOf");
var merge = require("./merge");
var mixInto = require("./mixInto");

var deleteListener = ReactBrowserEventEmitter.deleteListener;
var listenTo = ReactBrowserEventEmitter.listenTo;
var registrationNameModules = ReactBrowserEventEmitter.registrationNameModules;

// For quickly matching children type, to test if can be treated as content.
var CONTENT_TYPES = {'string': true, 'number': true};

var STYLE = keyOf({style: null});

var ELEMENT_NODE_TYPE = 1;

/**
 * @param {?object} props
 */
function assertValidProps(props) {
  if (!props) {
    return;
  }
  // Note the use of `==` which checks for null or undefined.
  ("production" !== process.env.NODE_ENV ? invariant(
    props.children == null || props.dangerouslySetInnerHTML == null,
    'Can only set one of `children` or `props.dangerouslySetInnerHTML`.'
  ) : invariant(props.children == null || props.dangerouslySetInnerHTML == null));
  ("production" !== process.env.NODE_ENV ? invariant(
    props.style == null || typeof props.style === 'object',
    'The `style` prop expects a mapping from style properties to values, ' +
    'not a string.'
  ) : invariant(props.style == null || typeof props.style === 'object'));
}

function putListener(id, registrationName, listener, transaction) {
  var container = ReactMount.findReactContainerForID(id);
  if (container) {
    var doc = container.nodeType === ELEMENT_NODE_TYPE ?
      container.ownerDocument :
      container;
    listenTo(registrationName, doc);
  }
  transaction.getPutListenerQueue().enqueuePutListener(
    id,
    registrationName,
    listener
  );
}


/**
 * @constructor ReactDOMComponent
 * @extends ReactComponent
 * @extends ReactMultiChild
 */
function ReactDOMComponent(tag, omitClose) {
  this._tagOpen = '<' + tag;
  this._tagClose = omitClose ? '' : '</' + tag + '>';
  this.tagName = tag.toUpperCase();
}

ReactDOMComponent.Mixin = {

  /**
   * Generates root tag markup then recurses. This method has side effects and
   * is not idempotent.
   *
   * @internal
   * @param {string} rootID The root DOM ID for this node.
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {number} mountDepth number of components in the owner hierarchy
   * @return {string} The computed markup.
   */
  mountComponent: ReactPerf.measure(
    'ReactDOMComponent',
    'mountComponent',
    function(rootID, transaction, mountDepth) {
      ReactComponent.Mixin.mountComponent.call(
        this,
        rootID,
        transaction,
        mountDepth
      );
      assertValidProps(this.props);
      return (
        this._createOpenTagMarkupAndPutListeners(transaction) +
        this._createContentMarkup(transaction) +
        this._tagClose
      );
    }
  ),

  /**
   * Creates markup for the open tag and all attributes.
   *
   * This method has side effects because events get registered.
   *
   * Iterating over object properties is faster than iterating over arrays.
   * @see http://jsperf.com/obj-vs-arr-iteration
   *
   * @private
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @return {string} Markup of opening tag.
   */
  _createOpenTagMarkupAndPutListeners: function(transaction) {
    var props = this.props;
    var ret = this._tagOpen;

    for (var propKey in props) {
      if (!props.hasOwnProperty(propKey)) {
        continue;
      }
      var propValue = props[propKey];
      if (propValue == null) {
        continue;
      }
      if (registrationNameModules.hasOwnProperty(propKey)) {
        putListener(this._rootNodeID, propKey, propValue, transaction);
      } else {
        if (propKey === STYLE) {
          if (propValue) {
            propValue = props.style = merge(props.style);
          }
          propValue = CSSPropertyOperations.createMarkupForStyles(propValue);
        }
        var markup =
          DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
        if (markup) {
          ret += ' ' + markup;
        }
      }
    }

    // For static pages, no need to put React ID and checksum. Saves lots of
    // bytes.
    if (transaction.renderToStaticMarkup) {
      return ret + '>';
    }

    var markupForID = DOMPropertyOperations.createMarkupForID(this._rootNodeID);
    return ret + ' ' + markupForID + '>';
  },

  /**
   * Creates markup for the content between the tags.
   *
   * @private
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @return {string} Content markup.
   */
  _createContentMarkup: function(transaction) {
    // Intentional use of != to avoid catching zero/false.
    var innerHTML = this.props.dangerouslySetInnerHTML;
    if (innerHTML != null) {
      if (innerHTML.__html != null) {
        return innerHTML.__html;
      }
    } else {
      var contentToUse =
        CONTENT_TYPES[typeof this.props.children] ? this.props.children : null;
      var childrenToUse = contentToUse != null ? null : this.props.children;
      if (contentToUse != null) {
        return escapeTextForBrowser(contentToUse);
      } else if (childrenToUse != null) {
        var mountImages = this.mountChildren(
          childrenToUse,
          transaction
        );
        return mountImages.join('');
      }
    }
    return '';
  },

  receiveComponent: function(nextDescriptor, transaction) {
    if (nextDescriptor === this._descriptor &&
        nextDescriptor._owner != null) {
      // Since descriptors are immutable after the owner is rendered,
      // we can do a cheap identity compare here to determine if this is a
      // superfluous reconcile. It's possible for state to be mutable but such
      // change should trigger an update of the owner which would recreate
      // the descriptor. We explicitly check for the existence of an owner since
      // it's possible for a descriptor created outside a composite to be
      // deeply mutated and reused.
      return;
    }

    ReactComponent.Mixin.receiveComponent.call(
      this,
      nextDescriptor,
      transaction
    );
  },

  /**
   * Updates a native DOM component after it has already been allocated and
   * attached to the DOM. Reconciles the root DOM node, then recurses.
   *
   * @param {ReactReconcileTransaction} transaction
   * @param {ReactDescriptor} prevDescriptor
   * @internal
   * @overridable
   */
  updateComponent: ReactPerf.measure(
    'ReactDOMComponent',
    'updateComponent',
    function(transaction, prevDescriptor) {
      assertValidProps(this._descriptor.props);
      ReactComponent.Mixin.updateComponent.call(
        this,
        transaction,
        prevDescriptor
      );
      this._updateDOMProperties(prevDescriptor.props, transaction);
      this._updateDOMChildren(prevDescriptor.props, transaction);
    }
  ),

  /**
   * Reconciles the properties by detecting differences in property values and
   * updating the DOM as necessary. This function is probably the single most
   * critical path for performance optimization.
   *
   * TODO: Benchmark whether checking for changed values in memory actually
   *       improves performance (especially statically positioned elements).
   * TODO: Benchmark the effects of putting this at the top since 99% of props
   *       do not change for a given reconciliation.
   * TODO: Benchmark areas that can be improved with caching.
   *
   * @private
   * @param {object} lastProps
   * @param {ReactReconcileTransaction} transaction
   */
  _updateDOMProperties: function(lastProps, transaction) {
    var nextProps = this.props;
    var propKey;
    var styleName;
    var styleUpdates;
    for (propKey in lastProps) {
      if (nextProps.hasOwnProperty(propKey) ||
         !lastProps.hasOwnProperty(propKey)) {
        continue;
      }
      if (propKey === STYLE) {
        var lastStyle = lastProps[propKey];
        for (styleName in lastStyle) {
          if (lastStyle.hasOwnProperty(styleName)) {
            styleUpdates = styleUpdates || {};
            styleUpdates[styleName] = '';
          }
        }
      } else if (registrationNameModules.hasOwnProperty(propKey)) {
        deleteListener(this._rootNodeID, propKey);
      } else if (
          DOMProperty.isStandardName[propKey] ||
          DOMProperty.isCustomAttribute(propKey)) {
        ReactComponent.BackendIDOperations.deletePropertyByID(
          this._rootNodeID,
          propKey
        );
      }
    }
    for (propKey in nextProps) {
      var nextProp = nextProps[propKey];
      var lastProp = lastProps[propKey];
      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp) {
        continue;
      }
      if (propKey === STYLE) {
        if (nextProp) {
          nextProp = nextProps.style = merge(nextProp);
        }
        if (lastProp) {
          // Unset styles on `lastProp` but not on `nextProp`.
          for (styleName in lastProp) {
            if (lastProp.hasOwnProperty(styleName) &&
                (!nextProp || !nextProp.hasOwnProperty(styleName))) {
              styleUpdates = styleUpdates || {};
              styleUpdates[styleName] = '';
            }
          }
          // Update styles that changed since `lastProp`.
          for (styleName in nextProp) {
            if (nextProp.hasOwnProperty(styleName) &&
                lastProp[styleName] !== nextProp[styleName]) {
              styleUpdates = styleUpdates || {};
              styleUpdates[styleName] = nextProp[styleName];
            }
          }
        } else {
          // Relies on `updateStylesByID` not mutating `styleUpdates`.
          styleUpdates = nextProp;
        }
      } else if (registrationNameModules.hasOwnProperty(propKey)) {
        putListener(this._rootNodeID, propKey, nextProp, transaction);
      } else if (
          DOMProperty.isStandardName[propKey] ||
          DOMProperty.isCustomAttribute(propKey)) {
        ReactComponent.BackendIDOperations.updatePropertyByID(
          this._rootNodeID,
          propKey,
          nextProp
        );
      }
    }
    if (styleUpdates) {
      ReactComponent.BackendIDOperations.updateStylesByID(
        this._rootNodeID,
        styleUpdates
      );
    }
  },

  /**
   * Reconciles the children with the various properties that affect the
   * children content.
   *
   * @param {object} lastProps
   * @param {ReactReconcileTransaction} transaction
   */
  _updateDOMChildren: function(lastProps, transaction) {
    var nextProps = this.props;

    var lastContent =
      CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
    var nextContent =
      CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;

    var lastHtml =
      lastProps.dangerouslySetInnerHTML &&
      lastProps.dangerouslySetInnerHTML.__html;
    var nextHtml =
      nextProps.dangerouslySetInnerHTML &&
      nextProps.dangerouslySetInnerHTML.__html;

    // Note the use of `!=` which checks for null or undefined.
    var lastChildren = lastContent != null ? null : lastProps.children;
    var nextChildren = nextContent != null ? null : nextProps.children;

    // If we're switching from children to content/html or vice versa, remove
    // the old content
    var lastHasContentOrHtml = lastContent != null || lastHtml != null;
    var nextHasContentOrHtml = nextContent != null || nextHtml != null;
    if (lastChildren != null && nextChildren == null) {
      this.updateChildren(null, transaction);
    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
      this.updateTextContent('');
    }

    if (nextContent != null) {
      if (lastContent !== nextContent) {
        this.updateTextContent('' + nextContent);
      }
    } else if (nextHtml != null) {
      if (lastHtml !== nextHtml) {
        ReactComponent.BackendIDOperations.updateInnerHTMLByID(
          this._rootNodeID,
          nextHtml
        );
      }
    } else if (nextChildren != null) {
      this.updateChildren(nextChildren, transaction);
    }
  },

  /**
   * Destroys all event registrations for this instance. Does not remove from
   * the DOM. That must be done by the parent.
   *
   * @internal
   */
  unmountComponent: function() {
    this.unmountChildren();
    ReactBrowserEventEmitter.deleteAllListeners(this._rootNodeID);
    ReactComponent.Mixin.unmountComponent.call(this);
  }

};

mixInto(ReactDOMComponent, ReactComponent.Mixin);
mixInto(ReactDOMComponent, ReactDOMComponent.Mixin);
mixInto(ReactDOMComponent, ReactMultiChild.Mixin);
mixInto(ReactDOMComponent, ReactBrowserComponentMixin);

module.exports = ReactDOMComponent;

}).call(this,require('_process'))
},{"./CSSPropertyOperations":83,"./DOMProperty":89,"./DOMPropertyOperations":90,"./ReactBrowserComponentMixin":108,"./ReactBrowserEventEmitter":109,"./ReactComponent":113,"./ReactMount":145,"./ReactMultiChild":146,"./ReactPerf":149,"./escapeTextForBrowser":196,"./invariant":212,"./keyOf":219,"./merge":222,"./mixInto":225,"_process":73}],122:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactDOMForm
 */

"use strict";

var EventConstants = require("./EventConstants");
var LocalEventTrapMixin = require("./LocalEventTrapMixin");
var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
var ReactCompositeComponent = require("./ReactCompositeComponent");
var ReactDOM = require("./ReactDOM");

// Store a reference to the <form> `ReactDOMComponent`.
var form = ReactDOM.form;

/**
 * Since onSubmit doesn't bubble OR capture on the top level in IE8, we need
 * to capture it on the <form> element itself. There are lots of hacks we could
 * do to accomplish this, but the most reliable is to make <form> a
 * composite component and use `componentDidMount` to attach the event handlers.
 */
var ReactDOMForm = ReactCompositeComponent.createClass({
  displayName: 'ReactDOMForm',

  mixins: [ReactBrowserComponentMixin, LocalEventTrapMixin],

  render: function() {
    // TODO: Instead of using `ReactDOM` directly, we should use JSX. However,
    // `jshint` fails to parse JSX so in order for linting to work in the open
    // source repo, we need to just use `ReactDOM.form`.
    return this.transferPropsTo(form(null, this.props.children));
  },

  componentDidMount: function() {
    this.trapBubbledEvent(EventConstants.topLevelTypes.topReset, 'reset');
    this.trapBubbledEvent(EventConstants.topLevelTypes.topSubmit, 'submit');
  }
});

module.exports = ReactDOMForm;

},{"./EventConstants":94,"./LocalEventTrapMixin":104,"./ReactBrowserComponentMixin":108,"./ReactCompositeComponent":116,"./ReactDOM":119}],123:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactDOMIDOperations
 * @typechecks static-only
 */

/*jslint evil: true */

"use strict";

var CSSPropertyOperations = require("./CSSPropertyOperations");
var DOMChildrenOperations = require("./DOMChildrenOperations");
var DOMPropertyOperations = require("./DOMPropertyOperations");
var ReactMount = require("./ReactMount");
var ReactPerf = require("./ReactPerf");

var invariant = require("./invariant");
var setInnerHTML = require("./setInnerHTML");

/**
 * Errors for properties that should not be updated with `updatePropertyById()`.
 *
 * @type {object}
 * @private
 */
var INVALID_PROPERTY_ERRORS = {
  dangerouslySetInnerHTML:
    '`dangerouslySetInnerHTML` must be set using `updateInnerHTMLByID()`.',
  style: '`style` must be set using `updateStylesByID()`.'
};

/**
 * Operations used to process updates to DOM nodes. This is made injectable via
 * `ReactComponent.BackendIDOperations`.
 */
var ReactDOMIDOperations = {

  /**
   * Updates a DOM node with new property values. This should only be used to
   * update DOM properties in `DOMProperty`.
   *
   * @param {string} id ID of the node to update.
   * @param {string} name A valid property name, see `DOMProperty`.
   * @param {*} value New value of the property.
   * @internal
   */
  updatePropertyByID: ReactPerf.measure(
    'ReactDOMIDOperations',
    'updatePropertyByID',
    function(id, name, value) {
      var node = ReactMount.getNode(id);
      ("production" !== process.env.NODE_ENV ? invariant(
        !INVALID_PROPERTY_ERRORS.hasOwnProperty(name),
        'updatePropertyByID(...): %s',
        INVALID_PROPERTY_ERRORS[name]
      ) : invariant(!INVALID_PROPERTY_ERRORS.hasOwnProperty(name)));

      // If we're updating to null or undefined, we should remove the property
      // from the DOM node instead of inadvertantly setting to a string. This
      // brings us in line with the same behavior we have on initial render.
      if (value != null) {
        DOMPropertyOperations.setValueForProperty(node, name, value);
      } else {
        DOMPropertyOperations.deleteValueForProperty(node, name);
      }
    }
  ),

  /**
   * Updates a DOM node to remove a property. This should only be used to remove
   * DOM properties in `DOMProperty`.
   *
   * @param {string} id ID of the node to update.
   * @param {string} name A property name to remove, see `DOMProperty`.
   * @internal
   */
  deletePropertyByID: ReactPerf.measure(
    'ReactDOMIDOperations',
    'deletePropertyByID',
    function(id, name, value) {
      var node = ReactMount.getNode(id);
      ("production" !== process.env.NODE_ENV ? invariant(
        !INVALID_PROPERTY_ERRORS.hasOwnProperty(name),
        'updatePropertyByID(...): %s',
        INVALID_PROPERTY_ERRORS[name]
      ) : invariant(!INVALID_PROPERTY_ERRORS.hasOwnProperty(name)));
      DOMPropertyOperations.deleteValueForProperty(node, name, value);
    }
  ),

  /**
   * Updates a DOM node with new style values. If a value is specified as '',
   * the corresponding style property will be unset.
   *
   * @param {string} id ID of the node to update.
   * @param {object} styles Mapping from styles to values.
   * @internal
   */
  updateStylesByID: ReactPerf.measure(
    'ReactDOMIDOperations',
    'updateStylesByID',
    function(id, styles) {
      var node = ReactMount.getNode(id);
      CSSPropertyOperations.setValueForStyles(node, styles);
    }
  ),

  /**
   * Updates a DOM node's innerHTML.
   *
   * @param {string} id ID of the node to update.
   * @param {string} html An HTML string.
   * @internal
   */
  updateInnerHTMLByID: ReactPerf.measure(
    'ReactDOMIDOperations',
    'updateInnerHTMLByID',
    function(id, html) {
      var node = ReactMount.getNode(id);
      setInnerHTML(node, html);
    }
  ),

  /**
   * Updates a DOM node's text content set by `props.content`.
   *
   * @param {string} id ID of the node to update.
   * @param {string} content Text content.
   * @internal
   */
  updateTextContentByID: ReactPerf.measure(
    'ReactDOMIDOperations',
    'updateTextContentByID',
    function(id, content) {
      var node = ReactMount.getNode(id);
      DOMChildrenOperations.updateTextContent(node, content);
    }
  ),

  /**
   * Replaces a DOM node that exists in the document with markup.
   *
   * @param {string} id ID of child to be replaced.
   * @param {string} markup Dangerous markup to inject in place of child.
   * @internal
   * @see {Danger.dangerouslyReplaceNodeWithMarkup}
   */
  dangerouslyReplaceNodeWithMarkupByID: ReactPerf.measure(
    'ReactDOMIDOperations',
    'dangerouslyReplaceNodeWithMarkupByID',
    function(id, markup) {
      var node = ReactMount.getNode(id);
      DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup(node, markup);
    }
  ),

  /**
   * Updates a component's children by processing a series of updates.
   *
   * @param {array<object>} updates List of update configurations.
   * @param {array<string>} markup List of markup strings.
   * @internal
   */
  dangerouslyProcessChildrenUpdates: ReactPerf.measure(
    'ReactDOMIDOperations',
    'dangerouslyProcessChildrenUpdates',
    function(updates, markup) {
      for (var i = 0; i < updates.length; i++) {
        updates[i].parentNode = ReactMount.getNode(updates[i].parentID);
      }
      DOMChildrenOperations.processUpdates(updates, markup);
    }
  )
};

module.exports = ReactDOMIDOperations;

}).call(this,require('_process'))
},{"./CSSPropertyOperations":83,"./DOMChildrenOperations":88,"./DOMPropertyOperations":90,"./ReactMount":145,"./ReactPerf":149,"./invariant":212,"./setInnerHTML":230,"_process":73}],124:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactDOMImg
 */

"use strict";

var EventConstants = require("./EventConstants");
var LocalEventTrapMixin = require("./LocalEventTrapMixin");
var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
var ReactCompositeComponent = require("./ReactCompositeComponent");
var ReactDOM = require("./ReactDOM");

// Store a reference to the <img> `ReactDOMComponent`.
var img = ReactDOM.img;

/**
 * Since onLoad doesn't bubble OR capture on the top level in IE8, we need to
 * capture it on the <img> element itself. There are lots of hacks we could do
 * to accomplish this, but the most reliable is to make <img> a composite
 * component and use `componentDidMount` to attach the event handlers.
 */
var ReactDOMImg = ReactCompositeComponent.createClass({
  displayName: 'ReactDOMImg',
  tagName: 'IMG',

  mixins: [ReactBrowserComponentMixin, LocalEventTrapMixin],

  render: function() {
    return img(this.props);
  },

  componentDidMount: function() {
    this.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load');
    this.trapBubbledEvent(EventConstants.topLevelTypes.topError, 'error');
  }
});

module.exports = ReactDOMImg;

},{"./EventConstants":94,"./LocalEventTrapMixin":104,"./ReactBrowserComponentMixin":108,"./ReactCompositeComponent":116,"./ReactDOM":119}],125:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactDOMInput
 */

"use strict";

var AutoFocusMixin = require("./AutoFocusMixin");
var DOMPropertyOperations = require("./DOMPropertyOperations");
var LinkedValueUtils = require("./LinkedValueUtils");
var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
var ReactCompositeComponent = require("./ReactCompositeComponent");
var ReactDOM = require("./ReactDOM");
var ReactMount = require("./ReactMount");

var invariant = require("./invariant");
var merge = require("./merge");

// Store a reference to the <input> `ReactDOMComponent`.
var input = ReactDOM.input;

var instancesByReactID = {};

/**
 * Implements an <input> native component that allows setting these optional
 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
 *
 * If `checked` or `value` are not supplied (or null/undefined), user actions
 * that affect the checked state or value will trigger updates to the element.
 *
 * If they are supplied (and not null/undefined), the rendered element will not
 * trigger updates to the element. Instead, the props must change in order for
 * the rendered element to be updated.
 *
 * The rendered element will be initialized as unchecked (or `defaultChecked`)
 * with an empty value (or `defaultValue`).
 *
 * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */
var ReactDOMInput = ReactCompositeComponent.createClass({
  displayName: 'ReactDOMInput',

  mixins: [AutoFocusMixin, LinkedValueUtils.Mixin, ReactBrowserComponentMixin],

  getInitialState: function() {
    var defaultValue = this.props.defaultValue;
    return {
      checked: this.props.defaultChecked || false,
      value: defaultValue != null ? defaultValue : null
    };
  },

  shouldComponentUpdate: function() {
    // Defer any updates to this component during the `onChange` handler.
    return !this._isChanging;
  },

  render: function() {
    // Clone `this.props` so we don't mutate the input.
    var props = merge(this.props);

    props.defaultChecked = null;
    props.defaultValue = null;

    var value = LinkedValueUtils.getValue(this);
    props.value = value != null ? value : this.state.value;

    var checked = LinkedValueUtils.getChecked(this);
    props.checked = checked != null ? checked : this.state.checked;

    props.onChange = this._handleChange;

    return input(props, this.props.children);
  },

  componentDidMount: function() {
    var id = ReactMount.getID(this.getDOMNode());
    instancesByReactID[id] = this;
  },

  componentWillUnmount: function() {
    var rootNode = this.getDOMNode();
    var id = ReactMount.getID(rootNode);
    delete instancesByReactID[id];
  },

  componentDidUpdate: function(prevProps, prevState, prevContext) {
    var rootNode = this.getDOMNode();
    if (this.props.checked != null) {
      DOMPropertyOperations.setValueForProperty(
        rootNode,
        'checked',
        this.props.checked || false
      );
    }

    var value = LinkedValueUtils.getValue(this);
    if (value != null) {
      // Cast `value` to a string to ensure the value is set correctly. While
      // browsers typically do this as necessary, jsdom doesn't.
      DOMPropertyOperations.setValueForProperty(rootNode, 'value', '' + value);
    }
  },

  _handleChange: function(event) {
    var returnValue;
    var onChange = LinkedValueUtils.getOnChange(this);
    if (onChange) {
      this._isChanging = true;
      returnValue = onChange.call(this, event);
      this._isChanging = false;
    }
    this.setState({
      checked: event.target.checked,
      value: event.target.value
    });

    var name = this.props.name;
    if (this.props.type === 'radio' && name != null) {
      var rootNode = this.getDOMNode();
      var queryRoot = rootNode;

      while (queryRoot.parentNode) {
        queryRoot = queryRoot.parentNode;
      }

      // If `rootNode.form` was non-null, then we could try `form.elements`,
      // but that sometimes behaves strangely in IE8. We could also try using
      // `form.getElementsByName`, but that will only return direct children
      // and won't include inputs that use the HTML5 `form=` attribute. Since
      // the input might not even be in a form, let's just use the global
      // `querySelectorAll` to ensure we don't miss anything.
      var group = queryRoot.querySelectorAll(
        'input[name=' + JSON.stringify('' + name) + '][type="radio"]');

      for (var i = 0, groupLen = group.length; i < groupLen; i++) {
        var otherNode = group[i];
        if (otherNode === rootNode ||
            otherNode.form !== rootNode.form) {
          continue;
        }
        var otherID = ReactMount.getID(otherNode);
        ("production" !== process.env.NODE_ENV ? invariant(
          otherID,
          'ReactDOMInput: Mixing React and non-React radio inputs with the ' +
          'same `name` is not supported.'
        ) : invariant(otherID));
        var otherInstance = instancesByReactID[otherID];
        ("production" !== process.env.NODE_ENV ? invariant(
          otherInstance,
          'ReactDOMInput: Unknown radio button ID %s.',
          otherID
        ) : invariant(otherInstance));
        // In some cases, this will actually change the `checked` state value.
        // In other cases, there's no change but this forces a reconcile upon
        // which componentDidUpdate will reset the DOM property to whatever it
        // should be.
        otherInstance.setState({
          checked: false
        });
      }
    }

    return returnValue;
  }

});

module.exports = ReactDOMInput;

}).call(this,require('_process'))
},{"./AutoFocusMixin":79,"./DOMPropertyOperations":90,"./LinkedValueUtils":103,"./ReactBrowserComponentMixin":108,"./ReactCompositeComponent":116,"./ReactDOM":119,"./ReactMount":145,"./invariant":212,"./merge":222,"_process":73}],126:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactDOMOption
 */

"use strict";

var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
var ReactCompositeComponent = require("./ReactCompositeComponent");
var ReactDOM = require("./ReactDOM");

var warning = require("./warning");

// Store a reference to the <option> `ReactDOMComponent`.
var option = ReactDOM.option;

/**
 * Implements an <option> native component that warns when `selected` is set.
 */
var ReactDOMOption = ReactCompositeComponent.createClass({
  displayName: 'ReactDOMOption',

  mixins: [ReactBrowserComponentMixin],

  componentWillMount: function() {
    // TODO (yungsters): Remove support for `selected` in <option>.
    if ("production" !== process.env.NODE_ENV) {
      ("production" !== process.env.NODE_ENV ? warning(
        this.props.selected == null,
        'Use the `defaultValue` or `value` props on <select> instead of ' +
        'setting `selected` on <option>.'
      ) : null);
    }
  },

  render: function() {
    return option(this.props, this.props.children);
  }

});

module.exports = ReactDOMOption;

}).call(this,require('_process'))
},{"./ReactBrowserComponentMixin":108,"./ReactCompositeComponent":116,"./ReactDOM":119,"./warning":236,"_process":73}],127:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactDOMSelect
 */

"use strict";

var AutoFocusMixin = require("./AutoFocusMixin");
var LinkedValueUtils = require("./LinkedValueUtils");
var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
var ReactCompositeComponent = require("./ReactCompositeComponent");
var ReactDOM = require("./ReactDOM");

var merge = require("./merge");

// Store a reference to the <select> `ReactDOMComponent`.
var select = ReactDOM.select;

/**
 * Validation function for `value` and `defaultValue`.
 * @private
 */
function selectValueType(props, propName, componentName) {
  if (props[propName] == null) {
    return;
  }
  if (props.multiple) {
    if (!Array.isArray(props[propName])) {
      return new Error(
        ("The `" + propName + "` prop supplied to <select> must be an array if ") +
        ("`multiple` is true.")
      );
    }
  } else {
    if (Array.isArray(props[propName])) {
      return new Error(
        ("The `" + propName + "` prop supplied to <select> must be a scalar ") +
        ("value if `multiple` is false.")
      );
    }
  }
}

/**
 * If `value` is supplied, updates <option> elements on mount and update.
 * @param {ReactComponent} component Instance of ReactDOMSelect
 * @param {?*} propValue For uncontrolled components, null/undefined. For
 * controlled components, a string (or with `multiple`, a list of strings).
 * @private
 */
function updateOptions(component, propValue) {
  var multiple = component.props.multiple;
  var value = propValue != null ? propValue : component.state.value;
  var options = component.getDOMNode().options;
  var selectedValue, i, l;
  if (multiple) {
    selectedValue = {};
    for (i = 0, l = value.length; i < l; ++i) {
      selectedValue['' + value[i]] = true;
    }
  } else {
    selectedValue = '' + value;
  }
  for (i = 0, l = options.length; i < l; i++) {
    var selected = multiple ?
      selectedValue.hasOwnProperty(options[i].value) :
      options[i].value === selectedValue;

    if (selected !== options[i].selected) {
      options[i].selected = selected;
    }
  }
}

/**
 * Implements a <select> native component that allows optionally setting the
 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
 * string. If `multiple` is true, the prop must be an array of strings.
 *
 * If `value` is not supplied (or null/undefined), user actions that change the
 * selected option will trigger updates to the rendered options.
 *
 * If it is supplied (and not null/undefined), the rendered options will not
 * update in response to user actions. Instead, the `value` prop must change in
 * order for the rendered options to update.
 *
 * If `defaultValue` is provided, any options with the supplied values will be
 * selected.
 */
var ReactDOMSelect = ReactCompositeComponent.createClass({
  displayName: 'ReactDOMSelect',

  mixins: [AutoFocusMixin, LinkedValueUtils.Mixin, ReactBrowserComponentMixin],

  propTypes: {
    defaultValue: selectValueType,
    value: selectValueType
  },

  getInitialState: function() {
    return {value: this.props.defaultValue || (this.props.multiple ? [] : '')};
  },

  componentWillReceiveProps: function(nextProps) {
    if (!this.props.multiple && nextProps.multiple) {
      this.setState({value: [this.state.value]});
    } else if (this.props.multiple && !nextProps.multiple) {
      this.setState({value: this.state.value[0]});
    }
  },

  shouldComponentUpdate: function() {
    // Defer any updates to this component during the `onChange` handler.
    return !this._isChanging;
  },

  render: function() {
    // Clone `this.props` so we don't mutate the input.
    var props = merge(this.props);

    props.onChange = this._handleChange;
    props.value = null;

    return select(props, this.props.children);
  },

  componentDidMount: function() {
    updateOptions(this, LinkedValueUtils.getValue(this));
  },

  componentDidUpdate: function(prevProps) {
    var value = LinkedValueUtils.getValue(this);
    var prevMultiple = !!prevProps.multiple;
    var multiple = !!this.props.multiple;
    if (value != null || prevMultiple !== multiple) {
      updateOptions(this, value);
    }
  },

  _handleChange: function(event) {
    var returnValue;
    var onChange = LinkedValueUtils.getOnChange(this);
    if (onChange) {
      this._isChanging = true;
      returnValue = onChange.call(this, event);
      this._isChanging = false;
    }

    var selectedValue;
    if (this.props.multiple) {
      selectedValue = [];
      var options = event.target.options;
      for (var i = 0, l = options.length; i < l; i++) {
        if (options[i].selected) {
          selectedValue.push(options[i].value);
        }
      }
    } else {
      selectedValue = event.target.value;
    }

    this.setState({value: selectedValue});
    return returnValue;
  }

});

module.exports = ReactDOMSelect;

},{"./AutoFocusMixin":79,"./LinkedValueUtils":103,"./ReactBrowserComponentMixin":108,"./ReactCompositeComponent":116,"./ReactDOM":119,"./merge":222}],128:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactDOMSelection
 */

"use strict";

var ExecutionEnvironment = require("./ExecutionEnvironment");

var getNodeForCharacterOffset = require("./getNodeForCharacterOffset");
var getTextContentAccessor = require("./getTextContentAccessor");

/**
 * While `isCollapsed` is available on the Selection object and `collapsed`
 * is available on the Range object, IE11 sometimes gets them wrong.
 * If the anchor/focus nodes and offsets are the same, the range is collapsed.
 */
function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
  return anchorNode === focusNode && anchorOffset === focusOffset;
}

/**
 * Get the appropriate anchor and focus node/offset pairs for IE.
 *
 * The catch here is that IE's selection API doesn't provide information
 * about whether the selection is forward or backward, so we have to
 * behave as though it's always forward.
 *
 * IE text differs from modern selection in that it behaves as though
 * block elements end with a new line. This means character offsets will
 * differ between the two APIs.
 *
 * @param {DOMElement} node
 * @return {object}
 */
function getIEOffsets(node) {
  var selection = document.selection;
  var selectedRange = selection.createRange();
  var selectedLength = selectedRange.text.length;

  // Duplicate selection so we can move range without breaking user selection.
  var fromStart = selectedRange.duplicate();
  fromStart.moveToElementText(node);
  fromStart.setEndPoint('EndToStart', selectedRange);

  var startOffset = fromStart.text.length;
  var endOffset = startOffset + selectedLength;

  return {
    start: startOffset,
    end: endOffset
  };
}

/**
 * @param {DOMElement} node
 * @return {?object}
 */
function getModernOffsets(node) {
  var selection = window.getSelection();

  if (selection.rangeCount === 0) {
    return null;
  }

  var anchorNode = selection.anchorNode;
  var anchorOffset = selection.anchorOffset;
  var focusNode = selection.focusNode;
  var focusOffset = selection.focusOffset;

  var currentRange = selection.getRangeAt(0);

  // If the node and offset values are the same, the selection is collapsed.
  // `Selection.isCollapsed` is available natively, but IE sometimes gets
  // this value wrong.
  var isSelectionCollapsed = isCollapsed(
    selection.anchorNode,
    selection.anchorOffset,
    selection.focusNode,
    selection.focusOffset
  );

  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;

  var tempRange = currentRange.cloneRange();
  tempRange.selectNodeContents(node);
  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);

  var isTempRangeCollapsed = isCollapsed(
    tempRange.startContainer,
    tempRange.startOffset,
    tempRange.endContainer,
    tempRange.endOffset
  );

  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
  var end = start + rangeLength;

  // Detect whether the selection is backward.
  var detectionRange = document.createRange();
  detectionRange.setStart(anchorNode, anchorOffset);
  detectionRange.setEnd(focusNode, focusOffset);
  var isBackward = detectionRange.collapsed;
  detectionRange.detach();

  return {
    start: isBackward ? end : start,
    end: isBackward ? start : end
  };
}

/**
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */
function setIEOffsets(node, offsets) {
  var range = document.selection.createRange().duplicate();
  var start, end;

  if (typeof offsets.end === 'undefined') {
    start = offsets.start;
    end = start;
  } else if (offsets.start > offsets.end) {
    start = offsets.end;
    end = offsets.start;
  } else {
    start = offsets.start;
    end = offsets.end;
  }

  range.moveToElementText(node);
  range.moveStart('character', start);
  range.setEndPoint('EndToStart', range);
  range.moveEnd('character', end - start);
  range.select();
}

/**
 * In modern non-IE browsers, we can support both forward and backward
 * selections.
 *
 * Note: IE10+ supports the Selection object, but it does not support
 * the `extend` method, which means that even in modern IE, it's not possible
 * to programatically create a backward selection. Thus, for all IE
 * versions, we use the old IE API to create our selections.
 *
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */
function setModernOffsets(node, offsets) {
  var selection = window.getSelection();

  var length = node[getTextContentAccessor()].length;
  var start = Math.min(offsets.start, length);
  var end = typeof offsets.end === 'undefined' ?
            start : Math.min(offsets.end, length);

  // IE 11 uses modern selection, but doesn't support the extend method.
  // Flip backward selections, so we can set with a single range.
  if (!selection.extend && start > end) {
    var temp = end;
    end = start;
    start = temp;
  }

  var startMarker = getNodeForCharacterOffset(node, start);
  var endMarker = getNodeForCharacterOffset(node, end);

  if (startMarker && endMarker) {
    var range = document.createRange();
    range.setStart(startMarker.node, startMarker.offset);
    selection.removeAllRanges();

    if (start > end) {
      selection.addRange(range);
      selection.extend(endMarker.node, endMarker.offset);
    } else {
      range.setEnd(endMarker.node, endMarker.offset);
      selection.addRange(range);
    }

    range.detach();
  }
}

var useIEOffsets = ExecutionEnvironment.canUseDOM && document.selection;

var ReactDOMSelection = {
  /**
   * @param {DOMElement} node
   */
  getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,

  /**
   * @param {DOMElement|DOMTextNode} node
   * @param {object} offsets
   */
  setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
};

module.exports = ReactDOMSelection;

},{"./ExecutionEnvironment":100,"./getNodeForCharacterOffset":205,"./getTextContentAccessor":207}],129:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactDOMTextarea
 */

"use strict";

var AutoFocusMixin = require("./AutoFocusMixin");
var DOMPropertyOperations = require("./DOMPropertyOperations");
var LinkedValueUtils = require("./LinkedValueUtils");
var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
var ReactCompositeComponent = require("./ReactCompositeComponent");
var ReactDOM = require("./ReactDOM");

var invariant = require("./invariant");
var merge = require("./merge");

var warning = require("./warning");

// Store a reference to the <textarea> `ReactDOMComponent`.
var textarea = ReactDOM.textarea;

/**
 * Implements a <textarea> native component that allows setting `value`, and
 * `defaultValue`. This differs from the traditional DOM API because value is
 * usually set as PCDATA children.
 *
 * If `value` is not supplied (or null/undefined), user actions that affect the
 * value will trigger updates to the element.
 *
 * If `value` is supplied (and not null/undefined), the rendered element will
 * not trigger updates to the element. Instead, the `value` prop must change in
 * order for the rendered element to be updated.
 *
 * The rendered element will be initialized with an empty value, the prop
 * `defaultValue` if specified, or the children content (deprecated).
 */
var ReactDOMTextarea = ReactCompositeComponent.createClass({
  displayName: 'ReactDOMTextarea',

  mixins: [AutoFocusMixin, LinkedValueUtils.Mixin, ReactBrowserComponentMixin],

  getInitialState: function() {
    var defaultValue = this.props.defaultValue;
    // TODO (yungsters): Remove support for children content in <textarea>.
    var children = this.props.children;
    if (children != null) {
      if ("production" !== process.env.NODE_ENV) {
        ("production" !== process.env.NODE_ENV ? warning(
          false,
          'Use the `defaultValue` or `value` props instead of setting ' +
          'children on <textarea>.'
        ) : null);
      }
      ("production" !== process.env.NODE_ENV ? invariant(
        defaultValue == null,
        'If you supply `defaultValue` on a <textarea>, do not pass children.'
      ) : invariant(defaultValue == null));
      if (Array.isArray(children)) {
        ("production" !== process.env.NODE_ENV ? invariant(
          children.length <= 1,
          '<textarea> can only have at most one child.'
        ) : invariant(children.length <= 1));
        children = children[0];
      }

      defaultValue = '' + children;
    }
    if (defaultValue == null) {
      defaultValue = '';
    }
    var value = LinkedValueUtils.getValue(this);
    return {
      // We save the initial value so that `ReactDOMComponent` doesn't update
      // `textContent` (unnecessary since we update value).
      // The initial value can be a boolean or object so that's why it's
      // forced to be a string.
      initialValue: '' + (value != null ? value : defaultValue)
    };
  },

  shouldComponentUpdate: function() {
    // Defer any updates to this component during the `onChange` handler.
    return !this._isChanging;
  },

  render: function() {
    // Clone `this.props` so we don't mutate the input.
    var props = merge(this.props);

    ("production" !== process.env.NODE_ENV ? invariant(
      props.dangerouslySetInnerHTML == null,
      '`dangerouslySetInnerHTML` does not make sense on <textarea>.'
    ) : invariant(props.dangerouslySetInnerHTML == null));

    props.defaultValue = null;
    props.value = null;
    props.onChange = this._handleChange;

    // Always set children to the same thing. In IE9, the selection range will
    // get reset if `textContent` is mutated.
    return textarea(props, this.state.initialValue);
  },

  componentDidUpdate: function(prevProps, prevState, prevContext) {
    var value = LinkedValueUtils.getValue(this);
    if (value != null) {
      var rootNode = this.getDOMNode();
      // Cast `value` to a string to ensure the value is set correctly. While
      // browsers typically do this as necessary, jsdom doesn't.
      DOMPropertyOperations.setValueForProperty(rootNode, 'value', '' + value);
    }
  },

  _handleChange: function(event) {
    var returnValue;
    var onChange = LinkedValueUtils.getOnChange(this);
    if (onChange) {
      this._isChanging = true;
      returnValue = onChange.call(this, event);
      this._isChanging = false;
    }
    this.setState({value: event.target.value});
    return returnValue;
  }

});

module.exports = ReactDOMTextarea;

}).call(this,require('_process'))
},{"./AutoFocusMixin":79,"./DOMPropertyOperations":90,"./LinkedValueUtils":103,"./ReactBrowserComponentMixin":108,"./ReactCompositeComponent":116,"./ReactDOM":119,"./invariant":212,"./merge":222,"./warning":236,"_process":73}],130:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactDefaultBatchingStrategy
 */

"use strict";

var ReactUpdates = require("./ReactUpdates");
var Transaction = require("./Transaction");

var emptyFunction = require("./emptyFunction");
var mixInto = require("./mixInto");

var RESET_BATCHED_UPDATES = {
  initialize: emptyFunction,
  close: function() {
    ReactDefaultBatchingStrategy.isBatchingUpdates = false;
  }
};

var FLUSH_BATCHED_UPDATES = {
  initialize: emptyFunction,
  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
};

var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];

function ReactDefaultBatchingStrategyTransaction() {
  this.reinitializeTransaction();
}

mixInto(ReactDefaultBatchingStrategyTransaction, Transaction.Mixin);
mixInto(ReactDefaultBatchingStrategyTransaction, {
  getTransactionWrappers: function() {
    return TRANSACTION_WRAPPERS;
  }
});

var transaction = new ReactDefaultBatchingStrategyTransaction();

var ReactDefaultBatchingStrategy = {
  isBatchingUpdates: false,

  /**
   * Call the provided function in a context within which calls to `setState`
   * and friends are batched such that components aren't updated unnecessarily.
   */
  batchedUpdates: function(callback, a, b) {
    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;

    ReactDefaultBatchingStrategy.isBatchingUpdates = true;

    // The code is written this way to avoid extra allocations
    if (alreadyBatchingUpdates) {
      callback(a, b);
    } else {
      transaction.perform(callback, null, a, b);
    }
  }
};

module.exports = ReactDefaultBatchingStrategy;

},{"./ReactUpdates":165,"./Transaction":182,"./emptyFunction":194,"./mixInto":225}],131:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactDefaultInjection
 */

"use strict";

var BeforeInputEventPlugin = require("./BeforeInputEventPlugin");
var ChangeEventPlugin = require("./ChangeEventPlugin");
var ClientReactRootIndex = require("./ClientReactRootIndex");
var CompositionEventPlugin = require("./CompositionEventPlugin");
var DefaultEventPluginOrder = require("./DefaultEventPluginOrder");
var EnterLeaveEventPlugin = require("./EnterLeaveEventPlugin");
var ExecutionEnvironment = require("./ExecutionEnvironment");
var HTMLDOMPropertyConfig = require("./HTMLDOMPropertyConfig");
var MobileSafariClickEventPlugin = require("./MobileSafariClickEventPlugin");
var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
var ReactComponentBrowserEnvironment =
  require("./ReactComponentBrowserEnvironment");
var ReactDefaultBatchingStrategy = require("./ReactDefaultBatchingStrategy");
var ReactDOM = require("./ReactDOM");
var ReactDOMButton = require("./ReactDOMButton");
var ReactDOMForm = require("./ReactDOMForm");
var ReactDOMImg = require("./ReactDOMImg");
var ReactDOMInput = require("./ReactDOMInput");
var ReactDOMOption = require("./ReactDOMOption");
var ReactDOMSelect = require("./ReactDOMSelect");
var ReactDOMTextarea = require("./ReactDOMTextarea");
var ReactEventListener = require("./ReactEventListener");
var ReactInjection = require("./ReactInjection");
var ReactInstanceHandles = require("./ReactInstanceHandles");
var ReactMount = require("./ReactMount");
var SelectEventPlugin = require("./SelectEventPlugin");
var ServerReactRootIndex = require("./ServerReactRootIndex");
var SimpleEventPlugin = require("./SimpleEventPlugin");
var SVGDOMPropertyConfig = require("./SVGDOMPropertyConfig");

var createFullPageComponent = require("./createFullPageComponent");

function inject() {
  ReactInjection.EventEmitter.injectReactEventListener(
    ReactEventListener
  );

  /**
   * Inject modules for resolving DOM hierarchy and plugin ordering.
   */
  ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
  ReactInjection.EventPluginHub.injectInstanceHandle(ReactInstanceHandles);
  ReactInjection.EventPluginHub.injectMount(ReactMount);

  /**
   * Some important event plugins included by default (without having to require
   * them).
   */
  ReactInjection.EventPluginHub.injectEventPluginsByName({
    SimpleEventPlugin: SimpleEventPlugin,
    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
    ChangeEventPlugin: ChangeEventPlugin,
    CompositionEventPlugin: CompositionEventPlugin,
    MobileSafariClickEventPlugin: MobileSafariClickEventPlugin,
    SelectEventPlugin: SelectEventPlugin,
    BeforeInputEventPlugin: BeforeInputEventPlugin
  });

  ReactInjection.DOM.injectComponentClasses({
    button: ReactDOMButton,
    form: ReactDOMForm,
    img: ReactDOMImg,
    input: ReactDOMInput,
    option: ReactDOMOption,
    select: ReactDOMSelect,
    textarea: ReactDOMTextarea,

    html: createFullPageComponent(ReactDOM.html),
    head: createFullPageComponent(ReactDOM.head),
    body: createFullPageComponent(ReactDOM.body)
  });

  // This needs to happen after createFullPageComponent() otherwise the mixin
  // gets double injected.
  ReactInjection.CompositeComponent.injectMixin(ReactBrowserComponentMixin);

  ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
  ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);

  ReactInjection.EmptyComponent.injectEmptyComponent(ReactDOM.noscript);

  ReactInjection.Updates.injectReconcileTransaction(
    ReactComponentBrowserEnvironment.ReactReconcileTransaction
  );
  ReactInjection.Updates.injectBatchingStrategy(
    ReactDefaultBatchingStrategy
  );

  ReactInjection.RootIndex.injectCreateReactRootIndex(
    ExecutionEnvironment.canUseDOM ?
      ClientReactRootIndex.createReactRootIndex :
      ServerReactRootIndex.createReactRootIndex
  );

  ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);

  if ("production" !== process.env.NODE_ENV) {
    var url = (ExecutionEnvironment.canUseDOM && window.location.href) || '';
    if ((/[?&]react_perf\b/).test(url)) {
      var ReactDefaultPerf = require("./ReactDefaultPerf");
      ReactDefaultPerf.start();
    }
  }
}

module.exports = {
  inject: inject
};

}).call(this,require('_process'))
},{"./BeforeInputEventPlugin":80,"./ChangeEventPlugin":85,"./ClientReactRootIndex":86,"./CompositionEventPlugin":87,"./DefaultEventPluginOrder":92,"./EnterLeaveEventPlugin":93,"./ExecutionEnvironment":100,"./HTMLDOMPropertyConfig":101,"./MobileSafariClickEventPlugin":105,"./ReactBrowserComponentMixin":108,"./ReactComponentBrowserEnvironment":114,"./ReactDOM":119,"./ReactDOMButton":120,"./ReactDOMForm":122,"./ReactDOMImg":124,"./ReactDOMInput":125,"./ReactDOMOption":126,"./ReactDOMSelect":127,"./ReactDOMTextarea":129,"./ReactDefaultBatchingStrategy":130,"./ReactDefaultPerf":132,"./ReactEventListener":139,"./ReactInjection":140,"./ReactInstanceHandles":142,"./ReactMount":145,"./SVGDOMPropertyConfig":167,"./SelectEventPlugin":168,"./ServerReactRootIndex":169,"./SimpleEventPlugin":170,"./createFullPageComponent":190,"_process":73}],132:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactDefaultPerf
 * @typechecks static-only
 */

"use strict";

var DOMProperty = require("./DOMProperty");
var ReactDefaultPerfAnalysis = require("./ReactDefaultPerfAnalysis");
var ReactMount = require("./ReactMount");
var ReactPerf = require("./ReactPerf");

var performanceNow = require("./performanceNow");

function roundFloat(val) {
  return Math.floor(val * 100) / 100;
}

function addValue(obj, key, val) {
  obj[key] = (obj[key] || 0) + val;
}

var ReactDefaultPerf = {
  _allMeasurements: [], // last item in the list is the current one
  _mountStack: [0],
  _injected: false,

  start: function() {
    if (!ReactDefaultPerf._injected) {
      ReactPerf.injection.injectMeasure(ReactDefaultPerf.measure);
    }

    ReactDefaultPerf._allMeasurements.length = 0;
    ReactPerf.enableMeasure = true;
  },

  stop: function() {
    ReactPerf.enableMeasure = false;
  },

  getLastMeasurements: function() {
    return ReactDefaultPerf._allMeasurements;
  },

  printExclusive: function(measurements) {
    measurements = measurements || ReactDefaultPerf._allMeasurements;
    var summary = ReactDefaultPerfAnalysis.getExclusiveSummary(measurements);
    console.table(summary.map(function(item) {
      return {
        'Component class name': item.componentName,
        'Total inclusive time (ms)': roundFloat(item.inclusive),
        'Exclusive mount time (ms)': roundFloat(item.exclusive),
        'Exclusive render time (ms)': roundFloat(item.render),
        'Mount time per instance (ms)': roundFloat(item.exclusive / item.count),
        'Render time per instance (ms)': roundFloat(item.render / item.count),
        'Instances': item.count
      };
    }));
    // TODO: ReactDefaultPerfAnalysis.getTotalTime() does not return the correct
    // number.
  },

  printInclusive: function(measurements) {
    measurements = measurements || ReactDefaultPerf._allMeasurements;
    var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements);
    console.table(summary.map(function(item) {
      return {
        'Owner > component': item.componentName,
        'Inclusive time (ms)': roundFloat(item.time),
        'Instances': item.count
      };
    }));
    console.log(
      'Total time:',
      ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms'
    );
  },

  printWasted: function(measurements) {
    measurements = measurements || ReactDefaultPerf._allMeasurements;
    var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(
      measurements,
      true
    );
    console.table(summary.map(function(item) {
      return {
        'Owner > component': item.componentName,
        'Wasted time (ms)': item.time,
        'Instances': item.count
      };
    }));
    console.log(
      'Total time:',
      ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms'
    );
  },

  printDOM: function(measurements) {
    measurements = measurements || ReactDefaultPerf._allMeasurements;
    var summary = ReactDefaultPerfAnalysis.getDOMSummary(measurements);
    console.table(summary.map(function(item) {
      var result = {};
      result[DOMProperty.ID_ATTRIBUTE_NAME] = item.id;
      result['type'] = item.type;
      result['args'] = JSON.stringify(item.args);
      return result;
    }));
    console.log(
      'Total time:',
      ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms'
    );
  },

  _recordWrite: function(id, fnName, totalTime, args) {
    // TODO: totalTime isn't that useful since it doesn't count paints/reflows
    var writes =
      ReactDefaultPerf
        ._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1]
        .writes;
    writes[id] = writes[id] || [];
    writes[id].push({
      type: fnName,
      time: totalTime,
      args: args
    });
  },

  measure: function(moduleName, fnName, func) {
    return function() {var args=Array.prototype.slice.call(arguments,0);
      var totalTime;
      var rv;
      var start;

      if (fnName === '_renderNewRootComponent' ||
          fnName === 'flushBatchedUpdates') {
        // A "measurement" is a set of metrics recorded for each flush. We want
        // to group the metrics for a given flush together so we can look at the
        // components that rendered and the DOM operations that actually
        // happened to determine the amount of "wasted work" performed.
        ReactDefaultPerf._allMeasurements.push({
          exclusive: {},
          inclusive: {},
          render: {},
          counts: {},
          writes: {},
          displayNames: {},
          totalTime: 0
        });
        start = performanceNow();
        rv = func.apply(this, args);
        ReactDefaultPerf._allMeasurements[
          ReactDefaultPerf._allMeasurements.length - 1
        ].totalTime = performanceNow() - start;
        return rv;
      } else if (moduleName === 'ReactDOMIDOperations' ||
        moduleName === 'ReactComponentBrowserEnvironment') {
        start = performanceNow();
        rv = func.apply(this, args);
        totalTime = performanceNow() - start;

        if (fnName === 'mountImageIntoNode') {
          var mountID = ReactMount.getID(args[1]);
          ReactDefaultPerf._recordWrite(mountID, fnName, totalTime, args[0]);
        } else if (fnName === 'dangerouslyProcessChildrenUpdates') {
          // special format
          args[0].forEach(function(update) {
            var writeArgs = {};
            if (update.fromIndex !== null) {
              writeArgs.fromIndex = update.fromIndex;
            }
            if (update.toIndex !== null) {
              writeArgs.toIndex = update.toIndex;
            }
            if (update.textContent !== null) {
              writeArgs.textContent = update.textContent;
            }
            if (update.markupIndex !== null) {
              writeArgs.markup = args[1][update.markupIndex];
            }
            ReactDefaultPerf._recordWrite(
              update.parentID,
              update.type,
              totalTime,
              writeArgs
            );
          });
        } else {
          // basic format
          ReactDefaultPerf._recordWrite(
            args[0],
            fnName,
            totalTime,
            Array.prototype.slice.call(args, 1)
          );
        }
        return rv;
      } else if (moduleName === 'ReactCompositeComponent' && (
        fnName === 'mountComponent' ||
        fnName === 'updateComponent' || // TODO: receiveComponent()?
        fnName === '_renderValidatedComponent')) {

        var rootNodeID = fnName === 'mountComponent' ?
          args[0] :
          this._rootNodeID;
        var isRender = fnName === '_renderValidatedComponent';
        var isMount = fnName === 'mountComponent';

        var mountStack = ReactDefaultPerf._mountStack;
        var entry = ReactDefaultPerf._allMeasurements[
          ReactDefaultPerf._allMeasurements.length - 1
        ];

        if (isRender) {
          addValue(entry.counts, rootNodeID, 1);
        } else if (isMount) {
          mountStack.push(0);
        }

        start = performanceNow();
        rv = func.apply(this, args);
        totalTime = performanceNow() - start;

        if (isRender) {
          addValue(entry.render, rootNodeID, totalTime);
        } else if (isMount) {
          var subMountTime = mountStack.pop();
          mountStack[mountStack.length - 1] += totalTime;
          addValue(entry.exclusive, rootNodeID, totalTime - subMountTime);
          addValue(entry.inclusive, rootNodeID, totalTime);
        } else {
          addValue(entry.inclusive, rootNodeID, totalTime);
        }

        entry.displayNames[rootNodeID] = {
          current: this.constructor.displayName,
          owner: this._owner ? this._owner.constructor.displayName : '<root>'
        };

        return rv;
      } else {
        return func.apply(this, args);
      }
    };
  }
};

module.exports = ReactDefaultPerf;

},{"./DOMProperty":89,"./ReactDefaultPerfAnalysis":133,"./ReactMount":145,"./ReactPerf":149,"./performanceNow":229}],133:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactDefaultPerfAnalysis
 */

var merge = require("./merge");

// Don't try to save users less than 1.2ms (a number I made up)
var DONT_CARE_THRESHOLD = 1.2;
var DOM_OPERATION_TYPES = {
  'mountImageIntoNode': 'set innerHTML',
  INSERT_MARKUP: 'set innerHTML',
  MOVE_EXISTING: 'move',
  REMOVE_NODE: 'remove',
  TEXT_CONTENT: 'set textContent',
  'updatePropertyByID': 'update attribute',
  'deletePropertyByID': 'delete attribute',
  'updateStylesByID': 'update styles',
  'updateInnerHTMLByID': 'set innerHTML',
  'dangerouslyReplaceNodeWithMarkupByID': 'replace'
};

function getTotalTime(measurements) {
  // TODO: return number of DOM ops? could be misleading.
  // TODO: measure dropped frames after reconcile?
  // TODO: log total time of each reconcile and the top-level component
  // class that triggered it.
  var totalTime = 0;
  for (var i = 0; i < measurements.length; i++) {
    var measurement = measurements[i];
    totalTime += measurement.totalTime;
  }
  return totalTime;
}

function getDOMSummary(measurements) {
  var items = [];
  for (var i = 0; i < measurements.length; i++) {
    var measurement = measurements[i];
    var id;

    for (id in measurement.writes) {
      measurement.writes[id].forEach(function(write) {
        items.push({
          id: id,
          type: DOM_OPERATION_TYPES[write.type] || write.type,
          args: write.args
        });
      });
    }
  }
  return items;
}

function getExclusiveSummary(measurements) {
  var candidates = {};
  var displayName;

  for (var i = 0; i < measurements.length; i++) {
    var measurement = measurements[i];
    var allIDs = merge(measurement.exclusive, measurement.inclusive);

    for (var id in allIDs) {
      displayName = measurement.displayNames[id].current;

      candidates[displayName] = candidates[displayName] || {
        componentName: displayName,
        inclusive: 0,
        exclusive: 0,
        render: 0,
        count: 0
      };
      if (measurement.render[id]) {
        candidates[displayName].render += measurement.render[id];
      }
      if (measurement.exclusive[id]) {
        candidates[displayName].exclusive += measurement.exclusive[id];
      }
      if (measurement.inclusive[id]) {
        candidates[displayName].inclusive += measurement.inclusive[id];
      }
      if (measurement.counts[id]) {
        candidates[displayName].count += measurement.counts[id];
      }
    }
  }

  // Now make a sorted array with the results.
  var arr = [];
  for (displayName in candidates) {
    if (candidates[displayName].exclusive >= DONT_CARE_THRESHOLD) {
      arr.push(candidates[displayName]);
    }
  }

  arr.sort(function(a, b) {
    return b.exclusive - a.exclusive;
  });

  return arr;
}

function getInclusiveSummary(measurements, onlyClean) {
  var candidates = {};
  var inclusiveKey;

  for (var i = 0; i < measurements.length; i++) {
    var measurement = measurements[i];
    var allIDs = merge(measurement.exclusive, measurement.inclusive);
    var cleanComponents;

    if (onlyClean) {
      cleanComponents = getUnchangedComponents(measurement);
    }

    for (var id in allIDs) {
      if (onlyClean && !cleanComponents[id]) {
        continue;
      }

      var displayName = measurement.displayNames[id];

      // Inclusive time is not useful for many components without knowing where
      // they are instantiated. So we aggregate inclusive time with both the
      // owner and current displayName as the key.
      inclusiveKey = displayName.owner + ' > ' + displayName.current;

      candidates[inclusiveKey] = candidates[inclusiveKey] || {
        componentName: inclusiveKey,
        time: 0,
        count: 0
      };

      if (measurement.inclusive[id]) {
        candidates[inclusiveKey].time += measurement.inclusive[id];
      }
      if (measurement.counts[id]) {
        candidates[inclusiveKey].count += measurement.counts[id];
      }
    }
  }

  // Now make a sorted array with the results.
  var arr = [];
  for (inclusiveKey in candidates) {
    if (candidates[inclusiveKey].time >= DONT_CARE_THRESHOLD) {
      arr.push(candidates[inclusiveKey]);
    }
  }

  arr.sort(function(a, b) {
    return b.time - a.time;
  });

  return arr;
}

function getUnchangedComponents(measurement) {
  // For a given reconcile, look at which components did not actually
  // render anything to the DOM and return a mapping of their ID to
  // the amount of time it took to render the entire subtree.
  var cleanComponents = {};
  var dirtyLeafIDs = Object.keys(measurement.writes);
  var allIDs = merge(measurement.exclusive, measurement.inclusive);

  for (var id in allIDs) {
    var isDirty = false;
    // For each component that rendered, see if a component that triggerd
    // a DOM op is in its subtree.
    for (var i = 0; i < dirtyLeafIDs.length; i++) {
      if (dirtyLeafIDs[i].indexOf(id) === 0) {
        isDirty = true;
        break;
      }
    }
    if (!isDirty && measurement.counts[id] > 0) {
      cleanComponents[id] = true;
    }
  }
  return cleanComponents;
}

var ReactDefaultPerfAnalysis = {
  getExclusiveSummary: getExclusiveSummary,
  getInclusiveSummary: getInclusiveSummary,
  getDOMSummary: getDOMSummary,
  getTotalTime: getTotalTime
};

module.exports = ReactDefaultPerfAnalysis;

},{"./merge":222}],134:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactDescriptor
 */

"use strict";

var ReactContext = require("./ReactContext");
var ReactCurrentOwner = require("./ReactCurrentOwner");

var merge = require("./merge");
var warning = require("./warning");

/**
 * Warn for mutations.
 *
 * @internal
 * @param {object} object
 * @param {string} key
 */
function defineWarningProperty(object, key) {
  Object.defineProperty(object, key, {

    configurable: false,
    enumerable: true,

    get: function() {
      if (!this._store) {
        return null;
      }
      return this._store[key];
    },

    set: function(value) {
      ("production" !== process.env.NODE_ENV ? warning(
        false,
        'Don\'t set the ' + key + ' property of the component. ' +
        'Mutate the existing props object instead.'
      ) : null);
      this._store[key] = value;
    }

  });
}

/**
 * This is updated to true if the membrane is successfully created.
 */
var useMutationMembrane = false;

/**
 * Warn for mutations.
 *
 * @internal
 * @param {object} descriptor
 */
function defineMutationMembrane(prototype) {
  try {
    var pseudoFrozenProperties = {
      props: true
    };
    for (var key in pseudoFrozenProperties) {
      defineWarningProperty(prototype, key);
    }
    useMutationMembrane = true;
  } catch (x) {
    // IE will fail on defineProperty
  }
}

/**
 * Transfer static properties from the source to the target. Functions are
 * rebound to have this reflect the original source.
 */
function proxyStaticMethods(target, source) {
  if (typeof source !== 'function') {
    return;
  }
  for (var key in source) {
    if (source.hasOwnProperty(key)) {
      var value = source[key];
      if (typeof value === 'function') {
        var bound = value.bind(source);
        // Copy any properties defined on the function, such as `isRequired` on
        // a PropTypes validator. (mergeInto refuses to work on functions.)
        for (var k in value) {
          if (value.hasOwnProperty(k)) {
            bound[k] = value[k];
          }
        }
        target[key] = bound;
      } else {
        target[key] = value;
      }
    }
  }
}

/**
 * Base constructor for all React descriptors. This is only used to make this
 * work with a dynamic instanceof check. Nothing should live on this prototype.
 *
 * @param {*} type
 * @internal
 */
var ReactDescriptor = function() {};

if ("production" !== process.env.NODE_ENV) {
  defineMutationMembrane(ReactDescriptor.prototype);
}

ReactDescriptor.createFactory = function(type) {

  var descriptorPrototype = Object.create(ReactDescriptor.prototype);

  var factory = function(props, children) {
    // For consistency we currently allocate a new object for every descriptor.
    // This protects the descriptor from being mutated by the original props
    // object being mutated. It also protects the original props object from
    // being mutated by children arguments and default props. This behavior
    // comes with a performance cost and could be deprecated in the future.
    // It could also be optimized with a smarter JSX transform.
    if (props == null) {
      props = {};
    } else if (typeof props === 'object') {
      props = merge(props);
    }

    // Children can be more than one argument, and those are transferred onto
    // the newly allocated props object.
    var childrenLength = arguments.length - 1;
    if (childrenLength === 1) {
      props.children = children;
    } else if (childrenLength > 1) {
      var childArray = Array(childrenLength);
      for (var i = 0; i < childrenLength; i++) {
        childArray[i] = arguments[i + 1];
      }
      props.children = childArray;
    }

    // Initialize the descriptor object
    var descriptor = Object.create(descriptorPrototype);

    // Record the component responsible for creating this descriptor.
    descriptor._owner = ReactCurrentOwner.current;

    // TODO: Deprecate withContext, and then the context becomes accessible
    // through the owner.
    descriptor._context = ReactContext.current;

    if ("production" !== process.env.NODE_ENV) {
      // The validation flag and props are currently mutative. We put them on
      // an external backing store so that we can freeze the whole object.
      // This can be replaced with a WeakMap once they are implemented in
      // commonly used development environments.
      descriptor._store = { validated: false, props: props };

      // We're not allowed to set props directly on the object so we early
      // return and rely on the prototype membrane to forward to the backing
      // store.
      if (useMutationMembrane) {
        Object.freeze(descriptor);
        return descriptor;
      }
    }

    descriptor.props = props;
    return descriptor;
  };

  // Currently we expose the prototype of the descriptor so that
  // <Foo /> instanceof Foo works. This is controversial pattern.
  factory.prototype = descriptorPrototype;

  // Expose the type on the factory and the prototype so that it can be
  // easily accessed on descriptors. E.g. <Foo />.type === Foo.type and for
  // static methods like <Foo />.type.staticMethod();
  // This should not be named constructor since this may not be the function
  // that created the descriptor, and it may not even be a constructor.
  factory.type = type;
  descriptorPrototype.type = type;

  proxyStaticMethods(factory, type);

  // Expose a unique constructor on the prototype is that this works with type
  // systems that compare constructor properties: <Foo />.constructor === Foo
  // This may be controversial since it requires a known factory function.
  descriptorPrototype.constructor = factory;

  return factory;

};

ReactDescriptor.cloneAndReplaceProps = function(oldDescriptor, newProps) {
  var newDescriptor = Object.create(oldDescriptor.constructor.prototype);
  // It's important that this property order matches the hidden class of the
  // original descriptor to maintain perf.
  newDescriptor._owner = oldDescriptor._owner;
  newDescriptor._context = oldDescriptor._context;

  if ("production" !== process.env.NODE_ENV) {
    newDescriptor._store = {
      validated: oldDescriptor._store.validated,
      props: newProps
    };
    if (useMutationMembrane) {
      Object.freeze(newDescriptor);
      return newDescriptor;
    }
  }

  newDescriptor.props = newProps;
  return newDescriptor;
};

/**
 * Checks if a value is a valid descriptor constructor.
 *
 * @param {*}
 * @return {boolean}
 * @public
 */
ReactDescriptor.isValidFactory = function(factory) {
  return typeof factory === 'function' &&
         factory.prototype instanceof ReactDescriptor;
};

/**
 * @param {?object} object
 * @return {boolean} True if `object` is a valid component.
 * @final
 */
ReactDescriptor.isValidDescriptor = function(object) {
  return object instanceof ReactDescriptor;
};

module.exports = ReactDescriptor;

}).call(this,require('_process'))
},{"./ReactContext":117,"./ReactCurrentOwner":118,"./merge":222,"./warning":236,"_process":73}],135:[function(require,module,exports){
/**
 * Copyright 2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactDescriptorValidator
 */

/**
 * ReactDescriptorValidator provides a wrapper around a descriptor factory
 * which validates the props passed to the descriptor. This is intended to be
 * used only in DEV and could be replaced by a static type checker for languages
 * that support it.
 */

"use strict";

var ReactDescriptor = require("./ReactDescriptor");
var ReactPropTypeLocations = require("./ReactPropTypeLocations");
var ReactCurrentOwner = require("./ReactCurrentOwner");

var monitorCodeUse = require("./monitorCodeUse");

/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */
var ownerHasKeyUseWarning = {
  'react_key_warning': {},
  'react_numeric_key_warning': {}
};
var ownerHasMonitoredObjectMap = {};

var loggedTypeFailures = {};

var NUMERIC_PROPERTY_REGEX = /^\d+$/;

/**
 * Gets the current owner's displayName for use in warnings.
 *
 * @internal
 * @return {?string} Display name or undefined
 */
function getCurrentOwnerDisplayName() {
  var current = ReactCurrentOwner.current;
  return current && current.constructor.displayName || undefined;
}

/**
 * Warn if the component doesn't have an explicit key assigned to it.
 * This component is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it.
 *
 * @internal
 * @param {ReactComponent} component Component that requires a key.
 * @param {*} parentType component's parent's type.
 */
function validateExplicitKey(component, parentType) {
  if (component._store.validated || component.props.key != null) {
    return;
  }
  component._store.validated = true;

  warnAndMonitorForKeyUse(
    'react_key_warning',
    'Each child in an array should have a unique "key" prop.',
    component,
    parentType
  );
}

/**
 * Warn if the key is being defined as an object property but has an incorrect
 * value.
 *
 * @internal
 * @param {string} name Property name of the key.
 * @param {ReactComponent} component Component that requires a key.
 * @param {*} parentType component's parent's type.
 */
function validatePropertyKey(name, component, parentType) {
  if (!NUMERIC_PROPERTY_REGEX.test(name)) {
    return;
  }
  warnAndMonitorForKeyUse(
    'react_numeric_key_warning',
    'Child objects should have non-numeric keys so ordering is preserved.',
    component,
    parentType
  );
}

/**
 * Shared warning and monitoring code for the key warnings.
 *
 * @internal
 * @param {string} warningID The id used when logging.
 * @param {string} message The base warning that gets output.
 * @param {ReactComponent} component Component that requires a key.
 * @param {*} parentType component's parent's type.
 */
function warnAndMonitorForKeyUse(warningID, message, component, parentType) {
  var ownerName = getCurrentOwnerDisplayName();
  var parentName = parentType.displayName;

  var useName = ownerName || parentName;
  var memoizer = ownerHasKeyUseWarning[warningID];
  if (memoizer.hasOwnProperty(useName)) {
    return;
  }
  memoizer[useName] = true;

  message += ownerName ?
    (" Check the render method of " + ownerName + ".") :
    (" Check the renderComponent call using <" + parentName + ">.");

  // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.
  var childOwnerName = null;
  if (component._owner && component._owner !== ReactCurrentOwner.current) {
    // Name of the component that originally created this child.
    childOwnerName = component._owner.constructor.displayName;

    message += (" It was passed a child from " + childOwnerName + ".");
  }

  message += ' See http://fb.me/react-warning-keys for more information.';
  monitorCodeUse(warningID, {
    component: useName,
    componentOwner: childOwnerName
  });
  console.warn(message);
}

/**
 * Log that we're using an object map. We're considering deprecating this
 * feature and replace it with proper Map and ImmutableMap data structures.
 *
 * @internal
 */
function monitorUseOfObjectMap() {
  var currentName = getCurrentOwnerDisplayName() || '';
  if (ownerHasMonitoredObjectMap.hasOwnProperty(currentName)) {
    return;
  }
  ownerHasMonitoredObjectMap[currentName] = true;
  monitorCodeUse('react_object_map_children');
}

/**
 * Ensure that every component either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {*} component Statically passed child of any type.
 * @param {*} parentType component's parent's type.
 * @return {boolean}
 */
function validateChildKeys(component, parentType) {
  if (Array.isArray(component)) {
    for (var i = 0; i < component.length; i++) {
      var child = component[i];
      if (ReactDescriptor.isValidDescriptor(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (ReactDescriptor.isValidDescriptor(component)) {
    // This component was passed in a valid location.
    component._store.validated = true;
  } else if (component && typeof component === 'object') {
    monitorUseOfObjectMap();
    for (var name in component) {
      validatePropertyKey(name, component[name], parentType);
    }
  }
}

/**
 * Assert that the props are valid
 *
 * @param {string} componentName Name of the component for error messages.
 * @param {object} propTypes Map of prop name to a ReactPropType
 * @param {object} props
 * @param {string} location e.g. "prop", "context", "child context"
 * @private
 */
function checkPropTypes(componentName, propTypes, props, location) {
  for (var propName in propTypes) {
    if (propTypes.hasOwnProperty(propName)) {
      var error;
      // Prop type validation may throw. In case they do, we don't want to
      // fail the render phase where it didn't fail before. So we log it.
      // After these have been cleaned up, we'll let them throw.
      try {
        error = propTypes[propName](props, propName, componentName, location);
      } catch (ex) {
        error = ex;
      }
      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
        // Only monitor this failure once because there tends to be a lot of the
        // same error.
        loggedTypeFailures[error.message] = true;
        // This will soon use the warning module
        monitorCodeUse(
          'react_failed_descriptor_type_check',
          { message: error.message }
        );
      }
    }
  }
}

var ReactDescriptorValidator = {

  /**
   * Wraps a descriptor factory function in another function which validates
   * the props and context of the descriptor and warns about any failed type
   * checks.
   *
   * @param {function} factory The original descriptor factory
   * @param {object?} propTypes A prop type definition set
   * @param {object?} contextTypes A context type definition set
   * @return {object} The component descriptor, which may be invalid.
   * @private
   */
  createFactory: function(factory, propTypes, contextTypes) {
    var validatedFactory = function(props, children) {
      var descriptor = factory.apply(this, arguments);

      for (var i = 1; i < arguments.length; i++) {
        validateChildKeys(arguments[i], descriptor.type);
      }

      var name = descriptor.type.displayName;
      if (propTypes) {
        checkPropTypes(
          name,
          propTypes,
          descriptor.props,
          ReactPropTypeLocations.prop
        );
      }
      if (contextTypes) {
        checkPropTypes(
          name,
          contextTypes,
          descriptor._context,
          ReactPropTypeLocations.context
        );
      }
      return descriptor;
    };

    validatedFactory.prototype = factory.prototype;
    validatedFactory.type = factory.type;

    // Copy static properties
    for (var key in factory) {
      if (factory.hasOwnProperty(key)) {
        validatedFactory[key] = factory[key];
      }
    }

    return validatedFactory;
  }

};

module.exports = ReactDescriptorValidator;

},{"./ReactCurrentOwner":118,"./ReactDescriptor":134,"./ReactPropTypeLocations":152,"./monitorCodeUse":226}],136:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactEmptyComponent
 */

"use strict";

var invariant = require("./invariant");

var component;
// This registry keeps track of the React IDs of the components that rendered to
// `null` (in reality a placeholder such as `noscript`)
var nullComponentIdsRegistry = {};

var ReactEmptyComponentInjection = {
  injectEmptyComponent: function(emptyComponent) {
    component = emptyComponent;
  }
};

/**
 * @return {ReactComponent} component The injected empty component.
 */
function getEmptyComponent() {
  ("production" !== process.env.NODE_ENV ? invariant(
    component,
    'Trying to return null from a render, but no null placeholder component ' +
    'was injected.'
  ) : invariant(component));
  return component();
}

/**
 * Mark the component as having rendered to null.
 * @param {string} id Component's `_rootNodeID`.
 */
function registerNullComponentID(id) {
  nullComponentIdsRegistry[id] = true;
}

/**
 * Unmark the component as having rendered to null: it renders to something now.
 * @param {string} id Component's `_rootNodeID`.
 */
function deregisterNullComponentID(id) {
  delete nullComponentIdsRegistry[id];
}

/**
 * @param {string} id Component's `_rootNodeID`.
 * @return {boolean} True if the component is rendered to null.
 */
function isNullComponentID(id) {
  return nullComponentIdsRegistry[id];
}

var ReactEmptyComponent = {
  deregisterNullComponentID: deregisterNullComponentID,
  getEmptyComponent: getEmptyComponent,
  injection: ReactEmptyComponentInjection,
  isNullComponentID: isNullComponentID,
  registerNullComponentID: registerNullComponentID
};

module.exports = ReactEmptyComponent;

}).call(this,require('_process'))
},{"./invariant":212,"_process":73}],137:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactErrorUtils
 * @typechecks
 */

"use strict";

var ReactErrorUtils = {
  /**
   * Creates a guarded version of a function. This is supposed to make debugging
   * of event handlers easier. To aid debugging with the browser's debugger,
   * this currently simply returns the original function.
   *
   * @param {function} func Function to be executed
   * @param {string} name The name of the guard
   * @return {function}
   */
  guard: function(func, name) {
    return func;
  }
};

module.exports = ReactErrorUtils;

},{}],138:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactEventEmitterMixin
 */

"use strict";

var EventPluginHub = require("./EventPluginHub");

function runEventQueueInBatch(events) {
  EventPluginHub.enqueueEvents(events);
  EventPluginHub.processEventQueue();
}

var ReactEventEmitterMixin = {

  /**
   * Streams a fired top-level event to `EventPluginHub` where plugins have the
   * opportunity to create `ReactEvent`s to be dispatched.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {object} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native environment event.
   */
  handleTopLevel: function(
      topLevelType,
      topLevelTarget,
      topLevelTargetID,
      nativeEvent) {
    var events = EventPluginHub.extractEvents(
      topLevelType,
      topLevelTarget,
      topLevelTargetID,
      nativeEvent
    );

    runEventQueueInBatch(events);
  }
};

module.exports = ReactEventEmitterMixin;

},{"./EventPluginHub":96}],139:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactEventListener
 * @typechecks static-only
 */

"use strict";

var EventListener = require("./EventListener");
var ExecutionEnvironment = require("./ExecutionEnvironment");
var PooledClass = require("./PooledClass");
var ReactInstanceHandles = require("./ReactInstanceHandles");
var ReactMount = require("./ReactMount");
var ReactUpdates = require("./ReactUpdates");

var getEventTarget = require("./getEventTarget");
var getUnboundedScrollPosition = require("./getUnboundedScrollPosition");
var mixInto = require("./mixInto");

/**
 * Finds the parent React component of `node`.
 *
 * @param {*} node
 * @return {?DOMEventTarget} Parent container, or `null` if the specified node
 *                           is not nested.
 */
function findParent(node) {
  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
  // traversal, but caching is difficult to do correctly without using a
  // mutation observer to listen for all DOM changes.
  var nodeID = ReactMount.getID(node);
  var rootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);
  var container = ReactMount.findReactContainerForID(rootID);
  var parent = ReactMount.getFirstReactDOM(container);
  return parent;
}

// Used to store ancestor hierarchy in top level callback
function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
  this.topLevelType = topLevelType;
  this.nativeEvent = nativeEvent;
  this.ancestors = [];
}
mixInto(TopLevelCallbackBookKeeping, {
  destructor: function() {
    this.topLevelType = null;
    this.nativeEvent = null;
    this.ancestors.length = 0;
  }
});
PooledClass.addPoolingTo(
  TopLevelCallbackBookKeeping,
  PooledClass.twoArgumentPooler
);

function handleTopLevelImpl(bookKeeping) {
  var topLevelTarget = ReactMount.getFirstReactDOM(
    getEventTarget(bookKeeping.nativeEvent)
  ) || window;

  // Loop through the hierarchy, in case there's any nested components.
  // It's important that we build the array of ancestors before calling any
  // event handlers, because event handlers can modify the DOM, leading to
  // inconsistencies with ReactMount's node cache. See #1105.
  var ancestor = topLevelTarget;
  while (ancestor) {
    bookKeeping.ancestors.push(ancestor);
    ancestor = findParent(ancestor);
  }

  for (var i = 0, l = bookKeeping.ancestors.length; i < l; i++) {
    topLevelTarget = bookKeeping.ancestors[i];
    var topLevelTargetID = ReactMount.getID(topLevelTarget) || '';
    ReactEventListener._handleTopLevel(
      bookKeeping.topLevelType,
      topLevelTarget,
      topLevelTargetID,
      bookKeeping.nativeEvent
    );
  }
}

function scrollValueMonitor(cb) {
  var scrollPosition = getUnboundedScrollPosition(window);
  cb(scrollPosition);
}

var ReactEventListener = {
  _enabled: true,
  _handleTopLevel: null,

  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,

  setHandleTopLevel: function(handleTopLevel) {
    ReactEventListener._handleTopLevel = handleTopLevel;
  },

  setEnabled: function(enabled) {
    ReactEventListener._enabled = !!enabled;
  },

  isEnabled: function() {
    return ReactEventListener._enabled;
  },


  /**
   * Traps top-level events by using event bubbling.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {string} handlerBaseName Event name (e.g. "click").
   * @param {object} handle Element on which to attach listener.
   * @return {object} An object with a remove function which will forcefully
   *                  remove the listener.
   * @internal
   */
  trapBubbledEvent: function(topLevelType, handlerBaseName, handle) {
    var element = handle;
    if (!element) {
      return;
    }
    return EventListener.listen(
      element,
      handlerBaseName,
      ReactEventListener.dispatchEvent.bind(null, topLevelType)
    );
  },

  /**
   * Traps a top-level event by using event capturing.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {string} handlerBaseName Event name (e.g. "click").
   * @param {object} handle Element on which to attach listener.
   * @return {object} An object with a remove function which will forcefully
   *                  remove the listener.
   * @internal
   */
  trapCapturedEvent: function(topLevelType, handlerBaseName, handle) {
    var element = handle;
    if (!element) {
      return;
    }
    return EventListener.capture(
      element,
      handlerBaseName,
      ReactEventListener.dispatchEvent.bind(null, topLevelType)
    );
  },

  monitorScrollValue: function(refresh) {
    var callback = scrollValueMonitor.bind(null, refresh);
    EventListener.listen(window, 'scroll', callback);
    EventListener.listen(window, 'resize', callback);
  },

  dispatchEvent: function(topLevelType, nativeEvent) {
    if (!ReactEventListener._enabled) {
      return;
    }

    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(
      topLevelType,
      nativeEvent
    );
    try {
      // Event queue being processed in the same cycle allows
      // `preventDefault`.
      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
    } finally {
      TopLevelCallbackBookKeeping.release(bookKeeping);
    }
  }
};

module.exports = ReactEventListener;

},{"./EventListener":95,"./ExecutionEnvironment":100,"./PooledClass":106,"./ReactInstanceHandles":142,"./ReactMount":145,"./ReactUpdates":165,"./getEventTarget":203,"./getUnboundedScrollPosition":208,"./mixInto":225}],140:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactInjection
 */

"use strict";

var DOMProperty = require("./DOMProperty");
var EventPluginHub = require("./EventPluginHub");
var ReactComponent = require("./ReactComponent");
var ReactCompositeComponent = require("./ReactCompositeComponent");
var ReactDOM = require("./ReactDOM");
var ReactEmptyComponent = require("./ReactEmptyComponent");
var ReactBrowserEventEmitter = require("./ReactBrowserEventEmitter");
var ReactPerf = require("./ReactPerf");
var ReactRootIndex = require("./ReactRootIndex");
var ReactUpdates = require("./ReactUpdates");

var ReactInjection = {
  Component: ReactComponent.injection,
  CompositeComponent: ReactCompositeComponent.injection,
  DOMProperty: DOMProperty.injection,
  EmptyComponent: ReactEmptyComponent.injection,
  EventPluginHub: EventPluginHub.injection,
  DOM: ReactDOM.injection,
  EventEmitter: ReactBrowserEventEmitter.injection,
  Perf: ReactPerf.injection,
  RootIndex: ReactRootIndex.injection,
  Updates: ReactUpdates.injection
};

module.exports = ReactInjection;

},{"./DOMProperty":89,"./EventPluginHub":96,"./ReactBrowserEventEmitter":109,"./ReactComponent":113,"./ReactCompositeComponent":116,"./ReactDOM":119,"./ReactEmptyComponent":136,"./ReactPerf":149,"./ReactRootIndex":156,"./ReactUpdates":165}],141:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactInputSelection
 */

"use strict";

var ReactDOMSelection = require("./ReactDOMSelection");

var containsNode = require("./containsNode");
var focusNode = require("./focusNode");
var getActiveElement = require("./getActiveElement");

function isInDocument(node) {
  return containsNode(document.documentElement, node);
}

/**
 * @ReactInputSelection: React input selection module. Based on Selection.js,
 * but modified to be suitable for react and has a couple of bug fixes (doesn't
 * assume buttons have range selections allowed).
 * Input selection module for React.
 */
var ReactInputSelection = {

  hasSelectionCapabilities: function(elem) {
    return elem && (
      (elem.nodeName === 'INPUT' && elem.type === 'text') ||
      elem.nodeName === 'TEXTAREA' ||
      elem.contentEditable === 'true'
    );
  },

  getSelectionInformation: function() {
    var focusedElem = getActiveElement();
    return {
      focusedElem: focusedElem,
      selectionRange:
          ReactInputSelection.hasSelectionCapabilities(focusedElem) ?
          ReactInputSelection.getSelection(focusedElem) :
          null
    };
  },

  /**
   * @restoreSelection: If any selection information was potentially lost,
   * restore it. This is useful when performing operations that could remove dom
   * nodes and place them back in, resulting in focus being lost.
   */
  restoreSelection: function(priorSelectionInformation) {
    var curFocusedElem = getActiveElement();
    var priorFocusedElem = priorSelectionInformation.focusedElem;
    var priorSelectionRange = priorSelectionInformation.selectionRange;
    if (curFocusedElem !== priorFocusedElem &&
        isInDocument(priorFocusedElem)) {
      if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
        ReactInputSelection.setSelection(
          priorFocusedElem,
          priorSelectionRange
        );
      }
      focusNode(priorFocusedElem);
    }
  },

  /**
   * @getSelection: Gets the selection bounds of a focused textarea, input or
   * contentEditable node.
   * -@input: Look up selection bounds of this input
   * -@return {start: selectionStart, end: selectionEnd}
   */
  getSelection: function(input) {
    var selection;

    if ('selectionStart' in input) {
      // Modern browser with input or textarea.
      selection = {
        start: input.selectionStart,
        end: input.selectionEnd
      };
    } else if (document.selection && input.nodeName === 'INPUT') {
      // IE8 input.
      var range = document.selection.createRange();
      // There can only be one selection per document in IE, so it must
      // be in our element.
      if (range.parentElement() === input) {
        selection = {
          start: -range.moveStart('character', -input.value.length),
          end: -range.moveEnd('character', -input.value.length)
        };
      }
    } else {
      // Content editable or old IE textarea.
      selection = ReactDOMSelection.getOffsets(input);
    }

    return selection || {start: 0, end: 0};
  },

  /**
   * @setSelection: Sets the selection bounds of a textarea or input and focuses
   * the input.
   * -@input     Set selection bounds of this input or textarea
   * -@offsets   Object of same form that is returned from get*
   */
  setSelection: function(input, offsets) {
    var start = offsets.start;
    var end = offsets.end;
    if (typeof end === 'undefined') {
      end = start;
    }

    if ('selectionStart' in input) {
      input.selectionStart = start;
      input.selectionEnd = Math.min(end, input.value.length);
    } else if (document.selection && input.nodeName === 'INPUT') {
      var range = input.createTextRange();
      range.collapse(true);
      range.moveStart('character', start);
      range.moveEnd('character', end - start);
      range.select();
    } else {
      ReactDOMSelection.setOffsets(input, offsets);
    }
  }
};

module.exports = ReactInputSelection;

},{"./ReactDOMSelection":128,"./containsNode":187,"./focusNode":198,"./getActiveElement":200}],142:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactInstanceHandles
 * @typechecks static-only
 */

"use strict";

var ReactRootIndex = require("./ReactRootIndex");

var invariant = require("./invariant");

var SEPARATOR = '.';
var SEPARATOR_LENGTH = SEPARATOR.length;

/**
 * Maximum depth of traversals before we consider the possibility of a bad ID.
 */
var MAX_TREE_DEPTH = 100;

/**
 * Creates a DOM ID prefix to use when mounting React components.
 *
 * @param {number} index A unique integer
 * @return {string} React root ID.
 * @internal
 */
function getReactRootIDString(index) {
  return SEPARATOR + index.toString(36);
}

/**
 * Checks if a character in the supplied ID is a separator or the end.
 *
 * @param {string} id A React DOM ID.
 * @param {number} index Index of the character to check.
 * @return {boolean} True if the character is a separator or end of the ID.
 * @private
 */
function isBoundary(id, index) {
  return id.charAt(index) === SEPARATOR || index === id.length;
}

/**
 * Checks if the supplied string is a valid React DOM ID.
 *
 * @param {string} id A React DOM ID, maybe.
 * @return {boolean} True if the string is a valid React DOM ID.
 * @private
 */
function isValidID(id) {
  return id === '' || (
    id.charAt(0) === SEPARATOR && id.charAt(id.length - 1) !== SEPARATOR
  );
}

/**
 * Checks if the first ID is an ancestor of or equal to the second ID.
 *
 * @param {string} ancestorID
 * @param {string} descendantID
 * @return {boolean} True if `ancestorID` is an ancestor of `descendantID`.
 * @internal
 */
function isAncestorIDOf(ancestorID, descendantID) {
  return (
    descendantID.indexOf(ancestorID) === 0 &&
    isBoundary(descendantID, ancestorID.length)
  );
}

/**
 * Gets the parent ID of the supplied React DOM ID, `id`.
 *
 * @param {string} id ID of a component.
 * @return {string} ID of the parent, or an empty string.
 * @private
 */
function getParentID(id) {
  return id ? id.substr(0, id.lastIndexOf(SEPARATOR)) : '';
}

/**
 * Gets the next DOM ID on the tree path from the supplied `ancestorID` to the
 * supplied `destinationID`. If they are equal, the ID is returned.
 *
 * @param {string} ancestorID ID of an ancestor node of `destinationID`.
 * @param {string} destinationID ID of the destination node.
 * @return {string} Next ID on the path from `ancestorID` to `destinationID`.
 * @private
 */
function getNextDescendantID(ancestorID, destinationID) {
  ("production" !== process.env.NODE_ENV ? invariant(
    isValidID(ancestorID) && isValidID(destinationID),
    'getNextDescendantID(%s, %s): Received an invalid React DOM ID.',
    ancestorID,
    destinationID
  ) : invariant(isValidID(ancestorID) && isValidID(destinationID)));
  ("production" !== process.env.NODE_ENV ? invariant(
    isAncestorIDOf(ancestorID, destinationID),
    'getNextDescendantID(...): React has made an invalid assumption about ' +
    'the DOM hierarchy. Expected `%s` to be an ancestor of `%s`.',
    ancestorID,
    destinationID
  ) : invariant(isAncestorIDOf(ancestorID, destinationID)));
  if (ancestorID === destinationID) {
    return ancestorID;
  }
  // Skip over the ancestor and the immediate separator. Traverse until we hit
  // another separator or we reach the end of `destinationID`.
  var start = ancestorID.length + SEPARATOR_LENGTH;
  for (var i = start; i < destinationID.length; i++) {
    if (isBoundary(destinationID, i)) {
      break;
    }
  }
  return destinationID.substr(0, i);
}

/**
 * Gets the nearest common ancestor ID of two IDs.
 *
 * Using this ID scheme, the nearest common ancestor ID is the longest common
 * prefix of the two IDs that immediately preceded a "marker" in both strings.
 *
 * @param {string} oneID
 * @param {string} twoID
 * @return {string} Nearest common ancestor ID, or the empty string if none.
 * @private
 */
function getFirstCommonAncestorID(oneID, twoID) {
  var minLength = Math.min(oneID.length, twoID.length);
  if (minLength === 0) {
    return '';
  }
  var lastCommonMarkerIndex = 0;
  // Use `<=` to traverse until the "EOL" of the shorter string.
  for (var i = 0; i <= minLength; i++) {
    if (isBoundary(oneID, i) && isBoundary(twoID, i)) {
      lastCommonMarkerIndex = i;
    } else if (oneID.charAt(i) !== twoID.charAt(i)) {
      break;
    }
  }
  var longestCommonID = oneID.substr(0, lastCommonMarkerIndex);
  ("production" !== process.env.NODE_ENV ? invariant(
    isValidID(longestCommonID),
    'getFirstCommonAncestorID(%s, %s): Expected a valid React DOM ID: %s',
    oneID,
    twoID,
    longestCommonID
  ) : invariant(isValidID(longestCommonID)));
  return longestCommonID;
}

/**
 * Traverses the parent path between two IDs (either up or down). The IDs must
 * not be the same, and there must exist a parent path between them. If the
 * callback returns `false`, traversal is stopped.
 *
 * @param {?string} start ID at which to start traversal.
 * @param {?string} stop ID at which to end traversal.
 * @param {function} cb Callback to invoke each ID with.
 * @param {?boolean} skipFirst Whether or not to skip the first node.
 * @param {?boolean} skipLast Whether or not to skip the last node.
 * @private
 */
function traverseParentPath(start, stop, cb, arg, skipFirst, skipLast) {
  start = start || '';
  stop = stop || '';
  ("production" !== process.env.NODE_ENV ? invariant(
    start !== stop,
    'traverseParentPath(...): Cannot traverse from and to the same ID, `%s`.',
    start
  ) : invariant(start !== stop));
  var traverseUp = isAncestorIDOf(stop, start);
  ("production" !== process.env.NODE_ENV ? invariant(
    traverseUp || isAncestorIDOf(start, stop),
    'traverseParentPath(%s, %s, ...): Cannot traverse from two IDs that do ' +
    'not have a parent path.',
    start,
    stop
  ) : invariant(traverseUp || isAncestorIDOf(start, stop)));
  // Traverse from `start` to `stop` one depth at a time.
  var depth = 0;
  var traverse = traverseUp ? getParentID : getNextDescendantID;
  for (var id = start; /* until break */; id = traverse(id, stop)) {
    var ret;
    if ((!skipFirst || id !== start) && (!skipLast || id !== stop)) {
      ret = cb(id, traverseUp, arg);
    }
    if (ret === false || id === stop) {
      // Only break //after// visiting `stop`.
      break;
    }
    ("production" !== process.env.NODE_ENV ? invariant(
      depth++ < MAX_TREE_DEPTH,
      'traverseParentPath(%s, %s, ...): Detected an infinite loop while ' +
      'traversing the React DOM ID tree. This may be due to malformed IDs: %s',
      start, stop
    ) : invariant(depth++ < MAX_TREE_DEPTH));
  }
}

/**
 * Manages the IDs assigned to DOM representations of React components. This
 * uses a specific scheme in order to traverse the DOM efficiently (e.g. in
 * order to simulate events).
 *
 * @internal
 */
var ReactInstanceHandles = {

  /**
   * Constructs a React root ID
   * @return {string} A React root ID.
   */
  createReactRootID: function() {
    return getReactRootIDString(ReactRootIndex.createReactRootIndex());
  },

  /**
   * Constructs a React ID by joining a root ID with a name.
   *
   * @param {string} rootID Root ID of a parent component.
   * @param {string} name A component's name (as flattened children).
   * @return {string} A React ID.
   * @internal
   */
  createReactID: function(rootID, name) {
    return rootID + name;
  },

  /**
   * Gets the DOM ID of the React component that is the root of the tree that
   * contains the React component with the supplied DOM ID.
   *
   * @param {string} id DOM ID of a React component.
   * @return {?string} DOM ID of the React component that is the root.
   * @internal
   */
  getReactRootIDFromNodeID: function(id) {
    if (id && id.charAt(0) === SEPARATOR && id.length > 1) {
      var index = id.indexOf(SEPARATOR, 1);
      return index > -1 ? id.substr(0, index) : id;
    }
    return null;
  },

  /**
   * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
   * should would receive a `mouseEnter` or `mouseLeave` event.
   *
   * NOTE: Does not invoke the callback on the nearest common ancestor because
   * nothing "entered" or "left" that element.
   *
   * @param {string} leaveID ID being left.
   * @param {string} enterID ID being entered.
   * @param {function} cb Callback to invoke on each entered/left ID.
   * @param {*} upArg Argument to invoke the callback with on left IDs.
   * @param {*} downArg Argument to invoke the callback with on entered IDs.
   * @internal
   */
  traverseEnterLeave: function(leaveID, enterID, cb, upArg, downArg) {
    var ancestorID = getFirstCommonAncestorID(leaveID, enterID);
    if (ancestorID !== leaveID) {
      traverseParentPath(leaveID, ancestorID, cb, upArg, false, true);
    }
    if (ancestorID !== enterID) {
      traverseParentPath(ancestorID, enterID, cb, downArg, true, false);
    }
  },

  /**
   * Simulates the traversal of a two-phase, capture/bubble event dispatch.
   *
   * NOTE: This traversal happens on IDs without touching the DOM.
   *
   * @param {string} targetID ID of the target node.
   * @param {function} cb Callback to invoke.
   * @param {*} arg Argument to invoke the callback with.
   * @internal
   */
  traverseTwoPhase: function(targetID, cb, arg) {
    if (targetID) {
      traverseParentPath('', targetID, cb, arg, true, false);
      traverseParentPath(targetID, '', cb, arg, false, true);
    }
  },

  /**
   * Traverse a node ID, calling the supplied `cb` for each ancestor ID. For
   * example, passing `.0.$row-0.1` would result in `cb` getting called
   * with `.0`, `.0.$row-0`, and `.0.$row-0.1`.
   *
   * NOTE: This traversal happens on IDs without touching the DOM.
   *
   * @param {string} targetID ID of the target node.
   * @param {function} cb Callback to invoke.
   * @param {*} arg Argument to invoke the callback with.
   * @internal
   */
  traverseAncestors: function(targetID, cb, arg) {
    traverseParentPath('', targetID, cb, arg, true, false);
  },

  /**
   * Exposed for unit testing.
   * @private
   */
  _getFirstCommonAncestorID: getFirstCommonAncestorID,

  /**
   * Exposed for unit testing.
   * @private
   */
  _getNextDescendantID: getNextDescendantID,

  isAncestorIDOf: isAncestorIDOf,

  SEPARATOR: SEPARATOR

};

module.exports = ReactInstanceHandles;

}).call(this,require('_process'))
},{"./ReactRootIndex":156,"./invariant":212,"_process":73}],143:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactLink
 * @typechecks static-only
 */

"use strict";

/**
 * ReactLink encapsulates a common pattern in which a component wants to modify
 * a prop received from its parent. ReactLink allows the parent to pass down a
 * value coupled with a callback that, when invoked, expresses an intent to
 * modify that value. For example:
 *
 * React.createClass({
 *   getInitialState: function() {
 *     return {value: ''};
 *   },
 *   render: function() {
 *     var valueLink = new ReactLink(this.state.value, this._handleValueChange);
 *     return <input valueLink={valueLink} />;
 *   },
 *   this._handleValueChange: function(newValue) {
 *     this.setState({value: newValue});
 *   }
 * });
 *
 * We have provided some sugary mixins to make the creation and
 * consumption of ReactLink easier; see LinkedValueUtils and LinkedStateMixin.
 */

var React = require("./React");

/**
 * @param {*} value current value of the link
 * @param {function} requestChange callback to request a change
 */
function ReactLink(value, requestChange) {
  this.value = value;
  this.requestChange = requestChange;
}

/**
 * Creates a PropType that enforces the ReactLink API and optionally checks the
 * type of the value being passed inside the link. Example:
 *
 * MyComponent.propTypes = {
 *   tabIndexLink: ReactLink.PropTypes.link(React.PropTypes.number)
 * }
 */
function createLinkTypeChecker(linkType) {
  var shapes = {
    value: typeof linkType === 'undefined' ?
      React.PropTypes.any.isRequired :
      linkType.isRequired,
    requestChange: React.PropTypes.func.isRequired
  };
  return React.PropTypes.shape(shapes);
}

ReactLink.PropTypes = {
  link: createLinkTypeChecker
};

module.exports = ReactLink;

},{"./React":107}],144:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactMarkupChecksum
 */

"use strict";

var adler32 = require("./adler32");

var ReactMarkupChecksum = {
  CHECKSUM_ATTR_NAME: 'data-react-checksum',

  /**
   * @param {string} markup Markup string
   * @return {string} Markup string with checksum attribute attached
   */
  addChecksumToMarkup: function(markup) {
    var checksum = adler32(markup);
    return markup.replace(
      '>',
      ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '">'
    );
  },

  /**
   * @param {string} markup to use
   * @param {DOMElement} element root React element
   * @returns {boolean} whether or not the markup is the same
   */
  canReuseMarkup: function(markup, element) {
    var existingChecksum = element.getAttribute(
      ReactMarkupChecksum.CHECKSUM_ATTR_NAME
    );
    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
    var markupChecksum = adler32(markup);
    return markupChecksum === existingChecksum;
  }
};

module.exports = ReactMarkupChecksum;

},{"./adler32":185}],145:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactMount
 */

"use strict";

var DOMProperty = require("./DOMProperty");
var ReactBrowserEventEmitter = require("./ReactBrowserEventEmitter");
var ReactCurrentOwner = require("./ReactCurrentOwner");
var ReactDescriptor = require("./ReactDescriptor");
var ReactInstanceHandles = require("./ReactInstanceHandles");
var ReactPerf = require("./ReactPerf");

var containsNode = require("./containsNode");
var getReactRootElementInContainer = require("./getReactRootElementInContainer");
var instantiateReactComponent = require("./instantiateReactComponent");
var invariant = require("./invariant");
var shouldUpdateReactComponent = require("./shouldUpdateReactComponent");
var warning = require("./warning");

var SEPARATOR = ReactInstanceHandles.SEPARATOR;

var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
var nodeCache = {};

var ELEMENT_NODE_TYPE = 1;
var DOC_NODE_TYPE = 9;

/** Mapping from reactRootID to React component instance. */
var instancesByReactRootID = {};

/** Mapping from reactRootID to `container` nodes. */
var containersByReactRootID = {};

if ("production" !== process.env.NODE_ENV) {
  /** __DEV__-only mapping from reactRootID to root elements. */
  var rootElementsByReactRootID = {};
}

// Used to store breadth-first search state in findComponentRoot.
var findComponentRootReusableArray = [];

/**
 * @param {DOMElement} container DOM element that may contain a React component.
 * @return {?string} A "reactRoot" ID, if a React component is rendered.
 */
function getReactRootID(container) {
  var rootElement = getReactRootElementInContainer(container);
  return rootElement && ReactMount.getID(rootElement);
}

/**
 * Accessing node[ATTR_NAME] or calling getAttribute(ATTR_NAME) on a form
 * element can return its control whose name or ID equals ATTR_NAME. All
 * DOM nodes support `getAttributeNode` but this can also get called on
 * other objects so just return '' if we're given something other than a
 * DOM node (such as window).
 *
 * @param {?DOMElement|DOMWindow|DOMDocument|DOMTextNode} node DOM node.
 * @return {string} ID of the supplied `domNode`.
 */
function getID(node) {
  var id = internalGetID(node);
  if (id) {
    if (nodeCache.hasOwnProperty(id)) {
      var cached = nodeCache[id];
      if (cached !== node) {
        ("production" !== process.env.NODE_ENV ? invariant(
          !isValid(cached, id),
          'ReactMount: Two valid but unequal nodes with the same `%s`: %s',
          ATTR_NAME, id
        ) : invariant(!isValid(cached, id)));

        nodeCache[id] = node;
      }
    } else {
      nodeCache[id] = node;
    }
  }

  return id;
}

function internalGetID(node) {
  // If node is something like a window, document, or text node, none of
  // which support attributes or a .getAttribute method, gracefully return
  // the empty string, as if the attribute were missing.
  return node && node.getAttribute && node.getAttribute(ATTR_NAME) || '';
}

/**
 * Sets the React-specific ID of the given node.
 *
 * @param {DOMElement} node The DOM node whose ID will be set.
 * @param {string} id The value of the ID attribute.
 */
function setID(node, id) {
  var oldID = internalGetID(node);
  if (oldID !== id) {
    delete nodeCache[oldID];
  }
  node.setAttribute(ATTR_NAME, id);
  nodeCache[id] = node;
}

/**
 * Finds the node with the supplied React-generated DOM ID.
 *
 * @param {string} id A React-generated DOM ID.
 * @return {DOMElement} DOM node with the suppled `id`.
 * @internal
 */
function getNode(id) {
  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
    nodeCache[id] = ReactMount.findReactNodeByID(id);
  }
  return nodeCache[id];
}

/**
 * A node is "valid" if it is contained by a currently mounted container.
 *
 * This means that the node does not have to be contained by a document in
 * order to be considered valid.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @param {string} id The expected ID of the node.
 * @return {boolean} Whether the node is contained by a mounted container.
 */
function isValid(node, id) {
  if (node) {
    ("production" !== process.env.NODE_ENV ? invariant(
      internalGetID(node) === id,
      'ReactMount: Unexpected modification of `%s`',
      ATTR_NAME
    ) : invariant(internalGetID(node) === id));

    var container = ReactMount.findReactContainerForID(id);
    if (container && containsNode(container, node)) {
      return true;
    }
  }

  return false;
}

/**
 * Causes the cache to forget about one React-specific ID.
 *
 * @param {string} id The ID to forget.
 */
function purgeID(id) {
  delete nodeCache[id];
}

var deepestNodeSoFar = null;
function findDeepestCachedAncestorImpl(ancestorID) {
  var ancestor = nodeCache[ancestorID];
  if (ancestor && isValid(ancestor, ancestorID)) {
    deepestNodeSoFar = ancestor;
  } else {
    // This node isn't populated in the cache, so presumably none of its
    // descendants are. Break out of the loop.
    return false;
  }
}

/**
 * Return the deepest cached node whose ID is a prefix of `targetID`.
 */
function findDeepestCachedAncestor(targetID) {
  deepestNodeSoFar = null;
  ReactInstanceHandles.traverseAncestors(
    targetID,
    findDeepestCachedAncestorImpl
  );

  var foundNode = deepestNodeSoFar;
  deepestNodeSoFar = null;
  return foundNode;
}

/**
 * Mounting is the process of initializing a React component by creatings its
 * representative DOM elements and inserting them into a supplied `container`.
 * Any prior content inside `container` is destroyed in the process.
 *
 *   ReactMount.renderComponent(
 *     component,
 *     document.getElementById('container')
 *   );
 *
 *   <div id="container">                   <-- Supplied `container`.
 *     <div data-reactid=".3">              <-- Rendered reactRoot of React
 *       // ...                                 component.
 *     </div>
 *   </div>
 *
 * Inside of `container`, the first element rendered is the "reactRoot".
 */
var ReactMount = {
  /** Exposed for debugging purposes **/
  _instancesByReactRootID: instancesByReactRootID,

  /**
   * This is a hook provided to support rendering React components while
   * ensuring that the apparent scroll position of its `container` does not
   * change.
   *
   * @param {DOMElement} container The `container` being rendered into.
   * @param {function} renderCallback This must be called once to do the render.
   */
  scrollMonitor: function(container, renderCallback) {
    renderCallback();
  },

  /**
   * Take a component that's already mounted into the DOM and replace its props
   * @param {ReactComponent} prevComponent component instance already in the DOM
   * @param {ReactComponent} nextComponent component instance to render
   * @param {DOMElement} container container to render into
   * @param {?function} callback function triggered on completion
   */
  _updateRootComponent: function(
      prevComponent,
      nextComponent,
      container,
      callback) {
    var nextProps = nextComponent.props;
    ReactMount.scrollMonitor(container, function() {
      prevComponent.replaceProps(nextProps, callback);
    });

    if ("production" !== process.env.NODE_ENV) {
      // Record the root element in case it later gets transplanted.
      rootElementsByReactRootID[getReactRootID(container)] =
        getReactRootElementInContainer(container);
    }

    return prevComponent;
  },

  /**
   * Register a component into the instance map and starts scroll value
   * monitoring
   * @param {ReactComponent} nextComponent component instance to render
   * @param {DOMElement} container container to render into
   * @return {string} reactRoot ID prefix
   */
  _registerComponent: function(nextComponent, container) {
    ("production" !== process.env.NODE_ENV ? invariant(
      container && (
        container.nodeType === ELEMENT_NODE_TYPE ||
        container.nodeType === DOC_NODE_TYPE
      ),
      '_registerComponent(...): Target container is not a DOM element.'
    ) : invariant(container && (
      container.nodeType === ELEMENT_NODE_TYPE ||
      container.nodeType === DOC_NODE_TYPE
    )));

    ReactBrowserEventEmitter.ensureScrollValueMonitoring();

    var reactRootID = ReactMount.registerContainer(container);
    instancesByReactRootID[reactRootID] = nextComponent;
    return reactRootID;
  },

  /**
   * Render a new component into the DOM.
   * @param {ReactComponent} nextComponent component instance to render
   * @param {DOMElement} container container to render into
   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion
   * @return {ReactComponent} nextComponent
   */
  _renderNewRootComponent: ReactPerf.measure(
    'ReactMount',
    '_renderNewRootComponent',
    function(
        nextComponent,
        container,
        shouldReuseMarkup) {
      // Various parts of our code (such as ReactCompositeComponent's
      // _renderValidatedComponent) assume that calls to render aren't nested;
      // verify that that's the case.
      ("production" !== process.env.NODE_ENV ? warning(
        ReactCurrentOwner.current == null,
        '_renderNewRootComponent(): Render methods should be a pure function ' +
        'of props and state; triggering nested component updates from ' +
        'render is not allowed. If necessary, trigger nested updates in ' +
        'componentDidUpdate.'
      ) : null);

      var componentInstance = instantiateReactComponent(nextComponent);
      var reactRootID = ReactMount._registerComponent(
        componentInstance,
        container
      );
      componentInstance.mountComponentIntoNode(
        reactRootID,
        container,
        shouldReuseMarkup
      );

      if ("production" !== process.env.NODE_ENV) {
        // Record the root element in case it later gets transplanted.
        rootElementsByReactRootID[reactRootID] =
          getReactRootElementInContainer(container);
      }

      return componentInstance;
    }
  ),

  /**
   * Renders a React component into the DOM in the supplied `container`.
   *
   * If the React component was previously rendered into `container`, this will
   * perform an update on it and only mutate the DOM as necessary to reflect the
   * latest React component.
   *
   * @param {ReactDescriptor} nextDescriptor Component descriptor to render.
   * @param {DOMElement} container DOM element to render into.
   * @param {?function} callback function triggered on completion
   * @return {ReactComponent} Component instance rendered in `container`.
   */
  renderComponent: function(nextDescriptor, container, callback) {
    ("production" !== process.env.NODE_ENV ? invariant(
      ReactDescriptor.isValidDescriptor(nextDescriptor),
      'renderComponent(): Invalid component descriptor.%s',
      (
        ReactDescriptor.isValidFactory(nextDescriptor) ?
          ' Instead of passing a component class, make sure to instantiate ' +
          'it first by calling it with props.' :
        // Check if it quacks like a descriptor
        typeof nextDescriptor.props !== "undefined" ?
          ' This may be caused by unintentionally loading two independent ' +
          'copies of React.' :
          ''
      )
    ) : invariant(ReactDescriptor.isValidDescriptor(nextDescriptor)));

    var prevComponent = instancesByReactRootID[getReactRootID(container)];

    if (prevComponent) {
      var prevDescriptor = prevComponent._descriptor;
      if (shouldUpdateReactComponent(prevDescriptor, nextDescriptor)) {
        return ReactMount._updateRootComponent(
          prevComponent,
          nextDescriptor,
          container,
          callback
        );
      } else {
        ReactMount.unmountComponentAtNode(container);
      }
    }

    var reactRootElement = getReactRootElementInContainer(container);
    var containerHasReactMarkup =
      reactRootElement && ReactMount.isRenderedByReact(reactRootElement);

    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent;

    var component = ReactMount._renderNewRootComponent(
      nextDescriptor,
      container,
      shouldReuseMarkup
    );
    callback && callback.call(component);
    return component;
  },

  /**
   * Constructs a component instance of `constructor` with `initialProps` and
   * renders it into the supplied `container`.
   *
   * @param {function} constructor React component constructor.
   * @param {?object} props Initial props of the component instance.
   * @param {DOMElement} container DOM element to render into.
   * @return {ReactComponent} Component instance rendered in `container`.
   */
  constructAndRenderComponent: function(constructor, props, container) {
    return ReactMount.renderComponent(constructor(props), container);
  },

  /**
   * Constructs a component instance of `constructor` with `initialProps` and
   * renders it into a container node identified by supplied `id`.
   *
   * @param {function} componentConstructor React component constructor
   * @param {?object} props Initial props of the component instance.
   * @param {string} id ID of the DOM element to render into.
   * @return {ReactComponent} Component instance rendered in the container node.
   */
  constructAndRenderComponentByID: function(constructor, props, id) {
    var domNode = document.getElementById(id);
    ("production" !== process.env.NODE_ENV ? invariant(
      domNode,
      'Tried to get element with id of "%s" but it is not present on the page.',
      id
    ) : invariant(domNode));
    return ReactMount.constructAndRenderComponent(constructor, props, domNode);
  },

  /**
   * Registers a container node into which React components will be rendered.
   * This also creates the "reactRoot" ID that will be assigned to the element
   * rendered within.
   *
   * @param {DOMElement} container DOM element to register as a container.
   * @return {string} The "reactRoot" ID of elements rendered within.
   */
  registerContainer: function(container) {
    var reactRootID = getReactRootID(container);
    if (reactRootID) {
      // If one exists, make sure it is a valid "reactRoot" ID.
      reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID);
    }
    if (!reactRootID) {
      // No valid "reactRoot" ID found, create one.
      reactRootID = ReactInstanceHandles.createReactRootID();
    }
    containersByReactRootID[reactRootID] = container;
    return reactRootID;
  },

  /**
   * Unmounts and destroys the React component rendered in the `container`.
   *
   * @param {DOMElement} container DOM element containing a React component.
   * @return {boolean} True if a component was found in and unmounted from
   *                   `container`
   */
  unmountComponentAtNode: function(container) {
    // Various parts of our code (such as ReactCompositeComponent's
    // _renderValidatedComponent) assume that calls to render aren't nested;
    // verify that that's the case. (Strictly speaking, unmounting won't cause a
    // render but we still don't expect to be in a render call here.)
    ("production" !== process.env.NODE_ENV ? warning(
      ReactCurrentOwner.current == null,
      'unmountComponentAtNode(): Render methods should be a pure function of ' +
      'props and state; triggering nested component updates from render is ' +
      'not allowed. If necessary, trigger nested updates in ' +
      'componentDidUpdate.'
    ) : null);

    var reactRootID = getReactRootID(container);
    var component = instancesByReactRootID[reactRootID];
    if (!component) {
      return false;
    }
    ReactMount.unmountComponentFromNode(component, container);
    delete instancesByReactRootID[reactRootID];
    delete containersByReactRootID[reactRootID];
    if ("production" !== process.env.NODE_ENV) {
      delete rootElementsByReactRootID[reactRootID];
    }
    return true;
  },

  /**
   * Unmounts a component and removes it from the DOM.
   *
   * @param {ReactComponent} instance React component instance.
   * @param {DOMElement} container DOM element to unmount from.
   * @final
   * @internal
   * @see {ReactMount.unmountComponentAtNode}
   */
  unmountComponentFromNode: function(instance, container) {
    instance.unmountComponent();

    if (container.nodeType === DOC_NODE_TYPE) {
      container = container.documentElement;
    }

    // http://jsperf.com/emptying-a-node
    while (container.lastChild) {
      container.removeChild(container.lastChild);
    }
  },

  /**
   * Finds the container DOM element that contains React component to which the
   * supplied DOM `id` belongs.
   *
   * @param {string} id The ID of an element rendered by a React component.
   * @return {?DOMElement} DOM element that contains the `id`.
   */
  findReactContainerForID: function(id) {
    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(id);
    var container = containersByReactRootID[reactRootID];

    if ("production" !== process.env.NODE_ENV) {
      var rootElement = rootElementsByReactRootID[reactRootID];
      if (rootElement && rootElement.parentNode !== container) {
        ("production" !== process.env.NODE_ENV ? invariant(
          // Call internalGetID here because getID calls isValid which calls
          // findReactContainerForID (this function).
          internalGetID(rootElement) === reactRootID,
          'ReactMount: Root element ID differed from reactRootID.'
        ) : invariant(// Call internalGetID here because getID calls isValid which calls
        // findReactContainerForID (this function).
        internalGetID(rootElement) === reactRootID));

        var containerChild = container.firstChild;
        if (containerChild &&
            reactRootID === internalGetID(containerChild)) {
          // If the container has a new child with the same ID as the old
          // root element, then rootElementsByReactRootID[reactRootID] is
          // just stale and needs to be updated. The case that deserves a
          // warning is when the container is empty.
          rootElementsByReactRootID[reactRootID] = containerChild;
        } else {
          console.warn(
            'ReactMount: Root element has been removed from its original ' +
            'container. New container:', rootElement.parentNode
          );
        }
      }
    }

    return container;
  },

  /**
   * Finds an element rendered by React with the supplied ID.
   *
   * @param {string} id ID of a DOM node in the React component.
   * @return {DOMElement} Root DOM node of the React component.
   */
  findReactNodeByID: function(id) {
    var reactRoot = ReactMount.findReactContainerForID(id);
    return ReactMount.findComponentRoot(reactRoot, id);
  },

  /**
   * True if the supplied `node` is rendered by React.
   *
   * @param {*} node DOM Element to check.
   * @return {boolean} True if the DOM Element appears to be rendered by React.
   * @internal
   */
  isRenderedByReact: function(node) {
    if (node.nodeType !== 1) {
      // Not a DOMElement, therefore not a React component
      return false;
    }
    var id = ReactMount.getID(node);
    return id ? id.charAt(0) === SEPARATOR : false;
  },

  /**
   * Traverses up the ancestors of the supplied node to find a node that is a
   * DOM representation of a React component.
   *
   * @param {*} node
   * @return {?DOMEventTarget}
   * @internal
   */
  getFirstReactDOM: function(node) {
    var current = node;
    while (current && current.parentNode !== current) {
      if (ReactMount.isRenderedByReact(current)) {
        return current;
      }
      current = current.parentNode;
    }
    return null;
  },

  /**
   * Finds a node with the supplied `targetID` inside of the supplied
   * `ancestorNode`.  Exploits the ID naming scheme to perform the search
   * quickly.
   *
   * @param {DOMEventTarget} ancestorNode Search from this root.
   * @pararm {string} targetID ID of the DOM representation of the component.
   * @return {DOMEventTarget} DOM node with the supplied `targetID`.
   * @internal
   */
  findComponentRoot: function(ancestorNode, targetID) {
    var firstChildren = findComponentRootReusableArray;
    var childIndex = 0;

    var deepestAncestor = findDeepestCachedAncestor(targetID) || ancestorNode;

    firstChildren[0] = deepestAncestor.firstChild;
    firstChildren.length = 1;

    while (childIndex < firstChildren.length) {
      var child = firstChildren[childIndex++];
      var targetChild;

      while (child) {
        var childID = ReactMount.getID(child);
        if (childID) {
          // Even if we find the node we're looking for, we finish looping
          // through its siblings to ensure they're cached so that we don't have
          // to revisit this node again. Otherwise, we make n^2 calls to getID
          // when visiting the many children of a single node in order.

          if (targetID === childID) {
            targetChild = child;
          } else if (ReactInstanceHandles.isAncestorIDOf(childID, targetID)) {
            // If we find a child whose ID is an ancestor of the given ID,
            // then we can be sure that we only want to search the subtree
            // rooted at this child, so we can throw out the rest of the
            // search state.
            firstChildren.length = childIndex = 0;
            firstChildren.push(child.firstChild);
          }

        } else {
          // If this child had no ID, then there's a chance that it was
          // injected automatically by the browser, as when a `<table>`
          // element sprouts an extra `<tbody>` child as a side effect of
          // `.innerHTML` parsing. Optimistically continue down this
          // branch, but not before examining the other siblings.
          firstChildren.push(child.firstChild);
        }

        child = child.nextSibling;
      }

      if (targetChild) {
        // Emptying firstChildren/findComponentRootReusableArray is
        // not necessary for correctness, but it helps the GC reclaim
        // any nodes that were left at the end of the search.
        firstChildren.length = 0;

        return targetChild;
      }
    }

    firstChildren.length = 0;

    ("production" !== process.env.NODE_ENV ? invariant(
      false,
      'findComponentRoot(..., %s): Unable to find element. This probably ' +
      'means the DOM was unexpectedly mutated (e.g., by the browser), ' +
      'usually due to forgetting a <tbody> when using tables, nesting <p> ' +
      'or <a> tags, or using non-SVG elements in an <svg> parent. Try ' +
      'inspecting the child nodes of the element with React ID `%s`.',
      targetID,
      ReactMount.getID(ancestorNode)
    ) : invariant(false));
  },


  /**
   * React ID utilities.
   */

  getReactRootID: getReactRootID,

  getID: getID,

  setID: setID,

  getNode: getNode,

  purgeID: purgeID
};

module.exports = ReactMount;

}).call(this,require('_process'))
},{"./DOMProperty":89,"./ReactBrowserEventEmitter":109,"./ReactCurrentOwner":118,"./ReactDescriptor":134,"./ReactInstanceHandles":142,"./ReactPerf":149,"./containsNode":187,"./getReactRootElementInContainer":206,"./instantiateReactComponent":211,"./invariant":212,"./shouldUpdateReactComponent":232,"./warning":236,"_process":73}],146:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactMultiChild
 * @typechecks static-only
 */

"use strict";

var ReactComponent = require("./ReactComponent");
var ReactMultiChildUpdateTypes = require("./ReactMultiChildUpdateTypes");

var flattenChildren = require("./flattenChildren");
var instantiateReactComponent = require("./instantiateReactComponent");
var shouldUpdateReactComponent = require("./shouldUpdateReactComponent");

/**
 * Updating children of a component may trigger recursive updates. The depth is
 * used to batch recursive updates to render markup more efficiently.
 *
 * @type {number}
 * @private
 */
var updateDepth = 0;

/**
 * Queue of update configuration objects.
 *
 * Each object has a `type` property that is in `ReactMultiChildUpdateTypes`.
 *
 * @type {array<object>}
 * @private
 */
var updateQueue = [];

/**
 * Queue of markup to be rendered.
 *
 * @type {array<string>}
 * @private
 */
var markupQueue = [];

/**
 * Enqueues markup to be rendered and inserted at a supplied index.
 *
 * @param {string} parentID ID of the parent component.
 * @param {string} markup Markup that renders into an element.
 * @param {number} toIndex Destination index.
 * @private
 */
function enqueueMarkup(parentID, markup, toIndex) {
  // NOTE: Null values reduce hidden classes.
  updateQueue.push({
    parentID: parentID,
    parentNode: null,
    type: ReactMultiChildUpdateTypes.INSERT_MARKUP,
    markupIndex: markupQueue.push(markup) - 1,
    textContent: null,
    fromIndex: null,
    toIndex: toIndex
  });
}

/**
 * Enqueues moving an existing element to another index.
 *
 * @param {string} parentID ID of the parent component.
 * @param {number} fromIndex Source index of the existing element.
 * @param {number} toIndex Destination index of the element.
 * @private
 */
function enqueueMove(parentID, fromIndex, toIndex) {
  // NOTE: Null values reduce hidden classes.
  updateQueue.push({
    parentID: parentID,
    parentNode: null,
    type: ReactMultiChildUpdateTypes.MOVE_EXISTING,
    markupIndex: null,
    textContent: null,
    fromIndex: fromIndex,
    toIndex: toIndex
  });
}

/**
 * Enqueues removing an element at an index.
 *
 * @param {string} parentID ID of the parent component.
 * @param {number} fromIndex Index of the element to remove.
 * @private
 */
function enqueueRemove(parentID, fromIndex) {
  // NOTE: Null values reduce hidden classes.
  updateQueue.push({
    parentID: parentID,
    parentNode: null,
    type: ReactMultiChildUpdateTypes.REMOVE_NODE,
    markupIndex: null,
    textContent: null,
    fromIndex: fromIndex,
    toIndex: null
  });
}

/**
 * Enqueues setting the text content.
 *
 * @param {string} parentID ID of the parent component.
 * @param {string} textContent Text content to set.
 * @private
 */
function enqueueTextContent(parentID, textContent) {
  // NOTE: Null values reduce hidden classes.
  updateQueue.push({
    parentID: parentID,
    parentNode: null,
    type: ReactMultiChildUpdateTypes.TEXT_CONTENT,
    markupIndex: null,
    textContent: textContent,
    fromIndex: null,
    toIndex: null
  });
}

/**
 * Processes any enqueued updates.
 *
 * @private
 */
function processQueue() {
  if (updateQueue.length) {
    ReactComponent.BackendIDOperations.dangerouslyProcessChildrenUpdates(
      updateQueue,
      markupQueue
    );
    clearQueue();
  }
}

/**
 * Clears any enqueued updates.
 *
 * @private
 */
function clearQueue() {
  updateQueue.length = 0;
  markupQueue.length = 0;
}

/**
 * ReactMultiChild are capable of reconciling multiple children.
 *
 * @class ReactMultiChild
 * @internal
 */
var ReactMultiChild = {

  /**
   * Provides common functionality for components that must reconcile multiple
   * children. This is used by `ReactDOMComponent` to mount, update, and
   * unmount child components.
   *
   * @lends {ReactMultiChild.prototype}
   */
  Mixin: {

    /**
     * Generates a "mount image" for each of the supplied children. In the case
     * of `ReactDOMComponent`, a mount image is a string of markup.
     *
     * @param {?object} nestedChildren Nested child maps.
     * @return {array} An array of mounted representations.
     * @internal
     */
    mountChildren: function(nestedChildren, transaction) {
      var children = flattenChildren(nestedChildren);
      var mountImages = [];
      var index = 0;
      this._renderedChildren = children;
      for (var name in children) {
        var child = children[name];
        if (children.hasOwnProperty(name)) {
          // The rendered children must be turned into instances as they're
          // mounted.
          var childInstance = instantiateReactComponent(child);
          children[name] = childInstance;
          // Inlined for performance, see `ReactInstanceHandles.createReactID`.
          var rootID = this._rootNodeID + name;
          var mountImage = childInstance.mountComponent(
            rootID,
            transaction,
            this._mountDepth + 1
          );
          childInstance._mountIndex = index;
          mountImages.push(mountImage);
          index++;
        }
      }
      return mountImages;
    },

    /**
     * Replaces any rendered children with a text content string.
     *
     * @param {string} nextContent String of content.
     * @internal
     */
    updateTextContent: function(nextContent) {
      updateDepth++;
      var errorThrown = true;
      try {
        var prevChildren = this._renderedChildren;
        // Remove any rendered children.
        for (var name in prevChildren) {
          if (prevChildren.hasOwnProperty(name)) {
            this._unmountChildByName(prevChildren[name], name);
          }
        }
        // Set new text content.
        this.setTextContent(nextContent);
        errorThrown = false;
      } finally {
        updateDepth--;
        if (!updateDepth) {
          errorThrown ? clearQueue() : processQueue();
        }
      }
    },

    /**
     * Updates the rendered children with new children.
     *
     * @param {?object} nextNestedChildren Nested child maps.
     * @param {ReactReconcileTransaction} transaction
     * @internal
     */
    updateChildren: function(nextNestedChildren, transaction) {
      updateDepth++;
      var errorThrown = true;
      try {
        this._updateChildren(nextNestedChildren, transaction);
        errorThrown = false;
      } finally {
        updateDepth--;
        if (!updateDepth) {
          errorThrown ? clearQueue() : processQueue();
        }
      }
    },

    /**
     * Improve performance by isolating this hot code path from the try/catch
     * block in `updateChildren`.
     *
     * @param {?object} nextNestedChildren Nested child maps.
     * @param {ReactReconcileTransaction} transaction
     * @final
     * @protected
     */
    _updateChildren: function(nextNestedChildren, transaction) {
      var nextChildren = flattenChildren(nextNestedChildren);
      var prevChildren = this._renderedChildren;
      if (!nextChildren && !prevChildren) {
        return;
      }
      var name;
      // `nextIndex` will increment for each child in `nextChildren`, but
      // `lastIndex` will be the last index visited in `prevChildren`.
      var lastIndex = 0;
      var nextIndex = 0;
      for (name in nextChildren) {
        if (!nextChildren.hasOwnProperty(name)) {
          continue;
        }
        var prevChild = prevChildren && prevChildren[name];
        var prevDescriptor = prevChild && prevChild._descriptor;
        var nextDescriptor = nextChildren[name];
        if (shouldUpdateReactComponent(prevDescriptor, nextDescriptor)) {
          this.moveChild(prevChild, nextIndex, lastIndex);
          lastIndex = Math.max(prevChild._mountIndex, lastIndex);
          prevChild.receiveComponent(nextDescriptor, transaction);
          prevChild._mountIndex = nextIndex;
        } else {
          if (prevChild) {
            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
            this._unmountChildByName(prevChild, name);
          }
          // The child must be instantiated before it's mounted.
          var nextChildInstance = instantiateReactComponent(nextDescriptor);
          this._mountChildByNameAtIndex(
            nextChildInstance, name, nextIndex, transaction
          );
        }
        nextIndex++;
      }
      // Remove children that are no longer present.
      for (name in prevChildren) {
        if (prevChildren.hasOwnProperty(name) &&
            !(nextChildren && nextChildren[name])) {
          this._unmountChildByName(prevChildren[name], name);
        }
      }
    },

    /**
     * Unmounts all rendered children. This should be used to clean up children
     * when this component is unmounted.
     *
     * @internal
     */
    unmountChildren: function() {
      var renderedChildren = this._renderedChildren;
      for (var name in renderedChildren) {
        var renderedChild = renderedChildren[name];
        // TODO: When is this not true?
        if (renderedChild.unmountComponent) {
          renderedChild.unmountComponent();
        }
      }
      this._renderedChildren = null;
    },

    /**
     * Moves a child component to the supplied index.
     *
     * @param {ReactComponent} child Component to move.
     * @param {number} toIndex Destination index of the element.
     * @param {number} lastIndex Last index visited of the siblings of `child`.
     * @protected
     */
    moveChild: function(child, toIndex, lastIndex) {
      // If the index of `child` is less than `lastIndex`, then it needs to
      // be moved. Otherwise, we do not need to move it because a child will be
      // inserted or moved before `child`.
      if (child._mountIndex < lastIndex) {
        enqueueMove(this._rootNodeID, child._mountIndex, toIndex);
      }
    },

    /**
     * Creates a child component.
     *
     * @param {ReactComponent} child Component to create.
     * @param {string} mountImage Markup to insert.
     * @protected
     */
    createChild: function(child, mountImage) {
      enqueueMarkup(this._rootNodeID, mountImage, child._mountIndex);
    },

    /**
     * Removes a child component.
     *
     * @param {ReactComponent} child Child to remove.
     * @protected
     */
    removeChild: function(child) {
      enqueueRemove(this._rootNodeID, child._mountIndex);
    },

    /**
     * Sets this text content string.
     *
     * @param {string} textContent Text content to set.
     * @protected
     */
    setTextContent: function(textContent) {
      enqueueTextContent(this._rootNodeID, textContent);
    },

    /**
     * Mounts a child with the supplied name.
     *
     * NOTE: This is part of `updateChildren` and is here for readability.
     *
     * @param {ReactComponent} child Component to mount.
     * @param {string} name Name of the child.
     * @param {number} index Index at which to insert the child.
     * @param {ReactReconcileTransaction} transaction
     * @private
     */
    _mountChildByNameAtIndex: function(child, name, index, transaction) {
      // Inlined for performance, see `ReactInstanceHandles.createReactID`.
      var rootID = this._rootNodeID + name;
      var mountImage = child.mountComponent(
        rootID,
        transaction,
        this._mountDepth + 1
      );
      child._mountIndex = index;
      this.createChild(child, mountImage);
      this._renderedChildren = this._renderedChildren || {};
      this._renderedChildren[name] = child;
    },

    /**
     * Unmounts a rendered child by name.
     *
     * NOTE: This is part of `updateChildren` and is here for readability.
     *
     * @param {ReactComponent} child Component to unmount.
     * @param {string} name Name of the child in `this._renderedChildren`.
     * @private
     */
    _unmountChildByName: function(child, name) {
      this.removeChild(child);
      child._mountIndex = null;
      child.unmountComponent();
      delete this._renderedChildren[name];
    }

  }

};

module.exports = ReactMultiChild;

},{"./ReactComponent":113,"./ReactMultiChildUpdateTypes":147,"./flattenChildren":197,"./instantiateReactComponent":211,"./shouldUpdateReactComponent":232}],147:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactMultiChildUpdateTypes
 */

"use strict";

var keyMirror = require("./keyMirror");

/**
 * When a component's children are updated, a series of update configuration
 * objects are created in order to batch and serialize the required changes.
 *
 * Enumerates all the possible types of update configurations.
 *
 * @internal
 */
var ReactMultiChildUpdateTypes = keyMirror({
  INSERT_MARKUP: null,
  MOVE_EXISTING: null,
  REMOVE_NODE: null,
  TEXT_CONTENT: null
});

module.exports = ReactMultiChildUpdateTypes;

},{"./keyMirror":218}],148:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactOwner
 */

"use strict";

var emptyObject = require("./emptyObject");
var invariant = require("./invariant");

/**
 * ReactOwners are capable of storing references to owned components.
 *
 * All components are capable of //being// referenced by owner components, but
 * only ReactOwner components are capable of //referencing// owned components.
 * The named reference is known as a "ref".
 *
 * Refs are available when mounted and updated during reconciliation.
 *
 *   var MyComponent = React.createClass({
 *     render: function() {
 *       return (
 *         <div onClick={this.handleClick}>
 *           <CustomComponent ref="custom" />
 *         </div>
 *       );
 *     },
 *     handleClick: function() {
 *       this.refs.custom.handleClick();
 *     },
 *     componentDidMount: function() {
 *       this.refs.custom.initialize();
 *     }
 *   });
 *
 * Refs should rarely be used. When refs are used, they should only be done to
 * control data that is not handled by React's data flow.
 *
 * @class ReactOwner
 */
var ReactOwner = {

  /**
   * @param {?object} object
   * @return {boolean} True if `object` is a valid owner.
   * @final
   */
  isValidOwner: function(object) {
    return !!(
      object &&
      typeof object.attachRef === 'function' &&
      typeof object.detachRef === 'function'
    );
  },

  /**
   * Adds a component by ref to an owner component.
   *
   * @param {ReactComponent} component Component to reference.
   * @param {string} ref Name by which to refer to the component.
   * @param {ReactOwner} owner Component on which to record the ref.
   * @final
   * @internal
   */
  addComponentAsRefTo: function(component, ref, owner) {
    ("production" !== process.env.NODE_ENV ? invariant(
      ReactOwner.isValidOwner(owner),
      'addComponentAsRefTo(...): Only a ReactOwner can have refs. This ' +
      'usually means that you\'re trying to add a ref to a component that ' +
      'doesn\'t have an owner (that is, was not created inside of another ' +
      'component\'s `render` method). Try rendering this component inside of ' +
      'a new top-level component which will hold the ref.'
    ) : invariant(ReactOwner.isValidOwner(owner)));
    owner.attachRef(ref, component);
  },

  /**
   * Removes a component by ref from an owner component.
   *
   * @param {ReactComponent} component Component to dereference.
   * @param {string} ref Name of the ref to remove.
   * @param {ReactOwner} owner Component on which the ref is recorded.
   * @final
   * @internal
   */
  removeComponentAsRefFrom: function(component, ref, owner) {
    ("production" !== process.env.NODE_ENV ? invariant(
      ReactOwner.isValidOwner(owner),
      'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. This ' +
      'usually means that you\'re trying to remove a ref to a component that ' +
      'doesn\'t have an owner (that is, was not created inside of another ' +
      'component\'s `render` method). Try rendering this component inside of ' +
      'a new top-level component which will hold the ref.'
    ) : invariant(ReactOwner.isValidOwner(owner)));
    // Check that `component` is still the current ref because we do not want to
    // detach the ref if another component stole it.
    if (owner.refs[ref] === component) {
      owner.detachRef(ref);
    }
  },

  /**
   * A ReactComponent must mix this in to have refs.
   *
   * @lends {ReactOwner.prototype}
   */
  Mixin: {

    construct: function() {
      this.refs = emptyObject;
    },

    /**
     * Lazily allocates the refs object and stores `component` as `ref`.
     *
     * @param {string} ref Reference name.
     * @param {component} component Component to store as `ref`.
     * @final
     * @private
     */
    attachRef: function(ref, component) {
      ("production" !== process.env.NODE_ENV ? invariant(
        component.isOwnedBy(this),
        'attachRef(%s, ...): Only a component\'s owner can store a ref to it.',
        ref
      ) : invariant(component.isOwnedBy(this)));
      var refs = this.refs === emptyObject ? (this.refs = {}) : this.refs;
      refs[ref] = component;
    },

    /**
     * Detaches a reference name.
     *
     * @param {string} ref Name to dereference.
     * @final
     * @private
     */
    detachRef: function(ref) {
      delete this.refs[ref];
    }

  }

};

module.exports = ReactOwner;

}).call(this,require('_process'))
},{"./emptyObject":195,"./invariant":212,"_process":73}],149:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactPerf
 * @typechecks static-only
 */

"use strict";

/**
 * ReactPerf is a general AOP system designed to measure performance. This
 * module only has the hooks: see ReactDefaultPerf for the analysis tool.
 */
var ReactPerf = {
  /**
   * Boolean to enable/disable measurement. Set to false by default to prevent
   * accidental logging and perf loss.
   */
  enableMeasure: false,

  /**
   * Holds onto the measure function in use. By default, don't measure
   * anything, but we'll override this if we inject a measure function.
   */
  storedMeasure: _noMeasure,

  /**
   * Use this to wrap methods you want to measure. Zero overhead in production.
   *
   * @param {string} objName
   * @param {string} fnName
   * @param {function} func
   * @return {function}
   */
  measure: function(objName, fnName, func) {
    if ("production" !== process.env.NODE_ENV) {
      var measuredFunc = null;
      return function() {
        if (ReactPerf.enableMeasure) {
          if (!measuredFunc) {
            measuredFunc = ReactPerf.storedMeasure(objName, fnName, func);
          }
          return measuredFunc.apply(this, arguments);
        }
        return func.apply(this, arguments);
      };
    }
    return func;
  },

  injection: {
    /**
     * @param {function} measure
     */
    injectMeasure: function(measure) {
      ReactPerf.storedMeasure = measure;
    }
  }
};

/**
 * Simply passes through the measured function, without measuring it.
 *
 * @param {string} objName
 * @param {string} fnName
 * @param {function} func
 * @return {function}
 */
function _noMeasure(objName, fnName, func) {
  return func;
}

module.exports = ReactPerf;

}).call(this,require('_process'))
},{"_process":73}],150:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactPropTransferer
 */

"use strict";

var emptyFunction = require("./emptyFunction");
var invariant = require("./invariant");
var joinClasses = require("./joinClasses");
var merge = require("./merge");

/**
 * Creates a transfer strategy that will merge prop values using the supplied
 * `mergeStrategy`. If a prop was previously unset, this just sets it.
 *
 * @param {function} mergeStrategy
 * @return {function}
 */
function createTransferStrategy(mergeStrategy) {
  return function(props, key, value) {
    if (!props.hasOwnProperty(key)) {
      props[key] = value;
    } else {
      props[key] = mergeStrategy(props[key], value);
    }
  };
}

var transferStrategyMerge = createTransferStrategy(function(a, b) {
  // `merge` overrides the first object's (`props[key]` above) keys using the
  // second object's (`value`) keys. An object's style's existing `propA` would
  // get overridden. Flip the order here.
  return merge(b, a);
});

/**
 * Transfer strategies dictate how props are transferred by `transferPropsTo`.
 * NOTE: if you add any more exceptions to this list you should be sure to
 * update `cloneWithProps()` accordingly.
 */
var TransferStrategies = {
  /**
   * Never transfer `children`.
   */
  children: emptyFunction,
  /**
   * Transfer the `className` prop by merging them.
   */
  className: createTransferStrategy(joinClasses),
  /**
   * Never transfer the `key` prop.
   */
  key: emptyFunction,
  /**
   * Never transfer the `ref` prop.
   */
  ref: emptyFunction,
  /**
   * Transfer the `style` prop (which is an object) by merging them.
   */
  style: transferStrategyMerge
};

/**
 * Mutates the first argument by transferring the properties from the second
 * argument.
 *
 * @param {object} props
 * @param {object} newProps
 * @return {object}
 */
function transferInto(props, newProps) {
  for (var thisKey in newProps) {
    if (!newProps.hasOwnProperty(thisKey)) {
      continue;
    }

    var transferStrategy = TransferStrategies[thisKey];

    if (transferStrategy && TransferStrategies.hasOwnProperty(thisKey)) {
      transferStrategy(props, thisKey, newProps[thisKey]);
    } else if (!props.hasOwnProperty(thisKey)) {
      props[thisKey] = newProps[thisKey];
    }
  }
  return props;
}

/**
 * ReactPropTransferer are capable of transferring props to another component
 * using a `transferPropsTo` method.
 *
 * @class ReactPropTransferer
 */
var ReactPropTransferer = {

  TransferStrategies: TransferStrategies,

  /**
   * Merge two props objects using TransferStrategies.
   *
   * @param {object} oldProps original props (they take precedence)
   * @param {object} newProps new props to merge in
   * @return {object} a new object containing both sets of props merged.
   */
  mergeProps: function(oldProps, newProps) {
    return transferInto(merge(oldProps), newProps);
  },

  /**
   * @lends {ReactPropTransferer.prototype}
   */
  Mixin: {

    /**
     * Transfer props from this component to a target component.
     *
     * Props that do not have an explicit transfer strategy will be transferred
     * only if the target component does not already have the prop set.
     *
     * This is usually used to pass down props to a returned root component.
     *
     * @param {ReactDescriptor} descriptor Component receiving the properties.
     * @return {ReactDescriptor} The supplied `component`.
     * @final
     * @protected
     */
    transferPropsTo: function(descriptor) {
      ("production" !== process.env.NODE_ENV ? invariant(
        descriptor._owner === this,
        '%s: You can\'t call transferPropsTo() on a component that you ' +
        'don\'t own, %s. This usually means you are calling ' +
        'transferPropsTo() on a component passed in as props or children.',
        this.constructor.displayName,
        descriptor.type.displayName
      ) : invariant(descriptor._owner === this));

      // Because descriptors are immutable we have to merge into the existing
      // props object rather than clone it.
      transferInto(descriptor.props, this.props);

      return descriptor;
    }

  }
};

module.exports = ReactPropTransferer;

}).call(this,require('_process'))
},{"./emptyFunction":194,"./invariant":212,"./joinClasses":217,"./merge":222,"_process":73}],151:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactPropTypeLocationNames
 */

"use strict";

var ReactPropTypeLocationNames = {};

if ("production" !== process.env.NODE_ENV) {
  ReactPropTypeLocationNames = {
    prop: 'prop',
    context: 'context',
    childContext: 'child context'
  };
}

module.exports = ReactPropTypeLocationNames;

}).call(this,require('_process'))
},{"_process":73}],152:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactPropTypeLocations
 */

"use strict";

var keyMirror = require("./keyMirror");

var ReactPropTypeLocations = keyMirror({
  prop: null,
  context: null,
  childContext: null
});

module.exports = ReactPropTypeLocations;

},{"./keyMirror":218}],153:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactPropTypes
 */

"use strict";

var ReactDescriptor = require("./ReactDescriptor");
var ReactPropTypeLocationNames = require("./ReactPropTypeLocationNames");

var emptyFunction = require("./emptyFunction");

/**
 * Collection of methods that allow declaration and validation of props that are
 * supplied to React components. Example usage:
 *
 *   var Props = require('ReactPropTypes');
 *   var MyArticle = React.createClass({
 *     propTypes: {
 *       // An optional string prop named "description".
 *       description: Props.string,
 *
 *       // A required enum prop named "category".
 *       category: Props.oneOf(['News','Photos']).isRequired,
 *
 *       // A prop named "dialog" that requires an instance of Dialog.
 *       dialog: Props.instanceOf(Dialog).isRequired
 *     },
 *     render: function() { ... }
 *   });
 *
 * A more formal specification of how these methods are used:
 *
 *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
 *   decl := ReactPropTypes.{type}(.isRequired)?
 *
 * Each and every declaration produces a function with the same signature. This
 * allows the creation of custom validation functions. For example:
 *
 *  var MyLink = React.createClass({
 *    propTypes: {
 *      // An optional string or URI prop named "href".
 *      href: function(props, propName, componentName) {
 *        var propValue = props[propName];
 *        if (propValue != null && typeof propValue !== 'string' &&
 *            !(propValue instanceof URI)) {
 *          return new Error(
 *            'Expected a string or an URI for ' + propName + ' in ' +
 *            componentName
 *          );
 *        }
 *      }
 *    },
 *    render: function() {...}
 *  });
 *
 * @internal
 */

var ANONYMOUS = '<<anonymous>>';

var ReactPropTypes = {
  array: createPrimitiveTypeChecker('array'),
  bool: createPrimitiveTypeChecker('boolean'),
  func: createPrimitiveTypeChecker('function'),
  number: createPrimitiveTypeChecker('number'),
  object: createPrimitiveTypeChecker('object'),
  string: createPrimitiveTypeChecker('string'),

  any: createAnyTypeChecker(),
  arrayOf: createArrayOfTypeChecker,
  component: createComponentTypeChecker(),
  instanceOf: createInstanceTypeChecker,
  objectOf: createObjectOfTypeChecker,
  oneOf: createEnumTypeChecker,
  oneOfType: createUnionTypeChecker,
  renderable: createRenderableTypeChecker(),
  shape: createShapeTypeChecker
};

function createChainableTypeChecker(validate) {
  function checkType(isRequired, props, propName, componentName, location) {
    componentName = componentName || ANONYMOUS;
    if (props[propName] == null) {
      var locationName = ReactPropTypeLocationNames[location];
      if (isRequired) {
        return new Error(
          ("Required " + locationName + " `" + propName + "` was not specified in ")+
          ("`" + componentName + "`.")
        );
      }
    } else {
      return validate(props, propName, componentName, location);
    }
  }

  var chainedCheckType = checkType.bind(null, false);
  chainedCheckType.isRequired = checkType.bind(null, true);

  return chainedCheckType;
}

function createPrimitiveTypeChecker(expectedType) {
  function validate(props, propName, componentName, location) {
    var propValue = props[propName];
    var propType = getPropType(propValue);
    if (propType !== expectedType) {
      var locationName = ReactPropTypeLocationNames[location];
      // `propValue` being instance of, say, date/regexp, pass the 'object'
      // check, but we can offer a more precise error message here rather than
      // 'of type `object`'.
      var preciseType = getPreciseType(propValue);

      return new Error(
        ("Invalid " + locationName + " `" + propName + "` of type `" + preciseType + "` ") +
        ("supplied to `" + componentName + "`, expected `" + expectedType + "`.")
      );
    }
  }
  return createChainableTypeChecker(validate);
}

function createAnyTypeChecker() {
  return createChainableTypeChecker(emptyFunction.thatReturns());
}

function createArrayOfTypeChecker(typeChecker) {
  function validate(props, propName, componentName, location) {
    var propValue = props[propName];
    if (!Array.isArray(propValue)) {
      var locationName = ReactPropTypeLocationNames[location];
      var propType = getPropType(propValue);
      return new Error(
        ("Invalid " + locationName + " `" + propName + "` of type ") +
        ("`" + propType + "` supplied to `" + componentName + "`, expected an array.")
      );
    }
    for (var i = 0; i < propValue.length; i++) {
      var error = typeChecker(propValue, i, componentName, location);
      if (error instanceof Error) {
        return error;
      }
    }
  }
  return createChainableTypeChecker(validate);
}

function createComponentTypeChecker() {
  function validate(props, propName, componentName, location) {
    if (!ReactDescriptor.isValidDescriptor(props[propName])) {
      var locationName = ReactPropTypeLocationNames[location];
      return new Error(
        ("Invalid " + locationName + " `" + propName + "` supplied to ") +
        ("`" + componentName + "`, expected a React component.")
      );
    }
  }
  return createChainableTypeChecker(validate);
}

function createInstanceTypeChecker(expectedClass) {
  function validate(props, propName, componentName, location) {
    if (!(props[propName] instanceof expectedClass)) {
      var locationName = ReactPropTypeLocationNames[location];
      var expectedClassName = expectedClass.name || ANONYMOUS;
      return new Error(
        ("Invalid " + locationName + " `" + propName + "` supplied to ") +
        ("`" + componentName + "`, expected instance of `" + expectedClassName + "`.")
      );
    }
  }
  return createChainableTypeChecker(validate);
}

function createEnumTypeChecker(expectedValues) {
  function validate(props, propName, componentName, location) {
    var propValue = props[propName];
    for (var i = 0; i < expectedValues.length; i++) {
      if (propValue === expectedValues[i]) {
        return;
      }
    }

    var locationName = ReactPropTypeLocationNames[location];
    var valuesString = JSON.stringify(expectedValues);
    return new Error(
      ("Invalid " + locationName + " `" + propName + "` of value `" + propValue + "` ") +
      ("supplied to `" + componentName + "`, expected one of " + valuesString + ".")
    );
  }
  return createChainableTypeChecker(validate);
}

function createObjectOfTypeChecker(typeChecker) {
  function validate(props, propName, componentName, location) {
    var propValue = props[propName];
    var propType = getPropType(propValue);
    if (propType !== 'object') {
      var locationName = ReactPropTypeLocationNames[location];
      return new Error(
        ("Invalid " + locationName + " `" + propName + "` of type ") +
        ("`" + propType + "` supplied to `" + componentName + "`, expected an object.")
      );
    }
    for (var key in propValue) {
      if (propValue.hasOwnProperty(key)) {
        var error = typeChecker(propValue, key, componentName, location);
        if (error instanceof Error) {
          return error;
        }
      }
    }
  }
  return createChainableTypeChecker(validate);
}

function createUnionTypeChecker(arrayOfTypeCheckers) {
  function validate(props, propName, componentName, location) {
    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (checker(props, propName, componentName, location) == null) {
        return;
      }
    }

    var locationName = ReactPropTypeLocationNames[location];
    return new Error(
      ("Invalid " + locationName + " `" + propName + "` supplied to ") +
      ("`" + componentName + "`.")
    );
  }
  return createChainableTypeChecker(validate);
}

function createRenderableTypeChecker() {
  function validate(props, propName, componentName, location) {
    if (!isRenderable(props[propName])) {
      var locationName = ReactPropTypeLocationNames[location];
      return new Error(
        ("Invalid " + locationName + " `" + propName + "` supplied to ") +
        ("`" + componentName + "`, expected a renderable prop.")
      );
    }
  }
  return createChainableTypeChecker(validate);
}

function createShapeTypeChecker(shapeTypes) {
  function validate(props, propName, componentName, location) {
    var propValue = props[propName];
    var propType = getPropType(propValue);
    if (propType !== 'object') {
      var locationName = ReactPropTypeLocationNames[location];
      return new Error(
        ("Invalid " + locationName + " `" + propName + "` of type `" + propType + "` ") +
        ("supplied to `" + componentName + "`, expected `object`.")
      );
    }
    for (var key in shapeTypes) {
      var checker = shapeTypes[key];
      if (!checker) {
        continue;
      }
      var error = checker(propValue, key, componentName, location);
      if (error) {
        return error;
      }
    }
  }
  return createChainableTypeChecker(validate, 'expected `object`');
}

function isRenderable(propValue) {
  switch(typeof propValue) {
    // TODO: this was probably written with the assumption that we're not
    // returning `this.props.component` directly from `render`. This is
    // currently not supported but we should, to make it consistent.
    case 'number':
    case 'string':
      return true;
    case 'boolean':
      return !propValue;
    case 'object':
      if (Array.isArray(propValue)) {
        return propValue.every(isRenderable);
      }
      if (ReactDescriptor.isValidDescriptor(propValue)) {
        return true;
      }
      for (var k in propValue) {
        if (!isRenderable(propValue[k])) {
          return false;
        }
      }
      return true;
    default:
      return false;
  }
}

// Equivalent of `typeof` but with special handling for array and regexp.
function getPropType(propValue) {
  var propType = typeof propValue;
  if (Array.isArray(propValue)) {
    return 'array';
  }
  if (propValue instanceof RegExp) {
    // Old webkits (at least until Android 4.0) return 'function' rather than
    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
    // passes PropTypes.object.
    return 'object';
  }
  return propType;
}

// This handles more types than `getPropType`. Only used for error messages.
// See `createPrimitiveTypeChecker`.
function getPreciseType(propValue) {
  var propType = getPropType(propValue);
  if (propType === 'object') {
    if (propValue instanceof Date) {
      return 'date';
    } else if (propValue instanceof RegExp) {
      return 'regexp';
    }
  }
  return propType;
}

module.exports = ReactPropTypes;

},{"./ReactDescriptor":134,"./ReactPropTypeLocationNames":151,"./emptyFunction":194}],154:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactPutListenerQueue
 */

"use strict";

var PooledClass = require("./PooledClass");
var ReactBrowserEventEmitter = require("./ReactBrowserEventEmitter");

var mixInto = require("./mixInto");

function ReactPutListenerQueue() {
  this.listenersToPut = [];
}

mixInto(ReactPutListenerQueue, {
  enqueuePutListener: function(rootNodeID, propKey, propValue) {
    this.listenersToPut.push({
      rootNodeID: rootNodeID,
      propKey: propKey,
      propValue: propValue
    });
  },

  putListeners: function() {
    for (var i = 0; i < this.listenersToPut.length; i++) {
      var listenerToPut = this.listenersToPut[i];
      ReactBrowserEventEmitter.putListener(
        listenerToPut.rootNodeID,
        listenerToPut.propKey,
        listenerToPut.propValue
      );
    }
  },

  reset: function() {
    this.listenersToPut.length = 0;
  },

  destructor: function() {
    this.reset();
  }
});

PooledClass.addPoolingTo(ReactPutListenerQueue);

module.exports = ReactPutListenerQueue;

},{"./PooledClass":106,"./ReactBrowserEventEmitter":109,"./mixInto":225}],155:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactReconcileTransaction
 * @typechecks static-only
 */

"use strict";

var CallbackQueue = require("./CallbackQueue");
var PooledClass = require("./PooledClass");
var ReactBrowserEventEmitter = require("./ReactBrowserEventEmitter");
var ReactInputSelection = require("./ReactInputSelection");
var ReactPutListenerQueue = require("./ReactPutListenerQueue");
var Transaction = require("./Transaction");

var mixInto = require("./mixInto");

/**
 * Ensures that, when possible, the selection range (currently selected text
 * input) is not disturbed by performing the transaction.
 */
var SELECTION_RESTORATION = {
  /**
   * @return {Selection} Selection information.
   */
  initialize: ReactInputSelection.getSelectionInformation,
  /**
   * @param {Selection} sel Selection information returned from `initialize`.
   */
  close: ReactInputSelection.restoreSelection
};

/**
 * Suppresses events (blur/focus) that could be inadvertently dispatched due to
 * high level DOM manipulations (like temporarily removing a text input from the
 * DOM).
 */
var EVENT_SUPPRESSION = {
  /**
   * @return {boolean} The enabled status of `ReactBrowserEventEmitter` before
   * the reconciliation.
   */
  initialize: function() {
    var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
    ReactBrowserEventEmitter.setEnabled(false);
    return currentlyEnabled;
  },

  /**
   * @param {boolean} previouslyEnabled Enabled status of
   *   `ReactBrowserEventEmitter` before the reconciliation occured. `close`
   *   restores the previous value.
   */
  close: function(previouslyEnabled) {
    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
  }
};

/**
 * Provides a queue for collecting `componentDidMount` and
 * `componentDidUpdate` callbacks during the the transaction.
 */
var ON_DOM_READY_QUEUEING = {
  /**
   * Initializes the internal `onDOMReady` queue.
   */
  initialize: function() {
    this.reactMountReady.reset();
  },

  /**
   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
   */
  close: function() {
    this.reactMountReady.notifyAll();
  }
};

var PUT_LISTENER_QUEUEING = {
  initialize: function() {
    this.putListenerQueue.reset();
  },

  close: function() {
    this.putListenerQueue.putListeners();
  }
};

/**
 * Executed within the scope of the `Transaction` instance. Consider these as
 * being member methods, but with an implied ordering while being isolated from
 * each other.
 */
var TRANSACTION_WRAPPERS = [
  PUT_LISTENER_QUEUEING,
  SELECTION_RESTORATION,
  EVENT_SUPPRESSION,
  ON_DOM_READY_QUEUEING
];

/**
 * Currently:
 * - The order that these are listed in the transaction is critical:
 * - Suppresses events.
 * - Restores selection range.
 *
 * Future:
 * - Restore document/overflow scroll positions that were unintentionally
 *   modified via DOM insertions above the top viewport boundary.
 * - Implement/integrate with customized constraint based layout system and keep
 *   track of which dimensions must be remeasured.
 *
 * @class ReactReconcileTransaction
 */
function ReactReconcileTransaction() {
  this.reinitializeTransaction();
  // Only server-side rendering really needs this option (see
  // `ReactServerRendering`), but server-side uses
  // `ReactServerRenderingTransaction` instead. This option is here so that it's
  // accessible and defaults to false when `ReactDOMComponent` and
  // `ReactTextComponent` checks it in `mountComponent`.`
  this.renderToStaticMarkup = false;
  this.reactMountReady = CallbackQueue.getPooled(null);
  this.putListenerQueue = ReactPutListenerQueue.getPooled();
}

var Mixin = {
  /**
   * @see Transaction
   * @abstract
   * @final
   * @return {array<object>} List of operation wrap proceedures.
   *   TODO: convert to array<TransactionWrapper>
   */
  getTransactionWrappers: function() {
    return TRANSACTION_WRAPPERS;
  },

  /**
   * @return {object} The queue to collect `onDOMReady` callbacks with.
   */
  getReactMountReady: function() {
    return this.reactMountReady;
  },

  getPutListenerQueue: function() {
    return this.putListenerQueue;
  },

  /**
   * `PooledClass` looks for this, and will invoke this before allowing this
   * instance to be resused.
   */
  destructor: function() {
    CallbackQueue.release(this.reactMountReady);
    this.reactMountReady = null;

    ReactPutListenerQueue.release(this.putListenerQueue);
    this.putListenerQueue = null;
  }
};


mixInto(ReactReconcileTransaction, Transaction.Mixin);
mixInto(ReactReconcileTransaction, Mixin);

PooledClass.addPoolingTo(ReactReconcileTransaction);

module.exports = ReactReconcileTransaction;

},{"./CallbackQueue":84,"./PooledClass":106,"./ReactBrowserEventEmitter":109,"./ReactInputSelection":141,"./ReactPutListenerQueue":154,"./Transaction":182,"./mixInto":225}],156:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactRootIndex
 * @typechecks
 */

"use strict";

var ReactRootIndexInjection = {
  /**
   * @param {function} _createReactRootIndex
   */
  injectCreateReactRootIndex: function(_createReactRootIndex) {
    ReactRootIndex.createReactRootIndex = _createReactRootIndex;
  }
};

var ReactRootIndex = {
  createReactRootIndex: null,
  injection: ReactRootIndexInjection
};

module.exports = ReactRootIndex;

},{}],157:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @typechecks static-only
 * @providesModule ReactServerRendering
 */
"use strict";

var ReactDescriptor = require("./ReactDescriptor");
var ReactInstanceHandles = require("./ReactInstanceHandles");
var ReactMarkupChecksum = require("./ReactMarkupChecksum");
var ReactServerRenderingTransaction =
  require("./ReactServerRenderingTransaction");

var instantiateReactComponent = require("./instantiateReactComponent");
var invariant = require("./invariant");

/**
 * @param {ReactComponent} component
 * @return {string} the HTML markup
 */
function renderComponentToString(component) {
  ("production" !== process.env.NODE_ENV ? invariant(
    ReactDescriptor.isValidDescriptor(component),
    'renderComponentToString(): You must pass a valid ReactComponent.'
  ) : invariant(ReactDescriptor.isValidDescriptor(component)));

  ("production" !== process.env.NODE_ENV ? invariant(
    !(arguments.length === 2 && typeof arguments[1] === 'function'),
    'renderComponentToString(): This function became synchronous and now ' +
    'returns the generated markup. Please remove the second parameter.'
  ) : invariant(!(arguments.length === 2 && typeof arguments[1] === 'function')));

  var transaction;
  try {
    var id = ReactInstanceHandles.createReactRootID();
    transaction = ReactServerRenderingTransaction.getPooled(false);

    return transaction.perform(function() {
      var componentInstance = instantiateReactComponent(component);
      var markup = componentInstance.mountComponent(id, transaction, 0);
      return ReactMarkupChecksum.addChecksumToMarkup(markup);
    }, null);
  } finally {
    ReactServerRenderingTransaction.release(transaction);
  }
}

/**
 * @param {ReactComponent} component
 * @return {string} the HTML markup, without the extra React ID and checksum
* (for generating static pages)
 */
function renderComponentToStaticMarkup(component) {
  ("production" !== process.env.NODE_ENV ? invariant(
    ReactDescriptor.isValidDescriptor(component),
    'renderComponentToStaticMarkup(): You must pass a valid ReactComponent.'
  ) : invariant(ReactDescriptor.isValidDescriptor(component)));

  var transaction;
  try {
    var id = ReactInstanceHandles.createReactRootID();
    transaction = ReactServerRenderingTransaction.getPooled(true);

    return transaction.perform(function() {
      var componentInstance = instantiateReactComponent(component);
      return componentInstance.mountComponent(id, transaction, 0);
    }, null);
  } finally {
    ReactServerRenderingTransaction.release(transaction);
  }
}

module.exports = {
  renderComponentToString: renderComponentToString,
  renderComponentToStaticMarkup: renderComponentToStaticMarkup
};

}).call(this,require('_process'))
},{"./ReactDescriptor":134,"./ReactInstanceHandles":142,"./ReactMarkupChecksum":144,"./ReactServerRenderingTransaction":158,"./instantiateReactComponent":211,"./invariant":212,"_process":73}],158:[function(require,module,exports){
/**
 * Copyright 2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactServerRenderingTransaction
 * @typechecks
 */

"use strict";

var PooledClass = require("./PooledClass");
var CallbackQueue = require("./CallbackQueue");
var ReactPutListenerQueue = require("./ReactPutListenerQueue");
var Transaction = require("./Transaction");

var emptyFunction = require("./emptyFunction");
var mixInto = require("./mixInto");

/**
 * Provides a `CallbackQueue` queue for collecting `onDOMReady` callbacks
 * during the performing of the transaction.
 */
var ON_DOM_READY_QUEUEING = {
  /**
   * Initializes the internal `onDOMReady` queue.
   */
  initialize: function() {
    this.reactMountReady.reset();
  },

  close: emptyFunction
};

var PUT_LISTENER_QUEUEING = {
  initialize: function() {
    this.putListenerQueue.reset();
  },

  close: emptyFunction
};

/**
 * Executed within the scope of the `Transaction` instance. Consider these as
 * being member methods, but with an implied ordering while being isolated from
 * each other.
 */
var TRANSACTION_WRAPPERS = [
  PUT_LISTENER_QUEUEING,
  ON_DOM_READY_QUEUEING
];

/**
 * @class ReactServerRenderingTransaction
 * @param {boolean} renderToStaticMarkup
 */
function ReactServerRenderingTransaction(renderToStaticMarkup) {
  this.reinitializeTransaction();
  this.renderToStaticMarkup = renderToStaticMarkup;
  this.reactMountReady = CallbackQueue.getPooled(null);
  this.putListenerQueue = ReactPutListenerQueue.getPooled();
}

var Mixin = {
  /**
   * @see Transaction
   * @abstract
   * @final
   * @return {array} Empty list of operation wrap proceedures.
   */
  getTransactionWrappers: function() {
    return TRANSACTION_WRAPPERS;
  },

  /**
   * @return {object} The queue to collect `onDOMReady` callbacks with.
   */
  getReactMountReady: function() {
    return this.reactMountReady;
  },

  getPutListenerQueue: function() {
    return this.putListenerQueue;
  },

  /**
   * `PooledClass` looks for this, and will invoke this before allowing this
   * instance to be resused.
   */
  destructor: function() {
    CallbackQueue.release(this.reactMountReady);
    this.reactMountReady = null;

    ReactPutListenerQueue.release(this.putListenerQueue);
    this.putListenerQueue = null;
  }
};


mixInto(ReactServerRenderingTransaction, Transaction.Mixin);
mixInto(ReactServerRenderingTransaction, Mixin);

PooledClass.addPoolingTo(ReactServerRenderingTransaction);

module.exports = ReactServerRenderingTransaction;

},{"./CallbackQueue":84,"./PooledClass":106,"./ReactPutListenerQueue":154,"./Transaction":182,"./emptyFunction":194,"./mixInto":225}],159:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactStateSetters
 */

"use strict";

var ReactStateSetters = {
  /**
   * Returns a function that calls the provided function, and uses the result
   * of that to set the component's state.
   *
   * @param {ReactCompositeComponent} component
   * @param {function} funcReturningState Returned callback uses this to
   *                                      determine how to update state.
   * @return {function} callback that when invoked uses funcReturningState to
   *                    determined the object literal to setState.
   */
  createStateSetter: function(component, funcReturningState) {
    return function(a, b, c, d, e, f) {
      var partialState = funcReturningState.call(component, a, b, c, d, e, f);
      if (partialState) {
        component.setState(partialState);
      }
    };
  },

  /**
   * Returns a single-argument callback that can be used to update a single
   * key in the component's state.
   *
   * Note: this is memoized function, which makes it inexpensive to call.
   *
   * @param {ReactCompositeComponent} component
   * @param {string} key The key in the state that you should update.
   * @return {function} callback of 1 argument which calls setState() with
   *                    the provided keyName and callback argument.
   */
  createStateKeySetter: function(component, key) {
    // Memoize the setters.
    var cache = component.__keySetters || (component.__keySetters = {});
    return cache[key] || (cache[key] = createStateKeySetter(component, key));
  }
};

function createStateKeySetter(component, key) {
  // Partial state is allocated outside of the function closure so it can be
  // reused with every call, avoiding memory allocation when this function
  // is called.
  var partialState = {};
  return function stateKeySetter(value) {
    partialState[key] = value;
    component.setState(partialState);
  };
}

ReactStateSetters.Mixin = {
  /**
   * Returns a function that calls the provided function, and uses the result
   * of that to set the component's state.
   *
   * For example, these statements are equivalent:
   *
   *   this.setState({x: 1});
   *   this.createStateSetter(function(xValue) {
   *     return {x: xValue};
   *   })(1);
   *
   * @param {function} funcReturningState Returned callback uses this to
   *                                      determine how to update state.
   * @return {function} callback that when invoked uses funcReturningState to
   *                    determined the object literal to setState.
   */
  createStateSetter: function(funcReturningState) {
    return ReactStateSetters.createStateSetter(this, funcReturningState);
  },

  /**
   * Returns a single-argument callback that can be used to update a single
   * key in the component's state.
   *
   * For example, these statements are equivalent:
   *
   *   this.setState({x: 1});
   *   this.createStateKeySetter('x')(1);
   *
   * Note: this is memoized function, which makes it inexpensive to call.
   *
   * @param {string} key The key in the state that you should update.
   * @return {function} callback of 1 argument which calls setState() with
   *                    the provided keyName and callback argument.
   */
  createStateKeySetter: function(key) {
    return ReactStateSetters.createStateKeySetter(this, key);
  }
};

module.exports = ReactStateSetters;

},{}],160:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactTestUtils
 */

"use strict";

var EventConstants = require("./EventConstants");
var EventPluginHub = require("./EventPluginHub");
var EventPropagators = require("./EventPropagators");
var React = require("./React");
var ReactDescriptor = require("./ReactDescriptor");
var ReactDOM = require("./ReactDOM");
var ReactBrowserEventEmitter = require("./ReactBrowserEventEmitter");
var ReactMount = require("./ReactMount");
var ReactTextComponent = require("./ReactTextComponent");
var ReactUpdates = require("./ReactUpdates");
var SyntheticEvent = require("./SyntheticEvent");

var mergeInto = require("./mergeInto");
var copyProperties = require("./copyProperties");

var topLevelTypes = EventConstants.topLevelTypes;

function Event(suffix) {}

/**
 * @class ReactTestUtils
 */

/**
 * Todo: Support the entire DOM.scry query syntax. For now, these simple
 * utilities will suffice for testing purposes.
 * @lends ReactTestUtils
 */
var ReactTestUtils = {
  renderIntoDocument: function(instance) {
    var div = document.createElement('div');
    // None of our tests actually require attaching the container to the
    // DOM, and doing so creates a mess that we rely on test isolation to
    // clean up, so we're going to stop honoring the name of this method
    // (and probably rename it eventually) if no problems arise.
    // document.documentElement.appendChild(div);
    return React.renderComponent(instance, div);
  },

  isDescriptor: function(descriptor) {
    return ReactDescriptor.isValidDescriptor(descriptor);
  },

  isDescriptorOfType: function(inst, convenienceConstructor) {
    return (
      ReactDescriptor.isValidDescriptor(inst) &&
      inst.type === convenienceConstructor.type
    );
  },

  isDOMComponent: function(inst) {
    return !!(inst && inst.mountComponent && inst.tagName);
  },

  isDOMComponentDescriptor: function(inst) {
    return !!(inst &&
              ReactDescriptor.isValidDescriptor(inst) &&
              !!inst.tagName);
  },

  isCompositeComponent: function(inst) {
    return typeof inst.render === 'function' &&
           typeof inst.setState === 'function';
  },

  isCompositeComponentWithType: function(inst, type) {
    return !!(ReactTestUtils.isCompositeComponent(inst) &&
             (inst.constructor === type.type));
  },

  isCompositeComponentDescriptor: function(inst) {
    if (!ReactDescriptor.isValidDescriptor(inst)) {
      return false;
    }
    // We check the prototype of the type that will get mounted, not the
    // instance itself. This is a future proof way of duck typing.
    var prototype = inst.type.prototype;
    return (
      typeof prototype.render === 'function' &&
      typeof prototype.setState === 'function'
    );
  },

  isCompositeComponentDescriptorWithType: function(inst, type) {
    return !!(ReactTestUtils.isCompositeComponentDescriptor(inst) &&
             (inst.constructor === type));
  },

  isTextComponent: function(inst) {
    return inst instanceof ReactTextComponent.type;
  },

  findAllInRenderedTree: function(inst, test) {
    if (!inst) {
      return [];
    }
    var ret = test(inst) ? [inst] : [];
    if (ReactTestUtils.isDOMComponent(inst)) {
      var renderedChildren = inst._renderedChildren;
      var key;
      for (key in renderedChildren) {
        if (!renderedChildren.hasOwnProperty(key)) {
          continue;
        }
        ret = ret.concat(
          ReactTestUtils.findAllInRenderedTree(renderedChildren[key], test)
        );
      }
    } else if (ReactTestUtils.isCompositeComponent(inst)) {
      ret = ret.concat(
        ReactTestUtils.findAllInRenderedTree(inst._renderedComponent, test)
      );
    }
    return ret;
  },

  /**
   * Finds all instance of components in the rendered tree that are DOM
   * components with the class name matching `className`.
   * @return an array of all the matches.
   */
  scryRenderedDOMComponentsWithClass: function(root, className) {
    return ReactTestUtils.findAllInRenderedTree(root, function(inst) {
      var instClassName = inst.props.className;
      return ReactTestUtils.isDOMComponent(inst) && (
        instClassName &&
        (' ' + instClassName + ' ').indexOf(' ' + className + ' ') !== -1
      );
    });
  },

  /**
   * Like scryRenderedDOMComponentsWithClass but expects there to be one result,
   * and returns that one result, or throws exception if there is any other
   * number of matches besides one.
   * @return {!ReactDOMComponent} The one match.
   */
  findRenderedDOMComponentWithClass: function(root, className) {
    var all =
      ReactTestUtils.scryRenderedDOMComponentsWithClass(root, className);
    if (all.length !== 1) {
      throw new Error('Did not find exactly one match for class:' + className);
    }
    return all[0];
  },


  /**
   * Finds all instance of components in the rendered tree that are DOM
   * components with the tag name matching `tagName`.
   * @return an array of all the matches.
   */
  scryRenderedDOMComponentsWithTag: function(root, tagName) {
    return ReactTestUtils.findAllInRenderedTree(root, function(inst) {
      return ReactTestUtils.isDOMComponent(inst) &&
            inst.tagName === tagName.toUpperCase();
    });
  },

  /**
   * Like scryRenderedDOMComponentsWithTag but expects there to be one result,
   * and returns that one result, or throws exception if there is any other
   * number of matches besides one.
   * @return {!ReactDOMComponent} The one match.
   */
  findRenderedDOMComponentWithTag: function(root, tagName) {
    var all = ReactTestUtils.scryRenderedDOMComponentsWithTag(root, tagName);
    if (all.length !== 1) {
      throw new Error('Did not find exactly one match for tag:' + tagName);
    }
    return all[0];
  },


  /**
   * Finds all instances of components with type equal to `componentType`.
   * @return an array of all the matches.
   */
  scryRenderedComponentsWithType: function(root, componentType) {
    return ReactTestUtils.findAllInRenderedTree(root, function(inst) {
      return ReactTestUtils.isCompositeComponentWithType(
        inst,
        componentType
      );
    });
  },

  /**
   * Same as `scryRenderedComponentsWithType` but expects there to be one result
   * and returns that one result, or throws exception if there is any other
   * number of matches besides one.
   * @return {!ReactComponent} The one match.
   */
  findRenderedComponentWithType: function(root, componentType) {
    var all = ReactTestUtils.scryRenderedComponentsWithType(
      root,
      componentType
    );
    if (all.length !== 1) {
      throw new Error(
        'Did not find exactly one match for componentType:' + componentType
      );
    }
    return all[0];
  },

  /**
   * Pass a mocked component module to this method to augment it with
   * useful methods that allow it to be used as a dummy React component.
   * Instead of rendering as usual, the component will become a simple
   * <div> containing any provided children.
   *
   * @param {object} module the mock function object exported from a
   *                        module that defines the component to be mocked
   * @param {?string} mockTagName optional dummy root tag name to return
   *                              from render method (overrides
   *                              module.mockTagName if provided)
   * @return {object} the ReactTestUtils object (for chaining)
   */
  mockComponent: function(module, mockTagName) {
    var ConvenienceConstructor = React.createClass({
      render: function() {
        var mockTagName = mockTagName || module.mockTagName || "div";
        return ReactDOM[mockTagName](null, this.props.children);
      }
    });

    copyProperties(module, ConvenienceConstructor);
    module.mockImplementation(ConvenienceConstructor);

    return this;
  },

  /**
   * Simulates a top level event being dispatched from a raw event that occured
   * on an `Element` node.
   * @param topLevelType {Object} A type from `EventConstants.topLevelTypes`
   * @param {!Element} node The dom to simulate an event occurring on.
   * @param {?Event} fakeNativeEvent Fake native event to use in SyntheticEvent.
   */
  simulateNativeEventOnNode: function(topLevelType, node, fakeNativeEvent) {
    fakeNativeEvent.target = node;
    ReactBrowserEventEmitter.ReactEventListener.dispatchEvent(
      topLevelType,
      fakeNativeEvent
    );
  },

  /**
   * Simulates a top level event being dispatched from a raw event that occured
   * on the `ReactDOMComponent` `comp`.
   * @param topLevelType {Object} A type from `EventConstants.topLevelTypes`.
   * @param comp {!ReactDOMComponent}
   * @param {?Event} fakeNativeEvent Fake native event to use in SyntheticEvent.
   */
  simulateNativeEventOnDOMComponent: function(
      topLevelType,
      comp,
      fakeNativeEvent) {
    ReactTestUtils.simulateNativeEventOnNode(
      topLevelType,
      comp.getDOMNode(),
      fakeNativeEvent
    );
  },

  nativeTouchData: function(x, y) {
    return {
      touches: [
        {pageX: x, pageY: y}
      ]
    };
  },

  Simulate: null,
  SimulateNative: {}
};

/**
 * Exports:
 *
 * - `ReactTestUtils.Simulate.click(Element/ReactDOMComponent)`
 * - `ReactTestUtils.Simulate.mouseMove(Element/ReactDOMComponent)`
 * - `ReactTestUtils.Simulate.change(Element/ReactDOMComponent)`
 * - ... (All keys from event plugin `eventTypes` objects)
 */
function makeSimulator(eventType) {
  return function(domComponentOrNode, eventData) {
    var node;
    if (ReactTestUtils.isDOMComponent(domComponentOrNode)) {
      node = domComponentOrNode.getDOMNode();
    } else if (domComponentOrNode.tagName) {
      node = domComponentOrNode;
    }

    var fakeNativeEvent = new Event();
    fakeNativeEvent.target = node;
    // We don't use SyntheticEvent.getPooled in order to not have to worry about
    // properly destroying any properties assigned from `eventData` upon release
    var event = new SyntheticEvent(
      ReactBrowserEventEmitter.eventNameDispatchConfigs[eventType],
      ReactMount.getID(node),
      fakeNativeEvent
    );
    mergeInto(event, eventData);
    EventPropagators.accumulateTwoPhaseDispatches(event);

    ReactUpdates.batchedUpdates(function() {
      EventPluginHub.enqueueEvents(event);
      EventPluginHub.processEventQueue();
    });
  };
}

function buildSimulators() {
  ReactTestUtils.Simulate = {};

  var eventType;
  for (eventType in ReactBrowserEventEmitter.eventNameDispatchConfigs) {
    /**
     * @param {!Element || ReactDOMComponent} domComponentOrNode
     * @param {?object} eventData Fake event data to use in SyntheticEvent.
     */
    ReactTestUtils.Simulate[eventType] = makeSimulator(eventType);
  }
}

// Rebuild ReactTestUtils.Simulate whenever event plugins are injected
var oldInjectEventPluginOrder = EventPluginHub.injection.injectEventPluginOrder;
EventPluginHub.injection.injectEventPluginOrder = function() {
  oldInjectEventPluginOrder.apply(this, arguments);
  buildSimulators();
};
var oldInjectEventPlugins = EventPluginHub.injection.injectEventPluginsByName;
EventPluginHub.injection.injectEventPluginsByName = function() {
  oldInjectEventPlugins.apply(this, arguments);
  buildSimulators();
};

buildSimulators();

/**
 * Exports:
 *
 * - `ReactTestUtils.SimulateNative.click(Element/ReactDOMComponent)`
 * - `ReactTestUtils.SimulateNative.mouseMove(Element/ReactDOMComponent)`
 * - `ReactTestUtils.SimulateNative.mouseIn/ReactDOMComponent)`
 * - `ReactTestUtils.SimulateNative.mouseOut(Element/ReactDOMComponent)`
 * - ... (All keys from `EventConstants.topLevelTypes`)
 *
 * Note: Top level event types are a subset of the entire set of handler types
 * (which include a broader set of "synthetic" events). For example, onDragDone
 * is a synthetic event. Except when testing an event plugin or React's event
 * handling code specifically, you probably want to use ReactTestUtils.Simulate
 * to dispatch synthetic events.
 */

function makeNativeSimulator(eventType) {
  return function(domComponentOrNode, nativeEventData) {
    var fakeNativeEvent = new Event(eventType);
    mergeInto(fakeNativeEvent, nativeEventData);
    if (ReactTestUtils.isDOMComponent(domComponentOrNode)) {
      ReactTestUtils.simulateNativeEventOnDOMComponent(
        eventType,
        domComponentOrNode,
        fakeNativeEvent
      );
    } else if (!!domComponentOrNode.tagName) {
      // Will allow on actual dom nodes.
      ReactTestUtils.simulateNativeEventOnNode(
        eventType,
        domComponentOrNode,
        fakeNativeEvent
      );
    }
  };
}

var eventType;
for (eventType in topLevelTypes) {
  // Event type is stored as 'topClick' - we transform that to 'click'
  var convenienceName = eventType.indexOf('top') === 0 ?
    eventType.charAt(3).toLowerCase() + eventType.substr(4) : eventType;
  /**
   * @param {!Element || ReactDOMComponent} domComponentOrNode
   * @param {?Event} nativeEventData Fake native event to use in SyntheticEvent.
   */
  ReactTestUtils.SimulateNative[convenienceName] =
    makeNativeSimulator(eventType);
}

module.exports = ReactTestUtils;

},{"./EventConstants":94,"./EventPluginHub":96,"./EventPropagators":99,"./React":107,"./ReactBrowserEventEmitter":109,"./ReactDOM":119,"./ReactDescriptor":134,"./ReactMount":145,"./ReactTextComponent":161,"./ReactUpdates":165,"./SyntheticEvent":174,"./copyProperties":188,"./mergeInto":224}],161:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactTextComponent
 * @typechecks static-only
 */

"use strict";

var DOMPropertyOperations = require("./DOMPropertyOperations");
var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
var ReactComponent = require("./ReactComponent");
var ReactDescriptor = require("./ReactDescriptor");

var escapeTextForBrowser = require("./escapeTextForBrowser");
var mixInto = require("./mixInto");

/**
 * Text nodes violate a couple assumptions that React makes about components:
 *
 *  - When mounting text into the DOM, adjacent text nodes are merged.
 *  - Text nodes cannot be assigned a React root ID.
 *
 * This component is used to wrap strings in elements so that they can undergo
 * the same reconciliation that is applied to elements.
 *
 * TODO: Investigate representing React components in the DOM with text nodes.
 *
 * @class ReactTextComponent
 * @extends ReactComponent
 * @internal
 */
var ReactTextComponent = function(descriptor) {
  this.construct(descriptor);
};

mixInto(ReactTextComponent, ReactComponent.Mixin);
mixInto(ReactTextComponent, ReactBrowserComponentMixin);
mixInto(ReactTextComponent, {

  /**
   * Creates the markup for this text node. This node is not intended to have
   * any features besides containing text content.
   *
   * @param {string} rootID DOM ID of the root node.
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {number} mountDepth number of components in the owner hierarchy
   * @return {string} Markup for this text node.
   * @internal
   */
  mountComponent: function(rootID, transaction, mountDepth) {
    ReactComponent.Mixin.mountComponent.call(
      this,
      rootID,
      transaction,
      mountDepth
    );

    var escapedText = escapeTextForBrowser(this.props);

    if (transaction.renderToStaticMarkup) {
      // Normally we'd wrap this in a `span` for the reasons stated above, but
      // since this is a situation where React won't take over (static pages),
      // we can simply return the text as it is.
      return escapedText;
    }

    return (
      '<span ' + DOMPropertyOperations.createMarkupForID(rootID) + '>' +
        escapedText +
      '</span>'
    );
  },

  /**
   * Updates this component by updating the text content.
   *
   * @param {object} nextComponent Contains the next text content.
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  receiveComponent: function(nextComponent, transaction) {
    var nextProps = nextComponent.props;
    if (nextProps !== this.props) {
      this.props = nextProps;
      ReactComponent.BackendIDOperations.updateTextContentByID(
        this._rootNodeID,
        nextProps
      );
    }
  }

});

module.exports = ReactDescriptor.createFactory(ReactTextComponent);

},{"./DOMPropertyOperations":90,"./ReactBrowserComponentMixin":108,"./ReactComponent":113,"./ReactDescriptor":134,"./escapeTextForBrowser":196,"./mixInto":225}],162:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @typechecks static-only
 * @providesModule ReactTransitionChildMapping
 */

"use strict";

var ReactChildren = require("./ReactChildren");

var ReactTransitionChildMapping = {
  /**
   * Given `this.props.children`, return an object mapping key to child. Just
   * simple syntactic sugar around ReactChildren.map().
   *
   * @param {*} children `this.props.children`
   * @return {object} Mapping of key to child
   */
  getChildMapping: function(children) {
    return ReactChildren.map(children, function(child) {
      return child;
    });
  },

  /**
   * When you're adding or removing children some may be added or removed in the
   * same render pass. We want ot show *both* since we want to simultaneously
   * animate elements in and out. This function takes a previous set of keys
   * and a new set of keys and merges them with its best guess of the correct
   * ordering. In the future we may expose some of the utilities in
   * ReactMultiChild to make this easy, but for now React itself does not
   * directly have this concept of the union of prevChildren and nextChildren
   * so we implement it here.
   *
   * @param {object} prev prev children as returned from
   * `ReactTransitionChildMapping.getChildMapping()`.
   * @param {object} next next children as returned from
   * `ReactTransitionChildMapping.getChildMapping()`.
   * @return {object} a key set that contains all keys in `prev` and all keys
   * in `next` in a reasonable order.
   */
  mergeChildMappings: function(prev, next) {
    prev = prev || {};
    next = next || {};

    function getValueForKey(key) {
      if (next.hasOwnProperty(key)) {
        return next[key];
      } else {
        return prev[key];
      }
    }

    // For each key of `next`, the list of keys to insert before that key in
    // the combined list
    var nextKeysPending = {};

    var pendingKeys = [];
    for (var prevKey in prev) {
      if (next.hasOwnProperty(prevKey)) {
        if (pendingKeys.length) {
          nextKeysPending[prevKey] = pendingKeys;
          pendingKeys = [];
        }
      } else {
        pendingKeys.push(prevKey);
      }
    }

    var i;
    var childMapping = {};
    for (var nextKey in next) {
      if (nextKeysPending.hasOwnProperty(nextKey)) {
        for (i = 0; i < nextKeysPending[nextKey].length; i++) {
          var pendingNextKey = nextKeysPending[nextKey][i];
          childMapping[nextKeysPending[nextKey][i]] = getValueForKey(
            pendingNextKey
          );
        }
      }
      childMapping[nextKey] = getValueForKey(nextKey);
    }

    // Finally, add the keys which didn't appear before any key in `next`
    for (i = 0; i < pendingKeys.length; i++) {
      childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
    }

    return childMapping;
  }
};

module.exports = ReactTransitionChildMapping;

},{"./ReactChildren":112}],163:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactTransitionEvents
 */

"use strict";

var ExecutionEnvironment = require("./ExecutionEnvironment");

/**
 * EVENT_NAME_MAP is used to determine which event fired when a
 * transition/animation ends, based on the style property used to
 * define that event.
 */
var EVENT_NAME_MAP = {
  transitionend: {
    'transition': 'transitionend',
    'WebkitTransition': 'webkitTransitionEnd',
    'MozTransition': 'mozTransitionEnd',
    'OTransition': 'oTransitionEnd',
    'msTransition': 'MSTransitionEnd'
  },

  animationend: {
    'animation': 'animationend',
    'WebkitAnimation': 'webkitAnimationEnd',
    'MozAnimation': 'mozAnimationEnd',
    'OAnimation': 'oAnimationEnd',
    'msAnimation': 'MSAnimationEnd'
  }
};

var endEvents = [];

function detectEvents() {
  var testEl = document.createElement('div');
  var style = testEl.style;

  // On some platforms, in particular some releases of Android 4.x,
  // the un-prefixed "animation" and "transition" properties are defined on the
  // style object but the events that fire will still be prefixed, so we need
  // to check if the un-prefixed events are useable, and if not remove them
  // from the map
  if (!('AnimationEvent' in window)) {
    delete EVENT_NAME_MAP.animationend.animation;
  }

  if (!('TransitionEvent' in window)) {
    delete EVENT_NAME_MAP.transitionend.transition;
  }

  for (var baseEventName in EVENT_NAME_MAP) {
    var baseEvents = EVENT_NAME_MAP[baseEventName];
    for (var styleName in baseEvents) {
      if (styleName in style) {
        endEvents.push(baseEvents[styleName]);
        break;
      }
    }
  }
}

if (ExecutionEnvironment.canUseDOM) {
  detectEvents();
}

// We use the raw {add|remove}EventListener() call because EventListener
// does not know how to remove event listeners and we really should
// clean up. Also, these events are not triggered in older browsers
// so we should be A-OK here.

function addEventListener(node, eventName, eventListener) {
  node.addEventListener(eventName, eventListener, false);
}

function removeEventListener(node, eventName, eventListener) {
  node.removeEventListener(eventName, eventListener, false);
}

var ReactTransitionEvents = {
  addEndEventListener: function(node, eventListener) {
    if (endEvents.length === 0) {
      // If CSS transitions are not supported, trigger an "end animation"
      // event immediately.
      window.setTimeout(eventListener, 0);
      return;
    }
    endEvents.forEach(function(endEvent) {
      addEventListener(node, endEvent, eventListener);
    });
  },

  removeEndEventListener: function(node, eventListener) {
    if (endEvents.length === 0) {
      return;
    }
    endEvents.forEach(function(endEvent) {
      removeEventListener(node, endEvent, eventListener);
    });
  }
};

module.exports = ReactTransitionEvents;

},{"./ExecutionEnvironment":100}],164:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactTransitionGroup
 */

"use strict";

var React = require("./React");
var ReactTransitionChildMapping = require("./ReactTransitionChildMapping");

var cloneWithProps = require("./cloneWithProps");
var emptyFunction = require("./emptyFunction");
var merge = require("./merge");

var ReactTransitionGroup = React.createClass({
  displayName: 'ReactTransitionGroup',

  propTypes: {
    component: React.PropTypes.func,
    childFactory: React.PropTypes.func
  },

  getDefaultProps: function() {
    return {
      component: React.DOM.span,
      childFactory: emptyFunction.thatReturnsArgument
    };
  },

  getInitialState: function() {
    return {
      children: ReactTransitionChildMapping.getChildMapping(this.props.children)
    };
  },

  componentWillReceiveProps: function(nextProps) {
    var nextChildMapping = ReactTransitionChildMapping.getChildMapping(
      nextProps.children
    );
    var prevChildMapping = this.state.children;

    this.setState({
      children: ReactTransitionChildMapping.mergeChildMappings(
        prevChildMapping,
        nextChildMapping
      )
    });

    var key;

    for (key in nextChildMapping) {
      var hasPrev = prevChildMapping && prevChildMapping.hasOwnProperty(key);
      if (nextChildMapping[key] && !hasPrev &&
          !this.currentlyTransitioningKeys[key]) {
        this.keysToEnter.push(key);
      }
    }

    for (key in prevChildMapping) {
      var hasNext = nextChildMapping && nextChildMapping.hasOwnProperty(key);
      if (prevChildMapping[key] && !hasNext &&
          !this.currentlyTransitioningKeys[key]) {
        this.keysToLeave.push(key);
      }
    }

    // If we want to someday check for reordering, we could do it here.
  },

  componentWillMount: function() {
    this.currentlyTransitioningKeys = {};
    this.keysToEnter = [];
    this.keysToLeave = [];
  },

  componentDidUpdate: function() {
    var keysToEnter = this.keysToEnter;
    this.keysToEnter = [];
    keysToEnter.forEach(this.performEnter);

    var keysToLeave = this.keysToLeave;
    this.keysToLeave = [];
    keysToLeave.forEach(this.performLeave);
  },

  performEnter: function(key) {
    this.currentlyTransitioningKeys[key] = true;

    var component = this.refs[key];

    if (component.componentWillEnter) {
      component.componentWillEnter(
        this._handleDoneEntering.bind(this, key)
      );
    } else {
      this._handleDoneEntering(key);
    }
  },

  _handleDoneEntering: function(key) {
    var component = this.refs[key];
    if (component.componentDidEnter) {
      component.componentDidEnter();
    }

    delete this.currentlyTransitioningKeys[key];

    var currentChildMapping = ReactTransitionChildMapping.getChildMapping(
      this.props.children
    );

    if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key)) {
      // This was removed before it had fully entered. Remove it.
      this.performLeave(key);
    }
  },

  performLeave: function(key) {
    this.currentlyTransitioningKeys[key] = true;

    var component = this.refs[key];
    if (component.componentWillLeave) {
      component.componentWillLeave(this._handleDoneLeaving.bind(this, key));
    } else {
      // Note that this is somewhat dangerous b/c it calls setState()
      // again, effectively mutating the component before all the work
      // is done.
      this._handleDoneLeaving(key);
    }
  },

  _handleDoneLeaving: function(key) {
    var component = this.refs[key];

    if (component.componentDidLeave) {
      component.componentDidLeave();
    }

    delete this.currentlyTransitioningKeys[key];

    var currentChildMapping = ReactTransitionChildMapping.getChildMapping(
      this.props.children
    );

    if (currentChildMapping && currentChildMapping.hasOwnProperty(key)) {
      // This entered again before it fully left. Add it again.
      this.performEnter(key);
    } else {
      var newChildren = merge(this.state.children);
      delete newChildren[key];
      this.setState({children: newChildren});
    }
  },

  render: function() {
    // TODO: we could get rid of the need for the wrapper node
    // by cloning a single child
    var childrenToRender = {};
    for (var key in this.state.children) {
      var child = this.state.children[key];
      if (child) {
        // You may need to apply reactive updates to a child as it is leaving.
        // The normal React way to do it won't work since the child will have
        // already been removed. In case you need this behavior you can provide
        // a childFactory function to wrap every child, even the ones that are
        // leaving.
        childrenToRender[key] = cloneWithProps(
          this.props.childFactory(child),
          {ref: key}
        );
      }
    }
    return this.transferPropsTo(this.props.component(null, childrenToRender));
  }
});

module.exports = ReactTransitionGroup;

},{"./React":107,"./ReactTransitionChildMapping":162,"./cloneWithProps":186,"./emptyFunction":194,"./merge":222}],165:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactUpdates
 */

"use strict";

var CallbackQueue = require("./CallbackQueue");
var PooledClass = require("./PooledClass");
var ReactCurrentOwner = require("./ReactCurrentOwner");
var ReactPerf = require("./ReactPerf");
var Transaction = require("./Transaction");

var invariant = require("./invariant");
var mixInto = require("./mixInto");
var warning = require("./warning");

var dirtyComponents = [];

var batchingStrategy = null;

function ensureInjected() {
  ("production" !== process.env.NODE_ENV ? invariant(
    ReactUpdates.ReactReconcileTransaction && batchingStrategy,
    'ReactUpdates: must inject a reconcile transaction class and batching ' +
    'strategy'
  ) : invariant(ReactUpdates.ReactReconcileTransaction && batchingStrategy));
}

var NESTED_UPDATES = {
  initialize: function() {
    this.dirtyComponentsLength = dirtyComponents.length;
  },
  close: function() {
    if (this.dirtyComponentsLength !== dirtyComponents.length) {
      // Additional updates were enqueued by componentDidUpdate handlers or
      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run
      // these new updates so that if A's componentDidUpdate calls setState on
      // B, B will update before the callback A's updater provided when calling
      // setState.
      dirtyComponents.splice(0, this.dirtyComponentsLength);
      flushBatchedUpdates();
    } else {
      dirtyComponents.length = 0;
    }
  }
};

var UPDATE_QUEUEING = {
  initialize: function() {
    this.callbackQueue.reset();
  },
  close: function() {
    this.callbackQueue.notifyAll();
  }
};

var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];

function ReactUpdatesFlushTransaction() {
  this.reinitializeTransaction();
  this.dirtyComponentsLength = null;
  this.callbackQueue = CallbackQueue.getPooled(null);
  this.reconcileTransaction =
    ReactUpdates.ReactReconcileTransaction.getPooled();
}

mixInto(ReactUpdatesFlushTransaction, Transaction.Mixin);
mixInto(ReactUpdatesFlushTransaction, {
  getTransactionWrappers: function() {
    return TRANSACTION_WRAPPERS;
  },

  destructor: function() {
    this.dirtyComponentsLength = null;
    CallbackQueue.release(this.callbackQueue);
    this.callbackQueue = null;
    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
    this.reconcileTransaction = null;
  },

  perform: function(method, scope, a) {
    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`
    // with this transaction's wrappers around it.
    return Transaction.Mixin.perform.call(
      this,
      this.reconcileTransaction.perform,
      this.reconcileTransaction,
      method,
      scope,
      a
    );
  }
});

PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);

function batchedUpdates(callback, a, b) {
  ensureInjected();
  batchingStrategy.batchedUpdates(callback, a, b);
}

/**
 * Array comparator for ReactComponents by owner depth
 *
 * @param {ReactComponent} c1 first component you're comparing
 * @param {ReactComponent} c2 second component you're comparing
 * @return {number} Return value usable by Array.prototype.sort().
 */
function mountDepthComparator(c1, c2) {
  return c1._mountDepth - c2._mountDepth;
}

function runBatchedUpdates(transaction) {
  var len = transaction.dirtyComponentsLength;
  ("production" !== process.env.NODE_ENV ? invariant(
    len === dirtyComponents.length,
    'Expected flush transaction\'s stored dirty-components length (%s) to ' +
    'match dirty-components array length (%s).',
    len,
    dirtyComponents.length
  ) : invariant(len === dirtyComponents.length));

  // Since reconciling a component higher in the owner hierarchy usually (not
  // always -- see shouldComponentUpdate()) will reconcile children, reconcile
  // them before their children by sorting the array.
  dirtyComponents.sort(mountDepthComparator);

  for (var i = 0; i < len; i++) {
    // If a component is unmounted before pending changes apply, ignore them
    // TODO: Queue unmounts in the same list to avoid this happening at all
    var component = dirtyComponents[i];
    if (component.isMounted()) {
      // If performUpdateIfNecessary happens to enqueue any new updates, we
      // shouldn't execute the callbacks until the next render happens, so
      // stash the callbacks first
      var callbacks = component._pendingCallbacks;
      component._pendingCallbacks = null;
      component.performUpdateIfNecessary(transaction.reconcileTransaction);

      if (callbacks) {
        for (var j = 0; j < callbacks.length; j++) {
          transaction.callbackQueue.enqueue(
            callbacks[j],
            component
          );
        }
      }
    }
  }
}

var flushBatchedUpdates = ReactPerf.measure(
  'ReactUpdates',
  'flushBatchedUpdates',
  function() {
    // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents
    // array and perform any updates enqueued by mount-ready handlers (i.e.,
    // componentDidUpdate) but we need to check here too in order to catch
    // updates enqueued by setState callbacks.
    while (dirtyComponents.length) {
      var transaction = ReactUpdatesFlushTransaction.getPooled();
      transaction.perform(runBatchedUpdates, null, transaction);
      ReactUpdatesFlushTransaction.release(transaction);
    }
  }
);

/**
 * Mark a component as needing a rerender, adding an optional callback to a
 * list of functions which will be executed once the rerender occurs.
 */
function enqueueUpdate(component, callback) {
  ("production" !== process.env.NODE_ENV ? invariant(
    !callback || typeof callback === "function",
    'enqueueUpdate(...): You called `setProps`, `replaceProps`, ' +
    '`setState`, `replaceState`, or `forceUpdate` with a callback that ' +
    'isn\'t callable.'
  ) : invariant(!callback || typeof callback === "function"));
  ensureInjected();

  // Various parts of our code (such as ReactCompositeComponent's
  // _renderValidatedComponent) assume that calls to render aren't nested;
  // verify that that's the case. (This is called by each top-level update
  // function, like setProps, setState, forceUpdate, etc.; creation and
  // destruction of top-level components is guarded in ReactMount.)
  ("production" !== process.env.NODE_ENV ? warning(
    ReactCurrentOwner.current == null,
    'enqueueUpdate(): Render methods should be a pure function of props ' +
    'and state; triggering nested component updates from render is not ' +
    'allowed. If necessary, trigger nested updates in ' +
    'componentDidUpdate.'
  ) : null);

  if (!batchingStrategy.isBatchingUpdates) {
    batchingStrategy.batchedUpdates(enqueueUpdate, component, callback);
    return;
  }

  dirtyComponents.push(component);

  if (callback) {
    if (component._pendingCallbacks) {
      component._pendingCallbacks.push(callback);
    } else {
      component._pendingCallbacks = [callback];
    }
  }
}

var ReactUpdatesInjection = {
  injectReconcileTransaction: function(ReconcileTransaction) {
    ("production" !== process.env.NODE_ENV ? invariant(
      ReconcileTransaction,
      'ReactUpdates: must provide a reconcile transaction class'
    ) : invariant(ReconcileTransaction));
    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
  },

  injectBatchingStrategy: function(_batchingStrategy) {
    ("production" !== process.env.NODE_ENV ? invariant(
      _batchingStrategy,
      'ReactUpdates: must provide a batching strategy'
    ) : invariant(_batchingStrategy));
    ("production" !== process.env.NODE_ENV ? invariant(
      typeof _batchingStrategy.batchedUpdates === 'function',
      'ReactUpdates: must provide a batchedUpdates() function'
    ) : invariant(typeof _batchingStrategy.batchedUpdates === 'function'));
    ("production" !== process.env.NODE_ENV ? invariant(
      typeof _batchingStrategy.isBatchingUpdates === 'boolean',
      'ReactUpdates: must provide an isBatchingUpdates boolean attribute'
    ) : invariant(typeof _batchingStrategy.isBatchingUpdates === 'boolean'));
    batchingStrategy = _batchingStrategy;
  }
};

var ReactUpdates = {
  /**
   * React references `ReactReconcileTransaction` using this property in order
   * to allow dependency injection.
   *
   * @internal
   */
  ReactReconcileTransaction: null,

  batchedUpdates: batchedUpdates,
  enqueueUpdate: enqueueUpdate,
  flushBatchedUpdates: flushBatchedUpdates,
  injection: ReactUpdatesInjection
};

module.exports = ReactUpdates;

}).call(this,require('_process'))
},{"./CallbackQueue":84,"./PooledClass":106,"./ReactCurrentOwner":118,"./ReactPerf":149,"./Transaction":182,"./invariant":212,"./mixInto":225,"./warning":236,"_process":73}],166:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactWithAddons
 */

/**
 * This module exists purely in the open source project, and is meant as a way
 * to create a separate standalone build of React. This build has "addons", or
 * functionality we've built and think might be useful but doesn't have a good
 * place to live inside React core.
 */

"use strict";

var LinkedStateMixin = require("./LinkedStateMixin");
var React = require("./React");
var ReactComponentWithPureRenderMixin =
  require("./ReactComponentWithPureRenderMixin");
var ReactCSSTransitionGroup = require("./ReactCSSTransitionGroup");
var ReactTransitionGroup = require("./ReactTransitionGroup");

var cx = require("./cx");
var cloneWithProps = require("./cloneWithProps");
var update = require("./update");

React.addons = {
  CSSTransitionGroup: ReactCSSTransitionGroup,
  LinkedStateMixin: LinkedStateMixin,
  PureRenderMixin: ReactComponentWithPureRenderMixin,
  TransitionGroup: ReactTransitionGroup,

  classSet: cx,
  cloneWithProps: cloneWithProps,
  update: update
};

if ("production" !== process.env.NODE_ENV) {
  React.addons.Perf = require("./ReactDefaultPerf");
  React.addons.TestUtils = require("./ReactTestUtils");
}

module.exports = React;


}).call(this,require('_process'))
},{"./LinkedStateMixin":102,"./React":107,"./ReactCSSTransitionGroup":110,"./ReactComponentWithPureRenderMixin":115,"./ReactDefaultPerf":132,"./ReactTestUtils":160,"./ReactTransitionGroup":164,"./cloneWithProps":186,"./cx":192,"./update":235,"_process":73}],167:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule SVGDOMPropertyConfig
 */

/*jslint bitwise: true*/

"use strict";

var DOMProperty = require("./DOMProperty");

var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;

var SVGDOMPropertyConfig = {
  Properties: {
    cx: MUST_USE_ATTRIBUTE,
    cy: MUST_USE_ATTRIBUTE,
    d: MUST_USE_ATTRIBUTE,
    dx: MUST_USE_ATTRIBUTE,
    dy: MUST_USE_ATTRIBUTE,
    fill: MUST_USE_ATTRIBUTE,
    fillOpacity: MUST_USE_ATTRIBUTE,
    fontFamily: MUST_USE_ATTRIBUTE,
    fontSize: MUST_USE_ATTRIBUTE,
    fx: MUST_USE_ATTRIBUTE,
    fy: MUST_USE_ATTRIBUTE,
    gradientTransform: MUST_USE_ATTRIBUTE,
    gradientUnits: MUST_USE_ATTRIBUTE,
    markerEnd: MUST_USE_ATTRIBUTE,
    markerMid: MUST_USE_ATTRIBUTE,
    markerStart: MUST_USE_ATTRIBUTE,
    offset: MUST_USE_ATTRIBUTE,
    opacity: MUST_USE_ATTRIBUTE,
    patternContentUnits: MUST_USE_ATTRIBUTE,
    patternUnits: MUST_USE_ATTRIBUTE,
    points: MUST_USE_ATTRIBUTE,
    preserveAspectRatio: MUST_USE_ATTRIBUTE,
    r: MUST_USE_ATTRIBUTE,
    rx: MUST_USE_ATTRIBUTE,
    ry: MUST_USE_ATTRIBUTE,
    spreadMethod: MUST_USE_ATTRIBUTE,
    stopColor: MUST_USE_ATTRIBUTE,
    stopOpacity: MUST_USE_ATTRIBUTE,
    stroke: MUST_USE_ATTRIBUTE,
    strokeDasharray: MUST_USE_ATTRIBUTE,
    strokeLinecap: MUST_USE_ATTRIBUTE,
    strokeOpacity: MUST_USE_ATTRIBUTE,
    strokeWidth: MUST_USE_ATTRIBUTE,
    textAnchor: MUST_USE_ATTRIBUTE,
    transform: MUST_USE_ATTRIBUTE,
    version: MUST_USE_ATTRIBUTE,
    viewBox: MUST_USE_ATTRIBUTE,
    x1: MUST_USE_ATTRIBUTE,
    x2: MUST_USE_ATTRIBUTE,
    x: MUST_USE_ATTRIBUTE,
    y1: MUST_USE_ATTRIBUTE,
    y2: MUST_USE_ATTRIBUTE,
    y: MUST_USE_ATTRIBUTE
  },
  DOMAttributeNames: {
    fillOpacity: 'fill-opacity',
    fontFamily: 'font-family',
    fontSize: 'font-size',
    gradientTransform: 'gradientTransform',
    gradientUnits: 'gradientUnits',
    markerEnd: 'marker-end',
    markerMid: 'marker-mid',
    markerStart: 'marker-start',
    patternContentUnits: 'patternContentUnits',
    patternUnits: 'patternUnits',
    preserveAspectRatio: 'preserveAspectRatio',
    spreadMethod: 'spreadMethod',
    stopColor: 'stop-color',
    stopOpacity: 'stop-opacity',
    strokeDasharray: 'stroke-dasharray',
    strokeLinecap: 'stroke-linecap',
    strokeOpacity: 'stroke-opacity',
    strokeWidth: 'stroke-width',
    textAnchor: 'text-anchor',
    viewBox: 'viewBox'
  }
};

module.exports = SVGDOMPropertyConfig;

},{"./DOMProperty":89}],168:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule SelectEventPlugin
 */

"use strict";

var EventConstants = require("./EventConstants");
var EventPropagators = require("./EventPropagators");
var ReactInputSelection = require("./ReactInputSelection");
var SyntheticEvent = require("./SyntheticEvent");

var getActiveElement = require("./getActiveElement");
var isTextInputElement = require("./isTextInputElement");
var keyOf = require("./keyOf");
var shallowEqual = require("./shallowEqual");

var topLevelTypes = EventConstants.topLevelTypes;

var eventTypes = {
  select: {
    phasedRegistrationNames: {
      bubbled: keyOf({onSelect: null}),
      captured: keyOf({onSelectCapture: null})
    },
    dependencies: [
      topLevelTypes.topBlur,
      topLevelTypes.topContextMenu,
      topLevelTypes.topFocus,
      topLevelTypes.topKeyDown,
      topLevelTypes.topMouseDown,
      topLevelTypes.topMouseUp,
      topLevelTypes.topSelectionChange
    ]
  }
};

var activeElement = null;
var activeElementID = null;
var lastSelection = null;
var mouseDown = false;

/**
 * Get an object which is a unique representation of the current selection.
 *
 * The return value will not be consistent across nodes or browsers, but
 * two identical selections on the same node will return identical objects.
 *
 * @param {DOMElement} node
 * @param {object}
 */
function getSelection(node) {
  if ('selectionStart' in node &&
      ReactInputSelection.hasSelectionCapabilities(node)) {
    return {
      start: node.selectionStart,
      end: node.selectionEnd
    };
  } else if (document.selection) {
    var range = document.selection.createRange();
    return {
      parentElement: range.parentElement(),
      text: range.text,
      top: range.boundingTop,
      left: range.boundingLeft
    };
  } else {
    var selection = window.getSelection();
    return {
      anchorNode: selection.anchorNode,
      anchorOffset: selection.anchorOffset,
      focusNode: selection.focusNode,
      focusOffset: selection.focusOffset
    };
  }
}

/**
 * Poll selection to see whether it's changed.
 *
 * @param {object} nativeEvent
 * @return {?SyntheticEvent}
 */
function constructSelectEvent(nativeEvent) {
  // Ensure we have the right element, and that the user is not dragging a
  // selection (this matches native `select` event behavior). In HTML5, select
  // fires only on input and textarea thus if there's no focused element we
  // won't dispatch.
  if (mouseDown ||
      activeElement == null ||
      activeElement != getActiveElement()) {
    return;
  }

  // Only fire when selection has actually changed.
  var currentSelection = getSelection(activeElement);
  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
    lastSelection = currentSelection;

    var syntheticEvent = SyntheticEvent.getPooled(
      eventTypes.select,
      activeElementID,
      nativeEvent
    );

    syntheticEvent.type = 'select';
    syntheticEvent.target = activeElement;

    EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);

    return syntheticEvent;
  }
}

/**
 * This plugin creates an `onSelect` event that normalizes select events
 * across form elements.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - contentEditable
 *
 * This differs from native browser implementations in the following ways:
 * - Fires on contentEditable fields as well as inputs.
 * - Fires for collapsed selection.
 * - Fires after user input.
 */
var SelectEventPlugin = {

  eventTypes: eventTypes,

  /**
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function(
      topLevelType,
      topLevelTarget,
      topLevelTargetID,
      nativeEvent) {

    switch (topLevelType) {
      // Track the input node that has focus.
      case topLevelTypes.topFocus:
        if (isTextInputElement(topLevelTarget) ||
            topLevelTarget.contentEditable === 'true') {
          activeElement = topLevelTarget;
          activeElementID = topLevelTargetID;
          lastSelection = null;
        }
        break;
      case topLevelTypes.topBlur:
        activeElement = null;
        activeElementID = null;
        lastSelection = null;
        break;

      // Don't fire the event while the user is dragging. This matches the
      // semantics of the native select event.
      case topLevelTypes.topMouseDown:
        mouseDown = true;
        break;
      case topLevelTypes.topContextMenu:
      case topLevelTypes.topMouseUp:
        mouseDown = false;
        return constructSelectEvent(nativeEvent);

      // Chrome and IE fire non-standard event when selection is changed (and
      // sometimes when it hasn't).
      // Firefox doesn't support selectionchange, so check selection status
      // after each key entry. The selection changes after keydown and before
      // keyup, but we check on keydown as well in the case of holding down a
      // key, when multiple keydown events are fired but only one keyup is.
      case topLevelTypes.topSelectionChange:
      case topLevelTypes.topKeyDown:
      case topLevelTypes.topKeyUp:
        return constructSelectEvent(nativeEvent);
    }
  }
};

module.exports = SelectEventPlugin;

},{"./EventConstants":94,"./EventPropagators":99,"./ReactInputSelection":141,"./SyntheticEvent":174,"./getActiveElement":200,"./isTextInputElement":215,"./keyOf":219,"./shallowEqual":231}],169:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ServerReactRootIndex
 * @typechecks
 */

"use strict";

/**
 * Size of the reactRoot ID space. We generate random numbers for React root
 * IDs and if there's a collision the events and DOM update system will
 * get confused. In the future we need a way to generate GUIDs but for
 * now this will work on a smaller scale.
 */
var GLOBAL_MOUNT_POINT_MAX = Math.pow(2, 53);

var ServerReactRootIndex = {
  createReactRootIndex: function() {
    return Math.ceil(Math.random() * GLOBAL_MOUNT_POINT_MAX);
  }
};

module.exports = ServerReactRootIndex;

},{}],170:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule SimpleEventPlugin
 */

"use strict";

var EventConstants = require("./EventConstants");
var EventPluginUtils = require("./EventPluginUtils");
var EventPropagators = require("./EventPropagators");
var SyntheticClipboardEvent = require("./SyntheticClipboardEvent");
var SyntheticEvent = require("./SyntheticEvent");
var SyntheticFocusEvent = require("./SyntheticFocusEvent");
var SyntheticKeyboardEvent = require("./SyntheticKeyboardEvent");
var SyntheticMouseEvent = require("./SyntheticMouseEvent");
var SyntheticDragEvent = require("./SyntheticDragEvent");
var SyntheticTouchEvent = require("./SyntheticTouchEvent");
var SyntheticUIEvent = require("./SyntheticUIEvent");
var SyntheticWheelEvent = require("./SyntheticWheelEvent");

var invariant = require("./invariant");
var keyOf = require("./keyOf");

var topLevelTypes = EventConstants.topLevelTypes;

var eventTypes = {
  blur: {
    phasedRegistrationNames: {
      bubbled: keyOf({onBlur: true}),
      captured: keyOf({onBlurCapture: true})
    }
  },
  click: {
    phasedRegistrationNames: {
      bubbled: keyOf({onClick: true}),
      captured: keyOf({onClickCapture: true})
    }
  },
  contextMenu: {
    phasedRegistrationNames: {
      bubbled: keyOf({onContextMenu: true}),
      captured: keyOf({onContextMenuCapture: true})
    }
  },
  copy: {
    phasedRegistrationNames: {
      bubbled: keyOf({onCopy: true}),
      captured: keyOf({onCopyCapture: true})
    }
  },
  cut: {
    phasedRegistrationNames: {
      bubbled: keyOf({onCut: true}),
      captured: keyOf({onCutCapture: true})
    }
  },
  doubleClick: {
    phasedRegistrationNames: {
      bubbled: keyOf({onDoubleClick: true}),
      captured: keyOf({onDoubleClickCapture: true})
    }
  },
  drag: {
    phasedRegistrationNames: {
      bubbled: keyOf({onDrag: true}),
      captured: keyOf({onDragCapture: true})
    }
  },
  dragEnd: {
    phasedRegistrationNames: {
      bubbled: keyOf({onDragEnd: true}),
      captured: keyOf({onDragEndCapture: true})
    }
  },
  dragEnter: {
    phasedRegistrationNames: {
      bubbled: keyOf({onDragEnter: true}),
      captured: keyOf({onDragEnterCapture: true})
    }
  },
  dragExit: {
    phasedRegistrationNames: {
      bubbled: keyOf({onDragExit: true}),
      captured: keyOf({onDragExitCapture: true})
    }
  },
  dragLeave: {
    phasedRegistrationNames: {
      bubbled: keyOf({onDragLeave: true}),
      captured: keyOf({onDragLeaveCapture: true})
    }
  },
  dragOver: {
    phasedRegistrationNames: {
      bubbled: keyOf({onDragOver: true}),
      captured: keyOf({onDragOverCapture: true})
    }
  },
  dragStart: {
    phasedRegistrationNames: {
      bubbled: keyOf({onDragStart: true}),
      captured: keyOf({onDragStartCapture: true})
    }
  },
  drop: {
    phasedRegistrationNames: {
      bubbled: keyOf({onDrop: true}),
      captured: keyOf({onDropCapture: true})
    }
  },
  focus: {
    phasedRegistrationNames: {
      bubbled: keyOf({onFocus: true}),
      captured: keyOf({onFocusCapture: true})
    }
  },
  input: {
    phasedRegistrationNames: {
      bubbled: keyOf({onInput: true}),
      captured: keyOf({onInputCapture: true})
    }
  },
  keyDown: {
    phasedRegistrationNames: {
      bubbled: keyOf({onKeyDown: true}),
      captured: keyOf({onKeyDownCapture: true})
    }
  },
  keyPress: {
    phasedRegistrationNames: {
      bubbled: keyOf({onKeyPress: true}),
      captured: keyOf({onKeyPressCapture: true})
    }
  },
  keyUp: {
    phasedRegistrationNames: {
      bubbled: keyOf({onKeyUp: true}),
      captured: keyOf({onKeyUpCapture: true})
    }
  },
  load: {
    phasedRegistrationNames: {
      bubbled: keyOf({onLoad: true}),
      captured: keyOf({onLoadCapture: true})
    }
  },
  error: {
    phasedRegistrationNames: {
      bubbled: keyOf({onError: true}),
      captured: keyOf({onErrorCapture: true})
    }
  },
  // Note: We do not allow listening to mouseOver events. Instead, use the
  // onMouseEnter/onMouseLeave created by `EnterLeaveEventPlugin`.
  mouseDown: {
    phasedRegistrationNames: {
      bubbled: keyOf({onMouseDown: true}),
      captured: keyOf({onMouseDownCapture: true})
    }
  },
  mouseMove: {
    phasedRegistrationNames: {
      bubbled: keyOf({onMouseMove: true}),
      captured: keyOf({onMouseMoveCapture: true})
    }
  },
  mouseOut: {
    phasedRegistrationNames: {
      bubbled: keyOf({onMouseOut: true}),
      captured: keyOf({onMouseOutCapture: true})
    }
  },
  mouseOver: {
    phasedRegistrationNames: {
      bubbled: keyOf({onMouseOver: true}),
      captured: keyOf({onMouseOverCapture: true})
    }
  },
  mouseUp: {
    phasedRegistrationNames: {
      bubbled: keyOf({onMouseUp: true}),
      captured: keyOf({onMouseUpCapture: true})
    }
  },
  paste: {
    phasedRegistrationNames: {
      bubbled: keyOf({onPaste: true}),
      captured: keyOf({onPasteCapture: true})
    }
  },
  reset: {
    phasedRegistrationNames: {
      bubbled: keyOf({onReset: true}),
      captured: keyOf({onResetCapture: true})
    }
  },
  scroll: {
    phasedRegistrationNames: {
      bubbled: keyOf({onScroll: true}),
      captured: keyOf({onScrollCapture: true})
    }
  },
  submit: {
    phasedRegistrationNames: {
      bubbled: keyOf({onSubmit: true}),
      captured: keyOf({onSubmitCapture: true})
    }
  },
  touchCancel: {
    phasedRegistrationNames: {
      bubbled: keyOf({onTouchCancel: true}),
      captured: keyOf({onTouchCancelCapture: true})
    }
  },
  touchEnd: {
    phasedRegistrationNames: {
      bubbled: keyOf({onTouchEnd: true}),
      captured: keyOf({onTouchEndCapture: true})
    }
  },
  touchMove: {
    phasedRegistrationNames: {
      bubbled: keyOf({onTouchMove: true}),
      captured: keyOf({onTouchMoveCapture: true})
    }
  },
  touchStart: {
    phasedRegistrationNames: {
      bubbled: keyOf({onTouchStart: true}),
      captured: keyOf({onTouchStartCapture: true})
    }
  },
  wheel: {
    phasedRegistrationNames: {
      bubbled: keyOf({onWheel: true}),
      captured: keyOf({onWheelCapture: true})
    }
  }
};

var topLevelEventsToDispatchConfig = {
  topBlur:        eventTypes.blur,
  topClick:       eventTypes.click,
  topContextMenu: eventTypes.contextMenu,
  topCopy:        eventTypes.copy,
  topCut:         eventTypes.cut,
  topDoubleClick: eventTypes.doubleClick,
  topDrag:        eventTypes.drag,
  topDragEnd:     eventTypes.dragEnd,
  topDragEnter:   eventTypes.dragEnter,
  topDragExit:    eventTypes.dragExit,
  topDragLeave:   eventTypes.dragLeave,
  topDragOver:    eventTypes.dragOver,
  topDragStart:   eventTypes.dragStart,
  topDrop:        eventTypes.drop,
  topError:       eventTypes.error,
  topFocus:       eventTypes.focus,
  topInput:       eventTypes.input,
  topKeyDown:     eventTypes.keyDown,
  topKeyPress:    eventTypes.keyPress,
  topKeyUp:       eventTypes.keyUp,
  topLoad:        eventTypes.load,
  topMouseDown:   eventTypes.mouseDown,
  topMouseMove:   eventTypes.mouseMove,
  topMouseOut:    eventTypes.mouseOut,
  topMouseOver:   eventTypes.mouseOver,
  topMouseUp:     eventTypes.mouseUp,
  topPaste:       eventTypes.paste,
  topReset:       eventTypes.reset,
  topScroll:      eventTypes.scroll,
  topSubmit:      eventTypes.submit,
  topTouchCancel: eventTypes.touchCancel,
  topTouchEnd:    eventTypes.touchEnd,
  topTouchMove:   eventTypes.touchMove,
  topTouchStart:  eventTypes.touchStart,
  topWheel:       eventTypes.wheel
};

for (var topLevelType in topLevelEventsToDispatchConfig) {
  topLevelEventsToDispatchConfig[topLevelType].dependencies = [topLevelType];
}

var SimpleEventPlugin = {

  eventTypes: eventTypes,

  /**
   * Same as the default implementation, except cancels the event when return
   * value is false.
   *
   * @param {object} Event to be dispatched.
   * @param {function} Application-level callback.
   * @param {string} domID DOM ID to pass to the callback.
   */
  executeDispatch: function(event, listener, domID) {
    var returnValue = EventPluginUtils.executeDispatch(event, listener, domID);
    if (returnValue === false) {
      event.stopPropagation();
      event.preventDefault();
    }
  },

  /**
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function(
      topLevelType,
      topLevelTarget,
      topLevelTargetID,
      nativeEvent) {
    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
    if (!dispatchConfig) {
      return null;
    }
    var EventConstructor;
    switch (topLevelType) {
      case topLevelTypes.topInput:
      case topLevelTypes.topLoad:
      case topLevelTypes.topError:
      case topLevelTypes.topReset:
      case topLevelTypes.topSubmit:
        // HTML Events
        // @see http://www.w3.org/TR/html5/index.html#events-0
        EventConstructor = SyntheticEvent;
        break;
      case topLevelTypes.topKeyPress:
        // FireFox creates a keypress event for function keys too. This removes
        // the unwanted keypress events.
        if (nativeEvent.charCode === 0) {
          return null;
        }
        /* falls through */
      case topLevelTypes.topKeyDown:
      case topLevelTypes.topKeyUp:
        EventConstructor = SyntheticKeyboardEvent;
        break;
      case topLevelTypes.topBlur:
      case topLevelTypes.topFocus:
        EventConstructor = SyntheticFocusEvent;
        break;
      case topLevelTypes.topClick:
        // Firefox creates a click event on right mouse clicks. This removes the
        // unwanted click events.
        if (nativeEvent.button === 2) {
          return null;
        }
        /* falls through */
      case topLevelTypes.topContextMenu:
      case topLevelTypes.topDoubleClick:
      case topLevelTypes.topMouseDown:
      case topLevelTypes.topMouseMove:
      case topLevelTypes.topMouseOut:
      case topLevelTypes.topMouseOver:
      case topLevelTypes.topMouseUp:
        EventConstructor = SyntheticMouseEvent;
        break;
      case topLevelTypes.topDrag:
      case topLevelTypes.topDragEnd:
      case topLevelTypes.topDragEnter:
      case topLevelTypes.topDragExit:
      case topLevelTypes.topDragLeave:
      case topLevelTypes.topDragOver:
      case topLevelTypes.topDragStart:
      case topLevelTypes.topDrop:
        EventConstructor = SyntheticDragEvent;
        break;
      case topLevelTypes.topTouchCancel:
      case topLevelTypes.topTouchEnd:
      case topLevelTypes.topTouchMove:
      case topLevelTypes.topTouchStart:
        EventConstructor = SyntheticTouchEvent;
        break;
      case topLevelTypes.topScroll:
        EventConstructor = SyntheticUIEvent;
        break;
      case topLevelTypes.topWheel:
        EventConstructor = SyntheticWheelEvent;
        break;
      case topLevelTypes.topCopy:
      case topLevelTypes.topCut:
      case topLevelTypes.topPaste:
        EventConstructor = SyntheticClipboardEvent;
        break;
    }
    ("production" !== process.env.NODE_ENV ? invariant(
      EventConstructor,
      'SimpleEventPlugin: Unhandled event type, `%s`.',
      topLevelType
    ) : invariant(EventConstructor));
    var event = EventConstructor.getPooled(
      dispatchConfig,
      topLevelTargetID,
      nativeEvent
    );
    EventPropagators.accumulateTwoPhaseDispatches(event);
    return event;
  }

};

module.exports = SimpleEventPlugin;

}).call(this,require('_process'))
},{"./EventConstants":94,"./EventPluginUtils":98,"./EventPropagators":99,"./SyntheticClipboardEvent":171,"./SyntheticDragEvent":173,"./SyntheticEvent":174,"./SyntheticFocusEvent":175,"./SyntheticKeyboardEvent":177,"./SyntheticMouseEvent":178,"./SyntheticTouchEvent":179,"./SyntheticUIEvent":180,"./SyntheticWheelEvent":181,"./invariant":212,"./keyOf":219,"_process":73}],171:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule SyntheticClipboardEvent
 * @typechecks static-only
 */

"use strict";

var SyntheticEvent = require("./SyntheticEvent");

/**
 * @interface Event
 * @see http://www.w3.org/TR/clipboard-apis/
 */
var ClipboardEventInterface = {
  clipboardData: function(event) {
    return (
      'clipboardData' in event ?
        event.clipboardData :
        window.clipboardData
    );
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent) {
  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
}

SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);

module.exports = SyntheticClipboardEvent;


},{"./SyntheticEvent":174}],172:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule SyntheticCompositionEvent
 * @typechecks static-only
 */

"use strict";

var SyntheticEvent = require("./SyntheticEvent");

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
 */
var CompositionEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticCompositionEvent(
  dispatchConfig,
  dispatchMarker,
  nativeEvent) {
  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
}

SyntheticEvent.augmentClass(
  SyntheticCompositionEvent,
  CompositionEventInterface
);

module.exports = SyntheticCompositionEvent;


},{"./SyntheticEvent":174}],173:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule SyntheticDragEvent
 * @typechecks static-only
 */

"use strict";

var SyntheticMouseEvent = require("./SyntheticMouseEvent");

/**
 * @interface DragEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var DragEventInterface = {
  dataTransfer: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent) {
  SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
}

SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);

module.exports = SyntheticDragEvent;

},{"./SyntheticMouseEvent":178}],174:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule SyntheticEvent
 * @typechecks static-only
 */

"use strict";

var PooledClass = require("./PooledClass");

var emptyFunction = require("./emptyFunction");
var getEventTarget = require("./getEventTarget");
var merge = require("./merge");
var mergeInto = require("./mergeInto");

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var EventInterface = {
  type: null,
  target: getEventTarget,
  // currentTarget is set when dispatching; no use in copying it here
  currentTarget: emptyFunction.thatReturnsNull,
  eventPhase: null,
  bubbles: null,
  cancelable: null,
  timeStamp: function(event) {
    return event.timeStamp || Date.now();
  },
  defaultPrevented: null,
  isTrusted: null
};

/**
 * Synthetic events are dispatched by event plugins, typically in response to a
 * top-level event delegation handler.
 *
 * These systems should generally use pooling to reduce the frequency of garbage
 * collection. The system should check `isPersistent` to determine whether the
 * event should be released into the pool after being dispatched. Users that
 * need a persisted event should invoke `persist`.
 *
 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
 * normalizing browser quirks. Subclasses do not necessarily have to implement a
 * DOM interface; custom application-specific events can also subclass this.
 *
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 */
function SyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent) {
  this.dispatchConfig = dispatchConfig;
  this.dispatchMarker = dispatchMarker;
  this.nativeEvent = nativeEvent;

  var Interface = this.constructor.Interface;
  for (var propName in Interface) {
    if (!Interface.hasOwnProperty(propName)) {
      continue;
    }
    var normalize = Interface[propName];
    if (normalize) {
      this[propName] = normalize(nativeEvent);
    } else {
      this[propName] = nativeEvent[propName];
    }
  }

  var defaultPrevented = nativeEvent.defaultPrevented != null ?
    nativeEvent.defaultPrevented :
    nativeEvent.returnValue === false;
  if (defaultPrevented) {
    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
  } else {
    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
  }
  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
}

mergeInto(SyntheticEvent.prototype, {

  preventDefault: function() {
    this.defaultPrevented = true;
    var event = this.nativeEvent;
    event.preventDefault ? event.preventDefault() : event.returnValue = false;
    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
  },

  stopPropagation: function() {
    var event = this.nativeEvent;
    event.stopPropagation ? event.stopPropagation() : event.cancelBubble = true;
    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
  },

  /**
   * We release all dispatched `SyntheticEvent`s after each event loop, adding
   * them back into the pool. This allows a way to hold onto a reference that
   * won't be added back into the pool.
   */
  persist: function() {
    this.isPersistent = emptyFunction.thatReturnsTrue;
  },

  /**
   * Checks if this event should be released back into the pool.
   *
   * @return {boolean} True if this should not be released, false otherwise.
   */
  isPersistent: emptyFunction.thatReturnsFalse,

  /**
   * `PooledClass` looks for `destructor` on each instance it releases.
   */
  destructor: function() {
    var Interface = this.constructor.Interface;
    for (var propName in Interface) {
      this[propName] = null;
    }
    this.dispatchConfig = null;
    this.dispatchMarker = null;
    this.nativeEvent = null;
  }

});

SyntheticEvent.Interface = EventInterface;

/**
 * Helper to reduce boilerplate when creating subclasses.
 *
 * @param {function} Class
 * @param {?object} Interface
 */
SyntheticEvent.augmentClass = function(Class, Interface) {
  var Super = this;

  var prototype = Object.create(Super.prototype);
  mergeInto(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = merge(Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;

  PooledClass.addPoolingTo(Class, PooledClass.threeArgumentPooler);
};

PooledClass.addPoolingTo(SyntheticEvent, PooledClass.threeArgumentPooler);

module.exports = SyntheticEvent;

},{"./PooledClass":106,"./emptyFunction":194,"./getEventTarget":203,"./merge":222,"./mergeInto":224}],175:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule SyntheticFocusEvent
 * @typechecks static-only
 */

"use strict";

var SyntheticUIEvent = require("./SyntheticUIEvent");

/**
 * @interface FocusEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var FocusEventInterface = {
  relatedTarget: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent) {
  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
}

SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);

module.exports = SyntheticFocusEvent;

},{"./SyntheticUIEvent":180}],176:[function(require,module,exports){
/**
 * Copyright 2013 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule SyntheticInputEvent
 * @typechecks static-only
 */

"use strict";

var SyntheticEvent = require("./SyntheticEvent");

/**
 * @interface Event
 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
 *      /#events-inputevents
 */
var InputEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticInputEvent(
  dispatchConfig,
  dispatchMarker,
  nativeEvent) {
  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
}

SyntheticEvent.augmentClass(
  SyntheticInputEvent,
  InputEventInterface
);

module.exports = SyntheticInputEvent;


},{"./SyntheticEvent":174}],177:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule SyntheticKeyboardEvent
 * @typechecks static-only
 */

"use strict";

var SyntheticUIEvent = require("./SyntheticUIEvent");

var getEventKey = require("./getEventKey");
var getEventModifierState = require("./getEventModifierState");

/**
 * @interface KeyboardEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var KeyboardEventInterface = {
  key: getEventKey,
  location: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  repeat: null,
  locale: null,
  getModifierState: getEventModifierState,
  // Legacy Interface
  charCode: function(event) {
    // `charCode` is the result of a KeyPress event and represents the value of
    // the actual printable character.

    // KeyPress is deprecated but its replacement is not yet final and not
    // implemented in any major browser.
    if (event.type === 'keypress') {
      // IE8 does not implement "charCode", but "keyCode" has the correct value.
      return 'charCode' in event ? event.charCode : event.keyCode;
    }
    return 0;
  },
  keyCode: function(event) {
    // `keyCode` is the result of a KeyDown/Up event and represents the value of
    // physical keyboard key.

    // The actual meaning of the value depends on the users' keyboard layout
    // which cannot be detected. Assuming that it is a US keyboard layout
    // provides a surprisingly accurate mapping for US and European users.
    // Due to this, it is left to the user to implement at this time.
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  },
  which: function(event) {
    // `which` is an alias for either `keyCode` or `charCode` depending on the
    // type of the event. There is no need to determine the type of the event
    // as `keyCode` and `charCode` are either aliased or default to zero.
    return event.keyCode || event.charCode;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent) {
  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
}

SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);

module.exports = SyntheticKeyboardEvent;

},{"./SyntheticUIEvent":180,"./getEventKey":201,"./getEventModifierState":202}],178:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule SyntheticMouseEvent
 * @typechecks static-only
 */

"use strict";

var SyntheticUIEvent = require("./SyntheticUIEvent");
var ViewportMetrics = require("./ViewportMetrics");

var getEventModifierState = require("./getEventModifierState");

/**
 * @interface MouseEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var MouseEventInterface = {
  screenX: null,
  screenY: null,
  clientX: null,
  clientY: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  getModifierState: getEventModifierState,
  button: function(event) {
    // Webkit, Firefox, IE9+
    // which:  1 2 3
    // button: 0 1 2 (standard)
    var button = event.button;
    if ('which' in event) {
      return button;
    }
    // IE<9
    // which:  undefined
    // button: 0 0 0
    // button: 1 4 2 (onmouseup)
    return button === 2 ? 2 : button === 4 ? 1 : 0;
  },
  buttons: null,
  relatedTarget: function(event) {
    return event.relatedTarget || (
      event.fromElement === event.srcElement ?
        event.toElement :
        event.fromElement
    );
  },
  // "Proprietary" Interface.
  pageX: function(event) {
    return 'pageX' in event ?
      event.pageX :
      event.clientX + ViewportMetrics.currentScrollLeft;
  },
  pageY: function(event) {
    return 'pageY' in event ?
      event.pageY :
      event.clientY + ViewportMetrics.currentScrollTop;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent) {
  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
}

SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);

module.exports = SyntheticMouseEvent;

},{"./SyntheticUIEvent":180,"./ViewportMetrics":183,"./getEventModifierState":202}],179:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule SyntheticTouchEvent
 * @typechecks static-only
 */

"use strict";

var SyntheticUIEvent = require("./SyntheticUIEvent");

var getEventModifierState = require("./getEventModifierState");

/**
 * @interface TouchEvent
 * @see http://www.w3.org/TR/touch-events/
 */
var TouchEventInterface = {
  touches: null,
  targetTouches: null,
  changedTouches: null,
  altKey: null,
  metaKey: null,
  ctrlKey: null,
  shiftKey: null,
  getModifierState: getEventModifierState
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent) {
  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
}

SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);

module.exports = SyntheticTouchEvent;

},{"./SyntheticUIEvent":180,"./getEventModifierState":202}],180:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule SyntheticUIEvent
 * @typechecks static-only
 */

"use strict";

var SyntheticEvent = require("./SyntheticEvent");

var getEventTarget = require("./getEventTarget");

/**
 * @interface UIEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var UIEventInterface = {
  view: function(event) {
    if (event.view) {
      return event.view;
    }

    var target = getEventTarget(event);
    if (target != null && target.window === target) {
      // target is a window object
      return target;
    }

    var doc = target.ownerDocument;
    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
    if (doc) {
      return doc.defaultView || doc.parentWindow;
    } else {
      return window;
    }
  },
  detail: function(event) {
    return event.detail || 0;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent) {
  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
}

SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);

module.exports = SyntheticUIEvent;

},{"./SyntheticEvent":174,"./getEventTarget":203}],181:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule SyntheticWheelEvent
 * @typechecks static-only
 */

"use strict";

var SyntheticMouseEvent = require("./SyntheticMouseEvent");

/**
 * @interface WheelEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var WheelEventInterface = {
  deltaX: function(event) {
    return (
      'deltaX' in event ? event.deltaX :
      // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
      'wheelDeltaX' in event ? -event.wheelDeltaX : 0
    );
  },
  deltaY: function(event) {
    return (
      'deltaY' in event ? event.deltaY :
      // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
      'wheelDeltaY' in event ? -event.wheelDeltaY :
      // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
      'wheelDelta' in event ? -event.wheelDelta : 0
    );
  },
  deltaZ: null,

  // Browsers without "deltaMode" is reporting in raw wheel delta where one
  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
  deltaMode: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticMouseEvent}
 */
function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent) {
  SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
}

SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);

module.exports = SyntheticWheelEvent;

},{"./SyntheticMouseEvent":178}],182:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule Transaction
 */

"use strict";

var invariant = require("./invariant");

/**
 * `Transaction` creates a black box that is able to wrap any method such that
 * certain invariants are maintained before and after the method is invoked
 * (Even if an exception is thrown while invoking the wrapped method). Whoever
 * instantiates a transaction can provide enforcers of the invariants at
 * creation time. The `Transaction` class itself will supply one additional
 * automatic invariant for you - the invariant that any transaction instance
 * should not be run while it is already being run. You would typically create a
 * single instance of a `Transaction` for reuse multiple times, that potentially
 * is used to wrap several different methods. Wrappers are extremely simple -
 * they only require implementing two methods.
 *
 * <pre>
 *                       wrappers (injected at creation time)
 *                                      +        +
 *                                      |        |
 *                    +-----------------|--------|--------------+
 *                    |                 v        |              |
 *                    |      +---------------+   |              |
 *                    |   +--|    wrapper1   |---|----+         |
 *                    |   |  +---------------+   v    |         |
 *                    |   |          +-------------+  |         |
 *                    |   |     +----|   wrapper2  |--------+   |
 *                    |   |     |    +-------------+  |     |   |
 *                    |   |     |                     |     |   |
 *                    |   v     v                     v     v   | wrapper
 *                    | +---+ +---+   +---------+   +---+ +---+ | invariants
 * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained
 * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | +---+ +---+   +---------+   +---+ +---+ |
 *                    |  initialize                    close    |
 *                    +-----------------------------------------+
 * </pre>
 *
 * Use cases:
 * - Preserving the input selection ranges before/after reconciliation.
 *   Restoring selection even in the event of an unexpected error.
 * - Deactivating events while rearranging the DOM, preventing blurs/focuses,
 *   while guaranteeing that afterwards, the event system is reactivated.
 * - Flushing a queue of collected DOM mutations to the main UI thread after a
 *   reconciliation takes place in a worker thread.
 * - Invoking any collected `componentDidUpdate` callbacks after rendering new
 *   content.
 * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue
 *   to preserve the `scrollTop` (an automatic scroll aware DOM).
 * - (Future use case): Layout calculations before and after DOM upates.
 *
 * Transactional plugin API:
 * - A module that has an `initialize` method that returns any precomputation.
 * - and a `close` method that accepts the precomputation. `close` is invoked
 *   when the wrapped process is completed, or has failed.
 *
 * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules
 * that implement `initialize` and `close`.
 * @return {Transaction} Single transaction for reuse in thread.
 *
 * @class Transaction
 */
var Mixin = {
  /**
   * Sets up this instance so that it is prepared for collecting metrics. Does
   * so such that this setup method may be used on an instance that is already
   * initialized, in a way that does not consume additional memory upon reuse.
   * That can be useful if you decide to make your subclass of this mixin a
   * "PooledClass".
   */
  reinitializeTransaction: function() {
    this.transactionWrappers = this.getTransactionWrappers();
    if (!this.wrapperInitData) {
      this.wrapperInitData = [];
    } else {
      this.wrapperInitData.length = 0;
    }
    this._isInTransaction = false;
  },

  _isInTransaction: false,

  /**
   * @abstract
   * @return {Array<TransactionWrapper>} Array of transaction wrappers.
   */
  getTransactionWrappers: null,

  isInTransaction: function() {
    return !!this._isInTransaction;
  },

  /**
   * Executes the function within a safety window. Use this for the top level
   * methods that result in large amounts of computation/mutations that would
   * need to be safety checked.
   *
   * @param {function} method Member of scope to call.
   * @param {Object} scope Scope to invoke from.
   * @param {Object?=} args... Arguments to pass to the method (optional).
   *                           Helps prevent need to bind in many cases.
   * @return Return value from `method`.
   */
  perform: function(method, scope, a, b, c, d, e, f) {
    ("production" !== process.env.NODE_ENV ? invariant(
      !this.isInTransaction(),
      'Transaction.perform(...): Cannot initialize a transaction when there ' +
      'is already an outstanding transaction.'
    ) : invariant(!this.isInTransaction()));
    var errorThrown;
    var ret;
    try {
      this._isInTransaction = true;
      // Catching errors makes debugging more difficult, so we start with
      // errorThrown set to true before setting it to false after calling
      // close -- if it's still set to true in the finally block, it means
      // one of these calls threw.
      errorThrown = true;
      this.initializeAll(0);
      ret = method.call(scope, a, b, c, d, e, f);
      errorThrown = false;
    } finally {
      try {
        if (errorThrown) {
          // If `method` throws, prefer to show that stack trace over any thrown
          // by invoking `closeAll`.
          try {
            this.closeAll(0);
          } catch (err) {
          }
        } else {
          // Since `method` didn't throw, we don't want to silence the exception
          // here.
          this.closeAll(0);
        }
      } finally {
        this._isInTransaction = false;
      }
    }
    return ret;
  },

  initializeAll: function(startIndex) {
    var transactionWrappers = this.transactionWrappers;
    for (var i = startIndex; i < transactionWrappers.length; i++) {
      var wrapper = transactionWrappers[i];
      try {
        // Catching errors makes debugging more difficult, so we start with the
        // OBSERVED_ERROR state before overwriting it with the real return value
        // of initialize -- if it's still set to OBSERVED_ERROR in the finally
        // block, it means wrapper.initialize threw.
        this.wrapperInitData[i] = Transaction.OBSERVED_ERROR;
        this.wrapperInitData[i] = wrapper.initialize ?
          wrapper.initialize.call(this) :
          null;
      } finally {
        if (this.wrapperInitData[i] === Transaction.OBSERVED_ERROR) {
          // The initializer for wrapper i threw an error; initialize the
          // remaining wrappers but silence any exceptions from them to ensure
          // that the first error is the one to bubble up.
          try {
            this.initializeAll(i + 1);
          } catch (err) {
          }
        }
      }
    }
  },

  /**
   * Invokes each of `this.transactionWrappers.close[i]` functions, passing into
   * them the respective return values of `this.transactionWrappers.init[i]`
   * (`close`rs that correspond to initializers that failed will not be
   * invoked).
   */
  closeAll: function(startIndex) {
    ("production" !== process.env.NODE_ENV ? invariant(
      this.isInTransaction(),
      'Transaction.closeAll(): Cannot close transaction when none are open.'
    ) : invariant(this.isInTransaction()));
    var transactionWrappers = this.transactionWrappers;
    for (var i = startIndex; i < transactionWrappers.length; i++) {
      var wrapper = transactionWrappers[i];
      var initData = this.wrapperInitData[i];
      var errorThrown;
      try {
        // Catching errors makes debugging more difficult, so we start with
        // errorThrown set to true before setting it to false after calling
        // close -- if it's still set to true in the finally block, it means
        // wrapper.close threw.
        errorThrown = true;
        if (initData !== Transaction.OBSERVED_ERROR) {
          wrapper.close && wrapper.close.call(this, initData);
        }
        errorThrown = false;
      } finally {
        if (errorThrown) {
          // The closer for wrapper i threw an error; close the remaining
          // wrappers but silence any exceptions from them to ensure that the
          // first error is the one to bubble up.
          try {
            this.closeAll(i + 1);
          } catch (e) {
          }
        }
      }
    }
    this.wrapperInitData.length = 0;
  }
};

var Transaction = {

  Mixin: Mixin,

  /**
   * Token to look for to determine if an error occured.
   */
  OBSERVED_ERROR: {}

};

module.exports = Transaction;

}).call(this,require('_process'))
},{"./invariant":212,"_process":73}],183:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ViewportMetrics
 */

"use strict";

var getUnboundedScrollPosition = require("./getUnboundedScrollPosition");

var ViewportMetrics = {

  currentScrollLeft: 0,

  currentScrollTop: 0,

  refreshScrollValues: function() {
    var scrollPosition = getUnboundedScrollPosition(window);
    ViewportMetrics.currentScrollLeft = scrollPosition.x;
    ViewportMetrics.currentScrollTop = scrollPosition.y;
  }

};

module.exports = ViewportMetrics;

},{"./getUnboundedScrollPosition":208}],184:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule accumulate
 */

"use strict";

var invariant = require("./invariant");

/**
 * Accumulates items that must not be null or undefined.
 *
 * This is used to conserve memory by avoiding array allocations.
 *
 * @return {*|array<*>} An accumulation of items.
 */
function accumulate(current, next) {
  ("production" !== process.env.NODE_ENV ? invariant(
    next != null,
    'accumulate(...): Accumulated items must be not be null or undefined.'
  ) : invariant(next != null));
  if (current == null) {
    return next;
  } else {
    // Both are not empty. Warning: Never call x.concat(y) when you are not
    // certain that x is an Array (x could be a string with concat method).
    var currentIsArray = Array.isArray(current);
    var nextIsArray = Array.isArray(next);
    if (currentIsArray) {
      return current.concat(next);
    } else {
      if (nextIsArray) {
        return [current].concat(next);
      } else {
        return [current, next];
      }
    }
  }
}

module.exports = accumulate;

}).call(this,require('_process'))
},{"./invariant":212,"_process":73}],185:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule adler32
 */

/* jslint bitwise:true */

"use strict";

var MOD = 65521;

// This is a clean-room implementation of adler32 designed for detecting
// if markup is not what we expect it to be. It does not need to be
// cryptographically strong, only reasonable good at detecting if markup
// generated on the server is different than that on the client.
function adler32(data) {
  var a = 1;
  var b = 0;
  for (var i = 0; i < data.length; i++) {
    a = (a + data.charCodeAt(i)) % MOD;
    b = (b + a) % MOD;
  }
  return a | (b << 16);
}

module.exports = adler32;

},{}],186:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @typechecks
 * @providesModule cloneWithProps
 */

"use strict";

var ReactPropTransferer = require("./ReactPropTransferer");

var keyOf = require("./keyOf");
var warning = require("./warning");

var CHILDREN_PROP = keyOf({children: null});

/**
 * Sometimes you want to change the props of a child passed to you. Usually
 * this is to add a CSS class.
 *
 * @param {object} child child component you'd like to clone
 * @param {object} props props you'd like to modify. They will be merged
 * as if you used `transferPropsTo()`.
 * @return {object} a clone of child with props merged in.
 */
function cloneWithProps(child, props) {
  if ("production" !== process.env.NODE_ENV) {
    ("production" !== process.env.NODE_ENV ? warning(
      !child.props.ref,
      'You are calling cloneWithProps() on a child with a ref. This is ' +
      'dangerous because you\'re creating a new child which will not be ' +
      'added as a ref to its parent.'
    ) : null);
  }

  var newProps = ReactPropTransferer.mergeProps(props, child.props);

  // Use `child.props.children` if it is provided.
  if (!newProps.hasOwnProperty(CHILDREN_PROP) &&
      child.props.hasOwnProperty(CHILDREN_PROP)) {
    newProps.children = child.props.children;
  }

  // The current API doesn't retain _owner and _context, which is why this
  // doesn't use ReactDescriptor.cloneAndReplaceProps.
  return child.constructor(newProps);
}

module.exports = cloneWithProps;

}).call(this,require('_process'))
},{"./ReactPropTransferer":150,"./keyOf":219,"./warning":236,"_process":73}],187:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule containsNode
 * @typechecks
 */

var isTextNode = require("./isTextNode");

/*jslint bitwise:true */

/**
 * Checks if a given DOM node contains or is another DOM node.
 *
 * @param {?DOMNode} outerNode Outer DOM node.
 * @param {?DOMNode} innerNode Inner DOM node.
 * @return {boolean} True if `outerNode` contains or is `innerNode`.
 */
function containsNode(outerNode, innerNode) {
  if (!outerNode || !innerNode) {
    return false;
  } else if (outerNode === innerNode) {
    return true;
  } else if (isTextNode(outerNode)) {
    return false;
  } else if (isTextNode(innerNode)) {
    return containsNode(outerNode, innerNode.parentNode);
  } else if (outerNode.contains) {
    return outerNode.contains(innerNode);
  } else if (outerNode.compareDocumentPosition) {
    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
  } else {
    return false;
  }
}

module.exports = containsNode;

},{"./isTextNode":216}],188:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule copyProperties
 */

/**
 * Copy properties from one or more objects (up to 5) into the first object.
 * This is a shallow copy. It mutates the first object and also returns it.
 *
 * NOTE: `arguments` has a very significant performance penalty, which is why
 * we don't support unlimited arguments.
 */
function copyProperties(obj, a, b, c, d, e, f) {
  obj = obj || {};

  if ("production" !== process.env.NODE_ENV) {
    if (f) {
      throw new Error('Too many arguments passed to copyProperties');
    }
  }

  var args = [a, b, c, d, e];
  var ii = 0, v;
  while (args[ii]) {
    v = args[ii++];
    for (var k in v) {
      obj[k] = v[k];
    }

    // IE ignores toString in object iteration.. See:
    // webreflection.blogspot.com/2007/07/quick-fix-internet-explorer-and.html
    if (v.hasOwnProperty && v.hasOwnProperty('toString') &&
        (typeof v.toString != 'undefined') && (obj.toString !== v.toString)) {
      obj.toString = v.toString;
    }
  }

  return obj;
}

module.exports = copyProperties;

}).call(this,require('_process'))
},{"_process":73}],189:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule createArrayFrom
 * @typechecks
 */

var toArray = require("./toArray");

/**
 * Perform a heuristic test to determine if an object is "array-like".
 *
 *   A monk asked Joshu, a Zen master, "Has a dog Buddha nature?"
 *   Joshu replied: "Mu."
 *
 * This function determines if its argument has "array nature": it returns
 * true if the argument is an actual array, an `arguments' object, or an
 * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).
 *
 * It will return false for other array-like objects like Filelist.
 *
 * @param {*} obj
 * @return {boolean}
 */
function hasArrayNature(obj) {
  return (
    // not null/false
    !!obj &&
    // arrays are objects, NodeLists are functions in Safari
    (typeof obj == 'object' || typeof obj == 'function') &&
    // quacks like an array
    ('length' in obj) &&
    // not window
    !('setInterval' in obj) &&
    // no DOM node should be considered an array-like
    // a 'select' element has 'length' and 'item' properties on IE8
    (typeof obj.nodeType != 'number') &&
    (
      // a real array
      (// HTMLCollection/NodeList
      (Array.isArray(obj) ||
      // arguments
      ('callee' in obj) || 'item' in obj))
    )
  );
}

/**
 * Ensure that the argument is an array by wrapping it in an array if it is not.
 * Creates a copy of the argument if it is already an array.
 *
 * This is mostly useful idiomatically:
 *
 *   var createArrayFrom = require('createArrayFrom');
 *
 *   function takesOneOrMoreThings(things) {
 *     things = createArrayFrom(things);
 *     ...
 *   }
 *
 * This allows you to treat `things' as an array, but accept scalars in the API.
 *
 * If you need to convert an array-like object, like `arguments`, into an array
 * use toArray instead.
 *
 * @param {*} obj
 * @return {array}
 */
function createArrayFrom(obj) {
  if (!hasArrayNature(obj)) {
    return [obj];
  } else if (Array.isArray(obj)) {
    return obj.slice();
  } else {
    return toArray(obj);
  }
}

module.exports = createArrayFrom;

},{"./toArray":233}],190:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule createFullPageComponent
 * @typechecks
 */

"use strict";

// Defeat circular references by requiring this directly.
var ReactCompositeComponent = require("./ReactCompositeComponent");

var invariant = require("./invariant");

/**
 * Create a component that will throw an exception when unmounted.
 *
 * Components like <html> <head> and <body> can't be removed or added
 * easily in a cross-browser way, however it's valuable to be able to
 * take advantage of React's reconciliation for styling and <title>
 * management. So we just document it and throw in dangerous cases.
 *
 * @param {function} componentClass convenience constructor to wrap
 * @return {function} convenience constructor of new component
 */
function createFullPageComponent(componentClass) {
  var FullPageComponent = ReactCompositeComponent.createClass({
    displayName: 'ReactFullPageComponent' + (
      componentClass.type.displayName || ''
    ),

    componentWillUnmount: function() {
      ("production" !== process.env.NODE_ENV ? invariant(
        false,
        '%s tried to unmount. Because of cross-browser quirks it is ' +
        'impossible to unmount some top-level components (eg <html>, <head>, ' +
        'and <body>) reliably and efficiently. To fix this, have a single ' +
        'top-level component that never unmounts render these elements.',
        this.constructor.displayName
      ) : invariant(false));
    },

    render: function() {
      return this.transferPropsTo(componentClass(null, this.props.children));
    }
  });

  return FullPageComponent;
}

module.exports = createFullPageComponent;

}).call(this,require('_process'))
},{"./ReactCompositeComponent":116,"./invariant":212,"_process":73}],191:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule createNodesFromMarkup
 * @typechecks
 */

/*jslint evil: true, sub: true */

var ExecutionEnvironment = require("./ExecutionEnvironment");

var createArrayFrom = require("./createArrayFrom");
var getMarkupWrap = require("./getMarkupWrap");
var invariant = require("./invariant");

/**
 * Dummy container used to render all markup.
 */
var dummyNode =
  ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

/**
 * Pattern used by `getNodeName`.
 */
var nodeNamePattern = /^\s*<(\w+)/;

/**
 * Extracts the `nodeName` of the first element in a string of markup.
 *
 * @param {string} markup String of markup.
 * @return {?string} Node name of the supplied markup.
 */
function getNodeName(markup) {
  var nodeNameMatch = markup.match(nodeNamePattern);
  return nodeNameMatch && nodeNameMatch[1].toLowerCase();
}

/**
 * Creates an array containing the nodes rendered from the supplied markup. The
 * optionally supplied `handleScript` function will be invoked once for each
 * <script> element that is rendered. If no `handleScript` function is supplied,
 * an exception is thrown if any <script> elements are rendered.
 *
 * @param {string} markup A string of valid HTML markup.
 * @param {?function} handleScript Invoked once for each rendered <script>.
 * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.
 */
function createNodesFromMarkup(markup, handleScript) {
  var node = dummyNode;
  ("production" !== process.env.NODE_ENV ? invariant(!!dummyNode, 'createNodesFromMarkup dummy not initialized') : invariant(!!dummyNode));
  var nodeName = getNodeName(markup);

  var wrap = nodeName && getMarkupWrap(nodeName);
  if (wrap) {
    node.innerHTML = wrap[1] + markup + wrap[2];

    var wrapDepth = wrap[0];
    while (wrapDepth--) {
      node = node.lastChild;
    }
  } else {
    node.innerHTML = markup;
  }

  var scripts = node.getElementsByTagName('script');
  if (scripts.length) {
    ("production" !== process.env.NODE_ENV ? invariant(
      handleScript,
      'createNodesFromMarkup(...): Unexpected <script> element rendered.'
    ) : invariant(handleScript));
    createArrayFrom(scripts).forEach(handleScript);
  }

  var nodes = createArrayFrom(node.childNodes);
  while (node.lastChild) {
    node.removeChild(node.lastChild);
  }
  return nodes;
}

module.exports = createNodesFromMarkup;

}).call(this,require('_process'))
},{"./ExecutionEnvironment":100,"./createArrayFrom":189,"./getMarkupWrap":204,"./invariant":212,"_process":73}],192:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule cx
 */

/**
 * This function is used to mark string literals representing CSS class names
 * so that they can be transformed statically. This allows for modularization
 * and minification of CSS class names.
 *
 * In static_upstream, this function is actually implemented, but it should
 * eventually be replaced with something more descriptive, and the transform
 * that is used in the main stack should be ported for use elsewhere.
 *
 * @param string|object className to modularize, or an object of key/values.
 *                      In the object case, the values are conditions that
 *                      determine if the className keys should be included.
 * @param [string ...]  Variable list of classNames in the string case.
 * @return string       Renderable space-separated CSS className.
 */
function cx(classNames) {
  if (typeof classNames == 'object') {
    return Object.keys(classNames).filter(function(className) {
      return classNames[className];
    }).join(' ');
  } else {
    return Array.prototype.join.call(arguments, ' ');
  }
}

module.exports = cx;

},{}],193:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule dangerousStyleValue
 * @typechecks static-only
 */

"use strict";

var CSSProperty = require("./CSSProperty");

var isUnitlessNumber = CSSProperty.isUnitlessNumber;

/**
 * Convert a value into the proper css writable value. The style name `name`
 * should be logical (no hyphens), as specified
 * in `CSSProperty.isUnitlessNumber`.
 *
 * @param {string} name CSS property name such as `topMargin`.
 * @param {*} value CSS property value such as `10px`.
 * @return {string} Normalized style value with dimensions applied.
 */
function dangerousStyleValue(name, value) {
  // Note that we've removed escapeTextForBrowser() calls here since the
  // whole string will be escaped when the attribute is injected into
  // the markup. If you provide unsafe user data here they can inject
  // arbitrary CSS which may be problematic (I couldn't repro this):
  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
  // This is not an XSS hole but instead a potential CSS injection issue
  // which has lead to a greater discussion about how we're going to
  // trust URLs moving forward. See #2115901

  var isEmpty = value == null || typeof value === 'boolean' || value === '';
  if (isEmpty) {
    return '';
  }

  var isNonNumeric = isNaN(value);
  if (isNonNumeric || value === 0 ||
      isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
    return '' + value; // cast to string
  }

  if (typeof value === 'string') {
    value = value.trim();
  }
  return value + 'px';
}

module.exports = dangerousStyleValue;

},{"./CSSProperty":82}],194:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule emptyFunction
 */

var copyProperties = require("./copyProperties");

function makeEmptyFunction(arg) {
  return function() {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
function emptyFunction() {}

copyProperties(emptyFunction, {
  thatReturns: makeEmptyFunction,
  thatReturnsFalse: makeEmptyFunction(false),
  thatReturnsTrue: makeEmptyFunction(true),
  thatReturnsNull: makeEmptyFunction(null),
  thatReturnsThis: function() { return this; },
  thatReturnsArgument: function(arg) { return arg; }
});

module.exports = emptyFunction;

},{"./copyProperties":188}],195:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule emptyObject
 */

"use strict";

var emptyObject = {};

if ("production" !== process.env.NODE_ENV) {
  Object.freeze(emptyObject);
}

module.exports = emptyObject;

}).call(this,require('_process'))
},{"_process":73}],196:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule escapeTextForBrowser
 * @typechecks static-only
 */

"use strict";

var ESCAPE_LOOKUP = {
  "&": "&amp;",
  ">": "&gt;",
  "<": "&lt;",
  "\"": "&quot;",
  "'": "&#x27;"
};

var ESCAPE_REGEX = /[&><"']/g;

function escaper(match) {
  return ESCAPE_LOOKUP[match];
}

/**
 * Escapes text to prevent scripting attacks.
 *
 * @param {*} text Text value to escape.
 * @return {string} An escaped string.
 */
function escapeTextForBrowser(text) {
  return ('' + text).replace(ESCAPE_REGEX, escaper);
}

module.exports = escapeTextForBrowser;

},{}],197:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule flattenChildren
 */

"use strict";

var traverseAllChildren = require("./traverseAllChildren");
var warning = require("./warning");

/**
 * @param {function} traverseContext Context passed through traversal.
 * @param {?ReactComponent} child React child component.
 * @param {!string} name String name of key path to child.
 */
function flattenSingleChildIntoContext(traverseContext, child, name) {
  // We found a component instance.
  var result = traverseContext;
  var keyUnique = !result.hasOwnProperty(name);
  ("production" !== process.env.NODE_ENV ? warning(
    keyUnique,
    'flattenChildren(...): Encountered two children with the same key, ' +
    '`%s`. Child keys must be unique; when two children share a key, only ' +
    'the first child will be used.',
    name
  ) : null);
  if (keyUnique && child != null) {
    result[name] = child;
  }
}

/**
 * Flattens children that are typically specified as `props.children`. Any null
 * children will not be included in the resulting object.
 * @return {!object} flattened children keyed by name.
 */
function flattenChildren(children) {
  if (children == null) {
    return children;
  }
  var result = {};
  traverseAllChildren(children, flattenSingleChildIntoContext, result);
  return result;
}

module.exports = flattenChildren;

}).call(this,require('_process'))
},{"./traverseAllChildren":234,"./warning":236,"_process":73}],198:[function(require,module,exports){
/**
 * Copyright 2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule focusNode
 */

"use strict";

/**
 * IE8 throws if an input/textarea is disabled and we try to focus it.
 * Focus only when necessary.
 *
 * @param {DOMElement} node input/textarea to focus
 */
function focusNode(node) {
  if (!node.disabled) {
    node.focus();
  }
}

module.exports = focusNode;

},{}],199:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule forEachAccumulated
 */

"use strict";

/**
 * @param {array} an "accumulation" of items which is either an Array or
 * a single item. Useful when paired with the `accumulate` module. This is a
 * simple utility that allows us to reason about a collection of items, but
 * handling the case when there is exactly one item (and we do not need to
 * allocate an array).
 */
var forEachAccumulated = function(arr, cb, scope) {
  if (Array.isArray(arr)) {
    arr.forEach(cb, scope);
  } else if (arr) {
    cb.call(scope, arr);
  }
};

module.exports = forEachAccumulated;

},{}],200:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule getActiveElement
 * @typechecks
 */

/**
 * Same as document.activeElement but wraps in a try-catch block. In IE it is
 * not safe to call document.activeElement if there is nothing focused.
 *
 * The activeElement will be null only if the document body is not yet defined.
 */
function getActiveElement() /*?DOMElement*/ {
  try {
    return document.activeElement || document.body;
  } catch (e) {
    return document.body;
  }
}

module.exports = getActiveElement;

},{}],201:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule getEventKey
 * @typechecks static-only
 */

"use strict";

var invariant = require("./invariant");

/**
 * Normalization of deprecated HTML5 `key` values
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var normalizeKey = {
  'Esc': 'Escape',
  'Spacebar': ' ',
  'Left': 'ArrowLeft',
  'Up': 'ArrowUp',
  'Right': 'ArrowRight',
  'Down': 'ArrowDown',
  'Del': 'Delete',
  'Win': 'OS',
  'Menu': 'ContextMenu',
  'Apps': 'ContextMenu',
  'Scroll': 'ScrollLock',
  'MozPrintableKey': 'Unidentified'
};

/**
 * Translation from legacy `which`/`keyCode` to HTML5 `key`
 * Only special keys supported, all others depend on keyboard layout or browser
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var translateToKey = {
  8: 'Backspace',
  9: 'Tab',
  12: 'Clear',
  13: 'Enter',
  16: 'Shift',
  17: 'Control',
  18: 'Alt',
  19: 'Pause',
  20: 'CapsLock',
  27: 'Escape',
  32: ' ',
  33: 'PageUp',
  34: 'PageDown',
  35: 'End',
  36: 'Home',
  37: 'ArrowLeft',
  38: 'ArrowUp',
  39: 'ArrowRight',
  40: 'ArrowDown',
  45: 'Insert',
  46: 'Delete',
  112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6',
  118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12',
  144: 'NumLock',
  145: 'ScrollLock',
  224: 'Meta'
};

/**
 * @param {object} nativeEvent Native browser event.
 * @return {string} Normalized `key` property.
 */
function getEventKey(nativeEvent) {
  if (nativeEvent.key) {
    // Normalize inconsistent values reported by browsers due to
    // implementations of a working draft specification.

    // FireFox implements `key` but returns `MozPrintableKey` for all
    // printable characters (normalized to `Unidentified`), ignore it.
    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
    if (key !== 'Unidentified') {
      return key;
    }
  }

  // Browser does not implement `key`, polyfill as much of it as we can.
  if (nativeEvent.type === 'keypress') {
    // Create the character from the `charCode` ourselves and use as an almost
    // perfect replacement.
    var charCode = 'charCode' in nativeEvent ?
      nativeEvent.charCode :
      nativeEvent.keyCode;

    // The enter-key is technically both printable and non-printable and can
    // thus be captured by `keypress`, no other non-printable key should.
    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
  }
  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
    // While user keyboard layout determines the actual meaning of each
    // `keyCode` value, almost all function keys have a universal value.
    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
  }

  ("production" !== process.env.NODE_ENV ? invariant(false, "Unexpected keyboard event type: %s", nativeEvent.type) : invariant(false));
}

module.exports = getEventKey;

}).call(this,require('_process'))
},{"./invariant":212,"_process":73}],202:[function(require,module,exports){
/**
 * Copyright 2013 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule getEventModifierState
 * @typechecks static-only
 */

"use strict";

/**
 * Translation from modifier key to the associated property in the event.
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
 */

var modifierKeyToProp = {
  'Alt': 'altKey',
  'Control': 'ctrlKey',
  'Meta': 'metaKey',
  'Shift': 'shiftKey'
};

// IE8 does not implement getModifierState so we simply map it to the only
// modifier keys exposed by the event itself, does not support Lock-keys.
// Currently, all major browsers except Chrome seems to support Lock-keys.
function modifierStateGetter(keyArg) {
  /*jshint validthis:true */
  var syntheticEvent = this;
  var nativeEvent = syntheticEvent.nativeEvent;
  if (nativeEvent.getModifierState) {
    return nativeEvent.getModifierState(keyArg);
  }
  var keyProp = modifierKeyToProp[keyArg];
  return keyProp ? !!nativeEvent[keyProp] : false;
}

function getEventModifierState(nativeEvent) {
  return modifierStateGetter;
}

module.exports = getEventModifierState;

},{}],203:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule getEventTarget
 * @typechecks static-only
 */

"use strict";

/**
 * Gets the target node from a native browser event by accounting for
 * inconsistencies in browser DOM APIs.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {DOMEventTarget} Target node.
 */
function getEventTarget(nativeEvent) {
  var target = nativeEvent.target || nativeEvent.srcElement || window;
  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
  // @see http://www.quirksmode.org/js/events_properties.html
  return target.nodeType === 3 ? target.parentNode : target;
}

module.exports = getEventTarget;

},{}],204:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule getMarkupWrap
 */

var ExecutionEnvironment = require("./ExecutionEnvironment");

var invariant = require("./invariant");

/**
 * Dummy container used to detect which wraps are necessary.
 */
var dummyNode =
  ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

/**
 * Some browsers cannot use `innerHTML` to render certain elements standalone,
 * so we wrap them, render the wrapped nodes, then extract the desired node.
 *
 * In IE8, certain elements cannot render alone, so wrap all elements ('*').
 */
var shouldWrap = {
  // Force wrapping for SVG elements because if they get created inside a <div>,
  // they will be initialized in the wrong namespace (and will not display).
  'circle': true,
  'defs': true,
  'ellipse': true,
  'g': true,
  'line': true,
  'linearGradient': true,
  'path': true,
  'polygon': true,
  'polyline': true,
  'radialGradient': true,
  'rect': true,
  'stop': true,
  'text': true
};

var selectWrap = [1, '<select multiple="true">', '</select>'];
var tableWrap = [1, '<table>', '</table>'];
var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];

var svgWrap = [1, '<svg>', '</svg>'];

var markupWrap = {
  '*': [1, '?<div>', '</div>'],

  'area': [1, '<map>', '</map>'],
  'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
  'legend': [1, '<fieldset>', '</fieldset>'],
  'param': [1, '<object>', '</object>'],
  'tr': [2, '<table><tbody>', '</tbody></table>'],

  'optgroup': selectWrap,
  'option': selectWrap,

  'caption': tableWrap,
  'colgroup': tableWrap,
  'tbody': tableWrap,
  'tfoot': tableWrap,
  'thead': tableWrap,

  'td': trWrap,
  'th': trWrap,

  'circle': svgWrap,
  'defs': svgWrap,
  'ellipse': svgWrap,
  'g': svgWrap,
  'line': svgWrap,
  'linearGradient': svgWrap,
  'path': svgWrap,
  'polygon': svgWrap,
  'polyline': svgWrap,
  'radialGradient': svgWrap,
  'rect': svgWrap,
  'stop': svgWrap,
  'text': svgWrap
};

/**
 * Gets the markup wrap configuration for the supplied `nodeName`.
 *
 * NOTE: This lazily detects which wraps are necessary for the current browser.
 *
 * @param {string} nodeName Lowercase `nodeName`.
 * @return {?array} Markup wrap configuration, if applicable.
 */
function getMarkupWrap(nodeName) {
  ("production" !== process.env.NODE_ENV ? invariant(!!dummyNode, 'Markup wrapping node not initialized') : invariant(!!dummyNode));
  if (!markupWrap.hasOwnProperty(nodeName)) {
    nodeName = '*';
  }
  if (!shouldWrap.hasOwnProperty(nodeName)) {
    if (nodeName === '*') {
      dummyNode.innerHTML = '<link />';
    } else {
      dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
    }
    shouldWrap[nodeName] = !dummyNode.firstChild;
  }
  return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
}


module.exports = getMarkupWrap;

}).call(this,require('_process'))
},{"./ExecutionEnvironment":100,"./invariant":212,"_process":73}],205:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule getNodeForCharacterOffset
 */

"use strict";

/**
 * Given any node return the first leaf node without children.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {DOMElement|DOMTextNode}
 */
function getLeafNode(node) {
  while (node && node.firstChild) {
    node = node.firstChild;
  }
  return node;
}

/**
 * Get the next sibling within a container. This will walk up the
 * DOM if a node's siblings have been exhausted.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {?DOMElement|DOMTextNode}
 */
function getSiblingNode(node) {
  while (node) {
    if (node.nextSibling) {
      return node.nextSibling;
    }
    node = node.parentNode;
  }
}

/**
 * Get object describing the nodes which contain characters at offset.
 *
 * @param {DOMElement|DOMTextNode} root
 * @param {number} offset
 * @return {?object}
 */
function getNodeForCharacterOffset(root, offset) {
  var node = getLeafNode(root);
  var nodeStart = 0;
  var nodeEnd = 0;

  while (node) {
    if (node.nodeType == 3) {
      nodeEnd = nodeStart + node.textContent.length;

      if (nodeStart <= offset && nodeEnd >= offset) {
        return {
          node: node,
          offset: offset - nodeStart
        };
      }

      nodeStart = nodeEnd;
    }

    node = getLeafNode(getSiblingNode(node));
  }
}

module.exports = getNodeForCharacterOffset;

},{}],206:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule getReactRootElementInContainer
 */

"use strict";

var DOC_NODE_TYPE = 9;

/**
 * @param {DOMElement|DOMDocument} container DOM element that may contain
 *                                           a React component
 * @return {?*} DOM element that may have the reactRoot ID, or null.
 */
function getReactRootElementInContainer(container) {
  if (!container) {
    return null;
  }

  if (container.nodeType === DOC_NODE_TYPE) {
    return container.documentElement;
  } else {
    return container.firstChild;
  }
}

module.exports = getReactRootElementInContainer;

},{}],207:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule getTextContentAccessor
 */

"use strict";

var ExecutionEnvironment = require("./ExecutionEnvironment");

var contentKey = null;

/**
 * Gets the key used to access text content on a DOM node.
 *
 * @return {?string} Key used to access text content.
 * @internal
 */
function getTextContentAccessor() {
  if (!contentKey && ExecutionEnvironment.canUseDOM) {
    // Prefer textContent to innerText because many browsers support both but
    // SVG <text> elements don't support innerText even when <div> does.
    contentKey = 'textContent' in document.documentElement ?
      'textContent' :
      'innerText';
  }
  return contentKey;
}

module.exports = getTextContentAccessor;

},{"./ExecutionEnvironment":100}],208:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule getUnboundedScrollPosition
 * @typechecks
 */

"use strict";

/**
 * Gets the scroll position of the supplied element or window.
 *
 * The return values are unbounded, unlike `getScrollPosition`. This means they
 * may be negative or exceed the element boundaries (which is possible using
 * inertial scrolling).
 *
 * @param {DOMWindow|DOMElement} scrollable
 * @return {object} Map with `x` and `y` keys.
 */
function getUnboundedScrollPosition(scrollable) {
  if (scrollable === window) {
    return {
      x: window.pageXOffset || document.documentElement.scrollLeft,
      y: window.pageYOffset || document.documentElement.scrollTop
    };
  }
  return {
    x: scrollable.scrollLeft,
    y: scrollable.scrollTop
  };
}

module.exports = getUnboundedScrollPosition;

},{}],209:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule hyphenate
 * @typechecks
 */

var _uppercasePattern = /([A-Z])/g;

/**
 * Hyphenates a camelcased string, for example:
 *
 *   > hyphenate('backgroundColor')
 *   < "background-color"
 *
 * For CSS style names, use `hyphenateStyleName` instead which works properly
 * with all vendor prefixes, including `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenate(string) {
  return string.replace(_uppercasePattern, '-$1').toLowerCase();
}

module.exports = hyphenate;

},{}],210:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule hyphenateStyleName
 * @typechecks
 */

"use strict";

var hyphenate = require("./hyphenate");

var msPattern = /^ms-/;

/**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenate('backgroundColor')
 *   < "background-color"
 *   > hyphenate('MozTransition')
 *   < "-moz-transition"
 *   > hyphenate('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenateStyleName(string) {
  return hyphenate(string).replace(msPattern, '-ms-');
}

module.exports = hyphenateStyleName;

},{"./hyphenate":209}],211:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule instantiateReactComponent
 * @typechecks static-only
 */

"use strict";

var invariant = require("./invariant");

/**
 * Validate a `componentDescriptor`. This should be exposed publicly in a follow
 * up diff.
 *
 * @param {object} descriptor
 * @return {boolean} Returns true if this is a valid descriptor of a Component.
 */
function isValidComponentDescriptor(descriptor) {
  return (
    descriptor &&
    typeof descriptor.type === 'function' &&
    typeof descriptor.type.prototype.mountComponent === 'function' &&
    typeof descriptor.type.prototype.receiveComponent === 'function'
  );
}

/**
 * Given a `componentDescriptor` create an instance that will actually be
 * mounted. Currently it just extracts an existing clone from composite
 * components but this is an implementation detail which will change.
 *
 * @param {object} descriptor
 * @return {object} A new instance of componentDescriptor's constructor.
 * @protected
 */
function instantiateReactComponent(descriptor) {

  // TODO: Make warning
  // if (__DEV__) {
    ("production" !== process.env.NODE_ENV ? invariant(
      isValidComponentDescriptor(descriptor),
      'Only React Components are valid for mounting.'
    ) : invariant(isValidComponentDescriptor(descriptor)));
  // }

  return new descriptor.type(descriptor);
}

module.exports = instantiateReactComponent;

}).call(this,require('_process'))
},{"./invariant":212,"_process":73}],212:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule invariant
 */

"use strict";

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function(condition, format, a, b, c, d, e, f) {
  if ("production" !== process.env.NODE_ENV) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        'Invariant Violation: ' +
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;

}).call(this,require('_process'))
},{"_process":73}],213:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule isEventSupported
 */

"use strict";

var ExecutionEnvironment = require("./ExecutionEnvironment");

var useHasFeature;
if (ExecutionEnvironment.canUseDOM) {
  useHasFeature =
    document.implementation &&
    document.implementation.hasFeature &&
    // always returns true in newer browsers as per the standard.
    // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
    document.implementation.hasFeature('', '') !== true;
}

/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
function isEventSupported(eventNameSuffix, capture) {
  if (!ExecutionEnvironment.canUseDOM ||
      capture && !('addEventListener' in document)) {
    return false;
  }

  var eventName = 'on' + eventNameSuffix;
  var isSupported = eventName in document;

  if (!isSupported) {
    var element = document.createElement('div');
    element.setAttribute(eventName, 'return;');
    isSupported = typeof element[eventName] === 'function';
  }

  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
    // This is the only way to test support for the `wheel` event in IE9+.
    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
  }

  return isSupported;
}

module.exports = isEventSupported;

},{"./ExecutionEnvironment":100}],214:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule isNode
 * @typechecks
 */

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM node.
 */
function isNode(object) {
  return !!(object && (
    typeof Node === 'function' ? object instanceof Node :
      typeof object === 'object' &&
      typeof object.nodeType === 'number' &&
      typeof object.nodeName === 'string'
  ));
}

module.exports = isNode;

},{}],215:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule isTextInputElement
 */

"use strict";

/**
 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
 */
var supportedInputTypes = {
  'color': true,
  'date': true,
  'datetime': true,
  'datetime-local': true,
  'email': true,
  'month': true,
  'number': true,
  'password': true,
  'range': true,
  'search': true,
  'tel': true,
  'text': true,
  'time': true,
  'url': true,
  'week': true
};

function isTextInputElement(elem) {
  return elem && (
    (elem.nodeName === 'INPUT' && supportedInputTypes[elem.type]) ||
    elem.nodeName === 'TEXTAREA'
  );
}

module.exports = isTextInputElement;

},{}],216:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule isTextNode
 * @typechecks
 */

var isNode = require("./isNode");

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM text node.
 */
function isTextNode(object) {
  return isNode(object) && object.nodeType == 3;
}

module.exports = isTextNode;

},{"./isNode":214}],217:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule joinClasses
 * @typechecks static-only
 */

"use strict";

/**
 * Combines multiple className strings into one.
 * http://jsperf.com/joinclasses-args-vs-array
 *
 * @param {...?string} classes
 * @return {string}
 */
function joinClasses(className/*, ... */) {
  if (!className) {
    className = '';
  }
  var nextClass;
  var argLength = arguments.length;
  if (argLength > 1) {
    for (var ii = 1; ii < argLength; ii++) {
      nextClass = arguments[ii];
      nextClass && (className += ' ' + nextClass);
    }
  }
  return className;
}

module.exports = joinClasses;

},{}],218:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule keyMirror
 * @typechecks static-only
 */

"use strict";

var invariant = require("./invariant");

/**
 * Constructs an enumeration with keys equal to their value.
 *
 * For example:
 *
 *   var COLORS = keyMirror({blue: null, red: null});
 *   var myColor = COLORS.blue;
 *   var isColorValid = !!COLORS[myColor];
 *
 * The last line could not be performed if the values of the generated enum were
 * not equal to their keys.
 *
 *   Input:  {key1: val1, key2: val2}
 *   Output: {key1: key1, key2: key2}
 *
 * @param {object} obj
 * @return {object}
 */
var keyMirror = function(obj) {
  var ret = {};
  var key;
  ("production" !== process.env.NODE_ENV ? invariant(
    obj instanceof Object && !Array.isArray(obj),
    'keyMirror(...): Argument must be an object.'
  ) : invariant(obj instanceof Object && !Array.isArray(obj)));
  for (key in obj) {
    if (!obj.hasOwnProperty(key)) {
      continue;
    }
    ret[key] = key;
  }
  return ret;
};

module.exports = keyMirror;

}).call(this,require('_process'))
},{"./invariant":212,"_process":73}],219:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule keyOf
 */

/**
 * Allows extraction of a minified key. Let's the build system minify keys
 * without loosing the ability to dynamically use key strings as values
 * themselves. Pass in an object with a single key/val pair and it will return
 * you the string key of that single record. Suppose you want to grab the
 * value for a key 'className' inside of an object. Key/val minification may
 * have aliased that key to be 'xa12'. keyOf({className: null}) will return
 * 'xa12' in that case. Resolve keys you want to use once at startup time, then
 * reuse those resolutions.
 */
var keyOf = function(oneKeyObj) {
  var key;
  for (key in oneKeyObj) {
    if (!oneKeyObj.hasOwnProperty(key)) {
      continue;
    }
    return key;
  }
  return null;
};


module.exports = keyOf;

},{}],220:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule mapObject
 */

"use strict";

/**
 * For each key/value pair, invokes callback func and constructs a resulting
 * object which contains, for every key in obj, values that are the result of
 * of invoking the function:
 *
 *   func(value, key, iteration)
 *
 * Grepable names:
 *
 *   function objectMap()
 *   function objMap()
 *
 * @param {?object} obj Object to map keys over
 * @param {function} func Invoked for each key/val pair.
 * @param {?*} context
 * @return {?object} Result of mapping or null if obj is falsey
 */
function mapObject(obj, func, context) {
  if (!obj) {
    return null;
  }
  var i = 0;
  var ret = {};
  for (var key in obj) {
    if (obj.hasOwnProperty(key)) {
      ret[key] = func.call(context, obj[key], key, i++);
    }
  }
  return ret;
}

module.exports = mapObject;

},{}],221:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule memoizeStringOnly
 * @typechecks static-only
 */

"use strict";

/**
 * Memoizes the return value of a function that accepts one string argument.
 *
 * @param {function} callback
 * @return {function}
 */
function memoizeStringOnly(callback) {
  var cache = {};
  return function(string) {
    if (cache.hasOwnProperty(string)) {
      return cache[string];
    } else {
      return cache[string] = callback.call(this, string);
    }
  };
}

module.exports = memoizeStringOnly;

},{}],222:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule merge
 */

"use strict";

var mergeInto = require("./mergeInto");

/**
 * Shallow merges two structures into a return value, without mutating either.
 *
 * @param {?object} one Optional object with properties to merge from.
 * @param {?object} two Optional object with properties to merge from.
 * @return {object} The shallow extension of one by two.
 */
var merge = function(one, two) {
  var result = {};
  mergeInto(result, one);
  mergeInto(result, two);
  return result;
};

module.exports = merge;

},{"./mergeInto":224}],223:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule mergeHelpers
 *
 * requiresPolyfills: Array.isArray
 */

"use strict";

var invariant = require("./invariant");
var keyMirror = require("./keyMirror");

/**
 * Maximum number of levels to traverse. Will catch circular structures.
 * @const
 */
var MAX_MERGE_DEPTH = 36;

/**
 * We won't worry about edge cases like new String('x') or new Boolean(true).
 * Functions are considered terminals, and arrays are not.
 * @param {*} o The item/object/value to test.
 * @return {boolean} true iff the argument is a terminal.
 */
var isTerminal = function(o) {
  return typeof o !== 'object' || o === null;
};

var mergeHelpers = {

  MAX_MERGE_DEPTH: MAX_MERGE_DEPTH,

  isTerminal: isTerminal,

  /**
   * Converts null/undefined values into empty object.
   *
   * @param {?Object=} arg Argument to be normalized (nullable optional)
   * @return {!Object}
   */
  normalizeMergeArg: function(arg) {
    return arg === undefined || arg === null ? {} : arg;
  },

  /**
   * If merging Arrays, a merge strategy *must* be supplied. If not, it is
   * likely the caller's fault. If this function is ever called with anything
   * but `one` and `two` being `Array`s, it is the fault of the merge utilities.
   *
   * @param {*} one Array to merge into.
   * @param {*} two Array to merge from.
   */
  checkMergeArrayArgs: function(one, two) {
    ("production" !== process.env.NODE_ENV ? invariant(
      Array.isArray(one) && Array.isArray(two),
      'Tried to merge arrays, instead got %s and %s.',
      one,
      two
    ) : invariant(Array.isArray(one) && Array.isArray(two)));
  },

  /**
   * @param {*} one Object to merge into.
   * @param {*} two Object to merge from.
   */
  checkMergeObjectArgs: function(one, two) {
    mergeHelpers.checkMergeObjectArg(one);
    mergeHelpers.checkMergeObjectArg(two);
  },

  /**
   * @param {*} arg
   */
  checkMergeObjectArg: function(arg) {
    ("production" !== process.env.NODE_ENV ? invariant(
      !isTerminal(arg) && !Array.isArray(arg),
      'Tried to merge an object, instead got %s.',
      arg
    ) : invariant(!isTerminal(arg) && !Array.isArray(arg)));
  },

  /**
   * @param {*} arg
   */
  checkMergeIntoObjectArg: function(arg) {
    ("production" !== process.env.NODE_ENV ? invariant(
      (!isTerminal(arg) || typeof arg === 'function') && !Array.isArray(arg),
      'Tried to merge into an object, instead got %s.',
      arg
    ) : invariant((!isTerminal(arg) || typeof arg === 'function') && !Array.isArray(arg)));
  },

  /**
   * Checks that a merge was not given a circular object or an object that had
   * too great of depth.
   *
   * @param {number} Level of recursion to validate against maximum.
   */
  checkMergeLevel: function(level) {
    ("production" !== process.env.NODE_ENV ? invariant(
      level < MAX_MERGE_DEPTH,
      'Maximum deep merge depth exceeded. You may be attempting to merge ' +
      'circular structures in an unsupported way.'
    ) : invariant(level < MAX_MERGE_DEPTH));
  },

  /**
   * Checks that the supplied merge strategy is valid.
   *
   * @param {string} Array merge strategy.
   */
  checkArrayStrategy: function(strategy) {
    ("production" !== process.env.NODE_ENV ? invariant(
      strategy === undefined || strategy in mergeHelpers.ArrayStrategies,
      'You must provide an array strategy to deep merge functions to ' +
      'instruct the deep merge how to resolve merging two arrays.'
    ) : invariant(strategy === undefined || strategy in mergeHelpers.ArrayStrategies));
  },

  /**
   * Set of possible behaviors of merge algorithms when encountering two Arrays
   * that must be merged together.
   * - `clobber`: The left `Array` is ignored.
   * - `indexByIndex`: The result is achieved by recursively deep merging at
   *   each index. (not yet supported.)
   */
  ArrayStrategies: keyMirror({
    Clobber: true,
    IndexByIndex: true
  })

};

module.exports = mergeHelpers;

}).call(this,require('_process'))
},{"./invariant":212,"./keyMirror":218,"_process":73}],224:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule mergeInto
 * @typechecks static-only
 */

"use strict";

var mergeHelpers = require("./mergeHelpers");

var checkMergeObjectArg = mergeHelpers.checkMergeObjectArg;
var checkMergeIntoObjectArg = mergeHelpers.checkMergeIntoObjectArg;

/**
 * Shallow merges two structures by mutating the first parameter.
 *
 * @param {object|function} one Object to be merged into.
 * @param {?object} two Optional object with properties to merge from.
 */
function mergeInto(one, two) {
  checkMergeIntoObjectArg(one);
  if (two != null) {
    checkMergeObjectArg(two);
    for (var key in two) {
      if (!two.hasOwnProperty(key)) {
        continue;
      }
      one[key] = two[key];
    }
  }
}

module.exports = mergeInto;

},{"./mergeHelpers":223}],225:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule mixInto
 */

"use strict";

/**
 * Simply copies properties to the prototype.
 */
var mixInto = function(constructor, methodBag) {
  var methodName;
  for (methodName in methodBag) {
    if (!methodBag.hasOwnProperty(methodName)) {
      continue;
    }
    constructor.prototype[methodName] = methodBag[methodName];
  }
};

module.exports = mixInto;

},{}],226:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule monitorCodeUse
 */

"use strict";

var invariant = require("./invariant");

/**
 * Provides open-source compatible instrumentation for monitoring certain API
 * uses before we're ready to issue a warning or refactor. It accepts an event
 * name which may only contain the characters [a-z0-9_] and an optional data
 * object with further information.
 */

function monitorCodeUse(eventName, data) {
  ("production" !== process.env.NODE_ENV ? invariant(
    eventName && !/[^a-z0-9_]/.test(eventName),
    'You must provide an eventName using only the characters [a-z0-9_]'
  ) : invariant(eventName && !/[^a-z0-9_]/.test(eventName)));
}

module.exports = monitorCodeUse;

}).call(this,require('_process'))
},{"./invariant":212,"_process":73}],227:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule onlyChild
 */
"use strict";

var ReactDescriptor = require("./ReactDescriptor");

var invariant = require("./invariant");

/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection. The current implementation of this
 * function assumes that a single child gets passed without a wrapper, but the
 * purpose of this helper function is to abstract away the particular structure
 * of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactComponent} The first and only `ReactComponent` contained in the
 * structure.
 */
function onlyChild(children) {
  ("production" !== process.env.NODE_ENV ? invariant(
    ReactDescriptor.isValidDescriptor(children),
    'onlyChild must be passed a children with exactly one child.'
  ) : invariant(ReactDescriptor.isValidDescriptor(children)));
  return children;
}

module.exports = onlyChild;

}).call(this,require('_process'))
},{"./ReactDescriptor":134,"./invariant":212,"_process":73}],228:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule performance
 * @typechecks
 */

"use strict";

var ExecutionEnvironment = require("./ExecutionEnvironment");

var performance;

if (ExecutionEnvironment.canUseDOM) {
  performance =
    window.performance ||
    window.msPerformance ||
    window.webkitPerformance;
}

module.exports = performance || {};

},{"./ExecutionEnvironment":100}],229:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule performanceNow
 * @typechecks
 */

var performance = require("./performance");

/**
 * Detect if we can use `window.performance.now()` and gracefully fallback to
 * `Date.now()` if it doesn't exist. We need to support Firefox < 15 for now
 * because of Facebook's testing infrastructure.
 */
if (!performance || !performance.now) {
  performance = Date;
}

var performanceNow = performance.now.bind(performance);

module.exports = performanceNow;

},{"./performance":228}],230:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule setInnerHTML
 */

"use strict";

var ExecutionEnvironment = require("./ExecutionEnvironment");

/**
 * Set the innerHTML property of a node, ensuring that whitespace is preserved
 * even in IE8.
 *
 * @param {DOMElement} node
 * @param {string} html
 * @internal
 */
var setInnerHTML = function(node, html) {
  node.innerHTML = html;
};

if (ExecutionEnvironment.canUseDOM) {
  // IE8: When updating a just created node with innerHTML only leading
  // whitespace is removed. When updating an existing node with innerHTML
  // whitespace in root TextNodes is also collapsed.
  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html

  // Feature detection; only IE8 is known to behave improperly like this.
  var testElement = document.createElement('div');
  testElement.innerHTML = ' ';
  if (testElement.innerHTML === '') {
    setInnerHTML = function(node, html) {
      // Magic theory: IE8 supposedly differentiates between added and updated
      // nodes when processing innerHTML, innerHTML on updated nodes suffers
      // from worse whitespace behavior. Re-adding a node like this triggers
      // the initial and more favorable whitespace behavior.
      // TODO: What to do on a detached node?
      if (node.parentNode) {
        node.parentNode.replaceChild(node, node);
      }

      // We also implement a workaround for non-visible tags disappearing into
      // thin air on IE8, this only happens if there is no visible text
      // in-front of the non-visible tags. Piggyback on the whitespace fix
      // and simply check if any non-visible tags appear in the source.
      if (html.match(/^[ \r\n\t\f]/) ||
          html[0] === '<' && (
            html.indexOf('<noscript') !== -1 ||
            html.indexOf('<script') !== -1 ||
            html.indexOf('<style') !== -1 ||
            html.indexOf('<meta') !== -1 ||
            html.indexOf('<link') !== -1)) {
        // Recover leading whitespace by temporarily prepending any character.
        // \uFEFF has the potential advantage of being zero-width/invisible.
        node.innerHTML = '\uFEFF' + html;

        // deleteData leaves an empty `TextNode` which offsets the index of all
        // children. Definitely want to avoid this.
        var textNode = node.firstChild;
        if (textNode.data.length === 1) {
          node.removeChild(textNode);
        } else {
          textNode.deleteData(0, 1);
        }
      } else {
        node.innerHTML = html;
      }
    };
  }
}

module.exports = setInnerHTML;

},{"./ExecutionEnvironment":100}],231:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule shallowEqual
 */

"use strict";

/**
 * Performs equality by iterating through keys on an object and returning
 * false when any key has values which are not strictly equal between
 * objA and objB. Returns true when the values of all keys are strictly equal.
 *
 * @return {boolean}
 */
function shallowEqual(objA, objB) {
  if (objA === objB) {
    return true;
  }
  var key;
  // Test for A's keys different from B.
  for (key in objA) {
    if (objA.hasOwnProperty(key) &&
        (!objB.hasOwnProperty(key) || objA[key] !== objB[key])) {
      return false;
    }
  }
  // Test for B'a keys missing from A.
  for (key in objB) {
    if (objB.hasOwnProperty(key) && !objA.hasOwnProperty(key)) {
      return false;
    }
  }
  return true;
}

module.exports = shallowEqual;

},{}],232:[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule shouldUpdateReactComponent
 * @typechecks static-only
 */

"use strict";

/**
 * Given a `prevDescriptor` and `nextDescriptor`, determines if the existing
 * instance should be updated as opposed to being destroyed or replaced by a new
 * instance. Both arguments are descriptors. This ensures that this logic can
 * operate on stateless trees without any backing instance.
 *
 * @param {?object} prevDescriptor
 * @param {?object} nextDescriptor
 * @return {boolean} True if the existing instance should be updated.
 * @protected
 */
function shouldUpdateReactComponent(prevDescriptor, nextDescriptor) {
  if (prevDescriptor && nextDescriptor &&
      prevDescriptor.type === nextDescriptor.type && (
        (prevDescriptor.props && prevDescriptor.props.key) ===
        (nextDescriptor.props && nextDescriptor.props.key)
      ) && prevDescriptor._owner === nextDescriptor._owner) {
    return true;
  }
  return false;
}

module.exports = shouldUpdateReactComponent;

},{}],233:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule toArray
 * @typechecks
 */

var invariant = require("./invariant");

/**
 * Convert array-like objects to arrays.
 *
 * This API assumes the caller knows the contents of the data type. For less
 * well defined inputs use createArrayFrom.
 *
 * @param {object|function|filelist} obj
 * @return {array}
 */
function toArray(obj) {
  var length = obj.length;

  // Some browse builtin objects can report typeof 'function' (e.g. NodeList in
  // old versions of Safari).
  ("production" !== process.env.NODE_ENV ? invariant(
    !Array.isArray(obj) &&
    (typeof obj === 'object' || typeof obj === 'function'),
    'toArray: Array-like object expected'
  ) : invariant(!Array.isArray(obj) &&
  (typeof obj === 'object' || typeof obj === 'function')));

  ("production" !== process.env.NODE_ENV ? invariant(
    typeof length === 'number',
    'toArray: Object needs a length property'
  ) : invariant(typeof length === 'number'));

  ("production" !== process.env.NODE_ENV ? invariant(
    length === 0 ||
    (length - 1) in obj,
    'toArray: Object should have keys for indices'
  ) : invariant(length === 0 ||
  (length - 1) in obj));

  // Old IE doesn't give collections access to hasOwnProperty. Assume inputs
  // without method will throw during the slice call and skip straight to the
  // fallback.
  if (obj.hasOwnProperty) {
    try {
      return Array.prototype.slice.call(obj);
    } catch (e) {
      // IE < 9 does not support Array#slice on collections objects
    }
  }

  // Fall back to copying key by key. This assumes all keys have a value,
  // so will not preserve sparsely populated inputs.
  var ret = Array(length);
  for (var ii = 0; ii < length; ii++) {
    ret[ii] = obj[ii];
  }
  return ret;
}

module.exports = toArray;

}).call(this,require('_process'))
},{"./invariant":212,"_process":73}],234:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule traverseAllChildren
 */

"use strict";

var ReactInstanceHandles = require("./ReactInstanceHandles");
var ReactTextComponent = require("./ReactTextComponent");

var invariant = require("./invariant");

var SEPARATOR = ReactInstanceHandles.SEPARATOR;
var SUBSEPARATOR = ':';

/**
 * TODO: Test that:
 * 1. `mapChildren` transforms strings and numbers into `ReactTextComponent`.
 * 2. it('should fail when supplied duplicate key', function() {
 * 3. That a single child and an array with one item have the same key pattern.
 * });
 */

var userProvidedKeyEscaperLookup = {
  '=': '=0',
  '.': '=1',
  ':': '=2'
};

var userProvidedKeyEscapeRegex = /[=.:]/g;

function userProvidedKeyEscaper(match) {
  return userProvidedKeyEscaperLookup[match];
}

/**
 * Generate a key string that identifies a component within a set.
 *
 * @param {*} component A component that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */
function getComponentKey(component, index) {
  if (component && component.props && component.props.key != null) {
    // Explicit key
    return wrapUserProvidedKey(component.props.key);
  }
  // Implicit key determined by the index in the set
  return index.toString(36);
}

/**
 * Escape a component key so that it is safe to use in a reactid.
 *
 * @param {*} key Component key to be escaped.
 * @return {string} An escaped string.
 */
function escapeUserProvidedKey(text) {
  return ('' + text).replace(
    userProvidedKeyEscapeRegex,
    userProvidedKeyEscaper
  );
}

/**
 * Wrap a `key` value explicitly provided by the user to distinguish it from
 * implicitly-generated keys generated by a component's index in its parent.
 *
 * @param {string} key Value of a user-provided `key` attribute
 * @return {string}
 */
function wrapUserProvidedKey(key) {
  return '$' + escapeUserProvidedKey(key);
}

/**
 * @param {?*} children Children tree container.
 * @param {!string} nameSoFar Name of the key path so far.
 * @param {!number} indexSoFar Number of children encountered until this point.
 * @param {!function} callback Callback to invoke with each child found.
 * @param {?*} traverseContext Used to pass information throughout the traversal
 * process.
 * @return {!number} The number of children in this subtree.
 */
var traverseAllChildrenImpl =
  function(children, nameSoFar, indexSoFar, callback, traverseContext) {
    var subtreeCount = 0;  // Count of children found in the current subtree.
    if (Array.isArray(children)) {
      for (var i = 0; i < children.length; i++) {
        var child = children[i];
        var nextName = (
          nameSoFar +
          (nameSoFar ? SUBSEPARATOR : SEPARATOR) +
          getComponentKey(child, i)
        );
        var nextIndex = indexSoFar + subtreeCount;
        subtreeCount += traverseAllChildrenImpl(
          child,
          nextName,
          nextIndex,
          callback,
          traverseContext
        );
      }
    } else {
      var type = typeof children;
      var isOnlyChild = nameSoFar === '';
      // If it's the only child, treat the name as if it was wrapped in an array
      // so that it's consistent if the number of children grows
      var storageName =
        isOnlyChild ? SEPARATOR + getComponentKey(children, 0) : nameSoFar;
      if (children == null || type === 'boolean') {
        // All of the above are perceived as null.
        callback(traverseContext, null, storageName, indexSoFar);
        subtreeCount = 1;
      } else if (children.type && children.type.prototype &&
                 children.type.prototype.mountComponentIntoNode) {
        callback(traverseContext, children, storageName, indexSoFar);
        subtreeCount = 1;
      } else {
        if (type === 'object') {
          ("production" !== process.env.NODE_ENV ? invariant(
            !children || children.nodeType !== 1,
            'traverseAllChildren(...): Encountered an invalid child; DOM ' +
            'elements are not valid children of React components.'
          ) : invariant(!children || children.nodeType !== 1));
          for (var key in children) {
            if (children.hasOwnProperty(key)) {
              subtreeCount += traverseAllChildrenImpl(
                children[key],
                (
                  nameSoFar + (nameSoFar ? SUBSEPARATOR : SEPARATOR) +
                  wrapUserProvidedKey(key) + SUBSEPARATOR +
                  getComponentKey(children[key], 0)
                ),
                indexSoFar + subtreeCount,
                callback,
                traverseContext
              );
            }
          }
        } else if (type === 'string') {
          var normalizedText = ReactTextComponent(children);
          callback(traverseContext, normalizedText, storageName, indexSoFar);
          subtreeCount += 1;
        } else if (type === 'number') {
          var normalizedNumber = ReactTextComponent('' + children);
          callback(traverseContext, normalizedNumber, storageName, indexSoFar);
          subtreeCount += 1;
        }
      }
    }
    return subtreeCount;
  };

/**
 * Traverses children that are typically specified as `props.children`, but
 * might also be specified through attributes:
 *
 * - `traverseAllChildren(this.props.children, ...)`
 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
 *
 * The `traverseContext` is an optional argument that is passed through the
 * entire traversal. It can be used to store accumulations or anything else that
 * the callback might find relevant.
 *
 * @param {?*} children Children tree object.
 * @param {!function} callback To invoke upon traversing each child.
 * @param {?*} traverseContext Context for traversal.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildren(children, callback, traverseContext) {
  if (children == null) {
    return 0;
  }

  return traverseAllChildrenImpl(children, '', 0, callback, traverseContext);
}

module.exports = traverseAllChildren;

}).call(this,require('_process'))
},{"./ReactInstanceHandles":142,"./ReactTextComponent":161,"./invariant":212,"_process":73}],235:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule update
 */

"use strict";

var copyProperties = require("./copyProperties");
var keyOf = require("./keyOf");
var invariant = require("./invariant");

function shallowCopy(x) {
  if (Array.isArray(x)) {
    return x.concat();
  } else if (x && typeof x === 'object') {
    return copyProperties(new x.constructor(), x);
  } else {
    return x;
  }
}

var COMMAND_PUSH = keyOf({$push: null});
var COMMAND_UNSHIFT = keyOf({$unshift: null});
var COMMAND_SPLICE = keyOf({$splice: null});
var COMMAND_SET = keyOf({$set: null});
var COMMAND_MERGE = keyOf({$merge: null});
var COMMAND_APPLY = keyOf({$apply: null});

var ALL_COMMANDS_LIST = [
  COMMAND_PUSH,
  COMMAND_UNSHIFT,
  COMMAND_SPLICE,
  COMMAND_SET,
  COMMAND_MERGE,
  COMMAND_APPLY
];

var ALL_COMMANDS_SET = {};

ALL_COMMANDS_LIST.forEach(function(command) {
  ALL_COMMANDS_SET[command] = true;
});

function invariantArrayCase(value, spec, command) {
  ("production" !== process.env.NODE_ENV ? invariant(
    Array.isArray(value),
    'update(): expected target of %s to be an array; got %s.',
    command,
    value
  ) : invariant(Array.isArray(value)));
  var specValue = spec[command];
  ("production" !== process.env.NODE_ENV ? invariant(
    Array.isArray(specValue),
    'update(): expected spec of %s to be an array; got %s. ' +
    'Did you forget to wrap your parameter in an array?',
    command,
    specValue
  ) : invariant(Array.isArray(specValue)));
}

function update(value, spec) {
  ("production" !== process.env.NODE_ENV ? invariant(
    typeof spec === 'object',
    'update(): You provided a key path to update() that did not contain one ' +
    'of %s. Did you forget to include {%s: ...}?',
    ALL_COMMANDS_LIST.join(', '),
    COMMAND_SET
  ) : invariant(typeof spec === 'object'));

  if (spec.hasOwnProperty(COMMAND_SET)) {
    ("production" !== process.env.NODE_ENV ? invariant(
      Object.keys(spec).length === 1,
      'Cannot have more than one key in an object with %s',
      COMMAND_SET
    ) : invariant(Object.keys(spec).length === 1));

    return spec[COMMAND_SET];
  }

  var nextValue = shallowCopy(value);

  if (spec.hasOwnProperty(COMMAND_MERGE)) {
    var mergeObj = spec[COMMAND_MERGE];
    ("production" !== process.env.NODE_ENV ? invariant(
      mergeObj && typeof mergeObj === 'object',
      'update(): %s expects a spec of type \'object\'; got %s',
      COMMAND_MERGE,
      mergeObj
    ) : invariant(mergeObj && typeof mergeObj === 'object'));
    ("production" !== process.env.NODE_ENV ? invariant(
      nextValue && typeof nextValue === 'object',
      'update(): %s expects a target of type \'object\'; got %s',
      COMMAND_MERGE,
      nextValue
    ) : invariant(nextValue && typeof nextValue === 'object'));
    copyProperties(nextValue, spec[COMMAND_MERGE]);
  }

  if (spec.hasOwnProperty(COMMAND_PUSH)) {
    invariantArrayCase(value, spec, COMMAND_PUSH);
    spec[COMMAND_PUSH].forEach(function(item) {
      nextValue.push(item);
    });
  }

  if (spec.hasOwnProperty(COMMAND_UNSHIFT)) {
    invariantArrayCase(value, spec, COMMAND_UNSHIFT);
    spec[COMMAND_UNSHIFT].forEach(function(item) {
      nextValue.unshift(item);
    });
  }

  if (spec.hasOwnProperty(COMMAND_SPLICE)) {
    ("production" !== process.env.NODE_ENV ? invariant(
      Array.isArray(value),
      'Expected %s target to be an array; got %s',
      COMMAND_SPLICE,
      value
    ) : invariant(Array.isArray(value)));
    ("production" !== process.env.NODE_ENV ? invariant(
      Array.isArray(spec[COMMAND_SPLICE]),
      'update(): expected spec of %s to be an array of arrays; got %s. ' +
      'Did you forget to wrap your parameters in an array?',
      COMMAND_SPLICE,
      spec[COMMAND_SPLICE]
    ) : invariant(Array.isArray(spec[COMMAND_SPLICE])));
    spec[COMMAND_SPLICE].forEach(function(args) {
      ("production" !== process.env.NODE_ENV ? invariant(
        Array.isArray(args),
        'update(): expected spec of %s to be an array of arrays; got %s. ' +
        'Did you forget to wrap your parameters in an array?',
        COMMAND_SPLICE,
        spec[COMMAND_SPLICE]
      ) : invariant(Array.isArray(args)));
      nextValue.splice.apply(nextValue, args);
    });
  }

  if (spec.hasOwnProperty(COMMAND_APPLY)) {
    ("production" !== process.env.NODE_ENV ? invariant(
      typeof spec[COMMAND_APPLY] === 'function',
      'update(): expected spec of %s to be a function; got %s.',
      COMMAND_APPLY,
      spec[COMMAND_APPLY]
    ) : invariant(typeof spec[COMMAND_APPLY] === 'function'));
    nextValue = spec[COMMAND_APPLY](nextValue);
  }

  for (var k in spec) {
    if (!(ALL_COMMANDS_SET.hasOwnProperty(k) && ALL_COMMANDS_SET[k])) {
      nextValue[k] = update(value[k], spec[k]);
    }
  }

  return nextValue;
}

module.exports = update;

}).call(this,require('_process'))
},{"./copyProperties":188,"./invariant":212,"./keyOf":219,"_process":73}],236:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule warning
 */

"use strict";

var emptyFunction = require("./emptyFunction");

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if ("production" !== process.env.NODE_ENV) {
  warning = function(condition, format ) {var args=Array.prototype.slice.call(arguments,2);
    if (format === undefined) {
      throw new Error(
        '`warning(condition, format, ...args)` requires a warning ' +
        'message argument'
      );
    }

    if (!condition) {
      var argIndex = 0;
      console.warn('Warning: ' + format.replace(/%s/g, function()  {return args[argIndex++];}));
    }
  };
}

module.exports = warning;

}).call(this,require('_process'))
},{"./emptyFunction":194,"_process":73}],237:[function(require,module,exports){
module.exports = require('./lib/React');

},{"./lib/React":107}]},{},[1])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9hcHAvc2NyaXB0cy9pbmRleC5jb2ZmZWUiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9hcHAvc2NyaXB0cy9kZWZhdWx0X3NvbmcuY29mZmVlIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvYXBwL3NjcmlwdHMvZHNwL2F1ZGlvX3JlY29yZGVyLmNvZmZlZSIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L2FwcC9zY3JpcHRzL2RzcC9lbnZlbG9wZS5jb2ZmZWUiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9hcHAvc2NyaXB0cy9kc3AvZ2xvYmFsX2NvbnRleHQuY29mZmVlIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvYXBwL3NjcmlwdHMvZHNwL2hpZ2hwYXNzX2ZpbHRlci5jb2ZmZWUiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9hcHAvc2NyaXB0cy9kc3AvbGluZWFyX2ludGVycG9sYXRvci5jb2ZmZWUiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9hcHAvc2NyaXB0cy9kc3AvbG93cGFzc19maWx0ZXIuY29mZmVlIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvYXBwL3NjcmlwdHMvZHNwL29zY2lsbGF0b3JzLmNvZmZlZSIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L2FwcC9zY3JpcHRzL2RzcC9zaW1wbGVfZW52ZWxvcGUuY29mZmVlIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvYXBwL3NjcmlwdHMvZHNwL3dlYmF1ZGlvLmNvZmZlZSIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L2FwcC9zY3JpcHRzL21vZGVscy9hbmFsb2dfc3ludGhlc2l6ZXIuY29mZmVlIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvYXBwL3NjcmlwdHMvbW9kZWxzL2Jhc2ljX3NhbXBsZXIuY29mZmVlIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvYXBwL3NjcmlwdHMvbW9kZWxzL2RydW1fc2FtcGxlci5jb2ZmZWUiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9hcHAvc2NyaXB0cy9tb2RlbHMvZHJ1bV9zeW50aGVzaXplci5jb2ZmZWUiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9hcHAvc2NyaXB0cy9tb2RlbHMvaW5zdHJ1bWVudC5jb2ZmZWUiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9hcHAvc2NyaXB0cy9tb2RlbHMvbG9vcF9zYW1wbGVyLmNvZmZlZSIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L2FwcC9zY3JpcHRzL21vZGVscy9tb2RlbC5jb2ZmZWUiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9hcHAvc2NyaXB0cy9tb2RlbHMvc2VxdWVuY2UuY29mZmVlIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvYXBwL3NjcmlwdHMvbW9kZWxzL3NvbmcuY29mZmVlIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvYXBwL3NjcmlwdHMvbW9kZWxzL3RyYWNrLmNvZmZlZSIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L2FwcC9zY3JpcHRzL3NlcXVlbmNlcy5jb2ZmZWUiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9hcHAvc2NyaXB0cy91aS9hbmFsb2dfc3ludGhlc2l6ZXJfY29udHJvbC5janN4IiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvYXBwL3NjcmlwdHMvdWkvYXBwLmNqc3giLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9hcHAvc2NyaXB0cy91aS9iYXNpY19zYW1wbGVyX2NvbnRyb2wuY2pzeCIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L2FwcC9zY3JpcHRzL3VpL2Nob29zZXIuY2pzeCIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L2FwcC9zY3JpcHRzL3VpL2RydW1fc2FtcGxlcl9jb250cm9sLmNqc3giLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9hcHAvc2NyaXB0cy91aS9kcnVtX3N5bnRoZXNpemVyX2NvbnRyb2wuY2pzeCIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L2FwcC9zY3JpcHRzL3VpL2VudmVsb3BlLmNqc3giLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9hcHAvc2NyaXB0cy91aS9maWx0ZXIuY2pzeCIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L2FwcC9zY3JpcHRzL3VpL2tub2IuY2pzeCIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L2FwcC9zY3JpcHRzL3VpL2xpc3RfY29udHJvbC5janN4IiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvYXBwL3NjcmlwdHMvdWkvbG9vcF9zYW1wbGVyX2NvbnRyb2wuY2pzeCIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L2FwcC9zY3JpcHRzL3VpL21lbnUuY2pzeCIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L2FwcC9zY3JpcHRzL3VpL21ldGVyLmNqc3giLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9hcHAvc2NyaXB0cy91aS9taXhpbnMvZHJhZ2dhYmxlLmNvZmZlZSIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L2FwcC9zY3JpcHRzL3VpL21peGlucy9rZXlib2FyZF9pbnRlcmFjdGlvbi5jb2ZmZWUiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9hcHAvc2NyaXB0cy91aS9taXhpbnMvc2l6ZV9tZWFzdXJhYmxlLmNvZmZlZSIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L2FwcC9zY3JpcHRzL3VpL21peGlucy9zb3J0YWJsZS5jb2ZmZWUiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9hcHAvc2NyaXB0cy91aS9taXhpbnMvdXBkYXRhYmxlLmNvZmZlZSIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L2FwcC9zY3JpcHRzL3VpL21vZGFsLmNqc3giLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9hcHAvc2NyaXB0cy91aS9vc2NpbGxhdG9yLmNqc3giLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9hcHAvc2NyaXB0cy91aS9waWFub19yb2xsLmNqc3giLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9hcHAvc2NyaXB0cy91aS9waWFub19yb2xsL2dyaWRfbGluZXMuY2pzeCIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L2FwcC9zY3JpcHRzL3VpL3BpYW5vX3JvbGwva2V5cy5janN4IiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvYXBwL3NjcmlwdHMvdWkvcGlhbm9fcm9sbC9taXhpbnMva2V5Ym9hcmRfaW50ZXJhY3Rpb24uY29mZmVlIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvYXBwL3NjcmlwdHMvdWkvcGlhbm9fcm9sbC9taXhpbnMvbW91c2VfaW50ZXJhY3Rpb24uY29mZmVlIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvYXBwL3NjcmlwdHMvdWkvcGlhbm9fcm9sbC9taXhpbnMvb3ZlcnJpZGVfc2Nyb2xsaW5nLmNvZmZlZSIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L2FwcC9zY3JpcHRzL3VpL3BpYW5vX3JvbGwvbm90ZXMuY2pzeCIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L2FwcC9zY3JpcHRzL3VpL3BpYW5vX3JvbGwvcGxheWJhY2tfbWFya2VyLmNqc3giLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9hcHAvc2NyaXB0cy91aS9waWFub19yb2xsL3NlbGVjdGlvbi5janN4IiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvYXBwL3NjcmlwdHMvdWkvcGxheWJhY2tfY29udHJvbC5janN4IiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvYXBwL3NjcmlwdHMvdWkvcmVjb3JkX2NvbnRyb2wuY2pzeCIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L2FwcC9zY3JpcHRzL3VpL3NhbXBsZV9jb250cm9sLmNqc3giLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9hcHAvc2NyaXB0cy91aS9zY2FsZV9oYW5kbGUuY2pzeCIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L2FwcC9zY3JpcHRzL3VpL3NsaWRlci5janN4IiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvYXBwL3NjcmlwdHMvdWkvdHJhY2tfc2VsZWN0aW9uLmNqc3giLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9hcHAvc2NyaXB0cy91aS93YXZlZm9ybS5janN4IiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvYXBwL3NjcmlwdHMvdWkvd2F2ZWZvcm0vbWFya2VyLmNqc3giLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9hcHAvc2NyaXB0cy91aS93YXZlZm9ybS92aXN1YWxpemF0aW9uLmNqc3giLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9hcHAvc2NyaXB0cy91dGlsL2RlYm91bmNlLmNvZmZlZSIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L2FwcC9zY3JpcHRzL3V0aWwvZGVlcF9mcmVlemUuY29mZmVlIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvYXBwL3NjcmlwdHMvdXRpbC9kZWVwX21lcmdlLmNvZmZlZSIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L2FwcC9zY3JpcHRzL3V0aWwvaW1tdXRhYmxlX2RhdGEuY29mZmVlIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvYXBwL3NjcmlwdHMvdXRpbC9rZXlfb3B0aW9ucy5jb2ZmZWUiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9hcHAvc2NyaXB0cy91dGlsL2xvZ19zYW1wbGUuY29mZmVlIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvYXBwL3NjcmlwdHMvdXRpbC9wb2ludGVyLmNvZmZlZSIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L2FwcC9zY3JpcHRzL3V0aWwvcmluZ19idWZmZXIuY29mZmVlIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvYXBwL3NjcmlwdHMvdXRpbC90cmFuc3Bvc2Vfb3B0aW9ucy5jb2ZmZWUiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9hcHAvc2NyaXB0cy91dGlsL3VuZG9faGlzdG9yeS5jb2ZmZWUiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvYXN5bmMvbGliL2FzeW5jLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL2Jhc2U2NC1hcnJheWJ1ZmZlci9saWIvYmFzZTY0LWFycmF5YnVmZmVyLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9idWlsZC1zdGF0dXMvaW5kZXguanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvYnVpbGQtc3RhdHVzL25vZGVfbW9kdWxlcy93cy9saWIvYnJvd3Nlci5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9jdWlkL2Rpc3QvYnJvd3Nlci1jdWlkLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL2tleWJvYXJkanMva2V5Ym9hcmQuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvYWRkb25zLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9BdXRvRm9jdXNNaXhpbi5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvQmVmb3JlSW5wdXRFdmVudFBsdWdpbi5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvQ1NTQ29yZS5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvQ1NTUHJvcGVydHkuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL0NTU1Byb3BlcnR5T3BlcmF0aW9ucy5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvQ2FsbGJhY2tRdWV1ZS5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvQ2hhbmdlRXZlbnRQbHVnaW4uanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL0NsaWVudFJlYWN0Um9vdEluZGV4LmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9Db21wb3NpdGlvbkV2ZW50UGx1Z2luLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9ET01DaGlsZHJlbk9wZXJhdGlvbnMuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL0RPTVByb3BlcnR5LmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9ET01Qcm9wZXJ0eU9wZXJhdGlvbnMuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL0Rhbmdlci5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXIuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL0VudGVyTGVhdmVFdmVudFBsdWdpbi5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvRXZlbnRDb25zdGFudHMuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL0V2ZW50TGlzdGVuZXIuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL0V2ZW50UGx1Z2luSHViLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9FdmVudFBsdWdpblJlZ2lzdHJ5LmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9FdmVudFBsdWdpblV0aWxzLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9FdmVudFByb3BhZ2F0b3JzLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudC5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvSFRNTERPTVByb3BlcnR5Q29uZmlnLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9MaW5rZWRTdGF0ZU1peGluLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9MaW5rZWRWYWx1ZVV0aWxzLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9Mb2NhbEV2ZW50VHJhcE1peGluLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9Nb2JpbGVTYWZhcmlDbGlja0V2ZW50UGx1Z2luLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9Qb29sZWRDbGFzcy5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3QuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0QnJvd3NlckNvbXBvbmVudE1peGluLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0Q1NTVHJhbnNpdGlvbkdyb3VwLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdENTU1RyYW5zaXRpb25Hcm91cENoaWxkLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdENoaWxkcmVuLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudC5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50V2l0aFB1cmVSZW5kZXJNaXhpbi5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RDb21wb3NpdGVDb21wb25lbnQuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0Q29udGV4dC5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RDdXJyZW50T3duZXIuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RE9NLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERPTUJ1dHRvbi5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RET01Db21wb25lbnQuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RE9NRm9ybS5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RET01JRE9wZXJhdGlvbnMuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RE9NSW1nLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERPTUlucHV0LmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERPTU9wdGlvbi5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RET01TZWxlY3QuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RE9NU2VsZWN0aW9uLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERPTVRleHRhcmVhLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5LmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERlZmF1bHRJbmplY3Rpb24uanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RGVmYXVsdFBlcmYuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RGVmYXVsdFBlcmZBbmFseXNpcy5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3REZXNjcmlwdG9yLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERlc2NyaXB0b3JWYWxpZGF0b3IuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RW1wdHlDb21wb25lbnQuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RXJyb3JVdGlscy5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RFdmVudEVtaXR0ZXJNaXhpbi5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RFdmVudExpc3RlbmVyLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdEluamVjdGlvbi5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RJbnB1dFNlbGVjdGlvbi5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RJbnN0YW5jZUhhbmRsZXMuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0TGluay5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RNYXJrdXBDaGVja3N1bS5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RNb3VudC5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RNdWx0aUNoaWxkLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RPd25lci5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RQZXJmLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFByb3BUcmFuc2ZlcmVyLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcy5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZXMuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0UHV0TGlzdGVuZXJRdWV1ZS5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RSb290SW5kZXguanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0U2VydmVyUmVuZGVyaW5nLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFN0YXRlU2V0dGVycy5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RUZXN0VXRpbHMuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0VGV4dENvbXBvbmVudC5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RUcmFuc2l0aW9uQ2hpbGRNYXBwaW5nLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFRyYW5zaXRpb25FdmVudHMuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0VHJhbnNpdGlvbkdyb3VwLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFVwZGF0ZXMuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0V2l0aEFkZG9ucy5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvU1ZHRE9NUHJvcGVydHlDb25maWcuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1NlbGVjdEV2ZW50UGx1Z2luLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9TZXJ2ZXJSZWFjdFJvb3RJbmRleC5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvU2ltcGxlRXZlbnRQbHVnaW4uanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1N5bnRoZXRpY0NsaXBib2FyZEV2ZW50LmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9TeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9TeW50aGV0aWNEcmFnRXZlbnQuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1N5bnRoZXRpY0V2ZW50LmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9TeW50aGV0aWNGb2N1c0V2ZW50LmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9TeW50aGV0aWNJbnB1dEV2ZW50LmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9TeW50aGV0aWNLZXlib2FyZEV2ZW50LmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9TeW50aGV0aWNNb3VzZUV2ZW50LmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9TeW50aGV0aWNUb3VjaEV2ZW50LmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9TeW50aGV0aWNVSUV2ZW50LmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9TeW50aGV0aWNXaGVlbEV2ZW50LmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9UcmFuc2FjdGlvbi5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvVmlld3BvcnRNZXRyaWNzLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9hY2N1bXVsYXRlLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9hZGxlcjMyLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9jbG9uZVdpdGhQcm9wcy5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvY29udGFpbnNOb2RlLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9jb3B5UHJvcGVydGllcy5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvY3JlYXRlQXJyYXlGcm9tLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9jcmVhdGVGdWxsUGFnZUNvbXBvbmVudC5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvY3JlYXRlTm9kZXNGcm9tTWFya3VwLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9jeC5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvZGFuZ2Vyb3VzU3R5bGVWYWx1ZS5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvZW1wdHlGdW5jdGlvbi5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvZW1wdHlPYmplY3QuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL2VzY2FwZVRleHRGb3JCcm93c2VyLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9mbGF0dGVuQ2hpbGRyZW4uanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL2ZvY3VzTm9kZS5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvZm9yRWFjaEFjY3VtdWxhdGVkLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9nZXRBY3RpdmVFbGVtZW50LmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9nZXRFdmVudEtleS5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvZ2V0RXZlbnRNb2RpZmllclN0YXRlLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9nZXRFdmVudFRhcmdldC5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvZ2V0TWFya3VwV3JhcC5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldC5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9nZXRUZXh0Q29udGVudEFjY2Vzc29yLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9nZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbi5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvaHlwaGVuYXRlLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9oeXBoZW5hdGVTdHlsZU5hbWUuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL2ludmFyaWFudC5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvaXNFdmVudFN1cHBvcnRlZC5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvaXNOb2RlLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9pc1RleHRJbnB1dEVsZW1lbnQuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL2lzVGV4dE5vZGUuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL2pvaW5DbGFzc2VzLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9rZXlNaXJyb3IuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL2tleU9mLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9tYXBPYmplY3QuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL21lbW9pemVTdHJpbmdPbmx5LmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9tZXJnZS5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvbWVyZ2VIZWxwZXJzLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9tZXJnZUludG8uanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL21peEludG8uanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL21vbml0b3JDb2RlVXNlLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9vbmx5Q2hpbGQuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL3BlcmZvcm1hbmNlLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9wZXJmb3JtYW5jZU5vdy5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvc2V0SW5uZXJIVE1MLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9zaGFsbG93RXF1YWwuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL3Nob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50LmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi90b0FycmF5LmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi90cmF2ZXJzZUFsbENoaWxkcmVuLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi91cGRhdGUuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL3dhcm5pbmcuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvcmVhY3QuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQSxJQUFBLDRDQUFBOztBQUFBLGFBQUEsR0FBZ0IsT0FBQSxDQUFRLHVCQUFSLENBQWhCLENBQUE7O0FBQUEsV0FDQSxHQUFjLE9BQUEsQ0FBUSxxQkFBUixDQURkLENB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JtQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy83QkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25ZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbk1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25OQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcGFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ROQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5YUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcmFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25NQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJJbW11dGFibGVEYXRhID0gcmVxdWlyZSAnLi91dGlsL2ltbXV0YWJsZV9kYXRhJ1xuVW5kb0hpc3RvcnkgPSByZXF1aXJlICcuL3V0aWwvdW5kb19oaXN0b3J5J1xuUmVhY3QgPSByZXF1aXJlICdyZWFjdC9hZGRvbnMnXG5Tb25nID0gcmVxdWlyZSAnLi9tb2RlbHMvc29uZydcbkFwcCA9IHJlcXVpcmUgJy4vdWkvYXBwJ1xuXG5cbiMgZGV2ZWxvcG1lbnQgb25seSBjb2RlXG5pZiBwcm9jZXNzLmVudi5OT0RFX0VOViBpcyAnZGV2ZWxvcG1lbnQnXG5cbiAgIyBzZXR1cCBndWxwIGJ1aWxkIHN0YXR1cyAvIGF1dG9yZWxvYWRcbiAgKHJlcXVpcmUgJ2J1aWxkLXN0YXR1cycpLmNsaWVudCgpXG5cbiAgIyBzZXQgdGhlc2Ugb24gd2luZG93IGZvciBkZWJ1Z2dpbmcgLyByZWFjdCBkZXYgdG9vbHMgY2hyb21lIGV4dGVuc2lvblxuICB3aW5kb3cuUmVhY3QgPSBSZWFjdFxuICB3aW5kb3cuQXBwID0gQXBwXG4gIHdpbmRvdy5Tb25nID0gU29uZ1xuICB3aW5kb3cuVHJhY2sgPSByZXF1aXJlICcuL21vZGVscy90cmFjaydcbiAgd2luZG93LkRydW1TYW1wbGVyID0gcmVxdWlyZSAnLi9tb2RlbHMvZHJ1bV9zYW1wbGVyJ1xuICB3aW5kb3cuQmFzaWNTYW1wbGVyID0gcmVxdWlyZSAnLi9tb2RlbHMvYmFzaWNfc2FtcGxlcidcbiAgd2luZG93LlRyYWNrU2VsZWN0aW9uID0gcmVxdWlyZSAnLi91aS90cmFja19zZWxlY3Rpb24nXG4gIHdpbmRvdy5NZXRlciA9IHJlcXVpcmUgJy4vdWkvbWV0ZXInXG4gIHdpbmRvdy5QaWFub1JvbGwgPSByZXF1aXJlICcuL3VpL3BpYW5vX3JvbGwnXG4gIHdpbmRvdy5HcmlkTGluZXMgPSByZXF1aXJlICcuL3VpL3BpYW5vX3JvbGwvZ3JpZF9saW5lcydcbiAgd2luZG93LktleXMgPSByZXF1aXJlICcuL3VpL3BpYW5vX3JvbGwva2V5cydcbiAgd2luZG93Lk5vdGVzID0gcmVxdWlyZSAnLi91aS9waWFub19yb2xsL25vdGVzJ1xuICB3aW5kb3cuUGxheWJhY2tNYXJrZXIgPSByZXF1aXJlICcuL3VpL3BpYW5vX3JvbGwvcGxheWJhY2tfbWFya2VyJ1xuICB3aW5kb3cuU2VsZWN0aW9uID0gcmVxdWlyZSAnLi91aS9waWFub19yb2xsL3NlbGVjdGlvbidcblxuIyBpbmplY3QgcmVxdWVzdCBhbmltYXRpb24gZnJhbWUgYmF0Y2hpbmcgc3RyYXRlZ3kgaW50byByZWFjdFxuIyByZXF1aXJlKCdyZWFjdC1yYWYtYmF0Y2hpbmcnKS5pbmplY3QoKVxuXG4jIGxvYWQgZGVmYXVsdCBzb25nLCBzZXR1cCBpbW11dGFibGUgZGF0YSwgYW5kIHJlbmRlciBhcHBcblxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciAnRE9NQ29udGVudExvYWRlZCcsIC0+XG5cbiAgcmVxdWlyZSgnLi9kZWZhdWx0X3NvbmcnKSAoc29uZ0RhdGEpIC0+XG5cbiAgICBzb25nID0gbmV3IFNvbmdcblxuICAgIEltbXV0YWJsZURhdGEuY3JlYXRlIHNvbmdEYXRhLCAoZGF0YSwgaGlzdG9yeSkgLT5cbiAgICAgIHdpbmRvdy5kYXRhID0gZGF0YSBpZiBwcm9jZXNzLmVudi5OT0RFX0VOViBpcyAnZGV2ZWxvcG1lbnQnXG4gICAgICBzb25nLnVwZGF0ZSBkYXRhXG4gICAgICBSZWFjdC5yZW5kZXJDb21wb25lbnQgQXBwKHtkYXRhLCBzb25nLCBoaXN0b3J5fSksIGRvY3VtZW50LmJvZHlcbiIsIiMgVGhpcyBmaWxlIGRlZmluZXMgZGF0YSBmb3IgYSBkZWZhdWx0IHNvbmcsIGFuZCBzZXJ2ZXMgYXMgYSBnb29kIHJlZmVyZW5jZSBmb3JcbiMgdGhlIGRhdGEgc3RydWN0dXJlIG9mIGEgc29uZy5cbiNcbiMgUmlnaHQgbm93IGF1ZGlvIGRhdGEgaXMgaW5saW5lZCB1c2luZyBicmZzIGZvciBlYXNpZXIgZGV2ZWxvcG1lbnQsIGV2ZW50dWFsbHlcbiMgZmlsZXMgc2hvdWxkIGJlIGxvYWRlZCBpbmRlcGVuZGVudGx5IGZvciBiZXR0ZXIgY2FjaGluZy5cbiNcbiMgQmVjYXVzZSBkZWNvZGluZyBhdWRpbyBkYXRhIGludG8gYSB0eXBlZCBhcnJheSBpcyBhc3luYywgYW5kIGJlY2F1c2UgdGhpcyB3aWxsXG4jIGV2ZW50dWFsbHkgYXN5bmNocm9ub3VzbHkgbG9hZCByZW1vdGUgYXVkaW8gZmlsZXMsIHRoaXMgZXhwb3J0cyBhIGZ1bmN0aW9uXG4jIHRoYXQgcGFzc2VzIHRoZSBkZWNvZGVkIGRhdGEgdG8gYSBjYWxsYmFjay5cblxuXG5hc3luYyA9IHJlcXVpcmUgJ2FzeW5jJ1xuZnMgPSByZXF1aXJlICdmcydcbmIyYSA9IHJlcXVpcmUgJ2Jhc2U2NC1hcnJheWJ1ZmZlcidcbmN1aWQgPSByZXF1aXJlICdjdWlkJ1xuZGVjb2RlciA9IHJlcXVpcmUgJy4vZHNwL2dsb2JhbF9jb250ZXh0J1xuc2VxdWVuY2VzID0gcmVxdWlyZSAnLi9zZXF1ZW5jZXMnXG5cbmxvYWRlZCA9IGZhbHNlXG5kYXRhID0gbnVsbFxuY2FsbGJhY2tzID0gW11cblxubW9kdWxlLmV4cG9ydHMgPSAoY2IpIC0+XG4gIGlmIGxvYWRlZFxuICAgIGNiIGRhdGFcbiAgZWxzZVxuICAgIGNhbGxiYWNrcy5wdXNoIGNiXG5cblxuIyBpbmxpbmUgYXVkaW8gZmlsZXMgYXMgYmFzZTY0IHN0cmluZ3MgdXNpbmcgYnJmc1xuYmFzcyA9IGIyYS5kZWNvZGUgZnMucmVhZEZpbGVTeW5jIFwiI3tfX2Rpcm5hbWV9Ly4uL2F1ZGlvL2Jhc3Mud2F2XCIsICdiYXNlNjQnXG5raWNrID0gYjJhLmRlY29kZSBmcy5yZWFkRmlsZVN5bmMgXCIje19fZGlybmFtZX0vLi4vYXVkaW8va2ljay53YXZcIiwgJ2Jhc2U2NCdcbnNuYXJlID0gYjJhLmRlY29kZSBmcy5yZWFkRmlsZVN5bmMgXCIje19fZGlybmFtZX0vLi4vYXVkaW8vc25hcmUud2F2XCIsICdiYXNlNjQnXG5oYXQgPSBiMmEuZGVjb2RlIGZzLnJlYWRGaWxlU3luYyBcIiN7X19kaXJuYW1lfS8uLi9hdWRpby9oYXQud2F2XCIsICdiYXNlNjQnXG5cbiMgbG9hZCBzYW1wbGUgZGF0YVxuYXN5bmMucGFyYWxsZWxcbiAgYmFzczogKGNiKSAtPiBkZWNvZGVyLmRlY29kZUF1ZGlvRGF0YSBiYXNzLCAoYnVmZmVyKSAtPiBjYiBudWxsLCBidWZmZXJcbiAga2ljazogKGNiKSAtPiBkZWNvZGVyLmRlY29kZUF1ZGlvRGF0YSBraWNrLCAoYnVmZmVyKSAtPiBjYiBudWxsLCBidWZmZXJcbiAgc25hcmU6IChjYikgLT4gZGVjb2Rlci5kZWNvZGVBdWRpb0RhdGEgc25hcmUsIChidWZmZXIpIC0+IGNiIG51bGwsIGJ1ZmZlclxuICBoYXQ6IChjYikgLT4gZGVjb2Rlci5kZWNvZGVBdWRpb0RhdGEgaGF0LCAoYnVmZmVyKSAtPiBjYiBudWxsLCBidWZmZXJcblxuICAoZXJyLCByZXN1bHRzKSAtPlxuXG4gICAgZGF0YSA9XG4gICAgICBfaWQ6IGN1aWQoKVxuICAgICAgYnBtOiAxMjBcbiAgICAgIHBsYXlpbmc6IGZhbHNlXG4gICAgICByZWNvcmRpbmc6IGZhbHNlXG4gICAgICBwb3NpdGlvbjogMFxuICAgICAgdHJhY2tzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBfaWQ6IGN1aWQoKVxuICAgICAgICAgIG5hbWU6ICdBbmFsb2cgU3ludGgnXG4gICAgICAgICAgbWV0ZXJMZXZlbDogMFxuICAgICAgICAgIHNlcXVlbmNlOlxuICAgICAgICAgICAgX2lkOiBjdWlkKClcbiAgICAgICAgICAgIGxvb3BTaXplOiA4XG4gICAgICAgICAgICBub3Rlczogc2VxdWVuY2VzLnRlcmplXG4gICAgICAgICAgZWZmZWN0czogW11cbiAgICAgICAgICBpbnN0cnVtZW50OlxuICAgICAgICAgICAgX2lkOiBjdWlkKClcbiAgICAgICAgICAgIF90eXBlOiAnQW5hbG9nU3ludGhlc2l6ZXInXG4gICAgICAgICAgICBsZXZlbDogMVxuICAgICAgICAgICAgcGFuOiAwLjVcbiAgICAgICAgICAgIHBvbHlwaG9ueTogM1xuICAgICAgICAgICAgbWF4UG9seXBob255OiA2XG4gICAgICAgICAgICB2b2x1bWVFbnY6XG4gICAgICAgICAgICAgIGE6IDBcbiAgICAgICAgICAgICAgZDogMC4yNVxuICAgICAgICAgICAgICBzOiAwXG4gICAgICAgICAgICAgIHI6IDAuNVxuICAgICAgICAgICAgZmlsdGVyRW52OlxuICAgICAgICAgICAgICBhOiAwXG4gICAgICAgICAgICAgIGQ6IDAuMjVcbiAgICAgICAgICAgICAgczogMC4yXG4gICAgICAgICAgICAgIHI6IDAuNVxuICAgICAgICAgICAgZmlsdGVyOlxuICAgICAgICAgICAgICB0eXBlOiAnTFAnXG4gICAgICAgICAgICAgIGZyZXE6IDAuMjdcbiAgICAgICAgICAgICAgcmVzOiAwLjA1XG4gICAgICAgICAgICAgIGVudjogMC40NVxuICAgICAgICAgICAgb3NjMTpcbiAgICAgICAgICAgICAgd2F2ZWZvcm06ICdzYXcnXG4gICAgICAgICAgICAgIGxldmVsOiAwLjVcbiAgICAgICAgICAgICAgcGl0Y2g6IDAuNVxuICAgICAgICAgICAgICB0dW5lOiAwLjVcbiAgICAgICAgICAgIG9zYzI6XG4gICAgICAgICAgICAgIHdhdmVmb3JtOiAnc2F3J1xuICAgICAgICAgICAgICBsZXZlbDogMC41XG4gICAgICAgICAgICAgIHBpdGNoOiAwLjVcbiAgICAgICAgICAgICAgdHVuZTogMC41XG4gICAgICAgIH1cbiAgICAgICAge1xuICAgICAgICAgIF9pZDogY3VpZCgpXG4gICAgICAgICAgbmFtZTogJ0RydW0gU3ludGhlc2l6ZXInXG4gICAgICAgICAgbWV0ZXJMZXZlbDogMFxuICAgICAgICAgIHNlcXVlbmNlOlxuICAgICAgICAgICAgX2lkOiBjdWlkKClcbiAgICAgICAgICAgIGxvb3BTaXplOiA0XG4gICAgICAgICAgICBub3Rlczoge31cbiAgICAgICAgICBlZmZlY3RzOiBbXVxuICAgICAgICAgIGluc3RydW1lbnQ6XG4gICAgICAgICAgICBfaWQ6IGN1aWQoKVxuICAgICAgICAgICAgX3R5cGU6ICdEcnVtU3ludGhlc2l6ZXInXG4gICAgICAgICAgICBsZXZlbDogMC41XG4gICAgICAgICAgICBwYW46IDAuNVxuICAgICAgICAgICAgZHJ1bXM6IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlkOiAxXG4gICAgICAgICAgICAgICAga2V5OiAwXG4gICAgICAgICAgICAgICAgbmFtZTogJ0tpY2snXG4gICAgICAgICAgICAgICAgbGV2ZWw6IDFcbiAgICAgICAgICAgICAgICBocDogMFxuICAgICAgICAgICAgICAgIGRlY2F5OiAwLjM1XG4gICAgICAgICAgICAgICAgbm9pc2U6IDAuMDAxXG4gICAgICAgICAgICAgICAgcGl0Y2g6IDBcbiAgICAgICAgICAgICAgICBiZW5kOiAwLjM5XG4gICAgICAgICAgICAgICAgZm06IDFcbiAgICAgICAgICAgICAgICBmbURlY2F5OiAwLjA1XG4gICAgICAgICAgICAgICAgZm1GcmVxOiAwLjAyXG4gICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBpZDogMlxuICAgICAgICAgICAgICAgIGtleTogMVxuICAgICAgICAgICAgICAgIG5hbWU6ICdTbmFyZSdcbiAgICAgICAgICAgICAgICBsZXZlbDogMC41XG4gICAgICAgICAgICAgICAgaHA6IDAuMjJcbiAgICAgICAgICAgICAgICBkZWNheTogMC4xXG4gICAgICAgICAgICAgICAgbm9pc2U6IDAuOFxuICAgICAgICAgICAgICAgIHBpdGNoOiAwLjFcbiAgICAgICAgICAgICAgICBiZW5kOiAwXG4gICAgICAgICAgICAgICAgZm06IDBcbiAgICAgICAgICAgICAgICBmbURlY2F5OiAwXG4gICAgICAgICAgICAgICAgZm1GcmVxOiAwXG4gICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBpZDogM1xuICAgICAgICAgICAgICAgIGtleTogMlxuICAgICAgICAgICAgICAgIG5hbWU6ICdISDEnXG4gICAgICAgICAgICAgICAgbGV2ZWw6IDAuMDVcbiAgICAgICAgICAgICAgICBocDogMVxuICAgICAgICAgICAgICAgIGRlY2F5OiAwLjA3XG4gICAgICAgICAgICAgICAgbm9pc2U6IDAuOFxuICAgICAgICAgICAgICAgIHBpdGNoOiAwLjRcbiAgICAgICAgICAgICAgICBiZW5kOiAwXG4gICAgICAgICAgICAgICAgZm06IDFcbiAgICAgICAgICAgICAgICBmbURlY2F5OiAwLjRcbiAgICAgICAgICAgICAgICBmbUZyZXE6IDBcbiAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGlkOiA0XG4gICAgICAgICAgICAgICAga2V5OiAzXG4gICAgICAgICAgICAgICAgbmFtZTogJ0hIMidcbiAgICAgICAgICAgICAgICBsZXZlbDogMC4yXG4gICAgICAgICAgICAgICAgaHA6IDAuNlxuICAgICAgICAgICAgICAgIGRlY2F5OiAwLjIyXG4gICAgICAgICAgICAgICAgbm9pc2U6IDFcbiAgICAgICAgICAgICAgICBwaXRjaDogMC41XG4gICAgICAgICAgICAgICAgYmVuZDogMFxuICAgICAgICAgICAgICAgIGZtOiAwXG4gICAgICAgICAgICAgICAgZm1EZWNheTogMFxuICAgICAgICAgICAgICAgIGZtRnJlcTogMFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgICAgfVxuICAgICAgICAjIHtcbiAgICAgICAgIyAgIF9pZDogY3VpZCgpXG4gICAgICAgICMgICBuYW1lOiAnRHJ1bSBTYW1wbGVyJ1xuICAgICAgICAjICAgbWV0ZXJMZXZlbDogMFxuICAgICAgICAjICAgc2VxdWVuY2U6XG4gICAgICAgICMgICAgIF9pZDogY3VpZCgpXG4gICAgICAgICMgICAgIGxvb3BTaXplOiA0XG4gICAgICAgICMgICAgIG5vdGVzOiBzZXF1ZW5jZXMuYmVhdFxuICAgICAgICAjICAgZWZmZWN0czogW11cbiAgICAgICAgIyAgIGluc3RydW1lbnQ6XG4gICAgICAgICMgICAgIF9pZDogY3VpZCgpXG4gICAgICAgICMgICAgIF90eXBlOiAnRHJ1bVNhbXBsZXInXG4gICAgICAgICMgICAgIGxldmVsOiAwLjhcbiAgICAgICAgIyAgICAgcGFuOiAwLjVcbiAgICAgICAgIyAgICAgZHJ1bXM6IFtcbiAgICAgICAgIyAgICAgICB7XG4gICAgICAgICMgICAgICAgICBuYW1lOiAnS2ljaydcbiAgICAgICAgIyAgICAgICAgIHNhbXBsZURhdGE6IHJlc3VsdHMua2ljay5nZXRDaGFubmVsRGF0YSAwXG4gICAgICAgICMgICAgICAgICBzYW1wbGVOYW1lOiAna2ljay53YXYnXG4gICAgICAgICMgICAgICAgICB0cmFuc3Bvc2U6IDBcbiAgICAgICAgIyAgICAgICAgIGxldmVsOiAxXG4gICAgICAgICMgICAgICAgICBrZXk6IDBcbiAgICAgICAgIyAgICAgICAgIHN0YXJ0OiAwXG4gICAgICAgICMgICAgICAgICB2b2x1bWVFbnY6XG4gICAgICAgICMgICAgICAgICAgIGE6IDBcbiAgICAgICAgIyAgICAgICAgICAgZDogMVxuICAgICAgICAjICAgICAgICAgICBzOiAxXG4gICAgICAgICMgICAgICAgICAgIHI6IDFcbiAgICAgICAgIyAgICAgICB9LCB7XG4gICAgICAgICMgICAgICAgICBuYW1lOiAnU25hcmUnXG4gICAgICAgICMgICAgICAgICBzYW1wbGVEYXRhOiByZXN1bHRzLnNuYXJlLmdldENoYW5uZWxEYXRhIDBcbiAgICAgICAgIyAgICAgICAgIHNhbXBsZU5hbWU6ICdzbmFyZS53YXYnXG4gICAgICAgICMgICAgICAgICB0cmFuc3Bvc2U6IDBcbiAgICAgICAgIyAgICAgICAgIGxldmVsOiAwLjM1XG4gICAgICAgICMgICAgICAgICBrZXk6IDFcbiAgICAgICAgIyAgICAgICAgIHN0YXJ0OiAwXG4gICAgICAgICMgICAgICAgICB2b2x1bWVFbnY6XG4gICAgICAgICMgICAgICAgICAgIGE6IDBcbiAgICAgICAgIyAgICAgICAgICAgZDogMVxuICAgICAgICAjICAgICAgICAgICBzOiAxXG4gICAgICAgICMgICAgICAgICAgIHI6IDFcbiAgICAgICAgIyAgICAgICB9LCB7XG4gICAgICAgICMgICAgICAgICBuYW1lOiAnSGlnaCBIYXQnXG4gICAgICAgICMgICAgICAgICBzYW1wbGVEYXRhOiByZXN1bHRzLmhhdC5nZXRDaGFubmVsRGF0YSAwXG4gICAgICAgICMgICAgICAgICBzYW1wbGVOYW1lOiAnaGF0LndhdidcbiAgICAgICAgIyAgICAgICAgIHRyYW5zcG9zZTogMFxuICAgICAgICAjICAgICAgICAgbGV2ZWw6IDAuMlxuICAgICAgICAjICAgICAgICAga2V5OiAyXG4gICAgICAgICMgICAgICAgICBzdGFydDogMFxuICAgICAgICAjICAgICAgICAgdm9sdW1lRW52OlxuICAgICAgICAjICAgICAgICAgICBhOiAwXG4gICAgICAgICMgICAgICAgICAgIGQ6IDFcbiAgICAgICAgIyAgICAgICAgICAgczogMVxuICAgICAgICAjICAgICAgICAgICByOiAxXG4gICAgICAgICMgICAgICAgfVxuICAgICAgICAjICAgICBdXG4gICAgICAgICMgfVxuICAgICAgICAjIHtcbiAgICAgICAgIyAgIF9pZDogY3VpZCgpXG4gICAgICAgICMgICBuYW1lOiAnQmFzaWMgU2FtcGxlcidcbiAgICAgICAgIyAgIG1ldGVyTGV2ZWw6IDBcbiAgICAgICAgIyAgIHNlcXVlbmNlOlxuICAgICAgICAjICAgICBfaWQ6IGN1aWQoKVxuICAgICAgICAjICAgICBsb29wU2l6ZTogOFxuICAgICAgICAjICAgICBub3Rlczogc2VxdWVuY2VzLnRlcmplXG4gICAgICAgICMgICBlZmZlY3RzOiBbXVxuICAgICAgICAjICAgaW5zdHJ1bWVudDpcbiAgICAgICAgIyAgICAgX2lkOiBjdWlkKClcbiAgICAgICAgIyAgICAgX3R5cGU6ICdCYXNpY1NhbXBsZXInXG4gICAgICAgICMgICAgIGxldmVsOiAwLjJcbiAgICAgICAgIyAgICAgcGFuOiAwLjVcbiAgICAgICAgIyAgICAgcG9seXBob255OiAxXG4gICAgICAgICMgICAgIG1heFBvbHlwaG9ueTogNlxuICAgICAgICAjICAgICByb290S2V5OiA2MFxuICAgICAgICAjICAgICBzYW1wbGVEYXRhOiByZXN1bHRzLmJhc3MuZ2V0Q2hhbm5lbERhdGEgMFxuICAgICAgICAjICAgICBzYW1wbGVOYW1lOiAnYmFzcy53YXYnXG4gICAgICAgICMgICAgIHN0YXJ0OiAwLjNcbiAgICAgICAgIyAgICAgbG9vcEFjdGl2ZTogJ2xvb3AnXG4gICAgICAgICMgICAgIGxvb3A6IDAuN1xuICAgICAgICAjICAgICB0dW5lOiAwLjVcbiAgICAgICAgIyAgICAgdm9sdW1lRW52OlxuICAgICAgICAjICAgICAgIGE6IDBcbiAgICAgICAgIyAgICAgICBkOiAwLjI1XG4gICAgICAgICMgICAgICAgczogMVxuICAgICAgICAjICAgICAgIHI6IDAuNVxuICAgICAgICAjICAgICBmaWx0ZXJFbnY6XG4gICAgICAgICMgICAgICAgYTogMFxuICAgICAgICAjICAgICAgIGQ6IDAuMjVcbiAgICAgICAgIyAgICAgICBzOiAxXG4gICAgICAgICMgICAgICAgcjogMC41XG4gICAgICAgICMgICAgIGZpbHRlcjpcbiAgICAgICAgIyAgICAgICB0eXBlOiAnbm9uZSdcbiAgICAgICAgIyAgICAgICBmcmVxOiAwLjI3XG4gICAgICAgICMgICAgICAgcmVzOiAwLjA1XG4gICAgICAgICMgICAgICAgZW52OiAwLjQ1XG4gICAgICAgICMgfVxuICAgICAgXVxuXG4gICAgY2IgZGF0YSBmb3IgY2IgaW4gY2FsbGJhY2tzXG4iLCJjb250ZXh0ID0gcmVxdWlyZSAnLi9nbG9iYWxfY29udGV4dCdcblxud29ya2VyU2NyaXB0ID0gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbJygnLCAoKHdpbmRvdykgLT5cblxuICBidWZmZXJzID0gW11cbiAgbGVuZ3RoID0gMFxuXG4gIHJlY29yZCA9IChpbnB1dEJ1ZmZlcikgLT5cbiAgICBidWZmZXJzLnB1c2ggaW5wdXRCdWZmZXJcbiAgICBsZW5ndGggKz0gaW5wdXRCdWZmZXIubGVuZ3RoXG5cbiAgY2xlYXIgPSAtPlxuICAgIGJ1ZmZlcnMgPSBbXVxuICAgIGxlbmd0aCA9IDBcblxuICBnZXRTYW1wbGVEYXRhID0gLT5cbiAgICAjIGpvaW4gYnVmZmVycyBpbnRvIGZsb2F0IGFycmF5XG4gICAgc2FtcGxlRGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkgbGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAgIGZvciBidWZmZXIgaW4gYnVmZmVyc1xuICAgICAgc2FtcGxlRGF0YS5zZXQgYnVmZmVyLCBvZmZzZXRcbiAgICAgIG9mZnNldCArPSBidWZmZXIubGVuZ3RoXG5cbiAgICAjIG5vcm1hbGl6ZVxuICAgIG1heCA9IC1JbmZpbml0eVxuICAgIGZvciB2YWx1ZSwgaSBpbiBzYW1wbGVEYXRhXG4gICAgICB2ID0gTWF0aC5hYnMgdmFsdWVcbiAgICAgIG1heCA9IHYgaWYgdiA+IG1heFxuXG4gICAgZm9yIHZhbHVlLCBpIGluIHNhbXBsZURhdGFcbiAgICAgIHNhbXBsZURhdGFbaV0gPSB2YWx1ZSAvIG1heFxuXG4gICAgd2luZG93LnBvc3RNZXNzYWdlIHNhbXBsZURhdGFcblxuICB3aW5kb3cub25tZXNzYWdlID0gKGUpIC0+XG4gICAgc3dpdGNoIGUuZGF0YS5jb21tYW5kXG4gICAgICB3aGVuICdyZWNvcmQnIHRoZW4gcmVjb3JkIGUuZGF0YS5idWZmZXJcbiAgICAgIHdoZW4gJ2NsZWFyJyB0aGVuIGNsZWFyKClcbiAgICAgIHdoZW4gJ2dldFNhbXBsZURhdGEnIHRoZW4gZ2V0U2FtcGxlRGF0YSgpXG5cbikudG9TdHJpbmcoKSwgJykodGhpcyknXSwgdHlwZTogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnKSlcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIEF1ZGlvUmVjb3JkZXJcblxuICBjb25zdHJ1Y3RvcjogKGlucHV0KSAtPlxuICAgIEBpbnB1dCA9IGlucHV0XG4gICAgQHJlY29yZGVyID0gY29udGV4dC5jcmVhdGVTY3JpcHRQcm9jZXNzb3IgNDA5NiwgMSwgMVxuICAgIEByZWNvcmRpbmcgPSBmYWxzZVxuICAgIEB3b3JrZXIgPSBuZXcgV29ya2VyIHdvcmtlclNjcmlwdFxuICAgIFxuICAgIEByZWNvcmRlci5vbmF1ZGlvcHJvY2VzcyA9IChlKSA9PlxuICAgICAgcmV0dXJuIHVubGVzcyBAcmVjb3JkaW5nXG4gICAgICBAd29ya2VyLnBvc3RNZXNzYWdlXG4gICAgICAgIGNvbW1hbmQ6ICdyZWNvcmQnXG4gICAgICAgIGJ1ZmZlcjogZS5pbnB1dEJ1ZmZlci5nZXRDaGFubmVsRGF0YSAwXG5cbiAgICBAd29ya2VyLm9ubWVzc2FnZSA9IChlKSA9PlxuICAgICAgQGN1cnJlbnRDYWxsYmFjaz8oZS5kYXRhKVxuICAgICAgQGN1cnJlbnRDYWxsYmFjayA9IG51bGxcblxuICAgIEBpbnB1dC5jb25uZWN0IEByZWNvcmRlclxuICAgIEByZWNvcmRlci5jb25uZWN0IGNvbnRleHQuZGVzdGluYXRpb25cblxuICByZWNvcmQ6IC0+XG4gICAgQHJlY29yZGluZyA9IHRydWVcbiAgICB0aGlzXG5cbiAgc3RvcDogLT5cbiAgICBAcmVjb3JkaW5nID0gZmFsc2VcbiAgICB0aGlzXG5cbiAgY2xlYXI6IC0+XG4gICAgQHdvcmtlci5wb3N0TWVzc2FnZSBjb21tYW5kOiAnY2xlYXInXG4gICAgdGhpc1xuXG4gIGdldFNhbXBsZURhdGE6IChjYWxsYmFjaykgLT5cbiAgICBAY3VycmVudENhbGxiYWNrID0gY2FsbGJhY2tcbiAgICBAd29ya2VyLnBvc3RNZXNzYWdlIGNvbW1hbmQ6ICdnZXRTYW1wbGVEYXRhJ1xuICAgIHRoaXNcbiIsIm1pbkVudlZhbHVlID0gMC4wMVxuXG5tb2R1bGUuZXhwb3J0cyA9IChlbnYsIG5vdGUsIHRpbWUpIC0+XG5cbiAgZWxhcHNlZCA9IHRpbWUgLSBub3RlLnRpbWVcbiAgYSA9IE1hdGgubWF4IG1pbkVudlZhbHVlLCBlbnYuYVxuICBkID0gTWF0aC5tYXggbWluRW52VmFsdWUsIGVudi5kXG4gIHMgPSBlbnYuc1xuICByID0gTWF0aC5tYXggbWluRW52VmFsdWUsIGVudi5yXG5cbiAgIyBhdHRhY2ssIGRlY2F5LCBzdXN0YWluXG4gIGwgPSBpZiBlbGFwc2VkID4gYSArIGRcbiAgICBsID0gc1xuICBlbHNlIGlmIGVsYXBzZWQgPiBhXG4gICAgbCA9IHMgKyAoMSAtIHMpICogKGEgKyBkIC0gZWxhcHNlZCkgLyBkXG4gIGVsc2VcbiAgICBlbGFwc2VkIC8gYVxuXG4gICMgcmVsZWFzZVxuICBpZiBlbGFwc2VkID4gbm90ZS5sZW5cbiAgICBsID0gbCAqIChyICsgbm90ZS5sZW4gLSBlbGFwc2VkKSAvIHJcblxuICBNYXRoLm1heCAwLCBsXG4iLCJtb2R1bGUuZXhwb3J0cyA9IG5ldyAod2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCBvciB3aW5kb3cuQXVkaW9Db250ZXh0KVxuIiwic2FtcGxlUmF0ZSA9IDQ4MDAwXG5tYXhGcmVxID0gMTIwMDBcbmRiR2FpbiA9IDEyICAgICMgZ2FpbiBvZiBmaWx0ZXJcbmJhbmR3aWR0aCA9IDEgICMgYmFuZHdpZHRoIGluIG9jdGF2ZXNcblxuIyBjb25zdGFudHNcbkEgPSBNYXRoLnBvdygxMCwgZGJHYWluIC8gNDApXG5lID0gTWF0aC5sb2coMilcbnRhdSA9IDIgKiBNYXRoLlBJXG5iZXRhID0gTWF0aC5zcXJ0KDIgKiBBKVxuXG4jIGh5cGVyYm9saWMgc2luIGZ1bmN0aW9uXG5zaW5oID0gKHgpIC0+XG4gIHkgPSBNYXRoLmV4cCB4XG4gICh5IC0gMSAvIHkpIC8gMlxuXG5tb2R1bGUuZXhwb3J0cyA9IC0+XG4gIGEwID0gYTEgPSBhMiA9IGEzID0gYTQgPSB4MSA9IHgyID0geTEgPSB5MiA9IDBcbiAgZnJlcSA9IG9tZWdhID0gc24gPSBhbHBoYSA9IDBcbiAgY3MgPSAxXG5cbiAgbGFzdEN1dG9mZiA9IDBcblxuICAoc2FtcGxlLCBjdXRvZmYpIC0+XG4gICAgIyBjYWNoZSBmaWx0ZXIgdmFsdWVzIHVudGlsIGN1dG9mZiBjaGFuZ2VzXG4gICAgaWYgY3V0b2ZmICE9IGxhc3RDdXRvZmZcbiAgXG4gICAgICBvbGRDdXRvZmYgPSBjdXRvZmZcblxuICAgICAgZnJlcSA9IGN1dG9mZiAqIG1heEZyZXFcbiAgICAgIG9tZWdhID0gdGF1ICogZnJlcSAvIHNhbXBsZVJhdGVcbiAgICAgIHNuID0gTWF0aC5zaW4gb21lZ2FcbiAgICAgIGNzID0gTWF0aC5jb3Mgb21lZ2FcbiAgICAgIGFscGhhID0gc24gKiBzaW5oKGUgLyAyICogYmFuZHdpZHRoICogb21lZ2EgLyBzbilcblxuICAgICAgYjAgPSAoMSArIGNzKSAvIDJcbiAgICAgIGIxID0gLSgxICsgY3MpXG4gICAgICBiMiA9ICgxICsgY3MpIC8gMlxuICAgICAgYWEwID0gMSArIGFscGhhXG4gICAgICBhYTEgPSAtMiAqIGNzXG4gICAgICBhYTIgPSAxIC0gYWxwaGFcblxuICAgICAgYTAgPSBiMCAvIGFhMFxuICAgICAgYTEgPSBiMSAvIGFhMFxuICAgICAgYTIgPSBiMiAvIGFhMFxuICAgICAgYTMgPSBhYTEgLyBhYTBcbiAgICAgIGE0ID0gYWEyIC8gYWEwXG5cbiAgICAjIGNvbXB1dGUgcmVzdWx0XG4gICAgcyA9IE1hdGgubWF4IC0xLCBNYXRoLm1pbiAxLCBzYW1wbGVcbiAgICByZXN1bHQgPSBhMCAqIHMgKyBhMSAqIHgxICsgYTIgKiB4MiAtIGEzICogeTEgLSBhNCAqIHkyXG5cbiAgICAjIHNoaWZ0IHgxIHRvIHgyLCBzYW1wbGUgdG8geDFcbiAgICB4MiA9IHgxXG4gICAgeDEgPSBzXG5cbiAgICAjIHNoaWZ0IHkxIHRvIHkyLCByZXN1bHQgdG8geTFcbiAgICB5MiA9IHkxXG4gICAgeTEgPSByZXN1bHRcblxuICAgIHJlc3VsdCIsIm1vZHVsZS5leHBvcnRzID0gKHNhbXBsZURhdGEsIHRyYW5zcG9zZSwgc2FtcGxlc0VsYXBzZWQsIG9mZnNldCA9IDAsIGxvb3BBY3RpdmUgPSBmYWxzZSwgbG9vcFBvaW50KSAtPlxuICBpID0gc2FtcGxlc0VsYXBzZWQgKiBNYXRoLnBvdyAyLCB0cmFuc3Bvc2UgLyAxMlxuICBpMSA9IE1hdGguZmxvb3IgaVxuICBpMSA9IGkxICUgKGxvb3BQb2ludCAtIG9mZnNldCkgaWYgbG9vcEFjdGl2ZVxuICBpMiA9IGkxICsgMVxuICBsID0gaSAlIDFcblxuICBzYW1wbGVEYXRhW29mZnNldCArIGkxXSAqICgxIC0gbCkgKyBzYW1wbGVEYXRhW29mZnNldCArIGkyXSAqIGwiLCJzYW1wbGVSYXRlID0gNDgwMDBcblxubW9kdWxlLmV4cG9ydHMgPSAtPlxuXG4gIHkxID0geTIgPSB5MyA9IHk0ID0gb2xkeCA9IG9sZHkxID0gb2xkeTIgPSBvbGR5MyA9IDBcbiAgcCA9IGsgPSB0MSA9IHQyID0gciA9IHggPSBudWxsXG5cbiAgKHNhbXBsZSwgY3V0b2ZmLCByZXMpIC0+XG4gICAgZnJlcSA9IDIwICogTWF0aC5wb3cgMTAsIDMgKiBjdXRvZmZcbiAgICBmcmVxID0gZnJlcSAvIHNhbXBsZVJhdGVcbiAgICBwID0gZnJlcSAqICgxLjggLSAoMC44ICogZnJlcSkpXG4gICAgayA9IDIgKiBNYXRoLnNpbihmcmVxICogTWF0aC5QSSAvIDIpIC0gMVxuICAgIHQxID0gKDEgLSBwKSAqIDEuMzg2MjQ5XG4gICAgdDIgPSAxMiArIHQxICogdDFcbiAgICByID0gcmVzICogMC41NyAqICh0MiArIDYgKiB0MSkgLyAodDIgLSA2ICogdDEpXG5cbiAgICB4ID0gc2FtcGxlIC0gciAqIHk0XG5cbiAgICAjIGZvdXIgY2FzY2FkZWQgb25lLXBvbGUgZmlsdGVycyAoYmlsaW5lYXIgdHJhbnNmb3JtKVxuICAgIHkxID0gIHggKiBwICsgb2xkeCAgKiBwIC0gayAqIHkxXG4gICAgeTIgPSB5MSAqIHAgKyBvbGR5MSAqIHAgLSBrICogeTJcbiAgICB5MyA9IHkyICogcCArIG9sZHkyICogcCAtIGsgKiB5M1xuICAgIHk0ID0geTMgKiBwICsgb2xkeTMgKiBwIC0gayAqIHk0XG5cbiAgICAjIGNsaXBwZXIgYmFuZCBsaW1pdGVkIHNpZ21vaWRcbiAgICB5NCAtPSAoeTQgKiB5NCAqIHk0KSAvIDZcblxuICAgIG9sZHggPSB4XG4gICAgb2xkeTEgPSB5MVxuICAgIG9sZHkyID0geTJcbiAgICBvbGR5MyA9IHkzXG5cbiAgICB5NCIsInRhdSA9IE1hdGguUEkgKiAyXG5cbm1vZHVsZS5leHBvcnRzID1cblxuICBzaW5lOiAodGltZSwgZnJlcXVlbmN5KSAtPlxuICAgIE1hdGguc2luIHRpbWUgKiB0YXUgKiBmcmVxdWVuY3lcblxuICBzcXVhcmU6ICh0aW1lLCBmcmVxdWVuY3kpIC0+XG4gICAgaWYgKCh0aW1lICUgKDEgLyBmcmVxdWVuY3kpKSAqIGZyZXF1ZW5jeSkgJSAxID4gMC41IHRoZW4gMSBlbHNlIC0xXG5cbiAgc2F3OiAodGltZSwgZnJlcXVlbmN5KSAtPlxuICAgIDEgLSAyICogKCgodGltZSAlICgxIC8gZnJlcXVlbmN5KSkgKiBmcmVxdWVuY3kpICUgMSlcblxuICBub2lzZTogLT5cbiAgICAyICogTWF0aC5yYW5kb20oKSAtIDEiLCJtb2R1bGUuZXhwb3J0cyA9IChkZWNheSwgZWxhcHNlZCkgLT5cbiAgaWYgZWxhcHNlZCA+IGRlY2F5XG4gICAgMFxuICBlbHNlXG4gICAgMSAtIGVsYXBzZWQgLyBkZWNheVxuIiwiYnVmZmVyU2l6ZSA9IDQwOTZcblxubW9kdWxlLmV4cG9ydHMgPSAoY29udGV4dCwgZm4pIC0+XG5cbiAgIyBhY2NlcHQgYSBzaW5nbGUgYXJndW1lbnRcbiAgaWYgdHlwZW9mIGNvbnRleHQgaXMgJ2Z1bmN0aW9uJ1xuICAgIENvbnRleHQgPSB3aW5kb3cuQXVkaW9Db250ZXh0IG9yIHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHRcbiAgICB0aHJvdyBuZXcgRXJyb3IgJ0F1ZGlvQ29udGV4dCBub3Qgc3VwcG9ydGVkJyB1bmxlc3MgQ29udGV4dFxuICAgIGZuID0gY29udGV4dFxuICAgIGNvbnRleHQgPSBuZXcgQ29udGV4dCgpXG5cbiAgc2VsZiA9IGNvbnRleHQuY3JlYXRlU2NyaXB0UHJvY2Vzc29yIGJ1ZmZlclNpemUsIDEsIDFcbiAgc2VsZi5mbiA9IGZuXG4gIHNlbGYuaSA9IHNlbGYudCA9IDBcbiAgc2VsZi5zYW1wbGVSYXRlID0gY29udGV4dC5zYW1wbGVSYXRlXG4gIHNlbGYuZHVyYXRpb24gPSBJbmZpbml0eVxuICBzZWxmLnBsYXlpbmcgPSBmYWxzZVxuXG4gIGJ1ZmZlclN0YXJ0QWJzb2x1dGUgPSBudWxsXG4gIGJ1ZmZlclN0YXJ0UmVsYXRpdmUgPSBudWxsXG5cbiAgc2VsZi5vbmF1ZGlvcHJvY2VzcyA9IChlKSAtPlxuICAgIGJ1ZmZlclN0YXJ0QWJzb2x1dGUgPSBEYXRlLm5vdygpXG4gICAgYnVmZmVyU3RhcnRSZWxhdGl2ZSA9IHNlbGYudFxuXG4gICAgb3V0cHV0ID0gZS5vdXRwdXRCdWZmZXIuZ2V0Q2hhbm5lbERhdGEgMFxuXG4gICAgZm9yIGkgaW4gWzAuLi5idWZmZXJTaXplXVxuICAgICAgc2VsZi50ID0gc2VsZi5pIC8gc2VsZi5zYW1wbGVSYXRlXG4gICAgICBzZWxmLmkgKz0gMVxuXG4gICAgICBvdXRwdXRbaV0gPSBzZWxmLmZuIHNlbGYudCwgc2VsZi5pXG5cbiAgICBvdXRwdXRcblxuICBzZWxmLmdldFRpbWUgPSAtPlxuICAgIGlmIGJ1ZmZlclN0YXJ0UmVsYXRpdmU/XG4gICAgICBidWZmZXJTdGFydFJlbGF0aXZlICsgKERhdGUubm93KCkgLSBidWZmZXJTdGFydEFic29sdXRlKSAvIDEwMDBcbiAgICBlbHNlXG4gICAgICBzZWxmLnRcblxuICBzZWxmLnNlZWsgPSAodGltZSkgLT5cbiAgICBidWZmZXJTdGFydEFic29sdXRlID0gbnVsbFxuICAgIGJ1ZmZlclN0YXJ0UmVsYXRpdmUgPSBudWxsXG4gICAgc2VsZi5pID0gTWF0aC5mbG9vcih0aW1lICogc2VsZi5zYW1wbGVSYXRlKVxuICAgIHNlbGYudCA9IHRpbWVcblxuICBzZWxmLnBsYXkgPSAob3B0cykgLT5cbiAgICByZXR1cm4gaWYgc2VsZi5wbGF5aW5nXG4gICAgc2VsZi5jb25uZWN0IHNlbGYuY29udGV4dC5kZXN0aW5hdGlvblxuICAgIHNlbGYucGxheWluZyA9IHRydWVcblxuICAgICMgdGhpcyB0aW1lb3V0IHNlZW1zIHRvIGJlIHRoZSB0aGluZyB0aGF0IGtlZXBzIHRoZSBhdWRpbyBmcm9tIGNsaXBwaW5nICNXVEZBTEVSVFxuICAgIHNldFRpbWVvdXQgKC0+IHRoaXMubm9kZS5kaXNjb25uZWN0KCkpLCAxMDAwMDAwMDAwMDBcblxuICBzZWxmLnN0b3AgPSAtPlxuICAgIGJ1ZmZlclN0YXJ0QWJzb2x1dGUgPSBudWxsXG4gICAgYnVmZmVyU3RhcnRSZWxhdGl2ZSA9IG51bGxcbiAgICBzZWxmLnBsYXlpbmcgPSBmYWxzZVxuICAgIHNlbGYuZGlzY29ubmVjdCgpXG5cbiAgc2VsZi5yZXNldCA9IC0+XG4gICAgc2VsZi5pID0gc2VsZi50ID0gMFxuXG4gIHNlbGZcbiIsIkluc3RydW1lbnQgPSByZXF1aXJlICcuL2luc3RydW1lbnQnXG5SaW5nQnVmZmVyID0gcmVxdWlyZSAnLi4vdXRpbC9yaW5nX2J1ZmZlcidcbmxvd3Bhc3NGaWx0ZXIgPSByZXF1aXJlICcuLi9kc3AvbG93cGFzc19maWx0ZXInXG5oaWdocGFzc0ZpbHRlciA9IHJlcXVpcmUgJy4uL2RzcC9oaWdocGFzc19maWx0ZXInXG5lbnZlbG9wZSA9IHJlcXVpcmUgJy4uL2RzcC9lbnZlbG9wZSdcbm9zY2lsbGF0b3JzID0gcmVxdWlyZSAnLi4vZHNwL29zY2lsbGF0b3JzJ1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIEFuYWxvZ1N5bnRoZXNpemVyIGV4dGVuZHMgSW5zdHJ1bWVudFxuXG4gIEBkZWZhdWx0czpcbiAgICBfdHlwZTogJ0FuYWxvZ1N5bnRoZXNpemVyJ1xuICAgIGxldmVsOiAwLjVcbiAgICBwYW46IDAuNVxuICAgIHBvbHlwaG9ueTogM1xuICAgIG1heFBvbHlwaG9ueTogNlxuICAgIHZvbHVtZUVudjpcbiAgICAgIGE6IDBcbiAgICAgIGQ6IDAuMjVcbiAgICAgIHM6IDBcbiAgICAgIHI6IDAuNVxuICAgIGZpbHRlckVudjpcbiAgICAgIGE6IDBcbiAgICAgIGQ6IDAuMjVcbiAgICAgIHM6IDAuMlxuICAgICAgcjogMC41XG4gICAgZmlsdGVyOlxuICAgICAgdHlwZTogJ0xQJ1xuICAgICAgZnJlcTogMC4yN1xuICAgICAgcmVzOiAwLjA1XG4gICAgICBlbnY6IDAuNDVcbiAgICBvc2MxOlxuICAgICAgd2F2ZWZvcm06ICdzYXcnXG4gICAgICBsZXZlbDogMC41XG4gICAgICBwaXRjaDogMC41XG4gICAgICB0dW5lOiAwLjVcbiAgICBvc2MyOlxuICAgICAgd2F2ZWZvcm06ICdzYXcnXG4gICAgICBsZXZlbDogMC41XG4gICAgICBwaXRjaDogMC41XG4gICAgICB0dW5lOiAwLjVcblxuICBAY3JlYXRlU3RhdGU6IChpbnN0cnVtZW50KSAtPlxuICAgIHN1cGVyIGluc3RydW1lbnRcblxuICAgIEBzdGF0ZVtpbnN0cnVtZW50Ll9pZF0uZmlsdGVycyA9XG4gICAgICBMUDogKGxvd3Bhc3NGaWx0ZXIoKSBmb3IgaSBpbiBbMC4uLmluc3RydW1lbnQubWF4UG9seXBob255XSlcbiAgICAgIEhQOiAoaGlnaHBhc3NGaWx0ZXIoKSBmb3IgaSBpbiBbMC4uLmluc3RydW1lbnQubWF4UG9seXBob255XSlcbiAgICAgIG5vbmU6ICgoKHNhbXBsZSkgLT4gc2FtcGxlKSBmb3IgaSBpbiBbMC4uLmluc3RydW1lbnQubWF4UG9seXBob255XSlcblxuICB0dW5lID0gNDQwXG4gIGZyZXF1ZW5jeSA9IChrZXkpIC0+XG4gICAgdHVuZSAqIE1hdGgucG93IDIsIChrZXkgLSA2OSkgLyAxMlxuXG4gIEBzYW1wbGU6IChpbnN0cnVtZW50LCB0aW1lLCBpKSAtPlxuICAgIHJldHVybiAwIGlmIEBzdGF0ZS5sZXZlbCA9PSAwXG4gICAgcmV0dXJuIDAgdW5sZXNzIEBzdGF0ZVtpbnN0cnVtZW50Ll9pZF0/XG5cbiAgICAjIHN1bSBhbGwgYWN0aXZlIG5vdGVzXG4gICAgciA9IE1hdGgubWF4IDAuMDEsIGluc3RydW1lbnQudm9sdW1lRW52LnJcbiAgICBpbnN0cnVtZW50LmxldmVsICogQHN0YXRlW2luc3RydW1lbnQuX2lkXS5ub3Rlcy5yZWR1Y2UoKG1lbW8sIG5vdGUsIGluZGV4KSA9PlxuICAgICAgcmV0dXJuIG1lbW8gdW5sZXNzIG5vdGU/XG4gICAgICByZXR1cm4gbWVtbyB1bmxlc3Mgbm90ZS5sZW4gKyByID4gdGltZSAtIG5vdGUudGltZVxuXG4gICAgICAjIHN1bSBvc2NpbGxhdG9ycyBhbmQgYXBwbHkgdm9sdW1lIGVudmVsb3BlXG4gICAgICBvc2MxRnJlcSA9IGZyZXF1ZW5jeSBub3RlLmtleSArIGluc3RydW1lbnQub3NjMS50dW5lIC0gMC41ICsgTWF0aC5yb3VuZCgyNCAqIChpbnN0cnVtZW50Lm9zYzEucGl0Y2ggLSAwLjUpKVxuICAgICAgb3NjMkZyZXEgPSBmcmVxdWVuY3kgbm90ZS5rZXkgKyBpbnN0cnVtZW50Lm9zYzIudHVuZSAtIDAuNSArIE1hdGgucm91bmQoMjQgKiAoaW5zdHJ1bWVudC5vc2MyLnBpdGNoIC0gMC41KSlcbiAgICAgIHNhbXBsZSA9IGVudmVsb3BlKGluc3RydW1lbnQudm9sdW1lRW52LCBub3RlLCB0aW1lKSAqIChcbiAgICAgICAgaW5zdHJ1bWVudC5vc2MxLmxldmVsICogb3NjaWxsYXRvcnNbaW5zdHJ1bWVudC5vc2MxLndhdmVmb3JtXSh0aW1lLCBvc2MxRnJlcSkgK1xuICAgICAgICBpbnN0cnVtZW50Lm9zYzIubGV2ZWwgKiBvc2NpbGxhdG9yc1tpbnN0cnVtZW50Lm9zYzIud2F2ZWZvcm1dKHRpbWUsIG9zYzJGcmVxKVxuICAgICAgKVxuXG4gICAgICAjIGFwcGx5IGZpbHRlciB3aXRoIGVudmVsb3BlXG4gICAgICBjdXRvZmYgPSBNYXRoLm1pbiAxLCBpbnN0cnVtZW50LmZpbHRlci5mcmVxICsgaW5zdHJ1bWVudC5maWx0ZXIuZW52ICogZW52ZWxvcGUoaW5zdHJ1bWVudC5maWx0ZXJFbnYsIG5vdGUsIHRpbWUpXG4gICAgICBmaWx0ZXIgPSBAc3RhdGVbaW5zdHJ1bWVudC5faWRdLmZpbHRlcnNbaW5zdHJ1bWVudC5maWx0ZXIudHlwZV1baW5kZXhdXG4gICAgICBzYW1wbGUgPSBmaWx0ZXIgc2FtcGxlLCBjdXRvZmYsIGluc3RydW1lbnQuZmlsdGVyLnJlc1xuXG4gICAgICAjIHJldHVybiByZXN1bHRcbiAgICAgIG1lbW8gKyBzYW1wbGVcblxuICAgICwgMClcbiIsIkluc3RydW1lbnQgPSByZXF1aXJlICcuL2luc3RydW1lbnQnXG5SaW5nQnVmZmVyID0gcmVxdWlyZSAnLi4vdXRpbC9yaW5nX2J1ZmZlcidcbmxpbmVhckludGVycG9sYXRvciA9IHJlcXVpcmUgJy4uL2RzcC9saW5lYXJfaW50ZXJwb2xhdG9yJ1xubG93cGFzc0ZpbHRlciA9IHJlcXVpcmUgJy4uL2RzcC9sb3dwYXNzX2ZpbHRlcidcbmhpZ2hwYXNzRmlsdGVyID0gcmVxdWlyZSAnLi4vZHNwL2hpZ2hwYXNzX2ZpbHRlcidcbmVudmVsb3BlID0gcmVxdWlyZSAnLi4vZHNwL2VudmVsb3BlJ1xubG9nU2FtcGxlID0gcmVxdWlyZSAnLi4vdXRpbC9sb2dfc2FtcGxlJ1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIEJhc2ljU2FtcGxlciBleHRlbmRzIEluc3RydW1lbnRcblxuICBAZGVmYXVsdHM6XG4gICAgX3R5cGU6ICdCYXNpY1NhbXBsZXInXG4gICAgbGV2ZWw6IDAuNVxuICAgIHBhbjogMC41XG4gICAgcG9seXBob255OiAxXG4gICAgbWF4UG9seXBob255OiA2XG4gICAgcm9vdEtleTogNjBcbiAgICBzYW1wbGVEYXRhOiBudWxsXG4gICAgc2FtcGxlTmFtZTogJydcbiAgICBzdGFydDogMC4zXG4gICAgbG9vcEFjdGl2ZTogJ2xvb3AnXG4gICAgbG9vcDogMC43XG4gICAgdHVuZTogMC41XG4gICAgdm9sdW1lRW52OlxuICAgICAgYTogMFxuICAgICAgZDogMC4yNVxuICAgICAgczogMVxuICAgICAgcjogMC41XG4gICAgZmlsdGVyRW52OlxuICAgICAgYTogMFxuICAgICAgZDogMC4yNVxuICAgICAgczogMVxuICAgICAgcjogMC41XG4gICAgZmlsdGVyOlxuICAgICAgdHlwZTogJ25vbmUnXG4gICAgICBmcmVxOiAwLjI3XG4gICAgICByZXM6IDAuMDVcbiAgICAgIGVudjogMC40NVxuXG4gIEBjcmVhdGVTdGF0ZTogKGluc3RydW1lbnQpIC0+XG4gICAgc3VwZXIgaW5zdHJ1bWVudFxuXG4gICAgQHN0YXRlW2luc3RydW1lbnQuX2lkXS5maWx0ZXJzID1cbiAgICAgIExQOiAobG93cGFzc0ZpbHRlcigpIGZvciBpIGluIFswLi4uaW5zdHJ1bWVudC5tYXhQb2x5cGhvbnldKVxuICAgICAgSFA6IChoaWdocGFzc0ZpbHRlcigpIGZvciBpIGluIFswLi4uaW5zdHJ1bWVudC5tYXhQb2x5cGhvbnldKVxuICAgICAgbm9uZTogKCgoc2FtcGxlKSAtPiBzYW1wbGUpIGZvciBpIGluIFswLi4uaW5zdHJ1bWVudC5tYXhQb2x5cGhvbnldKVxuXG4gIEBzYW1wbGU6IChpbnN0cnVtZW50LCB0aW1lLCBpKSAtPlxuICAgIHJldHVybiAwIGlmIGluc3RydW1lbnQubGV2ZWwgPT0gMFxuICAgIHJldHVybiAwIHVubGVzcyBAc3RhdGVbaW5zdHJ1bWVudC5faWRdP1xuICAgIHJldHVybiAwIHVubGVzcyBpbnN0cnVtZW50LnNhbXBsZURhdGE/XG5cbiAgICByID0gTWF0aC5tYXggMC4wMSwgaW5zdHJ1bWVudC52b2x1bWVFbnYuclxuXG4gICAgaW5zdHJ1bWVudC5sZXZlbCAqIEBzdGF0ZVtpbnN0cnVtZW50Ll9pZF0ubm90ZXMucmVkdWNlKChtZW1vLCBub3RlLCBpbmRleCkgPT5cbiAgICAgIHJldHVybiBtZW1vIHVubGVzcyBub3RlP1xuICAgICAgcmV0dXJuIG1lbW8gdW5sZXNzIG5vdGUubGVuICsgciA+IHRpbWUgLSBub3RlLnRpbWVcblxuICAgICAgIyBnZXQgcGl0Y2ggc2hpZnRlZCBpbnRlcnBvbGF0ZWQgc2FtcGxlIGFuZCBhcHBseSB2b2x1bWUgZW52ZWxvcGVcbiAgICAgIHRyYW5zcG9zZSA9IG5vdGUua2V5IC0gaW5zdHJ1bWVudC5yb290S2V5ICsgaW5zdHJ1bWVudC50dW5lIC0gMC41XG4gICAgICBzYW1wbGVzRWxhcHNlZCA9IGkgLSBub3RlLmlcbiAgICAgIG9mZnNldCA9IE1hdGguZmxvb3IgaW5zdHJ1bWVudC5zdGFydCAqIGluc3RydW1lbnQuc2FtcGxlRGF0YS5sZW5ndGhcbiAgICAgIGxvb3BQb2ludCA9IE1hdGguZmxvb3IgaW5zdHJ1bWVudC5sb29wICogaW5zdHJ1bWVudC5zYW1wbGVEYXRhLmxlbmd0aFxuICAgICAgc2FtcGxlID0gbGluZWFySW50ZXJwb2xhdG9yIGluc3RydW1lbnQuc2FtcGxlRGF0YSwgdHJhbnNwb3NlLCBzYW1wbGVzRWxhcHNlZCwgb2Zmc2V0LCBpbnN0cnVtZW50Lmxvb3BBY3RpdmUgPT0gJ2xvb3AnLCBsb29wUG9pbnRcbiAgICAgIHNhbXBsZSA9IGVudmVsb3BlKGluc3RydW1lbnQudm9sdW1lRW52LCBub3RlLCB0aW1lKSAqIChzYW1wbGUgb3IgMClcblxuICAgICAgIyBhcHBseSBmaWx0ZXIgd2l0aCBlbnZlbG9wZVxuICAgICAgY3V0b2ZmID0gTWF0aC5taW4gMSwgaW5zdHJ1bWVudC5maWx0ZXIuZnJlcSArIGluc3RydW1lbnQuZmlsdGVyLmVudiAqIGVudmVsb3BlKGluc3RydW1lbnQuZmlsdGVyRW52LCBub3RlLCB0aW1lKVxuICAgICAgZmlsdGVyID0gQHN0YXRlW2luc3RydW1lbnQuX2lkXS5maWx0ZXJzW2luc3RydW1lbnQuZmlsdGVyLnR5cGVdW2luZGV4XVxuICAgICAgc2FtcGxlID0gZmlsdGVyIHNhbXBsZSwgY3V0b2ZmLCBpbnN0cnVtZW50LmZpbHRlci5yZXNcblxuICAgICAgIyByZXR1cm4gcmVzdWx0XG4gICAgICBtZW1vICsgc2FtcGxlXG5cbiAgICAsIDApXG4iLCJJbnN0cnVtZW50ID0gcmVxdWlyZSAnLi9pbnN0cnVtZW50J1xuZW52ZWxvcGUgPSByZXF1aXJlICcuLi9kc3AvZW52ZWxvcGUnXG5saW5lYXJJbnRlcnBvbGF0b3IgPSByZXF1aXJlICcuLi9kc3AvbGluZWFyX2ludGVycG9sYXRvcidcbmxvZ1NhbXBsZSA9IHJlcXVpcmUgJy4uL3V0aWwvbG9nX3NhbXBsZSdcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBEcnVtU2FtcGxlciBleHRlbmRzIEluc3RydW1lbnRcblxuICBAZGVmYXVsdHM6XG4gICAgX3R5cGU6ICdEcnVtU2FtcGxlcidcbiAgICBsZXZlbDogMC41XG4gICAgcGFuOiAwLjVcbiAgICBkcnVtczogW1xuICAgICAge1xuICAgICAgICBuYW1lOiAnRHJ1bSAxJ1xuICAgICAgICBzYW1wbGVEYXRhOiBudWxsXG4gICAgICAgIHNhbXBsZU5hbWU6ICcnXG4gICAgICAgIHRyYW5zcG9zZTogMFxuICAgICAgICBsZXZlbDogMVxuICAgICAgICBzdGFydDogMFxuICAgICAgICBrZXk6IDBcbiAgICAgICAgdm9sdW1lRW52OlxuICAgICAgICAgIGE6IDBcbiAgICAgICAgICBkOiAxXG4gICAgICAgICAgczogMVxuICAgICAgICAgIHI6IDFcbiAgICAgIH1cbiAgICBdXG5cbiAgQGRlZmF1bHREcnVtOiAoZHJ1bXMpIC0+XG4gICAgbmFtZTogXCJEcnVtICN7ZHJ1bXMubGVuZ3RoICsgMX1cIlxuICAgIHNhbXBsZURhdGE6IG51bGxcbiAgICBzYW1wbGVOYW1lOiAnJ1xuICAgIHRyYW5zcG9zZTogMFxuICAgIGxldmVsOiAxXG4gICAgc3RhcnQ6IDBcbiAgICBrZXk6IGRvID0+XG4gICAgICBrZXkgPSAwXG4gICAgICBrZXkgKz0gMSB3aGlsZSBkcnVtcy5zb21lIChkcnVtKSAtPiBkcnVtLmtleSA9PSBrZXlcbiAgICAgIGtleVxuICAgIHZvbHVtZUVudjpcbiAgICAgIGE6IDBcbiAgICAgIGQ6IDFcbiAgICAgIHM6IDFcbiAgICAgIHI6IDFcblxuICAjIGtlZXAgbm90ZXMgaW4gYSBtYXAge2tleTogbm90ZURhdGF9IGluc3RlYWQgb2YgdG8gYSByaW5nIGJ1ZmZlclxuICAjIHRoaXMgZ2l2ZXMgdXMgb25lIG1vbnBob25pYyB2b2ljZSBwZXIgZHJ1bVxuICBAY3JlYXRlU3RhdGU6IChpbnN0cnVtZW50KSAtPlxuICAgIEBzdGF0ZVtpbnN0cnVtZW50Ll9pZF0gPSBub3Rlczoge31cblxuICBAc2FtcGxlOiAoaW5zdHJ1bWVudCwgdGltZSwgaSkgLT5cbiAgICByZXR1cm4gMCBpZiBpbnN0cnVtZW50LmxldmVsID09IDBcbiAgICByZXR1cm4gMCB1bmxlc3MgQHN0YXRlW2luc3RydW1lbnQuX2lkXT9cblxuICAgICMgc3VtIGFsbCBhY3RpdmUgbm90ZXNcbiAgICBpbnN0cnVtZW50LmxldmVsICogaW5zdHJ1bWVudC5kcnVtcy5yZWR1Y2UoKG1lbW8sIGRydW0pID0+XG4gICAgICByZXR1cm4gbWVtbyB1bmxlc3MgZHJ1bS5zYW1wbGVEYXRhP1xuXG4gICAgICBub3RlID0gQHN0YXRlW2luc3RydW1lbnQuX2lkXS5ub3Rlc1tkcnVtLmtleV1cbiAgICAgIHJldHVybiBtZW1vIHVubGVzcyBub3RlP1xuXG4gICAgICBzYW1wbGVzRWxhcHNlZCA9IGkgLSBub3RlLmlcbiAgICAgIG9mZnNldCA9IE1hdGguZmxvb3IgZHJ1bS5zdGFydCAqIGRydW0uc2FtcGxlRGF0YS5sZW5ndGhcbiAgICAgIHJldHVybiBtZW1vIGlmIHNhbXBsZXNFbGFwc2VkICsgb2Zmc2V0ID4gZHJ1bS5zYW1wbGVEYXRhLmxlbmd0aFxuXG4gICAgICBzYW1wbGUgPSBsaW5lYXJJbnRlcnBvbGF0b3IgZHJ1bS5zYW1wbGVEYXRhLCBkcnVtLnRyYW5zcG9zZSwgc2FtcGxlc0VsYXBzZWQsIG9mZnNldFxuICAgICAgbWVtbyArIGRydW0ubGV2ZWwgKiBlbnZlbG9wZShkcnVtLnZvbHVtZUVudiwgbm90ZSwgdGltZSkgKiAoc2FtcGxlIG9yIDApXG4gICAgLCAwKVxuXG4gIEB0aWNrOiAoaW5zdHJ1bWVudCwgdGltZSwgaSwgYmVhdCwgYnBzLCBub3Rlc09uKSAtPlxuICAgIEBjcmVhdGVTdGF0ZSBpbnN0cnVtZW50IHVubGVzcyBAc3RhdGVbaW5zdHJ1bWVudC5faWRdP1xuXG4gICAgbm90ZXNPbi5mb3JFYWNoIChub3RlKSA9PlxuICAgICAgQHN0YXRlW2luc3RydW1lbnQuX2lkXS5ub3Rlc1tub3RlLmtleV0gPSB7dGltZSwgaSwgbGVuOiBub3RlLmxlbmd0aCAvIGJwc31cbiIsIkluc3RydW1lbnQgPSByZXF1aXJlICcuL2luc3RydW1lbnQnXG5oaWdocGFzc0ZpbHRlciA9IHJlcXVpcmUgJy4uL2RzcC9oaWdocGFzc19maWx0ZXInXG5zaW1wbGVFbnZlbG9wZSA9IHJlcXVpcmUgJy4uL2RzcC9zaW1wbGVfZW52ZWxvcGUnXG5vc2NpbGxhdG9ycyA9IHJlcXVpcmUgJy4uL2RzcC9vc2NpbGxhdG9ycydcbmxvZ1NhbXBsZSA9IHJlcXVpcmUgJy4uL3V0aWwvbG9nX3NhbXBsZSdcbmN1aWQgPSByZXF1aXJlICdjdWlkJ1xuXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgRHJ1bVN5bnRoZXNpemVyIGV4dGVuZHMgSW5zdHJ1bWVudFxuXG4gIG1pbkZyZXEgPSA2MFxuICBtYXhGcmVxID0gMzAwMFxuICBmcmVxU2NhbGUgPSBtYXhGcmVxIC0gbWluRnJlcVxuXG4gIEBkZWZhdWx0czpcbiAgICBsZXZlbDogMC41XG4gICAgcGFuOiAwLjVcbiAgICBkcnVtczogW1xuICAgICAge1xuICAgICAgICBrZXk6IDBcbiAgICAgICAgbmFtZTogJ0tpY2snXG4gICAgICAgIGxldmVsOiAxXG4gICAgICAgIGhwOiAwXG4gICAgICAgIGRlY2F5OiAwLjM1XG4gICAgICAgIG5vaXNlOiAwLjAwMVxuICAgICAgICBwaXRjaDogMFxuICAgICAgICBiZW5kOiAwLjM5XG4gICAgICAgIGZtOiAxXG4gICAgICAgIGZtRGVjYXk6IDAuMDVcbiAgICAgICAgZm1GcmVxOiAwLjAyXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogMVxuICAgICAgICBuYW1lOiAnU25hcmUnXG4gICAgICAgIGxldmVsOiAwLjVcbiAgICAgICAgaHA6IDAuMjJcbiAgICAgICAgZGVjYXk6IDAuMVxuICAgICAgICBub2lzZTogMC44XG4gICAgICAgIHBpdGNoOiAwLjFcbiAgICAgICAgYmVuZDogMFxuICAgICAgICBmbTogMFxuICAgICAgICBmbURlY2F5OiAwXG4gICAgICAgIGZtRnJlcTogMFxuICAgICAgfSwge1xuICAgICAgICBrZXk6IDJcbiAgICAgICAgbmFtZTogJ0hIMSdcbiAgICAgICAgbGV2ZWw6IDAuMDVcbiAgICAgICAgaHA6IDFcbiAgICAgICAgZGVjYXk6IDAuMDdcbiAgICAgICAgbm9pc2U6IDAuOFxuICAgICAgICBwaXRjaDogMC40XG4gICAgICAgIGJlbmQ6IDBcbiAgICAgICAgZm06IDFcbiAgICAgICAgZm1EZWNheTogMC40XG4gICAgICAgIGZtRnJlcTogMFxuICAgICAgfSwge1xuICAgICAgICBrZXk6IDNcbiAgICAgICAgbmFtZTogJ0hIMidcbiAgICAgICAgbGV2ZWw6IDAuMlxuICAgICAgICBocDogMC42XG4gICAgICAgIGRlY2F5OiAwLjIyXG4gICAgICAgIG5vaXNlOiAxXG4gICAgICAgIHBpdGNoOiAwLjVcbiAgICAgICAgYmVuZDogMFxuICAgICAgICBmbTogMFxuICAgICAgICBmbURlY2F5OiAwXG4gICAgICAgIGZtRnJlcTogMFxuICAgICAgfVxuICAgIF1cblxuICBAZGVmYXVsdERydW06IChkcnVtcykgLT5cbiAgICBrZXk6IGRvID0+XG4gICAgICBrZXkgPSAwXG4gICAgICBrZXkgKz0gMSB3aGlsZSBkcnVtcy5zb21lIChkcnVtKSAtPiBkcnVtLmtleSA9PSBrZXlcbiAgICAgIGtleVxuICAgIG5hbWU6IFwiRHJ1bSAje2RydW1zLmxlbmd0aCArIDF9XCJcbiAgICBsZXZlbDogMC41XG4gICAgaHA6IDBcbiAgICBkZWNheTogMC41XG4gICAgbm9pc2U6IDAuNVxuICAgIHBpdGNoOiAwLjVcbiAgICBiZW5kOiAwXG4gICAgZm06IDBcbiAgICBmbURlY2F5OiAwXG4gICAgZm1GcmVxOiAwXG5cbiAgIyBrZWVwIG5vdGVzIGluIGEgbWFwIHtrZXk6IG5vdGVEYXRhfSBpbnN0ZWFkIG9mIHRvIGEgcmluZyBidWZmZXJcbiAgIyB0aGlzIGdpdmVzIHVzIG9uZSBtb25waG9uaWMgdm9pY2UgcGVyIGRydW0uXG4gIEBjcmVhdGVTdGF0ZTogKGluc3RydW1lbnQpIC0+XG4gICAgQHN0YXRlW2luc3RydW1lbnQuX2lkXSA9XG4gICAgICBub3Rlczoge31cbiAgICAgIGZpbHRlcnM6IChcbiAgICAgICAgaGlnaHBhc3NGaWx0ZXIoKSBmb3IgaSBpbiBbMC4uLjEyN11cbiAgICAgIClcblxuICBAc2FtcGxlOiAoaW5zdHJ1bWVudCwgdGltZSwgaSkgLT5cbiAgICByZXR1cm4gMCBpZiBpbnN0cnVtZW50LmxldmVsID09IDBcbiAgICByZXR1cm4gMCB1bmxlc3MgQHN0YXRlW2luc3RydW1lbnQuX2lkXT9cblxuICAgICMgc3VtIGFsbCBhY3RpdmUgbm90ZXNcbiAgICBpbnN0cnVtZW50LmxldmVsICogaW5zdHJ1bWVudC5kcnVtcy5yZWR1Y2UoKG1lbW8sIGRydW0pID0+XG4gICAgICBub3RlID0gQHN0YXRlW2luc3RydW1lbnQuX2lkXS5ub3Rlc1tkcnVtLmtleV1cbiAgICAgIHJldHVybiBtZW1vIHVubGVzcyBub3RlP1xuXG4gICAgICBlbGFwc2VkID0gdGltZSAtIG5vdGUudGltZVxuICAgICAgcmV0dXJuIG1lbW8gaWYgZWxhcHNlZCA+IGRydW0uZGVjYXlcblxuICAgICAgZW52ID0gc2ltcGxlRW52ZWxvcGUgZHJ1bS5kZWNheSwgZWxhcHNlZFxuICAgICAgZnJlcSA9IG1pbkZyZXEgKyBkcnVtLnBpdGNoICogZnJlcVNjYWxlXG5cbiAgICAgICMgYXBwbHkgcGl0Y2ggYmVuZFxuICAgICAgaWYgZHJ1bS5iZW5kXG4gICAgICAgIGZyZXEgPSAoMiAtIGRydW0uYmVuZCArIGRydW0uYmVuZCAqIGVudikgLyAyICogZnJlcVxuXG4gICAgICAjIGFwcGx5IGZtXG4gICAgICBpZiBkcnVtLmZtID4gMFxuICAgICAgICBzaWduYWwgPSBvc2NpbGxhdG9ycy5zaW5lIGVsYXBzZWQsIG1pbkZyZXEgKyBkcnVtLmZtRnJlcSAqIGZyZXFTY2FsZVxuICAgICAgICBmcmVxICs9IGRydW0uZm0gKiBzaWduYWwgKiBzaW1wbGVFbnZlbG9wZShkcnVtLmZtRGVjYXkgKyAwLjAxLCBlbGFwc2VkKVxuXG4gICAgICAjIHN1bSBub2lzZSBhbmQgb3NjaWxsYXRvclxuICAgICAgc2FtcGxlID0gKFxuICAgICAgICAoMSAtIGRydW0ubm9pc2UpICogb3NjaWxsYXRvcnMuc2luZShlbGFwc2VkLCBmcmVxKSArXG4gICAgICAgIGRydW0ubm9pc2UgKiBvc2NpbGxhdG9ycy5ub2lzZSgpXG4gICAgICApXG5cbiAgICAgICMgYXBwbHkgaGlnaHBhc3NcbiAgICAgIGlmIGRydW0uaHAgPiAwXG4gICAgICAgIHNhbXBsZSA9IEBzdGF0ZVtpbnN0cnVtZW50Ll9pZF0uZmlsdGVyc1tkcnVtLmtleV0gc2FtcGxlLCBkcnVtLmhwXG5cbiAgICAgIG1lbW8gKyBkcnVtLmxldmVsICogZW52ICogc2FtcGxlXG5cbiAgICAsIDApXG5cblxuICBAdGljazogKGluc3RydW1lbnQsIHRpbWUsIGksIGJlYXQsIGJwcywgbm90ZXNPbikgLT5cbiAgICBAY3JlYXRlU3RhdGUgaW5zdHJ1bWVudCB1bmxlc3MgQHN0YXRlW2luc3RydW1lbnQuX2lkXT9cblxuICAgIG5vdGVzT24uZm9yRWFjaCAobm90ZSkgPT5cbiAgICAgIEBzdGF0ZVtpbnN0cnVtZW50Ll9pZF0ubm90ZXNbbm90ZS5rZXldID0ge3RpbWUsIGksIGxlbjogbm90ZS5sZW5ndGggLyBicHN9XG5cbiIsIk1vZGVsID0gcmVxdWlyZSAnLi9tb2RlbCdcblJpbmdCdWZmZXIgPSByZXF1aXJlICcuLi91dGlsL3JpbmdfYnVmZmVyJ1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIEluc3RydW1lbnQgZXh0ZW5kcyBNb2RlbFxuXG4gIEBzdGF0ZToge31cblxuICBAY3JlYXRlU3RhdGU6IChpbnN0cnVtZW50KSAtPlxuICAgIEBzdGF0ZVtpbnN0cnVtZW50Ll9pZF0gPVxuICAgICAgbm90ZXM6IG5ldyBSaW5nQnVmZmVyIGluc3RydW1lbnQubWF4UG9seXBob255LCBBcnJheSwgaW5zdHJ1bWVudC5wb2x5cGhvbnlcblxuICBAcmVsZWFzZVN0YXRlOiAoaW5zdHJ1bWVudCkgLT5cbiAgICBkZWxldGUgQHN0YXRlW2luc3RydW1lbnQuX2lkXVxuXG4gIEBzYW1wbGU6IChpbnN0cnVtZW50LCB0aW1lLCBpKSAtPlxuICAgIDBcblxuICBAdGljazogKGluc3RydW1lbnQsIHRpbWUsIGksIGJlYXQsIGJwcywgbm90ZXNPbikgLT5cbiAgICBAY3JlYXRlU3RhdGUgaW5zdHJ1bWVudCB1bmxlc3MgQHN0YXRlW2luc3RydW1lbnQuX2lkXT9cbiAgICBzdGF0ZSA9IEBzdGF0ZVtpbnN0cnVtZW50Ll9pZF1cblxuICAgIGlmIGluc3RydW1lbnQucG9seXBob255ICE9IHN0YXRlLm5vdGVzLmxlbmd0aFxuICAgICAgc3RhdGUubm90ZXMucmVzaXplIGluc3RydW1lbnQucG9seXBob255XG5cbiAgICBub3Rlc09uLmZvckVhY2ggKG5vdGUpID0+XG4gICAgICBzdGF0ZS5ub3Rlcy5wdXNoIHt0aW1lLCBpLCBrZXk6IG5vdGUua2V5LCBsZW46IG5vdGUubGVuZ3RoIC8gYnBzfVxuIiwiSW5zdHJ1bWVudCA9IHJlcXVpcmUgJy4vaW5zdHJ1bWVudCdcblJpbmdCdWZmZXIgPSByZXF1aXJlICcuLi91dGlsL3JpbmdfYnVmZmVyJ1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIExvb3BTYW1wbGVyIGV4dGVuZHMgSW5zdHJ1bWVudFxuXG4gIGRlZmF1bHRzOlxuICAgIGxldmVsOiAwLjVcbiAgICBwb2x5cGhvbnk6IDFcbiAgICBzbGljZXM6IFtdXG4iLCJkZWVwTWVyZ2UgPSByZXF1aXJlICcuLi91dGlsL2RlZXBfbWVyZ2UnXG5jdWlkID0gcmVxdWlyZSAnY3VpZCdcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIE1vZGVsXG5cbiAgIyBkZWZhdWx0IGF0dHJpYnV0ZXNcbiAgQGRlZmF1bHRzOiB7fVxuXG4gIEBidWlsZDogKGRhdGEgPSB7fSkgLT5cbiAgICBkYXRhLl9pZCA9IGN1aWQoKSB1bmxlc3MgZGF0YS5faWQ/XG5cbiAgICBkZWZhdWx0cyA9XG4gICAgICBpZiB0eXBlb2YgQGRlZmF1bHRzIGlzICdmdW5jdGlvbidcbiAgICAgIHRoZW4gQGRlZmF1bHRzKClcbiAgICAgIGVsc2UgQGRlZmF1bHRzXG5cbiAgICBkZWVwTWVyZ2UgZGVmYXVsdHMsIGRhdGFcbiIsIk1vZGVsID0gcmVxdWlyZSAnLi9tb2RlbCdcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBTZXF1ZW5jZSBleHRlbmRzIE1vZGVsXG5cbiAgQGRlZmF1bHRzOlxuICAgIGxvb3BTaXplOiA0XG4gICAgbm90ZXM6IHt9XG5cbiAgQG5vdGVzT246IChzZXF1ZW5jZSwgYmVhdCwgbGFzdEJlYXQpIC0+XG4gICAgYmFyID0gTWF0aC5mbG9vciBiZWF0IC8gc2VxdWVuY2UubG9vcFNpemVcbiAgICBsYXN0QmFyID0gTWF0aC5mbG9vciBsYXN0QmVhdCAvIHNlcXVlbmNlLmxvb3BTaXplXG4gICAgYmVhdCA9IGJlYXQgJSBzZXF1ZW5jZS5sb29wU2l6ZVxuICAgIGxhc3RCZWF0ID0gbGFzdEJlYXQgJSBzZXF1ZW5jZS5sb29wU2l6ZVxuXG4gICAgcmVzdWx0ID0gW11cbiAgICBmb3IgaWQsIG5vdGUgb2Ygc2VxdWVuY2Uubm90ZXNcbiAgICAgIGlmIG5vdGUuc3RhcnQgPCBiZWF0IGFuZCAobm90ZS5zdGFydCA+PSBsYXN0QmVhdCBvciBiYXIgPiBsYXN0QmFyKVxuICAgICAgICByZXN1bHQucHVzaCBub3RlXG5cbiAgICByZXN1bHQiLCJ3ZWJhdWRpbyA9IHJlcXVpcmUgJy4uL2RzcC93ZWJhdWRpbydcbndpbmRvdy5jb250ZXh0ID0gcmVxdWlyZSAnLi4vZHNwL2dsb2JhbF9jb250ZXh0J1xuVHJhY2sgPSByZXF1aXJlICcuL3RyYWNrJ1xuXG4jIHRoZXJlIGFyZSB0aHJlZSB0aW1lIHNjYWxlcyB0aGF0IHdlIGFyZSBjb25jZXJuZWQgd2l0aFxuI1xuIyAtIHNhbXBsZSByYXRlXG4jIHJ1bnMgYXQgNDQxMDAgaHosIG9uY2UgZm9yIGVhY2ggc2FtcGxlIG9mIGF1ZGlvIHdlIG91dHB1dC4gIEFueSBjb2RlIHJ1bm5pbmdcbiMgYXQgdGhpcyByYXRlIGhhcyBhIGhpZ2ggY29zdCwgc28gcGVyZm9ybWFuY2UgaXMgaW1wb3J0YW50IGhlcmVcbiNcbiMgLSB0aWNrIHJhdGVcbiMgVGlja3MgcnVuIGV2ZXJ5IG4gc2FtcGxlcywgZGVmaW5lZCB1c2luZyB0aGUgY2xvY2tSYXRpbyB2YXJpYWJsZS4gIFRoaXNcbiMgYWxsb3dzIHVzIHRvIGRvIHByb2Nlc3NpbmcgdGhhdCBuZWVkcyB0byBydW4gZnJlcXVlbnRseSwgYnV0IGlzIHRvbyBleHBlbnNpdmVcbiMgdG8gcnVuIGZvciBlYWNoIHNtYXBsZS4gIEZvciBleGFtcGxlLCB0aGlzIGlzIHRoZSB0aW1lIHJlc29sdXRpb24gYXQgd2hpY2hcbiMgd2UgdHJpZ2dlciBuZXcgbm90ZXMuXG4jXG4jIC0gZnJhbWUgcmF0ZVxuIyBUaGUgZnJhbWUgcmF0ZSBpcyB0aGUgc3BlZWQgYXQgd2hpY2ggd2UgdHJpZ2dlciBHVUkgdXBkYXRlcyBmb3IgdGhpbmdzIGxpa2VcbiMgbGV2ZWwgbWV0ZXJzIGFuZCBwbGF5YmFjayBwb3NpdGlvbi5cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBTb25nXG5cbiAgIyBudW1iZXIgb2Ygc2FtcGxlcyB0byBwcm9jZXNzIGJldHdlZW4gdGlja3NcbiAgY2xvY2tSYXRpbyA9IDUwXG5cbiAgIyByYXRlIGF0IHdoaWNoIGxldmVsIG1ldGVycyBkZWNheVxuICBtZXRlckRlY2F5ID0gMC4wNVxuXG4gIGNsaXAgPSAoc2FtcGxlKSAtPlxuICAgIE1hdGgubWF4KDAsIE1hdGgubWluKDIsIHNhbXBsZSArIDEpKSAtIDFcblxuICBjb25zdHJ1Y3RvcjogLT5cbiAgICBAYXVkaW8gPSB3ZWJhdWRpbyBjb250ZXh0LCBAc2FtcGxlXG4gICAgQGxhc3RCZWF0ID0gMFxuXG4gICAgIyBzdGFydCBjYWxsaW5nIEBmcmFtZSBmb3IgZXZlcnkgdWkgZnJhbWVcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgQGZyYW1lXG5cbiAgdXBkYXRlOiAoY3Vyc29yKSAtPlxuICAgIEBjdXJzb3IgPSBjdXJzb3JcbiAgICBAZGF0YSA9IGN1cnNvci5nZXQoKVxuXG4gIHBsYXk6ID0+XG4gICAgQGF1ZGlvLnBsYXkoKVxuICAgIEBjdXJzb3Iuc2V0ICdwbGF5aW5nJywgdHJ1ZVxuXG4gIHBhdXNlOiA9PlxuICAgIEBhdWRpby5zdG9wKClcbiAgICBAY3Vyc29yLnNldCAncGxheWluZycsIGZhbHNlXG5cbiAgc3RvcDogPT5cbiAgICBAYXVkaW8uc3RvcCgpXG4gICAgQGF1ZGlvLnJlc2V0KClcbiAgICBAY3Vyc29yLmJhdGNoZWQgPT5cbiAgICAgIEBjdXJzb3Iuc2V0ICdwbGF5aW5nJywgZmFsc2VcbiAgICAgIEBjdXJzb3Iuc2V0ICdwb3NpdGlvbicsIDBcblxuICBzZWVrOiAoYmVhdCkgLT5cbiAgICBAY3Vyc29yLnNldCAncG9zaXRpb24nLCBiZWF0XG4gICAgQGF1ZGlvLnNlZWsgYmVhdCAqIDYwIC8gQGRhdGEuYnBtXG5cbiAgIyBjYWxsZWQgZm9yIGV2ZXJ5IHNhbXBsZSBvZiBhdWRpb1xuICBzYW1wbGU6ICh0aW1lLCBpKSA9PlxuICAgIHJldHVybiAwIHVubGVzcyBAZGF0YT8ucGxheWluZ1xuXG4gICAgQHRpY2sgdGltZSwgaSBpZiBpICUgY2xvY2tSYXRpbyBpcyAwXG5cbiAgICBjbGlwIEBkYXRhLnRyYWNrcy5yZWR1Y2UoKG1lbW8sIHRyYWNrKSAtPlxuICAgICAgbWVtbyArIFRyYWNrLnNhbXBsZSB0cmFjaywgdGltZSwgaVxuICAgICwgMClcblxuICAjIGNhbGxlZCBmb3IgZXZlcnkgY2xvY2tSYXRpbyBzYW1wbGVzXG4gIHRpY2s6ICh0aW1lLCBpKSAtPlxuICAgIGJwcyA9IEBkYXRhLmJwbSAvIDYwXG4gICAgYmVhdCA9IHRpbWUgKiBicHNcblxuICAgIEBkYXRhLnRyYWNrcy5mb3JFYWNoICh0cmFjaykgPT5cbiAgICAgIFRyYWNrLnRpY2sgdHJhY2ssIHRpbWUsIGksIGJlYXQsIEBsYXN0QmVhdCwgYnBzXG5cbiAgICBAbGFzdEJlYXQgPSBiZWF0XG5cbiAgIyBjYWxsZWQgZm9yIGV2ZXJ5IHVpIGFuaW1hdGlvbiBmcmFtZVxuICBmcmFtZTogPT5cbiAgICBAY3Vyc29yLmJhdGNoZWQgPT5cbiAgICAgIGZvciB0cmFja0luZGV4LCB0cmFjayBvZiBAZGF0YS50cmFja3NcbiAgICAgICAgbWV0ZXJMZXZlbCA9IFRyYWNrLm1ldGVyTGV2ZWxzW3RyYWNrLl9pZF0gb3IgMFxuICAgICAgICBAY3Vyc29yLnNldCBbJ3RyYWNrcycsIHRyYWNrSW5kZXgsICdtZXRlckxldmVsJ10sIChtZXRlckxldmVsIHx8IDApXG5cbiAgICAgIEBjdXJzb3Iuc2V0ICdwb3NpdGlvbicsIEBhdWRpby5nZXRUaW1lKCkgKiBAZGF0YS5icG0gLyA2MFxuXG5cbiAgICBmb3IgaWQsIGxldmVsIG9mIFRyYWNrLm1ldGVyTGV2ZWxzXG4gICAgICBUcmFjay5tZXRlckxldmVsc1tpZF0gPSBsZXZlbCAtIG1ldGVyRGVjYXlcbiAgICAgIGRlbGV0ZSBUcmFjay5tZXRlckxldmVsc1tpZF0gaWYgVHJhY2subWV0ZXJMZXZlbHNbaWRdIDwgMFxuXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIEBmcmFtZVxuIiwiTW9kZWwgPSByZXF1aXJlICcuL21vZGVsJ1xuU2VxdWVuY2UgPSByZXF1aXJlICcuL3NlcXVlbmNlJ1xubG9nU2FtcGxlID0gcmVxdWlyZSAnLi4vdXRpbC9sb2dfc2FtcGxlJ1xuXG5pbnN0cnVtZW50VHlwZXMgPVxuICBBbmFsb2dTeW50aGVzaXplcjogcmVxdWlyZSAnLi9hbmFsb2dfc3ludGhlc2l6ZXInXG4gIEJhc2ljU2FtcGxlcjogcmVxdWlyZSAnLi9iYXNpY19zYW1wbGVyJ1xuICBEcnVtU2FtcGxlcjogcmVxdWlyZSAnLi9kcnVtX3NhbXBsZXInXG4gIERydW1TeW50aGVzaXplcjogcmVxdWlyZSAnLi9kcnVtX3N5bnRoZXNpemVyJ1xuICBMb29wU2FtcGxlcjogcmVxdWlyZSAnLi9sb29wX3NhbXBsZXInXG5cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBUcmFjayBleHRlbmRzIE1vZGVsXG5cbiAgQGRlZmF1bHRzOiAtPlxuICAgIG5hbWU6ICdUcmFjaydcbiAgICBtZXRlckxldmVsOiAwXG4gICAgc2VxdWVuY2U6IFNlcXVlbmNlLmJ1aWxkKClcbiAgICBlZmZlY3RzOiBbXVxuXG4gICMga2VlcCBtZXRlciBsZXZlbHMgaGVyZSAtIHRoaXMgd2lsbCBiZSBhIG1hcCB0cmFja0lkOiBsZXZlbFxuICAjIHRoaXMgbmVlZHMgdG8gc3RheSBvdXRzaWRlIHRoZSBub3JtYWwgY3Vyc29yIHN0cnVjdHVyZSBmb3IgcGVyZm9ybWFuY2VcbiAgIyByZWFzb25zIGJlY2F1c2UgbGV2ZWxzIGFyZSB1cGRhdGVkIG9uIGV2ZXJ5IHNhbXBsZVxuICBAbWV0ZXJMZXZlbHM6IHt9XG5cbiAgQHNhbXBsZTogKHRyYWNrLCB0aW1lLCBpKSAtPlxuICAgICMgZ2V0IGluc3RydW1lbnQgb3V0cHV0XG4gICAgSW5zdHJ1bWVudCA9IGluc3RydW1lbnRUeXBlc1t0cmFjay5pbnN0cnVtZW50Ll90eXBlXVxuICAgIHNhbXBsZSA9IEluc3RydW1lbnQuc2FtcGxlIHRyYWNrLmluc3RydW1lbnQsIHRpbWUsIGlcblxuICAgICMgYXBwbHkgZWZmZWN0c1xuICAgIHNhbXBsZSA9IHRyYWNrLmVmZmVjdHMucmVkdWNlKChzYW1wbGUsIGVmZmVjdCkgLT5cbiAgICAgIEVmZmVjdC5zYW1wbGUgZWZmZWN0LCB0aW1lLCBpLCBzYW1wbGVcbiAgICAsIHNhbXBsZSlcblxuICAgICMgdXBkYXRlIG1ldGVyIGxldmVsc1xuICAgIGlkID0gdHJhY2suX2lkXG4gICAgaWYgbm90IEBtZXRlckxldmVsc1tpZF0/IG9yIGlzTmFOKEBtZXRlckxldmVsc1tpZF0pIG9yIHNhbXBsZSA+IEBtZXRlckxldmVsc1tpZF1cbiAgICAgIEBtZXRlckxldmVsc1tpZF0gPSBzYW1wbGVcblxuICAgIHNhbXBsZVxuXG4gIEB0aWNrOiAodHJhY2ssIHRpbWUsIGksIGJlYXQsIGxhc3RCZWF0LCBicHMpIC0+XG4gICAgSW5zdHJ1bWVudCA9IGluc3RydW1lbnRUeXBlc1t0cmFjay5pbnN0cnVtZW50Ll90eXBlXVxuICAgIG5vdGVzT24gPSBTZXF1ZW5jZS5ub3Rlc09uIHRyYWNrLnNlcXVlbmNlLCBiZWF0LCBsYXN0QmVhdFxuICAgIEluc3RydW1lbnQudGljayB0cmFjay5pbnN0cnVtZW50LCB0aW1lLCBpLCBiZWF0LCBicHMsIG5vdGVzT25cbiAgICB0cmFjay5lZmZlY3RzLmZvckVhY2ggKGUpIC0+IGUudGljayB0aW1lLCBiZWF0LCBicHNcbiIsIiMgc29tZSBiYXNpYyBzZXF1ZW5jZXMgZm9yIGVhc3kgdXNlIGluIGRldmVsb3BtZW50IC8gdGVzdGluZ1xuXG5tb2R1bGUuZXhwb3J0cyA9XG5cbiAgZm91cmZvdXI6XG4gICAgMDoge2lkOiAnMCcsIGtleTogMCwgc3RhcnQ6IDAsIGxlbmd0aDogMS80fVxuICAgIDE6IHtpZDogJzEnLCBrZXk6IDAsIHN0YXJ0OiAxLCBsZW5ndGg6IDEvNH1cbiAgICAyOiB7aWQ6ICcyJywga2V5OiAwLCBzdGFydDogMiwgbGVuZ3RoOiAxLzR9XG4gICAgMzoge2lkOiAnMycsIGtleTogMCwgc3RhcnQ6IDMsIGxlbmd0aDogMS80fVxuXG4gIGJlYXQ6XG4gICAgMDoge2lkOiAnMCcsIGtleTogMCwgc3RhcnQ6IDAsIGxlbmd0aDogMS80fVxuICAgIDE6IHtpZDogJzEnLCBrZXk6IDAsIHN0YXJ0OiAxLCBsZW5ndGg6IDEvNH1cbiAgICAyOiB7aWQ6ICcyJywga2V5OiAwLCBzdGFydDogMiwgbGVuZ3RoOiAxLzR9XG4gICAgMzoge2lkOiAnMycsIGtleTogMCwgc3RhcnQ6IDMsIGxlbmd0aDogMS80fVxuICAgIDQ6IHtpZDogJzQnLCBrZXk6IDIsIHN0YXJ0OiAxLzIsIGxlbmd0aDogMS80fVxuICAgIDU6IHtpZDogJzUnLCBrZXk6IDIsIHN0YXJ0OiAzLzIsIGxlbmd0aDogMS80fVxuICAgIDY6IHtpZDogJzYnLCBrZXk6IDIsIHN0YXJ0OiA1LzIsIGxlbmd0aDogMS80fVxuICAgIDc6IHtpZDogJzcnLCBrZXk6IDIsIHN0YXJ0OiA3LzIsIGxlbmd0aDogMS80fVxuICAgIDg6IHtpZDogJzgnLCBrZXk6IDEsIHN0YXJ0OiAxLCBsZW5ndGg6IDEvNH1cbiAgICA5OiB7aWQ6ICc5Jywga2V5OiAxLCBzdGFydDogMywgbGVuZ3RoOiAxLzR9XG5cbiAgY2hvcmRzOlxuICAgIDA6IHtpZDogJzAnLCBrZXk6IDYwLCBzdGFydDogMCwgbGVuZ3RoOiAxLzR9XG4gICAgMToge2lkOiAnMScsIGtleTogNjMsIHN0YXJ0OiAwLCBsZW5ndGg6IDEvNH1cbiAgICAyOiB7aWQ6ICcyJywga2V5OiA2Nywgc3RhcnQ6IDAsIGxlbmd0aDogMS80fVxuICAgIDM6IHtpZDogJzMnLCBrZXk6IDYwLCBzdGFydDogMS8yLCBsZW5ndGg6IDEvNH1cbiAgICA0OiB7aWQ6ICc0Jywga2V5OiA2Mywgc3RhcnQ6IDEvMiwgbGVuZ3RoOiAxLzR9XG4gICAgNToge2lkOiAnNScsIGtleTogNjcsIHN0YXJ0OiAxLzIsIGxlbmd0aDogMS80fVxuXG4gIHNpbXBsZTpcbiAgICAwOiB7aWQ6ICcwJywga2V5OiA2MCwgc3RhcnQ6IDAsIGxlbmd0aDogMS80fVxuICAgIDE6IHtpZDogJzEnLCBrZXk6IDYzLCBzdGFydDogMS8yLCBsZW5ndGg6IDEvNH1cbiAgICAyOiB7aWQ6ICcyJywga2V5OiA2Nywgc3RhcnQ6IDIvMiwgbGVuZ3RoOiAxLzR9XG4gICAgMzoge2lkOiAnMycsIGtleTogNjMsIHN0YXJ0OiAzLzIsIGxlbmd0aDogMS80fVxuICAgIDQ6IHtpZDogJzQnLCBrZXk6IDYwLCBzdGFydDogNC8yLCBsZW5ndGg6IDEvNH1cbiAgICA1OiB7aWQ6ICc1Jywga2V5OiA2NSwgc3RhcnQ6IDUvMiwgbGVuZ3RoOiAxLzR9XG4gICAgNjoge2lkOiAnNicsIGtleTogNzAsIHN0YXJ0OiA2LzIsIGxlbmd0aDogMS80fVxuICAgIDc6IHtpZDogJzcnLCBrZXk6IDY1LCBzdGFydDogNy8yLCBsZW5ndGg6IDEvNH1cblxuICBiYXNzOlxuICAgIDA6IHtpZDogJzAnLCBrZXk6IDQ4LCBzdGFydDogMi80LCBsZW5ndGg6IDEvNH1cbiAgICAxOiB7aWQ6ICcxJywga2V5OiA0OCwgc3RhcnQ6IDMvNCwgbGVuZ3RoOiAxLzR9XG4gICAgMjoge2lkOiAnMicsIGtleTogNDgsIHN0YXJ0OiA2LzQsIGxlbmd0aDogMS80fVxuICAgIDM6IHtpZDogJzMnLCBrZXk6IDQ4LCBzdGFydDogNy80LCBsZW5ndGg6IDEvNH1cbiAgICA0OiB7aWQ6ICc0Jywga2V5OiA1MCwgc3RhcnQ6IDEwLzQsIGxlbmd0aDogMS80fVxuICAgIDU6IHtpZDogJzUnLCBrZXk6IDUwLCBzdGFydDogMTEvNCwgbGVuZ3RoOiAxLzR9XG4gICAgNjoge2lkOiAnNicsIGtleTogNTEsIHN0YXJ0OiAxNC80LCBsZW5ndGg6IDEvNH1cbiAgICA3OiB7aWQ6ICc3Jywga2V5OiA1MSwgc3RhcnQ6IDE1LzQsIGxlbmd0aDogMS80fVxuXG4gIHRlcmplOlxuICAgIDA6IHtpZDogJzAnLCBrZXk6IDQ1LCBzdGFydDogMC80LCBsZW5ndGg6IDEvNH1cbiAgICAxOiB7aWQ6ICcxJywga2V5OiA2Miwgc3RhcnQ6IDEvNCwgbGVuZ3RoOiAxLzR9XG4gICAgMjoge2lkOiAnMicsIGtleTogNTcsIHN0YXJ0OiAyLzQsIGxlbmd0aDogMS80fVxuICAgIDM6IHtpZDogJzMnLCBrZXk6IDc0LCBzdGFydDogMy80LCBsZW5ndGg6IDEvNH1cbiAgICA0OiB7aWQ6ICc0Jywga2V5OiA0NSwgc3RhcnQ6IDQvNCwgbGVuZ3RoOiAxLzR9XG4gICAgNToge2lkOiAnNScsIGtleTogNjIsIHN0YXJ0OiA1LzQsIGxlbmd0aDogMS80fVxuICAgIDY6IHtpZDogJzYnLCBrZXk6IDU3LCBzdGFydDogNi80LCBsZW5ndGg6IDEvNH1cbiAgICA3OiB7aWQ6ICc3Jywga2V5OiA3NCwgc3RhcnQ6IDcvNCwgbGVuZ3RoOiAxLzR9XG4gICAgODoge2lkOiAnOCcsIGtleTogNDUsIHN0YXJ0OiA4LzQsIGxlbmd0aDogMS80fVxuICAgIDk6IHtpZDogJzknLCBrZXk6IDY0LCBzdGFydDogOS80LCBsZW5ndGg6IDEvNH1cbiAgICAxMDoge2lkOiAnMTAnLCBrZXk6IDU3LCBzdGFydDogMTAvNCwgbGVuZ3RoOiAxLzR9XG4gICAgMTE6IHtpZDogJzExJywga2V5OiA3Niwgc3RhcnQ6IDExLzQsIGxlbmd0aDogMS80fVxuICAgIDEyOiB7aWQ6ICcxMicsIGtleTogNDUsIHN0YXJ0OiAxMi80LCBsZW5ndGg6IDEvNH1cbiAgICAxMzoge2lkOiAnMTMnLCBrZXk6IDY3LCBzdGFydDogMTMvNCwgbGVuZ3RoOiAxLzR9XG4gICAgMTQ6IHtpZDogJzE0Jywga2V5OiA1Nywgc3RhcnQ6IDE0LzQsIGxlbmd0aDogMS80fVxuICAgIDE1OiB7aWQ6ICcxNScsIGtleTogNzksIHN0YXJ0OiAxNS80LCBsZW5ndGg6IDEvNH1cbiAgICAxNjoge2lkOiAnMTYnLCBrZXk6IDQ3LCBzdGFydDogMTYvNCwgbGVuZ3RoOiAxLzR9XG4gICAgMTc6IHtpZDogJzE3Jywga2V5OiA2NCwgc3RhcnQ6IDE3LzQsIGxlbmd0aDogMS80fVxuICAgIDE4OiB7aWQ6ICcxOCcsIGtleTogNTksIHN0YXJ0OiAxOC80LCBsZW5ndGg6IDEvNH1cbiAgICAxOToge2lkOiAnMTknLCBrZXk6IDc2LCBzdGFydDogMTkvNCwgbGVuZ3RoOiAxLzR9XG4gICAgMjA6IHtpZDogJzIwJywga2V5OiA0Nywgc3RhcnQ6IDIwLzQsIGxlbmd0aDogMS80fVxuICAgIDIxOiB7aWQ6ICcyMScsIGtleTogNjcsIHN0YXJ0OiAyMS80LCBsZW5ndGg6IDEvNH1cbiAgICAyMjoge2lkOiAnMjInLCBrZXk6IDU5LCBzdGFydDogMjIvNCwgbGVuZ3RoOiAxLzR9XG4gICAgMjM6IHtpZDogJzIzJywga2V5OiA3OSwgc3RhcnQ6IDIzLzQsIGxlbmd0aDogMS80fVxuICAgIDI0OiB7aWQ6ICcyNCcsIGtleTogNDgsIHN0YXJ0OiAyNC80LCBsZW5ndGg6IDEvNH1cbiAgICAyNToge2lkOiAnMjUnLCBrZXk6IDY5LCBzdGFydDogMjUvNCwgbGVuZ3RoOiAxLzR9XG4gICAgMjY6IHtpZDogJzI2Jywga2V5OiA2MCwgc3RhcnQ6IDI2LzQsIGxlbmd0aDogMS80fVxuICAgIDI3OiB7aWQ6ICcyNycsIGtleTogODEsIHN0YXJ0OiAyNy80LCBsZW5ndGg6IDEvNH1cbiAgICAyODoge2lkOiAnMjgnLCBrZXk6IDQ4LCBzdGFydDogMjgvNCwgbGVuZ3RoOiAxLzR9XG4gICAgMjk6IHtpZDogJzI5Jywga2V5OiA2Nywgc3RhcnQ6IDI5LzQsIGxlbmd0aDogMS80fVxuICAgIDMwOiB7aWQ6ICczMCcsIGtleTogNjAsIHN0YXJ0OiAzMC80LCBsZW5ndGg6IDEvNH1cbiAgICAzMToge2lkOiAnMzEnLCBrZXk6IDc5LCBzdGFydDogMzEvNCwgbGVuZ3RoOiAxLzR9XG4iLCIjIFVJIGZvciB0aGUgYW5hbG9nIHN5bnRoZXNpemVyIGluc3RydW1lbnRcblxuUmVhY3QgPSByZXF1aXJlICdyZWFjdCdcblNsaWRlciA9IHJlcXVpcmUgJy4vc2xpZGVyJ1xuRW52ZWxvcGUgPSByZXF1aXJlICcuL2VudmVsb3BlJ1xuRmlsdGVyID0gcmVxdWlyZSAnLi9maWx0ZXInXG5Pc2NpbGxhdG9yID0gcmVxdWlyZSAnLi9vc2NpbGxhdG9yJ1xuXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3QuY3JlYXRlQ2xhc3NcblxuICByZW5kZXI6IC0+XG4gICAgaW5zdHJ1bWVudCA9IEBwcm9wcy5pbnN0cnVtZW50XG5cbiAgICBvcHRpb25zID0gZm9yIGkgaW4gWzEuLjZdXG4gICAgICBSZWFjdC5ET00ub3B0aW9uKHtcImtleVwiOiAoaSksIFwidmFsdWVcIjogKGkpfSwgKGkpKVxuXG4gICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJ1aSBhbmFsb2dcIn0sIFxuICAgICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJjb2x1bW4gY2hhbm5lbFwifSwgXG4gICAgICAgIFNsaWRlcih7IFxcXG4gICAgICAgICAgXCJsYWJlbFwiOiBcIkxldmVsXCIsICBcXFxuICAgICAgICAgIFwidmFsdWVcIjogKGluc3RydW1lbnQuZ2V0ICdsZXZlbCcpLCAgXFxcbiAgICAgICAgICBcIm9uQ2hhbmdlXCI6IChpbnN0cnVtZW50LmJpbmQgJ2xldmVsJylcbiAgICAgICAgfSksIFxuICAgICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcInVpXCJ9LCBcbiAgICAgICAgICBSZWFjdC5ET00uc2VsZWN0KHsgXFxcbiAgICAgICAgICAgIFwib25DaGFuZ2VcIjogKGluc3RydW1lbnQuYmluZCAncG9seXBob255JywgKGUpIC0+IHBhcnNlSW50IGUudGFyZ2V0LnZhbHVlKSwgIFxcXG4gICAgICAgICAgICBcInZhbHVlXCI6IChpbnN0cnVtZW50LmdldCAncG9seXBob255JylcbiAgICAgICAgICB9LCBcbiAgICAgICAgICAgIChvcHRpb25zKVxuICAgICAgICAgICksIFxuICAgICAgICAgIFJlYWN0LkRPTS5sYWJlbChudWxsLCBcIlBvbHlcIilcbiAgICAgICAgKVxuICAgICAgKSwgXG4gICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcImNvbHVtblwifSwgXG4gICAgICAgIEVudmVsb3BlKHsgXFxcbiAgICAgICAgICBcImxhYmVsXCI6IFwiVm9sdW1lIEVudlwiLCAgXFxcbiAgICAgICAgICBcImVudlwiOiAoaW5zdHJ1bWVudC5jdXJzb3IgJ3ZvbHVtZUVudicpXG4gICAgICAgIH0pXG4gICAgICApLCBcbiAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwiY29sdW1uXCJ9LCBcbiAgICAgICAgRW52ZWxvcGUoeyBcXFxuICAgICAgICAgIFwibGFiZWxcIjogXCJGaWx0ZXIgRW52XCIsICBcXFxuICAgICAgICAgIFwiZW52XCI6IChpbnN0cnVtZW50LmN1cnNvciAnZmlsdGVyRW52JylcbiAgICAgICAgfSlcbiAgICAgICksIFxuICAgICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJjb2x1bW4gb3NjaWxsYXRvcnNcIn0sIFxuICAgICAgICBGaWx0ZXIoeyBcXFxuICAgICAgICAgIFwibGFiZWxcIjogXCJGaWx0ZXJcIiwgIFxcXG4gICAgICAgICAgXCJmaWx0ZXJcIjogKGluc3RydW1lbnQuY3Vyc29yICdmaWx0ZXInKVxuICAgICAgICB9KSwgXG4gICAgICAgIE9zY2lsbGF0b3IoeyBcXFxuICAgICAgICAgIFwibGFiZWxcIjogXCJPc2MgMVwiLCAgXFxcbiAgICAgICAgICBcIm9zY1wiOiAoaW5zdHJ1bWVudC5jdXJzb3IgJ29zYzEnKVxuICAgICAgICB9KSwgXG4gICAgICAgIE9zY2lsbGF0b3IoeyBcXFxuICAgICAgICAgIFwibGFiZWxcIjogXCJPc2MgMlwiLCAgXFxcbiAgICAgICAgICBcIm9zY1wiOiAoaW5zdHJ1bWVudC5jdXJzb3IgJ29zYzInKVxuICAgICAgICB9KVxuICAgICAgKVxuICAgIClcbiIsIiMgdGhpcyBpcyB0aGUgdG9wIGxldmVsIHJlYWN0IGNvbXBvbmVudCAtIGl0IGhhbmRsZXMgd2luZG93IGxheW91dCwgdHJhY2tcbiMgc2VsZWN0aW9uLCBhbmQgbW9kYWwgc3RhdGUuICBJdCBleHBlY3RzIG9ubHkgb25lIHByb3AsICdkYXRhJywgYSByb290IGN1cnNvclxuIyB0byBhIHNvbmcgb2JqZWN0LlxuXG5SZWFjdCA9IHJlcXVpcmUgJ3JlYWN0L2FkZG9ucydcblBsYXliYWNrQ29udHJvbCA9IHJlcXVpcmUgJy4vcGxheWJhY2tfY29udHJvbCdcblRyYWNrU2VsZWN0aW9uID0gcmVxdWlyZSAnLi90cmFja19zZWxlY3Rpb24nXG5QaWFub1JvbGwgPSByZXF1aXJlICcuL3BpYW5vX3JvbGwnXG5CYXNpY1NhbXBsZXJDb250cm9sID0gcmVxdWlyZSAnLi9iYXNpY19zYW1wbGVyX2NvbnRyb2wnXG5BbmFsb2dTeW50aGVzaXplckNvbnRyb2wgPSByZXF1aXJlICcuL2FuYWxvZ19zeW50aGVzaXplcl9jb250cm9sJ1xuRHJ1bVN5bnRoZXNpemVyQ29udHJvbCA9IHJlcXVpcmUgJy4vZHJ1bV9zeW50aGVzaXplcl9jb250cm9sJ1xuRHJ1bVNhbXBsZXJDb250cm9sID0gcmVxdWlyZSAnLi9kcnVtX3NhbXBsZXJfY29udHJvbCdcbkxvb3BTYW1wbGVyQ29udHJvbCA9IHJlcXVpcmUgJy4vbG9vcF9zYW1wbGVyX2NvbnRyb2wnXG5Nb2RhbCA9IHJlcXVpcmUgJy4vbW9kYWwnXG5LZXlib2FyZEludGVyYWN0aW9uID0gcmVxdWlyZSAnLi9taXhpbnMva2V5Ym9hcmRfaW50ZXJhY3Rpb24nXG5SZWFjdENTU1RyYW5zaXRpb25Hcm91cCA9IFJlYWN0LmFkZG9ucy5DU1NUcmFuc2l0aW9uR3JvdXBcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdC5jcmVhdGVDbGFzc1xuXG4gIG1peGluczogW1xuICAgIEtleWJvYXJkSW50ZXJhY3Rpb25cbiAgXVxuXG4gIHByb3BUeXBlczpcbiAgICBkYXRhOiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWRcblxuICBnZXRJbml0aWFsU3RhdGU6IC0+XG4gICAgc2VsZWN0ZWRUcmFjazogMFxuICAgIG1vZGFsQ29udGVudDogbnVsbFxuXG4gIGxhdW5jaE1vZGFsOiAobW9kYWxDb250ZW50KSAtPlxuICAgIEBwcm9wcy5kYXRhLnNldCAncGxheWluZycsIGZhbHNlXG4gICAgQHNldFN0YXRlIHttb2RhbENvbnRlbnR9XG5cbiAgZGlzbWlzc01vZGFsOiAtPlxuICAgIEBzZXRTdGF0ZSBtb2RhbENvbnRlbnQ6IG51bGxcblxuICByZW5kZXI6IC0+XG4gICAgdHJhY2sgPSBAcHJvcHMuZGF0YS5jdXJzb3IgWyd0cmFja3MnLCBAc3RhdGUuc2VsZWN0ZWRUcmFja11cblxuICAgIGlmIHRyYWNrXG4gICAgICBzZXF1ZW5jZSA9IHRyYWNrLmN1cnNvciAnc2VxdWVuY2UnXG4gICAgICBpbnN0cnVtZW50ID0gdHJhY2suY3Vyc29yICdpbnN0cnVtZW50J1xuXG4gICAgICBjb250cm9sQ2xhc3MgPSBzd2l0Y2ggaW5zdHJ1bWVudC5nZXQgJ190eXBlJ1xuICAgICAgICB3aGVuICdCYXNpY1NhbXBsZXInIHRoZW4gQmFzaWNTYW1wbGVyQ29udHJvbFxuICAgICAgICB3aGVuICdBbmFsb2dTeW50aGVzaXplcicgdGhlbiBBbmFsb2dTeW50aGVzaXplckNvbnRyb2xcbiAgICAgICAgd2hlbiAnRHJ1bVN5bnRoZXNpemVyJyB0aGVuIERydW1TeW50aGVzaXplckNvbnRyb2xcbiAgICAgICAgd2hlbiAnRHJ1bVNhbXBsZXInIHRoZW4gRHJ1bVNhbXBsZXJDb250cm9sXG4gICAgICAgIHdoZW4gJ0xvb3BTYW1wbGVyJyB0aGVuIExvb3BTYW1wbGVyQ29udHJvbFxuICAgICAgICBlbHNlIG51bGxcblxuICAgICAgaWYgY29udHJvbENsYXNzP1xuICAgICAgICBpbnN0cnVtZW50Q29udHJvbCA9XG4gICAgICAgICAgY29udHJvbENsYXNzKHsgXFxcbiAgICAgICAgICAgIFwia2V5XCI6ICh0cmFjay5nZXQgJ19pZCcpLCAgXFxcbiAgICAgICAgICAgIFwiaW5zdHJ1bWVudFwiOiAoaW5zdHJ1bWVudCksICBcXFxuICAgICAgICAgICAgXCJhcHBcIjogKHRoaXMpXG4gICAgICAgICAgfSlcblxuICAgIGlmIEBzdGF0ZS5tb2RhbENvbnRlbnQ/XG4gICAgICBtb2RhbCA9IE1vZGFsKHtcImtleVwiOiAnbSd9LCAoQHN0YXRlLm1vZGFsQ29udGVudCkpXG5cbiAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcImFwcFwifSwgXG4gICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcInJvdyBwbGF5YmFja1wifSwgXG4gICAgICAgIFBsYXliYWNrQ29udHJvbCh7XCJkYXRhXCI6IChAcHJvcHMuZGF0YSksIFwic29uZ1wiOiAoQHByb3BzLnNvbmcpfSlcbiAgICAgICksIFxuICAgICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJyb3cgbWFpblwifSwgXG4gICAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwiY29sdW1uIHNpZGViYXJcIn0sIFxuICAgICAgICAgIFRyYWNrU2VsZWN0aW9uKHsgXFxcbiAgICAgICAgICAgIFwidHJhY2tzXCI6IChAcHJvcHMuZGF0YS5jdXJzb3IgJ3RyYWNrcycpLCAgXFxcbiAgICAgICAgICAgIFwic2VsZWN0ZWRUcmFja1wiOiAoQHN0YXRlLnNlbGVjdGVkVHJhY2spLCAgXFxcbiAgICAgICAgICAgIFwic2VsZWN0VHJhY2tcIjogKCh2KSA9PiBAc2V0U3RhdGUgc2VsZWN0ZWRUcmFjazogcGFyc2VJbnQgdilcbiAgICAgICAgICB9KVxuICAgICAgICApLCBcbiAgICAgICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJjb2x1bW4gbWFpblwifSwgXG4gICAgICAgICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJyb3cgc2VxdWVuY2VcIn0sIFxuICAgICAgICAgICAgUGlhbm9Sb2xsKHsgXFxcbiAgICAgICAgICAgICAgXCJkYXRhXCI6IChAcHJvcHMuZGF0YSksICBcXFxuICAgICAgICAgICAgICBcInNvbmdcIjogKEBwcm9wcy5zb25nKSwgIFxcXG4gICAgICAgICAgICAgIFwic2VxdWVuY2VcIjogKHNlcXVlbmNlKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApLCBcbiAgICAgICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcInJvdyBpbnN0cnVtZW50XCJ9LCBcbiAgICAgICAgICAgIChpbnN0cnVtZW50Q29udHJvbClcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgICksIFxuICAgICAgUmVhY3RDU1NUcmFuc2l0aW9uR3JvdXAoe1widHJhbnNpdGlvbk5hbWVcIjogXCJtb2RhbFwifSwgXG4gICAgICAgIChtb2RhbClcbiAgICAgIClcbiAgICApXG4iLCIjIFVJIGZvciB0aGUgYmFzaWMgc2FtcGxlciBpbnN0cnVtZW50XG5cblJlYWN0ID0gcmVxdWlyZSAncmVhY3QvYWRkb25zJ1xuS25vYiA9IHJlcXVpcmUgJy4va25vYidcbkNob29zZXIgPSByZXF1aXJlICcuL2Nob29zZXInXG5TbGlkZXIgPSByZXF1aXJlICcuL3NsaWRlcidcblNhbXBsZUNvbnRyb2wgPSByZXF1aXJlICcuL3NhbXBsZV9jb250cm9sJ1xuRW52ZWxvcGUgPSByZXF1aXJlICcuL2VudmVsb3BlJ1xuRmlsdGVyID0gcmVxdWlyZSAnLi9maWx0ZXInXG5rZXlPcHRpb25zID0gcmVxdWlyZSAnLi4vdXRpbC9rZXlfb3B0aW9ucydcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0LmNyZWF0ZUNsYXNzXG5cbiAgZ2V0SW5pdGlhbFN0YXRlOiAtPlxuICAgIGJ1ZmZlcjogbnVsbFxuXG4gIHNldFN0YXJ0OiAodmFsdWUpIC0+XG4gICAgQHByb3BzLmluc3RydW1lbnQubWVyZ2VcbiAgICAgIHN0YXJ0OiB2YWx1ZVxuICAgICAgbG9vcDogTWF0aC5tYXggdmFsdWUsIEBwcm9wcy5pbnN0cnVtZW50LmdldCAnbG9vcCdcblxuICBzZXRMb29wOiAodmFsdWUpIC0+XG4gICAgQHByb3BzLmluc3RydW1lbnQubWVyZ2VcbiAgICAgIGxvb3A6IHZhbHVlXG4gICAgICBzdGFydDogTWF0aC5taW4gdmFsdWUsIEBwcm9wcy5pbnN0cnVtZW50LmdldCAnc3RhcnQnXG5cbiAgcmVuZGVyOiAtPlxuICAgIGluc3RydW1lbnQgPSBAcHJvcHMuaW5zdHJ1bWVudFxuXG4gICAgb3B0aW9ucyA9IGZvciBpIGluIFsxLi42XVxuICAgICAgUmVhY3QuRE9NLm9wdGlvbih7XCJrZXlcIjogKGkpLCBcInZhbHVlXCI6IChpKX0sIChpKSlcblxuICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwidWkgYmFzaWMtc2FtcGxlclwifSwgXG4gICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcImNvbHVtbiBjaGFubmVsXCJ9LCBcbiAgICAgICAgU2xpZGVyKHsgXFxcbiAgICAgICAgICBcImxhYmVsXCI6IFwiTGV2ZWxcIiwgIFxcXG4gICAgICAgICAgXCJ2YWx1ZVwiOiAoaW5zdHJ1bWVudC5nZXQgJ2xldmVsJyksICBcXFxuICAgICAgICAgIFwib25DaGFuZ2VcIjogKGluc3RydW1lbnQuYmluZCAnbGV2ZWwnKVxuICAgICAgICB9KSwgXG4gICAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwidWlcIn0sIFxuICAgICAgICAgIFJlYWN0LkRPTS5zZWxlY3QoeyBcXFxuICAgICAgICAgICAgXCJ2YWx1ZVwiOiAoaW5zdHJ1bWVudC5nZXQgJ3BvbHlwaG9ueScpLCAgXFxcbiAgICAgICAgICAgIFwib25DaGFuZ2VcIjogKGluc3RydW1lbnQuYmluZCAncG9seXBob255JywgKGUpIC0+IHBhcnNlSW50IGUudGFyZ2V0LnZhbHVlKVxuICAgICAgICAgIH0sIFxuICAgICAgICAgICAgKG9wdGlvbnMpXG4gICAgICAgICAgKSwgXG4gICAgICAgICAgUmVhY3QuRE9NLmxhYmVsKG51bGwsIFwiUG9seVwiKVxuICAgICAgICApXG4gICAgICApLCBcbiAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwiY29sdW1uXCJ9LCBcbiAgICAgICAgU2FtcGxlQ29udHJvbCh7IFxcXG4gICAgICAgICAgXCJsYWJlbFwiOiBcIlNhbXBsZVwiLCAgXFxcbiAgICAgICAgICBcImFwcFwiOiAoQHByb3BzLmFwcCksICBcXFxuICAgICAgICAgIFwic2FtcGxlclwiOiAoaW5zdHJ1bWVudClcbiAgICAgICAgfSlcbiAgICAgICksIFxuICAgICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJjb2x1bW4gZW52ZWxvcGVcIn0sIFxuICAgICAgICBFbnZlbG9wZSh7IFxcXG4gICAgICAgICAgXCJsYWJlbFwiOiBcIlZvbHVtZSBFbnZcIiwgIFxcXG4gICAgICAgICAgXCJlbnZcIjogKGluc3RydW1lbnQuY3Vyc29yICd2b2x1bWVFbnYnKVxuICAgICAgICB9KVxuICAgICAgKSwgXG4gICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcImNvbHVtbiBlbnZlbG9wZVwifSwgXG4gICAgICAgIEVudmVsb3BlKHsgXFxcbiAgICAgICAgICBcImxhYmVsXCI6IFwiRmlsdGVyIEVudlwiLCAgXFxcbiAgICAgICAgICBcImVudlwiOiAoaW5zdHJ1bWVudC5jdXJzb3IgJ2ZpbHRlckVudicpXG4gICAgICAgIH0pXG4gICAgICApLCBcbiAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwiY29sdW1uIGNvbnRyb2xzXCJ9LCBcbiAgICAgICAgRmlsdGVyKHsgXFxcbiAgICAgICAgICBcImxhYmVsXCI6IFwiRmlsdGVyXCIsICBcXFxuICAgICAgICAgIFwiZmlsdGVyXCI6IChpbnN0cnVtZW50LmN1cnNvciAnZmlsdGVyJylcbiAgICAgICAgfSksIFxuICAgICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcInJvdyBzYW1wbGVcIn0sIFxuICAgICAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwidWlcIn0sIFxuICAgICAgICAgICAgUmVhY3QuRE9NLnNlbGVjdCh7IFxcXG4gICAgICAgICAgICAgIFwidmFsdWVcIjogKGluc3RydW1lbnQuZ2V0ICdyb290S2V5JyksICBcXFxuICAgICAgICAgICAgICBcIm9uQ2hhbmdlXCI6IChpbnN0cnVtZW50LmJpbmQgJ3Jvb3RLZXknLCAoZSkgLT4gcGFyc2VJbnQgZS50YXJnZXQudmFsdWUpXG4gICAgICAgICAgICB9LCBcbiAgICAgICAgICAgICAgKGtleU9wdGlvbnMoKSlcbiAgICAgICAgICAgICksIFxuICAgICAgICAgICAgUmVhY3QuRE9NLmxhYmVsKG51bGwsIFwiUm9vdFwiKVxuICAgICAgICAgICksIFxuICAgICAgICAgIEtub2IoeyBcXFxuICAgICAgICAgICAgXCJsYWJlbFwiOiBcIlR1bmVcIiwgIFxcXG4gICAgICAgICAgICBcInZhbHVlXCI6IChpbnN0cnVtZW50LmdldCAndHVuZScpLCAgXFxcbiAgICAgICAgICAgIFwib25DaGFuZ2VcIjogKGluc3RydW1lbnQuYmluZCAndHVuZScpXG4gICAgICAgICAgfSlcbiAgICAgICAgKSwgXG4gICAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwicm93IHNhbXBsZVwifSwgXG4gICAgICAgICAgQ2hvb3Nlcih7IFxcXG4gICAgICAgICAgICBcIm9wdGlvbnNcIjogKFsnbG9vcCcsJ29mZiddKSwgIFxcXG4gICAgICAgICAgICBcInZhbHVlXCI6IChpbnN0cnVtZW50LmdldCAnbG9vcEFjdGl2ZScpLCAgXFxcbiAgICAgICAgICAgIFwib25DaGFuZ2VcIjogKGluc3RydW1lbnQuYmluZCAnbG9vcEFjdGl2ZScpXG4gICAgICAgICAgfSksIFxuICAgICAgICAgIEtub2IoeyBcXFxuICAgICAgICAgICAgXCJsYWJlbFwiOiBcIkxvb3BcIiwgIFxcXG4gICAgICAgICAgICBcInZhbHVlXCI6IChpbnN0cnVtZW50LmdldCAnbG9vcCcpLCAgXFxcbiAgICAgICAgICAgIFwiZGlzYWJsZWRcIjogKGluc3RydW1lbnQuZ2V0KCdsb29wQWN0aXZlJykgPT0gJ29mZicpLCAgXFxcbiAgICAgICAgICAgIFwib25DaGFuZ2VcIjogKEBzZXRMb29wKVxuICAgICAgICAgIH0pLCBcbiAgICAgICAgICBLbm9iKHsgXFxcbiAgICAgICAgICAgIFwibGFiZWxcIjogXCJTdGFydFwiLCAgXFxcbiAgICAgICAgICAgIFwidmFsdWVcIjogKGluc3RydW1lbnQuZ2V0ICdzdGFydCcpLCAgXFxcbiAgICAgICAgICAgIFwib25DaGFuZ2VcIjogKEBzZXRTdGFydClcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApXG4gICAgKVxuIiwiIyB2ZXJ0aWNhbGx5IHN0YWNrZWQgYnV0dG9ucyBmb3IgY2hvb3Npbmcgb25lIG9mIGEgc2V0IG9mIHZhbHVlc1xuIyBleHBlY3RzIHRocmVlIHByb3BzIC0gb3B0aW9ucywgYW4gYXJyYXkgb2Ygc3RyaW5nIG9wdGlvbnMsIHZhbHVlLCB0aGVcbiMgY3VycmVudGx5IHNlbGVjdGVkIG9wdGlvbiwgYW5kIGFuIG9uQ2hhbmdlIGNhbGxiYWNrIHdoaWNoIHdpbGwgYmUgcGFzc2VkIHRoZVxuIyBuZXcgdmFsdWUgb24gc2VsZWN0aW9uLlxuXG5SZWFjdCA9IHJlcXVpcmUgJ3JlYWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0LmNyZWF0ZUNsYXNzXG5cbiAgcHJvcFR5cGVzOlxuICAgIG9uQ2hhbmdlOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkXG4gICAgb3B0aW9uczogUmVhY3QuUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWRcbiAgICB2YWx1ZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkXG5cbiAgb25DbGlja1ZhbHVlOiAodmFsdWUpIC0+XG4gICAgQHByb3BzLm9uQ2hhbmdlIGUudGFyZ2V0LmRhdGFzZXQudmFsdWVcblxuICByZW5kZXI6IC0+XG4gICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJ1aSBjaG9vc2VyXCJ9LCBcbiAgICAgIChcbiAgICAgICAgQHByb3BzLm9wdGlvbnMubWFwICh2LCBpKSA9PlxuICAgICAgICAgIFJlYWN0LkRPTS5kaXYoeyBcXFxuICAgICAgICAgICAgXCJrZXlcIjogKGkpLCAgXFxcbiAgICAgICAgICAgIFwiY2xhc3NOYW1lXCI6ICgnb3B0aW9uJyArIGlmIHYgaXMgQHByb3BzLnZhbHVlIHRoZW4gJyBzZWxlY3RlZCcgZWxzZSAnJyksICBcXFxuICAgICAgICAgICAgXCJvbkNsaWNrXCI6ICg9PiBAcHJvcHMub25DaGFuZ2UgdilcbiAgICAgICAgICB9LCBcbiAgICAgICAgICAgICh2KVxuICAgICAgICAgIClcbiAgICAgIClcbiAgICApIiwiIyBVSSBmb3IgZHJ1bSBzYW1wbGVyIGluc3RydW1lbnRcblxuUmVhY3QgPSByZXF1aXJlICdyZWFjdC9hZGRvbnMnXG5VcGRhdGFibGUgPSByZXF1aXJlICcuL21peGlucy91cGRhdGFibGUnXG5Tb3J0YWJsZSA9IHJlcXVpcmUgJy4vbWl4aW5zL3NvcnRhYmxlJ1xuS25vYiA9IHJlcXVpcmUgJy4va25vYidcblNsaWRlciA9IHJlcXVpcmUgJy4vc2xpZGVyJ1xuTGlzdENvbnRyb2wgPSByZXF1aXJlICcuL2xpc3RfY29udHJvbCdcblNhbXBsZUNvbnRyb2wgPSByZXF1aXJlICcuL3NhbXBsZV9jb250cm9sJ1xuRW52ZWxvcGUgPSByZXF1aXJlICcuL2VudmVsb3BlJ1xua2V5T3B0aW9ucyA9IHJlcXVpcmUgJy4uL3V0aWwva2V5X29wdGlvbnMnXG50cmFuc3Bvc2VPcHRpb25zID0gcmVxdWlyZSAnLi4vdXRpbC90cmFuc3Bvc2Vfb3B0aW9ucydcbkRydW1TYW1wbGVyID0gcmVxdWlyZSAnLi4vbW9kZWxzL2RydW1fc2FtcGxlcidcblxuRHJ1bSA9IFJlYWN0LmNyZWF0ZUNsYXNzXG5cbiAgbWl4aW5zOiBbXG4gICAgUmVhY3QuYWRkb25zLlB1cmVSZW5kZXJNaXhpblxuICAgIFNvcnRhYmxlXG4gIF1cblxuICByZW5kZXI6IC0+XG4gICAgZHJ1bSA9IEBwcm9wcy5kcnVtXG5cbiAgICByZXR1cm4gUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJkcnVtXCJ9KSB1bmxlc3MgZHJ1bVxuXG4gICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJkcnVtXCJ9LCBcbiAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwiY29sdW1uXCJ9LCBcbiAgICAgICAgU2FtcGxlQ29udHJvbCh7IFxcXG4gICAgICAgICAgXCJsYWJlbFwiOiAoXCJTYW1wbGVcIiksICBcXFxuICAgICAgICAgIFwiYXBwXCI6IChAcHJvcHMuYXBwKSwgIFxcXG4gICAgICAgICAgXCJzYW1wbGVyXCI6IChkcnVtKVxuICAgICAgICB9KVxuICAgICAgKSwgXG4gICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcImNvbHVtbiBlbnZlbG9wZVwifSwgXG4gICAgICAgIEVudmVsb3BlKHsgXFxcbiAgICAgICAgICBcImxhYmVsXCI6IFwiVm9sdW1lIEVudlwiLCAgXFxcbiAgICAgICAgICBcImVudlwiOiAoZHJ1bS5jdXJzb3IoJ3ZvbHVtZUVudicpKVxuICAgICAgICB9KVxuICAgICAgKSwgXG4gICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcImNvbHVtbiBjb250cm9sXCJ9LCBcbiAgICAgICAgS25vYih7IFxcXG4gICAgICAgICAgXCJsYWJlbFwiOiBcIkxldmVsXCIsICBcXFxuICAgICAgICAgIFwidmFsdWVcIjogKGRydW0uZ2V0ICdsZXZlbCcpLCAgXFxcbiAgICAgICAgICBcIm9uQ2hhbmdlXCI6IChkcnVtLmJpbmQgJ2xldmVsJylcbiAgICAgICAgfSksIFxuICAgICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcInVpXCJ9LCBcbiAgICAgICAgICBSZWFjdC5ET00uc2VsZWN0KHsgXFxcbiAgICAgICAgICAgIFwidmFsdWVcIjogKGRydW0uZ2V0ICd0cmFuc3Bvc2UnKSwgIFxcXG4gICAgICAgICAgICBcIm9uQ2hhbmdlXCI6IChkcnVtLmJpbmQgJ3RyYW5zcG9zZScsIChlKSAtPiBwYXJzZUludCBlLnRhcmdldC52YWx1ZSlcbiAgICAgICAgICB9LCBcbiAgICAgICAgICAgICh0cmFuc3Bvc2VPcHRpb25zKCkpXG4gICAgICAgICAgKSwgXG4gICAgICAgICAgUmVhY3QuRE9NLmxhYmVsKG51bGwsIFwiVHJhbnNwb3NlXCIpXG4gICAgICAgICksIFxuICAgICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcInVpXCJ9LCBcbiAgICAgICAgICBSZWFjdC5ET00uc2VsZWN0KHsgXFxcbiAgICAgICAgICAgIFwidmFsdWVcIjogKGRydW0uZ2V0ICdrZXknKSwgIFxcXG4gICAgICAgICAgICBcIm9uQ2hhbmdlXCI6IChkcnVtLmJpbmQgJ2tleScsIChlKSAtPiBwYXJzZUludCBlLnRhcmdldC52YWx1ZSlcbiAgICAgICAgICB9LCBcbiAgICAgICAgICAgIChrZXlPcHRpb25zKCkpXG4gICAgICAgICAgKSwgXG4gICAgICAgICAgUmVhY3QuRE9NLmxhYmVsKG51bGwsIFwiVHJpZ2dlclwiKVxuICAgICAgICApXG4gICAgICApXG4gICAgKVxuXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3QuY3JlYXRlQ2xhc3NcblxuICBtaXhpbnM6IFtcbiAgICBSZWFjdC5hZGRvbnMuUHVyZVJlbmRlck1peGluXG4gIF1cblxuICBnZXRJbml0aWFsU3RhdGU6IC0+XG4gICAgYWN0aXZlRHJ1bTogMFxuXG4gIG9uQWRkRHJ1bTogLT5cbiAgICBkcnVtcyA9IEBwcm9wcy5pbnN0cnVtZW50LmdldCAnZHJ1bXMnXG4gICAgZHJ1bSA9IERydW1TYW1wbGVyLmRlZmF1bHREcnVtIGRydW1zXG4gICAgaW5kZXggPSBkcnVtcy5sZW5ndGhcblxuICAgIEBwcm9wcy5pbnN0cnVtZW50LnNldCBbJ2RydW1zJywgaW5kZXhdLCBkcnVtXG4gICAgQHNldFN0YXRlIGFjdGl2ZURydW06IGluZGV4XG5cbiAgb25SZW1vdmVEcnVtOiAtPlxuICAgIGRydW1zID0gQHByb3BzLmluc3RydW1lbnQuZ2V0KCdkcnVtcycpLnNsaWNlIDBcbiAgICBkcnVtcy5zcGxpY2UgQHN0YXRlLmFjdGl2ZURydW0sIDFcbiAgICBAcHJvcHMuaW5zdHJ1bWVudC5zZXQgJ2RydW1zJywgZHJ1bXNcbiAgICBAc2V0U3RhdGUgYWN0aXZlRHJ1bTogTWF0aC5taW4gQHN0YXRlLmFjdGl2ZURydW0sIGRydW1zLmxlbmd0aCAtIDFcblxuICByZW5kZXI6IC0+XG4gICAgaW5zdHJ1bWVudCA9IEBwcm9wcy5pbnN0cnVtZW50XG5cbiAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcInVpIGRydW0tc2FtcGxlclwifSwgXG4gICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcImNvbHVtbiBjaGFubmVsXCJ9LCBcbiAgICAgICAgU2xpZGVyKHsgXFxcbiAgICAgICAgICBcImxhYmVsXCI6IFwiTGV2ZWxcIiwgIFxcXG4gICAgICAgICAgXCJ2YWx1ZVwiOiAoaW5zdHJ1bWVudC5nZXQgJ2xldmVsJyksICBcXFxuICAgICAgICAgIFwib25DaGFuZ2VcIjogKGluc3RydW1lbnQuYmluZCAnbGV2ZWwnKVxuICAgICAgICB9KVxuICAgICAgKSwgXG4gICAgICBMaXN0Q29udHJvbCh7IFxcXG4gICAgICAgIFwib3B0aW9uc1wiOiAoaW5zdHJ1bWVudC5nZXQgJ2RydW1zJyksICBcXFxuICAgICAgICBcInNlbGVjdGVkSW5kZXhcIjogKEBzdGF0ZS5hY3RpdmVEcnVtKSwgIFxcXG4gICAgICAgIFwib25TZWxlY3RcIjogKChhY3RpdmVEcnVtKSA9PiBAc2V0U3RhdGUge2FjdGl2ZURydW19KSwgIFxcXG4gICAgICAgIFwib25Tb3J0XCI6IChpbnN0cnVtZW50LmJpbmQgJ2RydW1zJyksICBcXFxuICAgICAgICBcIm9uQWRkXCI6IChAb25BZGREcnVtKSwgIFxcXG4gICAgICAgIFwib25SZW1vdmVcIjogKEBvblJlbW92ZURydW0pXG4gICAgICB9KSwgXG4gICAgICBEcnVtKHsgXFxcbiAgICAgICAgXCJkcnVtXCI6IChpbnN0cnVtZW50LmN1cnNvciBbJ2RydW1zJywgQHN0YXRlLmFjdGl2ZURydW1dKSwgIFxcXG4gICAgICAgIFwiYXBwXCI6IChAcHJvcHMuYXBwKVxuICAgICAgfSlcbiAgICApXG4iLCIjIFVJIGZvciBkcnVtIHN5bnRoZXNpemVyIGluc3RydW1lbnRcblxuUmVhY3QgPSByZXF1aXJlICdyZWFjdCdcblVwZGF0YWJsZSA9IHJlcXVpcmUgJy4vbWl4aW5zL3VwZGF0YWJsZSdcbktub2IgPSByZXF1aXJlICcuL2tub2InXG5TbGlkZXIgPSByZXF1aXJlICcuL3NsaWRlcidcbkxpc3RDb250cm9sID0gcmVxdWlyZSAnLi9saXN0X2NvbnRyb2wnXG5rZXlPcHRpb25zID0gcmVxdWlyZSAnLi4vdXRpbC9rZXlfb3B0aW9ucydcbkRydW1TeW50aGVzaXplciA9IHJlcXVpcmUgJy4uL21vZGVscy9kcnVtX3N5bnRoZXNpemVyJ1xuXG5EcnVtID0gUmVhY3QuY3JlYXRlQ2xhc3NcblxuICByZW5kZXI6IC0+XG4gICAgZHJ1bSA9IEBwcm9wcy5kcnVtLmdldCgpXG5cbiAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiAnZHJ1bSd9LCBcbiAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6ICdjb2x1bW4gYXR0cnMnfSwgXG4gICAgICAgIEtub2IoeyBcXFxuICAgICAgICAgIFwibGFiZWxcIjogXCJMZXZlbFwiLCAgXFxcbiAgICAgICAgICBcInZhbHVlXCI6IChkcnVtLmxldmVsKSwgIFxcXG4gICAgICAgICAgXCJvbkNoYW5nZVwiOiAoQHByb3BzLmRydW0uYmluZCAnbGV2ZWwnKVxuICAgICAgICB9KSwgXG4gICAgICAgIEtub2IoeyBcXFxuICAgICAgICAgIFwibGFiZWxcIjogXCJQaXRjaFwiLCAgXFxcbiAgICAgICAgICBcInZhbHVlXCI6IChkcnVtLnBpdGNoKSwgIFxcXG4gICAgICAgICAgXCJvbkNoYW5nZVwiOiAoQHByb3BzLmRydW0uYmluZCAncGl0Y2gnKVxuICAgICAgICB9KSwgXG4gICAgICAgIEtub2IoeyBcXFxuICAgICAgICAgIFwibGFiZWxcIjogXCJGTVwiLCAgXFxcbiAgICAgICAgICBcInZhbHVlXCI6IChkcnVtLmZtKSwgIFxcXG4gICAgICAgICAgXCJvbkNoYW5nZVwiOiAoQHByb3BzLmRydW0uYmluZCAnZm0nKVxuICAgICAgICB9KSwgXG4gICAgICAgIEtub2IoeyBcXFxuICAgICAgICAgIFwibGFiZWxcIjogXCJEY3lcIiwgIFxcXG4gICAgICAgICAgXCJ2YWx1ZVwiOiAoZHJ1bS5kZWNheSksICBcXFxuICAgICAgICAgIFwib25DaGFuZ2VcIjogKEBwcm9wcy5kcnVtLmJpbmQgJ2RlY2F5JylcbiAgICAgICAgfSksIFxuICAgICAgICBLbm9iKHsgXFxcbiAgICAgICAgICBcImxhYmVsXCI6IFwiQmVuZFwiLCAgXFxcbiAgICAgICAgICBcInZhbHVlXCI6IChkcnVtLmJlbmQpLCAgXFxcbiAgICAgICAgICBcIm9uQ2hhbmdlXCI6IChAcHJvcHMuZHJ1bS5iaW5kICdiZW5kJylcbiAgICAgICAgfSksIFxuICAgICAgICBLbm9iKHsgXFxcbiAgICAgICAgICBcImxhYmVsXCI6IFwiTURjeVwiLCAgXFxcbiAgICAgICAgICBcInZhbHVlXCI6IChkcnVtLmZtRGVjYXkpLCAgXFxcbiAgICAgICAgICBcIm9uQ2hhbmdlXCI6IChAcHJvcHMuZHJ1bS5iaW5kICdmbURlY2F5JylcbiAgICAgICAgfSksIFxuICAgICAgICBLbm9iKHsgXFxcbiAgICAgICAgICBcImxhYmVsXCI6IFwiTm9pc2VcIiwgIFxcXG4gICAgICAgICAgXCJ2YWx1ZVwiOiAoZHJ1bS5ub2lzZSksICBcXFxuICAgICAgICAgIFwib25DaGFuZ2VcIjogKEBwcm9wcy5kcnVtLmJpbmQgJ25vaXNlJylcbiAgICAgICAgfSksIFxuICAgICAgICBLbm9iKHsgXFxcbiAgICAgICAgICBcImxhYmVsXCI6IFwiSFBcIiwgIFxcXG4gICAgICAgICAgXCJ2YWx1ZVwiOiAoZHJ1bS5ocCksICBcXFxuICAgICAgICAgIFwib25DaGFuZ2VcIjogKEBwcm9wcy5kcnVtLmJpbmQgJ2hwJylcbiAgICAgICAgfSksIFxuICAgICAgICBLbm9iKHsgXFxcbiAgICAgICAgICBcImxhYmVsXCI6IFwiTUZycVwiLCAgXFxcbiAgICAgICAgICBcInZhbHVlXCI6IChkcnVtLmZtRnJlcSksICBcXFxuICAgICAgICAgIFwib25DaGFuZ2VcIjogKEBwcm9wcy5kcnVtLmJpbmQgJ2ZtRnJlcScpXG4gICAgICAgIH0pXG4gICAgICApLCBcbiAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwiY29sdW1uIGNvbnRyb2xcIn0sIFxuICAgICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcInVpXCJ9LCBcbiAgICAgICAgICBSZWFjdC5ET00uc2VsZWN0KHsgXFxcbiAgICAgICAgICAgIFwidmFsdWVcIjogKGRydW0ua2V5KSwgIFxcXG4gICAgICAgICAgICBcIm9uQ2hhbmdlXCI6IChAcHJvcHMuZHJ1bS5iaW5kICdrZXknLCAoZSkgLT4gcGFyc2VJbnQgZS50YXJnZXQudmFsdWUpXG4gICAgICAgICAgfSwgXG4gICAgICAgICAgICAoa2V5T3B0aW9ucygpKVxuICAgICAgICAgICksIFxuICAgICAgICAgIFJlYWN0LkRPTS5sYWJlbChudWxsLCBcIlRyaWdnZXJcIilcbiAgICAgICAgKVxuICAgICAgKVxuICAgIClcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0LmNyZWF0ZUNsYXNzXG5cbiAgbWl4aW5zOiBbXG4gICAgUmVhY3QuYWRkb25zLlB1cmVSZW5kZXJNaXhpblxuICBdXG5cbiAgZ2V0SW5pdGlhbFN0YXRlOiAtPlxuICAgIGFjdGl2ZURydW06IDBcblxuICBvbkFkZERydW06IC0+XG4gICAgZHJ1bXMgPSBAcHJvcHMuaW5zdHJ1bWVudC5nZXQgJ2RydW1zJ1xuICAgIGRydW0gPSBEcnVtU3ludGhlc2l6ZXIuZGVmYXVsdERydW0gZHJ1bXNcbiAgICBpbmRleCA9IGRydW1zLmxlbmd0aFxuXG4gICAgQHByb3BzLmluc3RydW1lbnQuc2V0IFsnZHJ1bXMnLCBpbmRleF0sIGRydW1cbiAgICBAc2V0U3RhdGUgYWN0aXZlRHJ1bTogaW5kZXhcblxuICBvblJlbW92ZURydW06IC0+XG4gICAgZHJ1bXMgPSBAcHJvcHMuaW5zdHJ1bWVudC5nZXQoJ2RydW1zJykuc2xpY2UgMFxuICAgIGRydW1zLnNwbGljZSBAc3RhdGUuYWN0aXZlRHJ1bSwgMVxuICAgIEBwcm9wcy5pbnN0cnVtZW50LnNldCAnZHJ1bXMnLCBkcnVtc1xuICAgIEBzZXRTdGF0ZSBhY3RpdmVEcnVtOiBNYXRoLm1pbiBAc3RhdGUuYWN0aXZlRHJ1bSwgZHJ1bXMubGVuZ3RoIC0gMVxuXG4gIHJlbmRlcjogLT5cbiAgICBpbnN0cnVtZW50ID0gQHByb3BzLmluc3RydW1lbnRcblxuICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwidWkgZHJ1bS1zeW50aGVzaXplclwifSwgXG4gICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcImNvbHVtbiBjaGFubmVsXCJ9LCBcbiAgICAgICAgU2xpZGVyKHsgXFxcbiAgICAgICAgICBcImxhYmVsXCI6IFwiTGV2ZWxcIiwgIFxcXG4gICAgICAgICAgXCJ2YWx1ZVwiOiAoaW5zdHJ1bWVudC5nZXQgJ2xldmVsJyksICBcXFxuICAgICAgICAgIFwib25DaGFuZ2VcIjogKGluc3RydW1lbnQuYmluZCAnbGV2ZWwnKVxuICAgICAgICB9KVxuICAgICAgKSwgXG4gICAgICBMaXN0Q29udHJvbCh7IFxcXG4gICAgICAgIFwib3B0aW9uc1wiOiAoaW5zdHJ1bWVudC5nZXQgJ2RydW1zJyksICBcXFxuICAgICAgICBcInNlbGVjdGVkSW5kZXhcIjogKEBzdGF0ZS5hY3RpdmVEcnVtKSwgIFxcXG4gICAgICAgIFwib25TZWxlY3RcIjogKChhY3RpdmVEcnVtKSA9PiBAc2V0U3RhdGUge2FjdGl2ZURydW19KSwgIFxcXG4gICAgICAgIFwib25Tb3J0XCI6IChpbnN0cnVtZW50LmJpbmQgJ2RydW1zJyksICBcXFxuICAgICAgICBcIm9uQWRkXCI6IChAb25BZGREcnVtKSwgIFxcXG4gICAgICAgIFwib25SZW1vdmVcIjogKEBvblJlbW92ZURydW0pXG4gICAgICB9KSwgXG4gICAgICBEcnVtKHtcImRydW1cIjogKGluc3RydW1lbnQuY3Vyc29yIFsnZHJ1bXMnLCBAc3RhdGUuYWN0aXZlRHJ1bV0pfSlcbiAgICApXG4iLCIjIFVJIGZvciBhbiBlbnZlbG9wZSBjb250cm9sIHdpdGggYXR0YWNrLCBkZWNheSwgc3VzdGFpbiwgYW5kIHJlbGVhc2UuXG4jIGluY2x1ZGVzIDQga25vYnMgYW5kIGFuIGludGVyYWN0aXZlIHZpc3VhbGl6YXRpb24gb2YgdGhlIGVudmVsb3BlIHVzaW5nIFNWRy5cbiMgZXhwZWN0cyB0byByZWNlaXZlIGEgY3Vyc29yIHRvIGFuIGV2ZWxvcGUgb2JqZWN0IHthLGQscyxyfSBhcyBhICdlbnYnIHByb3AuXG5cblJlYWN0ID0gcmVxdWlyZSAncmVhY3QnXG5TaXplTWVhc3VyYWJsZSA9IHJlcXVpcmUgJy4vbWl4aW5zL3NpemVfbWVhc3VyYWJsZSdcbkRyYWdnYWJsZSA9IHJlcXVpcmUgJy4vbWl4aW5zL2RyYWdnYWJsZSdcbktub2IgPSByZXF1aXJlICcuL2tub2InXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3QuY3JlYXRlQ2xhc3NcblxuICBtaXhpbnM6IFtcbiAgICBTaXplTWVhc3VyYWJsZVxuICAgIERyYWdnYWJsZVxuICBdXG5cbiAgcHJvcFR5cGVzOlxuICAgIGxhYmVsOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWRcbiAgICBlbnY6IFJlYWN0LlByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZFxuICAgIGRvdFJhZGl1czogUmVhY3QuUHJvcFR5cGVzLm51bWJlclxuICAgIG1hcmdpbjogUmVhY3QuUHJvcFR5cGVzLm51bWJlclxuXG4gIGdldEluaXRpYWxTdGF0ZTogLT5cbiAgICBkcmFnVGFyZ2V0OiBudWxsXG5cbiAgZ2V0RGVmYXVsdFByb3BzOiAtPlxuICAgIGRvdFJhZGl1czogNVxuICAgIG1hcmdpbjogNFxuXG4gIGJ1aWxkTGluZXM6IC0+XG4gICAgbGluZXMgPSBbXVxuICAgIGRvdHMgPSBbXVxuICAgIG0gPSBAcHJvcHMubWFyZ2luICsgQHByb3BzLmRvdFJhZGl1c1xuICAgIHcgPSBAc3RhdGUud2lkdGggLSAyICogbVxuICAgIGggPSBAc3RhdGUuaGVpZ2h0IC0gMiAqIG1cbiAgICBlbnYgPSBAcHJvcHMuZW52LmdldCgpXG5cbiAgICBwMSA9XG4gICAgICB4OiAwXG4gICAgICB5OiBoXG5cbiAgICBwMiA9XG4gICAgICB4OiB3IC8gMyAqIGVudi5hXG4gICAgICB5OiAwXG5cbiAgICBwMyA9XG4gICAgICB4OiBwMi54ICsgdyAvIDMgKiBlbnYuZFxuICAgICAgeTogaCAqICgxIC0gZW52LnMpXG5cbiAgICBwNCA9XG4gICAgICB4OiB3ICogMiAvIDNcbiAgICAgIHk6IGggKiAoMSAtIGVudi5zKVxuXG4gICAgcDUgPVxuICAgICAgeDogdyAqICgyICsgZW52LnIpIC8gM1xuICAgICAgeTogaFxuXG4gICAgZm9yIHAgaW4gW3AxLCBwMiwgcDMsIHA0LCBwNV1cbiAgICAgIHAueCArPSBtXG4gICAgICBwLnkgKz0gbVxuXG4gICAgIyAjIGJhc2VcbiAgICAjIGxpbmVzLnB1c2ggPGxpbmUga2V5PVwiYlwiIHgxPXttfSB5MT17bStofSB4Mj17bSt3fSB5Mj17bStofS8+XG5cbiAgICAjIHBhdGhcbiAgICBkID0gJ00gJyArIFtwMSwgcDIsIHAzLCBwNCwgcDVdLm1hcCgocCkgLT4gXCIje3AueH0gI3twLnl9XCIpLmpvaW4gJyBMICdcbiAgICBsaW5lcy5wdXNoIFJlYWN0LkRPTS5wYXRoKHtcImtleVwiOiBcInBcIiwgXCJkXCI6IChkKX0pXG5cbiAgICAjIGF0dGFja1xuICAgIGNsYXNzTmFtZSA9IGlmIEBzdGF0ZS5kcmFnVGFyZ2V0IGlzICdhdHRhY2snIHRoZW4gJ2FjdGl2ZScgZWxzZSAnJ1xuICAgIGRvdHMucHVzaCBSZWFjdC5ET00uY2lyY2xlKHtcImtleVwiOiBcImFcIiwgXCJjbGFzc05hbWVcIjogKGNsYXNzTmFtZSksIFwiY3hcIjogKHAyLngpLCBcImN5XCI6IChwMi55KSwgXCJyXCI6IChAcHJvcHMuZG90UmFkaXVzKSwgXCJvbk1vdXNlRG93blwiOiAoQG9uTW91c2VEb3duQXR0YWNrKX0pXG5cbiAgICAjIGRlY2F5IC8gc3VzdGFpblxuICAgIGNsYXNzTmFtZSA9IGlmIEBzdGF0ZS5kcmFnVGFyZ2V0IGlzICdkZWNheScgdGhlbiAnYWN0aXZlJyBlbHNlICcnXG4gICAgZG90cy5wdXNoIFJlYWN0LkRPTS5jaXJjbGUoe1wia2V5XCI6IFwiZFwiLCBcImNsYXNzTmFtZVwiOiAoY2xhc3NOYW1lKSwgXCJjeFwiOiAocDMueCksIFwiY3lcIjogKHAzLnkpLCBcInJcIjogKEBwcm9wcy5kb3RSYWRpdXMpLCBcIm9uTW91c2VEb3duXCI6IChAb25Nb3VzZURvd25EZWNheSl9KVxuXG4gICAgI3JlbGVhc2VcbiAgICBjbGFzc05hbWUgPSBpZiBAc3RhdGUuZHJhZ1RhcmdldCBpcyAncmVsZWFzZScgdGhlbiAnYWN0aXZlJyBlbHNlICcnXG4gICAgZG90cy5wdXNoIFJlYWN0LkRPTS5jaXJjbGUoe1wia2V5XCI6IFwiclwiLCBcImNsYXNzTmFtZVwiOiAoY2xhc3NOYW1lKSwgXCJjeFwiOiAocDUueCksIFwiY3lcIjogKHA1LnkpLCBcInJcIjogKEBwcm9wcy5kb3RSYWRpdXMpLCBcIm9uTW91c2VEb3duXCI6IChAb25Nb3VzZURvd25SZWxlYXNlKX0pXG5cbiAgICBsaW5lcy5jb25jYXQgZG90c1xuXG4gIG9uTW91c2VEb3duQXR0YWNrOiAoZSkgLT5cbiAgICBAaW5pdGlhbFZhbHVlID0gQHByb3BzLmVudi5nZXQgJ2EnXG4gICAgQHNldFN0YXRlIGRyYWdUYXJnZXQ6ICdhdHRhY2snXG4gICAgQGRyYWdnYWJsZU9uTW91c2VEb3duIGVcblxuICBvbk1vdXNlRG93bkRlY2F5OiAoZSkgLT5cbiAgICBAaW5pdGlhbFZhbHVlID0ge2Q6IEBwcm9wcy5lbnYuZ2V0KCdkJyksIHM6IEBwcm9wcy5lbnYuZ2V0KCdzJyl9XG4gICAgQHNldFN0YXRlIGRyYWdUYXJnZXQ6ICdkZWNheSdcbiAgICBAZHJhZ2dhYmxlT25Nb3VzZURvd24gZVxuXG4gIG9uTW91c2VEb3duUmVsZWFzZTogKGUpIC0+XG4gICAgQGluaXRpYWxWYWx1ZSA9IEBwcm9wcy5lbnYuZ2V0ICdyJ1xuICAgIEBzZXRTdGF0ZSBkcmFnVGFyZ2V0OiAncmVsZWFzZSdcbiAgICBAZHJhZ2dhYmxlT25Nb3VzZURvd24gZVxuXG4gIG9uRHJhZzogKGRlbHRhKSAtPlxuICAgIG0gPSBAcHJvcHMubWFyZ2luICsgQHByb3BzLmRvdFJhZGl1c1xuICAgIHcgPSAoQHN0YXRlLndpZHRoIC0gMiAqIG0pIC8gM1xuICAgIGggPSBAc3RhdGUuaGVpZ2h0IC0gMiAqIG1cblxuICAgIGlmIEBzdGF0ZS5kcmFnVGFyZ2V0IGlzICdhdHRhY2snXG4gICAgICBhID0gQGluaXRpYWxWYWx1ZSArIGRlbHRhLnggLyB3XG4gICAgICBjaGFuZ2VzID0ge2F9XG4gICAgZWxzZSBpZiBAc3RhdGUuZHJhZ1RhcmdldCBpcyAnZGVjYXknXG4gICAgICBkID0gQGluaXRpYWxWYWx1ZS5kICsgZGVsdGEueCAvIHdcbiAgICAgIHMgPSBAaW5pdGlhbFZhbHVlLnMgKyBkZWx0YS55IC8gaFxuICAgICAgY2hhbmdlcyA9IHtkLCBzfVxuICAgIGVsc2UgaWYgQHN0YXRlLmRyYWdUYXJnZXQgaXMgJ3JlbGVhc2UnXG4gICAgICByID0gQGluaXRpYWxWYWx1ZSArIGRlbHRhLnggLyB3XG4gICAgICBjaGFuZ2VzID0ge3J9XG5cbiAgICBmb3IgaywgdiBvZiBjaGFuZ2VzXG4gICAgICBjaGFuZ2VzW2tdID0gTWF0aC5tYXggMCwgTWF0aC5taW4gMSwgdlxuXG4gICAgQHByb3BzLmVudi5tZXJnZSBjaGFuZ2VzXG5cbiAgb25EcmFnRW5kOiAtPlxuICAgIEBpbml0aWFsVmFsdWUgPSBudWxsXG4gICAgQHNldFN0YXRlIGRyYWdUYXJnZXQ6IG51bGxcblxuICByZW5kZXI6IC0+XG4gICAgZW52ID0gQHByb3BzLmVudlxuICAgIGxpbmVzID0gQGJ1aWxkTGluZXMoKSBpZiBAc3RhdGUud2lkdGggPiAwXG5cbiAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiAndWkgZW52ZWxvcGUnfSwgXG4gICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiAnY29udHJvbCcsIFwicmVmXCI6ICdjb250YWluZXInfSwgXG4gICAgICAgIFJlYWN0LkRPTS5zdmcoe1wid2lkdGhcIjogKEBzdGF0ZS53aWR0aCksIFwiaGVpZ2h0XCI6IChAc3RhdGUuaGVpZ2h0KX0sIFxuICAgICAgICAgIChsaW5lcylcbiAgICAgICAgKVxuICAgICAgKSwgXG4gICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiAna25vYnMnfSwgXG4gICAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6ICdncm91cCd9LCBcbiAgICAgICAgICBLbm9iKHtcImxhYmVsXCI6ICdBJywgXCJ2YWx1ZVwiOiAoZW52LmdldCAnYScpLCBcIm9uQ2hhbmdlXCI6IChlbnYuYmluZCAnYScpfSksIFxuICAgICAgICAgIEtub2Ioe1wibGFiZWxcIjogJ0QnLCBcInZhbHVlXCI6IChlbnYuZ2V0ICdkJyksIFwib25DaGFuZ2VcIjogKGVudi5iaW5kICdkJyl9KVxuICAgICAgICApLCBcbiAgICAgICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogJ2dyb3VwJ30sIFxuICAgICAgICAgIEtub2Ioe1wibGFiZWxcIjogJ1MnLCBcInZhbHVlXCI6IChlbnYuZ2V0ICdzJyksIFwib25DaGFuZ2VcIjogKGVudi5iaW5kICdzJyl9KSwgXG4gICAgICAgICAgS25vYih7XCJsYWJlbFwiOiAnUicsIFwidmFsdWVcIjogKGVudi5nZXQgJ3InKSwgXCJvbkNoYW5nZVwiOiAoZW52LmJpbmQgJ3InKX0pXG4gICAgICAgIClcbiAgICAgICksIFxuICAgICAgUmVhY3QuRE9NLmxhYmVsKG51bGwsIChAcHJvcHMubGFiZWwpKVxuICAgICkiLCIjIFVJIGNvbnRyb2wgZm9yIGEgZmlsdGVyIC0gZXhwZWN0cyB0byByZWNlaXZlIGEgY3Vyc29yIHRvIGEgZmlsdGVyIG9iamVjdCBhc1xuIyBhIHByb3AgJ2ZpbHRlcicuICBGaWx0ZXIgaXMgZXBlY3RlZCB0byBoYXZlIHZhbHVlcyB7dHlwZSwgZnJlcSwgcmVzLCBlbnZ9LlxuXG5SZWFjdCA9IHJlcXVpcmUgJ3JlYWN0J1xuQ2hvb3NlciA9IHJlcXVpcmUgJy4vY2hvb3Nlcidcbktub2IgPSByZXF1aXJlICcuL2tub2InXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3QuY3JlYXRlQ2xhc3NcblxuICBwcm9wVHlwZXM6XG4gICAgZmlsdGVyOiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWRcbiAgICBsYWJlbDogUmVhY3QuUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkXG5cbiAgcmVuZGVyOiAtPlxuICAgIGZpbHRlciA9IEBwcm9wcy5maWx0ZXJcblxuICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwidWkgZmlsdGVyXCJ9LCBcbiAgICAgIENob29zZXIoeyBcXFxuICAgICAgICBcIm9wdGlvbnNcIjogKFsnTFAnLCdIUCcsJ25vbmUnXSksICBcXFxuICAgICAgICBcInZhbHVlXCI6IChmaWx0ZXIuZ2V0ICd0eXBlJyksICBcXFxuICAgICAgICBcIm9uQ2hhbmdlXCI6IChmaWx0ZXIuYmluZCAndHlwZScpXG4gICAgICB9KSwgXG4gICAgICBLbm9iKHsgXFxcbiAgICAgICAgXCJsYWJlbFwiOiBcIkZyZXFcIiwgIFxcXG4gICAgICAgIFwidmFsdWVcIjogKGZpbHRlci5nZXQgJ2ZyZXEnKSwgIFxcXG4gICAgICAgIFwib25DaGFuZ2VcIjogKGZpbHRlci5iaW5kICdmcmVxJylcbiAgICAgIH0pLCBcbiAgICAgIEtub2IoeyBcXFxuICAgICAgICBcImxhYmVsXCI6IFwiUmVzXCIsICBcXFxuICAgICAgICBcInZhbHVlXCI6IChmaWx0ZXIuZ2V0ICdyZXMnKSwgIFxcXG4gICAgICAgIFwib25DaGFuZ2VcIjogKGZpbHRlci5iaW5kICdyZXMnKVxuICAgICAgfSksIFxuICAgICAgS25vYih7XCJsYWJlbFwiOiBcIkVudlwiLCBcInZhbHVlXCI6IChmaWx0ZXIuZ2V0ICdlbnYnKSwgXCJvbkNoYW5nZVwiOiAoZmlsdGVyLmJpbmQgJ2VudicpfSksIFxuICAgICAgUmVhY3QuRE9NLmxhYmVsKG51bGwsIChAcHJvcHMubGFiZWwpKVxuICAgICkiLCIjIGEgbW91c2UgaW50ZXJhY3RpdmUgcm90YXJ5IGtub2IgLSBleHBlY3RzIHRvIHJlY2VpdmUgdHdvIHByb3BzLCB2YWx1ZSwgdGhlXG4jIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIGtub2IgYXMgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxLCBhbmQgb25DaGFuZ2UsIGFcbiMgY2FsbGJhY2sgd2hpY2ggd2lsbCBnZXQgcGFzc2VkIHRoZSBuZXcgdmFsdWVzIG9uIGNoYW5nZXMuXG4jXG4jIEFsc28gY2FuIHJlY2VpdmUgYW4gb3B0aW9uYWwgcHJvcCAnZGlzYWJsZWQnIHdoaWNoIGlmIHRydWUgd2lsbCBwcmV2ZW50XG4jIGludGVyYWN0aW9uLlxuXG5SZWFjdCA9IHJlcXVpcmUgJ3JlYWN0J1xuRHJhZ2dhYmxlID0gcmVxdWlyZSAnLi9taXhpbnMvZHJhZ2dhYmxlJ1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0LmNyZWF0ZUNsYXNzXG5cbiAgcmFuZ2U6IDEwMFxuXG4gIG1peGluczogW0RyYWdnYWJsZV1cblxuICBwcm9wVHlwZXM6XG4gICAgdmFsdWU6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZFxuICAgIG9uQ2hhbmdlOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkXG4gICAgZGlzYWJsZWQ6IFJlYWN0LlByb3BUeXBlcy5ib29sXG5cbiAgZ2V0SW5pdGlhbFN0YXRlOiAtPlxuICAgIGFjdGl2ZTogZmFsc2VcblxuICBnZXREZWZhdWx0UHJvcHM6IC0+XG4gICAgdmFsdWU6IDAuNVxuICAgIGRpc2FibGVkOiBmYWxzZVxuXG4gIG9uRHJhZ1N0YXJ0OiAtPlxuICAgIEBpbml0YWxWYWx1ZSA9IEBwcm9wcy52YWx1ZVxuICAgIEBzZXRTdGF0ZSBhY3RpdmU6IHRydWVcblxuICBvbkRyYWc6IChkZWx0YSkgLT5cbiAgICByZXR1cm4gaWYgQHByb3BzLmRpc2FibGVkXG5cbiAgICB1cFJhbmdlID0gTWF0aC5taW4gQHJhbmdlLCAoQGRyYWdTdGFydFBvc2l0aW9uLnkgLSB3aW5kb3cuc2Nyb2xsWSlcbiAgICBkb3duUmFuZ2UgPSBNYXRoLm1pbiBAcmFuZ2UsICh3aW5kb3cuaW5uZXJIZWlnaHQgKyB3aW5kb3cuc2Nyb2xsWSAtIEBkcmFnU3RhcnRQb3NpdGlvbi55KVxuXG4gICAgaWYgZGVsdGEueSA8IDBcbiAgICAgIHZhbHVlID0gTWF0aC5tYXggMCwgQGluaXRhbFZhbHVlICogKGRvd25SYW5nZSArIGRlbHRhLnkpIC8gZG93blJhbmdlXG4gICAgZWxzZVxuICAgICAgdmFsdWUgPSBNYXRoLm1pbiAxLCBAaW5pdGFsVmFsdWUgKyAoMSAtIEBpbml0YWxWYWx1ZSkgKiBkZWx0YS55IC8gdXBSYW5nZVxuXG4gICAgQHByb3BzLm9uQ2hhbmdlIHZhbHVlXG5cbiAgb25EcmFnRW5kOiAtPlxuICAgIEBpbml0YWxWYWx1ZSA9IG51bGxcbiAgICBAc2V0U3RhdGUgYWN0aXZlOiBmYWxzZVxuXG4gIHByZXZlbnREZWZhdWx0OiAoZSkgLT5cbiAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG5cbiAgcmVuZGVyOiAtPlxuICAgIHN0eWxlID0gJy13ZWJraXQtdHJhbnNmb3JtJzogXCJyb3RhdGUoI3soQHByb3BzLnZhbHVlIC0gMC41KSAqIDMwMH1kZWcpXCJcblxuICAgIGNsYXNzTmFtZSA9ICd1aSBrbm9iJ1xuICAgIGNsYXNzTmFtZSArPSAnIGFjdGl2ZScgaWYgQHN0YXRlLmFjdGl2ZVxuICAgIGNsYXNzTmFtZSArPSAnIGRpc2FibGVkJyBpZiBAcHJvcHMuZGlzYWJsZWRcblxuICAgICMgaW5jbHVkZSBkcmFnZ2FibGUgYW5kIG9uZHJhZ3N0YXJ0IHRvIGFsbG93IHVzZSBvZiB0aGUga25vYiBjb21wb25lbnRcbiAgICAjIGluc2lkZSBhIHBhcmVudCBlbGVtZW50IHVzaW5nIG5hdGl2ZSBodG1sIGRyYWcvZHJvcFxuICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IChjbGFzc05hbWUpLCBcImRyYWdnYWJsZVwiOiAodHJ1ZSksIFwib25EcmFnU3RhcnRcIjogKEBwcmV2ZW50RGVmYXVsdCl9LCBcbiAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwiY29udHJvbFwifSwgXG4gICAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwiaGFuZGxlXCIsIFwic3R5bGVcIjogKHN0eWxlKSwgXCJvbk1vdXNlRG93blwiOiAoQGRyYWdnYWJsZU9uTW91c2VEb3duKX0pXG4gICAgICApLCBcbiAgICAgIFJlYWN0LkRPTS5sYWJlbChudWxsLCAoQHByb3BzLmxhYmVsKSlcbiAgICApXG4iLCIjIHVpIGZvciBhIHNvcnRhYmxlIHNlbGVjdGFibGUgbGlzdCBvZiBpdGVtc1xuXG5SZWFjdCA9IHJlcXVpcmUgJ3JlYWN0L2FkZG9ucydcblNvcnRhYmxlID0gcmVxdWlyZSAnLi9taXhpbnMvc29ydGFibGUnXG5cbkxpc3RPcHRpb24gPSBSZWFjdC5jcmVhdGVDbGFzc1xuXG4gIG1peGluczogW1NvcnRhYmxlLCBSZWFjdC5hZGRvbnMuUHVyZVJlbmRlck1peGluXVxuXG4gIHJlbmRlcjogLT5cbiAgICBjbGFzc05hbWUgPSAnb3B0aW9uJ1xuICAgIGNsYXNzTmFtZSArPSAnIHNlbGVjdGVkJyBpZiBAcHJvcHMuc2VsZWN0ZWRcbiAgICBjbGFzc05hbWUgKz0gJyBkcmFnZ2luZycgaWYgQGlzRHJhZ2dpbmcoKVxuXG4gICAgUmVhY3QuRE9NLmRpdih7IFxcXG4gICAgICBcImNsYXNzTmFtZVwiOiAoY2xhc3NOYW1lKSwgIFxcXG4gICAgICBcIm9uQ2xpY2tcIjogKEBwcm9wcy5zZWxlY3RPcHRpb24pLCAgXFxcbiAgICAgIFwiZHJhZ2dhYmxlXCI6ICh0cnVlKSwgIFxcXG4gICAgICBcIm9uRHJhZ1N0YXJ0XCI6IChAZHJhZ1N0YXJ0KSwgIFxcXG4gICAgICBcIm9uRHJhZ0VuZFwiOiAoQGRyYWdFbmQpLCAgXFxcbiAgICAgIFwib25EcmFnT3ZlclwiOiAoQGRyYWdPdmVyKSwgIFxcXG4gICAgICBcImRhdGEtaWRcIjogKEBwcm9wcy5rZXkpXG4gICAgfSwgXG4gICAgICAoQHByb3BzLm5hbWUpXG4gICAgKVxuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdC5jcmVhdGVDbGFzc1xuXG4gIG1peGluczogW1JlYWN0LmFkZG9ucy5QdXJlUmVuZGVyTWl4aW5dXG5cbiAgZ2V0SW5pdGlhbFN0YXRlOiAtPlxuICAgIGRyYWdnaW5nOiBudWxsXG5cbiAgb25SZW1vdmU6IC0+XG4gICAgQHByb3BzLm9uUmVtb3ZlIEBwcm9wcy5zZWxlY3RlZEluZGV4XG5cbiAgc29ydDogKGl0ZW1zLCBkcmFnZ2luZykgLT5cbiAgICBAcHJvcHMub25Tb3J0IGl0ZW1zXG4gICAgQHByb3BzLm9uU2VsZWN0IGRyYWdnaW5nIGlmIGRyYWdnaW5nP1xuICAgIEBzZXRTdGF0ZSB7ZHJhZ2dpbmd9XG5cbiAgcmVuZGVyOiAtPlxuICAgIG9wdGlvbnMgPSBAcHJvcHMub3B0aW9uc1xuICAgICAgLm1hcCAob3B0aW9uLCBpKSA9PlxuICAgICAgICBMaXN0T3B0aW9uKHsgXFxcbiAgICAgICAgICBcImtleVwiOiAoaSksICBcXFxuICAgICAgICAgIFwibmFtZVwiOiAob3B0aW9uLm5hbWUpLCAgXFxcbiAgICAgICAgICBcInNlbGVjdGVkXCI6IChpID09IEBwcm9wcy5zZWxlY3RlZEluZGV4KSwgIFxcXG4gICAgICAgICAgXCJzZWxlY3RPcHRpb25cIjogKD0+IEBwcm9wcy5vblNlbGVjdCBpKSwgIFxcXG4gICAgICAgICAgXCJzb3J0XCI6IChAc29ydCksICBcXFxuICAgICAgICAgIFwiaXRlbXNcIjogKEBwcm9wcy5vcHRpb25zKSwgIFxcXG4gICAgICAgICAgXCJkcmFnZ2luZ1wiOiAoQHN0YXRlLmRyYWdnaW5nKVxuICAgICAgICB9KVxuXG4gICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJ1aSBsaXN0LWNvbnRyb2xcIn0sIFxuICAgICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJsaXN0XCJ9LCBcbiAgICAgICAgKG9wdGlvbnMpXG4gICAgICApLCBcbiAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwiY29udHJvbHNcIn0sIFxuICAgICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcImljb24gaWNvbi1wbHVzIHB1bGwtcmlnaHRcIiwgXCJvbkNsaWNrXCI6IChAcHJvcHMub25BZGQpfSksIFxuICAgICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcImljb24gaWNvbi1taW51cyBwdWxsLWxlZnRcIiwgXCJvbkNsaWNrXCI6IChAb25SZW1vdmUpfSlcbiAgICAgIClcbiAgICApXG4iLCIjIHVpIGZvciB0aGUgbG9vcCBzYW1wbGVyIGluc3RydW1lbnRcbiMgaW5jb21wbGV0ZVxuXG5SZWFjdCA9IHJlcXVpcmUgJ3JlYWN0J1xuS25vYiA9IHJlcXVpcmUgJy4va25vYidcblNsaWRlciA9IHJlcXVpcmUgJy4vc2xpZGVyJ1xuU2FtcGxlQ29udHJvbCA9IHJlcXVpcmUgJy4vc2FtcGxlX2NvbnRyb2wnXG5FbnZlbG9wZSA9IHJlcXVpcmUgJy4vZW52ZWxvcGUnXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3QuY3JlYXRlQ2xhc3NcblxuICBzZXRQb2x5cGhvbnk6IChlKSAtPlxuICAgIEBwcm9wcy5pbnN0cnVtZW50LnNldFBvbHlwaG9ueSBwYXJzZUludCBlLnRhcmdldC52YWx1ZVxuXG4gIHJlbmRlcjogLT5cbiAgICBvcHRpb25zID0gZm9yIGkgaW4gWzEuLkBwcm9wcy5pbnN0cnVtZW50Lm1heFBvbHlwaG9ueV1cbiAgICAgIFJlYWN0LkRPTS5vcHRpb24oe1wia2V5XCI6IChpKSwgXCJ2YWx1ZVwiOiAoaSl9LCAoaSkpXG5cbiAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcInVpIGxvb3Atc2FtcGxlclwifSwgXG4gICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcImNvbHVtbiBjaGFubmVsXCJ9LCBcbiAgICAgICAgU2xpZGVyKHsgXFxcbiAgICAgICAgICBcImxhYmVsXCI6IFwiTGV2ZWxcIiwgIFxcXG4gICAgICAgICAgXCJ2YWx1ZVwiOiAoQHN0YXRlLmxldmVsKSwgIFxcXG4gICAgICAgICAgXCJvbkNoYW5nZVwiOiAoQHByb3BzLmluc3RydW1lbnQuY3JlYXRlU2V0dGVyRm9yICdsZXZlbCcpXG4gICAgICAgIH0pLCBcbiAgICAgICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJ1aVwifSwgXG4gICAgICAgICAgUmVhY3QuRE9NLnNlbGVjdCh7XCJvbkNoYW5nZVwiOiAoQHNldFBvbHlwaG9ueSksIFwidmFsdWVcIjogKEBzdGF0ZS5wb2x5cGhvbnkpfSwgKG9wdGlvbnMpKSwgXG4gICAgICAgICAgUmVhY3QuRE9NLmxhYmVsKG51bGwsIFwiUG9seVwiKVxuICAgICAgICApXG4gICAgICApXG4gICAgKVxuIiwiUmVhY3QgPSByZXF1aXJlICdyZWFjdCdcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdC5jcmVhdGVDbGFzc1xuICBcbiAgb25DbGlja09wdGlvbjogKGUpIC0+XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgIEBwcm9wcy5vblNlbGVjdCBlLnRhcmdldC5kYXRhc2V0Lm9wdGlvblxuXG4gIHJlbmRlcjogLT5cbiAgICBvcHRpb25zID0gZm9yIG9wdGlvbiwgaSBpbiBAcHJvcHMub3B0aW9uc1xuICAgICAgZG8gKG9wdGlvbikgPT5cbiAgICAgICAgUmVhY3QuRE9NLmRpdih7XCJrZXlcIjogKGkpLCBcImNsYXNzTmFtZVwiOiBcIm9wdGlvblwiLCBcIm9uQ2xpY2tcIjogKEBvbkNsaWNrT3B0aW9uKSwgXCJkYXRhLW9wdGlvblwiOiAob3B0aW9uKX0sIChvcHRpb24pKVxuXG4gICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJ1aSBtZW51XCIsIFwic3R5bGVcIjogKHtkaXNwbGF5OiBpZiBAcHJvcHMub3BlbiB0aGVuICdibG9jaycgZWxzZSAnbm9uZSd9KX0sIChvcHRpb25zKSlcbiIsIiMgcmVhY3QgY29tcG9uZW50IGZvciBhIHZvbHVtZSBtZXRlclxuXG5SZWFjdCA9IHJlcXVpcmUgJ3JlYWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0LmNyZWF0ZUNsYXNzXG5cbiAgcHJvcFR5cGVzOlxuICAgIGxldmVsOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWRcbiAgICBzdGVwczogUmVhY3QuUHJvcFR5cGVzLm51bWJlclxuXG4gIGdldERlZmF1bHRQcm9wczogLT5cbiAgICBzdGVwczogNlxuXG4gIHJlbmRlcjogLT5cbiAgICBsZXZlbCA9IE1hdGguY2VpbCBAcHJvcHMubGV2ZWwgKiBAcHJvcHMuc3RlcHNcblxuICAgIHN0ZXBzID0gZm9yIGkgaW4gWzEuLkBwcm9wcy5zdGVwc11cbiAgICAgIGNsYXNzTmFtZSA9IGlmIGkgPD0gbGV2ZWwgdGhlbiAnb24nIGVsc2UgJydcbiAgICAgIFJlYWN0LkRPTS5kaXYoe1wia2V5XCI6IChpKSwgXCJjbGFzc05hbWVcIjogKGNsYXNzTmFtZSl9KVxuXG4gICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJ1aSBtZXRlclwifSwgXG4gICAgICAoc3RlcHMpXG4gICAgKVxuXG4gICMgc2hvdWxkQ29tcG9uZW50VXBkYXRlOiAobmV4dFByb3BzKSAtPlxuICAjICAgTWF0aC5jZWlsKEBwcm9wcy5sZXZlbCAqIEBwcm9wcy5zdGVwcykgIT0gTWF0aC5jZWlsKG5leHRQcm9wcy5sZXZlbCAqIG5leHRQcm9wcy5zdGVwcylcbiIsIm1vZHVsZS5leHBvcnRzID1cblxuICBkcmFnZ2FibGVPbk1vdXNlRG93bjogKGUpIC0+XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgJ21vdXNlbW92ZScsIEBkcmFnZ2FibGVPbk1vdXNlTW92ZVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyICdtb3VzZXVwJywgQGRyYWdnYWJsZU9uTW91c2VVcFxuICAgIEBkcmFnU3RhcnRQb3NpdGlvbiA9IHg6IGUuY2xpZW50WCwgeTogZS5jbGllbnRZXG4gICAgQG9uRHJhZ1N0YXJ0PyhAZHJhZ1N0YXJ0UG9zaXRpb24sIGUpXG5cbiAgZHJhZ2dhYmxlT25Nb3VzZU1vdmU6IChlKSAtPlxuICAgIHggPSBlLmNsaWVudFggLSBAZHJhZ1N0YXJ0UG9zaXRpb24ueFxuICAgIHkgPSBAZHJhZ1N0YXJ0UG9zaXRpb24ueSAtIGUuY2xpZW50WVxuICAgIEBvbkRyYWc/KHt4LHl9LCBlKVxuXG4gIGRyYWdnYWJsZU9uTW91c2VVcDogKGUpIC0+XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIgJ21vdXNlbW92ZScsIEBkcmFnZ2FibGVPbk1vdXNlTW92ZVxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyICdtb3VzZXVwJywgQGRyYWdnYWJsZU9uTW91c2VVcFxuICAgIEBtb3VzZURvd25Qb3NpdGlvbiA9IG51bGxcbiAgICBAaW5pdGlhbFZhbHVlID0gbnVsbFxuICAgIEBvbkRyYWdFbmQ/KGUpXG4iLCIjIGdsb2JhbCBrZXlib2FyZCBjb250cm9scyBtaXhpbiwgaW5jbHVkZWQgYnkgdGhlIEFwcCBjb21wb25lbnRcblxuS2V5Ym9hcmQgPSByZXF1aXJlICdrZXlib2FyZGpzJ1xuXG5tb2R1bGUuZXhwb3J0cyA9XG5cbiAgY29tcG9uZW50RGlkTW91bnQ6IC0+XG4gICAgQGtleUJpbmRpbmdzID0gW1xuICAgICAgS2V5Ym9hcmQub24gJ3NwYWNlJywgQG9uU3BhY2VLZXlcbiAgICAgIEtleWJvYXJkLm9uICdjb21tYW5kICsgeicsIEB1bmRvXG4gICAgICBLZXlib2FyZC5vbiAnY29tbWFuZCArIHNoaWZ0ICsgeicsIEByZWRvXG4gICAgXVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50OiAtPlxuICAgIGJpbmRpbmcuY2xlYXIoKSBmb3IgYmluZGluZyBpbiBAa2V5QmluZGluZ3NcblxuICBvblNwYWNlS2V5OiAoZSkgLT5cbiAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICBpZiBAcHJvcHMuZGF0YS5nZXQgJ3BsYXlpbmcnXG4gICAgICBAcHJvcHMuc29uZy5wYXVzZSgpXG4gICAgZWxzZVxuICAgICAgQHByb3BzLnNvbmcucGxheSgpXG5cbiAgdW5kbzogKGUpIC0+XG4gICAgY29uc29sZS5sb2cgXCJIRVJFXCJcbiAgICBjb25zb2xlLmxvZyBAcHJvcHMuaGlzdG9yeVxuICAgIEBwcm9wcy5oaXN0b3J5LnVuZG8oKVxuXG4gIHJlZG86IC0+XG4gICAgQHByb3BzLmhpc3RvcnkucmVkbygpXG4iLCJtb2R1bGUuZXhwb3J0cyA9XG5cbiAgZ2V0SW5pdGlhbFN0YXRlOiAtPlxuICAgIGhlaWdodDogMFxuICAgIHdpZHRoOiAwXG5cbiAgdXBkYXRlRGltZW5zaW9uczogKGUpIC0+XG4gICAgZWwgPSBAcmVmcy5jb250YWluZXIuZ2V0RE9NTm9kZSgpXG5cbiAgICBAc2V0U3RhdGVcbiAgICAgIHdpZHRoOiBlbC5jbGllbnRXaWR0aFxuICAgICAgaGVpZ2h0OiBlbC5jbGllbnRIZWlnaHRcblxuICBjb21wb25lbnREaWRNb3VudDogLT5cbiAgICBAdXBkYXRlRGltZW5zaW9ucygpXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgJ3Jlc2l6ZScsIEB1cGRhdGVEaW1lbnNpb25zXG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQ6IC0+XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIgJ3Jlc2l6ZScsIEB1cGRhdGVEaW1lbnNpb25zXG4iLCJtb2R1bGUuZXhwb3J0cyA9IFxuXG4gIGRyYWdTdGFydDogKGUpIC0+XG4gICAgQHByb3BzLnVwZGF0ZURyYWdnaW5nIHBhcnNlSW50IGUuY3VycmVudFRhcmdldC5kYXRhc2V0LmlkXG4gICAgQHByb3BzLnNlbGVjdFRyYWNrIHBhcnNlSW50IGUuY3VycmVudFRhcmdldC5kYXRhc2V0LmlkXG4gXG4gICAgZS5kYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dlZCA9ICdtb3ZlJ1xuICAgIGUuZGF0YVRyYW5zZmVyLnNldERhdGEgJ3RleHQvaHRtbCcsIG51bGxcblxuICBkcmFnRW5kOiAtPlxuICAgIEBwcm9wcy51cGRhdGVEcmFnZ2luZyBudWxsXG5cbiAgZHJhZ092ZXI6IChlKSAtPlxuICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIG92ZXIgPSBlLmN1cnJlbnRUYXJnZXRcbiAgICByZWxYID0gZS5jbGllbnRYIC0gb3Zlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0XG4gICAgcmVsWSA9IGUuY2xpZW50WSAtIG92ZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wXG4gICAgaGVpZ2h0ID0gb3Zlci5vZmZzZXRIZWlnaHQgLyAyXG4gICAgYXBwZW5kID0gcmVsWSA+IGhlaWdodFxuXG4gICAgZnJvbSA9IEBwcm9wcy5kcmFnZ2luZ1xuICAgIHRvID0gTnVtYmVyIG92ZXIuZGF0YXNldC5pZFxuICAgIHRvICs9IDEgaWYgYXBwZW5kXG4gICAgdG8gLT0gMSBpZiBmcm9tIDwgdG9cblxuICAgIHJldHVybiBpZiBmcm9tID09IHRvXG5cbiAgICBpdGVtcyA9IEBwcm9wcy5pdGVtcy5nZXQoKS5zbGljZSAwXG4gICAgaXRlbXMuc3BsaWNlIHRvLCAwLCBpdGVtcy5zcGxpY2UoZnJvbSwgMSlbMF1cblxuICAgIEBwcm9wcy5pdGVtcy5zZXQgW10sIGl0ZW1zXG5cbiAgICBAcHJvcHMudXBkYXRlRHJhZ2dpbmcgdG9cbiAgICBAcHJvcHMuc2VsZWN0VHJhY2sgdG9cblxuICBpc0RyYWdnaW5nOiAtPlxuICAgIEBwcm9wcy5kcmFnZ2luZyA9PSBAcHJvcHMuaW5kZXhcbiIsIm1vZHVsZS5leHBvcnRzID1cbiAgXG4gIHVwZGF0ZTogKHByb3AsIHByZSkgLT5cbiAgICAodmFsdWUpID0+XG4gICAgICBvYmogPSB7fVxuICAgICAgb2JqW3Byb3BdID0gaWYgcHJlIHRoZW4gcHJlKHZhbHVlKSBlbHNlIHZhbHVlXG4gICAgICBAc2V0U3RhdGUgb2JqXG5cbiAgdXBkYXRlVG86ICh2YWx1ZXMpIC0+XG4gICAgPT4gQHNldFN0YXRlIHZhbHVlc1xuIiwiIyBBIHJlYWN0IGNvbXBvbmVudCByZXByZXNlbnRpbmcgYSBtb2RhbCBhbmQgaXRzIGJhY2tkcm9wXG5cblJlYWN0ID0gcmVxdWlyZSAncmVhY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3QuY3JlYXRlQ2xhc3NcblxuICByZW5kZXI6IC0+XG4gICAgUmVhY3QuRE9NLmRpdihudWxsLCBcbiAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwibW9kYWwtYmFja2Ryb3BcIn0pLCBcbiAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwibW9kYWwtYm9keVwifSwgXG4gICAgICAgIChAcHJvcHMuY2hpbGRyZW4pXG4gICAgICApXG4gICAgKSIsIiMgdWkgY29udHJvbHMgZm9yIGFuIG9zY2lsbGF0b3IsIGV4cGVjdHMgdHdvIHByb3BzICdvc2MnLCBhIGN1cnNvciB0byBhblxuIyBvc2NpbGxhdG9yIG9iamVjdCB7d2F2ZWZvcm0sIGxldmVsLCBwaXRjaCwgdHVuZX0sIGFuZCBhIGxhYmVsXG5cblJlYWN0ID0gcmVxdWlyZSAncmVhY3QnXG5DaG9vc2VyID0gcmVxdWlyZSAnLi9jaG9vc2VyJ1xuS25vYiA9IHJlcXVpcmUgJy4va25vYidcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdC5jcmVhdGVDbGFzc1xuXG4gIHByb3BUeXBlczpcbiAgICBvc2M6IFJlYWN0LlByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZFxuICAgIGxhYmVsOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWRcblxuICByZW5kZXI6IC0+XG4gICAgb3NjID0gQHByb3BzLm9zY1xuXG4gICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJ1aSBvc2NpbGxhdG9yXCJ9LCBcbiAgICAgIENob29zZXIoe1wib3B0aW9uc1wiOiAoWydzaW5lJywnc3F1YXJlJywnc2F3J10pLCBcInZhbHVlXCI6IChvc2MuZ2V0ICd3YXZlZm9ybScpLCBcIm9uQ2hhbmdlXCI6IChvc2MuYmluZCAnd2F2ZWZvcm0nKX0pLCBcbiAgICAgIEtub2Ioe1wibGFiZWxcIjogXCJMZXZlbFwiLCBcInZhbHVlXCI6IChvc2MuZ2V0ICdsZXZlbCcpLCBcIm9uQ2hhbmdlXCI6IChvc2MuYmluZCAnbGV2ZWwnKX0pLCBcbiAgICAgIEtub2Ioe1wibGFiZWxcIjogXCJQaXRjaFwiLCBcInZhbHVlXCI6IChvc2MuZ2V0ICdwaXRjaCcpLCBcIm9uQ2hhbmdlXCI6IChvc2MuYmluZCAncGl0Y2gnKX0pLCBcbiAgICAgIEtub2Ioe1wibGFiZWxcIjogXCJUdW5lXCIsIFwidmFsdWVcIjogKG9zYy5nZXQgJ3R1bmUnKSwgXCJvbkNoYW5nZVwiOiAob3NjLmJpbmQgJ3R1bmUnKX0pLCBcbiAgICAgIFJlYWN0LkRPTS5sYWJlbChudWxsLCAoQHByb3BzLmxhYmVsKSlcbiAgICApXG4iLCIjIFRoaXMgY29tcG9uZW50IHJlcHJlc2VudHMgYSBwaWFubyByb2xsIHN0eWxlIHNlcXVlbmNlIGVkaXRvciwgcmVuZGVyZWQgdXNpbmdcbiMgU1ZHLiAgSXQgcmVxdWlyZXMgdHdvIHByb3BzIC0gJ3NvbmcnLCBhIGN1cnNvciB0byB0aGUgcm9vdCBzb25nIG9iamVjdCwgYW5kXG4jICdzZXF1ZW5jZScsIGEgc2Vjb25kIGN1cnNvciB0byBzZXF1ZW5jZSBpdCB3aWxsIGVkaXQuXG4jXG4jIFVzZXIgaW50ZXJhY3Rpb24gZnJvbSBtb3VzZSBhbmQga2V5Ym9hcmQgaXMgc3BsaXQgaW50byB0aGUgbWl4aW5zXG4jICdLZXlib2FyZEludGVyYWN0aW9uJyBhbmQgJ01vdXNlSW50ZXJhY3Rpb24nLiAgUmVuZGVyaW5nIGlzIHNwbGl0IGludG9cbiMgbXVsdGlwbGUgc3ViY29tcG9uZW50czogJ0dyaWRMaW5lcycsICdLZXlzJywgJ05vdGVzJywgJ1BsYXliYWNrTWFya2VyJywgYW5kXG4jICdTZWxlY3Rpb24nXG4jXG4jIFRoZSBQaWFub1JvbGwgd2F0Y2hlcyBhbmQgcHJldmVudHMgZGVmYXVsdCBvbiBzY3JvbGwgZXZlbnRzLCBpbnN0ZWFkIGtlZXBpbmdcbiMgc2Nyb2xsIHBvc2l0aW9uIGluIGl0cyBzdGF0ZSAtIHRoaXMgYWxsb3dzIGl0IHRvIHF1YW50aXplIHNjcm9sbGluZyB0byBhIHdob2xlXG4jIG51bWJlciBvZiBub3RlcyBhbmQgYmVhdCBwb3NpdGlvbnMsIGFuZCB0byByZW5kZXIgb25seSBlbGVtZW50cyB2aXNpYmxlIG9uXG4jIHNjcmVlbi4gIFRoaXMgY29kZSBmb3Igc2Nyb2xsaW5nIGFuZCBzY2FsaW5nIHRoZSB2aWV3cG9ydCBpcyBpbiB0aGUgbWl4aW5cbiMgJ092ZXJyaWRlU2Nyb2xsaW5nJy5cblxuUmVhY3QgPSByZXF1aXJlICdyZWFjdCdcblNpemVNZWFzdXJhYmxlID0gcmVxdWlyZSAnLi9taXhpbnMvc2l6ZV9tZWFzdXJhYmxlJ1xuRHJhZ2dhYmxlID0gcmVxdWlyZSAnLi9taXhpbnMvZHJhZ2dhYmxlJ1xuXG5PdmVycmlkZVNjcm9sbGluZyA9IHJlcXVpcmUgJy4vcGlhbm9fcm9sbC9taXhpbnMvb3ZlcnJpZGVfc2Nyb2xsaW5nJ1xuTW91c2VJbnRlcmFjdGlvbiA9IHJlcXVpcmUgJy4vcGlhbm9fcm9sbC9taXhpbnMvbW91c2VfaW50ZXJhY3Rpb24nXG5LZXlib2FyZEludGVyYWN0aW9uID0gcmVxdWlyZSAnLi9waWFub19yb2xsL21peGlucy9rZXlib2FyZF9pbnRlcmFjdGlvbidcblxuU2NhbGVIYW5kbGUgPSByZXF1aXJlICcuL3NjYWxlX2hhbmRsZSdcbkdyaWRMaW5lcyA9IHJlcXVpcmUgJy4vcGlhbm9fcm9sbC9ncmlkX2xpbmVzJ1xuS2V5cyA9IHJlcXVpcmUgJy4vcGlhbm9fcm9sbC9rZXlzJ1xuTm90ZXMgPSByZXF1aXJlICcuL3BpYW5vX3JvbGwvbm90ZXMnXG5QbGF5YmFja01hcmtlciA9IHJlcXVpcmUgJy4vcGlhbm9fcm9sbC9wbGF5YmFja19tYXJrZXInXG5TZWxlY3Rpb24gPSByZXF1aXJlICcuL3BpYW5vX3JvbGwvc2VsZWN0aW9uJ1xuXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3QuY3JlYXRlQ2xhc3NcblxuICBtaXhpbnM6IFtcbiAgICBTaXplTWVhc3VyYWJsZVxuICAgIERyYWdnYWJsZVxuICAgIE92ZXJyaWRlU2Nyb2xsaW5nXG4gICAgTW91c2VJbnRlcmFjdGlvblxuICAgIEtleWJvYXJkSW50ZXJhY3Rpb25cbiAgICBSZWFjdC5hZGRvbnMuUHVyZVJlbmRlck1peGluXG4gIF1cblxuICBwcm9wVHlwZXM6XG4gICAgZGF0YTogUmVhY3QuUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkXG4gICAgc2VxdWVuY2U6IFJlYWN0LlByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZFxuXG4gIGdldEluaXRpYWxTdGF0ZTogLT5cblxuICAgICMgYW4gYXJyYXkgb2Ygbm90ZSBpZHMgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgbm90ZXNcbiAgICBzZWxlY3RlZE5vdGVzOiBbXVxuXG4gICAgIyBtb3ZlZCBub3RlcyB3aWxsIGJlIHF1YW50aXplZCB0byAxL0BzdGF0ZS5xdWFuaXRpemF0aW9uIGJlYXRzXG4gICAgcXVhbnRpemF0aW9uOiA0XG5cbiAgICAjIHNob3VsZCBtYXRjaCB0aGUgJGxpbmUtd2lkdGggYW5kICRtYXJnaW4gc2FzcyB2YXJpYWJsZXNcbiAgICBsaW5lV2lkdGg6IDEuNVxuXG4gICAgIyB3aWR0aCBvZiBrZXkgbWFya2Vyc1xuICAgIGtleVdpZHRoOiA0MFxuXG4gICAgIyBtYXhpbXVtIHdpZHRoIGZyb20gdGhlIGxlZnQvcmlnaHQgZWRnZSBvZiBhIG5vdGUgd2hlcmUgYSBkcmFnIHdpbGwgcmVzaXplXG4gICAgIyByYXRoZXIgdGhhbiB0cmFuc2xhdGUgdGhlIG5vdGVcbiAgICByZXNpemVIYW5kbGVXaWR0aDogMTBcblxuICAjIHVwZGF0ZSB0aGUgbG9vcCBzaXplIG9uIHRoZSBjdXJyZW50IHNlcXVlbmNlIGFuZCBzY2FsZSB0aGUgdmlld3BvcnQgdG8gbWF0Y2hcbiAgdXBkYXRlTG9vcFNpemU6IChlKSAtPlxuICAgIHZhbHVlID0gcGFyc2VGbG9hdCBlLnRhcmdldC52YWx1ZVxuICAgIEBwcm9wcy5zZXF1ZW5jZS5zZXQgJ2xvb3BTaXplJywgdmFsdWVcbiAgICBAc2V0U3RhdGUgeFNjYWxlOiB2YWx1ZVxuXG4gICMgdXBkYXRlIHRoZSBjdXJyZW50IHF1YW50aXphdGlvbiBzZXR0aW5nc1xuICB1cGRhdGVRdWFudGl6YXRpb246IChlKSAtPlxuICAgIHZhbHVlID0gcGFyc2VGbG9hdCBlLnRhcmdldC52YWx1ZVxuICAgIEBzZXRTdGF0ZSBxdWFudGl6YXRpb246IHZhbHVlXG5cbiAgIyB1cGRhdGUgdGhlIHZpZXdwb3J0IHpvb20gaW4gdGhlIHggZGltZW5zaW9uIC0gd2hlbiB0aGUgem9vbSBpbmNyZWFzZXMsIGlmXG4gICMgbmVlZGVkLCB1cGRhdGUgdGhlIHNjcm9sbCBwb3NpdGlvbiB0byBrZWVwIHRoZSB2aXNpYmxlIGFyZWEgd2l0aGluIHRoZVxuICAjIGJvdW5kcyBvZiB0aGUgc2VxdWVuY2UgbG9vcCBzaXplXG4gIHVwZGF0ZVhTY2FsZTogKHNjYWxlKSAtPlxuICAgIGxvb3BTaXplID0gQHByb3BzLnNlcXVlbmNlLmdldCAnbG9vcFNpemUnXG4gICAgeFNjYWxlID0gTWF0aC5yb3VuZChzY2FsZSAqIEBzdGF0ZS5xdWFudGl6YXRpb24pIC8gQHN0YXRlLnF1YW50aXphdGlvblxuICAgIHhTY2FsZSA9IE1hdGgubWluIGxvb3BTaXplLCB4U2NhbGVcblxuICAgIHhTY3JvbGwgPSBNYXRoLm1pbiBAc3RhdGUueFNjcm9sbCwgbG9vcFNpemUgLSB4U2NhbGVcblxuICAgIEBzZXRTdGF0ZSB7eFNjYWxlLCB4U2Nyb2xsfVxuXG4gICMgdXBkYXRlIHRoZSB2aWV3cG9ydCB6b29tIGluIHRoZSB5IGRpbWVuc2lvbiAtIGlmIG5lZWRlZCB1cGRhdGUgdGhlIHNjcm9sbFxuICAjIHBvc2l0aW9uIHRvIGF2b2lkIGRpc3BsYXlpbmcgbm90ZXMgb3V0c2lkZSBvZiB0aGUgcmFuZ2UgYWxsb3dlZCBieSBtaWRpXG4gIHVwZGF0ZVlTY2FsZTogKHNjYWxlKSAtPlxuICAgIHlTY2FsZSA9IE1hdGgucm91bmQgc2NhbGVcblxuICAgIHlTY3JvbGwgPSBNYXRoLm1pbiBAc3RhdGUueVNjcm9sbCwgMTI4IC0gQHN0YXRlLnlTY2FsZVxuXG4gICAgQHNldFN0YXRlIHt5U2NhbGUsIHlTY3JvbGx9XG5cblxuICAjIHVwZGF0ZSBub3RlcyBnaXZlbiBhbiBtYXAgb2YgY2hhbmdlcyB7aWQ6IHtrZXksIHN0YXJ0LCBsZW5ndGh9fVxuICAjIGNoYW5nZXMgYXJlIG1lcmdlZCBpbnRvIGV4aXN0aW5nIG5vdGVzIGJ5IGlkLCB3aXRoIGFueSBrZXlzIHByZXNlbnQgaW4gdGhlXG4gICMgdmFsdWVzIG9uIHRoZSBjaGFuZ2VzIG9iamVjdCBvdmVyd2l0aW5nIHRoZSB2YWx1ZXMgZm9yIHRoYXQgbm90ZSB3aXRoXG4gICMgbWF0Y2hpbmcgaWRcblxuICAjISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISFcbiAgIyB0aGlzIHNob3VsZCBiZSByZWZhY3RvcmVkIHRvICd1cGRhdGVOb3RlczogKGlkcywgZGVsdGEpIC0+JyBzbyB0aGF0IG5vdGVzXG4gICMgY2FuIG1vdmUgYXMgZmFyIGFzIHBvc3NpYmxlIHdoZW4geW91IGF0dGVtcHQgdG8gbW92ZSBhbiBvY3RhdmUgbmVhciB0aGUgZWRnZVxuICAjISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISFcblxuICB1cGRhdGVOb3RlczogKGNoYW5nZXMpIC0+XG4gICAgbm90ZXMgPSBAcHJvcHMuc2VxdWVuY2UuZ2V0ICdub3RlcydcbiAgICBsb29wU2l6ZSA9IEBwcm9wcy5zZXF1ZW5jZS5nZXQgJ2xvb3BTaXplJ1xuXG4gICAgY2hhbmdlZE5vdGVzID0gT2JqZWN0LmtleXMoY2hhbmdlcykubWFwIChpZCkgPT5cbiAgICAgIGtleTogaWYgY2hhbmdlc1tpZF0ua2V5PyB0aGVuIGNoYW5nZXNbaWRdLmtleSBlbHNlIG5vdGVzW2lkXS5rZXlcbiAgICAgIHN0YXJ0OiBpZiBjaGFuZ2VzW2lkXS5zdGFydD8gdGhlbiBjaGFuZ2VzW2lkXS5zdGFydCBlbHNlIG5vdGVzW2lkXS5zdGFydFxuICAgICAgbGVuZ3RoOiBpZiBjaGFuZ2VzW2lkXS5sZW5ndGg/IHRoZW4gY2hhbmdlc1tpZF0ubGVuZ3RoIGVsc2Ugbm90ZXNbaWRdLmxlbmd0aFxuXG4gICAga2V5cyA9IGNoYW5nZWROb3Rlcy5tYXAgKG5vdGUpIC0+IG5vdGUua2V5XG4gICAgc3RhcnRzID0gY2hhbmdlZE5vdGVzLm1hcCAobm90ZSkgLT4gbm90ZS5zdGFydFxuICAgIGVuZHMgPSBjaGFuZ2VkTm90ZXMubWFwIChub3RlKSAtPiBub3RlLnN0YXJ0ICsgbm90ZS5sZW5ndGhcblxuICAgIG1pbktleSA9IE1hdGgubWluLmFwcGx5IG51bGwsIGtleXNcbiAgICBtYXhLZXkgPSBNYXRoLm1heC5hcHBseSBudWxsLCBrZXlzXG4gICAgbWluU3RhcnQgPSBNYXRoLm1pbi5hcHBseSBudWxsLCBzdGFydHNcbiAgICBtYXhFbmQgPSBNYXRoLm1heC5hcHBseSBudWxsLCBlbmRzXG5cbiAgICAjIHByZXZlbnQgbm90ZXMgZnJvbSBiZWluZyBtb3ZlZCBvdXQgb2YgdGhlIGF2YWlsYWJsZSByYW5nZVxuXG4gICAgcmV0dXJuIGZhbHNlIGlmIG1pbktleSA8IDAgb3IgbWF4S2V5ID4gMTI3XG4gICAgcmV0dXJuIGZhbHNlIGlmIG1pblN0YXJ0IDwgMCBvciBtYXhFbmQgPiBsb29wU2l6ZVxuXG4gICAgIyB1cGRhdGUgc2Nyb2xsIHNvIG5vdGVzIHJlbWFpbiBvbiBzY3JlZW5cblxuICAgIHN0YXRlQ2hhbmdlcyA9IHt9XG5cbiAgICBpZiBtaW5LZXkgPCBAc3RhdGUueVNjcm9sbCBhbmQgbWF4S2V5IDw9IEBzdGF0ZS55U2Nyb2xsICsgQHN0YXRlLnlTY2FsZVxuICAgICAgc3RhdGVDaGFuZ2VzLnlTY3JvbGwgPSBtaW5LZXlcblxuICAgIGlmIG1heEtleSA+PSBAc3RhdGUueVNjcm9sbCArIEBzdGF0ZS55U2NhbGUgYW5kIG1pbktleSA+IEBzdGF0ZS55U2Nyb2xsXG4gICAgICBzdGF0ZUNoYW5nZXMueVNjcm9sbCA9IG1heEtleSAtIEBzdGF0ZS55U2NhbGUgKyAxXG5cbiAgICBpZiBtaW5TdGFydCA8IEBzdGF0ZS54U2Nyb2xsIGFuZCBtYXhFbmQgPD0gQHN0YXRlLnhTY3JvbGwgKyBAc3RhdGUueFNjYWxlXG4gICAgICBzdGF0ZUNoYW5nZXMueFNjcm9sbCA9IG1pblN0YXJ0XG5cbiAgICBpZiBtYXhFbmQgPj0gQHN0YXRlLnhTY3JvbGwgKyBAc3RhdGUueFNjYWxlIGFuZCBtaW5TdGFydCA+IEBzdGF0ZS54U2Nyb2xsXG4gICAgICBzdGF0ZUNoYW5nZXMueFNjcm9sbCA9IG1heEVuZCAtIEBzdGF0ZS54U2NhbGVcblxuICAgIEBwcm9wcy5zZXF1ZW5jZS5tZXJnZSBub3RlczogY2hhbmdlcywgdHJ1ZVxuICAgIEBzZXRTdGF0ZSBzdGF0ZUNoYW5nZXNcblxuXG4gIHJlbmRlcjogLT5cbiAgICBvdXRlclN0eWxlID1cbiAgICAgIHdpZHRoOiBAc3RhdGUud2lkdGggKyAyICogQHN0YXRlLnNjcm9sbFBhZGRpbmdcbiAgICAgIGhlaWdodDogQHN0YXRlLmhlaWdodCArIDIgKiBAc3RhdGUuc2Nyb2xsUGFkZGluZ1xuXG4gICAgaW5uZXJTdHlsZSA9XG4gICAgICB0b3A6IEBzdGF0ZS5zY3JvbGxQYWRkaW5nXG4gICAgICBsZWZ0OiBAc3RhdGUuc2Nyb2xsUGFkZGluZ1xuXG4gICAgZ3JpZFdpZHRoID0gTWF0aC5tYXggMCwgQHN0YXRlLndpZHRoIC0gQHN0YXRlLmtleVdpZHRoXG5cbiAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcInVpIHBpYW5vLXJvbGxcIn0sIFxuICAgICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJib2R5XCIsIFwicmVmXCI6ICdjb250YWluZXInLCBcIm9uU2Nyb2xsXCI6IChAb3ZlcnJpZGVTY3JvbGxpbmcpfSwgXG4gICAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwib3V0ZXJcIiwgXCJzdHlsZVwiOiAob3V0ZXJTdHlsZSl9LCBcbiAgICAgICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcImlubmVyXCIsIFwic3R5bGVcIjogKGlubmVyU3R5bGUpfSwgXG4gICAgICAgICAgICBLZXlzKHsgXFxcbiAgICAgICAgICAgICAgXCJ3aWR0aFwiOiAoQHN0YXRlLmtleVdpZHRoIC0gQHN0YXRlLmxpbmVXaWR0aCksICBcXFxuICAgICAgICAgICAgICBcImhlaWdodFwiOiAoQHN0YXRlLmhlaWdodCksICBcXFxuICAgICAgICAgICAgICBcInlTY3JvbGxcIjogKEBzdGF0ZS55U2Nyb2xsKSwgIFxcXG4gICAgICAgICAgICAgIFwieVNjYWxlXCI6IChAc3RhdGUueVNjYWxlKSwgIFxcXG4gICAgICAgICAgICAgIFwia2V5V2lkdGhcIjogKEBzdGF0ZS5rZXlXaWR0aCksICBcXFxuICAgICAgICAgICAgICBcIm9uQ2xpY2tcIjogKEBvbkNsaWNrS2V5cylcbiAgICAgICAgICAgIH0pLCBcbiAgICAgICAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6ICdncmlkJywgXCJyZWZcIjogJ2dyaWQnfSwgXG4gICAgICAgICAgICAgIFJlYWN0LkRPTS5zdmcoeyBcXFxuICAgICAgICAgICAgICAgIFwid2lkdGhcIjogKGdyaWRXaWR0aCksICBcXFxuICAgICAgICAgICAgICAgIFwiaGVpZ2h0XCI6IChAc3RhdGUuaGVpZ2h0KSwgIFxcXG4gICAgICAgICAgICAgICAgXCJvbk1vdXNlRG93blwiOiAoQG9uTW91c2VEb3duR3JpZCksICBcXFxuICAgICAgICAgICAgICAgIFwib25Nb3VzZVVwXCI6IChAb25Nb3VzZVVwR3JpZCksICBcXFxuICAgICAgICAgICAgICAgIFwib25DbGlja1wiOiAoQG9uQ2xpY2tHcmlkKSwgIFxcXG4gICAgICAgICAgICAgICAgXCJvbkRvdWJsZUNsaWNrXCI6IChAb25Eb3VibGVDbGlja0dyaWQpXG4gICAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgICAgIFBsYXliYWNrTWFya2VyKHsgXFxcbiAgICAgICAgICAgICAgICAgIFwicG9zaXRpb25cIjogKEBwcm9wcy5kYXRhLmdldCAncG9zaXRpb24nKSwgIFxcXG4gICAgICAgICAgICAgICAgICBcImxvb3BTaXplXCI6IChAcHJvcHMuc2VxdWVuY2UuZ2V0ICdsb29wU2l6ZScpLCAgXFxcbiAgICAgICAgICAgICAgICAgIFwid2lkdGhcIjogKGdyaWRXaWR0aCksICBcXFxuICAgICAgICAgICAgICAgICAgXCJoZWlnaHRcIjogKEBzdGF0ZS5oZWlnaHQpLCAgXFxcbiAgICAgICAgICAgICAgICAgIFwieFNjcm9sbFwiOiAoQHN0YXRlLnhTY3JvbGwpLCAgXFxcbiAgICAgICAgICAgICAgICAgIFwieFNjYWxlXCI6IChAc3RhdGUueFNjYWxlKSwgIFxcXG4gICAgICAgICAgICAgICAgICBcInF1YW50aXphdGlvblwiOiAoQHN0YXRlLnF1YW50aXphdGlvbilcbiAgICAgICAgICAgICAgICB9KSwgXG4gICAgICAgICAgICAgICAgR3JpZExpbmVzKHsgXFxcbiAgICAgICAgICAgICAgICAgIFwid2lkdGhcIjogKGdyaWRXaWR0aCksICBcXFxuICAgICAgICAgICAgICAgICAgXCJoZWlnaHRcIjogKEBzdGF0ZS5oZWlnaHQpLCAgXFxcbiAgICAgICAgICAgICAgICAgIFwieVNjYWxlXCI6IChAc3RhdGUueVNjYWxlKSwgIFxcXG4gICAgICAgICAgICAgICAgICBcInhTY2FsZVwiOiAoQHN0YXRlLnhTY2FsZSksICBcXFxuICAgICAgICAgICAgICAgICAgXCJ5U2Nyb2xsXCI6IChAc3RhdGUueVNjcm9sbCksICBcXFxuICAgICAgICAgICAgICAgICAgXCJ4U2Nyb2xsXCI6IChAc3RhdGUueFNjcm9sbCksICBcXFxuICAgICAgICAgICAgICAgICAgXCJxdWFudGl6YXRpb25cIjogKEBzdGF0ZS5xdWFudGl6YXRpb24pXG4gICAgICAgICAgICAgICAgfSksIFxuICAgICAgICAgICAgICAgIFNlbGVjdGlvbih7IFxcXG4gICAgICAgICAgICAgICAgICBcInNlbGVjdGlvbk9yaWdpblwiOiAoQHN0YXRlLnNlbGVjdGlvbk9yaWdpbiksICBcXFxuICAgICAgICAgICAgICAgICAgXCJzZWxlY3Rpb25Qb3NpdGlvblwiOiAoQHN0YXRlLnNlbGVjdGlvblBvc2l0aW9uKSwgIFxcXG4gICAgICAgICAgICAgICAgICBcIndpZHRoXCI6IChncmlkV2lkdGgpLCAgXFxcbiAgICAgICAgICAgICAgICAgIFwiaGVpZ2h0XCI6IChAc3RhdGUuaGVpZ2h0KSwgIFxcXG4gICAgICAgICAgICAgICAgICBcInlTY2FsZVwiOiAoQHN0YXRlLnlTY2FsZSksICBcXFxuICAgICAgICAgICAgICAgICAgXCJ4U2NhbGVcIjogKEBzdGF0ZS54U2NhbGUpLCAgXFxcbiAgICAgICAgICAgICAgICAgIFwieVNjcm9sbFwiOiAoQHN0YXRlLnlTY3JvbGwpLCAgXFxcbiAgICAgICAgICAgICAgICAgIFwieFNjcm9sbFwiOiAoQHN0YXRlLnhTY3JvbGwpLCAgXFxcbiAgICAgICAgICAgICAgICAgIFwicXVhbnRpemF0aW9uXCI6IChAc3RhdGUucXVhbnRpemF0aW9uKVxuICAgICAgICAgICAgICAgIH0pLCBcbiAgICAgICAgICAgICAgICBOb3Rlcyh7IFxcXG4gICAgICAgICAgICAgICAgICBcIm5vdGVzXCI6IChAcHJvcHMuc2VxdWVuY2UuZ2V0ICdub3RlcycpLCAgXFxcbiAgICAgICAgICAgICAgICAgIFwic2VsZWN0ZWROb3Rlc1wiOiAoQHN0YXRlLnNlbGVjdGVkTm90ZXMpLCAgXFxcbiAgICAgICAgICAgICAgICAgIFwiZHJhZ09yaWdpbmFsVmFsdWVcIjogKEBvcmlnaW5hbFZhbHVlKSwgIFxcXG4gICAgICAgICAgICAgICAgICBcInRyYW5zbGF0ZVRhcmdldFwiOiAoQHN0YXRlLnRyYW5zbGF0ZVRhcmdldCksICBcXFxuICAgICAgICAgICAgICAgICAgXCJyZXNpemVUYXJnZXRcIjogKEBzdGF0ZS5yZXNpemVUYXJnZXQpLCAgXFxcbiAgICAgICAgICAgICAgICAgIFwid2lkdGhcIjogKGdyaWRXaWR0aCksICBcXFxuICAgICAgICAgICAgICAgICAgXCJoZWlnaHRcIjogKEBzdGF0ZS5oZWlnaHQpLCAgXFxcbiAgICAgICAgICAgICAgICAgIFwieVNjYWxlXCI6IChAc3RhdGUueVNjYWxlKSwgIFxcXG4gICAgICAgICAgICAgICAgICBcInhTY2FsZVwiOiAoQHN0YXRlLnhTY2FsZSksICBcXFxuICAgICAgICAgICAgICAgICAgXCJ5U2Nyb2xsXCI6IChAc3RhdGUueVNjcm9sbCksICBcXFxuICAgICAgICAgICAgICAgICAgXCJ4U2Nyb2xsXCI6IChAc3RhdGUueFNjcm9sbCksICBcXFxuICAgICAgICAgICAgICAgICAgXCJsaW5lV2lkdGhcIjogKEBzdGF0ZS5saW5lV2lkdGgpLCAgXFxcbiAgICAgICAgICAgICAgICAgIFwicXVhbnRpemF0aW9uXCI6IChAc3RhdGUucXVhbnRpemF0aW9uKSwgIFxcXG4gICAgICAgICAgICAgICAgICBcIm9uTW91c2VEb3duXCI6IChAb25Nb3VzZURvd25Ob3RlKSwgIFxcXG4gICAgICAgICAgICAgICAgICBcIm9uTW91c2VNb3ZlXCI6IChAb25Nb3VzZU1vdmVOb3RlKSwgIFxcXG4gICAgICAgICAgICAgICAgICBcIm9uTW91c2VPdXRcIjogKEBvbk1vdXNlT3V0Tm90ZSksICBcXFxuICAgICAgICAgICAgICAgICAgXCJvbkRvdWJsZUNsaWNrXCI6IChAb25Eb3VibGVDbGlja05vdGUpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgKSwgXG4gICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcInZpZXctY29udHJvbHNcIn0sIFxuICAgICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcInNldHRpbmdcIn0sIFxuICAgICAgICAgIFJlYWN0LkRPTS5sYWJlbChudWxsLCBcIkdyaWRcIiksIFxuICAgICAgICAgIFJlYWN0LkRPTS5zZWxlY3QoeyBcXFxuICAgICAgICAgICAgXCJ2YWx1ZVwiOiAoQHN0YXRlLnF1YW50aXphdGlvbiksICBcXFxuICAgICAgICAgICAgXCJvbkNoYW5nZVwiOiAoQHVwZGF0ZVF1YW50aXphdGlvbilcbiAgICAgICAgICB9LCBcbiAgICAgICAgICAgIFJlYWN0LkRPTS5vcHRpb24oe1widmFsdWVcIjogXCIxXCJ9LCBcIjFcIiksIFxuICAgICAgICAgICAgUmVhY3QuRE9NLm9wdGlvbih7XCJ2YWx1ZVwiOiBcIjJcIn0sIFwiMVxceDJGMlwiKSwgXG4gICAgICAgICAgICBSZWFjdC5ET00ub3B0aW9uKHtcInZhbHVlXCI6IFwiM1wifSwgXCIxXFx4MkYzXCIpLCBcbiAgICAgICAgICAgIFJlYWN0LkRPTS5vcHRpb24oe1widmFsdWVcIjogXCI0XCJ9LCBcIjFcXHgyRjRcIiksIFxuICAgICAgICAgICAgUmVhY3QuRE9NLm9wdGlvbih7XCJ2YWx1ZVwiOiBcIjZcIn0sIFwiMVxceDJGNlwiKSwgXG4gICAgICAgICAgICBSZWFjdC5ET00ub3B0aW9uKHtcInZhbHVlXCI6IFwiOFwifSwgXCIxXFx4MkY4XCIpLCBcbiAgICAgICAgICAgIFJlYWN0LkRPTS5vcHRpb24oe1widmFsdWVcIjogXCIxMlwifSwgXCIxXFx4MkYxMlwiKSwgXG4gICAgICAgICAgICBSZWFjdC5ET00ub3B0aW9uKHtcInZhbHVlXCI6IFwiMTZcIn0sIFwiMVxceDJGMTZcIilcbiAgICAgICAgICApXG4gICAgICAgICksIFxuICAgICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcInNldHRpbmdcIn0sIFxuICAgICAgICAgIFJlYWN0LkRPTS5sYWJlbChudWxsLCBcIkxlbmd0aFwiKSwgXG4gICAgICAgICAgUmVhY3QuRE9NLnNlbGVjdCh7IFxcXG4gICAgICAgICAgICBcInZhbHVlXCI6IChAcHJvcHMuc2VxdWVuY2UuZ2V0ICdsb29wU2l6ZScpLCAgXFxcbiAgICAgICAgICAgIFwib25DaGFuZ2VcIjogKEB1cGRhdGVMb29wU2l6ZSlcbiAgICAgICAgICB9LCBcbiAgICAgICAgICAgIFJlYWN0LkRPTS5vcHRpb24oe1widmFsdWVcIjogXCIxXCJ9LCBcIjFcIiksIFxuICAgICAgICAgICAgUmVhY3QuRE9NLm9wdGlvbih7XCJ2YWx1ZVwiOiBcIjJcIn0sIFwiMlwiKSwgXG4gICAgICAgICAgICBSZWFjdC5ET00ub3B0aW9uKHtcInZhbHVlXCI6IFwiNFwifSwgXCI0XCIpLCBcbiAgICAgICAgICAgIFJlYWN0LkRPTS5vcHRpb24oe1widmFsdWVcIjogXCI4XCJ9LCBcIjhcIiksIFxuICAgICAgICAgICAgUmVhY3QuRE9NLm9wdGlvbih7XCJ2YWx1ZVwiOiBcIjE2XCJ9LCBcIjE2XCIpLCBcbiAgICAgICAgICAgIFJlYWN0LkRPTS5vcHRpb24oe1widmFsdWVcIjogXCIzMlwifSwgXCIzMlwiKSwgXG4gICAgICAgICAgICBSZWFjdC5ET00ub3B0aW9uKHtcInZhbHVlXCI6IFwiNjRcIn0sIFwiNjRcIilcbiAgICAgICAgICApXG4gICAgICAgICksIFxuICAgICAgICBTY2FsZUhhbmRsZSh7IFxcXG4gICAgICAgICAgXCJtaW5cIjogKEBzdGF0ZS5taW5ZU2NhbGUpLCAgXFxcbiAgICAgICAgICBcIm1heFwiOiAoQHN0YXRlLm1heFlTY2FsZSksICBcXFxuICAgICAgICAgIFwidmFsdWVcIjogKEBzdGF0ZS55U2NhbGUpLCAgXFxcbiAgICAgICAgICBcIm9uQ2hhbmdlXCI6IChAdXBkYXRlWVNjYWxlKVxuICAgICAgICB9LCBcbiAgICAgICAgICBSZWFjdC5ET00uc3Bhbih7XCJjbGFzc05hbWVcIjogXCJpY29uIGljb24tYXJyb3ctdXBcIn0pLCBcbiAgICAgICAgICBSZWFjdC5ET00uc3Bhbih7XCJjbGFzc05hbWVcIjogXCJpY29uIGljb24tYXJyb3ctZG93blwifSlcbiAgICAgICAgKSwgXG4gICAgICAgIFNjYWxlSGFuZGxlKHsgXFxcbiAgICAgICAgICBcIm1pblwiOiAoQHN0YXRlLm1pblhTY2FsZSksICBcXFxuICAgICAgICAgIFwibWF4XCI6IChAc3RhdGUubWF4WFNjYWxlKSwgIFxcXG4gICAgICAgICAgXCJ2YWx1ZVwiOiAoQHN0YXRlLnhTY2FsZSksICBcXFxuICAgICAgICAgIFwib25DaGFuZ2VcIjogKEB1cGRhdGVYU2NhbGUpXG4gICAgICAgIH0sIFxuICAgICAgICAgIFJlYWN0LkRPTS5zcGFuKHtcImNsYXNzTmFtZVwiOiBcImljb24gaWNvbi1hcnJvdy1sZWZ0XCJ9KSwgXG4gICAgICAgICAgUmVhY3QuRE9NLnNwYW4oe1wiY2xhc3NOYW1lXCI6IFwiaWNvbiBpY29uLWFycm93LXJpZ2h0XCJ9KVxuICAgICAgICApXG4gICAgICApXG4gICAgKVxuIiwiUmVhY3QgPSByZXF1aXJlICdyZWFjdC9hZGRvbnMnXG5cbmtleVBhdHRlcm4gPSBbdHJ1ZSwgZmFsc2UsIHRydWUsIGZhbHNlLCB0cnVlLCB0cnVlLCBmYWxzZSwgdHJ1ZSwgZmFsc2UsIHRydWUsIGZhbHNlLCB0cnVlXVxuXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3QuY3JlYXRlQ2xhc3NcblxuICBtaXhpbnM6IFtcbiAgICBSZWFjdC5hZGRvbnMuUHVyZVJlbmRlck1peGluXG4gIF1cblxuICBwcm9wVHlwZXM6XG4gICAgd2lkdGg6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZFxuICAgIGhlaWdodDogUmVhY3QuUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkXG4gICAgeVNjYWxlOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWRcbiAgICB4U2NhbGU6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZFxuICAgIHlTY3JvbGw6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZFxuICAgIHhTY3JvbGw6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZFxuICAgIHF1YW50aXphdGlvbjogUmVhY3QuUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkXG5cbiAgcmVuZGVyOiAtPlxuICAgIHdpZHRoID0gQHByb3BzLndpZHRoXG4gICAgaGVpZ2h0ID0gQHByb3BzLmhlaWdodFxuICAgIHNxdWFyZUhlaWdodCA9IGhlaWdodCAvIEBwcm9wcy55U2NhbGVcbiAgICBxdWFudGl6YXRpb24gPSBAcHJvcHMucXVhbnRpemF0aW9uXG4gICAgY29scyA9IEBwcm9wcy54U2NhbGUgKiBxdWFudGl6YXRpb25cbiAgICBzcXVhcmVXaWR0aCA9IHdpZHRoIC8gY29sc1xuXG4gICAgZWxzID0gW11cblxuICAgIG1pblJvdyA9IEBwcm9wcy55U2Nyb2xsXG4gICAgbWF4Um93ID0gbWluUm93ICsgQHByb3BzLnlTY2FsZVxuICAgIHJvd3MgPSBbbWluUm93Li4ubWF4Um93XVxuXG4gICAgbWluQ29sID0gQHByb3BzLnhTY3JvbGwgKiBxdWFudGl6YXRpb25cbiAgICBtYXhDb2wgPSBtaW5Db2wgKyBAcHJvcHMueFNjYWxlICogcXVhbnRpemF0aW9uXG4gICAgY29scyA9IFttaW5Db2wuLi5tYXhDb2xdXG5cbiAgICAjIHJvdyBzaGFkaW5nXG4gICAgZm9yIHJvdywgaSBpbiByb3dzXG4gICAgICB1bmxlc3Mga2V5UGF0dGVybltyb3cgJSAxMl1cbiAgICAgICAgeSA9IGhlaWdodCAtIChpICsgMSkgKiBzcXVhcmVIZWlnaHRcbiAgICAgICAgZWxzLnB1c2ggUmVhY3QuRE9NLnJlY3Qoe1wia2V5XCI6ICgncycraSksIFwieFwiOiAoMCksIFwieVwiOiAoeSksIFwid2lkdGhcIjogKHdpZHRoKSwgXCJoZWlnaHRcIjogKHNxdWFyZUhlaWdodCksIFwiY2xhc3NOYW1lXCI6ICdzaGFkZSd9KVxuXG4gICAgIyBob3Jpem9udGFsIGxpbmVzIChzZXBhcmF0aW5nIGUgYW5kIGYpXG4gICAgZm9yIHJvdywgaSBpbiByb3dzXG4gICAgICBpZiByb3cgJSAxMiA9PSA1XG4gICAgICAgIHkgPSAocm93cy5sZW5ndGggLSBpKSAqIHNxdWFyZUhlaWdodFxuICAgICAgICBlbHMucHVzaCBSZWFjdC5ET00ubGluZSh7XCJrZXlcIjogKCdoJytpKSwgXCJ4MVwiOiAoMCksIFwieTFcIjogKHkpLCBcIngyXCI6ICh3aWR0aCksIFwieTJcIjogKHkpfSlcblxuICAgICMgdmVydGljYWwgbGluZXNcbiAgICBmb3IgY29sLCBpIGluIGNvbHNcbiAgICAgIHVubGVzcyBjb2wgJSBxdWFudGl6YXRpb24gPT0gMFxuICAgICAgICB4ID0gaSAqIHNxdWFyZVdpZHRoXG4gICAgICAgIGVscy5wdXNoIFJlYWN0LkRPTS5saW5lKHtcImtleVwiOiAoJ3YnK2kpLCBcIngxXCI6ICh4KSwgXCJ5MVwiOiAoMCksIFwieDJcIjogKHgpLCBcInkyXCI6IChoZWlnaHQpfSlcblxuICAgICMgc3Ryb25nIGhvcml6b250YWwgbGluZXMgKHNlcGFyYXRpbmcgYiBhbmQgYylcbiAgICBmb3Igcm93LCBpIGluIHJvd3NcbiAgICAgIGlmIHJvdyAlIDEyID09IDBcbiAgICAgICAgeSA9IChyb3dzLmxlbmd0aCAtIGkpICogc3F1YXJlSGVpZ2h0XG4gICAgICAgIGVscy5wdXNoIFJlYWN0LkRPTS5saW5lKHtcImtleVwiOiAoJ2hzJytpKSwgXCJ4MVwiOiAoMCksIFwieTFcIjogKHkpLCBcIngyXCI6ICh3aWR0aCksIFwieTJcIjogKHkpLCBcImNsYXNzTmFtZVwiOiAnc3Ryb25nJ30pXG5cbiAgICAjIHN0cm9uZyB2ZXJ0aWNhbCBsaW5lc1xuICAgIGZvciBjb2wsIGkgaW4gY29sc1xuICAgICAgaWYgaSAhPSAwIGFuZCBjb2wgJSBxdWFudGl6YXRpb24gPT0gMFxuICAgICAgICB4ID0gaSAqIHNxdWFyZVdpZHRoXG4gICAgICAgIGVscy5wdXNoIFJlYWN0LkRPTS5saW5lKHtcImtleVwiOiAoJ3ZzJytpKSwgXCJ4MVwiOiAoeCksIFwieTFcIjogKDApLCBcIngyXCI6ICh4KSwgXCJ5MlwiOiAoaGVpZ2h0KSwgXCJjbGFzc05hbWVcIjogJ3N0cm9uZyd9KVxuXG4gICAgUmVhY3QuRE9NLmcobnVsbCwgKGVscykpXG5cbiIsIlJlYWN0ID0gcmVxdWlyZSAncmVhY3QvYWRkb25zJ1xuXG5rZXlQYXR0ZXJuID0gW3RydWUsIGZhbHNlLCB0cnVlLCBmYWxzZSwgdHJ1ZSwgdHJ1ZSwgZmFsc2UsIHRydWUsIGZhbHNlLCB0cnVlLCBmYWxzZSwgdHJ1ZV1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0LmNyZWF0ZUNsYXNzXG5cbiAgbWl4aW5zOiBbXG4gICAgUmVhY3QuYWRkb25zLlB1cmVSZW5kZXJNaXhpblxuICBdXG5cbiAgcHJvcFR5cGVzOlxuICAgIGhlaWdodDogUmVhY3QuUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkXG4gICAgeVNjcm9sbDogUmVhY3QuUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkXG4gICAgeVNjYWxlOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWRcbiAgICBrZXlXaWR0aDogUmVhY3QuUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkXG5cbiAgcmVuZGVyOiAtPlxuICAgIGhlaWdodCA9IEBwcm9wcy5oZWlnaHRcbiAgICBrZXlIZWlnaHQgPSBoZWlnaHQgLyBAcHJvcHMueVNjYWxlXG4gICAga2V5V2lkdGggPSBAcHJvcHMua2V5V2lkdGhcblxuICAgIGVscyA9IFtdXG5cbiAgICBtaW5Sb3cgPSBAcHJvcHMueVNjcm9sbFxuICAgIG1heFJvdyA9IG1pblJvdyArIEBwcm9wcy55U2NhbGVcbiAgICByb3dzID0gW21pblJvdy4uLm1heFJvd11cblxuICAgICMga2V5c1xuICAgIGZvciByb3csIGkgaW4gcm93c1xuICAgICAgdW5sZXNzIGtleVBhdHRlcm5bcm93ICUgMTJdXG4gICAgICAgIHkgPSBoZWlnaHQgLSAoaSArIDEpICoga2V5SGVpZ2h0XG4gICAgICAgIHRleHQgPSBudWxsXG4gICAgICAgIGVscy5wdXNoIFJlYWN0LkRPTS5yZWN0KHtcImtleVwiOiAoJ2snICsgaSksIFwieFwiOiAoMCksIFwieVwiOiAoeSksIFwid2lkdGhcIjogKGtleVdpZHRoKSwgXCJoZWlnaHRcIjogKGtleUhlaWdodCl9KVxuXG4gICAgIyAjIGxpbmVzXG4gICAgIyBmb3Igcm93LCBpIGluIHJvd3NcbiAgICAjICAgeSA9IGkgKiBrZXlIZWlnaHRcbiAgICAjICAgZWxzLnB1c2ggPGxpbmUga2V5PXsnbCcgKyBpfSB4MT17MH0geTE9e3l9IHgyPXtrZXlXaWR0aH0geTI9e3l9Lz5cblxuICAgICMgdGV4dFxuICAgIGZvciByb3csIGkgaW4gcm93c1xuICAgICAgaWYgcm93ICUgMTIgPT0gMFxuICAgICAgICB5ID0gaGVpZ2h0IC0gKGkgKyAwLjUpICoga2V5SGVpZ2h0XG4gICAgICAgIHRleHQgPSBcIkMgI3tNYXRoLmZsb29yKHJvdyAvIDEyKSAtIDJ9XCJcbiAgICAgICAgZWxzLnB1c2ggUmVhY3QuRE9NLnRleHQoe1wia2V5XCI6ICgndCcgKyBpKSwgXCJ4XCI6IChrZXlXaWR0aCAtIDQpLCBcInlcIjogKHkpfSwgKHRleHQpKVxuXG4gICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogJ2tleXMnfSwgXG4gICAgICBSZWFjdC5ET00uc3ZnKHtcIndpZHRoXCI6IChrZXlXaWR0aCksIFwiaGVpZ2h0XCI6IChoZWlnaHQpLCBcIm9uQ2xpY2tcIjogKEBwcm9wcy5vbkNsaWNrKX0sIFxuICAgICAgICAoZWxzKVxuICAgICAgKVxuICAgIClcbiIsIiMgS2V5Ym9hcmQgaW50ZXJhY3Rpb24gZm9yIHRoZSBQaWFub1JvbGwgcmVhY3QgY29tcG9uZW50XG5cbktleWJvYXJkID0gcmVxdWlyZSAna2V5Ym9hcmRqcydcblxubW9kdWxlLmV4cG9ydHMgPVxuXG4gIGNvbXBvbmVudERpZE1vdW50OiAtPlxuICAgIEBrZXlCaW5kaW5ncyA9IFtcbiAgICAgIEtleWJvYXJkLm9uICdiYWNrc3BhY2UnLCBAb25CYWNrc3BhY2VLZXlcbiAgICAgIEtleWJvYXJkLm9uICdsZWZ0LCByaWdodCwgdXAsIGRvd24nLCBAb25BcnJvd0tleVxuICAgIF1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudDogLT5cbiAgICBiaW5kaW5nLmNsZWFyKCkgZm9yIGJpbmRpbmcgaW4gQGtleUJpbmRpbmdzXG5cbiAgb25CYWNrc3BhY2VLZXk6IChlKSAtPlxuICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIEBwcm9wcy5zZXF1ZW5jZS5iYXRjaGVkID0+XG4gICAgICBmb3IgaWQgaW4gQHN0YXRlLnNlbGVjdGVkTm90ZXNcbiAgICAgICAgQHByb3BzLnNlcXVlbmNlLmRlbGV0ZSBbJ25vdGVzJywgaWRdXG5cbiAgb25BcnJvd0tleTogKGUpIC0+XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG5cbiAgICBjaGFuZ2VzID0ge31cblxuICAgIGZvciBpZCBpbiBAc3RhdGUuc2VsZWN0ZWROb3Rlc1xuXG4gICAgICBub3RlID0gQHByb3BzLnNlcXVlbmNlLmdldCBbJ25vdGVzJywgaWRdXG5cbiAgICAgICMgbGVmdCBhcnJvd1xuICAgICAgaWYgZS5rZXlDb2RlIGlzIDM3XG4gICAgICAgIGNoYW5nZXNbaWRdID0gc3RhcnQ6IG5vdGUuc3RhcnQgLSAxIC8gQHN0YXRlLnF1YW50aXphdGlvblxuXG4gICAgICAjIHVwIGFycm93XG4gICAgICBlbHNlIGlmIGUua2V5Q29kZSBpcyAzOFxuICAgICAgICBkaXN0YW5jZSA9IGlmICdzaGlmdCcgaW4gS2V5Ym9hcmQuYWN0aXZlS2V5cygpIHRoZW4gMTIgZWxzZSAxXG4gICAgICAgIGNoYW5nZXNbaWRdID0ga2V5OiBub3RlLmtleSArIGRpc3RhbmNlXG5cbiAgICAgICMgcmlnaHQgYXJyb3dcbiAgICAgIGVsc2UgaWYgZS5rZXlDb2RlIGlzIDM5XG4gICAgICAgIGNoYW5nZXNbaWRdID0gc3RhcnQ6IG5vdGUuc3RhcnQgKyAxIC8gQHN0YXRlLnF1YW50aXphdGlvblxuXG4gICAgICAjIGRvd24gYXJyb3dcbiAgICAgIGVsc2UgaWYgZS5rZXlDb2RlIGlzIDQwXG4gICAgICAgIGRpc3RhbmNlID0gaWYgJ3NoaWZ0JyBpbiBLZXlib2FyZC5hY3RpdmVLZXlzKCkgdGhlbiAxMiBlbHNlIDFcbiAgICAgICAgY2hhbmdlc1tpZF0gPSBrZXk6IG5vdGUua2V5IC0gZGlzdGFuY2VcblxuICAgIEB1cGRhdGVOb3RlcyBjaGFuZ2VzXG4iLCIjIE1vdXNlIGludGVyYWN0aW9uIGZvciB0aGUgUGlhbm9Sb2xsIHJlYWN0IGNvbXBvbmVudFxuXG5LZXlib2FyZCA9IHJlcXVpcmUgJ2tleWJvYXJkanMnXG5Qb2ludGVyID0gcmVxdWlyZSAnLi4vLi4vLi4vdXRpbC9wb2ludGVyJ1xuY3VpZCA9IHJlcXVpcmUgJ2N1aWQnXG5cblxubW9kdWxlLmV4cG9ydHMgPVxuXG4gIGdldEluaXRpYWxTdGF0ZTogLT5cbiAgICAjIHN0YXRlIHVzZWQgZHVyaW5nIHNlbGVjdGlvbiAvIHJlc2l6ZSAvIHRyYW5zbGF0ZSBhY3Rpb25zXG4gICAgc2VsZWN0aW9uT3JpZ2luOiBudWxsXG4gICAgc2VsZWN0aW9uUG9zaXRpb246IG51bGxcbiAgICByZXNpemVUYXJnZXQ6IG51bGxcbiAgICByZXNpemVEaXJlY3Rpb246IG51bGxcbiAgICB0cmFuc2xhdGVUYXJnZXQ6IG51bGxcblxuICAjIGdpdmVuIGEgcG9zaXRpb24gd2l0aCB7eCx5fSB2YWx1ZXMgaW4gcGl4ZWxzIHJlbGF0aXZlIHRvIHRoZSB3aW5kb3csIHJldHVyblxuICAjIHtrZXksIHN0YXJ0fSB3aXRoIHZhbHVlcyBpbiBub3RlcyBhbmQgYmVhdHMgYmFzZWQgb24gdGhlIGN1cnJlbnQgem9vbSBhbmRcbiAgIyBzY3JvbGwgcG9zaXRpb25zIG9mIHRoZSBwaWFubyByb2xsXG4gIGdldFJlbGF0aXZlUG9zaXRpb246ICh7eCx5fSkgLT5cbiAgICB7dG9wLCBsZWZ0fSA9IEByZWZzLmdyaWQuZ2V0RE9NTm9kZSgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgaGVpZ2h0ID0gQHN0YXRlLmhlaWdodFxuICAgIHdpZHRoID0gQHN0YXRlLndpZHRoIC0gQHN0YXRlLmtleVdpZHRoXG5cbiAgICBrZXkgPSBNYXRoLmZsb29yKChoZWlnaHQgLSB5ICsgdG9wKSAvIGhlaWdodCAqIEBzdGF0ZS55U2NhbGUpICsgQHN0YXRlLnlTY3JvbGxcbiAgICBzdGFydCA9IE1hdGguZmxvb3IoKHggLSBsZWZ0KSAvIHdpZHRoICogQHN0YXRlLnhTY2FsZSAqIEBzdGF0ZS5xdWFudGl6YXRpb24pIC8gQHN0YXRlLnF1YW50aXphdGlvbiArIEBzdGF0ZS54U2Nyb2xsXG5cbiAgICB7a2V5LCBzdGFydH1cblxuICAjIHJldHVybiBhbiBhcnJheSBvZiBub3RlIGlkcywgcmVwcmVzZW50aW5nIG5vdGVzIGluIHRoZSBzcXVlbmNlIGludGVyc2VjdGluZ1xuICAjIGEgcmVjdGFuZ2xlIGRlZmluZWQgYnkgdGhlIGFyZ3VtZW50cyBmcm9tIHtrZXksIHN0YXJ0fSwgYW5kIHRvIHtrZXksIHN0YXJ0fVxuICBub3Rlc1NlbGVjdGVkQnk6IChmcm9tLCB0bykgLT5cbiAgICBtaW5LZXkgPSBNYXRoLm1pbiBmcm9tLmtleSwgdG8ua2V5XG4gICAgbWF4S2V5ID0gTWF0aC5tYXggZnJvbS5rZXksIHRvLmtleVxuICAgIG1pbkVuZCA9IE1hdGgubWluIGZyb20uc3RhcnQsIHRvLnN0YXJ0XG4gICAgbWF4U3RhcnQgPSBNYXRoLm1heCBmcm9tLnN0YXJ0LCB0by5zdGFydFxuXG4gICAgbm90ZXMgPSBbXVxuXG4gICAgZm9yIGlkLCB7a2V5LCBzdGFydCwgbGVuZ3RofSBvZiBAcHJvcHMuc2VxdWVuY2UuZ2V0ICdub3RlcydcblxuICAgICAgbm90ZXMucHVzaCBpZCBpZiAoXG4gICAgICAgIGtleSA+PSBtaW5LZXkgYW5kXG4gICAgICAgIGtleSA8PSBtYXhLZXkgYW5kXG4gICAgICAgIHN0YXJ0ICsgbGVuZ3RoID4gbWluRW5kIGFuZFxuICAgICAgICBzdGFydCA8PSBtYXhTdGFydFxuICAgICAgKVxuXG4gICAgbm90ZXNcblxuICAjIHRoaXMgZG9lc24ndCBkbyBhbnl0aGluZyB5ZXQsIGJ1dCBldmVudHVhbGx5IGl0IGNvdWxkIHBsYXkgdGhlIGNsaWNrZWQgbm90ZVxuICAjIG9yIGNvdWxkIHNlbGVjdCBhbGwgbm90ZXMgdy8gdGhlIGNsaWNrZWQga2V5XG4gIG9uQ2xpY2tLZXlzOiAoZSkgLT5cblxuICAjIGRlc2VsZWN0IGFueSBzZWxlY3RlZCBub3RlcyxcbiAgIyBzdGFydCBkcmFnIHNlbGVjdGlvblxuICBvbk1vdXNlRG93bkdyaWQ6IChlKSAtPlxuICAgIEBzZXRTdGF0ZSBzZWxlY3RlZE5vdGVzOiBbXSB1bmxlc3MgJ3NoaWZ0JyBpbiBLZXlib2FyZC5hY3RpdmVLZXlzKClcblxuICAgICMgaGFuZGxlIGRyYWcgc3RhcnRcbiAgICBAZHJhZ2dhYmxlT25Nb3VzZURvd24gZVxuICAgIEBzZXRTdGF0ZSBzZWxlY3Rpb25PcmlnaW46IEBnZXRSZWxhdGl2ZVBvc2l0aW9uIHt4OiBlLmNsaWVudFgsIHk6IGUuY2xpZW50WX1cblxuICAjIG1vdmUgcGxheWJhY2sgcG9zaXRpb25cbiAgIyB3ZSBuZWVkIHRvIGhhdmUgYSBzZWxlY3RlZCBwb3NpdGlvbiBzZXBlcmF0ZSBmcm9tIGFjdHVhbCBwbGF5YmFjayBwb3NpdGlvbixcbiAgIyBzaW1pbGFyIHRvIGFibGV0b24gbGl2ZSAtIHNldHRpbmcgYWN0dWFsIHBsYXliYWNrIHBvc2l0b24gb24gY2xpY2sgaXNcbiAgIyBwcm9ibGVtYXRpYyBiZWNhdXNlIGEgY2xpY2sgaXMgdHJpZ2dlcmVkIGJ5IGEgY2xpY2sgdG8gc2VsZWN0IGEgbm90ZSwgYmVnaW5cbiAgIyBkcmFnIHNlbGVjdGlvbiwgb3IgYnkgYSBkb3VibGUgY2xpY2sgdG8gY3JlYXRlIGEgbmV3IG5vdGVcbiAgb25DbGlja0dyaWQ6IChlKSAtPlxuICAgICMgb25TaW5nbGVDbGlja09ubHkgZS5uYXRpdmVFdmVudCwgKGUpID0+XG4gICAgIyAgIEBwcm9wcy5zb25nLnNlZWsgQGdldFJlbGF0aXZlUG9zaXRpb24oeDogZS5jbGllbnRYLCB5OiBlLmNsaWVudFkpLnN0YXJ0XG5cbiAgIyBhZGQgYSBuZXcgbm90ZVxuICBvbkRvdWJsZUNsaWNrR3JpZDogKGUpIC0+XG4gICAge2tleSwgc3RhcnR9ID0gQGdldFJlbGF0aXZlUG9zaXRpb24geDogZS5jbGllbnRYLCB5OiBlLmNsaWVudFlcbiAgICBpZCA9IGN1aWQoKVxuXG4gICAgY2hhbmdlcyA9IHt9XG4gICAgY2hhbmdlc1tpZF0gPSB7aWQsIGtleSwgc3RhcnQsIGxlbmd0aDogMSAvIEBzdGF0ZS5xdWFudGl6YXRpb259XG5cbiAgICBAcHJvcHMuc2VxdWVuY2UubWVyZ2Ugbm90ZXM6IGNoYW5nZXNcblxuICAjIGNoYW5nZSBjdXJzb3IgdG8gaW5kaWNhdGUgcG9zc2libGUgYWN0aW9uXG4gIG9uTW91c2VNb3ZlTm90ZTogKGUpIC0+XG4gICAgcG9zaXRpb24gPSBlLnRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuXG4gICAgaGFuZGxlU2l6ZSA9IE1hdGgubWF4IDAsIE1hdGgubWluIEBzdGF0ZS5yZXNpemVIYW5kbGVXaWR0aCwgKHBvc2l0aW9uLndpZHRoIC0gQHN0YXRlLnJlc2l6ZUhhbmRsZVdpZHRoKSAvIDJcblxuICAgIGlmIHBvc2l0aW9uLmxlZnQgPiBlLmNsaWVudFggLSBoYW5kbGVTaXplXG4gICAgICBAbm90ZUhvdmVyQ3Vyc29yID0gUG9pbnRlci5zZXQgJ3ctcmVzaXplJywgMSwgQG5vdGVIb3ZlckN1cnNvclxuICAgIGVsc2UgaWYgcG9zaXRpb24ucmlnaHQgPCBlLmNsaWVudFggKyBoYW5kbGVTaXplXG4gICAgICBAbm90ZUhvdmVyQ3Vyc29yID0gUG9pbnRlci5zZXQgJ2UtcmVzaXplJywgMSwgQG5vdGVIb3ZlckN1cnNvclxuICAgIGVsc2VcbiAgICAgIFBvaW50ZXIuY2xlYXIgQG5vdGVIb3ZlckN1cnNvclxuXG4gICMgY2xlYXIgZXhpc3RpbmcgY3Vyc29yXG4gIG9uTW91c2VPdXROb3RlOiAoZSkgLT5cbiAgICBQb2ludGVyLmNsZWFyIEBub3RlSG92ZXJDdXJzb3JcblxuICAjIEEgbW91c2UgZG93biBldmVudCBvbiBhIG5vdGUgd2lsbCBzZWxlY3QgdGhlIG5vdGUsIGFuZCBjYW4gYmUgdGhlIGJlZ2lubmluZ1xuICAjIG9mIGEgdHJhbnNsYXRpb24gb3IgcmVzaXplIG9mIHRoZSBzZWxlY3RlZCBub3Rlcy5cbiAgb25Nb3VzZURvd25Ob3RlOiAoZSkgLT5cbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG4gICAgaWQgPSBlLnRhcmdldC5kYXRhc2V0LmlkXG4gICAgcG9zaXRpb24gPSBlLnRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuXG4gICAgIyBoYW5kbGUgbm90ZSBzZWxlY3Rpb25cbiAgICBpZiAnc2hpZnQnIGluIEtleWJvYXJkLmFjdGl2ZUtleXMoKVxuICAgICAgc2VsZWN0ZWROb3RlcyA9IEBzdGF0ZS5zZWxlY3RlZE5vdGVzLnNsaWNlIDBcbiAgICAgIGlmIGlkIGluIEBzdGF0ZS5zZWxlY3RlZE5vdGVzXG4gICAgICAgIHNlbGVjdGVkTm90ZXMuc3BsaWNlIHNlbGVjdGVkTm90ZXMuaW5kZXhPZihpZCksIDFcbiAgICAgIGVsc2VcbiAgICAgICAgc2VsZWN0ZWROb3Rlcy5wdXNoIGlkXG4gICAgZWxzZVxuICAgICAgdW5sZXNzIGlkIGluIEBzdGF0ZS5zZWxlY3RlZE5vdGVzXG4gICAgICAgIHNlbGVjdGVkTm90ZXMgPSBbaWRdXG4gICAgICBlbHNlXG4gICAgICAgIHNlbGVjdGVkTm90ZXMgPSBAc3RhdGUuc2VsZWN0ZWROb3Rlc1xuXG4gICAgc3RhdGVDaGFuZ2VzID0ge3NlbGVjdGVkTm90ZXN9XG5cbiAgICAjIGhhbmRsZSBkcmFnIHN0YXJ0XG4gICAgQGRyYWdnYWJsZU9uTW91c2VEb3duIGVcblxuICAgICMgY2FjaGUgb3JpZ2luYWwgdmFsdWVzIG9mIHNlbGVjdGVkIG5vdGVzXG4gICAgQG9yaWdpbmFsVmFsdWUgPSB7fVxuICAgIGZvciBub3RlSWQsIG5vdGUgb2YgQHByb3BzLnNlcXVlbmNlLmdldCAnbm90ZXMnXG4gICAgICBpZiBzZWxlY3RlZE5vdGVzLmluZGV4T2Yobm90ZUlkKSA+PSAwXG4gICAgICAgIEBvcmlnaW5hbFZhbHVlW25vdGVJZF0gPSBub3RlXG5cbiAgICBAZHJhZ09yaWdpbiA9IEBwcm9wcy5zZXF1ZW5jZS5nZXQgWydub3RlcycsIGlkXVxuXG4gICAgaGFuZGxlU2l6ZSA9IE1hdGgubWF4IDAsIE1hdGgubWluIEBzdGF0ZS5yZXNpemVIYW5kbGVXaWR0aCwgKHBvc2l0aW9uLndpZHRoIC0gQHN0YXRlLnJlc2l6ZUhhbmRsZVdpZHRoKSAvIDJcblxuICAgICMgaGFuZGxlIHJlc2l6ZVxuICAgIGlmIHBvc2l0aW9uLmxlZnQgPiBlLmNsaWVudFggLSBoYW5kbGVTaXplXG4gICAgICBzdGF0ZUNoYW5nZXMucmVzaXplVGFyZ2V0ID0gaWRcbiAgICAgIHN0YXRlQ2hhbmdlcy5yZXNpemVEaXJlY3Rpb24gPSAnbGVmdCdcbiAgICAgIEBkcmFnQWN0aW9uQ3Vyc29yID0gUG9pbnRlci5zZXQgJ3ctcmVzaXplJywgMiwgQGRyYWdBY3Rpb25DdXJzb3JcbiAgICBlbHNlIGlmIHBvc2l0aW9uLnJpZ2h0IDwgZS5jbGllbnRYICsgaGFuZGxlU2l6ZVxuICAgICAgc3RhdGVDaGFuZ2VzLnJlc2l6ZVRhcmdldCA9IGlkXG4gICAgICBzdGF0ZUNoYW5nZXMucmVzaXplRGlyZWN0aW9uID0gJ3JpZ2h0J1xuICAgICAgQGRyYWdBY3Rpb25DdXJzb3IgPSBQb2ludGVyLnNldCAnZS1yZXNpemUnLCAyLCBAZHJhZ0FjdGlvbkN1cnNvclxuICAgICMgaGFuZGxlIHRyYW5zbGF0ZVxuICAgIGVsc2VcbiAgICAgIHN0YXRlQ2hhbmdlcy50cmFuc2xhdGVUYXJnZXQgPSBpZFxuICAgICAgQGRyYWdBY3Rpb25DdXJzb3IgPSBQb2ludGVyLnNldCAnbW92ZScsIDIsIEBkcmFnQWN0aW9uQ3Vyc29yXG5cbiAgICAjIGFwcGx5IHN0YXRlIGNoYW5nZXNcbiAgICBAc2V0U3RhdGUgc3RhdGVDaGFuZ2VzXG5cblxuICAjIHJlbW92ZSB0aGUgZG91YmxlIGNsaWNrZWQgbm90ZVxuICBvbkRvdWJsZUNsaWNrTm90ZTogKGUpIC0+XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgIEBwcm9wcy5zZXF1ZW5jZS5kZWxldGUgWydub3RlcycsIGUudGFyZ2V0LmRhdGFzZXQuaWRdXG5cblxuICAjIEEgZHJhZyBjYW4gZWl0aGVyIGJlIHNlbGVjdGlvbiwgdHJhbnNsYXRpb24gb2Ygbm90ZXMsIG9yIHJlc2l6ZSBvZiBub3Rlcy5cbiAgIyBUaGlzIGRldGVybWluZXMgd2hpY2ggaXMgb2NjdXJpbmcgYW5kIHRha2VzIHRoZSBhcHByb3ByaWF0ZSBhY3Rpb25cbiAgb25EcmFnOiAoZGVsdGEsIGUpIC0+XG5cbiAgICBwb3NpdGlvbiA9IEBnZXRSZWxhdGl2ZVBvc2l0aW9uIHg6IGUuY2xpZW50WCwgeTogZS5jbGllbnRZXG5cbiAgICAjIGhhbmRsZSBkcmFnIHNlbGVjdGlvblxuICAgIGlmIEBzdGF0ZS5zZWxlY3Rpb25PcmlnaW4/XG4gICAgICBAc2V0U3RhdGUgc2VsZWN0aW9uUG9zaXRpb246IHBvc2l0aW9uXG5cbiAgICBlbHNlXG4gICAgICBrZXlEZWx0YSA9IHBvc2l0aW9uLmtleSAtIEBkcmFnT3JpZ2luLmtleVxuICAgICAgc3RhcnREZWx0YSA9IHBvc2l0aW9uLnN0YXJ0IC0gQGRyYWdPcmlnaW4uc3RhcnRcbiAgICAgIG5vdGVzID0ge31cblxuICAgICAgIyBoYW5kbGUgdHJhbnNsYXRpb24gb2Ygbm90ZXNcbiAgICAgIGlmIEBzdGF0ZS50cmFuc2xhdGVUYXJnZXQ/XG4gICAgICAgIGZvciBpZCwgbm90ZSBvZiBAb3JpZ2luYWxWYWx1ZVxuICAgICAgICAgIG5vdGVzW2lkXSA9XG4gICAgICAgICAgICBrZXk6IG5vdGUua2V5ICsga2V5RGVsdGFcbiAgICAgICAgICAgIHN0YXJ0OiBub3RlLnN0YXJ0ICsgc3RhcnREZWx0YVxuXG4gICAgICAjIGhhbmRsZSByZXNpemUgb2Ygbm90ZXNcbiAgICAgIGlmIEBzdGF0ZS5yZXNpemVUYXJnZXQ/XG4gICAgICAgIG1pbkxlbmd0aCA9IDEgLyBAc3RhdGUucXVhbnRpemF0aW9uXG5cbiAgICAgICAgaWYgQHN0YXRlLnJlc2l6ZURpcmVjdGlvbiA9PSAncmlnaHQnXG4gICAgICAgICAgZm9yIGlkLCBub3RlIG9mIEBvcmlnaW5hbFZhbHVlXG4gICAgICAgICAgICBub3Rlc1tpZF0gPSBsZW5ndGg6IE1hdGgubWF4IG1pbkxlbmd0aCwgbm90ZS5sZW5ndGggKyBzdGFydERlbHRhIC0gQGRyYWdPcmlnaW4ubGVuZ3RoICsgbWluTGVuZ3RoXG5cbiAgICAgICAgaWYgQHN0YXRlLnJlc2l6ZURpcmVjdGlvbiA9PSAnbGVmdCdcbiAgICAgICAgICBmb3IgaSwgbm90ZSBvZiBAb3JpZ2luYWxWYWx1ZVxuICAgICAgICAgICAgc3RhcnQgPSBub3RlLnN0YXJ0ICsgc3RhcnREZWx0YVxuICAgICAgICAgICAgc3RhcnQgPSBNYXRoLm1heCAwLCBzdGFydFxuICAgICAgICAgICAgc3RhcnQgPSBNYXRoLm1pbiBzdGFydCwgbm90ZS5zdGFydCArIG5vdGUubGVuZ3RoIC0gbWluTGVuZ3RoXG4gICAgICAgICAgICBub3Rlc1tpXSA9XG4gICAgICAgICAgICAgIHN0YXJ0OiBzdGFydFxuICAgICAgICAgICAgICBsZW5ndGg6IG5vdGUuc3RhcnQgKyBub3RlLmxlbmd0aCAtIHN0YXJ0XG5cbiAgICAgIEB1cGRhdGVOb3RlcyBub3Rlc1xuXG4gICMgdGhlIGVuZCBvZiBhIGRyYWcgY2FuIGVpdGhlclxuICBvbkRyYWdFbmQ6IChlKSAtPlxuICAgICMgaWYgdGhlIGFsdCBrZXkgaXMgaGVsZCwgY29weSBub3Rlc1xuICAgIGlmIEBvcmlnaW5hbFZhbHVlPyBhbmQgJ2FsdCcgaW4gS2V5Ym9hcmQuYWN0aXZlS2V5cygpXG5cbiAgICAgIGNoYW5nZXMgPSB7fVxuICAgICAgZm9yIGlkLCB7a2V5LCBzdGFydCwgbGVuZ3RofSBvZiBAb3JpZ2luYWxWYWx1ZVxuICAgICAgICBpZCA9IGN1aWQoKVxuICAgICAgICBjaGFuZ2VzW2lkXSA9IHtpZCwga2V5LCBzdGFydCwgbGVuZ3RofVxuXG4gICAgICBAcHJvcHMuc2VxdWVuY2UubWVyZ2Ugbm90ZXM6IGNoYW5nZXNcblxuICAgIHN0YXRlQ2hhbmdlcyA9XG4gICAgICB0cmFuc2xhdGVUYXJnZXQ6IG51bGxcbiAgICAgIHJlc2l6ZVRhcmdldDogbnVsbFxuICAgICAgcmVzaXplRGlyZWN0aW9uOiBudWxsXG4gICAgICBzZWxlY3Rpb25PcmlnaW46IG51bGxcbiAgICAgIHNlbGVjdGlvblBvc2l0aW9uOiBudWxsXG5cbiAgICAjIGhhbmRsZSBkcmFnIHNlbGVjdFxuICAgIGlmIEBzdGF0ZS5zZWxlY3Rpb25PcmlnaW4/XG5cbiAgICAgIHBvc2l0aW9uID0gQGdldFJlbGF0aXZlUG9zaXRpb24geDogZS5jbGllbnRYLCB5OiBlLmNsaWVudFlcbiAgICAgIHNlbGVjdGVkTm90ZXMgPSBAbm90ZXNTZWxlY3RlZEJ5IEBzdGF0ZS5zZWxlY3Rpb25PcmlnaW4sIHBvc2l0aW9uXG4gICAgICBzZWxlY3RlZE5vdGVzID0gQHN0YXRlLnNlbGVjdGVkTm90ZXMuc2xpY2UoMCkuY29uY2F0IHNlbGVjdGVkTm90ZXMgaWYgJ3NoaWZ0JyBpbiBLZXlib2FyZC5hY3RpdmVLZXlzKClcbiAgICAgIHN0YXRlQ2hhbmdlcy5zZWxlY3RlZE5vdGVzID0gc2VsZWN0ZWROb3Rlc1xuXG4gICAgQHNldFN0YXRlIHN0YXRlQ2hhbmdlc1xuXG4gICAgQG9yaWdpbmFsVmFsdWUgPSBudWxsXG4gICAgQGRyYWdPcmlnaW4gPSBudWxsXG5cbiAgICBQb2ludGVyLmNsZWFyIEBkcmFnQWN0aW9uQ3Vyc29yXG4iLCIjIHRoaXMgbWl4aW4gb3ZlcnJpZGVzIHRoZSBuYXRpdmUgc2Nyb2xsaW5nIGZvciB0aGUgUGlhbm9Sb2xsIGNvbXBvbmVudCwgYW5kXG4jIGhhbmRsZXMgc2Nyb2xsaW5nIGFuZCBzY2FsaW5nIG9mIHRoZSBwaWFubyByb2xsIHZpZXdwb3J0XG5cbm1vZHVsZS5leHBvcnRzID1cblxuICBnZXRJbml0aWFsU3RhdGU6IC0+XG4gICAgIyB4IHNjYWxlIGFuZCBzY3JvbGwgdmFsdWVzIGFyZSBpbiBiZWF0c1xuICAgICMgeSBzY2FsZSBhbmQgc2Nyb2xsIHZhbHVlcyBhcmUgaW4gaGFsZiBzdGVwc1xuXG4gICAgIyB4IGFuZCB5IHNjYWxlIGFuZCBzY3JvbGwgYXJlIHNldCBhZnRlciBjb21wb25lbnQgbW91bnRzIGJhc2VkIG9uXG4gICAgIyBzZXF1ZW5jZSBwcm9wZXJ0eSBhbmQgc2l6ZSBvZiBlbGVtZW50IG9uIHNjcmVlblxuICAgIHhTY2FsZTogMVxuICAgIHlTY2FsZTogMTJcbiAgICB4U2Nyb2xsOiAwXG4gICAgeVNjcm9sbDogMFxuXG4gICAgIyBtaW4gYW5kIG1heCBzY2FsZXMgb2Ygdmlld3BvcnRcbiAgICBtaW5YU2NhbGU6IDFcbiAgICBtYXhYU2NhbGU6IDY0XG4gICAgbWluWVNjYWxlOiAxMlxuICAgIG1heFlTY2FsZTogMTI4XG5cbiAgICAjIGV4dHJhIHNwYWNlIGFyb3VuZCB0aGUgZWxlbWVudCB1c2VkIHRvIG1lYXN1cmUgc2Nyb2xsaW5nLCBzaG91bGQgYmVcbiAgICAjIG1vcmUgdGhhbiB0aGUgbWF4aW11bSBwb3NzaWJsZSBkaXN0YW5jZSB0cmF2ZWxsZWQgYmV0d2VlbiBzY3JvbGwgZXZlbnRzXG4gICAgc2Nyb2xsUGFkZGluZzogNTAwXG5cbiAgY29tcG9uZW50RGlkTW91bnQ6IC0+XG4gICAgZWwgPSBAcmVmcy5jb250YWluZXIuZ2V0RE9NTm9kZSgpXG5cbiAgICBzZXRUaW1lb3V0ID0+XG4gICAgICBlbC5zY3JvbGxUb3AgPSBAc3RhdGUuc2Nyb2xsUGFkZGluZ1xuICAgICAgZWwuc2Nyb2xsTGVmdCA9IEBzdGF0ZS5zY3JvbGxQYWRkaW5nXG5cbiAgICAjIHVzZWQgdG8gc3RvcmUgc2Nyb2xsIGRlbHRhIHdoaWxlIGl0IGlzIG5vdCB5ZXQgZW5vdWdoIHRvIG1vdmUgdGhlIHZpZXdwb3J0XG4gICAgIyBieSBhbiBlbnRpcmUgcXVhbnR1bVxuICAgIEBzY3JvbGxEZWx0YVkgPSAwXG4gICAgQHNjcm9sbERlbHRhWCA9IDBcblxuICAgIEBhdXRvU2NhbGVWaWV3cG9ydCBAcHJvcHMuc2VxdWVuY2VcblxuICAjIHdoZW4gdGhlIHNlcXVlbmNlIHByb3AgY2hhbmdlcywgc2NhbGUgdGhlIHZpZXdwb3J0IHRvIGZpdCB0aGUgbmV3IHNlcXVlbmNlXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IChuZXh0UHJvcHMpIC0+XG4gICAgaWYgbmV4dFByb3BzLnNlcXVlbmNlLmdldCgnX2lkJykgIT0gQHByb3BzLnNlcXVlbmNlLmdldCgnX2lkJylcbiAgICAgIEBhdXRvU2NhbGVWaWV3cG9ydCBuZXh0UHJvcHMuc2VxdWVuY2VcblxuICAjIHNjYWxlIHRoZSB2aWV3cG9ydCB0byBmaXQgYWxsIG5vdGVzIGluIHRoZSBzZXF1ZW5jZVxuICBhdXRvU2NhbGVWaWV3cG9ydDogKHNlcXVlbmNlKSAtPlxuICAgIG1pbktleSA9IDEyOFxuICAgIG1heEtleSA9IDBcblxuICAgIGZvciBpZCwgbm90ZSBvZiBzZXF1ZW5jZS5nZXQgJ25vdGVzJ1xuICAgICAgcmV0dXJuIHVubGVzcyBub3RlXG4gICAgICBtaW5LZXkgPSBub3RlLmtleSBpZiBub3RlLmtleSA8IG1pbktleVxuICAgICAgbWF4S2V5ID0gbm90ZS5rZXkgaWYgbm90ZS5rZXkgPiBtYXhLZXlcblxuICAgIHNpemUgPSBNYXRoLm1heChAc3RhdGUubWluWVNjYWxlLCBtYXhLZXkgLSBtaW5LZXkpICsgMTJcblxuICAgIEBzZXRTdGF0ZVxuICAgICAgeFNjcm9sbDogMFxuICAgICAgeFNjYWxlOiBzZXF1ZW5jZS5nZXQgJ2xvb3BTaXplJ1xuICAgICAgeVNjcm9sbDogTWF0aC5tYXggMCwgTWF0aC5jZWlsIChtaW5LZXkgKyBtYXhLZXkgLSBzaXplKSAvIDJcbiAgICAgIHlTY2FsZTogc2l6ZVxuXG4gICMgd2F0Y2ggYW5kIHByZXZlbnQgZGVmYXVsdCBvbiBzY3JvbGwgZXZlbnRzLCBpbnN0ZWFkIGtlZXBpbmcgc2Nyb2xsIHBvc2l0aW9uXG4gICMgaW4gQHN0YXRlLnhTY3JvbGwgYW5kIEBzdGF0ZS55U2Nyb2xsXG4gIG92ZXJyaWRlU2Nyb2xsaW5nOiAoZSkgLT5cbiAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG5cbiAgICBlbCA9IGUudGFyZ2V0XG4gICAgeFF1YW50dW0gPSBAc3RhdGUud2lkdGggLyBAc3RhdGUueFNjYWxlIC8gQHN0YXRlLnF1YW50aXphdGlvblxuICAgIHlRdWFudHVtID0gQHN0YXRlLmhlaWdodCAvIEBzdGF0ZS55U2NhbGVcbiAgICBsb29wU2l6ZSA9IEBwcm9wcy5zZXF1ZW5jZS5nZXQgJ2xvb3BTaXplJ1xuXG4gICAgIyB1cGRhdGUgc2Nyb2xsIGRlbHRhc1xuICAgIEBzY3JvbGxEZWx0YVggKz0gZWwuc2Nyb2xsTGVmdCAtIEBzdGF0ZS5zY3JvbGxQYWRkaW5nXG4gICAgQHNjcm9sbERlbHRhWSArPSBAc3RhdGUuc2Nyb2xsUGFkZGluZyAtIGVsLnNjcm9sbFRvcFxuXG4gICAgIyBwcmV2ZW50IHNjcm9sbFxuICAgIGVsLnNjcm9sbFRvcCA9IGVsLnNjcm9sbExlZnQgPSBAc3RhdGUuc2Nyb2xsUGFkZGluZ1xuXG4gICAgIyBnZXQgdXBkYXRlZCBzY3JvbGwgc3RhdGVcbiAgICBpZiBNYXRoLmFicyhAc2Nyb2xsRGVsdGFYKSA+IHhRdWFudHVtXG4gICAgICBxdWFudGEgPSAoaWYgQHNjcm9sbERlbHRhWCA+IDAgdGhlbiBNYXRoLmZsb29yIGVsc2UgTWF0aC5jZWlsKShAc2Nyb2xsRGVsdGFYIC8geFF1YW50dW0pXG4gICAgICBAc2Nyb2xsRGVsdGFYIC09IHF1YW50YSAqIHhRdWFudHVtXG4gICAgICB4U2Nyb2xsID0gTWF0aC5taW4gTWF0aC5tYXgoMCwgQHN0YXRlLnhTY3JvbGwgKyBxdWFudGEgLyBAc3RhdGUucXVhbnRpemF0aW9uKSwgbG9vcFNpemUgLSBAc3RhdGUueFNjYWxlXG5cbiAgICBpZiBNYXRoLmFicyhAc2Nyb2xsRGVsdGFZKSA+IHlRdWFudHVtXG4gICAgICBxdWFudGEgPSAoaWYgQHNjcm9sbERlbHRhWCA+IDAgdGhlbiBNYXRoLmZsb29yIGVsc2UgTWF0aC5jZWlsKShAc2Nyb2xsRGVsdGFZIC8geVF1YW50dW0pXG4gICAgICBAc2Nyb2xsRGVsdGFZIC09IHF1YW50YSAqIHlRdWFudHVtXG4gICAgICB5U2Nyb2xsID0gTWF0aC5taW4gTWF0aC5tYXgoMCwgQHN0YXRlLnlTY3JvbGwgKyBxdWFudGEpLCAxMjggLSBAc3RhdGUueVNjYWxlXG5cbiAgICAjIGFwcGx5IGNoYW5nZXNcbiAgICBpZiB4U2Nyb2xsPyBvciB5U2Nyb2xsP1xuICAgICAgQHNldFN0YXRlXG4gICAgICAgIHhTY3JvbGw6IGlmIHhTY3JvbGw/IHRoZW4geFNjcm9sbCBlbHNlIEBzdGF0ZS54U2Nyb2xsXG4gICAgICAgIHlTY3JvbGw6IGlmIHlTY3JvbGw/IHRoZW4geVNjcm9sbCBlbHNlIEBzdGF0ZS55U2Nyb2xsXG4iLCJSZWFjdCA9IHJlcXVpcmUgJ3JlYWN0L2FkZG9ucydcbktleWJvYXJkID0gcmVxdWlyZSAna2V5Ym9hcmRqcydcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0LmNyZWF0ZUNsYXNzXG5cbiAgbWl4aW5zOiBbXG4gICAgUmVhY3QuYWRkb25zLlB1cmVSZW5kZXJNaXhpblxuICBdXG5cbiAgZ2V0RGVmYXVsdFByb3BzOiAtPlxuICAgIHJhZGl1czogMFxuXG4gIHByb3BUeXBlczpcbiAgICBub3RlczogUmVhY3QuUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkXG4gICAgc2VsZWN0ZWROb3RlczogUmVhY3QuUHJvcFR5cGVzLmFycmF5LmlzUmVxdWlyZWRcbiAgICBkcmFnT3JpZ2luYWxWYWx1ZTogUmVhY3QuUHJvcFR5cGVzLm9iamVjdFxuICAgIHRyYW5zbGF0ZVRhcmdldDogUmVhY3QuUHJvcFR5cGVzLnN0cmluZ1xuICAgIHJlc2l6ZVRhcmdldDogUmVhY3QuUHJvcFR5cGVzLnN0cmluZ1xuICAgIHdpZHRoOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWRcbiAgICBoZWlnaHQ6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZFxuICAgIGxpbmVXaWR0aDogUmVhY3QuUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkXG4gICAgeVNjYWxlOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWRcbiAgICB4U2NhbGU6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZFxuICAgIHlTY3JvbGw6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZFxuICAgIHhTY3JvbGw6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZFxuICAgIHF1YW50aXphdGlvbjogUmVhY3QuUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkXG4gICAgb25Nb3VzZURvd246IFJlYWN0LlByb3BUeXBlcy5mdW5jXG4gICAgb25Nb3VzZU1vdmU6IFJlYWN0LlByb3BUeXBlcy5mdW5jXG4gICAgb25Nb3VzZU91dDogUmVhY3QuUHJvcFR5cGVzLmZ1bmNcbiAgICBvbkNsaWNrOiBSZWFjdC5Qcm9wVHlwZXMuZnVuY1xuICAgIG9uRG91YmxlQ2xpY2s6IFJlYWN0LlByb3BUeXBlcy5mdW5jXG5cbiAgbm90ZU9uU2NyZWVuOiAobm90ZSkgLT5cbiAgICBub3RlLnN0YXJ0IDw9IEBwcm9wcy54U2Nyb2xsICsgQHByb3BzLnhTY2FsZSBhbmRcbiAgICBub3RlLnN0YXJ0ICsgbm90ZS5sZW5ndGggPj0gQHByb3BzLnhTY3JvbGwgYW5kXG4gICAgbm90ZS5rZXkgPj0gQHByb3BzLnlTY3JvbGwgYW5kXG4gICAgbm90ZS5rZXkgPD0gQHByb3BzLnlTY3JvbGwgKyBAcHJvcHMueVNjYWxlXG5cbiAgcmVuZGVyOiAtPlxuICAgIHJldHVybiBSZWFjdC5ET00uZyhudWxsKSB1bmxlc3MgQHByb3BzLndpZHRoID4gMCBhbmQgQHByb3BzLmhlaWdodCA+IDBcblxuICAgIHdpZHRoID0gQHByb3BzLndpZHRoXG4gICAgaGVpZ2h0ID0gQHByb3BzLmhlaWdodFxuICAgIGxpbmVXaWR0aCA9IEBwcm9wcy5saW5lV2lkdGhcbiAgICBzcXVhcmVIZWlnaHQgPSBoZWlnaHQgLyBAcHJvcHMueVNjYWxlXG4gICAgcXVhbnRpemF0aW9uID0gQHByb3BzLnF1YW50aXphdGlvblxuICAgIGNvbHMgPSBAcHJvcHMueFNjYWxlICogcXVhbnRpemF0aW9uXG4gICAgc3F1YXJlV2lkdGggPSB3aWR0aCAvIGNvbHNcblxuICAgIGVscyA9IFtdXG5cbiAgICBtaW5Sb3cgPSBAcHJvcHMueVNjcm9sbFxuICAgIG1heFJvdyA9IG1pblJvdyArIEBwcm9wcy55U2NhbGVcbiAgICByb3dzID0gW21pblJvdy4uLm1heFJvd11cblxuICAgIG1pbkNvbCA9IEBwcm9wcy54U2Nyb2xsICogcXVhbnRpemF0aW9uXG4gICAgbWF4Q29sID0gbWluQ29sICsgQHByb3BzLnhTY2FsZSAqIHF1YW50aXphdGlvblxuICAgIGNvbHMgPSBbbWluQ29sLi4ubWF4Q29sXVxuXG4gICAgIyBnaG9zdCBub3Rlc1xuICAgIGlmIEBwcm9wcy50cmFuc2xhdGVUYXJnZXQ/IGFuZCAnYWx0JyBpbiBLZXlib2FyZC5hY3RpdmVLZXlzKClcbiAgICAgIGZvciBpZCwgbm90ZSBvZiBAcHJvcHMuZHJhZ09yaWdpbmFsVmFsdWVcbiAgICAgICAgY29udGludWUgdW5sZXNzIEBub3RlT25TY3JlZW4gbm90ZVxuXG4gICAgICAgIHggPSAobm90ZS5zdGFydCAtIEBwcm9wcy54U2Nyb2xsKSAqIHNxdWFyZVdpZHRoICogcXVhbnRpemF0aW9uICsgbGluZVdpZHRoIC8gMlxuICAgICAgICB5ID0gKEBwcm9wcy55U2NhbGUgKyBAcHJvcHMueVNjcm9sbCAtIG5vdGUua2V5IC0gMSkgKiBzcXVhcmVIZWlnaHQgKyBsaW5lV2lkdGggLyAyXG4gICAgICAgIHcgPSBzcXVhcmVXaWR0aCAqIG5vdGUubGVuZ3RoICogQHByb3BzLnF1YW50aXphdGlvbiAtIEBwcm9wcy5saW5lV2lkdGhcbiAgICAgICAgaCA9IHNxdWFyZUhlaWdodCAtIEBwcm9wcy5saW5lV2lkdGhcblxuICAgICAgICBlbHMucHVzaChcbiAgICAgICAgICBSZWFjdC5ET00ucmVjdCh7IFxcXG4gICAgICAgICAgICBcImNsYXNzTmFtZVwiOiBcImdob3N0IG5vdGVcIiwgIFxcXG4gICAgICAgICAgICBcImtleVwiOiAoJ2cnICsgaWQpLCAgXFxcbiAgICAgICAgICAgIFwieFwiOiAoeCksICBcXFxuICAgICAgICAgICAgXCJ5XCI6ICh5KSwgIFxcXG4gICAgICAgICAgICBcIndpZHRoXCI6ICh3KSwgIFxcXG4gICAgICAgICAgICBcImhlaWdodFwiOiAoaCksICBcXFxuICAgICAgICAgICAgXCJyeFwiOiAoQHByb3BzLnJhZGl1cyksICBcXFxuICAgICAgICAgICAgXCJyeVwiOiAoQHByb3BzLnJhZGl1cylcbiAgICAgICAgICB9KVxuICAgICAgICApXG5cbiAgICAjIG5vdGVzXG4gICAgZm9yIGlkLCBub3RlIG9mIEBwcm9wcy5ub3Rlc1xuICAgICAgY29udGludWUgdW5sZXNzIEBub3RlT25TY3JlZW4gbm90ZVxuXG4gICAgICB4ID0gKG5vdGUuc3RhcnQgLSBAcHJvcHMueFNjcm9sbCkgKiBzcXVhcmVXaWR0aCAqIEBwcm9wcy5xdWFudGl6YXRpb24gKyBsaW5lV2lkdGggLyAyXG4gICAgICB5ID0gKEBwcm9wcy55U2NhbGUgKyBAcHJvcHMueVNjcm9sbCAtIG5vdGUua2V5IC0gMSkgKiBzcXVhcmVIZWlnaHQgKyBsaW5lV2lkdGggLyAyXG4gICAgICB3ID0gc3F1YXJlV2lkdGggKiBub3RlLmxlbmd0aCAqIEBwcm9wcy5xdWFudGl6YXRpb24gLSBsaW5lV2lkdGhcbiAgICAgIGggPSBzcXVhcmVIZWlnaHQgLSBsaW5lV2lkdGhcblxuICAgICAgY2xhc3NOYW1lID0gJ25vdGUnXG4gICAgICBjbGFzc05hbWUgKz0gJyBzZWxlY3RlZCcgaWYgbm90ZS5pZCBpbiBAcHJvcHMuc2VsZWN0ZWROb3Rlc1xuICAgICAgY2xhc3NOYW1lICs9ICcgYWN0aXZlJyBpZiBAcHJvcHMudHJhbnNsYXRlVGFyZ2V0ID09IG5vdGUuaWQgb3IgQHByb3BzLnJlc2l6ZVRhcmdldCA9PSBub3RlLmlkXG5cbiAgICAgIGVscy5wdXNoKFxuICAgICAgICBSZWFjdC5ET00ucmVjdCh7IFxcXG4gICAgICAgICAgXCJjbGFzc05hbWVcIjogKGNsYXNzTmFtZSksICBcXFxuICAgICAgICAgIFwia2V5XCI6ICgnbicgKyBpZCksICBcXFxuICAgICAgICAgIFwieFwiOiAoeCksICBcXFxuICAgICAgICAgIFwieVwiOiAoeSksICBcXFxuICAgICAgICAgIFwid2lkdGhcIjogKHcpLCAgXFxcbiAgICAgICAgICBcImhlaWdodFwiOiAoaCksICBcXFxuICAgICAgICAgIFwicnhcIjogKEBwcm9wcy5yYWRpdXMpLCAgXFxcbiAgICAgICAgICBcInJ5XCI6IChAcHJvcHMucmFkaXVzKSwgIFxcXG4gICAgICAgICAgXCJkYXRhLWlkXCI6IChpZCksICBcXFxuICAgICAgICAgIFwib25Nb3VzZURvd25cIjogKEBwcm9wcy5vbk1vdXNlRG93biksICBcXFxuICAgICAgICAgIFwib25Nb3VzZU1vdmVcIjogKEBwcm9wcy5vbk1vdXNlTW92ZSksICBcXFxuICAgICAgICAgIFwib25Nb3VzZU91dFwiOiAoQHByb3BzLm9uTW91c2VPdXQpLCAgXFxcbiAgICAgICAgICBcIm9uQ2xpY2tcIjogKEBwcm9wcy5vbkNsaWNrKSwgIFxcXG4gICAgICAgICAgXCJvbkRvdWJsZUNsaWNrXCI6IChAcHJvcHMub25Eb3VibGVDbGljaylcbiAgICAgICAgfSlcbiAgICAgIClcblxuICAgIFJlYWN0LkRPTS5nKG51bGwsIChlbHMpKSIsIlJlYWN0ID0gcmVxdWlyZSAncmVhY3QvYWRkb25zJ1xuXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3QuY3JlYXRlQ2xhc3NcblxuICBtaXhpbnM6IFtcbiAgICBSZWFjdC5hZGRvbnMuUHVyZVJlbmRlck1peGluXG4gIF1cblxuICBwcm9wVHlwZXM6XG4gICAgcG9zaXRpb246IFJlYWN0LlByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZFxuICAgIGxvb3BTaXplOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWRcbiAgICB3aWR0aDogUmVhY3QuUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkXG4gICAgaGVpZ2h0OiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWRcbiAgICB4U2NhbGU6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZFxuICAgIHhTY3JvbGw6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZFxuICAgIHF1YW50aXphdGlvbjogUmVhY3QuUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkXG5cbiAgcmVuZGVyOiAtPlxuICAgIHdpZHRoID0gQHByb3BzLndpZHRoXG4gICAgaGVpZ2h0ID0gQHByb3BzLmhlaWdodFxuICAgIHBvc2l0aW9uID0gQHByb3BzLnBvc2l0aW9uICUgQHByb3BzLmxvb3BTaXplXG4gICAgY29scyA9IEBwcm9wcy54U2NhbGUgKiBAcHJvcHMucXVhbnRpemF0aW9uXG4gICAgc3F1YXJlV2lkdGggPSB3aWR0aCAvIGNvbHNcblxuICAgIGlmIHBvc2l0aW9uID49IEBwcm9wcy54U2Nyb2xsIGFuZCBwb3NpdGlvbiA8PSBAcHJvcHMueFNjcm9sbCArIEBwcm9wcy54U2NhbGVcbiAgICAgIHggPSBNYXRoLmZsb29yKHBvc2l0aW9uICogQHByb3BzLnF1YW50aXphdGlvbikgKiBzcXVhcmVXaWR0aFxuICAgICAgZWwgPSBSZWFjdC5ET00ucmVjdCh7IFxcXG4gICAgICAgIFwiY2xhc3NOYW1lXCI6IFwicGxheWJhY2tcIiwgIFxcXG4gICAgICAgIFwia2V5XCI6ICdwYicsICBcXFxuICAgICAgICBcInhcIjogKHgpLCAgXFxcbiAgICAgICAgXCJ5XCI6ICgwKSwgIFxcXG4gICAgICAgIFwid2lkdGhcIjogKDMpLCAgXFxcbiAgICAgICAgXCJoZWlnaHRcIjogKGhlaWdodClcbiAgICAgIH0pXG5cbiAgICBSZWFjdC5ET00uZyhudWxsLCAoZWwpKVxuIiwiUmVhY3QgPSByZXF1aXJlICdyZWFjdC9hZGRvbnMnXG5cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdC5jcmVhdGVDbGFzc1xuXG4gIG1peGluczogW1xuICAgIFJlYWN0LmFkZG9ucy5QdXJlUmVuZGVyTWl4aW5cbiAgXVxuXG4gIHByb3BUeXBlczpcbiAgICBzZWxlY3Rpb25PcmlnaW46IFJlYWN0LlByb3BUeXBlcy5vYmplY3RcbiAgICBzZWxlY3Rpb25Qb3NpdGlvbjogUmVhY3QuUHJvcFR5cGVzLm9iamVjdFxuICAgIHdpZHRoOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWRcbiAgICBoZWlnaHQ6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZFxuICAgIHlTY2FsZTogUmVhY3QuUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkXG4gICAgeFNjYWxlOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWRcbiAgICB5U2Nyb2xsOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWRcbiAgICB4U2Nyb2xsOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWRcbiAgICBxdWFudGl6YXRpb246IFJlYWN0LlByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZFxuXG4gIHJlbmRlcjogLT5cbiAgICB3aWR0aCA9IEBwcm9wcy53aWR0aFxuICAgIGhlaWdodCA9IEBwcm9wcy5oZWlnaHRcbiAgICBzZWxlY3Rpb25PcmlnaW4gPSBAcHJvcHMuc2VsZWN0aW9uT3JpZ2luXG4gICAgc2VsZWN0aW9uUG9zaXRpb24gPSBAcHJvcHMuc2VsZWN0aW9uUG9zaXRpb25cbiAgICBzcXVhcmVIZWlnaHQgPSBoZWlnaHQgLyBAcHJvcHMueVNjYWxlXG4gICAgcXVhbnRpemF0aW9uID0gQHByb3BzLnF1YW50aXphdGlvblxuICAgIGNvbHMgPSBAcHJvcHMueFNjYWxlICogcXVhbnRpemF0aW9uXG4gICAgc3F1YXJlV2lkdGggPSB3aWR0aCAvIGNvbHNcblxuICAgIGlmIHNlbGVjdGlvbk9yaWdpbj8gYW5kIHNlbGVjdGlvblBvc2l0aW9uP1xuICAgICAgZnJvbUtleSA9IE1hdGgubWF4IHNlbGVjdGlvbk9yaWdpbi5rZXksIHNlbGVjdGlvblBvc2l0aW9uLmtleVxuICAgICAga2V5V2lkdGggPSBNYXRoLmFicyBzZWxlY3Rpb25PcmlnaW4ua2V5IC0gc2VsZWN0aW9uUG9zaXRpb24ua2V5XG4gICAgICBmcm9tQmVhdCA9ICBNYXRoLm1pbiBzZWxlY3Rpb25PcmlnaW4uc3RhcnQsIHNlbGVjdGlvblBvc2l0aW9uLnN0YXJ0XG4gICAgICBiZWF0V2lkdGggPSBNYXRoLmFicyBzZWxlY3Rpb25PcmlnaW4uc3RhcnQgLSBzZWxlY3Rpb25Qb3NpdGlvbi5zdGFydFxuICAgICAgeCA9IChmcm9tQmVhdCAtIEBwcm9wcy54U2Nyb2xsKSAqIHF1YW50aXphdGlvbiAqIHNxdWFyZVdpZHRoXG4gICAgICB5ID0gKEBwcm9wcy55U2NhbGUgKyBAcHJvcHMueVNjcm9sbCAtIGZyb21LZXkgLSAxKSAqIHNxdWFyZUhlaWdodFxuICAgICAgdyA9IChiZWF0V2lkdGggKiBxdWFudGl6YXRpb24gKyAxKSAqIHNxdWFyZVdpZHRoXG4gICAgICBoID0gKGtleVdpZHRoICsgMSkgKiBzcXVhcmVIZWlnaHRcbiAgICAgIGVsID0gUmVhY3QuRE9NLnJlY3Qoe1wiY2xhc3NOYW1lXCI6ICdzZWxlY3Rpb24nLCBcImtleVwiOiAnc2VsJywgXCJ4XCI6ICh4KSwgXCJ5XCI6ICh5KSwgXCJ3aWR0aFwiOiAodyksIFwiaGVpZ2h0XCI6IChoKX0pXG5cbiAgICBSZWFjdC5ET00uZyhudWxsLCAoZWwpKSIsIiMgdGhpcyByZW5kZXJzIHRoZSB0b3AgYmFyIG9mIHRoZSBhcHBsaWNhdGlvbiB3aXRoIHBsYXliYWNrIGFuZCB0ZW1wIGNvbnRyb2xzLlxuIyBQbGF5YmFja0NvbnRyb2xsZXIgYWNjZXB0cyBvbmUgcHJvcGVydHkgLSBhIHNvbmcgY3Vyc29yXG5cblJlYWN0ID0gcmVxdWlyZSAncmVhY3QnXG5TY2FsZUhhbmRsZSA9IHJlcXVpcmUgJy4vc2NhbGVfaGFuZGxlJ1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0LmNyZWF0ZUNsYXNzXG5cbiAgbWl4aW5zOiBbUmVhY3QuYWRkb25zLlB1cmVSZW5kZXJNaXhpbl1cblxuICBwcm9wVHlwZXM6XG4gICAgZGF0YTogUmVhY3QuUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkXG4gICAgc29uZzogUmVhY3QuUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkXG5cbiAgcmVuZGVyOiAtPlxuICAgIHBsYXlpbmcgPSBAcHJvcHMuZGF0YS5nZXQgJ3BsYXlpbmcnXG5cbiAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcInVpIHBsYXliYWNrLWNvbnRyb2xcIn0sIFxuICAgICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJncm91cCBwbGF5YmFja1wifSwgXG4gICAgICAgIFJlYWN0LkRPTS5kaXYoeyBcXFxuICAgICAgICAgIFwiY2xhc3NOYW1lXCI6IChcImljb24gaWNvbi1wbGF5I3tpZiBwbGF5aW5nIHRoZW4gJyBhY3RpdmUnIGVsc2UgJyd9XCIpLCAgXFxcbiAgICAgICAgICBcIm9uQ2xpY2tcIjogKFxuICAgICAgICAgICAgaWYgcGxheWluZ1xuICAgICAgICAgICAgdGhlbiBAcHJvcHMuc29uZy5wYXVzZVxuICAgICAgICAgICAgZWxzZSBAcHJvcHMuc29uZy5wbGF5XG4gICAgICAgICAgKVxuICAgICAgICB9KSwgXG4gICAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwiaWNvbiBpY29uLXJlY29yZFwiLCBcIm9uQ2xpY2tcIjogKEBwcm9wcy5zb25nLnJlY29yZCl9KSwgXG4gICAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwiaWNvbiBpY29uLXN0b3BcIiwgXCJvbkNsaWNrXCI6IChAcHJvcHMuc29uZy5zdG9wKX0pXG4gICAgICApLCBcbiAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwiZ3JvdXAgdGVtcG9cIn0sIFxuICAgICAgICBSZWFjdC5ET00uc2VsZWN0KHsgXFxcbiAgICAgICAgICBcInZhbHVlXCI6IChAcHJvcHMuZGF0YS5nZXQgJ2JwbScpLCAgXFxcbiAgICAgICAgICBcIm9uQ2hhbmdlXCI6IChAcHJvcHMuZGF0YS5iaW5kICdicG0nLCAoZSkgLT4gcGFyc2VJbnQgZS50YXJnZXQudmFsdWUpXG4gICAgICAgIH0sIFxuICAgICAgICAgIChcbiAgICAgICAgICAgIGZvciBpIGluIFsyMDAuLjIwXVxuICAgICAgICAgICAgICBSZWFjdC5ET00ub3B0aW9uKHtcImtleVwiOiAoaSksIFwidmFsdWVcIjogKGkpfSwgKGkpLCBcIiBicG1cIilcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgICksIFxuICAgICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJsb2dvXCJ9LCBcInNpbmVzYXdcIiksIFxuICAgICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJncm91cCBtZW51XCJ9LCBcbiAgICAgICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJpY29uIGljb24tYWlyXCJ9KVxuICAgICAgKVxuICAgIClcbiIsIiMgQSBtb2RhbCBhdWRpbyByZWNvcmRpbmcgaW50ZXJmYWNlXG5cblJlYWN0ID0gcmVxdWlyZSAncmVhY3QvYWRkb25zJ1xuV2F2ZWZvcm0gPSByZXF1aXJlICcuL3dhdmVmb3JtJ1xuTWV0ZXIgPSByZXF1aXJlICcuL21ldGVyJ1xuQXVkaW9SZWNvcmRlciA9IHJlcXVpcmUgJy4uL2RzcC9hdWRpb19yZWNvcmRlcidcbmNvbnRleHQgPSByZXF1aXJlICcuLi9kc3AvZ2xvYmFsX2NvbnRleHQnXG5cbmRlZmF1bHRTdGF0ZSA9XG4gIHNhbXBsZURhdGE6IG51bGxcbiAgZXJyb3I6IG51bGxcbiAgYWN0aXZlOiBmYWxzZVxuICBwbGF5aW5nOiBmYWxzZVxuICBjcm9wU3RhcnQ6IDBcbiAgY3JvcEVuZDogMVxuXG5tZXRlckRlY2F5ID0gMC4wMDA1XG5cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdC5jcmVhdGVDbGFzc1xuXG4gIGdldEluaXRpYWxTdGF0ZTogLT5cbiAgICBkZWZhdWx0U3RhdGVcblxuICBvbkNsaWNrOiAtPlxuICAgIGlmIEBzdGF0ZS5hY3RpdmVcbiAgICAgIEBzdG9wKClcbiAgICBlbHNlIHVubGVzcyBAc3RhdGUuc2FtcGxlRGF0YT9cbiAgICAgIEByZWNvcmQoKVxuXG4gIHNldENyb3BTdGFydDogKHZhbHVlKSAtPlxuICAgIEBzZXRTdGF0ZVxuICAgICAgY3JvcFN0YXJ0OiB2YWx1ZVxuICAgICAgY3JvcEVuZDogTWF0aC5tYXggdmFsdWUsIEBzdGF0ZS5jcm9wU3RhcnRcblxuICBzZXRDcm9wRW5kOiAodmFsdWUpIC0+XG4gICAgQHNldFN0YXRlXG4gICAgICBjcm9wRW5kOiB2YWx1ZVxuICAgICAgY3JvcFN0YXJ0OiBNYXRoLm1pbiB2YWx1ZSwgQHN0YXRlLmNyb3BFbmRcblxuICBjcm9wcGVkU2FtcGxlRGF0YTogLT5cbiAgICBsZW5ndGggPSBAc3RhdGUuc2FtcGxlRGF0YS5sZW5ndGhcbiAgICBAc3RhdGUuc2FtcGxlRGF0YS5zdWJhcnJheSBNYXRoLmZsb29yKEBzdGF0ZS5jcm9wU3RhcnQgKiBsZW5ndGgpLCBNYXRoLmZsb29yKEBzdGF0ZS5jcm9wRW5kICogbGVuZ3RoKVxuXG4gIHJlY29yZDogLT5cbiAgICByZXR1cm4gaWYgQHN0YXRlLmFjdGl2ZVxuXG4gICAgQGNsZWFyKClcblxuICAgIG5hdmlnYXRvci53ZWJraXRHZXRVc2VyTWVkaWFcbiAgICAgIGF1ZGlvOiB0cnVlXG4gICAgICAobG9jYWxNZWRpYVN0cmVhbSkgPT5cbiAgICAgICAgaW5wdXQgPSBjb250ZXh0LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlIGxvY2FsTWVkaWFTdHJlYW1cbiAgICAgICAgcmVjb3JkZXIgPSBuZXcgQXVkaW9SZWNvcmRlciBpbnB1dFxuICAgICAgICByZWNvcmRlci5yZWNvcmQoKVxuICAgICAgICBAc2V0U3RhdGUge3JlY29yZGVyLCBhY3RpdmU6IHRydWV9XG4gICAgICAoZXJyb3JDb2RlKSA9PlxuICAgICAgICBAc2V0U3RhdGUgZXJyb3I6ICdVbmFibGUgdG8gYWNjZXNzIG1pY3JvcGhvbmUnXG5cbiAgc3RvcDogLT5cbiAgICByZXR1cm4gdW5sZXNzIEBzdGF0ZS5hY3RpdmVcblxuICAgIGlmIEBzdGF0ZS5wbGF5ZXJcbiAgICAgIEBzdGF0ZS5wbGF5ZXIub25lbmRlZCA9IGZhbHNlXG4gICAgICBAc3RhdGUucGxheWVyLnN0b3AoKVxuXG4gICAgQHN0YXRlLnJlY29yZGVyLnN0b3AoKS5nZXRTYW1wbGVEYXRhIChzYW1wbGVEYXRhKSA9PlxuICAgICAgQHNldFN0YXRlXG4gICAgICAgIHJlY29yZGVyOiBudWxsXG4gICAgICAgIHNhbXBsZURhdGE6IHNhbXBsZURhdGFcbiAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgICAgYWN0aXZlOiBmYWxzZVxuICAgICAgICBwbGF5aW5nOiBmYWxzZVxuXG4gIHBsYXk6IC0+XG4gICAgaWYgQHN0YXRlLnBsYXllclxuICAgICAgQHN0YXRlLnBsYXllci5vbmVuZGVkID0gbnVsbFxuICAgICAgQHN0YXRlLnBsYXllci5zdG9wKClcbiAgICAgIEBzdGF0ZS5wbGF5ZXIuZGlzY29ubmVjdCBjb250ZXh0LmRlc3RpbmF0aW9uXG5cbiAgICBkYXRhID0gQGNyb3BwZWRTYW1wbGVEYXRhKClcblxuICAgIHBsYXllciA9IGNvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKClcbiAgICBwbGF5ZXIuY29ubmVjdCBjb250ZXh0LmRlc3RpbmF0aW9uXG4gICAgYXVkaW9CdWZmZXIgPSBjb250ZXh0LmNyZWF0ZUJ1ZmZlciAxLCBkYXRhLmxlbmd0aCwgY29udGV4dC5zYW1wbGVSYXRlXG4gICAgYXVkaW9CdWZmZXIuZ2V0Q2hhbm5lbERhdGEoMCkuc2V0IGRhdGFcbiAgICBwbGF5ZXIuYnVmZmVyID0gYXVkaW9CdWZmZXJcbiAgICBwbGF5ZXIub25lbmRlZCA9ID0+IEBzZXRTdGF0ZSBwbGF5aW5nOiBmYWxzZVxuICAgIHBsYXllci5zdGFydCgpXG5cbiAgICBAc2V0U3RhdGUge3BsYXllciwgcGxheWluZzogdHJ1ZX1cblxuICBjbGVhcjogLT5cbiAgICBAc2V0U3RhdGUgZGVmYXVsdFN0YXRlXG5cbiAgY29uZmlybTogLT5cbiAgICBAcHJvcHMub25Db25maXJtIEBjcm9wcGVkU2FtcGxlRGF0YSgpXG5cbiAgcmVuZGVyOiAtPlxuXG4gICAgbGVmdEJ1dHRvbnMgPSBbXG4gICAgICBSZWFjdC5ET00uZGl2KHsgXFxcbiAgICAgICAgXCJjbGFzc05hbWVcIjogKFwiaWNvbiBpY29uLXJlY29yZCAje2lmIEBzdGF0ZS5hY3RpdmUgdGhlbiAnIGFjdGl2ZScgZWxzZSAnJ31cIiksICBcXFxuICAgICAgICBcImtleVwiOiBcInJcIiwgIFxcXG4gICAgICAgIFwib25DbGlja1wiOiAoaWYgQHN0YXRlLmFjdGl2ZSB0aGVuIEBzdG9wIGVsc2UgQHJlY29yZClcbiAgICAgIH0pXG4gICAgXVxuXG4gICAgcmlnaHRCdXR0b25zID0gW1xuICAgICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJpY29uIGljb24tY3Jvc3NcIiwgXCJrZXlcIjogXCJjXCIsIFwib25DbGlja1wiOiAoQHByb3BzLm9uQ2FuY2VsKX0pXG4gICAgXVxuXG4gICAgaWYgQHN0YXRlLnNhbXBsZURhdGE/XG5cbiAgICAgIHdhdmVmb3JtID0gV2F2ZWZvcm0oeyBcXFxuICAgICAgICBcInNhbXBsZURhdGFcIjogKEBzdGF0ZS5zYW1wbGVEYXRhKSwgIFxcXG4gICAgICAgIFwic2VsZWN0aW9uU3RhcnRcIjogKEBzdGF0ZS5jcm9wU3RhcnQpLCAgXFxcbiAgICAgICAgXCJzZWxlY3Rpb25FbmRcIjogKEBzdGF0ZS5jcm9wRW5kKSwgIFxcXG4gICAgICAgIFwibWFya2Vyc1wiOiAoXG4gICAgICAgICAgc3RhcnQ6XG4gICAgICAgICAgICB2YWx1ZTogQHN0YXRlLmNyb3BTdGFydFxuICAgICAgICAgICAgb25DaGFuZ2U6IChjcm9wU3RhcnQpID0+IEBzZXRTdGF0ZSB7Y3JvcFN0YXJ0fVxuICAgICAgICAgIGVuZDpcbiAgICAgICAgICAgIHZhbHVlOiBAc3RhdGUuY3JvcEVuZFxuICAgICAgICAgICAgb25DaGFuZ2U6IChjcm9wRW5kKSA9PiBAc2V0U3RhdGUge2Nyb3BFbmR9XG4gICAgICAgIClcbiAgICAgIH0pXG5cbiAgICAgIGxlZnRCdXR0b25zLnB1c2ggUmVhY3QuRE9NLmRpdih7IFxcXG4gICAgICAgIFwiY2xhc3NOYW1lXCI6IFwiaWNvbiBpY29uLXBsYXkgI3tpZiBAc3RhdGUucGxheWluZyB0aGVuICcgYWN0aXZlJyBlbHNlICcnfVwiLCAgXFxcbiAgICAgICAgXCJrZXlcIjogXCJwXCIsICBcXFxuICAgICAgICBcIm9uQ2xpY2tcIjogKGlmIEBzdGF0ZS5wbGF5aW5nIHRoZW4gQHN0b3AgZWxzZSBAcGxheSlcbiAgICAgIH0pXG5cbiAgICAgIHJpZ2h0QnV0dG9ucy5wdXNoIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwiaWNvbiBpY29uLWNoZWNrbWFya1wiLCBcImtleVwiOiBcInNcIiwgXCJvbkNsaWNrXCI6IChAY29uZmlybSl9KVxuXG4gICAgZWxzZVxuXG4gICAgICBtZXNzYWdlID0gaWYgQHN0YXRlLmVycm9yP1xuICAgICAgICBAc3RhdGUuZXJyb3JcbiAgICAgIGVsc2UgaWYgQHN0YXRlLmFjdGl2ZVxuICAgICAgICAnUmVjb3JkaW5nLCBjbGljayB0byBzdG9wJ1xuICAgICAgZWxzZVxuICAgICAgICAnQ2xpY2sgdG8gcmVjb3JkJ1xuXG4gICAgICBpbnN0cnVjdGlvbiA9IFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwiaW5zdHJ1Y3Rpb25cIn0sIChtZXNzYWdlKSlcblxuXG4gICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJ1aSByZWNvcmQtY29udHJvbFwifSwgXG4gICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcInJvdyBzYW1wbGVcIn0sIFxuICAgICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcImRpc3BsYXlcIiwgXCJvbkNsaWNrXCI6IChAb25DbGljayl9LCBcbiAgICAgICAgICAod2F2ZWZvcm0pLCBcbiAgICAgICAgICAoaW5zdHJ1Y3Rpb24pXG4gICAgICAgIClcbiAgICAgICksIFxuICAgICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJyb3cgY29udHJvbHNcIn0sIFxuICAgICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcImxlZnRcIn0sIFxuICAgICAgICAgIChsZWZ0QnV0dG9ucylcbiAgICAgICAgKSwgXG4gICAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwicmlnaHRcIn0sIFxuICAgICAgICAgIChyaWdodEJ1dHRvbnMpXG4gICAgICAgIClcbiAgICAgIClcbiAgICApXG4iLCJSZWFjdCA9IHJlcXVpcmUgJ3JlYWN0L2FkZG9ucydcbldhdmVmb3JtID0gcmVxdWlyZSAnLi93YXZlZm9ybSdcblJlY29yZENvbnRyb2wgPSByZXF1aXJlICcuL3JlY29yZF9jb250cm9sJ1xuZGVjb2RlciA9IHJlcXVpcmUgJy4uL2RzcC9nbG9iYWxfY29udGV4dCdcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdC5jcmVhdGVDbGFzc1xuXG4gICMgcmFuZ2UgaW4gcGl4ZWxzIGZvciB2ZXJ0aWNhbCBkcmFnIHRvIHpvb21cbiAgcmFuZ2U6IDMwMFxuICBkcmFnVHlwZURpc3RhbmNlOiAxMFxuXG4gIGdldERlZmF1bHRQcm9wczogLT5cbiAgICBzYW1wbGVTdGFydDogMFxuXG4gIHRyaWdnZXJGaWxlSW5wdXQ6IC0+XG4gICAgQHJlZnMuaW5wdXQuZ2V0RE9NTm9kZSgpLmNsaWNrKClcblxuICBvbkZpbGVTZWxlY3Q6IC0+XG4gICAgZmlsZSA9IEByZWZzLmlucHV0LmdldERPTU5vZGUoKS5maWxlc1swXVxuXG4gICAgaWYgZmlsZT9cbiAgICAgIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyXG4gICAgICByZWFkZXIub25sb2FkID0gKGUpID0+XG4gICAgICAgIGRlY29kZXIuZGVjb2RlQXVkaW9EYXRhIGUudGFyZ2V0LnJlc3VsdCwgKGJ1ZmZlcikgPT5cbiAgICAgICAgICBzYW1wbGVEYXRhID0gYnVmZmVyLmdldENoYW5uZWxEYXRhIDBcbiAgICAgICAgICBAcHJvcHMuc2FtcGxlci51cGRhdGUgKHNhbXBsZXIpIC0+IHNhbXBsZXIubWVyZ2Uge3NhbXBsZU5hbWU6IGZpbGUubmFtZSwgc2FtcGxlRGF0YX1cbiAgICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlciBmaWxlXG5cbiAgY2xlYXI6IC0+XG4gICAgQHByb3BzLnNhbXBsZXIudXBkYXRlIChzYW1wbGVyKSAtPiBzYW1wbGVyLm1lcmdlIHNhbXBsZU5hbWU6IG51bGwsIHNhbXBsZURhdGE6IG51bGxcblxuICByZWNvcmRTYW1wbGU6IC0+XG4gICAgQHByb3BzLmFwcC5sYXVuY2hNb2RhbCBSZWNvcmRDb250cm9sKHsgXFxcbiAgICAgIFwib25DYW5jZWxcIjogKEBwcm9wcy5hcHAuZGlzbWlzc01vZGFsKSwgIFxcXG4gICAgICBcIm9uQ29uZmlybVwiOiAoXG4gICAgICAgIChzYW1wbGVEYXRhKSA9PlxuICAgICAgICAgIEBwcm9wcy5zYW1wbGVyLm1lcmdlIHtzYW1wbGVOYW1lOiAncmVjb3JkaW5nLndhdicsIHNhbXBsZURhdGF9XG4gICAgICAgICAgQHByb3BzLmFwcC5kaXNtaXNzTW9kYWwoKVxuICAgICAgKVxuICAgIH0pXG5cbiAgc2V0U3RhcnQ6ICh2YWx1ZSkgLT5cbiAgICBAcHJvcHMuc2FtcGxlci5tZXJnZVxuICAgICAgc3RhcnQ6IHZhbHVlXG4gICAgICBsb29wOiBNYXRoLm1heCB2YWx1ZSwgQHByb3BzLnNhbXBsZXIuZ2V0ICdsb29wJ1xuXG4gIHNldExvb3A6ICh2YWx1ZSkgLT5cbiAgICBAcHJvcHMuc2FtcGxlci5tZXJnZVxuICAgICAgbG9vcDogdmFsdWVcbiAgICAgIHN0YXJ0OiBNYXRoLm1pbiB2YWx1ZSwgQHByb3BzLnNhbXBsZXIuZ2V0ICdzdGFydCdcblxuICByZW5kZXI6IC0+XG4gICAgc2FtcGxlciA9IEBwcm9wcy5zYW1wbGVyXG4gICAgc2FtcGxlU3RhcnQgPSBzYW1wbGVyLmdldCAnc3RhcnQnXG4gICAgbG9vcEFjdGl2ZSA9IHNhbXBsZXIuZ2V0ICdsb29wQWN0aXZlJ1xuICAgIGxvb3BWYWx1ZSA9IHNhbXBsZXIuZ2V0ICdsb29wJ1xuICAgIHNhbXBsZURhdGEgPSBzYW1wbGVyLmdldCAnc2FtcGxlRGF0YSdcblxuICAgIG1hcmtlcnMgPSB7fVxuXG4gICAgaWYgc2FtcGxlU3RhcnQ/XG4gICAgICBtYXJrZXJzLnN0YXJ0ID1cbiAgICAgICAgdmFsdWU6IHNhbXBsZVN0YXJ0XG4gICAgICAgIG9uQ2hhbmdlOiBAc2V0U3RhcnRcblxuICAgIGlmIGxvb3BBY3RpdmUgPT0gJ2xvb3AnXG4gICAgICBtYXJrZXJzLmxvb3AgPVxuICAgICAgICB2YWx1ZTogbG9vcFZhbHVlXG4gICAgICAgIG9uQ2hhbmdlOiBAc2V0TG9vcFxuXG4gICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJ1aSBzYW1wbGUtY29udHJvbFwifSwgXG4gICAgICBSZWFjdC5ET00uaW5wdXQoe1widHlwZVwiOiBcImZpbGVcIiwgXCJyZWZcIjogXCJpbnB1dFwiLCBcIm9uQ2hhbmdlXCI6IChAb25GaWxlU2VsZWN0KX0pLCBcbiAgICAgIFJlYWN0LkRPTS5kaXYoeyBcXFxuICAgICAgICBcImNsYXNzTmFtZVwiOiBcImRpc3BsYXlcIiwgIFxcXG4gICAgICAgIFwicmVmXCI6IFwiY29udGFpbmVyXCIsICBcXFxuICAgICAgICBcIm9uQ2xpY2tcIjogKGlmIHNhbXBsZURhdGE/IHRoZW4gbnVsbCBlbHNlIEB0cmlnZ2VyRmlsZUlucHV0KVxuICAgICAgfSwgXG4gICAgICAgIChpZiBzYW1wbGVEYXRhPyB0aGVuIG51bGwgZWxzZSBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcImluc3RydWN0aW9uXCJ9LCBcImNsaWNrIHRvIHVwbG9hZFwiKSksIFxuICAgICAgICBXYXZlZm9ybSh7IFxcXG4gICAgICAgICAgXCJzYW1wbGVEYXRhXCI6IChzYW1wbGVEYXRhKSwgIFxcXG4gICAgICAgICAgXCJzZWxlY3Rpb25TdGFydFwiOiAoc2FtcGxlU3RhcnQgb3IgMCksICBcXFxuICAgICAgICAgIFwic2VsZWN0aW9uRW5kXCI6IChpZiBsb29wQWN0aXZlID09ICdsb29wJyB0aGVuIGxvb3BWYWx1ZSBlbHNlIDEpLCAgXFxcbiAgICAgICAgICBcIm1hcmtlcnNcIjogKG1hcmtlcnMpXG4gICAgICAgIH0pXG4gICAgICApLCBcbiAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwiY29udHJvbHNcIn0sIFxuICAgICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcImNvbnRyb2xcIiwgXCJvbkNsaWNrXCI6IChAdHJpZ2dlckZpbGVJbnB1dCl9LCBcbiAgICAgICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcImljb24gaWNvbi1hcnJvdy11cFwifSlcbiAgICAgICAgKSwgXG4gICAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwiY29udHJvbFwiLCBcIm9uQ2xpY2tcIjogKEByZWNvcmRTYW1wbGUpfSwgXG4gICAgICAgICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJpY29uIGljb24tcmVjb3JkXCJ9KVxuICAgICAgICApLCBcbiAgICAgICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJjb250cm9sXCIsIFwib25DbGlja1wiOiAoQGNsZWFyKX0sIFxuICAgICAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwiaWNvbiBpY29uLWNyb3NzXCJ9KVxuICAgICAgICApLCBcbiAgICAgICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJmaWxlLW5hbWVcIn0sIChAcHJvcHMuc2FtcGxlTmFtZSkpXG4gICAgICApLCBcbiAgICAgIFJlYWN0LkRPTS5sYWJlbChudWxsLCAoQHByb3BzLmxhYmVsKSlcbiAgICApXG4iLCJSZWFjdCA9IHJlcXVpcmUgJ3JlYWN0J1xuRHJhZ2dhYmxlID0gcmVxdWlyZSAnLi9taXhpbnMvZHJhZ2dhYmxlJ1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0LmNyZWF0ZUNsYXNzXG5cbiAgcmFuZ2U6IDMwMFxuXG4gIG1peGluczogW0RyYWdnYWJsZV1cblxuICBnZXRJbml0aWFsU3RhdGU6IC0+XG4gICAgYWN0aXZlOiBmYWxzZVxuXG4gIG9uRHJhZ1N0YXJ0OiAtPlxuICAgICMgbm9ybWFsaXplIHZhbHVlXG4gICAgQGluaXRpYWxWYWx1ZSA9IChAcHJvcHMudmFsdWUgLSBAcHJvcHMubWluKSAvIChAcHJvcHMubWF4IC0gQHByb3BzLm1pbilcbiAgICBAc2V0U3RhdGUgYWN0aXZlOiB0cnVlXG5cbiAgb25EcmFnOiAoZGVsdGEpIC0+XG4gICAgdXBSYW5nZSA9IE1hdGgubWluIEByYW5nZSwgKEBkcmFnU3RhcnRQb3NpdGlvbi55IC0gd2luZG93LnNjcm9sbFkpXG4gICAgZG93blJhbmdlID0gTWF0aC5taW4gQHJhbmdlLCAod2luZG93LmlubmVySGVpZ2h0ICsgd2luZG93LnNjcm9sbFkgLSBAZHJhZ1N0YXJ0UG9zaXRpb24ueSlcblxuICAgIGlmIGRlbHRhLnkgPCAwXG4gICAgICB2YWx1ZSA9IE1hdGgubWF4IDAsIEBpbml0aWFsVmFsdWUgKiAoZG93blJhbmdlICsgZGVsdGEueSkgLyBkb3duUmFuZ2VcbiAgICBlbHNlXG4gICAgICB2YWx1ZSA9IE1hdGgubWluIDEsIEBpbml0aWFsVmFsdWUgKyAoMSAtIEBpbml0aWFsVmFsdWUpICogZGVsdGEueSAvIHVwUmFuZ2VcblxuICAgICMgZGVub3JtYWxpemUgdmFsdWVcbiAgICB2YWx1ZSA9IDEgKiBAcHJvcHMubWluICsgdmFsdWUgKiAoQHByb3BzLm1heCAtIEBwcm9wcy5taW4pXG4gICAgQHByb3BzLm9uQ2hhbmdlIHZhbHVlXG5cbiAgb25EcmFnRW5kOiAtPlxuICAgIEBpbml0aWFsVmFsdWUgPSBudWxsXG4gICAgQHNldFN0YXRlIGFjdGlvbjogZmFsc2VcblxuICByZW5kZXI6IC0+XG4gICAgY2xhc3NOYW1lID0gJ3VpIHNjYWxlLWhhbmRsZSdcbiAgICBjbGFzc05hbWUgKz0gJyBhY3RpdmUnIGlmIEBzdGF0ZS5hY3RpdmVcblxuICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IChjbGFzc05hbWUpLCBcIm9uTW91c2VEb3duXCI6IChAZHJhZ2dhYmxlT25Nb3VzZURvd24pfSwgXG4gICAgICAoQHByb3BzLmNoaWxkcmVuKVxuICAgICkiLCIjIGEgbW91c2UgaW50ZXJhY3RpdmUgc2xpZGVyIHVpIGVsZW1lbnQgLSBleHBlY3RzIHRvIHJlY2VpdmUgdHdvIHByb3BzLCB2YWx1ZSxcbiMgdGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIHNsaWRlciBhcyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEsIGFuZCBvbkNoYW5nZSxcbiMgYSBjYWxsYmFjayB3aGljaCB3aWxsIGdldCBwYXNzZWQgdGhlIG5ldyB2YWx1ZXMgb24gY2hhbmdlcy5cbiNcbiMgQWxzbyBjYW4gcmVjZWl2ZSBhbiBvcHRpb25hbCBwcm9wICdkaXNhYmxlZCcgd2hpY2ggaWYgdHJ1ZSB3aWxsIHByZXZlbnRcbiMgaW50ZXJhY3Rpb24uXG5cblJlYWN0ID0gcmVxdWlyZSAncmVhY3QnXG5TaXplTWVhc3VyYWJsZSA9IHJlcXVpcmUgJy4vbWl4aW5zL3NpemVfbWVhc3VyYWJsZSdcbkRyYWdnYWJsZSA9IHJlcXVpcmUgJy4vbWl4aW5zL2RyYWdnYWJsZSdcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdC5jcmVhdGVDbGFzc1xuXG4gIG1peGluczogW1xuICAgIFNpemVNZWFzdXJhYmxlXG4gICAgRHJhZ2dhYmxlXG4gIF1cblxuICBwcm9wVHlwZXM6XG4gICAgdmFsdWU6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZFxuICAgIG9uQ2hhbmdlOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkXG4gICAgZGlzYWJsZWQ6IFJlYWN0LlByb3BUeXBlcy5ib29sXG5cbiAgZ2V0SW5pdGlhbFN0YXRlOiAtPlxuICAgIGFjdGl2ZTogZmFsc2VcblxuICBvbkRyYWdTdGFydDogLT5cbiAgICBAaW5pdGFsVmFsdWUgPSBAcHJvcHMudmFsdWVcbiAgICBAc2V0U3RhdGUgYWN0aXZlOiB0cnVlXG5cbiAgb25EcmFnOiAoZGVsdGEpIC0+XG4gICAgcmV0dXJuIGlmIEBwcm9wcy5kaXNhYmxlZFxuXG4gICAgdmFsdWUgPSBAaW5pdGFsVmFsdWUgKyBkZWx0YS55IC8gQHN0YXRlLmhlaWdodFxuICAgIHZhbHVlID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odmFsdWUsIDEpKVxuICAgIEBwcm9wcy5vbkNoYW5nZSB2YWx1ZVxuXG4gIG9uRHJhZ0VuZDogLT5cbiAgICBAaW5pdGFsVmFsdWUgPSBudWxsXG4gICAgQHNldFN0YXRlIGFjdGl2ZTogZmFsc2VcblxuICByZW5kZXI6IC0+XG4gICAgc3R5bGUgPSB0b3A6IFwiI3sxMDAqKDEgLSBAcHJvcHMudmFsdWUpfSVcIlxuXG4gICAgY2xhc3NOYW1lID0gJ3VpIHNsaWRlcidcbiAgICBjbGFzc05hbWUgKz0gJyBhY3RpdmUnIGlmIEBzdGF0ZS5hY3RpdmVcbiAgICBjbGFzc05hbWUgKz0gJyBkaXNhYmxlZCcgaWYgQHByb3BzLmRpc2FibGVkXG5cbiAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiAoY2xhc3NOYW1lKX0sIFxuICAgICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJjb250cm9sXCIsIFwicmVmXCI6IFwiY29udGFpbmVyXCJ9LCBcbiAgICAgICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJ0cmFja1wifSksIFxuICAgICAgICBSZWFjdC5ET00uZGl2KHsgXFxcbiAgICAgICAgICBcImNsYXNzTmFtZVwiOiBcImhhbmRsZVwiLCAgXFxcbiAgICAgICAgICBcInN0eWxlXCI6IChzdHlsZSksICBcXFxuICAgICAgICAgIFwib25Nb3VzZURvd25cIjogKEBkcmFnZ2FibGVPbk1vdXNlRG93bilcbiAgICAgICAgfSlcbiAgICAgICksIFxuICAgICAgUmVhY3QuRE9NLmxhYmVsKG51bGwsIChAcHJvcHMubGFiZWwpKVxuICAgICkiLCIjIFJlYWN0IGNvbXBvbmVudCByZXByZXNldGluZyB0cmFjayBzZWxlY3Rpb24gVUkgLSBhbGxvd3MgZm9yIHRyYWNrIHNlbGVjdGlvbixcbiMgY3JlYXRpb24sIGRlbGV0aW9uLCBhbmQgb3JkZXJpbmdcbiNcbiMgVHJhY2tTZWxlY3Rpb24gcmVxdWlyZXMgdGhyZWUgcHJvcHMgLSAndHJhY2tzJywgYSBjdXJzb3IgdG8gYW4gYXJyYXkgb2YgdHJhY2tcbiMgb2JqZWN0cywgJ3NlbGVjdGVkVHJhY2snLCB0aGUgaW5kZXggb2YgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCB0cmFjaywgYW5kXG4jICdzZWxlY3RUcmFjaycsIGEgY2FsbGJhY2sgdG8gc2V0IHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgdHJhY2suXG5cblJlYWN0ID0gcmVxdWlyZSAncmVhY3QvYWRkb25zJ1xuU29ydGFibGUgPSByZXF1aXJlICcuL21peGlucy9zb3J0YWJsZSdcbktub2IgPSByZXF1aXJlICcuL2tub2InXG5NZXRlciA9IHJlcXVpcmUgJy4vbWV0ZXInXG5NZW51ID0gcmVxdWlyZSAnLi9tZW51J1xuRHJ1bVNhbXBsZXIgPSByZXF1aXJlICcuLi9tb2RlbHMvZHJ1bV9zYW1wbGVyJ1xuQmFzaWNTYW1wbGVyID0gcmVxdWlyZSAnLi4vbW9kZWxzL2Jhc2ljX3NhbXBsZXInXG5Mb29wU2FtcGxlciA9IHJlcXVpcmUgJy4uL21vZGVscy9sb29wX3NhbXBsZXInXG5BbmFsb2dTeW50aGVzaXplciA9IHJlcXVpcmUgJy4uL21vZGVscy9hbmFsb2dfc3ludGhlc2l6ZXInXG5EcnVtU3ludGhlc2l6ZXIgPSByZXF1aXJlICcuLi9tb2RlbHMvZHJ1bV9zeW50aGVzaXplcidcblRyYWNrID0gcmVxdWlyZSAnLi4vbW9kZWxzL3RyYWNrJ1xuUmVhY3RDU1NUcmFuc2l0aW9uR3JvdXAgPSBSZWFjdC5hZGRvbnMuQ1NTVHJhbnNpdGlvbkdyb3VwXG5cblxuIyBkZWZpbmUgYSBwcml2YXRlIGNvbXBvbmVudCByZXByZXNlbnRpbmcgYSBzaW5nbGUgdHJhY2tcblxuVHJhY2tSb3cgPSBSZWFjdC5jcmVhdGVDbGFzc1xuXG4gIG1peGluczogW1xuICAgIFJlYWN0LmFkZG9ucy5QdXJlUmVuZGVyTWl4aW5cbiAgICBTb3J0YWJsZVxuICBdXG5cbiAgcmVuZGVyOiAtPlxuICAgIHRyYWNrID0gQHByb3BzLnRyYWNrXG5cbiAgICBpbnN0cnVtZW50ID0gdHJhY2suY3Vyc29yICdpbnN0cnVtZW50J1xuXG4gICAgY2xhc3NOYW1lID0gJ3RyYWNrJ1xuICAgIGNsYXNzTmFtZSArPSAnIHNlbGVjdGVkJyBpZiBAcHJvcHMuc2VsZWN0ZWRcbiAgICBjbGFzc05hbWUgKz0gJyBkcmFnZ2luZycgaWYgQGlzRHJhZ2dpbmcoKVxuXG4gICAgUmVhY3QuRE9NLmRpdih7IFxcXG4gICAgICBcImNsYXNzTmFtZVwiOiAoY2xhc3NOYW1lKSwgIFxcXG4gICAgICBcIm9uQ2xpY2tcIjogKEBwcm9wcy5zZWxlY3RUcmFjayksICBcXFxuICAgICAgXCJkcmFnZ2FibGVcIjogKHRydWUpLCAgXFxcbiAgICAgIFwib25EcmFnU3RhcnRcIjogKEBkcmFnU3RhcnQpLCAgXFxcbiAgICAgIFwib25EcmFnRW5kXCI6IChAZHJhZ0VuZCksICBcXFxuICAgICAgXCJvbkRyYWdPdmVyXCI6IChAZHJhZ092ZXIpLCAgXFxcbiAgICAgIFwiZGF0YS1pZFwiOiAoQHByb3BzLmluZGV4KVxuICAgIH0sIFxuICAgICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogJ25hbWUnfSwgKHRyYWNrLmdldCAnbmFtZScpKSwgXG4gICAgICBLbm9iKHsgXFxcbiAgICAgICAgXCJsYWJlbFwiOiBcIkxldmVsXCIsICBcXFxuICAgICAgICBcInZhbHVlXCI6IChpbnN0cnVtZW50LmdldCAnbGV2ZWwnKSwgIFxcXG4gICAgICAgIFwib25DaGFuZ2VcIjogKGluc3RydW1lbnQuYmluZCAnbGV2ZWwnKVxuICAgICAgfSksIFxuICAgICAgTWV0ZXIoe1wibGV2ZWxcIjogKHRyYWNrLmdldCAnbWV0ZXJMZXZlbCcpfSlcbiAgICApXG5cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdC5jcmVhdGVDbGFzc1xuXG4gIHByb3BUeXBlczpcbiAgICB0cmFja3M6IFJlYWN0LlByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZFxuICAgIHNlbGVjdGVkVHJhY2s6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZFxuICAgIHNlbGVjdFRyYWNrOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkXG5cbiAgdHJhY2tUeXBlczpcbiAgICAnRHJ1bSBTYW1wbGVyJzogRHJ1bVNhbXBsZXJcbiAgICAnQmFzaWMgU2FtcGxlcic6IEJhc2ljU2FtcGxlclxuICAgICdMb29wIFNhbXBsZXInOiBMb29wU2FtcGxlclxuICAgICdBbmFsb2cgU3ludGgnOiBBbmFsb2dTeW50aGVzaXplclxuICAgICdEcnVtIFN5bnRoJzogRHJ1bVN5bnRoZXNpemVyXG5cbiAgZ2V0SW5pdGlhbFN0YXRlOiAtPlxuICAgIG1lbnVPcGVuOiBmYWxzZVxuICAgIGRyYWdnaW5nOiBudWxsXG5cbiAgY29tcG9uZW50RGlkTW91bnQ6IC0+XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgJ2NsaWNrJywgQGNsb3NlTWVudVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50OiAtPlxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyICdjbGljaycsIEBjbG9zZU1lbnVcblxuICBjbG9zZU1lbnU6IC0+XG4gICAgQHNldFN0YXRlIG1lbnVPcGVuOiBmYWxzZSBpZiBAc3RhdGUubWVudU9wZW5cblxuICB0b2dnbGVNZW51OiAoZSkgLT5cbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG4gICAgQHNldFN0YXRlIG1lbnVPcGVuOiAhQHN0YXRlLm1lbnVPcGVuXG5cbiAgYWRkVHJhY2s6IChuYW1lKSAtPlxuICAgIHRyYWNrID0gVHJhY2suYnVpbGQge25hbWUsIGluc3RydW1lbnQ6IEB0cmFja1R5cGVzW25hbWVdLmJ1aWxkKCl9XG4gICAgaW5kZXggPSBAcHJvcHMudHJhY2tzLmdldCgpLmxlbmd0aFxuXG4gICAgQHByb3BzLnRyYWNrcy5zZXQgW2luZGV4XSwgdHJhY2tcbiAgICBAcHJvcHMuc2VsZWN0VHJhY2sgaW5kZXhcbiAgICBAc2V0U3RhdGUgbWVudU9wZW46IGZhbHNlXG5cbiAgcmVtb3ZlVHJhY2s6IC0+XG4gICAgdHJhY2tzID0gQHByb3BzLnRyYWNrcy5nZXQoKS5zbGljZSAwXG4gICAgdHJhY2tzLnNwbGljZSBAcHJvcHMuc2VsZWN0ZWRUcmFjaywgMVxuICAgIGluZGV4ID0gTWF0aC5tYXggMCwgTWF0aC5taW4gQHByb3BzLnNlbGVjdGVkVHJhY2ssIHRyYWNrcy5sZW5ndGggLSAxXG5cbiAgICBAcHJvcHMuc2VsZWN0VHJhY2sgaW5kZXhcbiAgICBAcHJvcHMudHJhY2tzLnNldCBbXSwgdHJhY2tzXG5cbiAgcmVuZGVyOiAtPlxuICAgIHRyYWNrcyA9IEBwcm9wcy50cmFja3MuZ2V0KClcblxuICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6ICd1aSB0cmFjay1zZWxlY3Rpb24nfSwgXG4gICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcInRyYWNrc1wifSwgXG4gICAgICAgIFJlYWN0Q1NTVHJhbnNpdGlvbkdyb3VwKHtcInRyYW5zaXRpb25OYW1lXCI6IFwidHJhY2tcIn0sIFxuICAgICAgICAgIChcbiAgICAgICAgICAgIHRyYWNrcy5tYXAgKHRyYWNrLCBpKSA9PlxuICAgICAgICAgICAgICBUcmFja1Jvdyh7IFxcXG4gICAgICAgICAgICAgICAgXCJrZXlcIjogKHRyYWNrLl9pZCksICBcXFxuICAgICAgICAgICAgICAgIFwiaW5kZXhcIjogKGkpLCAgXFxcbiAgICAgICAgICAgICAgICBcInRyYWNrXCI6IChAcHJvcHMudHJhY2tzLmN1cnNvciBpKSwgIFxcXG4gICAgICAgICAgICAgICAgXCJzZWxlY3RlZFwiOiAocGFyc2VJbnQoQHByb3BzLnNlbGVjdGVkVHJhY2spID09IHBhcnNlSW50KGkpKSwgIFxcXG4gICAgICAgICAgICAgICAgXCJzZWxlY3RUcmFja1wiOiAoPT4gQHByb3BzLnNlbGVjdFRyYWNrIGkpLCAgXFxcbiAgICAgICAgICAgICAgICBcImRyYWdnaW5nXCI6IChAc3RhdGUuZHJhZ2dpbmcpLCAgXFxcbiAgICAgICAgICAgICAgICBcInVwZGF0ZURyYWdnaW5nXCI6ICgoZHJhZ2dpbmcpID0+IEBzZXRTdGF0ZSB7ZHJhZ2dpbmd9KSwgIFxcXG4gICAgICAgICAgICAgICAgXCJpdGVtc1wiOiAoQHByb3BzLnRyYWNrcylcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgICksIFxuICAgICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJjb250cm9sc1wifSwgXG4gICAgICAgIE1lbnUoeyBcXFxuICAgICAgICAgIFwib3B0aW9uc1wiOiAoT2JqZWN0LmtleXMgQHRyYWNrVHlwZXMpLCAgXFxcbiAgICAgICAgICBcIm9uU2VsZWN0XCI6IChAYWRkVHJhY2spLCAgXFxcbiAgICAgICAgICBcIm9wZW5cIjogKEBzdGF0ZS5tZW51T3BlbilcbiAgICAgICAgfSksIFxuICAgICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcImljb24gaWNvbi1wbHVzIHB1bGwtcmlnaHRcIiwgXCJvbkNsaWNrXCI6IChAdG9nZ2xlTWVudSl9KSwgXG4gICAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwiaWNvbiBpY29uLW1pbnVzIHB1bGwtbGVmdFwiLCBcIm9uQ2xpY2tcIjogKEByZW1vdmVUcmFjayl9KVxuICAgICAgKVxuICAgIClcbiIsIlJlYWN0ID0gcmVxdWlyZSAncmVhY3QvYWRkb25zJ1xuU2l6ZU1lYXN1cmFibGUgPSByZXF1aXJlICcuL21peGlucy9zaXplX21lYXN1cmFibGUnXG5EcmFnZ2FibGUgPSByZXF1aXJlICcuL21peGlucy9kcmFnZ2FibGUnXG5NYXJrZXIgPSByZXF1aXJlICcuL3dhdmVmb3JtL21hcmtlcidcblZpc3VhbGl6YXRpb24gPSByZXF1aXJlICcuL3dhdmVmb3JtL3Zpc3VhbGl6YXRpb24nXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3QuY3JlYXRlQ2xhc3NcblxuICBtaXhpbnM6IFtSZWFjdC5hZGRvbnMuUHVyZVJlbmRlck1peGluLCBTaXplTWVhc3VyYWJsZSwgRHJhZ2dhYmxlXVxuXG4gIHByb3BUeXBlczpcbiAgICBzYW1wbGVEYXRhOiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0XG4gICAgbWFya2VyczogUmVhY3QuUHJvcFR5cGVzLm9iamVjdFxuICAgIHNlbGVjdGlvblN0YXJ0OiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyXG4gICAgc2VsZWN0aW9uRW5kOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyXG4gICAgbWFyZ2luVG9wOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyXG4gICAgbWFyZ2luQm90dG9tOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyXG5cbiAgIyByYW5nZSBpbiBwaXhlbHMgZm9yIHZlcnRpY2FsIGRyYWcgdG8gem9vbVxuICByYW5nZTogMzAwXG4gIGRyYWdUeXBlRGlzdGFuY2U6IDEwXG5cbiAgZ2V0SW5pdGlhbFN0YXRlOiAtPlxuICAgIHdpbmRvd0NlbnRlcjogMC41XG4gICAgd2luZG93U2l6ZTogMVxuXG4gIGdldERlZmF1bHRQcm9wczogLT5cbiAgICBtYXJnaW5Ub3A6IDJcbiAgICBtYXJnaW5Cb3R0b206IDJcblxuICB2YWxpZGF0ZVdpbmRvd0NlbnRlcjogKGNlbnRlcikgLT5cbiAgICBoYWxmU2l6ZSA9IEBzdGF0ZS53aW5kb3dTaXplIC8gMlxuXG4gICAgaWYgY2VudGVyIDwgaGFsZlNpemVcbiAgICAgIGhhbGZTaXplXG4gICAgZWxzZSBpZiBjZW50ZXIgPiAxIC0gaGFsZlNpemVcbiAgICAgIDEgLSBoYWxmU2l6ZVxuICAgIGVsc2VcbiAgICAgIGNlbnRlclxuXG4gIG9uRHJhZ1N0YXJ0OiAtPlxuICAgIEBpbml0aWFsV2luZG93U2l6ZSA9IEBzdGF0ZS53aW5kb3dTaXplXG4gICAgQGluaXRpYWxXaW5kb3dDZW50ZXIgPSBAc3RhdGUud2luZG93Q2VudGVyXG5cbiAgICAjIGdldCBzYW1wbGUgaW5kZXggb2YgaW5pdGlhbCBtb3VzZG93blxuICAgIHJlbGF0aXZlUG9zaXRpb24gPSAoQGRyYWdTdGFydFBvc2l0aW9uLnggLSBAZ2V0RE9NTm9kZSgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQpIC8gQHN0YXRlLndpZHRoXG4gICAgQGluaXRpYWxQb3NpdGlvbiA9IEBzdGF0ZS53aW5kb3dDZW50ZXIgKyBAc3RhdGUud2luZG93U2l6ZSAqIChyZWxhdGl2ZVBvc2l0aW9uIC0gMC41KVxuXG4gIG9uRHJhZ0VuZDogLT5cbiAgICBAZHJhZ1R5cGUgPSBudWxsXG4gICAgQGluaXRpYWxXaW5kb3dTaXplID0gbnVsbFxuICAgIEBpbml0aWFsV2luZG93Q2VudGVyID0gbnVsbFxuICAgIEBpbml0aWFsUG9zaXRpb24gPSBudWxsXG5cbiAgb25EcmFnOiAoZGVsdGEpIC0+XG4gICAgaWYgQGRyYWdUeXBlID09ICdzY2FsZSdcblxuICAgICAgdXBSYW5nZSA9IE1hdGgubWluIEByYW5nZSwgKEBkcmFnU3RhcnRQb3NpdGlvbi55IC0gd2luZG93LnNjcm9sbFkpXG4gICAgICBkb3duUmFuZ2UgPSBNYXRoLm1pbiBAcmFuZ2UsICh3aW5kb3cuaW5uZXJIZWlnaHQgKyB3aW5kb3cuc2Nyb2xsWSAtIEBkcmFnU3RhcnRQb3NpdGlvbi55KVxuXG4gICAgICBpZiBkZWx0YS55IDwgMFxuICAgICAgICBtaW5WYWx1ZSA9IE1hdGgubWluIDEsIEBzdGF0ZS53aWR0aCAvIEBwcm9wcy5zYW1wbGVEYXRhLmxlbmd0aFxuICAgICAgICBzaXplID0gTWF0aC5tYXggbWluVmFsdWUsIEBpbml0aWFsV2luZG93U2l6ZSAqIChkb3duUmFuZ2UgKyBkZWx0YS55KSAvIGRvd25SYW5nZVxuICAgICAgZWxzZVxuICAgICAgICBzaXplID0gTWF0aC5taW4gMSwgQGluaXRpYWxXaW5kb3dTaXplICsgKDEgLSBAaW5pdGlhbFdpbmRvd1NpemUpICogZGVsdGEueSAvIHVwUmFuZ2VcblxuICAgICAgY2VudGVyID0gQGluaXRpYWxQb3NpdGlvbiAtIHNpemUgLyBAaW5pdGlhbFdpbmRvd1NpemUgKiAoQGluaXRpYWxQb3NpdGlvbiAtIEBpbml0aWFsV2luZG93Q2VudGVyKVxuXG4gICAgICBAc2V0U3RhdGVcbiAgICAgICAgd2luZG93U2l6ZTogc2l6ZVxuICAgICAgICB3aW5kb3dDZW50ZXI6IEB2YWxpZGF0ZVdpbmRvd0NlbnRlciBjZW50ZXJcblxuICAgIGVsc2UgaWYgQGRyYWdUeXBlID09ICdwYW4nXG5cbiAgICAgIGNlbnRlciA9IEBpbml0aWFsV2luZG93Q2VudGVyIC0gZGVsdGEueCAvIEBzdGF0ZS53aWR0aCAqIEBpbml0aWFsV2luZG93U2l6ZVxuICAgICAgQHNldFN0YXRlIHdpbmRvd0NlbnRlcjogQHZhbGlkYXRlV2luZG93Q2VudGVyIGNlbnRlclxuXG4gICAgZWxzZVxuICAgICAgaWYgTWF0aC5hYnMoZGVsdGEueCkgPiBAZHJhZ1R5cGVEaXN0YW5jZVxuICAgICAgICBAZHJhZ1R5cGUgPSAncGFuJ1xuICAgICAgZWxzZSBpZiBNYXRoLmFicyhkZWx0YS55KSA+IEBkcmFnVHlwZURpc3RhbmNlXG4gICAgICAgIEBkcmFnVHlwZSA9ICdzY2FsZSdcblxuICByZW5kZXI6IC0+XG5cbiAgICBpZiBAcHJvcHMuc2FtcGxlRGF0YT8gYW5kIEBzdGF0ZS53aWR0aCA+IDBcbiAgICAgIFxuICAgICAgIyByZW5kZXIgd2F2ZWZvcm1cblxuICAgICAgc2FtcGxlRGF0YSA9IEBwcm9wcy5zYW1wbGVEYXRhXG5cbiAgICAgICMgd2luZG93IHNpemUgaW4gc2xpY2VzXG4gICAgICByZXNvbHV0aW9uID0gQHN0YXRlLndpZHRoIC8gMlxuXG4gICAgICAjIHdpbmRvdyBzaXplIGluIHNhbXBsZXNcbiAgICAgIHdpbmRvd1NpemUgPSBNYXRoLm1heCAxLCBNYXRoLmZsb29yIEBzdGF0ZS53aW5kb3dTaXplICogc2FtcGxlRGF0YS5sZW5ndGhcblxuICAgICAgIyBzbGljZSBzaXplIGluIHNhbXBsZXNcbiAgICAgIHNsaWNlU2l6ZSA9IHdpbmRvd1NpemUgLyByZXNvbHV0aW9uXG5cbiAgICAgICMgd2luZG93IHN0YXJ0IGluIHNhbXBsZXNcbiAgICAgIHdpbmRvd1N0YXJ0ID0gTWF0aC5mbG9vciBAc3RhdGUud2luZG93Q2VudGVyICogc2FtcGxlRGF0YS5sZW5ndGggLSB3aW5kb3dTaXplIC8gMlxuXG4gICAgICAjIHNlbGVjdGlvbiBzdGFydCAvIGVuZCBpbiBzbGljZXNcbiAgICAgIHNlbGVjdGlvblN0YXJ0ID0gTWF0aC5mbG9vciAoQHByb3BzLnNlbGVjdGlvblN0YXJ0ICogc2FtcGxlRGF0YS5sZW5ndGggLSB3aW5kb3dTdGFydCkgLyBzbGljZVNpemVcbiAgICAgIHNlbGVjdGlvbkVuZCA9IE1hdGguY2VpbCAoQHByb3BzLnNlbGVjdGlvbkVuZCAqIHNhbXBsZURhdGEubGVuZ3RoIC0gd2luZG93U3RhcnQpIC8gc2xpY2VTaXplXG5cbiAgICAgIGlmIHNlbGVjdGlvblN0YXJ0ID4gMVxuICAgICAgICBwcmVTZWxlY3Rpb24gPSBWaXN1YWxpemF0aW9uKHsgXFxcbiAgICAgICAgICBcInNhbXBsZURhdGFcIjogKHNhbXBsZURhdGEpLCAgXFxcbiAgICAgICAgICBcInJlc29sdXRpb25cIjogKHJlc29sdXRpb24pLCAgXFxcbiAgICAgICAgICBcInNsaWNlU2l6ZVwiOiAoc2xpY2VTaXplKSwgIFxcXG4gICAgICAgICAgXCJ3aW5kb3dTdGFydFwiOiAod2luZG93U3RhcnQpLCAgXFxcbiAgICAgICAgICBcImZyb21TbGljZVwiOiAoMCksICBcXFxuICAgICAgICAgIFwidG9TbGljZVwiOiAoTWF0aC5taW4gcmVzb2x1dGlvbiwgc2VsZWN0aW9uU3RhcnQpLCAgXFxcbiAgICAgICAgICBcIndpZHRoXCI6IChAc3RhdGUud2lkdGgpLCAgXFxcbiAgICAgICAgICBcImhlaWdodFwiOiAoQHN0YXRlLmhlaWdodCksICBcXFxuICAgICAgICAgIFwibWFyZ2luVG9wXCI6IChAcHJvcHMubWFyZ2luVG9wKSwgIFxcXG4gICAgICAgICAgXCJtYXJnaW5Cb3R0b21cIjogKEBwcm9wcy5tYXJnaW5Cb3R0b20pXG4gICAgICAgIH0pXG4gIFxuICAgICAgaWYgc2VsZWN0aW9uU3RhcnQgIT0gc2VsZWN0aW9uRW5kXG4gICAgICAgIHNlbGVjdGlvbiA9IFZpc3VhbGl6YXRpb24oeyBcXFxuICAgICAgICAgIFwic2FtcGxlRGF0YVwiOiAoc2FtcGxlRGF0YSksICBcXFxuICAgICAgICAgIFwicmVzb2x1dGlvblwiOiAocmVzb2x1dGlvbiksICBcXFxuICAgICAgICAgIFwic2xpY2VTaXplXCI6IChzbGljZVNpemUpLCAgXFxcbiAgICAgICAgICBcIndpbmRvd1N0YXJ0XCI6ICh3aW5kb3dTdGFydCksICBcXFxuICAgICAgICAgIFwiZnJvbVNsaWNlXCI6IChNYXRoLm1heCAwLCBzZWxlY3Rpb25TdGFydCksICBcXFxuICAgICAgICAgIFwidG9TbGljZVwiOiAoTWF0aC5taW4gcmVzb2x1dGlvbiwgc2VsZWN0aW9uRW5kKSwgIFxcXG4gICAgICAgICAgXCJ3aWR0aFwiOiAoQHN0YXRlLndpZHRoKSwgIFxcXG4gICAgICAgICAgXCJoZWlnaHRcIjogKEBzdGF0ZS5oZWlnaHQpLCAgXFxcbiAgICAgICAgICBcIm1hcmdpblRvcFwiOiAoQHByb3BzLm1hcmdpblRvcCksICBcXFxuICAgICAgICAgIFwibWFyZ2luQm90dG9tXCI6IChAcHJvcHMubWFyZ2luQm90dG9tKSwgIFxcXG4gICAgICAgICAgXCJzZWxlY3Rpb25cIjogKHRydWUpXG4gICAgICAgIH0pXG4gICAgICBcbiAgICAgIGlmIHNlbGVjdGlvbkVuZCA8IHJlc29sdXRpb25cbiAgICAgICAgcG9zdFNlbGVjdGlvbiA9IFZpc3VhbGl6YXRpb24oeyBcXFxuICAgICAgICAgIFwic2FtcGxlRGF0YVwiOiAoc2FtcGxlRGF0YSksICBcXFxuICAgICAgICAgIFwicmVzb2x1dGlvblwiOiAocmVzb2x1dGlvbiksICBcXFxuICAgICAgICAgIFwic2xpY2VTaXplXCI6IChzbGljZVNpemUpLCAgXFxcbiAgICAgICAgICBcIndpbmRvd1N0YXJ0XCI6ICh3aW5kb3dTdGFydCksICBcXFxuICAgICAgICAgIFwiZnJvbVNsaWNlXCI6IChNYXRoLm1heCAwLCBzZWxlY3Rpb25FbmQpLCAgXFxcbiAgICAgICAgICBcInRvU2xpY2VcIjogKHJlc29sdXRpb24pLCAgXFxcbiAgICAgICAgICBcIndpZHRoXCI6IChAc3RhdGUud2lkdGgpLCAgXFxcbiAgICAgICAgICBcImhlaWdodFwiOiAoQHN0YXRlLmhlaWdodCksICBcXFxuICAgICAgICAgIFwibWFyZ2luVG9wXCI6IChAcHJvcHMubWFyZ2luVG9wKSwgIFxcXG4gICAgICAgICAgXCJtYXJnaW5Cb3R0b21cIjogKEBwcm9wcy5tYXJnaW5Cb3R0b20pXG4gICAgICAgIH0pXG5cbiAgICAgICMgcmVuZGVyIG1hcmtlcnNcbiAgICAgIG1hcmtlcnMgPSBbXVxuICAgICAgaWYgQHByb3BzLm1hcmtlcnM/XG4gICAgICAgIGZvciBuYW1lLCBkYXRhIG9mIEBwcm9wcy5tYXJrZXJzXG4gICAgICAgICAgbWFya2Vycy5wdXNoIE1hcmtlcih7IFxcXG4gICAgICAgICAgICBcImtleVwiOiAobmFtZSksICBcXFxuICAgICAgICAgICAgXCJuYW1lXCI6IChuYW1lKSwgIFxcXG4gICAgICAgICAgICBcInZhbHVlXCI6IChkYXRhLnZhbHVlKSwgIFxcXG4gICAgICAgICAgICBcIm9uQ2hhbmdlXCI6IChkYXRhLm9uQ2hhbmdlKSwgIFxcXG4gICAgICAgICAgICBcInBhcmVudFdpZHRoXCI6IChAc3RhdGUud2lkdGgpLCAgXFxcbiAgICAgICAgICAgIFwicGFyZW50SGVpZ2h0XCI6IChAc3RhdGUuaGVpZ2h0KSwgIFxcXG4gICAgICAgICAgICBcIndpbmRvd1NpemVcIjogKEBzdGF0ZS53aW5kb3dTaXplKSwgIFxcXG4gICAgICAgICAgICBcIndpbmRvd0NlbnRlclwiOiAoQHN0YXRlLndpbmRvd0NlbnRlcilcbiAgICAgICAgICB9KVxuXG4gICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJ1aSB3YXZlZm9ybVwiLCBcInJlZlwiOiBcImNvbnRhaW5lclwifSwgXG4gICAgICBSZWFjdC5ET00uc3ZnKHsgXFxcbiAgICAgICAgXCJ3aWR0aFwiOiAoQHN0YXRlLndpZHRoKSwgIFxcXG4gICAgICAgIFwiaGVpZ2h0XCI6IChAc3RhdGUuaGVpZ2h0KSwgIFxcXG4gICAgICAgIFwib25Nb3VzZURvd25cIjogKGlmIEBwcm9wcy5zYW1wbGVEYXRhPyB0aGVuIEBkcmFnZ2FibGVPbk1vdXNlRG93biBlbHNlIG51bGwpXG4gICAgICB9LCBcbiAgICAgICAgKHByZVNlbGVjdGlvbiksIFxuICAgICAgICAoc2VsZWN0aW9uKSwgXG4gICAgICAgIChwb3N0U2VsZWN0aW9uKSwgXG4gICAgICAgIChtYXJrZXJzKVxuICAgICAgKVxuICAgICkiLCJSZWFjdCA9IHJlcXVpcmUgJ3JlYWN0L2FkZG9ucydcbkRyYWdnYWJsZSA9IHJlcXVpcmUgJy4uL21peGlucy9kcmFnZ2FibGUnXG5cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdC5jcmVhdGVDbGFzc1xuXG4gIG1peGluczogW0RyYWdnYWJsZSwgUmVhY3QuYWRkb25zLlB1cmVSZW5kZXJNaXhpbl1cblxuICBwcm9wVHlwZXM6XG4gICAgbmFtZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZ1xuICAgIHZhbHVlOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyXG4gICAgcGFyZW50V2lkdGg6IFJlYWN0LlByb3BUeXBlcy5udW1iZXJcbiAgICBwYXJlbnRIZWlnaHQ6IFJlYWN0LlByb3BUeXBlcy5udW1iZXJcbiAgICB3aW5kb3dTaXplOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyXG4gICAgd2luZG93Q2VudGVyOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyXG4gICAgd2lkdGg6IFJlYWN0LlByb3BUeXBlcy5udW1iZXJcbiAgICByYWRpdXM6IFJlYWN0LlByb3BUeXBlcy5udW1iZXJcblxuICBnZXREZWZhdWx0UHJvcHM6IC0+XG4gICAgcmFkaXVzOiAyXG4gICAgd2lkdGg6IDRcblxuICBnZXRJbml0aWFsU3RhdGU6IC0+XG4gICAgZHJhZ0FjdGl2ZTogZmFsc2VcblxuICBvbkRyYWdTdGFydDogKGRyYWdTdGFydFBvc2l0aW9uLCBlKSAtPlxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICBAc2V0U3RhdGUgZHJhZ0luaXRpYWxWYWx1ZTogQHByb3BzLnZhbHVlXG5cbiAgb25EcmFnRW5kOiAtPlxuICAgIEBzZXRTdGF0ZSBkcmFnSW5pdGlhbFZhbHVlOiBudWxsXG5cbiAgb25EcmFnOiAoZGVsdGEpIC0+XG4gICAgdmFsdWUgPSBNYXRoLm1heCAwLCBNYXRoLm1pbiAxLCBAc3RhdGUuZHJhZ0luaXRpYWxWYWx1ZSArIGRlbHRhLnggLyBAcHJvcHMucGFyZW50V2lkdGggKiBAcHJvcHMud2luZG93U2l6ZVxuICAgIEBwcm9wcy5vbkNoYW5nZSB2YWx1ZVxuXG4gIHJlbmRlcjogLT5cbiAgICB3aW5kb3dTdGFydCA9IEBwcm9wcy53aW5kb3dDZW50ZXIgLSBAcHJvcHMud2luZG93U2l6ZSAvIDJcbiAgICB3aW5kb3dFbmQgPSBAcHJvcHMud2luZG93Q2VudGVyICsgQHByb3BzLndpbmRvd1NpemUgLyAyXG5cbiAgICByZXR1cm4gUmVhY3QuRE9NLmcobnVsbCkgdW5sZXNzIEBwcm9wcy52YWx1ZSA+PSB3aW5kb3dTdGFydCBhbmQgQHByb3BzLnZhbHVlIDw9IHdpbmRvd0VuZFxuXG4gICAgeCA9IChAcHJvcHMudmFsdWUgLSB3aW5kb3dTdGFydCkgLyBAcHJvcHMud2luZG93U2l6ZSAqIEBwcm9wcy5wYXJlbnRXaWR0aCAtIEBwcm9wcy53aWR0aCAvIDJcbiAgICB4ID0gTWF0aC5tYXggMCwgTWF0aC5taW4gQHByb3BzLnBhcmVudFdpZHRoIC0gQHByb3BzLndpZHRoLCB4XG5cbiAgICBjbGFzc05hbWUgPSBcIm1hcmtlciAje0Bwcm9wcy5uYW1lfVwiXG4gICAgY2xhc3NOYW1lICs9ICcgYWN0aXZlJyBpZiBAc3RhdGUuZHJhZ0luaXRpYWxWYWx1ZT9cblxuICAgIFJlYWN0LkRPTS5nKG51bGwsIFxuICAgICAgUmVhY3QuRE9NLnJlY3QoeyBcXFxuICAgICAgICBcImNsYXNzTmFtZVwiOiAoY2xhc3NOYW1lKSwgIFxcXG4gICAgICAgIFwieFwiOiAoeCksICBcXFxuICAgICAgICBcInlcIjogKDApLCAgXFxcbiAgICAgICAgXCJ3aWR0aFwiOiAoQHByb3BzLndpZHRoKSwgIFxcXG4gICAgICAgIFwiaGVpZ2h0XCI6IChAcHJvcHMucGFyZW50SGVpZ2h0KSwgIFxcXG4gICAgICAgIFwicnhcIjogKEBwcm9wcy5yYWRpdXMpLCAgXFxcbiAgICAgICAgXCJyeVwiOiAoQHByb3BzLnJhZGl1cyksICBcXFxuICAgICAgICBcIm9uTW91c2VEb3duXCI6IChAZHJhZ2dhYmxlT25Nb3VzZURvd24pXG4gICAgICB9KVxuICAgIClcblxuIiwiUmVhY3QgPSByZXF1aXJlICdyZWFjdC9hZGRvbnMnXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3QuY3JlYXRlQ2xhc3NcblxuICBtaXhpbnM6IFtSZWFjdC5hZGRvbnMuUHVyZVJlbmRlck1peGluXVxuXG4gIHJlbmRlcjogLT5cbiAgICBzYW1wbGVEYXRhID0gQHByb3BzLnNhbXBsZURhdGFcbiAgICByZXNvbHV0aW9uID0gQHByb3BzLnJlc29sdXRpb25cbiAgICBzbGljZVNpemUgPSBAcHJvcHMuc2xpY2VTaXplXG4gICAgd2luZG93U3RhcnQgPSBAcHJvcHMud2luZG93U3RhcnRcbiAgICBmcm9tU2xpY2UgPSBAcHJvcHMuZnJvbVNsaWNlXG4gICAgdG9TbGljZSA9IEBwcm9wcy50b1NsaWNlXG4gICAgd2lkdGggPSBAcHJvcHMud2lkdGhcbiAgICBoZWlnaHQgPSBAcHJvcHMuaGVpZ2h0IC0gQHByb3BzLm1hcmdpblRvcCAtIEBwcm9wcy5tYXJnaW5Cb3R0b21cbiAgICB0b3AgPSBAcHJvcHMubWFyZ2luQm90dG9tXG4gICAgYm90dG9tID0gQHByb3BzLmhlaWdodCAtIEBwcm9wcy5tYXJnaW5Cb3R0b21cblxuICAgIHBvaW50cyA9IFtdXG5cbiAgICBwb2ludHMucHVzaCBcIiN7ZnJvbVNsaWNlICogd2lkdGggLyByZXNvbHV0aW9ufSAje2JvdHRvbX1cIlxuXG4gICAgZm9yIGkgaW4gW2Zyb21TbGljZS4udG9TbGljZV1cbiAgICAgIHNsaWNlU3RhcnQgPSBpICogc2xpY2VTaXplICsgd2luZG93U3RhcnRcbiAgICAgIHNsaWNlRW5kID0gc2xpY2VTdGFydCArIHNsaWNlU2l6ZVxuXG4gICAgICB4ID0gaSAqIHdpZHRoIC8gcmVzb2x1dGlvblxuXG4gICAgICB5ID0gMFxuICAgICAgZm9yIGogaW4gW01hdGguZmxvb3Ioc2xpY2VTdGFydCkuLi5NYXRoLmZsb29yKHNsaWNlRW5kKV1cbiAgICAgICAgdiA9IE1hdGguYWJzIHNhbXBsZURhdGFbal1cbiAgICAgICAgeSA9IHYgaWYgdiA+IHlcbiAgICAgIHkgPSAoKCgxIC0geSkgKiBoZWlnaHQpIHx8IDApICsgdG9wXG5cbiAgICAgIHBvaW50cy5wdXNoIFwiI3t4fSAje3l9XCJcblxuICAgIHBvaW50cy5wdXNoIFwiI3t4fSAje2JvdHRvbX1cIlxuXG4gICAgZCA9IFwiTSAje3BvaW50cy5qb2luICcgTCAnfVwiXG5cbiAgICBjbGFzc05hbWUgPSAnc2VsZWN0aW9uJyBpZiBAcHJvcHMuc2VsZWN0aW9uXG5cbiAgICBSZWFjdC5ET00ucGF0aCh7XCJjbGFzc05hbWVcIjogKGNsYXNzTmFtZSksIFwiZFwiOiAoZCl9KSIsIm1vZHVsZS5leHBvcnRzID0gKHdhaXQsIGZ1bmMpIC0+XG4gIHRpbWVvdXQgPSBhcmdzID0gY29udGV4dCA9IHRpbWVzdGFtcCA9IG51bGxcblxuICBsYXRlciA9IC0+XG4gICAgbGFzdCA9IERhdGUubm93KCkgLSB0aW1lc3RhbXBcblxuICAgIGlmIGxhc3QgPCB3YWl0IGFuZCBsYXN0ID4gMFxuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQgbGF0ZXIsIHdhaXQgLSBsYXN0XG4gICAgZWxzZVxuICAgICAgdGltZW91dCA9IG51bGxcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICBjb250ZXh0ID0gYXJncyA9IG51bGwgdW5sZXNzIHRpbWVvdXRcblxuICAtPlxuICAgIGNvbnRleHQgPSB0aGlzXG4gICAgYXJncyA9IGFyZ3VtZW50c1xuICAgIHRpbWVzdGFtcCA9IERhdGUubm93KClcbiAgICB0aW1lb3V0ID0gc2V0VGltZW91dCBsYXRlciwgd2FpdFxuIiwiIyByZWN1cnNpdmVseSBjYWxsIE9iamVjdC5mcmVlemUgb24gYW4gb2JqZWN0IGFuZCBpdHMgcHJvcGVydGllc1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZXBGcmVlemUgPSAobykgLT5cblxuICByZXR1cm4gbyB1bmxlc3MgbyBpbnN0YW5jZW9mIE9iamVjdFxuXG4gIGZvciBwcm9wIGluIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIG9cbiAgICBpZiAoXG4gICAgICBvLmhhc093blByb3BlcnR5KHByb3ApIGFuZFxuICAgICAgb1twcm9wXT8gYW5kXG4gICAgICAodHlwZW9mIG9bcHJvcF0gaXMgJ29iamVjdCcgb3IgdHlwZW9mIG9bcHJvcF0gaXMgJ2Z1bmN0aW9uJykgYW5kXG4gICAgICBub3Qgb1twcm9wXSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSBhbmRcbiAgICAgIG5vdCBPYmplY3QuaXNGcm96ZW4gb1twcm9wXVxuICAgIClcbiAgICAgIGRlZXBGcmVlemUgb1twcm9wXVxuXG4gIE9iamVjdC5mcmVlemUgb1xuIiwiaXNPYmplY3QgPSAobykgLT4gbz8gYW5kIHRvU3RyaW5nLmNhbGwobykgaXMgJ1tvYmplY3QgT2JqZWN0XSdcblxubW9kdWxlLmV4cG9ydHMgPSBkZWVwTWVyZ2UgPSAoc3JjLCBkYXRhKSAtPlxuXG4gIGRzdCA9IGlmIEFycmF5LmlzQXJyYXkgc3JjIHRoZW4gW10gZWxzZSB7fVxuXG4gIGZvciBrZXkgb2Ygc3JjXG4gICAgZHN0W2tleV0gPSBzcmNba2V5XVxuXG4gIGZvciBrZXkgb2YgZGF0YVxuICAgIGlmIGlzT2JqZWN0KGRhdGFba2V5XSkgYW5kIGlzT2JqZWN0KHNyY1trZXldKVxuICAgICAgZHN0W2tleV0gPSBkZWVwTWVyZ2Ugc3JjW2tleV0sIGRhdGFba2V5XVxuICAgIGVsc2VcbiAgICAgIGRzdFtrZXldID0gZGF0YVtrZXldXG5cbiAgZHN0XG4iLCJkZWVwRnJlZXplID0gcmVxdWlyZSAnLi9kZWVwX2ZyZWV6ZSdcbmRlZXBNZXJnZSA9IHJlcXVpcmUgJy4vZGVlcF9tZXJnZSdcblVuZG9IaXN0b3J5ID0gcmVxdWlyZSAnLi91bmRvX2hpc3RvcnknXG5cblxuIyByZXR1cm4gdHJ1ZSBpZiBhbiBvYmplY3QgaGFzIG5vIHByb3Blcml0ZXMsIGZhbHNlIG90aGVyd2lzZVxuaXNFbXB0eSA9IChvKSAtPlxuICBmb3IgaywgdiBvZiBvXG4gICAgcmV0dXJuIGZhbHNlIGlmIG8uaGFzT3duUHJvcGVydHkga1xuICB0cnVlXG5cblxuY2xhc3MgQ2FjaGVcblxuICBjb25zdHJ1Y3RvcjogLT5cbiAgICBAcm9vdCA9IGNoaWxkcmVuOiB7fVxuXG4gIGdldDogKHBhdGgpIC0+XG4gICAgdGFyZ2V0ID0gQHJvb3RcbiAgICBmb3Iga2V5IGluIHBhdGhcbiAgICAgIHRhcmdldCA9IHRhcmdldC5jaGlsZHJlbltrZXldXG4gICAgICByZXR1cm4gdW5kZWZpbmVkIHVubGVzcyB0YXJnZXQ/XG4gICAgdGFyZ2V0LmN1cnNvclxuXG4gIHN0b3JlOiAoY3Vyc29yKSAtPlxuICAgIHRhcmdldCA9IEByb290XG4gICAgZm9yIGtleSBpbiBjdXJzb3IucGF0aFxuICAgICAgdGFyZ2V0LmNoaWxkcmVuW2tleV0gfHw9IGNoaWxkcmVuOiB7fVxuICAgICAgdGFyZ2V0ID0gdGFyZ2V0LmNoaWxkcmVuW2tleV1cbiAgICB0YXJnZXQuY3Vyc29yID0gY3Vyc29yXG5cbiAgY2xlYXJQYXRoOiAocGF0aCkgLT5cbiAgICB0YXJnZXQgPSBAcm9vdFxuICAgIG5vZGVzID0gW11cblxuICAgICMgY2xlYXIgY2FjaGVkIGN1cnNvcnMgYWxvbmcgcGF0aFxuICAgIGZvciBrZXksIGkgaW4gcGF0aFxuICAgICAgYnJlYWsgdW5sZXNzIHRhcmdldC5jaGlsZHJlbltrZXldP1xuICAgICAgdGFyZ2V0ID0gdGFyZ2V0LmNoaWxkcmVuW2tleV1cbiAgICAgIG5vZGVzLnB1c2ggdGFyZ2V0XG4gICAgICBkZWxldGUgdGFyZ2V0LmN1cnNvclxuXG4gICAgIyBwcnVuZSBlbXB0eSBub2RlcyBhbG9uZyBwYXRoIHN0YXJ0aW5nIGF0IGxlYXZlc1xuICAgICMgZm9yIGkgaW4gW25vZGVzLmxlbmd0aCAtIDEgLi4uIDBdXG4gICAgIyAgIG5vZGUgPSBub2Rlc1tpXVxuICAgICMgICBpZiBpc0VtcHR5IG5vZGUuY2hpbGRyZW5cbiAgICAjICAgICBkZWxldGUgbm9kZXNbaSAtIDFdLmNoaWxkcmVuW3BhdGhbaV1dXG4gICAgIyAgIGVsc2VcbiAgICAjICAgICBicmVha1xuXG4gICAgQHJvb3RcblxuICAjIHJlY3Vyc2l2ZWx5IGNsZWFyIGNoYW5nZXMgbWFkZSBieSBtZXJnZVxuXG4gIGNsZWFyT2JqZWN0ID0gKG5vZGUsIGNoYW5nZXMpIC0+XG4gICAgZm9yIGsgb2YgY2hhbmdlc1xuICAgICAgaWYgKGNoaWxkID0gbm9kZS5jaGlsZHJlbltrXSk/XG4gICAgICAgIGRlbGV0ZSBjaGlsZC5jdXJzb3JcbiAgICAgICAgY2xlYXJPYmplY3QgY2hpbGQsIGNoYW5nZXNba11cbiAgICBub2RlXG5cbiAgY2xlYXJPYmplY3Q6IChwYXRoLCBvYmopIC0+XG4gICAgdGFyZ2V0ID0gQHJvb3RcbiAgICBmb3Iga2V5IGluIHBhdGhcbiAgICAgIHRhcmdldCA9IHRhcmdldC5jaGlsZHJlbltrZXldXG4gICAgICByZXR1cm4gdW5sZXNzIHRhcmdldD9cblxuICAgIGNsZWFyT2JqZWN0IHRhcmdldCwgb2JqXG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9XG5cbiAgY3JlYXRlOiAoaW5wdXREYXRhLCBvbkNoYW5nZSkgLT5cbiAgICBjYWNoZSA9IG5ldyBDYWNoZVxuICAgIGhpc3RvcnkgPSBuZXcgVW5kb0hpc3RvcnlcbiAgICBkYXRhID0gZGVlcEZyZWV6ZSBpbnB1dERhdGFcbiAgICBiYXRjaGVkID0gZmFsc2VcblxuICAgICMgZGVjbGFyZSBjdXJzb3IgY2xhc3Mgdy8gYWNjZXNzIHRvIG11dGFibGUgcmVmZXJlbmNlIHRvIGRhdGEgaW4gY2xvc3VyZVxuICAgIGNsYXNzIEN1cnNvclxuXG4gICAgICBjb25zdHJ1Y3RvcjogKEBwYXRoID0gW10pIC0+XG5cbiAgICAgIGN1cnNvcjogKHBhdGggPSBbXSkgLT5cbiAgICAgICAgZnVsbFBhdGggPSBAcGF0aC5jb25jYXQgcGF0aFxuXG4gICAgICAgIHJldHVybiBjYWNoZWQgaWYgKGNhY2hlZCA9IGNhY2hlLmdldCBmdWxsUGF0aCk/XG5cbiAgICAgICAgY3Vyc29yID0gbmV3IEN1cnNvciBmdWxsUGF0aFxuICAgICAgICBjYWNoZS5zdG9yZSBjdXJzb3JcbiAgICAgICAgY3Vyc29yXG5cbiAgICAgIGdldDogKHBhdGggPSBbXSkgLT5cbiAgICAgICAgdGFyZ2V0ID0gZGF0YVxuICAgICAgICBmb3Iga2V5IGluIEBwYXRoLmNvbmNhdCBwYXRoXG4gICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0W2tleV1cbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkIHVubGVzcyB0YXJnZXQ/XG4gICAgICAgIHRhcmdldFxuXG4gICAgICBtb2RpZnlBdDogKHBhdGgsIG1vZGlmaWVyLCBoaXN0b3JpYykgLT5cbiAgICAgICAgZnVsbFBhdGggPSBAcGF0aC5jb25jYXQgcGF0aFxuXG4gICAgICAgIG5ld0RhdGEgPSB0YXJnZXQgPSB7fVxuICAgICAgICB0YXJnZXRba10gPSB2IGZvciBrLCB2IG9mIGRhdGFcblxuICAgICAgICBmb3Iga2V5IGluIGZ1bGxQYXRoLnNsaWNlIDAsIC0xXG4gICAgICAgICAgdXBkYXRlZCA9IGlmIEFycmF5LmlzQXJyYXkgdGFyZ2V0W2tleV0gdGhlbiBbXSBlbHNlIHt9XG4gICAgICAgICAgdXBkYXRlZFtrXSA9IHYgZm9yIGssIHYgb2YgdGFyZ2V0W2tleV1cbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHVwZGF0ZWRcbiAgICAgICAgICBPYmplY3QuZnJlZXplIHRhcmdldFxuICAgICAgICAgIHRhcmdldCA9IHRhcmdldFtrZXldXG5cbiAgICAgICAgbW9kaWZpZXIgdGFyZ2V0LCBmdWxsUGF0aC5zbGljZSAtMVxuICAgICAgICBPYmplY3QuZnJlZXplIHRhcmdldFxuXG4gICAgICAgIGNhY2hlLmNsZWFyUGF0aCBmdWxsUGF0aFxuICAgICAgICB1cGRhdGUgbmV3RGF0YSwgaGlzdG9yaWNcblxuICAgICAgc2V0OiAocGF0aCwgdmFsdWUsIGhpc3RvcmljID0gZmFsc2UpIC0+XG4gICAgICAgIGlmIGFyZ3VtZW50cy5sZW5ndGggaXMgMVxuICAgICAgICAgIHZhbHVlID0gcGF0aFxuICAgICAgICAgIHBhdGggPSBbXVxuXG4gICAgICAgIGlmIEBwYXRoLmxlbmd0aCA+IDAgb3IgcGF0aC5sZW5ndGggPiAwXG4gICAgICAgICAgQG1vZGlmeUF0IHBhdGgsICh0YXJnZXQsIGtleSkgLT5cbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gZGVlcEZyZWV6ZSB2YWx1ZVxuICAgICAgICAgICwgaGlzdG9yaWNcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHVwZGF0ZSB2YWx1ZVxuXG4gICAgICBkZWxldGU6IChwYXRoKSAtPlxuICAgICAgICBpZiBAcGF0aC5sZW5ndGggPiAwIG9yIHBhdGgubGVuZ3RoID4gMFxuICAgICAgICAgIEBtb2RpZnlBdCBwYXRoLCAodGFyZ2V0LCBrZXkpIC0+XG4gICAgICAgICAgICBkZWxldGUgdGFyZ2V0W2tleV1cbiAgICAgICAgICAsIGhpc3RvcmljXG4gICAgICAgIGVsc2VcbiAgICAgICAgICB1cGRhdGUgdW5kZWZpbmVkXG5cbiAgICAgIG1lcmdlOiAobmV3RGF0YSwgaGlzdG9yaWMgPSBmYWxzZSkgLT5cbiAgICAgICAgY2FjaGUuY2xlYXJPYmplY3QgQHBhdGgsIG5ld0RhdGFcbiAgICAgICAgQHNldCBbXSwgZGVlcE1lcmdlKEBnZXQoKSwgZGVlcEZyZWV6ZSBuZXdEYXRhKSwgaGlzdG9yaWNcblxuICAgICAgYmluZDogKHBhdGgsIHByZSwgaGlzdG9yaWMgPSBmYWxzZSkgLT5cbiAgICAgICAgKHYpID0+IEBzZXQgcGF0aCwgKGlmIHByZSB0aGVuIHByZSB2IGVsc2UgdiksIGhpc3RvcmljXG5cbiAgICAgIGhhczogKHBhdGgpIC0+XG4gICAgICAgIEBnZXQocGF0aCk/XG5cbiAgICAgIGJhdGNoZWQ6IChjYiwgaGlzdG9yaWMgPSBmYWxzZSkgLT5cbiAgICAgICAgYmF0Y2hlZCA9IHRydWVcbiAgICAgICAgY2IoKVxuICAgICAgICBiYXRjaGVkID0gZmFsc2VcbiAgICAgICAgdXBkYXRlIGRhdGEsIGhpc3RvcmljXG5cblxuICAgIHVwZGF0ZSA9IChuZXdEYXRhLCBoaXN0b3JpYykgLT5cbiAgICAgIGRhdGEgPSBuZXdEYXRhXG5cbiAgICAgIHVubGVzcyBiYXRjaGVkXG4gICAgICAgIGN1cnNvciA9IG5ldyBDdXJzb3IoKVxuICAgICAgICBoaXN0b3J5LnVwZGF0ZSBjdXJzb3IgaWYgaGlzdG9yaWNcbiAgICAgICAgb25DaGFuZ2UgY3Vyc29yLCBoaXN0b3J5XG5cblxuICAgICMgcGVyZm9ybSBjYWxsYmFjayBvbmUgdGltZSB0byBzdGFydFxuICAgIG9uQ2hhbmdlIG5ldyBDdXJzb3IoKSwgaGlzdG9yeVxuXG4iLCJSZWFjdCA9IHJlcXVpcmUgJ3JlYWN0J1xuXG5rZXlzID0gWydDJywgJ0MjJywgJ0QnLCAnRCMnLCAnRScsICdGJywgJ0YjJywgJ0cnLCAnRyMnLCAnQScsICdBIycsICdCJ11cblxubW9kdWxlLmV4cG9ydHMgPSAtPlxuICBmb3IgaSBpbiBbMTI3Li4wXVxuICAgIG9jdGF2ZSA9IE1hdGguZmxvb3IoaSAvIDEyKSAtIDJcbiAgICBub3RlID0ga2V5c1tpICUgMTJdXG4gICAgUmVhY3QuRE9NLm9wdGlvbih7XCJrZXlcIjogKGkpLCBcInZhbHVlXCI6IChpKX0sIChcIiN7bm90ZX0je29jdGF2ZX1cIikpIiwiaSA9IDBcbm1vZHVsZS5leHBvcnRzID0gKHYpIC0+XG4gIGNvbnNvbGUubG9nKHYpIGlmIGkgPT0gMFxuICBpID0gKGkgKyAxKSAlIDcwMDBcbiIsIm5leHRJZCA9IDBcbmFjdGlvbnMgPSB7fVxuXG5hcHBseSA9IC0+XG4gIG1heCA9IG51bGxcblxuICBmb3IgaWQsIGFjdGlvbiBvZiBhY3Rpb25zXG4gICAgbWF4ID0gaWQgaWYgIW1heD8gb3IgYWN0aW9uLnByaW9yaXR5ID4gYWN0aW9uc1ttYXhdLnByaW9yaXR5XG5cbiAgZG9jdW1lbnQuYm9keS5zdHlsZS5jdXJzb3IgPSBpZiBtYXggdGhlbiBhY3Rpb25zW21heF0udmFsdWUgZWxzZSAnZGVmYXVsdCdcblxuXG5tb2R1bGUuZXhwb3J0cyA9XG5cbiAgc2V0OiAodmFsdWUsIHByaW9yaXR5LCBpZCkgLT5cbiAgICBpZCB8fD0gbmV4dElkICs9IDFcbiAgICBhY3Rpb25zW2lkXSA9IHt2YWx1ZSwgcHJpb3JpdHl9XG4gICAgYXBwbHkoKVxuXG4gICAgaWRcblxuICBjbGVhcjogKGlkKSAtPlxuICAgIGRlbGV0ZSBhY3Rpb25zW2lkXVxuICAgIGFwcGx5KClcbiIsIm1vZHVsZS5leHBvcnRzID0gY2xhc3MgUmluZ0J1ZmZlclxuICBcbiAgY29uc3RydWN0b3I6IChAbWF4TGVuZ3RoLCBAVHlwZSA9IEZsb2F0MzJBcnJheSwgQGxlbmd0aCkgLT5cbiAgICBAbGVuZ3RoIHx8PSBAbWF4TGVuZ3RoXG4gICAgQGFycmF5ID0gbmV3IFR5cGUgQG1heExlbmd0aFxuICAgIEBwb3MgPSAwXG5cbiAgcmVzZXQ6IC0+XG4gICAgQGFycmF5ID0gbmV3IEBUeXBlIEBtYXhMZW5ndGhcbiAgICB0aGlzXG5cbiAgcmVzaXplOiAoQGxlbmd0aCkgLT5cbiAgICBAcG9zID0gMCBpZiBAcG9zID49IEBsZW5ndGhcblxuICBwdXNoOiAoZWwpIC0+XG4gICAgQGFycmF5W0Bwb3NdID0gZWxcbiAgICBAcG9zICs9IDFcbiAgICBAcG9zID0gMCBpZiBAcG9zID09IEBsZW5ndGhcbiAgICB0aGlzXG5cbiAgZm9yRWFjaDogKGZuKSAtPlxuICAgIGB2YXIgaSwgbGVuO1xuICAgIGZvciAoaSA9IHRoaXMucG9zLCBsZW4gPSB0aGlzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBmbih0aGlzLmFycmF5W2ldLCBpKTtcbiAgICB9XG4gICAgZm9yIChpID0gMCwgbGVuID0gdGhpcy5wb3M7IGkgPCBsZW47IGkrKykge1xuICAgICAgZm4odGhpcy5hcnJheVtpXSwgaSk7XG4gICAgfWBcbiAgICB0aGlzXG5cbiAgcmVkdWNlOiAoZm4sIG1lbW8gPSAwKSAtPlxuICAgIEBmb3JFYWNoIChlbCwgaSkgLT5cbiAgICAgIG1lbW8gPSBmbiBtZW1vLCBlbCwgaVxuICAgIG1lbW9cbiIsIlJlYWN0ID0gcmVxdWlyZSAncmVhY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gLT5cbiAgZm9yIGkgaW4gWzI0Li4tMjRdXG4gICAgUmVhY3QuRE9NLm9wdGlvbih7XCJrZXlcIjogKGkpLCBcInZhbHVlXCI6IChpKX0sIChpKSlcbiIsImRlYm91bmNlID0gcmVxdWlyZSAnLi9kZWJvdW5jZSdcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBVbmRvSGlzdG9yeVxuXG4gIGNvbnN0cnVjdG9yOiAoQHNpemUgPSAxMDAsIEBpbnRlcnZhbCA9IDMwMCkgLT5cbiAgICBAdW5kb3MgPSBbXVxuICAgIEByZWRvcyA9IFtdXG4gICAgQGN1cnNvciA9IG51bGxcbiAgICBAZGF0YSA9IG51bGxcbiAgICBAcmVjb3JkID0gZGVib3VuY2UgQGludGVydmFsLCA9PlxuICAgICAgQHVuZG9zLnB1c2ggQGN1cnNvci5nZXQoKVxuXG4gIHVwZGF0ZTogKG5ld0N1cnNvcikgLT5cbiAgICByZXR1cm4gaWYgQGN1cnNvciBpcyBuZXdDdXJzb3JcbiAgICBAY3Vyc29yID0gbmV3Q3Vyc29yXG4gICAgQGRhdGEgPSBAY3Vyc29yLmdldCgpXG4gICAgQHJlY29yZCgpXG5cbiAgdW5kbzogLT5cbiAgICBjb25zb2xlLmxvZyAnaGVyZSdcbiAgICByZXR1cm4gdW5sZXNzIEB1bmRvcy5sZW5ndGggPiAwXG4gICAgQHJlZG9zLnB1c2ggQGRhdGFcbiAgICBAcmVkb3Muc2hpZnQoKSBpZiBAcmVkb3MubGVuZ3RoID4gQHNpemVcbiAgICBjb25zb2xlLmxvZyBAZGF0YVxuICAgIEBkYXRhID0gQHVuZG9zLnBvcCgpXG4gICAgY29uc29sZS5sb2cgQGRhdGFcbiAgICBAY3Vyc29yLnNldCBAZGF0YVxuXG4gIHJlZG86IC0+XG4gICAgcmV0dXJuIHVubGVzcyBAcmVkb3MubGVuZ3RoID4gMFxuICAgIEB1bmRvcy5wdXNoIEBkYXRhXG4gICAgQHVuZG9zLnNoaWZ0KCkgaWYgQHVuZG9zLmxlbmd0aCA+IEBzaXplXG4gICAgQGRhdGEgPSBAcmVkb3MucG9wKClcbiAgICBAY3Vyc29yLnNldCBAZGF0YVxuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qIVxuICogYXN5bmNcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jYW9sYW4vYXN5bmNcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMC0yMDE0IENhb2xhbiBNY01haG9uXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqL1xuLypqc2hpbnQgb25ldmFyOiBmYWxzZSwgaW5kZW50OjQgKi9cbi8qZ2xvYmFsIHNldEltbWVkaWF0ZTogZmFsc2UsIHNldFRpbWVvdXQ6IGZhbHNlLCBjb25zb2xlOiBmYWxzZSAqL1xuKGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBhc3luYyA9IHt9O1xuXG4gICAgLy8gZ2xvYmFsIG9uIHRoZSBzZXJ2ZXIsIHdpbmRvdyBpbiB0aGUgYnJvd3NlclxuICAgIHZhciByb290LCBwcmV2aW91c19hc3luYztcblxuICAgIHJvb3QgPSB0aGlzO1xuICAgIGlmIChyb290ICE9IG51bGwpIHtcbiAgICAgIHByZXZpb3VzX2FzeW5jID0gcm9vdC5hc3luYztcbiAgICB9XG5cbiAgICBhc3luYy5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByb290LmFzeW5jID0gcHJldmlvdXNfYXN5bmM7XG4gICAgICAgIHJldHVybiBhc3luYztcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gb25seV9vbmNlKGZuKSB7XG4gICAgICAgIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGNhbGxlZCkgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbGJhY2sgd2FzIGFscmVhZHkgY2FsbGVkLlwiKTtcbiAgICAgICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgICBmbi5hcHBseShyb290LCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8vLyBjcm9zcy1icm93c2VyIGNvbXBhdGlibGl0eSBmdW5jdGlvbnMgLy8vL1xuXG4gICAgdmFyIF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbiAgICB2YXIgX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIF90b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfTtcblxuICAgIHZhciBfZWFjaCA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yKSB7XG4gICAgICAgIGlmIChhcnIuZm9yRWFjaCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyci5mb3JFYWNoKGl0ZXJhdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgaXRlcmF0b3IoYXJyW2ldLCBpLCBhcnIpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBfbWFwID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IpIHtcbiAgICAgICAgaWYgKGFyci5tYXApIHtcbiAgICAgICAgICAgIHJldHVybiBhcnIubWFwKGl0ZXJhdG9yKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBfZWFjaChhcnIsIGZ1bmN0aW9uICh4LCBpLCBhKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goaXRlcmF0b3IoeCwgaSwgYSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcblxuICAgIHZhciBfcmVkdWNlID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIG1lbW8pIHtcbiAgICAgICAgaWYgKGFyci5yZWR1Y2UpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnIucmVkdWNlKGl0ZXJhdG9yLCBtZW1vKTtcbiAgICAgICAgfVxuICAgICAgICBfZWFjaChhcnIsIGZ1bmN0aW9uICh4LCBpLCBhKSB7XG4gICAgICAgICAgICBtZW1vID0gaXRlcmF0b3IobWVtbywgeCwgaSwgYSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWVtbztcbiAgICB9O1xuXG4gICAgdmFyIF9rZXlzID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrZXlzID0gW107XG4gICAgICAgIGZvciAodmFyIGsgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKGspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgIH07XG5cbiAgICAvLy8vIGV4cG9ydGVkIGFzeW5jIG1vZHVsZSBmdW5jdGlvbnMgLy8vL1xuXG4gICAgLy8vLyBuZXh0VGljayBpbXBsZW1lbnRhdGlvbiB3aXRoIGJyb3dzZXItY29tcGF0aWJsZSBmYWxsYmFjayAvLy8vXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJyB8fCAhKHByb2Nlc3MubmV4dFRpY2spKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBhc3luYy5uZXh0VGljayA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAgIC8vIG5vdCBhIGRpcmVjdCBhbGlhcyBmb3IgSUUxMCBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKGZuKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUgPSBhc3luYy5uZXh0VGljaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFzeW5jLm5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlID0gYXN5bmMubmV4dFRpY2s7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFzeW5jLm5leHRUaWNrID0gcHJvY2Vzcy5uZXh0VGljaztcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgICAgLy8gbm90IGEgZGlyZWN0IGFsaWFzIGZvciBJRTEwIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKGZuKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUgPSBhc3luYy5uZXh0VGljaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jLmVhY2ggPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgaWYgKCFhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29tcGxldGVkID0gMDtcbiAgICAgICAgX2VhY2goYXJyLCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgaXRlcmF0b3IoeCwgb25seV9vbmNlKGRvbmUpICk7XG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiBkb25lKGVycikge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGNvbXBsZXRlZCArPSAxO1xuICAgICAgICAgICAgICBpZiAoY29tcGxldGVkID49IGFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGFzeW5jLmZvckVhY2ggPSBhc3luYy5lYWNoO1xuXG4gICAgYXN5bmMuZWFjaFNlcmllcyA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICBpZiAoIWFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb21wbGV0ZWQgPSAwO1xuICAgICAgICB2YXIgaXRlcmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKGFycltjb21wbGV0ZWRdLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGVkICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZWQgPj0gYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXJhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBpdGVyYXRlKCk7XG4gICAgfTtcbiAgICBhc3luYy5mb3JFYWNoU2VyaWVzID0gYXN5bmMuZWFjaFNlcmllcztcblxuICAgIGFzeW5jLmVhY2hMaW1pdCA9IGZ1bmN0aW9uIChhcnIsIGxpbWl0LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGZuID0gX2VhY2hMaW1pdChsaW1pdCk7XG4gICAgICAgIGZuLmFwcGx5KG51bGwsIFthcnIsIGl0ZXJhdG9yLCBjYWxsYmFja10pO1xuICAgIH07XG4gICAgYXN5bmMuZm9yRWFjaExpbWl0ID0gYXN5bmMuZWFjaExpbWl0O1xuXG4gICAgdmFyIF9lYWNoTGltaXQgPSBmdW5jdGlvbiAobGltaXQpIHtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgaWYgKCFhcnIubGVuZ3RoIHx8IGxpbWl0IDw9IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjb21wbGV0ZWQgPSAwO1xuICAgICAgICAgICAgdmFyIHN0YXJ0ZWQgPSAwO1xuICAgICAgICAgICAgdmFyIHJ1bm5pbmcgPSAwO1xuXG4gICAgICAgICAgICAoZnVuY3Rpb24gcmVwbGVuaXNoICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29tcGxldGVkID49IGFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgd2hpbGUgKHJ1bm5pbmcgPCBsaW1pdCAmJiBzdGFydGVkIDwgYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydGVkICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIHJ1bm5pbmcgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3IoYXJyW3N0YXJ0ZWQgLSAxXSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlZCArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5pbmcgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGxldGVkID49IGFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxlbmlzaCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG5cbiAgICB2YXIgZG9QYXJhbGxlbCA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIFthc3luYy5lYWNoXS5jb25jYXQoYXJncykpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgdmFyIGRvUGFyYWxsZWxMaW1pdCA9IGZ1bmN0aW9uKGxpbWl0LCBmbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIFtfZWFjaExpbWl0KGxpbWl0KV0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHZhciBkb1NlcmllcyA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIFthc3luYy5lYWNoU2VyaWVzXS5jb25jYXQoYXJncykpO1xuICAgICAgICB9O1xuICAgIH07XG5cblxuICAgIHZhciBfYXN5bmNNYXAgPSBmdW5jdGlvbiAoZWFjaGZuLCBhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBhcnIgPSBfbWFwKGFyciwgZnVuY3Rpb24gKHgsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiB7aW5kZXg6IGksIHZhbHVlOiB4fTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGVhY2hmbihhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yKHgudmFsdWUsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGVhY2hmbihhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yKHgudmFsdWUsIGZ1bmN0aW9uIChlcnIsIHYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1t4LmluZGV4XSA9IHY7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBhc3luYy5tYXAgPSBkb1BhcmFsbGVsKF9hc3luY01hcCk7XG4gICAgYXN5bmMubWFwU2VyaWVzID0gZG9TZXJpZXMoX2FzeW5jTWFwKTtcbiAgICBhc3luYy5tYXBMaW1pdCA9IGZ1bmN0aW9uIChhcnIsIGxpbWl0LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIF9tYXBMaW1pdChsaW1pdCkoYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICB2YXIgX21hcExpbWl0ID0gZnVuY3Rpb24obGltaXQpIHtcbiAgICAgICAgcmV0dXJuIGRvUGFyYWxsZWxMaW1pdChsaW1pdCwgX2FzeW5jTWFwKTtcbiAgICB9O1xuXG4gICAgLy8gcmVkdWNlIG9ubHkgaGFzIGEgc2VyaWVzIHZlcnNpb24sIGFzIGRvaW5nIHJlZHVjZSBpbiBwYXJhbGxlbCB3b24ndFxuICAgIC8vIHdvcmsgaW4gbWFueSBzaXR1YXRpb25zLlxuICAgIGFzeW5jLnJlZHVjZSA9IGZ1bmN0aW9uIChhcnIsIG1lbW8sIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBhc3luYy5lYWNoU2VyaWVzKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpdGVyYXRvcihtZW1vLCB4LCBmdW5jdGlvbiAoZXJyLCB2KSB7XG4gICAgICAgICAgICAgICAgbWVtbyA9IHY7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsIG1lbW8pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIGluamVjdCBhbGlhc1xuICAgIGFzeW5jLmluamVjdCA9IGFzeW5jLnJlZHVjZTtcbiAgICAvLyBmb2xkbCBhbGlhc1xuICAgIGFzeW5jLmZvbGRsID0gYXN5bmMucmVkdWNlO1xuXG4gICAgYXN5bmMucmVkdWNlUmlnaHQgPSBmdW5jdGlvbiAoYXJyLCBtZW1vLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJldmVyc2VkID0gX21hcChhcnIsIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfSkucmV2ZXJzZSgpO1xuICAgICAgICBhc3luYy5yZWR1Y2UocmV2ZXJzZWQsIG1lbW8sIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICAvLyBmb2xkciBhbGlhc1xuICAgIGFzeW5jLmZvbGRyID0gYXN5bmMucmVkdWNlUmlnaHQ7XG5cbiAgICB2YXIgX2ZpbHRlciA9IGZ1bmN0aW9uIChlYWNoZm4sIGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIGFyciA9IF9tYXAoYXJyLCBmdW5jdGlvbiAoeCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHtpbmRleDogaSwgdmFsdWU6IHh9O1xuICAgICAgICB9KTtcbiAgICAgICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpdGVyYXRvcih4LnZhbHVlLCBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhfbWFwKHJlc3VsdHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhLmluZGV4IC0gYi5pbmRleDtcbiAgICAgICAgICAgIH0pLCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4LnZhbHVlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGFzeW5jLmZpbHRlciA9IGRvUGFyYWxsZWwoX2ZpbHRlcik7XG4gICAgYXN5bmMuZmlsdGVyU2VyaWVzID0gZG9TZXJpZXMoX2ZpbHRlcik7XG4gICAgLy8gc2VsZWN0IGFsaWFzXG4gICAgYXN5bmMuc2VsZWN0ID0gYXN5bmMuZmlsdGVyO1xuICAgIGFzeW5jLnNlbGVjdFNlcmllcyA9IGFzeW5jLmZpbHRlclNlcmllcztcblxuICAgIHZhciBfcmVqZWN0ID0gZnVuY3Rpb24gKGVhY2hmbiwgYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgYXJyID0gX21hcChhcnIsIGZ1bmN0aW9uICh4LCBpKSB7XG4gICAgICAgICAgICByZXR1cm4ge2luZGV4OiBpLCB2YWx1ZTogeH07XG4gICAgICAgIH0pO1xuICAgICAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgudmFsdWUsIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF2KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhfbWFwKHJlc3VsdHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhLmluZGV4IC0gYi5pbmRleDtcbiAgICAgICAgICAgIH0pLCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4LnZhbHVlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGFzeW5jLnJlamVjdCA9IGRvUGFyYWxsZWwoX3JlamVjdCk7XG4gICAgYXN5bmMucmVqZWN0U2VyaWVzID0gZG9TZXJpZXMoX3JlamVjdCk7XG5cbiAgICB2YXIgX2RldGVjdCA9IGZ1bmN0aW9uIChlYWNoZm4sIGFyciwgaXRlcmF0b3IsIG1haW5fY2FsbGJhY2spIHtcbiAgICAgICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpdGVyYXRvcih4LCBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBtYWluX2NhbGxiYWNrKHgpO1xuICAgICAgICAgICAgICAgICAgICBtYWluX2NhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBtYWluX2NhbGxiYWNrKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgYXN5bmMuZGV0ZWN0ID0gZG9QYXJhbGxlbChfZGV0ZWN0KTtcbiAgICBhc3luYy5kZXRlY3RTZXJpZXMgPSBkb1NlcmllcyhfZGV0ZWN0KTtcblxuICAgIGFzeW5jLnNvbWUgPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgbWFpbl9jYWxsYmFjaykge1xuICAgICAgICBhc3luYy5lYWNoKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpdGVyYXRvcih4LCBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgIG1haW5fY2FsbGJhY2sodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIG1haW5fY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBtYWluX2NhbGxiYWNrKGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBhbnkgYWxpYXNcbiAgICBhc3luYy5hbnkgPSBhc3luYy5zb21lO1xuXG4gICAgYXN5bmMuZXZlcnkgPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgbWFpbl9jYWxsYmFjaykge1xuICAgICAgICBhc3luYy5lYWNoKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpdGVyYXRvcih4LCBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIGlmICghdikge1xuICAgICAgICAgICAgICAgICAgICBtYWluX2NhbGxiYWNrKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgbWFpbl9jYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIG1haW5fY2FsbGJhY2sodHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gYWxsIGFsaWFzXG4gICAgYXN5bmMuYWxsID0gYXN5bmMuZXZlcnk7XG5cbiAgICBhc3luYy5zb3J0QnkgPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgYXN5bmMubWFwKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpdGVyYXRvcih4LCBmdW5jdGlvbiAoZXJyLCBjcml0ZXJpYSkge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHt2YWx1ZTogeCwgY3JpdGVyaWE6IGNyaXRlcmlhfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIsIHJlc3VsdHMpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBmbiA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IGxlZnQuY3JpdGVyaWEsIGIgPSByaWdodC5jcml0ZXJpYTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgX21hcChyZXN1bHRzLnNvcnQoZm4pLCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBhc3luYy5hdXRvID0gZnVuY3Rpb24gKHRhc2tzLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICB2YXIga2V5cyA9IF9rZXlzKHRhc2tzKTtcbiAgICAgICAgdmFyIHJlbWFpbmluZ1Rhc2tzID0ga2V5cy5sZW5ndGhcbiAgICAgICAgaWYgKCFyZW1haW5pbmdUYXNrcykge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0cyA9IHt9O1xuXG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgdmFyIGFkZExpc3RlbmVyID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnMudW5zaGlmdChmbik7XG4gICAgICAgIH07XG4gICAgICAgIHZhciByZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXJzW2ldID09PSBmbikge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgdGFza0NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVtYWluaW5nVGFza3MtLVxuICAgICAgICAgICAgX2VhY2gobGlzdGVuZXJzLnNsaWNlKDApLCBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgYWRkTGlzdGVuZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFyZW1haW5pbmdUYXNrcykge1xuICAgICAgICAgICAgICAgIHZhciB0aGVDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgZmluYWwgY2FsbGJhY2sgZnJvbSBjYWxsaW5nIGl0c2VsZiBpZiBpdCBlcnJvcnNcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgICAgICAgICAgICAgdGhlQ2FsbGJhY2sobnVsbCwgcmVzdWx0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIF9lYWNoKGtleXMsIGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9IF9pc0FycmF5KHRhc2tzW2tdKSA/IHRhc2tzW2tdOiBbdGFza3Nba11dO1xuICAgICAgICAgICAgdmFyIHRhc2tDYWxsYmFjayA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNhZmVSZXN1bHRzID0ge307XG4gICAgICAgICAgICAgICAgICAgIF9lYWNoKF9rZXlzKHJlc3VsdHMpLCBmdW5jdGlvbihya2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzYWZlUmVzdWx0c1tya2V5XSA9IHJlc3VsdHNbcmtleV07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzYWZlUmVzdWx0c1trXSA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgc2FmZVJlc3VsdHMpO1xuICAgICAgICAgICAgICAgICAgICAvLyBzdG9wIHN1YnNlcXVlbnQgZXJyb3JzIGhpdHRpbmcgY2FsbGJhY2sgbXVsdGlwbGUgdGltZXNcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHNba10gPSBhcmdzO1xuICAgICAgICAgICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUodGFza0NvbXBsZXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHJlcXVpcmVzID0gdGFzay5zbGljZSgwLCBNYXRoLmFicyh0YXNrLmxlbmd0aCAtIDEpKSB8fCBbXTtcbiAgICAgICAgICAgIHZhciByZWFkeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3JlZHVjZShyZXF1aXJlcywgZnVuY3Rpb24gKGEsIHgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChhICYmIHJlc3VsdHMuaGFzT3duUHJvcGVydHkoeCkpO1xuICAgICAgICAgICAgICAgIH0sIHRydWUpICYmICFyZXN1bHRzLmhhc093blByb3BlcnR5KGspO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChyZWFkeSgpKSB7XG4gICAgICAgICAgICAgICAgdGFza1t0YXNrLmxlbmd0aCAtIDFdKHRhc2tDYWxsYmFjaywgcmVzdWx0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWFkeSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrW3Rhc2subGVuZ3RoIC0gMV0odGFza0NhbGxiYWNrLCByZXN1bHRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYWRkTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgYXN5bmMucmV0cnkgPSBmdW5jdGlvbih0aW1lcywgdGFzaywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIERFRkFVTFRfVElNRVMgPSA1O1xuICAgICAgICB2YXIgYXR0ZW1wdHMgPSBbXTtcbiAgICAgICAgLy8gVXNlIGRlZmF1bHRzIGlmIHRpbWVzIG5vdCBwYXNzZWRcbiAgICAgICAgaWYgKHR5cGVvZiB0aW1lcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSB0YXNrO1xuICAgICAgICAgICAgdGFzayA9IHRpbWVzO1xuICAgICAgICAgICAgdGltZXMgPSBERUZBVUxUX1RJTUVTO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aW1lcyBpcyBhIG51bWJlclxuICAgICAgICB0aW1lcyA9IHBhcnNlSW50KHRpbWVzLCAxMCkgfHwgREVGQVVMVF9USU1FUztcbiAgICAgICAgdmFyIHdyYXBwZWRUYXNrID0gZnVuY3Rpb24od3JhcHBlZENhbGxiYWNrLCB3cmFwcGVkUmVzdWx0cykge1xuICAgICAgICAgICAgdmFyIHJldHJ5QXR0ZW1wdCA9IGZ1bmN0aW9uKHRhc2ssIGZpbmFsQXR0ZW1wdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihzZXJpZXNDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICB0YXNrKGZ1bmN0aW9uKGVyciwgcmVzdWx0KXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc0NhbGxiYWNrKCFlcnIgfHwgZmluYWxBdHRlbXB0LCB7ZXJyOiBlcnIsIHJlc3VsdDogcmVzdWx0fSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHdyYXBwZWRSZXN1bHRzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHdoaWxlICh0aW1lcykge1xuICAgICAgICAgICAgICAgIGF0dGVtcHRzLnB1c2gocmV0cnlBdHRlbXB0KHRhc2ssICEodGltZXMtPTEpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3luYy5zZXJpZXMoYXR0ZW1wdHMsIGZ1bmN0aW9uKGRvbmUsIGRhdGEpe1xuICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhW2RhdGEubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgKHdyYXBwZWRDYWxsYmFjayB8fCBjYWxsYmFjaykoZGF0YS5lcnIsIGRhdGEucmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGEgY2FsbGJhY2sgaXMgcGFzc2VkLCBydW4gdGhpcyBhcyBhIGNvbnRyb2xsIGZsb3dcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrID8gd3JhcHBlZFRhc2soKSA6IHdyYXBwZWRUYXNrXG4gICAgfTtcblxuICAgIGFzeW5jLndhdGVyZmFsbCA9IGZ1bmN0aW9uICh0YXNrcywgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgaWYgKCFfaXNBcnJheSh0YXNrcykpIHtcbiAgICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCB0byB3YXRlcmZhbGwgbXVzdCBiZSBhbiBhcnJheSBvZiBmdW5jdGlvbnMnKTtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRhc2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdyYXBJdGVyYXRvciA9IGZ1bmN0aW9uIChpdGVyYXRvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKHdyYXBJdGVyYXRvcihuZXh0KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVyYXRvci5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgd3JhcEl0ZXJhdG9yKGFzeW5jLml0ZXJhdG9yKHRhc2tzKSkoKTtcbiAgICB9O1xuXG4gICAgdmFyIF9wYXJhbGxlbCA9IGZ1bmN0aW9uKGVhY2hmbiwgdGFza3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG4gICAgICAgIGlmIChfaXNBcnJheSh0YXNrcykpIHtcbiAgICAgICAgICAgIGVhY2hmbi5tYXAodGFza3MsIGZ1bmN0aW9uIChmbiwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgICAgICAgICAgZm4oZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwobnVsbCwgZXJyLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB7fTtcbiAgICAgICAgICAgIGVhY2hmbi5lYWNoKF9rZXlzKHRhc2tzKSwgZnVuY3Rpb24gKGssIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdGFza3Nba10oZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2tdID0gYXJncztcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgYXN5bmMucGFyYWxsZWwgPSBmdW5jdGlvbiAodGFza3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIF9wYXJhbGxlbCh7IG1hcDogYXN5bmMubWFwLCBlYWNoOiBhc3luYy5lYWNoIH0sIHRhc2tzLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIGFzeW5jLnBhcmFsbGVsTGltaXQgPSBmdW5jdGlvbih0YXNrcywgbGltaXQsIGNhbGxiYWNrKSB7XG4gICAgICAgIF9wYXJhbGxlbCh7IG1hcDogX21hcExpbWl0KGxpbWl0KSwgZWFjaDogX2VhY2hMaW1pdChsaW1pdCkgfSwgdGFza3MsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgYXN5bmMuc2VyaWVzID0gZnVuY3Rpb24gKHRhc2tzLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICBpZiAoX2lzQXJyYXkodGFza3MpKSB7XG4gICAgICAgICAgICBhc3luYy5tYXBTZXJpZXModGFza3MsIGZ1bmN0aW9uIChmbiwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgICAgICAgICAgZm4oZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwobnVsbCwgZXJyLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB7fTtcbiAgICAgICAgICAgIGFzeW5jLmVhY2hTZXJpZXMoX2tleXModGFza3MpLCBmdW5jdGlvbiAoaywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0YXNrc1trXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHNba10gPSBhcmdzO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBhc3luYy5pdGVyYXRvciA9IGZ1bmN0aW9uICh0YXNrcykge1xuICAgICAgICB2YXIgbWFrZUNhbGxiYWNrID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgZm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhc2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0YXNrc1tpbmRleF0uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLm5leHQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmbi5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoaW5kZXggPCB0YXNrcy5sZW5ndGggLSAxKSA/IG1ha2VDYWxsYmFjayhpbmRleCArIDEpOiBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBmbjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG1ha2VDYWxsYmFjaygwKTtcbiAgICB9O1xuXG4gICAgYXN5bmMuYXBwbHkgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KFxuICAgICAgICAgICAgICAgIG51bGwsIGFyZ3MuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgX2NvbmNhdCA9IGZ1bmN0aW9uIChlYWNoZm4sIGFyciwgZm4sIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByID0gW107XG4gICAgICAgIGVhY2hmbihhcnIsIGZ1bmN0aW9uICh4LCBjYikge1xuICAgICAgICAgICAgZm4oeCwgZnVuY3Rpb24gKGVyciwgeSkge1xuICAgICAgICAgICAgICAgIHIgPSByLmNvbmNhdCh5IHx8IFtdKTtcbiAgICAgICAgICAgICAgICBjYihlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgYXN5bmMuY29uY2F0ID0gZG9QYXJhbGxlbChfY29uY2F0KTtcbiAgICBhc3luYy5jb25jYXRTZXJpZXMgPSBkb1NlcmllcyhfY29uY2F0KTtcblxuICAgIGFzeW5jLndoaWxzdCA9IGZ1bmN0aW9uICh0ZXN0LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRlc3QoKSkge1xuICAgICAgICAgICAgaXRlcmF0b3IoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFzeW5jLndoaWxzdCh0ZXN0LCBpdGVyYXRvciwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGFzeW5jLmRvV2hpbHN0ID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCB0ZXN0LCBjYWxsYmFjaykge1xuICAgICAgICBpdGVyYXRvcihmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICBpZiAodGVzdC5hcHBseShudWxsLCBhcmdzKSkge1xuICAgICAgICAgICAgICAgIGFzeW5jLmRvV2hpbHN0KGl0ZXJhdG9yLCB0ZXN0LCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgYXN5bmMudW50aWwgPSBmdW5jdGlvbiAodGVzdCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghdGVzdCgpKSB7XG4gICAgICAgICAgICBpdGVyYXRvcihmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXN5bmMudW50aWwodGVzdCwgaXRlcmF0b3IsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBhc3luYy5kb1VudGlsID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCB0ZXN0LCBjYWxsYmFjaykge1xuICAgICAgICBpdGVyYXRvcihmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICBpZiAoIXRlc3QuYXBwbHkobnVsbCwgYXJncykpIHtcbiAgICAgICAgICAgICAgICBhc3luYy5kb1VudGlsKGl0ZXJhdG9yLCB0ZXN0LCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgYXN5bmMucXVldWUgPSBmdW5jdGlvbiAod29ya2VyLCBjb25jdXJyZW5jeSkge1xuICAgICAgICBpZiAoY29uY3VycmVuY3kgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uY3VycmVuY3kgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIF9pbnNlcnQocSwgZGF0YSwgcG9zLCBjYWxsYmFjaykge1xuICAgICAgICAgIGlmICghcS5zdGFydGVkKXtcbiAgICAgICAgICAgIHEuc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghX2lzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgZGF0YSA9IFtkYXRhXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoZGF0YS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgIC8vIGNhbGwgZHJhaW4gaW1tZWRpYXRlbHkgaWYgdGhlcmUgYXJlIG5vIHRhc2tzXG4gICAgICAgICAgICAgcmV0dXJuIGFzeW5jLnNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgaWYgKHEuZHJhaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgIHEuZHJhaW4oKTtcbiAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfZWFjaChkYXRhLCBmdW5jdGlvbih0YXNrKSB7XG4gICAgICAgICAgICAgIHZhciBpdGVtID0ge1xuICAgICAgICAgICAgICAgICAgZGF0YTogdGFzayxcbiAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicgPyBjYWxsYmFjayA6IG51bGxcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBpZiAocG9zKSB7XG4gICAgICAgICAgICAgICAgcS50YXNrcy51bnNoaWZ0KGl0ZW0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHEudGFza3MucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChxLnNhdHVyYXRlZCAmJiBxLnRhc2tzLmxlbmd0aCA9PT0gcS5jb25jdXJyZW5jeSkge1xuICAgICAgICAgICAgICAgICAgcS5zYXR1cmF0ZWQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUocS5wcm9jZXNzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB3b3JrZXJzID0gMDtcbiAgICAgICAgdmFyIHEgPSB7XG4gICAgICAgICAgICB0YXNrczogW10sXG4gICAgICAgICAgICBjb25jdXJyZW5jeTogY29uY3VycmVuY3ksXG4gICAgICAgICAgICBzYXR1cmF0ZWQ6IG51bGwsXG4gICAgICAgICAgICBlbXB0eTogbnVsbCxcbiAgICAgICAgICAgIGRyYWluOiBudWxsLFxuICAgICAgICAgICAgc3RhcnRlZDogZmFsc2UsXG4gICAgICAgICAgICBwYXVzZWQ6IGZhbHNlLFxuICAgICAgICAgICAgcHVzaDogZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIF9pbnNlcnQocSwgZGF0YSwgZmFsc2UsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBraWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHEuZHJhaW4gPSBudWxsO1xuICAgICAgICAgICAgICBxLnRhc2tzID0gW107XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdW5zaGlmdDogZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIF9pbnNlcnQocSwgZGF0YSwgdHJ1ZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByb2Nlc3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXEucGF1c2VkICYmIHdvcmtlcnMgPCBxLmNvbmN1cnJlbmN5ICYmIHEudGFza3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXNrID0gcS50YXNrcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocS5lbXB0eSAmJiBxLnRhc2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcS5lbXB0eSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHdvcmtlcnMgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JrZXJzIC09IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFzay5jYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhc2suY2FsbGJhY2suYXBwbHkodGFzaywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxLmRyYWluICYmIHEudGFza3MubGVuZ3RoICsgd29ya2VycyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHEuZHJhaW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHEucHJvY2VzcygpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2IgPSBvbmx5X29uY2UobmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtlcih0YXNrLmRhdGEsIGNiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGVuZ3RoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHEudGFza3MubGVuZ3RoO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJ1bm5pbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd29ya2VycztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpZGxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcS50YXNrcy5sZW5ndGggKyB3b3JrZXJzID09PSAwO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhdXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHEucGF1c2VkID09PSB0cnVlKSB7IHJldHVybjsgfVxuICAgICAgICAgICAgICAgIHEucGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBxLnByb2Nlc3MoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXN1bWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAocS5wYXVzZWQgPT09IGZhbHNlKSB7IHJldHVybjsgfVxuICAgICAgICAgICAgICAgIHEucGF1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcS5wcm9jZXNzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBxO1xuICAgIH07XG4gICAgXG4gICAgYXN5bmMucHJpb3JpdHlRdWV1ZSA9IGZ1bmN0aW9uICh3b3JrZXIsIGNvbmN1cnJlbmN5KSB7XG4gICAgICAgIFxuICAgICAgICBmdW5jdGlvbiBfY29tcGFyZVRhc2tzKGEsIGIpe1xuICAgICAgICAgIHJldHVybiBhLnByaW9yaXR5IC0gYi5wcmlvcml0eTtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGZ1bmN0aW9uIF9iaW5hcnlTZWFyY2goc2VxdWVuY2UsIGl0ZW0sIGNvbXBhcmUpIHtcbiAgICAgICAgICB2YXIgYmVnID0gLTEsXG4gICAgICAgICAgICAgIGVuZCA9IHNlcXVlbmNlLmxlbmd0aCAtIDE7XG4gICAgICAgICAgd2hpbGUgKGJlZyA8IGVuZCkge1xuICAgICAgICAgICAgdmFyIG1pZCA9IGJlZyArICgoZW5kIC0gYmVnICsgMSkgPj4+IDEpO1xuICAgICAgICAgICAgaWYgKGNvbXBhcmUoaXRlbSwgc2VxdWVuY2VbbWlkXSkgPj0gMCkge1xuICAgICAgICAgICAgICBiZWcgPSBtaWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbmQgPSBtaWQgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYmVnO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBmdW5jdGlvbiBfaW5zZXJ0KHEsIGRhdGEsIHByaW9yaXR5LCBjYWxsYmFjaykge1xuICAgICAgICAgIGlmICghcS5zdGFydGVkKXtcbiAgICAgICAgICAgIHEuc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghX2lzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgZGF0YSA9IFtkYXRhXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoZGF0YS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgIC8vIGNhbGwgZHJhaW4gaW1tZWRpYXRlbHkgaWYgdGhlcmUgYXJlIG5vIHRhc2tzXG4gICAgICAgICAgICAgcmV0dXJuIGFzeW5jLnNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgaWYgKHEuZHJhaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgIHEuZHJhaW4oKTtcbiAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfZWFjaChkYXRhLCBmdW5jdGlvbih0YXNrKSB7XG4gICAgICAgICAgICAgIHZhciBpdGVtID0ge1xuICAgICAgICAgICAgICAgICAgZGF0YTogdGFzayxcbiAgICAgICAgICAgICAgICAgIHByaW9yaXR5OiBwcmlvcml0eSxcbiAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicgPyBjYWxsYmFjayA6IG51bGxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHEudGFza3Muc3BsaWNlKF9iaW5hcnlTZWFyY2gocS50YXNrcywgaXRlbSwgX2NvbXBhcmVUYXNrcykgKyAxLCAwLCBpdGVtKTtcblxuICAgICAgICAgICAgICBpZiAocS5zYXR1cmF0ZWQgJiYgcS50YXNrcy5sZW5ndGggPT09IHEuY29uY3VycmVuY3kpIHtcbiAgICAgICAgICAgICAgICAgIHEuc2F0dXJhdGVkKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlKHEucHJvY2Vzcyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFN0YXJ0IHdpdGggYSBub3JtYWwgcXVldWVcbiAgICAgICAgdmFyIHEgPSBhc3luYy5xdWV1ZSh3b3JrZXIsIGNvbmN1cnJlbmN5KTtcbiAgICAgICAgXG4gICAgICAgIC8vIE92ZXJyaWRlIHB1c2ggdG8gYWNjZXB0IHNlY29uZCBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIHByaW9yaXR5XG4gICAgICAgIHEucHVzaCA9IGZ1bmN0aW9uIChkYXRhLCBwcmlvcml0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgICBfaW5zZXJ0KHEsIGRhdGEsIHByaW9yaXR5LCBjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICAvLyBSZW1vdmUgdW5zaGlmdCBmdW5jdGlvblxuICAgICAgICBkZWxldGUgcS51bnNoaWZ0O1xuXG4gICAgICAgIHJldHVybiBxO1xuICAgIH07XG5cbiAgICBhc3luYy5jYXJnbyA9IGZ1bmN0aW9uICh3b3JrZXIsIHBheWxvYWQpIHtcbiAgICAgICAgdmFyIHdvcmtpbmcgICAgID0gZmFsc2UsXG4gICAgICAgICAgICB0YXNrcyAgICAgICA9IFtdO1xuXG4gICAgICAgIHZhciBjYXJnbyA9IHtcbiAgICAgICAgICAgIHRhc2tzOiB0YXNrcyxcbiAgICAgICAgICAgIHBheWxvYWQ6IHBheWxvYWQsXG4gICAgICAgICAgICBzYXR1cmF0ZWQ6IG51bGwsXG4gICAgICAgICAgICBlbXB0eTogbnVsbCxcbiAgICAgICAgICAgIGRyYWluOiBudWxsLFxuICAgICAgICAgICAgZHJhaW5lZDogdHJ1ZSxcbiAgICAgICAgICAgIHB1c2g6IGZ1bmN0aW9uIChkYXRhLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGlmICghX2lzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IFtkYXRhXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX2VhY2goZGF0YSwgZnVuY3Rpb24odGFzaykge1xuICAgICAgICAgICAgICAgICAgICB0YXNrcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHRhc2ssXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nID8gY2FsbGJhY2sgOiBudWxsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjYXJnby5kcmFpbmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYXJnby5zYXR1cmF0ZWQgJiYgdGFza3MubGVuZ3RoID09PSBwYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXJnby5zYXR1cmF0ZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZShjYXJnby5wcm9jZXNzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcm9jZXNzOiBmdW5jdGlvbiBwcm9jZXNzKCkge1xuICAgICAgICAgICAgICAgIGlmICh3b3JraW5nKSByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKHRhc2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZihjYXJnby5kcmFpbiAmJiAhY2FyZ28uZHJhaW5lZCkgY2FyZ28uZHJhaW4oKTtcbiAgICAgICAgICAgICAgICAgICAgY2FyZ28uZHJhaW5lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgdHMgPSB0eXBlb2YgcGF5bG9hZCA9PT0gJ251bWJlcidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHRhc2tzLnNwbGljZSgwLCBwYXlsb2FkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGFza3Muc3BsaWNlKDAsIHRhc2tzLmxlbmd0aCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZHMgPSBfbWFwKHRzLCBmdW5jdGlvbiAodGFzaykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFzay5kYXRhO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaWYoY2FyZ28uZW1wdHkpIGNhcmdvLmVtcHR5KCk7XG4gICAgICAgICAgICAgICAgd29ya2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgd29ya2VyKGRzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtpbmcgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICAgICAgX2VhY2godHMsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5jYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuY2FsbGJhY2suYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3MoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsZW5ndGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFza3MubGVuZ3RoO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJ1bm5pbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd29ya2luZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNhcmdvO1xuICAgIH07XG5cbiAgICB2YXIgX2NvbnNvbGVfZm4gPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzLmNvbmNhdChbZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25zb2xlLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbnNvbGVbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9lYWNoKGFyZ3MsIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZVtuYW1lXSh4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfV0pKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGFzeW5jLmxvZyA9IF9jb25zb2xlX2ZuKCdsb2cnKTtcbiAgICBhc3luYy5kaXIgPSBfY29uc29sZV9mbignZGlyJyk7XG4gICAgLyphc3luYy5pbmZvID0gX2NvbnNvbGVfZm4oJ2luZm8nKTtcbiAgICBhc3luYy53YXJuID0gX2NvbnNvbGVfZm4oJ3dhcm4nKTtcbiAgICBhc3luYy5lcnJvciA9IF9jb25zb2xlX2ZuKCdlcnJvcicpOyovXG5cbiAgICBhc3luYy5tZW1vaXplID0gZnVuY3Rpb24gKGZuLCBoYXNoZXIpIHtcbiAgICAgICAgdmFyIG1lbW8gPSB7fTtcbiAgICAgICAgdmFyIHF1ZXVlcyA9IHt9O1xuICAgICAgICBoYXNoZXIgPSBoYXNoZXIgfHwgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9O1xuICAgICAgICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzLnBvcCgpO1xuICAgICAgICAgICAgdmFyIGtleSA9IGhhc2hlci5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgIGlmIChrZXkgaW4gbWVtbykge1xuICAgICAgICAgICAgICAgIGFzeW5jLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgbWVtb1trZXldKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSBpbiBxdWV1ZXMpIHtcbiAgICAgICAgICAgICAgICBxdWV1ZXNba2V5XS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHF1ZXVlc1trZXldID0gW2NhbGxiYWNrXTtcbiAgICAgICAgICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzLmNvbmNhdChbZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBtZW1vW2tleV0gPSBhcmd1bWVudHM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBxID0gcXVldWVzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBxdWV1ZXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBxLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgIHFbaV0uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1dKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIG1lbW9pemVkLm1lbW8gPSBtZW1vO1xuICAgICAgICBtZW1vaXplZC51bm1lbW9pemVkID0gZm47XG4gICAgICAgIHJldHVybiBtZW1vaXplZDtcbiAgICB9O1xuXG4gICAgYXN5bmMudW5tZW1vaXplID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKGZuLnVubWVtb2l6ZWQgfHwgZm4pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBhc3luYy50aW1lcyA9IGZ1bmN0aW9uIChjb3VudCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBjb3VudGVyID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgY291bnRlci5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3luYy5tYXAoY291bnRlciwgaXRlcmF0b3IsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgYXN5bmMudGltZXNTZXJpZXMgPSBmdW5jdGlvbiAoY291bnQsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgY291bnRlciA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGNvdW50ZXIucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXN5bmMubWFwU2VyaWVzKGNvdW50ZXIsIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIGFzeW5jLnNlcSA9IGZ1bmN0aW9uICgvKiBmdW5jdGlvbnMuLi4gKi8pIHtcbiAgICAgICAgdmFyIGZucyA9IGFyZ3VtZW50cztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG4gICAgICAgICAgICBhc3luYy5yZWR1Y2UoZm5zLCBhcmdzLCBmdW5jdGlvbiAobmV3YXJncywgZm4sIGNiKSB7XG4gICAgICAgICAgICAgICAgZm4uYXBwbHkodGhhdCwgbmV3YXJncy5jb25jYXQoW2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVyciA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgY2IoZXJyLCBuZXh0YXJncyk7XG4gICAgICAgICAgICAgICAgfV0pKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChlcnIsIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseSh0aGF0LCBbZXJyXS5jb25jYXQocmVzdWx0cykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIGFzeW5jLmNvbXBvc2UgPSBmdW5jdGlvbiAoLyogZnVuY3Rpb25zLi4uICovKSB7XG4gICAgICByZXR1cm4gYXN5bmMuc2VxLmFwcGx5KG51bGwsIEFycmF5LnByb3RvdHlwZS5yZXZlcnNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgfTtcblxuICAgIHZhciBfYXBwbHlFYWNoID0gZnVuY3Rpb24gKGVhY2hmbiwgZm5zIC8qYXJncy4uLiovKSB7XG4gICAgICAgIHZhciBnbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gZWFjaGZuKGZucywgZnVuY3Rpb24gKGZuLCBjYikge1xuICAgICAgICAgICAgICAgIGZuLmFwcGx5KHRoYXQsIGFyZ3MuY29uY2F0KFtjYl0pKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgICAgICAgICAgcmV0dXJuIGdvLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGdvO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBhc3luYy5hcHBseUVhY2ggPSBkb1BhcmFsbGVsKF9hcHBseUVhY2gpO1xuICAgIGFzeW5jLmFwcGx5RWFjaFNlcmllcyA9IGRvU2VyaWVzKF9hcHBseUVhY2gpO1xuXG4gICAgYXN5bmMuZm9yZXZlciA9IGZ1bmN0aW9uIChmbiwgY2FsbGJhY2spIHtcbiAgICAgICAgZnVuY3Rpb24gbmV4dChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZuKG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIG5leHQoKTtcbiAgICB9O1xuXG4gICAgLy8gTm9kZS5qc1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGFzeW5jO1xuICAgIH1cbiAgICAvLyBBTUQgLyBSZXF1aXJlSlNcbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lICE9PSAndW5kZWZpbmVkJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShbXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGFzeW5jO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gaW5jbHVkZWQgZGlyZWN0bHkgdmlhIDxzY3JpcHQ+IHRhZ1xuICAgIGVsc2Uge1xuICAgICAgICByb290LmFzeW5jID0gYXN5bmM7XG4gICAgfVxuXG59KCkpO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIvKlxuICogYmFzZTY0LWFycmF5YnVmZmVyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbmlrbGFzdmgvYmFzZTY0LWFycmF5YnVmZmVyXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEyIE5pa2xhcyB2b24gSGVydHplblxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICovXG4oZnVuY3Rpb24oY2hhcnMpe1xuICBcInVzZSBzdHJpY3RcIjtcblxuICBleHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uKGFycmF5YnVmZmVyKSB7XG4gICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpLFxuICAgIGksIGxlbiA9IGJ5dGVzLmxlbmd0aCwgYmFzZTY0ID0gXCJcIjtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrPTMpIHtcbiAgICAgIGJhc2U2NCArPSBjaGFyc1tieXRlc1tpXSA+PiAyXTtcbiAgICAgIGJhc2U2NCArPSBjaGFyc1soKGJ5dGVzW2ldICYgMykgPDwgNCkgfCAoYnl0ZXNbaSArIDFdID4+IDQpXTtcbiAgICAgIGJhc2U2NCArPSBjaGFyc1soKGJ5dGVzW2kgKyAxXSAmIDE1KSA8PCAyKSB8IChieXRlc1tpICsgMl0gPj4gNildO1xuICAgICAgYmFzZTY0ICs9IGNoYXJzW2J5dGVzW2kgKyAyXSAmIDYzXTtcbiAgICB9XG5cbiAgICBpZiAoKGxlbiAlIDMpID09PSAyKSB7XG4gICAgICBiYXNlNjQgPSBiYXNlNjQuc3Vic3RyaW5nKDAsIGJhc2U2NC5sZW5ndGggLSAxKSArIFwiPVwiO1xuICAgIH0gZWxzZSBpZiAobGVuICUgMyA9PT0gMSkge1xuICAgICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMikgKyBcIj09XCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJhc2U2NDtcbiAgfTtcblxuICBleHBvcnRzLmRlY29kZSA9ICBmdW5jdGlvbihiYXNlNjQpIHtcbiAgICB2YXIgYnVmZmVyTGVuZ3RoID0gYmFzZTY0Lmxlbmd0aCAqIDAuNzUsXG4gICAgbGVuID0gYmFzZTY0Lmxlbmd0aCwgaSwgcCA9IDAsXG4gICAgZW5jb2RlZDEsIGVuY29kZWQyLCBlbmNvZGVkMywgZW5jb2RlZDQ7XG5cbiAgICBpZiAoYmFzZTY0W2Jhc2U2NC5sZW5ndGggLSAxXSA9PT0gXCI9XCIpIHtcbiAgICAgIGJ1ZmZlckxlbmd0aC0tO1xuICAgICAgaWYgKGJhc2U2NFtiYXNlNjQubGVuZ3RoIC0gMl0gPT09IFwiPVwiKSB7XG4gICAgICAgIGJ1ZmZlckxlbmd0aC0tO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhcnJheWJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihidWZmZXJMZW5ndGgpLFxuICAgIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSs9NCkge1xuICAgICAgZW5jb2RlZDEgPSBjaGFycy5pbmRleE9mKGJhc2U2NFtpXSk7XG4gICAgICBlbmNvZGVkMiA9IGNoYXJzLmluZGV4T2YoYmFzZTY0W2krMV0pO1xuICAgICAgZW5jb2RlZDMgPSBjaGFycy5pbmRleE9mKGJhc2U2NFtpKzJdKTtcbiAgICAgIGVuY29kZWQ0ID0gY2hhcnMuaW5kZXhPZihiYXNlNjRbaSszXSk7XG5cbiAgICAgIGJ5dGVzW3ArK10gPSAoZW5jb2RlZDEgPDwgMikgfCAoZW5jb2RlZDIgPj4gNCk7XG4gICAgICBieXRlc1twKytdID0gKChlbmNvZGVkMiAmIDE1KSA8PCA0KSB8IChlbmNvZGVkMyA+PiAyKTtcbiAgICAgIGJ5dGVzW3ArK10gPSAoKGVuY29kZWQzICYgMykgPDwgNikgfCAoZW5jb2RlZDQgJiA2Myk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5YnVmZmVyO1xuICB9O1xufSkoXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCIpO1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxucHJvY2Vzcy5uZXh0VGljayA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNhblNldEltbWVkaWF0ZSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnNldEltbWVkaWF0ZTtcbiAgICB2YXIgY2FuUG9zdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnBvc3RNZXNzYWdlICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyXG4gICAgO1xuXG4gICAgaWYgKGNhblNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIHdpbmRvdy5zZXRJbW1lZGlhdGUoZikgfTtcbiAgICB9XG5cbiAgICBpZiAoY2FuUG9zdCkge1xuICAgICAgICB2YXIgcXVldWUgPSBbXTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBldi5zb3VyY2U7XG4gICAgICAgICAgICBpZiAoKHNvdXJjZSA9PT0gd2luZG93IHx8IHNvdXJjZSA9PT0gbnVsbCkgJiYgZXYuZGF0YSA9PT0gJ3Byb2Nlc3MtdGljaycpIHtcbiAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm4gPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGZuKTtcbiAgICAgICAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZSgncHJvY2Vzcy10aWNrJywgJyonKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgfTtcbn0pKCk7XG5cbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufVxuXG4vLyBUT0RPKHNodHlsbWFuKVxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcblxuICBzZXJ2ZXI6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBXZWJTb2NrZXRTZXJ2ZXIgPSByZXF1aXJlKCd3cycpLlNlcnZlcjtcbiAgICB2YXIgd3NzID0gbmV3IFdlYlNvY2tldFNlcnZlcih7cG9ydDogODA4N30pO1xuICAgIHZhciBsYXN0TWVzc2FnZSA9ICdkb25lJztcblxuICAgIHdzcy5vbignY29ubmVjdGlvbicsIGZ1bmN0aW9uKHdzKSB7XG4gICAgICBpZiAobGFzdE1lc3NhZ2UgIT0gJ2RvbmUnKSB7XG4gICAgICAgIHdzLnNlbmQobGFzdE1lc3NhZ2UpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICBzZW5kOiBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgIGxhc3RNZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgd3NzLmNsaWVudHMuZm9yRWFjaChmdW5jdGlvbihjbGllbnQpe1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjbGllbnQuc2VuZChtZXNzYWdlKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgY2xpZW50OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgV2ViU29ja2V0ID0gcmVxdWlyZSgnd3MnKTtcbiAgICB2YXIgd3MgPSBuZXcgV2ViU29ja2V0KCd3czovL2xvY2FsaG9zdDo4MDg3Jyk7XG4gICAgd3Mub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5kYXRhID09ICdkb25lJykge1xuICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY2xhc3NlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LCAwKTtcbiAgICAgICAgY2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uKGNsYXNzTmFtZSkge1xuICAgICAgICAgIGlmIChjbGFzc05hbWUubWF0Y2goLyRidWlsZC1zdGF0dXMtLykpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKCdidWlsZC1zdGF0dXMtJyArIGV2ZW50LmRhdGEpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxufTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBnbG9iYWwgPSAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSgpO1xuXG4vKipcbiAqIFdlYlNvY2tldCBjb25zdHJ1Y3Rvci5cbiAqL1xuXG52YXIgV2ViU29ja2V0ID0gZ2xvYmFsLldlYlNvY2tldCB8fCBnbG9iYWwuTW96V2ViU29ja2V0O1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0ID8gd3MgOiBudWxsO1xuXG4vKipcbiAqIFdlYlNvY2tldCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBUaGUgdGhpcmQgYG9wdHNgIG9wdGlvbnMgb2JqZWN0IGdldHMgaWdub3JlZCBpbiB3ZWIgYnJvd3NlcnMsIHNpbmNlIGl0J3NcbiAqIG5vbi1zdGFuZGFyZCwgYW5kIHRocm93cyBhIFR5cGVFcnJvciBpZiBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yLlxuICogU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZWluYXJvcy93cy9pc3N1ZXMvMjI3XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVyaVxuICogQHBhcmFtIHtBcnJheX0gcHJvdG9jb2xzIChvcHRpb25hbClcbiAqIEBwYXJhbSB7T2JqZWN0KSBvcHRzIChvcHRpb25hbClcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gd3ModXJpLCBwcm90b2NvbHMsIG9wdHMpIHtcbiAgdmFyIGluc3RhbmNlO1xuICBpZiAocHJvdG9jb2xzKSB7XG4gICAgaW5zdGFuY2UgPSBuZXcgV2ViU29ja2V0KHVyaSwgcHJvdG9jb2xzKTtcbiAgfSBlbHNlIHtcbiAgICBpbnN0YW5jZSA9IG5ldyBXZWJTb2NrZXQodXJpKTtcbiAgfVxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbmlmIChXZWJTb2NrZXQpIHdzLnByb3RvdHlwZSA9IFdlYlNvY2tldC5wcm90b3R5cGU7XG4iLCIvKipcbiAqIGN1aWQuanNcbiAqIENvbGxpc2lvbi1yZXNpc3RhbnQgVUlEIGdlbmVyYXRvciBmb3IgYnJvd3NlcnMgYW5kIG5vZGUuXG4gKiBTZXF1ZW50aWFsIGZvciBmYXN0IGRiIGxvb2t1cHMgYW5kIHJlY2VuY3kgc29ydGluZy5cbiAqIFNhZmUgZm9yIGVsZW1lbnQgSURzIGFuZCBzZXJ2ZXItc2lkZSBsb29rdXBzLlxuICpcbiAqIEV4dHJhY3RlZCBmcm9tIENMQ1RSXG4gKiBcbiAqIENvcHlyaWdodCAoYykgRXJpYyBFbGxpb3R0IDIwMTJcbiAqIE1JVCBMaWNlbnNlXG4gKi9cblxuLypnbG9iYWwgd2luZG93LCBuYXZpZ2F0b3IsIGRvY3VtZW50LCByZXF1aXJlLCBwcm9jZXNzLCBtb2R1bGUgKi9cbihmdW5jdGlvbiAoYXBwKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgdmFyIG5hbWVzcGFjZSA9ICdjdWlkJyxcbiAgICBjID0gMCxcbiAgICBibG9ja1NpemUgPSA0LFxuICAgIGJhc2UgPSAzNixcbiAgICBkaXNjcmV0ZVZhbHVlcyA9IE1hdGgucG93KGJhc2UsIGJsb2NrU2l6ZSksXG5cbiAgICBwYWQgPSBmdW5jdGlvbiBwYWQobnVtLCBzaXplKSB7XG4gICAgICB2YXIgcyA9IFwiMDAwMDAwMDAwXCIgKyBudW07XG4gICAgICByZXR1cm4gcy5zdWJzdHIocy5sZW5ndGgtc2l6ZSk7XG4gICAgfSxcblxuICAgIHJhbmRvbUJsb2NrID0gZnVuY3Rpb24gcmFuZG9tQmxvY2soKSB7XG4gICAgICByZXR1cm4gcGFkKChNYXRoLnJhbmRvbSgpICpcbiAgICAgICAgICAgIGRpc2NyZXRlVmFsdWVzIDw8IDApXG4gICAgICAgICAgICAudG9TdHJpbmcoYmFzZSksIGJsb2NrU2l6ZSk7XG4gICAgfSxcblxuICAgIHNhZmVDb3VudGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgYyA9IChjIDwgZGlzY3JldGVWYWx1ZXMpID8gYyA6IDA7XG4gICAgICBjKys7IC8vIHRoaXMgaXMgbm90IHN1YmxpbWluYWxcbiAgICAgIHJldHVybiBjIC0gMTtcbiAgICB9LFxuXG4gICAgYXBpID0gZnVuY3Rpb24gY3VpZCgpIHtcbiAgICAgIC8vIFN0YXJ0aW5nIHdpdGggYSBsb3dlcmNhc2UgbGV0dGVyIG1ha2VzXG4gICAgICAvLyBpdCBIVE1MIGVsZW1lbnQgSUQgZnJpZW5kbHkuXG4gICAgICB2YXIgbGV0dGVyID0gJ2MnLCAvLyBoYXJkLWNvZGVkIGFsbG93cyBmb3Igc2VxdWVudGlhbCBhY2Nlc3NcblxuICAgICAgICAvLyB0aW1lc3RhbXBcbiAgICAgICAgLy8gd2FybmluZzogdGhpcyBleHBvc2VzIHRoZSBleGFjdCBkYXRlIGFuZCB0aW1lXG4gICAgICAgIC8vIHRoYXQgdGhlIHVpZCB3YXMgY3JlYXRlZC5cbiAgICAgICAgdGltZXN0YW1wID0gKG5ldyBEYXRlKCkuZ2V0VGltZSgpKS50b1N0cmluZyhiYXNlKSxcblxuICAgICAgICAvLyBQcmV2ZW50IHNhbWUtbWFjaGluZSBjb2xsaXNpb25zLlxuICAgICAgICBjb3VudGVyLFxuXG4gICAgICAgIC8vIEEgZmV3IGNoYXJzIHRvIGdlbmVyYXRlIGRpc3RpbmN0IGlkcyBmb3IgZGlmZmVyZW50XG4gICAgICAgIC8vIGNsaWVudHMgKHNvIGRpZmZlcmVudCBjb21wdXRlcnMgYXJlIGZhciBsZXNzXG4gICAgICAgIC8vIGxpa2VseSB0byBnZW5lcmF0ZSB0aGUgc2FtZSBpZClcbiAgICAgICAgZmluZ2VycHJpbnQgPSBhcGkuZmluZ2VycHJpbnQoKSxcblxuICAgICAgICAvLyBHcmFiIHNvbWUgbW9yZSBjaGFycyBmcm9tIE1hdGgucmFuZG9tKClcbiAgICAgICAgcmFuZG9tID0gcmFuZG9tQmxvY2soKSArIHJhbmRvbUJsb2NrKCk7XG5cbiAgICAgICAgY291bnRlciA9IHBhZChzYWZlQ291bnRlcigpLnRvU3RyaW5nKGJhc2UpLCBibG9ja1NpemUpO1xuXG4gICAgICByZXR1cm4gIChsZXR0ZXIgKyB0aW1lc3RhbXAgKyBjb3VudGVyICsgZmluZ2VycHJpbnQgKyByYW5kb20pO1xuICAgIH07XG5cbiAgYXBpLnNsdWcgPSBmdW5jdGlvbiBzbHVnKCkge1xuICAgIHZhciBkYXRlID0gbmV3IERhdGUoKS5nZXRUaW1lKCkudG9TdHJpbmcoMzYpLFxuICAgICAgY291bnRlcixcbiAgICAgIHByaW50ID0gYXBpLmZpbmdlcnByaW50KCkuc2xpY2UoMCwxKSArXG4gICAgICAgIGFwaS5maW5nZXJwcmludCgpLnNsaWNlKC0xKSxcbiAgICAgIHJhbmRvbSA9IHJhbmRvbUJsb2NrKCkuc2xpY2UoLTIpO1xuXG4gICAgICBjb3VudGVyID0gc2FmZUNvdW50ZXIoKS50b1N0cmluZygzNikuc2xpY2UoLTQpO1xuXG4gICAgcmV0dXJuIGRhdGUuc2xpY2UoLTIpICsgXG4gICAgICBjb3VudGVyICsgcHJpbnQgKyByYW5kb207XG4gIH07XG5cbiAgYXBpLmdsb2JhbENvdW50ID0gZnVuY3Rpb24gZ2xvYmFsQ291bnQoKSB7XG4gICAgLy8gV2Ugd2FudCB0byBjYWNoZSB0aGUgcmVzdWx0cyBvZiB0aGlzXG4gICAgdmFyIGNhY2hlID0gKGZ1bmN0aW9uIGNhbGMoKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgIGNvdW50ID0gMDtcblxuICAgICAgICBmb3IgKGkgaW4gd2luZG93KSB7XG4gICAgICAgICAgY291bnQrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICAgIH0oKSk7XG5cbiAgICBhcGkuZ2xvYmFsQ291bnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjYWNoZTsgfTtcbiAgICByZXR1cm4gY2FjaGU7XG4gIH07XG5cbiAgYXBpLmZpbmdlcnByaW50ID0gZnVuY3Rpb24gYnJvd3NlclByaW50KCkge1xuICAgIHJldHVybiBwYWQoKG5hdmlnYXRvci5taW1lVHlwZXMubGVuZ3RoICtcbiAgICAgIG5hdmlnYXRvci51c2VyQWdlbnQubGVuZ3RoKS50b1N0cmluZygzNikgK1xuICAgICAgYXBpLmdsb2JhbENvdW50KCkudG9TdHJpbmcoMzYpLCA0KTtcbiAgfTtcblxuICAvLyBkb24ndCBjaGFuZ2UgYW55dGhpbmcgZnJvbSBoZXJlIGRvd24uXG4gIGlmIChhcHAucmVnaXN0ZXIpIHtcbiAgICBhcHAucmVnaXN0ZXIobmFtZXNwYWNlLCBhcGkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBhcGk7XG4gIH0gZWxzZSB7XG4gICAgYXBwW25hbWVzcGFjZV0gPSBhcGk7XG4gIH1cblxufSh0aGlzLmFwcGxpdHVkZSB8fCB0aGlzKSk7XG4iLCIvKipcbiAqIFRpdGxlOiBLZXlib2FyZEpTXG4gKiBWZXJzaW9uOiB2MC40LjFcbiAqIERlc2NyaXB0aW9uOiBLZXlib2FyZEpTIGlzIGEgZmxleGlibGUgYW5kIGVhc3kgdG8gdXNlIGtleWJvYXJkIGJpbmRpbmdcbiAqIGxpYnJhcnkuXG4gKiBBdXRob3I6IFJvYmVydCBIdXJzdC5cbiAqXG4gKiBDb3B5cmlnaHQgMjAxMSwgUm9iZXJ0IFdpbGxpYW0gSHVyc3RcbiAqIExpY2VuY2VkIHVuZGVyIHRoZSBCU0QgTGljZW5zZS5cbiAqIFNlZSBodHRwczovL3Jhdy5naXRodWIuY29tL1JvYmVydFdIdXJzdC9LZXlib2FyZEpTL21hc3Rlci9saWNlbnNlLnR4dFxuICovXG4oZnVuY3Rpb24oY29udGV4dCwgZmFjdG9yeSkge1xuXG5cdC8vSU5ERVhPRiBQT0xMWUZJTExcblx0W10uaW5kZXhPZnx8KEFycmF5LnByb3RvdHlwZS5pbmRleE9mPWZ1bmN0aW9uKGEsYixjKXtmb3IoYz10aGlzLmxlbmd0aCxiPShjK35+YiklYztiPGMmJighKGIgaW4gdGhpcyl8fHRoaXNbYl0hPT1hKTtiKyspO3JldHVybiBiXmM/YjotMTt9KTtcblxuXHQvL0FNRFxuXHRpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHsgZGVmaW5lKGNvbnN0cnVjdEFNRCk7IH1cblxuXHQvL0NvbW1vbkpTXG5cdGVsc2UgaWYodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtjb25zdHJ1Y3RDb21tb25KUygpfVxuXG5cdC8vR0xPQkFMXG5cdGVsc2UgeyBjb25zdHJ1Y3RHbG9iYWwoKTsgfVxuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3QgQU1EIHZlcnNpb24gb2YgdGhlIGxpYnJhcnlcblx0ICovXG5cdGZ1bmN0aW9uIGNvbnN0cnVjdEFNRCgpIHtcblxuXHRcdC8vY3JlYXRlIGEgbGlicmFyeSBpbnN0YW5jZVxuXHRcdHJldHVybiBpbml0KCk7XG5cblx0XHQvL3NwYXducyBhIGxpYnJhcnkgaW5zdGFuY2Vcblx0XHRmdW5jdGlvbiBpbml0KCkge1xuXHRcdFx0dmFyIGxpYnJhcnk7XG5cdFx0XHRsaWJyYXJ5ID0gZmFjdG9yeSgnYW1kJyk7XG5cdFx0XHRsaWJyYXJ5LmZvcmsgPSBpbml0O1xuXHRcdFx0cmV0dXJuIGxpYnJhcnk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIENvbnN0cnVjdCBDb21tb25KUyB2ZXJzaW9uIG9mIHRoZSBsaWJyYXJ5XG5cdCAqL1xuXHRmdW5jdGlvbiBjb25zdHJ1Y3RDb21tb25KUygpIHtcblxuXHRcdC8vY3JlYXRlIGEgbGlicmFyeSBpbnN0YW5jZVxuXHRcdG1vZHVsZS5leHBvcnRzID0gaW5pdCgpO1xuXG5cdFx0cmV0dXJuO1xuXG5cdFx0Ly9zcGF3bnMgYSBsaWJyYXJ5IGluc3RhbmNlXG5cdFx0ZnVuY3Rpb24gaW5pdCgpIHtcblx0XHRcdHZhciBsaWJyYXJ5O1xuXHRcdFx0bGlicmFyeSA9IGZhY3RvcnkoJ0NvbW1vbkpTJyk7XG5cdFx0XHRsaWJyYXJ5LmZvcmsgPSBpbml0O1xuXHRcdFx0cmV0dXJuIGxpYnJhcnk7XG5cblx0XHR9XG5cblx0fVxuXG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3QgYSBHbG9iYWwgdmVyc2lvbiBvZiB0aGUgbGlicmFyeVxuXHQgKi9cblx0ZnVuY3Rpb24gY29uc3RydWN0R2xvYmFsKCkge1xuXHRcdHZhciBsaWJyYXJ5O1xuXG5cdFx0Ly9jcmVhdGUgYSBsaWJyYXJ5IGluc3RhbmNlXG5cdFx0bGlicmFyeSA9IGluaXQoKTtcblx0XHRsaWJyYXJ5Lm5vQ29uZmxpY3QoJ0tleWJvYXJkSlMnLCAnaycpO1xuXG5cdFx0Ly9zcGF3bnMgYSBsaWJyYXJ5IGluc3RhbmNlXG5cdFx0ZnVuY3Rpb24gaW5pdCgpIHtcblx0XHRcdHZhciBsaWJyYXJ5LCBuYW1lc3BhY2VzID0gW10sIHByZXZpb3VzVmFsdWVzID0ge307XG5cblx0XHRcdGxpYnJhcnkgPSBmYWN0b3J5KCdnbG9iYWwnKTtcblx0XHRcdGxpYnJhcnkuZm9yayA9IGluaXQ7XG5cdFx0XHRsaWJyYXJ5Lm5vQ29uZmxpY3QgPSBub0NvbmZsaWN0O1xuXHRcdFx0cmV0dXJuIGxpYnJhcnk7XG5cblx0XHRcdC8vc2V0cyBsaWJyYXJ5IG5hbWVzcGFjZXNcblx0XHRcdGZ1bmN0aW9uIG5vQ29uZmxpY3QoICAgICkge1xuXHRcdFx0XHR2YXIgYXJncywgbkksIG5ld05hbWVzcGFjZXM7XG5cblx0XHRcdFx0bmV3TmFtZXNwYWNlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShhcmd1bWVudHMpO1xuXG5cdFx0XHRcdGZvcihuSSA9IDA7IG5JIDwgbmFtZXNwYWNlcy5sZW5ndGg7IG5JICs9IDEpIHtcblx0XHRcdFx0XHRpZih0eXBlb2YgcHJldmlvdXNWYWx1ZXNbbmFtZXNwYWNlc1tuSV1dID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRcdFx0ZGVsZXRlIGNvbnRleHRbbmFtZXNwYWNlc1tuSV1dO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb250ZXh0W25hbWVzcGFjZXNbbkldXSA9IHByZXZpb3VzVmFsdWVzW25hbWVzcGFjZXNbbkldXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRwcmV2aW91c1ZhbHVlcyA9IHt9O1xuXG5cdFx0XHRcdGZvcihuSSA9IDA7IG5JIDwgbmV3TmFtZXNwYWNlcy5sZW5ndGg7IG5JICs9IDEpIHtcblx0XHRcdFx0XHRpZih0eXBlb2YgbmV3TmFtZXNwYWNlc1tuSV0gIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZXBsYWNlIG5hbWVzcGFjZXMuIEFsbCBuZXcgbmFtZXNwYWNlcyBtdXN0IGJlIHN0cmluZ3MuJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHByZXZpb3VzVmFsdWVzW25ld05hbWVzcGFjZXNbbkldXSA9IGNvbnRleHRbbmV3TmFtZXNwYWNlc1tuSV1dO1xuXHRcdFx0XHRcdGNvbnRleHRbbmV3TmFtZXNwYWNlc1tuSV1dID0gbGlicmFyeTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG5hbWVzcGFjZXMgPSBuZXdOYW1lc3BhY2VzO1xuXG5cdFx0XHRcdHJldHVybiBuYW1lc3BhY2VzO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG59KSh0aGlzLCBmdW5jdGlvbihlbnYpIHtcblx0dmFyIEtleWJvYXJkSlMgPSB7fSwgbG9jYWxlcyA9IHt9LCBsb2NhbGUsIG1hcCwgbWFjcm9zLCBhY3RpdmVLZXlzID0gW10sIGJpbmRpbmdzID0gW10sIGFjdGl2ZUJpbmRpbmdzID0gW10sXG5cdGFjdGl2ZU1hY3JvcyA9IFtdLCBhSSwgdXNMb2NhbGU7XG5cblxuXHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQvLyBERUZVQUxUIFVTIExPQ0FMRSAvL1xuXHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cdC8vZGVmaW5lIFVTIGxvY2FsZVxuXHQvL0lmIHlvdSBjcmVhdGUgYSBuZXcgbG9jYWxlIHBsZWFzZSBzdWJtaXQgaXQgYXMgYSBwdWxsIHJlcXVlc3Qgb3IgcG9zdFxuXHQvLyBpdCBpbiB0aGUgaXNzdWUgdHJhY2tlciBhdFxuXHQvLyBodHRwOi8vZ2l0aHViLmNvbS9Sb2JlcnRXaHVyc3QvS2V5Ym9hcmRKUy9pc3N1ZXMvXG5cdHVzTG9jYWxlID0ge1xuXHRcdFwibWFwXCI6IHtcblxuXHRcdFx0Ly9nZW5lcmFsXG5cdFx0XHRcIjNcIjogW1wiY2FuY2VsXCJdLFxuXHRcdFx0XCI4XCI6IFtcImJhY2tzcGFjZVwiXSxcblx0XHRcdFwiOVwiOiBbXCJ0YWJcIl0sXG5cdFx0XHRcIjEyXCI6IFtcImNsZWFyXCJdLFxuXHRcdFx0XCIxM1wiOiBbXCJlbnRlclwiXSxcblx0XHRcdFwiMTZcIjogW1wic2hpZnRcIl0sXG5cdFx0XHRcIjE3XCI6IFtcImN0cmxcIl0sXG5cdFx0XHRcIjE4XCI6IFtcImFsdFwiLCBcIm1lbnVcIl0sXG5cdFx0XHRcIjE5XCI6IFtcInBhdXNlXCIsIFwiYnJlYWtcIl0sXG5cdFx0XHRcIjIwXCI6IFtcImNhcHNsb2NrXCJdLFxuXHRcdFx0XCIyN1wiOiBbXCJlc2NhcGVcIiwgXCJlc2NcIl0sXG5cdFx0XHRcIjMyXCI6IFtcInNwYWNlXCIsIFwic3BhY2ViYXJcIl0sXG5cdFx0XHRcIjMzXCI6IFtcInBhZ2V1cFwiXSxcblx0XHRcdFwiMzRcIjogW1wicGFnZWRvd25cIl0sXG5cdFx0XHRcIjM1XCI6IFtcImVuZFwiXSxcblx0XHRcdFwiMzZcIjogW1wiaG9tZVwiXSxcblx0XHRcdFwiMzdcIjogW1wibGVmdFwiXSxcblx0XHRcdFwiMzhcIjogW1widXBcIl0sXG5cdFx0XHRcIjM5XCI6IFtcInJpZ2h0XCJdLFxuXHRcdFx0XCI0MFwiOiBbXCJkb3duXCJdLFxuXHRcdFx0XCI0MVwiOiBbXCJzZWxlY3RcIl0sXG5cdFx0XHRcIjQyXCI6IFtcInByaW50c2NyZWVuXCJdLFxuXHRcdFx0XCI0M1wiOiBbXCJleGVjdXRlXCJdLFxuXHRcdFx0XCI0NFwiOiBbXCJzbmFwc2hvdFwiXSxcblx0XHRcdFwiNDVcIjogW1wiaW5zZXJ0XCIsIFwiaW5zXCJdLFxuXHRcdFx0XCI0NlwiOiBbXCJkZWxldGVcIiwgXCJkZWxcIl0sXG5cdFx0XHRcIjQ3XCI6IFtcImhlbHBcIl0sXG5cdFx0XHRcIjkxXCI6IFtcImNvbW1hbmRcIiwgXCJ3aW5kb3dzXCIsIFwid2luXCIsIFwic3VwZXJcIiwgXCJsZWZ0Y29tbWFuZFwiLCBcImxlZnR3aW5kb3dzXCIsIFwibGVmdHdpblwiLCBcImxlZnRzdXBlclwiXSxcblx0XHRcdFwiOTJcIjogW1wiY29tbWFuZFwiLCBcIndpbmRvd3NcIiwgXCJ3aW5cIiwgXCJzdXBlclwiLCBcInJpZ2h0Y29tbWFuZFwiLCBcInJpZ2h0d2luZG93c1wiLCBcInJpZ2h0d2luXCIsIFwicmlnaHRzdXBlclwiXSxcblx0XHRcdFwiMTQ1XCI6IFtcInNjcm9sbGxvY2tcIiwgXCJzY3JvbGxcIl0sXG5cdFx0XHRcIjE4NlwiOiBbXCJzZW1pY29sb25cIiwgXCI7XCJdLFxuXHRcdFx0XCIxODdcIjogW1wiZXF1YWxcIiwgXCJlcXVhbHNpZ25cIiwgXCI9XCJdLFxuXHRcdFx0XCIxODhcIjogW1wiY29tbWFcIiwgXCIsXCJdLFxuXHRcdFx0XCIxODlcIjogW1wiZGFzaFwiLCBcIi1cIl0sXG5cdFx0XHRcIjE5MFwiOiBbXCJwZXJpb2RcIiwgXCIuXCJdLFxuXHRcdFx0XCIxOTFcIjogW1wic2xhc2hcIiwgXCJmb3J3YXJkc2xhc2hcIiwgXCIvXCJdLFxuXHRcdFx0XCIxOTJcIjogW1wiZ3JhdmVhY2NlbnRcIiwgXCJgXCJdLFxuXHRcdFx0XCIyMTlcIjogW1wib3BlbmJyYWNrZXRcIiwgXCJbXCJdLFxuXHRcdFx0XCIyMjBcIjogW1wiYmFja3NsYXNoXCIsIFwiXFxcXFwiXSxcblx0XHRcdFwiMjIxXCI6IFtcImNsb3NlYnJhY2tldFwiLCBcIl1cIl0sXG5cdFx0XHRcIjIyMlwiOiBbXCJhcG9zdHJvcGhlXCIsIFwiJ1wiXSxcblxuXHRcdFx0Ly8wLTlcblx0XHRcdFwiNDhcIjogW1wiemVyb1wiLCBcIjBcIl0sXG5cdFx0XHRcIjQ5XCI6IFtcIm9uZVwiLCBcIjFcIl0sXG5cdFx0XHRcIjUwXCI6IFtcInR3b1wiLCBcIjJcIl0sXG5cdFx0XHRcIjUxXCI6IFtcInRocmVlXCIsIFwiM1wiXSxcblx0XHRcdFwiNTJcIjogW1wiZm91clwiLCBcIjRcIl0sXG5cdFx0XHRcIjUzXCI6IFtcImZpdmVcIiwgXCI1XCJdLFxuXHRcdFx0XCI1NFwiOiBbXCJzaXhcIiwgXCI2XCJdLFxuXHRcdFx0XCI1NVwiOiBbXCJzZXZlblwiLCBcIjdcIl0sXG5cdFx0XHRcIjU2XCI6IFtcImVpZ2h0XCIsIFwiOFwiXSxcblx0XHRcdFwiNTdcIjogW1wibmluZVwiLCBcIjlcIl0sXG5cblx0XHRcdC8vbnVtcGFkXG5cdFx0XHRcIjk2XCI6IFtcIm51bXplcm9cIiwgXCJudW0wXCJdLFxuXHRcdFx0XCI5N1wiOiBbXCJudW1vbmVcIiwgXCJudW0xXCJdLFxuXHRcdFx0XCI5OFwiOiBbXCJudW10d29cIiwgXCJudW0yXCJdLFxuXHRcdFx0XCI5OVwiOiBbXCJudW10aHJlZVwiLCBcIm51bTNcIl0sXG5cdFx0XHRcIjEwMFwiOiBbXCJudW1mb3VyXCIsIFwibnVtNFwiXSxcblx0XHRcdFwiMTAxXCI6IFtcIm51bWZpdmVcIiwgXCJudW01XCJdLFxuXHRcdFx0XCIxMDJcIjogW1wibnVtc2l4XCIsIFwibnVtNlwiXSxcblx0XHRcdFwiMTAzXCI6IFtcIm51bXNldmVuXCIsIFwibnVtN1wiXSxcblx0XHRcdFwiMTA0XCI6IFtcIm51bWVpZ2h0XCIsIFwibnVtOFwiXSxcblx0XHRcdFwiMTA1XCI6IFtcIm51bW5pbmVcIiwgXCJudW05XCJdLFxuXHRcdFx0XCIxMDZcIjogW1wibnVtbXVsdGlwbHlcIiwgXCJudW0qXCJdLFxuXHRcdFx0XCIxMDdcIjogW1wibnVtYWRkXCIsIFwibnVtK1wiXSxcblx0XHRcdFwiMTA4XCI6IFtcIm51bWVudGVyXCJdLFxuXHRcdFx0XCIxMDlcIjogW1wibnVtc3VidHJhY3RcIiwgXCJudW0tXCJdLFxuXHRcdFx0XCIxMTBcIjogW1wibnVtZGVjaW1hbFwiLCBcIm51bS5cIl0sXG5cdFx0XHRcIjExMVwiOiBbXCJudW1kZXZpZGVcIiwgXCJudW0vXCJdLFxuXHRcdFx0XCIxNDRcIjogW1wibnVtbG9ja1wiLCBcIm51bVwiXSxcblxuXHRcdFx0Ly9mdW5jdGlvbiBrZXlzXG5cdFx0XHRcIjExMlwiOiBbXCJmMVwiXSxcblx0XHRcdFwiMTEzXCI6IFtcImYyXCJdLFxuXHRcdFx0XCIxMTRcIjogW1wiZjNcIl0sXG5cdFx0XHRcIjExNVwiOiBbXCJmNFwiXSxcblx0XHRcdFwiMTE2XCI6IFtcImY1XCJdLFxuXHRcdFx0XCIxMTdcIjogW1wiZjZcIl0sXG5cdFx0XHRcIjExOFwiOiBbXCJmN1wiXSxcblx0XHRcdFwiMTE5XCI6IFtcImY4XCJdLFxuXHRcdFx0XCIxMjBcIjogW1wiZjlcIl0sXG5cdFx0XHRcIjEyMVwiOiBbXCJmMTBcIl0sXG5cdFx0XHRcIjEyMlwiOiBbXCJmMTFcIl0sXG5cdFx0XHRcIjEyM1wiOiBbXCJmMTJcIl1cblx0XHR9LFxuXHRcdFwibWFjcm9zXCI6IFtcblxuXHRcdFx0Ly9zZWNvbmRhcnkga2V5IHN5bWJvbHNcblx0XHRcdFsnc2hpZnQgKyBgJywgW1widGlsZGVcIiwgXCJ+XCJdXSxcblx0XHRcdFsnc2hpZnQgKyAxJywgW1wiZXhjbGFtYXRpb25cIiwgXCJleGNsYW1hdGlvbnBvaW50XCIsIFwiIVwiXV0sXG5cdFx0XHRbJ3NoaWZ0ICsgMicsIFtcImF0XCIsIFwiQFwiXV0sXG5cdFx0XHRbJ3NoaWZ0ICsgMycsIFtcIm51bWJlclwiLCBcIiNcIl1dLFxuXHRcdFx0WydzaGlmdCArIDQnLCBbXCJkb2xsYXJcIiwgXCJkb2xsYXJzXCIsIFwiZG9sbGFyc2lnblwiLCBcIiRcIl1dLFxuXHRcdFx0WydzaGlmdCArIDUnLCBbXCJwZXJjZW50XCIsIFwiJVwiXV0sXG5cdFx0XHRbJ3NoaWZ0ICsgNicsIFtcImNhcmV0XCIsIFwiXlwiXV0sXG5cdFx0XHRbJ3NoaWZ0ICsgNycsIFtcImFtcGVyc2FuZFwiLCBcImFuZFwiLCBcIiZcIl1dLFxuXHRcdFx0WydzaGlmdCArIDgnLCBbXCJhc3Rlcmlza1wiLCBcIipcIl1dLFxuXHRcdFx0WydzaGlmdCArIDknLCBbXCJvcGVucGFyZW5cIiwgXCIoXCJdXSxcblx0XHRcdFsnc2hpZnQgKyAwJywgW1wiY2xvc2VwYXJlblwiLCBcIilcIl1dLFxuXHRcdFx0WydzaGlmdCArIC0nLCBbXCJ1bmRlcnNjb3JlXCIsIFwiX1wiXV0sXG5cdFx0XHRbJ3NoaWZ0ICsgPScsIFtcInBsdXNcIiwgXCIrXCJdXSxcblx0XHRcdFsnc2hpZnQgKyAoJywgW1wib3BlbmN1cmx5YnJhY2VcIiwgXCJvcGVuY3VybHlicmFja2V0XCIsIFwie1wiXV0sXG5cdFx0XHRbJ3NoaWZ0ICsgKScsIFtcImNsb3NlY3VybHlicmFjZVwiLCBcImNsb3NlY3VybHlicmFja2V0XCIsIFwifVwiXV0sXG5cdFx0XHRbJ3NoaWZ0ICsgXFxcXCcsIFtcInZlcnRpY2FsYmFyXCIsIFwifFwiXV0sXG5cdFx0XHRbJ3NoaWZ0ICsgOycsIFtcImNvbG9uXCIsIFwiOlwiXV0sXG5cdFx0XHRbJ3NoaWZ0ICsgXFwnJywgW1wicXVvdGF0aW9ubWFya1wiLCBcIlxcXCJcIl1dLFxuXHRcdFx0WydzaGlmdCArICEsJywgW1wib3BlbmFuZ2xlYnJhY2tldFwiLCBcIjxcIl1dLFxuXHRcdFx0WydzaGlmdCArIC4nLCBbXCJjbG9zZWFuZ2xlYnJhY2tldFwiLCBcIj5cIl1dLFxuXHRcdFx0WydzaGlmdCArIC8nLCBbXCJxdWVzdGlvbm1hcmtcIiwgXCI/XCJdXVxuXHRcdF1cblx0fTtcblx0Ly9hLXogYW5kIEEtWlxuXHRmb3IgKGFJID0gNjU7IGFJIDw9IDkwOyBhSSArPSAxKSB7XG5cdFx0dXNMb2NhbGUubWFwW2FJXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoYUkgKyAzMik7XG5cdFx0dXNMb2NhbGUubWFjcm9zLnB1c2goWydzaGlmdCArICcgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGFJICsgMzIpICsgJywgY2Fwc2xvY2sgKyAnICsgU3RyaW5nLmZyb21DaGFyQ29kZShhSSArIDMyKSwgW1N0cmluZy5mcm9tQ2hhckNvZGUoYUkpXV0pO1xuXHR9XG5cdHJlZ2lzdGVyTG9jYWxlKCd1cycsIHVzTG9jYWxlKTtcblx0Z2V0U2V0TG9jYWxlKCd1cycpO1xuXG5cblx0Ly8vLy8vLy8vL1xuXHQvLyBJTklUIC8vXG5cdC8vLy8vLy8vLy9cblxuXHQvL2VuYWJsZSB0aGUgbGlicmFyeVxuXHRlbmFibGUoKTtcblxuXG5cdC8vLy8vLy8vL1xuXHQvLyBBUEkgLy9cblx0Ly8vLy8vLy8vXG5cblx0Ly9hc3NlbWJsZSB0aGUgbGlicmFyeSBhbmQgcmV0dXJuIGl0XG5cdEtleWJvYXJkSlMuZW5hYmxlID0gZW5hYmxlO1xuXHRLZXlib2FyZEpTLmRpc2FibGUgPSBkaXNhYmxlO1xuXHRLZXlib2FyZEpTLmFjdGl2ZUtleXMgPSBnZXRBY3RpdmVLZXlzO1xuXHRLZXlib2FyZEpTLm9uID0gY3JlYXRlQmluZGluZztcblx0S2V5Ym9hcmRKUy5jbGVhciA9IHJlbW92ZUJpbmRpbmdCeUtleUNvbWJvO1xuXHRLZXlib2FyZEpTLmNsZWFyLmtleSA9IHJlbW92ZUJpbmRpbmdCeUtleU5hbWU7XG5cdEtleWJvYXJkSlMubG9jYWxlID0gZ2V0U2V0TG9jYWxlO1xuXHRLZXlib2FyZEpTLmxvY2FsZS5yZWdpc3RlciA9IHJlZ2lzdGVyTG9jYWxlO1xuXHRLZXlib2FyZEpTLm1hY3JvID0gY3JlYXRlTWFjcm87XG5cdEtleWJvYXJkSlMubWFjcm8ucmVtb3ZlID0gcmVtb3ZlTWFjcm87XG5cdEtleWJvYXJkSlMua2V5ID0ge307XG5cdEtleWJvYXJkSlMua2V5Lm5hbWUgPSBnZXRLZXlOYW1lO1xuXHRLZXlib2FyZEpTLmtleS5jb2RlID0gZ2V0S2V5Q29kZTtcblx0S2V5Ym9hcmRKUy5jb21ibyA9IHt9O1xuXHRLZXlib2FyZEpTLmNvbWJvLmFjdGl2ZSA9IGlzU2F0aXNmaWVkQ29tYm87XG5cdEtleWJvYXJkSlMuY29tYm8ucGFyc2UgPSBwYXJzZUtleUNvbWJvO1xuXHRLZXlib2FyZEpTLmNvbWJvLnN0cmluZ2lmeSA9IHN0cmluZ2lmeUtleUNvbWJvO1xuXHRyZXR1cm4gS2V5Ym9hcmRKUztcblxuXG5cdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0Ly8gSU5TVEFOQ0UgTUVUSE9EUyAvL1xuXHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblx0LyoqXG5cdCAqIEVuYWJsZXMgS2V5Ym9hcmRKU1xuXHQgKi9cblx0ZnVuY3Rpb24gZW5hYmxlKCkge1xuXHRcdGlmKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG5cdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywga2V5ZG93biwgZmFsc2UpO1xuXHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBrZXl1cCwgZmFsc2UpO1xuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCByZXNldCwgZmFsc2UpO1xuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmtpdGZ1bGxzY3JlZW5jaGFuZ2UnLCByZXNldCwgZmFsc2UpO1xuXHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vemZ1bGxzY3JlZW5jaGFuZ2UnLCByZXNldCwgZmFsc2UpO1xuXHRcdH0gZWxzZSBpZih3aW5kb3cuYXR0YWNoRXZlbnQpIHtcblx0XHRcdGRvY3VtZW50LmF0dGFjaEV2ZW50KCdvbmtleWRvd24nLCBrZXlkb3duKTtcblx0XHRcdGRvY3VtZW50LmF0dGFjaEV2ZW50KCdvbmtleXVwJywga2V5dXApO1xuXHRcdFx0d2luZG93LmF0dGFjaEV2ZW50KCdvbmJsdXInLCByZXNldCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEV4aXRzIGFsbCBhY3RpdmUgYmluZGluZ3MgYW5kIGRpc2FibGVzIEtleWJvYXJkSlNcblx0ICovXG5cdGZ1bmN0aW9uIGRpc2FibGUoKSB7XG5cdFx0cmVzZXQoKTtcblx0XHRpZih3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuXHRcdFx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGtleWRvd24sIGZhbHNlKTtcblx0XHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXVwJywga2V5dXAsIGZhbHNlKTtcblx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgcmVzZXQsIGZhbHNlKTtcblx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd3ZWJraXRmdWxsc2NyZWVuY2hhbmdlJywgcmVzZXQsIGZhbHNlKTtcblx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3pmdWxsc2NyZWVuY2hhbmdlJywgcmVzZXQsIGZhbHNlKTtcblx0XHR9IGVsc2UgaWYod2luZG93LmRldGFjaEV2ZW50KSB7XG5cdFx0XHRkb2N1bWVudC5kZXRhY2hFdmVudCgnb25rZXlkb3duJywga2V5ZG93bik7XG5cdFx0XHRkb2N1bWVudC5kZXRhY2hFdmVudCgnb25rZXl1cCcsIGtleXVwKTtcblx0XHRcdHdpbmRvdy5kZXRhY2hFdmVudCgnb25ibHVyJywgcmVzZXQpO1xuXHRcdH1cblx0fVxuXG5cblx0Ly8vLy8vLy8vLy8vLy8vLy8vLy9cblx0Ly8gRVZFTlQgSEFORExFUlMgLy9cblx0Ly8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXHQvKipcblx0ICogRXhpdHMgYWxsIGFjdGl2ZSBiaW5kaW5ncy4gT3B0aW9uYWxseSBwYXNzZXMgYW4gZXZlbnQgdG8gYWxsIGJpbmRpbmdcblx0ICogIGhhbmRsZXJzLlxuXHQgKiBAcGFyYW0gIHtLZXlib2FyZEV2ZW50fVx0ZXZlbnRcdFtPcHRpb25hbF1cblx0ICovXG5cdGZ1bmN0aW9uIHJlc2V0KGV2ZW50KSB7XG5cdFx0YWN0aXZlS2V5cyA9IFtdO1xuXHRcdHBydW5lTWFjcm9zKCk7XG5cdFx0cHJ1bmVCaW5kaW5ncyhldmVudCk7XG5cdH1cblxuXHQvKipcblx0ICogS2V5IGRvd24gZXZlbnQgaGFuZGxlci5cblx0ICogQHBhcmFtICB7S2V5Ym9hcmRFdmVudH1cdGV2ZW50XG5cdCAqL1xuXHRmdW5jdGlvbiBrZXlkb3duKGV2ZW50KSB7XG5cdFx0dmFyIGtleU5hbWVzLCBrZXlOYW1lLCBrSTtcblx0XHRrZXlOYW1lcyA9IGdldEtleU5hbWUoZXZlbnQua2V5Q29kZSk7XG5cdFx0aWYoa2V5TmFtZXMubGVuZ3RoIDwgMSkgeyByZXR1cm47IH1cblx0XHRldmVudC5pc1JlcGVhdCA9IGZhbHNlO1xuXHRcdGZvcihrSSA9IDA7IGtJIDwga2V5TmFtZXMubGVuZ3RoOyBrSSArPSAxKSB7XG5cdFx0ICAgIGtleU5hbWUgPSBrZXlOYW1lc1trSV07XG5cdFx0ICAgIGlmIChnZXRBY3RpdmVLZXlzKCkuaW5kZXhPZihrZXlOYW1lKSAhPSAtMSlcblx0XHQgICAgICAgIGV2ZW50LmlzUmVwZWF0ID0gdHJ1ZTtcblx0XHRcdGFkZEFjdGl2ZUtleShrZXlOYW1lKTtcblx0XHR9XG5cdFx0ZXhlY3V0ZU1hY3JvcygpO1xuXHRcdGV4ZWN1dGVCaW5kaW5ncyhldmVudCk7XG5cdH1cblxuXHQvKipcblx0ICogS2V5IHVwIGV2ZW50IGhhbmRsZXIuXG5cdCAqIEBwYXJhbSAge0tleWJvYXJkRXZlbnR9IGV2ZW50XG5cdCAqL1xuXHRmdW5jdGlvbiBrZXl1cChldmVudCkge1xuXHRcdHZhciBrZXlOYW1lcywga0k7XG5cdFx0a2V5TmFtZXMgPSBnZXRLZXlOYW1lKGV2ZW50LmtleUNvZGUpO1xuXHRcdGlmKGtleU5hbWVzLmxlbmd0aCA8IDEpIHsgcmV0dXJuOyB9XG5cdFx0Zm9yKGtJID0gMDsga0kgPCBrZXlOYW1lcy5sZW5ndGg7IGtJICs9IDEpIHtcblx0XHRcdHJlbW92ZUFjdGl2ZUtleShrZXlOYW1lc1trSV0pO1xuXHRcdH1cblx0XHRwcnVuZU1hY3JvcygpO1xuXHRcdHBydW5lQmluZGluZ3MoZXZlbnQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFjY2VwdHMgYSBrZXkgY29kZSBhbmQgcmV0dXJucyB0aGUga2V5IG5hbWVzIGRlZmluZWQgYnkgdGhlIGN1cnJlbnRcblx0ICogIGxvY2FsZS5cblx0ICogQHBhcmFtICB7TnVtYmVyfVx0a2V5Q29kZVxuXHQgKiBAcmV0dXJuIHtBcnJheX1cdGtleU5hbWVzXHRBbiBhcnJheSBvZiBrZXkgbmFtZXMgZGVmaW5lZCBmb3IgdGhlIGtleVxuXHQgKiAgY29kZSBhcyBkZWZpbmVkIGJ5IHRoZSBjdXJyZW50IGxvY2FsZS5cblx0ICovXG5cdGZ1bmN0aW9uIGdldEtleU5hbWUoa2V5Q29kZSkge1xuXHRcdHJldHVybiBtYXBba2V5Q29kZV0gfHwgW107XG5cdH1cblxuXHQvKipcblx0ICogQWNjZXB0cyBhIGtleSBuYW1lIGFuZCByZXR1cm5zIHRoZSBrZXkgY29kZSBkZWZpbmVkIGJ5IHRoZSBjdXJyZW50XG5cdCAqICBsb2NhbGUuXG5cdCAqIEBwYXJhbSAge051bWJlcn1cdGtleU5hbWVcblx0ICogQHJldHVybiB7TnVtYmVyfGZhbHNlfVxuXHQgKi9cblx0ZnVuY3Rpb24gZ2V0S2V5Q29kZShrZXlOYW1lKSB7XG5cdFx0dmFyIGtleUNvZGU7XG5cdFx0Zm9yKGtleUNvZGUgaW4gbWFwKSB7XG5cdFx0XHRpZighbWFwLmhhc093blByb3BlcnR5KGtleUNvZGUpKSB7IGNvbnRpbnVlOyB9XG5cdFx0XHRpZihtYXBba2V5Q29kZV0uaW5kZXhPZihrZXlOYW1lKSA+IC0xKSB7IHJldHVybiBrZXlDb2RlOyB9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cblx0Ly8vLy8vLy8vLy8vXG5cdC8vIE1BQ1JPUyAvL1xuXHQvLy8vLy8vLy8vLy9cblxuXHQvKipcblx0ICogQWNjZXB0cyBhIGtleSBjb21ibyBhbmQgYW4gYXJyYXkgb2Yga2V5IG5hbWVzIHRvIGluamVjdCBvbmNlIHRoZSBrZXlcblx0ICogIGNvbWJvIGlzIHNhdGlzZmllZC5cblx0ICogQHBhcmFtICB7U3RyaW5nfVx0Y29tYm9cblx0ICogQHBhcmFtICB7QXJyYXl9XHRpbmplY3RlZEtleXNcblx0ICovXG5cdGZ1bmN0aW9uIGNyZWF0ZU1hY3JvKGNvbWJvLCBpbmplY3RlZEtleXMpIHtcblx0XHRpZih0eXBlb2YgY29tYm8gIT09ICdzdHJpbmcnICYmICh0eXBlb2YgY29tYm8gIT09ICdvYmplY3QnIHx8IHR5cGVvZiBjb21iby5wdXNoICE9PSAnZnVuY3Rpb24nKSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNyZWF0ZSBtYWNyby4gVGhlIGNvbWJvIG11c3QgYmUgYSBzdHJpbmcgb3IgYXJyYXkuXCIpO1xuXHRcdH1cblx0XHRpZih0eXBlb2YgaW5qZWN0ZWRLZXlzICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgaW5qZWN0ZWRLZXlzLnB1c2ggIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjcmVhdGUgbWFjcm8uIFRoZSBpbmplY3RlZEtleXMgbXVzdCBiZSBhbiBhcnJheS5cIik7XG5cdFx0fVxuXHRcdG1hY3Jvcy5wdXNoKFtjb21ibywgaW5qZWN0ZWRLZXlzXSk7XG5cdH1cblxuXHQvKipcblx0ICogQWNjZXB0cyBhIGtleSBjb21ibyBhbmQgY2xlYXJzIGFueSBhbmQgYWxsIG1hY3JvcyBib3VuZCB0byB0aGF0IGtleVxuXHQgKiBjb21iby5cblx0ICogQHBhcmFtICB7U3RyaW5nfSBjb21ib1xuXHQgKi9cblx0ZnVuY3Rpb24gcmVtb3ZlTWFjcm8oY29tYm8pIHtcblx0XHR2YXIgbWFjcm87XG5cdFx0aWYodHlwZW9mIGNvbWJvICE9PSAnc3RyaW5nJyAmJiAodHlwZW9mIGNvbWJvICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgY29tYm8ucHVzaCAhPT0gJ2Z1bmN0aW9uJykpIHsgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlbW92ZSBtYWNyby4gVGhlIGNvbWJvIG11c3QgYmUgYSBzdHJpbmcgb3IgYXJyYXkuXCIpOyB9XG5cdFx0Zm9yKG1JID0gMDsgbUkgPCBtYWNyb3MubGVuZ3RoOyBtSSArPSAxKSB7XG5cdFx0XHRtYWNybyA9IG1hY3Jvc1ttSV07XG5cdFx0XHRpZihjb21wYXJlQ29tYm9zKGNvbWJvLCBtYWNyb1swXSkpIHtcblx0XHRcdFx0cmVtb3ZlQWN0aXZlS2V5KG1hY3JvWzFdKTtcblx0XHRcdFx0bWFjcm9zLnNwbGljZShtSSwgMSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBFeGVjdXRlcyBtYWNyb3MgYWdhaW5zdCB0aGUgYWN0aXZlIGtleXMuIEVhY2ggbWFjcm8ncyBrZXkgY29tYm8gaXNcblx0ICogIGNoZWNrZWQgYW5kIGlmIGZvdW5kIHRvIGJlIHNhdGlzZmllZCwgdGhlIG1hY3JvJ3Mga2V5IG5hbWVzIGFyZSBpbmplY3RlZFxuXHQgKiAgaW50byBhY3RpdmUga2V5cy5cblx0ICovXG5cdGZ1bmN0aW9uIGV4ZWN1dGVNYWNyb3MoKSB7XG5cdFx0dmFyIG1JLCBjb21ibywga0k7XG5cdFx0Zm9yKG1JID0gMDsgbUkgPCBtYWNyb3MubGVuZ3RoOyBtSSArPSAxKSB7XG5cdFx0XHRjb21ibyA9IHBhcnNlS2V5Q29tYm8obWFjcm9zW21JXVswXSk7XG5cdFx0XHRpZihhY3RpdmVNYWNyb3MuaW5kZXhPZihtYWNyb3NbbUldKSA9PT0gLTEgJiYgaXNTYXRpc2ZpZWRDb21ibyhjb21ibykpIHtcblx0XHRcdFx0YWN0aXZlTWFjcm9zLnB1c2gobWFjcm9zW21JXSk7XG5cdFx0XHRcdGZvcihrSSA9IDA7IGtJIDwgbWFjcm9zW21JXVsxXS5sZW5ndGg7IGtJICs9IDEpIHtcblx0XHRcdFx0XHRhZGRBY3RpdmVLZXkobWFjcm9zW21JXVsxXVtrSV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFBydW5lcyBhY3RpdmUgbWFjcm9zLiBDaGVja3MgZWFjaCBhY3RpdmUgbWFjcm8ncyBrZXkgY29tYm8gYW5kIGlmIGZvdW5kXG5cdCAqICB0byBubyBsb25nZXIgdG8gYmUgc2F0aXNmaWVkLCBlYWNoIG9mIHRoZSBtYWNybydzIGtleSBuYW1lcyBhcmUgcmVtb3ZlZFxuXHQgKiAgZnJvbSBhY3RpdmUga2V5cy5cblx0ICovXG5cdGZ1bmN0aW9uIHBydW5lTWFjcm9zKCkge1xuXHRcdHZhciBtSSwgY29tYm8sIGtJO1xuXHRcdGZvcihtSSA9IDA7IG1JIDwgYWN0aXZlTWFjcm9zLmxlbmd0aDsgbUkgKz0gMSkge1xuXHRcdFx0Y29tYm8gPSBwYXJzZUtleUNvbWJvKGFjdGl2ZU1hY3Jvc1ttSV1bMF0pO1xuXHRcdFx0aWYoaXNTYXRpc2ZpZWRDb21ibyhjb21ibykgPT09IGZhbHNlKSB7XG5cdFx0XHRcdGZvcihrSSA9IDA7IGtJIDwgYWN0aXZlTWFjcm9zW21JXVsxXS5sZW5ndGg7IGtJICs9IDEpIHtcblx0XHRcdFx0XHRyZW1vdmVBY3RpdmVLZXkoYWN0aXZlTWFjcm9zW21JXVsxXVtrSV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGFjdGl2ZU1hY3Jvcy5zcGxpY2UobUksIDEpO1xuXHRcdFx0XHRtSSAtPSAxO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cblx0Ly8vLy8vLy8vLy8vLy9cblx0Ly8gQklORElOR1MgLy9cblx0Ly8vLy8vLy8vLy8vLy9cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIGJpbmRpbmcgb2JqZWN0LCBhbmQsIGlmIHByb3ZpZGVkLCBiaW5kcyBhIGtleSBkb3duIGhhbmRlciBhbmRcblx0ICogIGEga2V5IHVwIGhhbmRsZXIuIFJldHVybnMgYSBiaW5kaW5nIG9iamVjdCB0aGF0IGVtaXRzIGtleXVwIGFuZFxuXHQgKiAga2V5ZG93biBldmVudHMuXG5cdCAqIEBwYXJhbSAge1N0cmluZ31cdFx0a2V5Q29tYm9cblx0ICogQHBhcmFtICB7RnVuY3Rpb259XHRrZXlEb3duQ2FsbGJhY2tcdFtPcHRpb25hbF1cblx0ICogQHBhcmFtICB7RnVuY3Rpb259XHRrZXlVcENhbGxiYWNrXHRbT3B0aW9uYWxdXG5cdCAqIEByZXR1cm4ge09iamVjdH1cdFx0YmluZGluZ1xuXHQgKi9cblx0ZnVuY3Rpb24gY3JlYXRlQmluZGluZyhrZXlDb21ibywga2V5RG93bkNhbGxiYWNrLCBrZXlVcENhbGxiYWNrKSB7XG5cdFx0dmFyIGFwaSA9IHt9LCBiaW5kaW5nLCBzdWJCaW5kaW5ncyA9IFtdLCBiaW5kaW5nQXBpID0ge30sIGtJLFxuXHRcdHN1YkNvbWJvO1xuXG5cdFx0Ly9icmVhayB0aGUgY29tYm8gZG93biBpbnRvIGEgY29tYm8gYXJyYXlcblx0XHRpZih0eXBlb2Yga2V5Q29tYm8gPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRrZXlDb21ibyA9IHBhcnNlS2V5Q29tYm8oa2V5Q29tYm8pO1xuXHRcdH1cblxuXHRcdC8vYmluZCBlYWNoIHN1YiBjb21ibyBjb250YWluZWQgd2l0aGluIHRoZSBjb21ibyBzdHJpbmdcblx0XHRmb3Ioa0kgPSAwOyBrSSA8IGtleUNvbWJvLmxlbmd0aDsga0kgKz0gMSkge1xuXHRcdFx0YmluZGluZyA9IHt9O1xuXG5cdFx0XHQvL3N0cmluZ2lmeSB0aGUgY29tYm8gYWdhaW5cblx0XHRcdHN1YkNvbWJvID0gc3RyaW5naWZ5S2V5Q29tYm8oW2tleUNvbWJvW2tJXV0pO1xuXG5cdFx0XHQvL3ZhbGlkYXRlIHRoZSBzdWIgY29tYm9cblx0XHRcdGlmKHR5cGVvZiBzdWJDb21ibyAhPT0gJ3N0cmluZycpIHsgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gYmluZCBrZXkgY29tYm8uIFRoZSBrZXkgY29tYm8gbXVzdCBiZSBzdHJpbmcuJyk7IH1cblxuXHRcdFx0Ly9jcmVhdGUgdGhlIGJpbmRpbmdcblx0XHRcdGJpbmRpbmcua2V5Q29tYm8gPSBzdWJDb21ibztcblx0XHRcdGJpbmRpbmcua2V5RG93bkNhbGxiYWNrID0gW107XG5cdFx0XHRiaW5kaW5nLmtleVVwQ2FsbGJhY2sgPSBbXTtcblxuXHRcdFx0Ly9pbmplY3QgdGhlIGtleSBkb3duIGFuZCBrZXkgdXAgY2FsbGJhY2tzIGlmIGdpdmVuXG5cdFx0XHRpZihrZXlEb3duQ2FsbGJhY2spIHsgYmluZGluZy5rZXlEb3duQ2FsbGJhY2sucHVzaChrZXlEb3duQ2FsbGJhY2spOyB9XG5cdFx0XHRpZihrZXlVcENhbGxiYWNrKSB7IGJpbmRpbmcua2V5VXBDYWxsYmFjay5wdXNoKGtleVVwQ2FsbGJhY2spOyB9XG5cblx0XHRcdC8vc3Rhc2ggdGhlIG5ldyBiaW5kaW5nXG5cdFx0XHRiaW5kaW5ncy5wdXNoKGJpbmRpbmcpO1xuXHRcdFx0c3ViQmluZGluZ3MucHVzaChiaW5kaW5nKTtcblx0XHR9XG5cblx0XHQvL2J1aWxkIHRoZSBiaW5kaW5nIGFwaVxuXHRcdGFwaS5jbGVhciA9IGNsZWFyO1xuXHRcdGFwaS5vbiA9IG9uO1xuXHRcdHJldHVybiBhcGk7XG5cblx0XHQvKipcblx0XHQgKiBDbGVhcnMgdGhlIGJpbmRpbmdcblx0XHQgKi9cblx0XHRmdW5jdGlvbiBjbGVhcigpIHtcblx0XHRcdHZhciBiSTtcblx0XHRcdGZvcihiSSA9IDA7IGJJIDwgc3ViQmluZGluZ3MubGVuZ3RoOyBiSSArPSAxKSB7XG5cdFx0XHRcdGJpbmRpbmdzLnNwbGljZShiaW5kaW5ncy5pbmRleE9mKHN1YkJpbmRpbmdzW2JJXSksIDEpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEFjY2VwdHMgYW4gZXZlbnQgbmFtZS4gYW5kIGFueSBudW1iZXIgb2YgY2FsbGJhY2tzLiBXaGVuIHRoZSBldmVudCBpc1xuXHRcdCAqICBlbWl0dGVkLCBhbGwgY2FsbGJhY2tzIGFyZSBleGVjdXRlZC4gQXZhaWxhYmxlIGV2ZW50cyBhcmUga2V5IHVwIGFuZFxuXHRcdCAqICBrZXkgZG93bi5cblx0XHQgKiBAcGFyYW0gIHtTdHJpbmd9XHRldmVudE5hbWVcblx0XHQgKiBAcmV0dXJuIHtPYmplY3R9XHRzdWJCaW5kaW5nXG5cdFx0ICovXG5cdFx0ZnVuY3Rpb24gb24oZXZlbnROYW1lICAgICkge1xuXHRcdFx0dmFyIGFwaSA9IHt9LCBjYWxsYmFja3MsIGNJLCBiSTtcblxuXHRcdFx0Ly92YWxpZGF0ZSBldmVudCBuYW1lXG5cdFx0XHRpZih0eXBlb2YgZXZlbnROYW1lICE9PSAnc3RyaW5nJykgeyB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBiaW5kIGNhbGxiYWNrLiBUaGUgZXZlbnQgbmFtZSBtdXN0IGJlIGEgc3RyaW5nLicpOyB9XG5cdFx0XHRpZihldmVudE5hbWUgIT09ICdrZXl1cCcgJiYgZXZlbnROYW1lICE9PSAna2V5ZG93bicpIHsgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYmluZCBjYWxsYmFjay4gVGhlIGV2ZW50IG5hbWUgbXVzdCBiZSBhIFwia2V5dXBcIiBvciBcImtleWRvd25cIi4nKTsgfVxuXG5cdFx0XHQvL2dhdGhlciB0aGUgY2FsbGJhY2tzXG5cdFx0XHRjYWxsYmFja3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYXJndW1lbnRzLCBbMV0pO1xuXG5cdFx0XHQvL3N0YXNoIGVhY2ggdGhlIG5ldyBiaW5kaW5nXG5cdFx0XHRmb3IoY0kgPSAwOyBjSSA8IGNhbGxiYWNrcy5sZW5ndGg7IGNJICs9IDEpIHtcblx0XHRcdFx0aWYodHlwZW9mIGNhbGxiYWNrc1tjSV0gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRpZihldmVudE5hbWUgPT09ICdrZXl1cCcpIHtcblx0XHRcdFx0XHRcdGZvcihiSSA9IDA7IGJJIDwgc3ViQmluZGluZ3MubGVuZ3RoOyBiSSArPSAxKSB7XG5cdFx0XHRcdFx0XHRcdHN1YkJpbmRpbmdzW2JJXS5rZXlVcENhbGxiYWNrLnB1c2goY2FsbGJhY2tzW2NJXSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIGlmKGV2ZW50TmFtZSA9PT0gJ2tleWRvd24nKSB7XG5cdFx0XHRcdFx0XHRmb3IoYkkgPSAwOyBiSSA8IHN1YkJpbmRpbmdzLmxlbmd0aDsgYkkgKz0gMSkge1xuXHRcdFx0XHRcdFx0XHRzdWJCaW5kaW5nc1tiSV0ua2V5RG93bkNhbGxiYWNrLnB1c2goY2FsbGJhY2tzW2NJXSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vY29uc3RydWN0IGFuZCByZXR1cm4gdGhlIHN1YiBiaW5kaW5nIGFwaVxuXHRcdFx0YXBpLmNsZWFyID0gY2xlYXI7XG5cdFx0XHRyZXR1cm4gYXBpO1xuXG5cdFx0XHQvKipcblx0XHRcdCAqIENsZWFycyB0aGUgYmluZGluZ1xuXHRcdFx0ICovXG5cdFx0XHRmdW5jdGlvbiBjbGVhcigpIHtcblx0XHRcdFx0dmFyIGNJLCBiSTtcblx0XHRcdFx0Zm9yKGNJID0gMDsgY0kgPCBjYWxsYmFja3MubGVuZ3RoOyBjSSArPSAxKSB7XG5cdFx0XHRcdFx0aWYodHlwZW9mIGNhbGxiYWNrc1tjSV0gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRcdGlmKGV2ZW50TmFtZSA9PT0gJ2tleXVwJykge1xuXHRcdFx0XHRcdFx0XHRmb3IoYkkgPSAwOyBiSSA8IHN1YkJpbmRpbmdzLmxlbmd0aDsgYkkgKz0gMSkge1xuXHRcdFx0XHRcdFx0XHRcdHN1YkJpbmRpbmdzW2JJXS5rZXlVcENhbGxiYWNrLnNwbGljZShzdWJCaW5kaW5nc1tiSV0ua2V5VXBDYWxsYmFjay5pbmRleE9mKGNhbGxiYWNrc1tjSV0pLCAxKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Zm9yKGJJID0gMDsgYkkgPCBzdWJCaW5kaW5ncy5sZW5ndGg7IGJJICs9IDEpIHtcblx0XHRcdFx0XHRcdFx0XHRzdWJCaW5kaW5nc1tiSV0ua2V5RG93bkNhbGxiYWNrLnNwbGljZShzdWJCaW5kaW5nc1tiSV0ua2V5RG93bkNhbGxiYWNrLmluZGV4T2YoY2FsbGJhY2tzW2NJXSksIDEpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIENsZWFycyBhbGwgYmluZGluZyBhdHRhY2hlZCB0byBhIGdpdmVuIGtleSBjb21iby4gS2V5IG5hbWUgb3JkZXIgZG9lcyBub3Rcblx0ICogbWF0dGVyIGFzIGxvbmcgYXMgdGhlIGtleSBjb21ib3MgZXF1YXRlLlxuXHQgKiBAcGFyYW0gIHtTdHJpbmd9XHRrZXlDb21ib1xuXHQgKi9cblx0ZnVuY3Rpb24gcmVtb3ZlQmluZGluZ0J5S2V5Q29tYm8oa2V5Q29tYm8pIHtcblx0XHR2YXIgYkksIGJpbmRpbmcsIGtleU5hbWU7XG5cdFx0Zm9yKGJJID0gMDsgYkkgPCBiaW5kaW5ncy5sZW5ndGg7IGJJICs9IDEpIHtcblx0XHRcdGJpbmRpbmcgPSBiaW5kaW5nc1tiSV07XG5cdFx0XHRpZihjb21wYXJlQ29tYm9zKGtleUNvbWJvLCBiaW5kaW5nLmtleUNvbWJvKSkge1xuXHRcdFx0XHRiaW5kaW5ncy5zcGxpY2UoYkksIDEpOyBiSSAtPSAxO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBDbGVhcnMgYWxsIGJpbmRpbmcgYXR0YWNoZWQgdG8ga2V5IGNvbWJvcyBjb250YWluaW5nIGEgZ2l2ZW4ga2V5IG5hbWUuXG5cdCAqIEBwYXJhbSAge1N0cmluZ31cdGtleU5hbWVcblx0ICovXG5cdGZ1bmN0aW9uIHJlbW92ZUJpbmRpbmdCeUtleU5hbWUoa2V5TmFtZSkge1xuXHRcdHZhciBiSSwga0ksIGJpbmRpbmc7XG5cdFx0aWYoa2V5TmFtZSkge1xuXHRcdFx0Zm9yKGJJID0gMDsgYkkgPCBiaW5kaW5ncy5sZW5ndGg7IGJJICs9IDEpIHtcblx0XHRcdFx0YmluZGluZyA9IGJpbmRpbmdzW2JJXTtcblx0XHRcdFx0Zm9yKGtJID0gMDsga0kgPCBiaW5kaW5nLmtleUNvbWJvLmxlbmd0aDsga0kgKz0gMSkge1xuXHRcdFx0XHRcdGlmKGJpbmRpbmcua2V5Q29tYm9ba0ldLmluZGV4T2Yoa2V5TmFtZSkgPiAtMSkge1xuXHRcdFx0XHRcdFx0YmluZGluZ3Muc3BsaWNlKGJJLCAxKTsgYkkgLT0gMTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRiaW5kaW5ncyA9IFtdO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBFeGVjdXRlcyBiaW5kaW5ncyB0aGF0IGFyZSBhY3RpdmUuIE9ubHkgYWxsb3dzIHRoZSBrZXlzIHRvIGJlIHVzZWQgb25jZVxuXHQgKiAgYXMgdG8gcHJldmVudCBiaW5kaW5nIG92ZXJsYXAuXG5cdCAqIEBwYXJhbSAge0tleWJvYXJkRXZlbnR9XHRldmVudFx0VGhlIGtleWJvYXJkIGV2ZW50LlxuXHQgKi9cblx0ZnVuY3Rpb24gZXhlY3V0ZUJpbmRpbmdzKGV2ZW50KSB7XG5cdFx0dmFyIGJJLCBzQkksIGJpbmRpbmcsIGJpbmRpbmdLZXlzLCByZW1haW5pbmdLZXlzLCBjSSwga2lsbEV2ZW50QnViYmxlLCBrSSwgYmluZGluZ0tleXNTYXRpc2ZpZWQsXG5cdFx0aW5kZXgsIHNvcnRlZEJpbmRpbmdzID0gW10sIGJpbmRpbmdXZWlnaHQ7XG5cblx0XHRyZW1haW5pbmdLZXlzID0gW10uY29uY2F0KGFjdGl2ZUtleXMpO1xuXHRcdGZvcihiSSA9IDA7IGJJIDwgYmluZGluZ3MubGVuZ3RoOyBiSSArPSAxKSB7XG5cdFx0XHRiaW5kaW5nV2VpZ2h0ID0gZXh0cmFjdENvbWJvS2V5cyhiaW5kaW5nc1tiSV0ua2V5Q29tYm8pLmxlbmd0aDtcblx0XHRcdGlmKCFzb3J0ZWRCaW5kaW5nc1tiaW5kaW5nV2VpZ2h0XSkgeyBzb3J0ZWRCaW5kaW5nc1tiaW5kaW5nV2VpZ2h0XSA9IFtdOyB9XG5cdFx0XHRzb3J0ZWRCaW5kaW5nc1tiaW5kaW5nV2VpZ2h0XS5wdXNoKGJpbmRpbmdzW2JJXSk7XG5cdFx0fVxuXHRcdGZvcihzQkkgPSBzb3J0ZWRCaW5kaW5ncy5sZW5ndGggLSAxOyBzQkkgPj0gMDsgc0JJIC09IDEpIHtcblx0XHRcdGlmKCFzb3J0ZWRCaW5kaW5nc1tzQkldKSB7IGNvbnRpbnVlOyB9XG5cdFx0XHRmb3IoYkkgPSAwOyBiSSA8IHNvcnRlZEJpbmRpbmdzW3NCSV0ubGVuZ3RoOyBiSSArPSAxKSB7XG5cdFx0XHRcdGJpbmRpbmcgPSBzb3J0ZWRCaW5kaW5nc1tzQkldW2JJXTtcblx0XHRcdFx0YmluZGluZ0tleXMgPSBleHRyYWN0Q29tYm9LZXlzKGJpbmRpbmcua2V5Q29tYm8pO1xuXHRcdFx0XHRiaW5kaW5nS2V5c1NhdGlzZmllZCA9IHRydWU7XG5cdFx0XHRcdGZvcihrSSA9IDA7IGtJIDwgYmluZGluZ0tleXMubGVuZ3RoOyBrSSArPSAxKSB7XG5cdFx0XHRcdFx0aWYocmVtYWluaW5nS2V5cy5pbmRleE9mKGJpbmRpbmdLZXlzW2tJXSkgPT09IC0xKSB7XG5cdFx0XHRcdFx0XHRiaW5kaW5nS2V5c1NhdGlzZmllZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKGJpbmRpbmdLZXlzU2F0aXNmaWVkICYmIGlzU2F0aXNmaWVkQ29tYm8oYmluZGluZy5rZXlDb21ibykpIHtcblx0XHRcdFx0XHRhY3RpdmVCaW5kaW5ncy5wdXNoKGJpbmRpbmcpO1xuXHRcdFx0XHRcdGZvcihrSSA9IDA7IGtJIDwgYmluZGluZ0tleXMubGVuZ3RoOyBrSSArPSAxKSB7XG5cdFx0XHRcdFx0XHRpbmRleCA9IHJlbWFpbmluZ0tleXMuaW5kZXhPZihiaW5kaW5nS2V5c1trSV0pO1xuXHRcdFx0XHRcdFx0aWYoaW5kZXggPiAtMSkge1xuXHRcdFx0XHRcdFx0XHRyZW1haW5pbmdLZXlzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRcdFx0XHRcdGtJIC09IDE7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGZvcihjSSA9IDA7IGNJIDwgYmluZGluZy5rZXlEb3duQ2FsbGJhY2subGVuZ3RoOyBjSSArPSAxKSB7XG5cdFx0XHRcdFx0XHRpZiAoYmluZGluZy5rZXlEb3duQ2FsbGJhY2tbY0ldKGV2ZW50LCBnZXRBY3RpdmVLZXlzKCksIGJpbmRpbmcua2V5Q29tYm8pID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0XHRraWxsRXZlbnRCdWJibGUgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZihraWxsRXZlbnRCdWJibGUgPT09IHRydWUpIHtcblx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyBiaW5kaW5ncyB0aGF0IGFyZSBubyBsb25nZXIgc2F0aXNmaWVkIGJ5IHRoZSBhY3RpdmUga2V5cy4gQWxzb1xuXHQgKiAgZmlyZXMgdGhlIGtleSB1cCBjYWxsYmFja3MuXG5cdCAqIEBwYXJhbSAge0tleWJvYXJkRXZlbnR9XHRldmVudFxuXHQgKi9cblx0ZnVuY3Rpb24gcHJ1bmVCaW5kaW5ncyhldmVudCkge1xuXHRcdHZhciBiSSwgY0ksIGJpbmRpbmcsIGtpbGxFdmVudEJ1YmJsZTtcblx0XHRmb3IoYkkgPSAwOyBiSSA8IGFjdGl2ZUJpbmRpbmdzLmxlbmd0aDsgYkkgKz0gMSkge1xuXHRcdFx0YmluZGluZyA9IGFjdGl2ZUJpbmRpbmdzW2JJXTtcblx0XHRcdGlmKGlzU2F0aXNmaWVkQ29tYm8oYmluZGluZy5rZXlDb21ibykgPT09IGZhbHNlKSB7XG5cdFx0XHRcdGZvcihjSSA9IDA7IGNJIDwgYmluZGluZy5rZXlVcENhbGxiYWNrLmxlbmd0aDsgY0kgKz0gMSkge1xuXHRcdFx0XHRcdGlmIChiaW5kaW5nLmtleVVwQ2FsbGJhY2tbY0ldKGV2ZW50LCBnZXRBY3RpdmVLZXlzKCksIGJpbmRpbmcua2V5Q29tYm8pID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0a2lsbEV2ZW50QnViYmxlID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoa2lsbEV2ZW50QnViYmxlID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRhY3RpdmVCaW5kaW5ncy5zcGxpY2UoYkksIDEpO1xuXHRcdFx0XHRiSSAtPSAxO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cblx0Ly8vLy8vLy8vLy8vLy8vLy8vL1xuXHQvLyBDT01CTyBTVFJJTkdTIC8vXG5cdC8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXHQvKipcblx0ICogQ29tcGFyZXMgdHdvIGtleSBjb21ib3MgcmV0dXJuaW5nIHRydWUgd2hlbiB0aGV5IGFyZSBmdW5jdGlvbmFsbHlcblx0ICogIGVxdWl2YWxlbnQuXG5cdCAqIEBwYXJhbSAge1N0cmluZ31cdGtleUNvbWJvQXJyYXlBIGtleUNvbWJvIEEga2V5IGNvbWJvIHN0cmluZyBvciBhcnJheS5cblx0ICogQHBhcmFtICB7U3RyaW5nfVx0a2V5Q29tYm9BcnJheUIga2V5Q29tYm8gQSBrZXkgY29tYm8gc3RyaW5nIG9yIGFycmF5LlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKi9cblx0ZnVuY3Rpb24gY29tcGFyZUNvbWJvcyhrZXlDb21ib0FycmF5QSwga2V5Q29tYm9BcnJheUIpIHtcblx0XHR2YXIgY0ksIHNJLCBrSTtcblx0XHRrZXlDb21ib0FycmF5QSA9IHBhcnNlS2V5Q29tYm8oa2V5Q29tYm9BcnJheUEpO1xuXHRcdGtleUNvbWJvQXJyYXlCID0gcGFyc2VLZXlDb21ibyhrZXlDb21ib0FycmF5Qik7XG5cdFx0aWYoa2V5Q29tYm9BcnJheUEubGVuZ3RoICE9PSBrZXlDb21ib0FycmF5Qi5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0Zm9yKGNJID0gMDsgY0kgPCBrZXlDb21ib0FycmF5QS5sZW5ndGg7IGNJICs9IDEpIHtcblx0XHRcdGlmKGtleUNvbWJvQXJyYXlBW2NJXS5sZW5ndGggIT09IGtleUNvbWJvQXJyYXlCW2NJXS5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRmb3Ioc0kgPSAwOyBzSSA8IGtleUNvbWJvQXJyYXlBW2NJXS5sZW5ndGg7IHNJICs9IDEpIHtcblx0XHRcdFx0aWYoa2V5Q29tYm9BcnJheUFbY0ldW3NJXS5sZW5ndGggIT09IGtleUNvbWJvQXJyYXlCW2NJXVtzSV0ubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdFx0XHRmb3Ioa0kgPSAwOyBrSSA8IGtleUNvbWJvQXJyYXlBW2NJXVtzSV0ubGVuZ3RoOyBrSSArPSAxKSB7XG5cdFx0XHRcdFx0aWYoa2V5Q29tYm9BcnJheUJbY0ldW3NJXS5pbmRleE9mKGtleUNvbWJvQXJyYXlBW2NJXVtzSV1ba0ldKSA9PT0gLTEpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIHRvIHNlZSBpZiBhIGtleSBjb21ibyBzdHJpbmcgb3Iga2V5IGFycmF5IGlzIHNhdGlzZmllZCBieSB0aGVcblx0ICogIGN1cnJlbnRseSBhY3RpdmUga2V5cy4gSXQgZG9lcyBub3QgdGFrZSBpbnRvIGFjY291bnQgc3BlbnQga2V5cy5cblx0ICogQHBhcmFtICB7U3RyaW5nfVx0a2V5Q29tYm9cdEEga2V5IGNvbWJvIHN0cmluZyBvciBhcnJheS5cblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICovXG5cdGZ1bmN0aW9uIGlzU2F0aXNmaWVkQ29tYm8oa2V5Q29tYm8pIHtcblx0XHR2YXIgY0ksIHNJLCBzdGFnZSwga0ksIHN0YWdlT2Zmc2V0ID0gMCwgaW5kZXgsIGNvbWJvTWF0Y2hlcztcblx0XHRrZXlDb21ibyA9IHBhcnNlS2V5Q29tYm8oa2V5Q29tYm8pO1xuXHRcdGZvcihjSSA9IDA7IGNJIDwga2V5Q29tYm8ubGVuZ3RoOyBjSSArPSAxKSB7XG5cdFx0XHRjb21ib01hdGNoZXMgPSB0cnVlO1xuXHRcdFx0c3RhZ2VPZmZzZXQgPSAwO1xuXHRcdFx0Zm9yKHNJID0gMDsgc0kgPCBrZXlDb21ib1tjSV0ubGVuZ3RoOyBzSSArPSAxKSB7XG5cdFx0XHRcdHN0YWdlID0gW10uY29uY2F0KGtleUNvbWJvW2NJXVtzSV0pO1xuXHRcdFx0XHRmb3Ioa0kgPSBzdGFnZU9mZnNldDsga0kgPCBhY3RpdmVLZXlzLmxlbmd0aDsga0kgKz0gMSkge1xuXHRcdFx0XHRcdGluZGV4ID0gc3RhZ2UuaW5kZXhPZihhY3RpdmVLZXlzW2tJXSk7XG5cdFx0XHRcdFx0aWYoaW5kZXggPiAtMSkge1xuXHRcdFx0XHRcdFx0c3RhZ2Uuc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdFx0XHRcdHN0YWdlT2Zmc2V0ID0ga0k7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKHN0YWdlLmxlbmd0aCAhPT0gMCkgeyBjb21ib01hdGNoZXMgPSBmYWxzZTsgYnJlYWs7IH1cblx0XHRcdH1cblx0XHRcdGlmKGNvbWJvTWF0Y2hlcykgeyByZXR1cm4gdHJ1ZTsgfVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0ICogQWNjZXB0cyBhIGtleSBjb21ibyBhcnJheSBvciBzdHJpbmcgYW5kIHJldHVybnMgYSBmbGF0IGFycmF5IGNvbnRhaW5pbmcgYWxsIGtleXMgcmVmZXJlbmNlZCBieVxuXHQgKiB0aGUga2V5IGNvbWJvLlxuXHQgKiBAcGFyYW0gIHtTdHJpbmd9XHRrZXlDb21ib1x0QSBrZXkgY29tYm8gc3RyaW5nIG9yIGFycmF5LlxuXHQgKiBAcmV0dXJuIHtBcnJheX1cblx0ICovXG5cdGZ1bmN0aW9uIGV4dHJhY3RDb21ib0tleXMoa2V5Q29tYm8pIHtcblx0XHR2YXIgY0ksIHNJLCBrSSwga2V5cyA9IFtdO1xuXHRcdGtleUNvbWJvID0gcGFyc2VLZXlDb21ibyhrZXlDb21ibyk7XG5cdFx0Zm9yKGNJID0gMDsgY0kgPCBrZXlDb21iby5sZW5ndGg7IGNJICs9IDEpIHtcblx0XHRcdGZvcihzSSA9IDA7IHNJIDwga2V5Q29tYm9bY0ldLmxlbmd0aDsgc0kgKz0gMSkge1xuXHRcdFx0XHRrZXlzID0ga2V5cy5jb25jYXQoa2V5Q29tYm9bY0ldW3NJXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBrZXlzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFBhcnNlcyBhIGtleSBjb21ibyBzdHJpbmcgaW50byBhIDMgZGltZW5zaW9uYWwgYXJyYXkuXG5cdCAqIC0gTGV2ZWwgMSAtIHN1YiBjb21ib3MuXG5cdCAqIC0gTGV2ZWwgMiAtIGNvbWJvIHN0YWdlcy4gQSBzdGFnZSBpcyBhIHNldCBvZiBrZXkgbmFtZSBwYWlycyB0aGF0IG11c3Rcblx0ICogIGJlIHNhdGlzZmllZCBpbiB0aGUgb3JkZXIgdGhleSBhcmUgZGVmaW5lZC5cblx0ICogLSBMZXZlbCAzIC0gZWFjaCBrZXkgbmFtZSB0byB0aGUgc3RhZ2UuXG5cdCAqIEBwYXJhbSAge1N0cmluZ3xBcnJheX1cdGtleUNvbWJvXHRBIGtleSBjb21ibyBzdHJpbmcuXG5cdCAqIEByZXR1cm4ge0FycmF5fVxuXHQgKi9cblx0ZnVuY3Rpb24gcGFyc2VLZXlDb21ibyhrZXlDb21ibykge1xuXHRcdHZhciBzID0ga2V5Q29tYm8sIGkgPSAwLCBvcCA9IDAsIHdzID0gZmFsc2UsIG5jID0gZmFsc2UsIGNvbWJvcyA9IFtdLCBjb21ibyA9IFtdLCBzdGFnZSA9IFtdLCBrZXkgPSAnJztcblxuXHRcdGlmKHR5cGVvZiBrZXlDb21ibyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGtleUNvbWJvLnB1c2ggPT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGtleUNvbWJvOyB9XG5cdFx0aWYodHlwZW9mIGtleUNvbWJvICE9PSAnc3RyaW5nJykgeyB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBwYXJzZSBcImtleUNvbWJvXCIgYmVjYXVzZSBpdHMgdHlwZSBpcyBcIicgKyAodHlwZW9mIGtleUNvbWJvKSArICdcIi4gSXQgbXVzdCBiZSBhIFwic3RyaW5nXCIuJyk7IH1cblxuXHRcdC8vcmVtb3ZlIGxlYWRpbmcgd2hpdGVzcGFjZVxuXHRcdHdoaWxlKHMuY2hhckF0KGkpID09PSAnICcpIHsgaSArPSAxOyB9XG5cdFx0d2hpbGUodHJ1ZSkge1xuXHRcdFx0aWYocy5jaGFyQXQoaSkgPT09ICcgJykge1xuXHRcdFx0XHQvL3doaXRlIHNwYWNlICYgbmV4dCBjb21ibyBvcFxuXHRcdFx0XHR3aGlsZShzLmNoYXJBdChpKSA9PT0gJyAnKSB7IGkgKz0gMTsgfVxuXHRcdFx0XHR3cyA9IHRydWU7XG5cdFx0XHR9IGVsc2UgaWYocy5jaGFyQXQoaSkgPT09ICcsJykge1xuXHRcdFx0XHRpZihvcCB8fCBuYykgeyB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBrZXkgY29tYm8uIFVuZXhwZWN0ZWQgLCBhdCBjaGFyYWN0ZXIgaW5kZXggJyArIGkgKyAnLicpOyB9XG5cdFx0XHRcdG5jID0gdHJ1ZTtcblx0XHRcdFx0aSArPSAxO1xuXHRcdFx0fSBlbHNlIGlmKHMuY2hhckF0KGkpID09PSAnKycpIHtcblx0XHRcdFx0Ly9uZXh0IGtleVxuXHRcdFx0XHRpZihrZXkubGVuZ3RoKSB7IHN0YWdlLnB1c2goa2V5KTsga2V5ID0gJyc7IH1cblx0XHRcdFx0aWYob3AgfHwgbmMpIHsgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcGFyc2Uga2V5IGNvbWJvLiBVbmV4cGVjdGVkICsgYXQgY2hhcmFjdGVyIGluZGV4ICcgKyBpICsgJy4nKTsgfVxuXHRcdFx0XHRvcCA9IHRydWU7XG5cdFx0XHRcdGkgKz0gMTtcblx0XHRcdH0gZWxzZSBpZihzLmNoYXJBdChpKSA9PT0gJz4nKSB7XG5cdFx0XHRcdC8vbmV4dCBzdGFnZSBvcFxuXHRcdFx0XHRpZihrZXkubGVuZ3RoKSB7IHN0YWdlLnB1c2goa2V5KTsga2V5ID0gJyc7IH1cblx0XHRcdFx0aWYoc3RhZ2UubGVuZ3RoKSB7IGNvbWJvLnB1c2goc3RhZ2UpOyBzdGFnZSA9IFtdOyB9XG5cdFx0XHRcdGlmKG9wIHx8IG5jKSB7IHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHBhcnNlIGtleSBjb21iby4gVW5leHBlY3RlZCA+IGF0IGNoYXJhY3RlciBpbmRleCAnICsgaSArICcuJyk7IH1cblx0XHRcdFx0b3AgPSB0cnVlO1xuXHRcdFx0XHRpICs9IDE7XG5cdFx0XHR9IGVsc2UgaWYoaSA8IHMubGVuZ3RoIC0gMSAmJiBzLmNoYXJBdChpKSA9PT0gJyEnICYmIChzLmNoYXJBdChpICsgMSkgPT09ICc+JyB8fCBzLmNoYXJBdChpICsgMSkgPT09ICcsJyB8fCBzLmNoYXJBdChpICsgMSkgPT09ICcrJykpIHtcblx0XHRcdFx0a2V5ICs9IHMuY2hhckF0KGkgKyAxKTtcblx0XHRcdFx0b3AgPSBmYWxzZTtcblx0XHRcdFx0d3MgPSBmYWxzZTtcblx0XHRcdFx0bmMgPSBmYWxzZTtcblx0XHRcdFx0aSArPSAyO1xuXHRcdFx0fSBlbHNlIGlmKGkgPCBzLmxlbmd0aCAmJiBzLmNoYXJBdChpKSAhPT0gJysnICYmIHMuY2hhckF0KGkpICE9PSAnPicgJiYgcy5jaGFyQXQoaSkgIT09ICcsJyAmJiBzLmNoYXJBdChpKSAhPT0gJyAnKSB7XG5cdFx0XHRcdC8vZW5kIGNvbWJvXG5cdFx0XHRcdGlmKG9wID09PSBmYWxzZSAmJiB3cyA9PT0gdHJ1ZSB8fCBuYyA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdGlmKGtleS5sZW5ndGgpIHsgc3RhZ2UucHVzaChrZXkpOyBrZXkgPSAnJzsgfVxuXHRcdFx0XHRcdGlmKHN0YWdlLmxlbmd0aCkgeyBjb21iby5wdXNoKHN0YWdlKTsgc3RhZ2UgPSBbXTsgfVxuXHRcdFx0XHRcdGlmKGNvbWJvLmxlbmd0aCkgeyBjb21ib3MucHVzaChjb21ibyk7IGNvbWJvID0gW107IH1cblx0XHRcdFx0fVxuXHRcdFx0XHRvcCA9IGZhbHNlO1xuXHRcdFx0XHR3cyA9IGZhbHNlO1xuXHRcdFx0XHRuYyA9IGZhbHNlO1xuXHRcdFx0XHQvL2tleVxuXHRcdFx0XHR3aGlsZShpIDwgcy5sZW5ndGggJiYgcy5jaGFyQXQoaSkgIT09ICcrJyAmJiBzLmNoYXJBdChpKSAhPT0gJz4nICYmIHMuY2hhckF0KGkpICE9PSAnLCcgJiYgcy5jaGFyQXQoaSkgIT09ICcgJykge1xuXHRcdFx0XHRcdGtleSArPSBzLmNoYXJBdChpKTtcblx0XHRcdFx0XHRpICs9IDE7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vdW5rbm93biBjaGFyXG5cdFx0XHRcdGkgKz0gMTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHQvL2VuZCBvZiBjb21ib3Mgc3RyaW5nXG5cdFx0XHRpZihpID49IHMubGVuZ3RoKSB7XG5cdFx0XHRcdGlmKGtleS5sZW5ndGgpIHsgc3RhZ2UucHVzaChrZXkpOyBrZXkgPSAnJzsgfVxuXHRcdFx0XHRpZihzdGFnZS5sZW5ndGgpIHsgY29tYm8ucHVzaChzdGFnZSk7IHN0YWdlID0gW107IH1cblx0XHRcdFx0aWYoY29tYm8ubGVuZ3RoKSB7IGNvbWJvcy5wdXNoKGNvbWJvKTsgY29tYm8gPSBbXTsgfVxuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNvbWJvcztcblx0fVxuXG5cdC8qKlxuXHQgKiBTdHJpbmdpZnlzIGEga2V5IGNvbWJvLlxuXHQgKiBAcGFyYW0gIHtBcnJheXxTdHJpbmd9XHRrZXlDb21ib0FycmF5XHRBIGtleSBjb21ibyBhcnJheS4gSWYgYSBrZXlcblx0ICogIGNvbWJvIHN0cmluZyBpcyBnaXZlbiBpdCB3aWxsIGJlIHJldHVybmVkLlxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqL1xuXHRmdW5jdGlvbiBzdHJpbmdpZnlLZXlDb21ibyhrZXlDb21ib0FycmF5KSB7XG5cdFx0dmFyIGNJLCBjY0ksIG91dHB1dCA9IFtdO1xuXHRcdGlmKHR5cGVvZiBrZXlDb21ib0FycmF5ID09PSAnc3RyaW5nJykgeyByZXR1cm4ga2V5Q29tYm9BcnJheTsgfVxuXHRcdGlmKHR5cGVvZiBrZXlDb21ib0FycmF5ICE9PSAnb2JqZWN0JyB8fCB0eXBlb2Yga2V5Q29tYm9BcnJheS5wdXNoICE9PSAnZnVuY3Rpb24nKSB7IHRocm93IG5ldyBFcnJvcignQ2Fubm90IHN0cmluZ2lmeSBrZXkgY29tYm8uJyk7IH1cblx0XHRmb3IoY0kgPSAwOyBjSSA8IGtleUNvbWJvQXJyYXkubGVuZ3RoOyBjSSArPSAxKSB7XG5cdFx0XHRvdXRwdXRbY0ldID0gW107XG5cdFx0XHRmb3IoY2NJID0gMDsgY2NJIDwga2V5Q29tYm9BcnJheVtjSV0ubGVuZ3RoOyBjY0kgKz0gMSkge1xuXHRcdFx0XHRvdXRwdXRbY0ldW2NjSV0gPSBrZXlDb21ib0FycmF5W2NJXVtjY0ldLmpvaW4oJyArICcpO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0W2NJXSA9IG91dHB1dFtjSV0uam9pbignID4gJyk7XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQuam9pbignICcpO1xuXHR9XG5cblxuXHQvLy8vLy8vLy8vLy8vLy8vL1xuXHQvLyBBQ1RJVkUgS0VZUyAvL1xuXHQvLy8vLy8vLy8vLy8vLy8vL1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBhIGNvcHkgb2YgdGhlIGFjdGl2ZSBrZXlzIGFycmF5LlxuXHQgKiBAcmV0dXJuIHtBcnJheX1cblx0ICovXG5cdGZ1bmN0aW9uIGdldEFjdGl2ZUtleXMoKSB7XG5cdFx0cmV0dXJuIFtdLmNvbmNhdChhY3RpdmVLZXlzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEga2V5IHRvIHRoZSBhY3RpdmUga2V5cyBhcnJheSwgYnV0IG9ubHkgaWYgaXQgaGFzIG5vdCBhbHJlYWR5IGJlZW5cblx0ICogIGFkZGVkLlxuXHQgKiBAcGFyYW0ge1N0cmluZ31cdGtleU5hbWVcdFRoZSBrZXkgbmFtZSBzdHJpbmcuXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGRBY3RpdmVLZXkoa2V5TmFtZSkge1xuXHRcdGlmKGtleU5hbWUubWF0Y2goL1xccy8pKSB7IHRocm93IG5ldyBFcnJvcignQ2Fubm90IGFkZCBrZXkgbmFtZSAnICsga2V5TmFtZSArICcgdG8gYWN0aXZlIGtleXMgYmVjYXVzZSBpdCBjb250YWlucyB3aGl0ZXNwYWNlLicpOyB9XG5cdFx0aWYoYWN0aXZlS2V5cy5pbmRleE9mKGtleU5hbWUpID4gLTEpIHsgcmV0dXJuOyB9XG5cdFx0YWN0aXZlS2V5cy5wdXNoKGtleU5hbWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgYSBrZXkgZnJvbSB0aGUgYWN0aXZlIGtleXMgYXJyYXkuXG5cdCAqIEBwYXJhbSAge1N0cmluZ31cdGtleU5hbWVzXHRUaGUga2V5IG5hbWUgc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gcmVtb3ZlQWN0aXZlS2V5KGtleU5hbWUpIHtcblx0XHR2YXIga2V5Q29kZSA9IGdldEtleUNvZGUoa2V5TmFtZSk7XG5cdFx0aWYoa2V5Q29kZSA9PT0gJzkxJyB8fCBrZXlDb2RlID09PSAnOTInKSB7IGFjdGl2ZUtleXMgPSBbXTsgfSAvL3JlbW92ZSBhbGwga2V5IG9uIHJlbGVhc2Ugb2Ygc3VwZXIuXG5cdFx0ZWxzZSB7IGFjdGl2ZUtleXMuc3BsaWNlKGFjdGl2ZUtleXMuaW5kZXhPZihrZXlOYW1lKSwgMSk7IH1cblx0fVxuXG5cblx0Ly8vLy8vLy8vLy8vL1xuXHQvLyBMT0NBTEVTIC8vXG5cdC8vLy8vLy8vLy8vLy9cblxuXHQvKipcblx0ICogUmVnaXN0ZXJzIGEgbmV3IGxvY2FsZS4gVGhpcyBpcyB1c2VmdWwgaWYgeW91IHdvdWxkIGxpa2UgdG8gYWRkIHN1cHBvcnQgZm9yIGEgbmV3IGtleWJvYXJkIGxheW91dC4gSXQgY291bGQgYWxzbyBiZSB1c2VmdWwgZm9yXG5cdCAqIGFsdGVybmF0aXZlIGtleSBuYW1lcy4gRm9yIGV4YW1wbGUgaWYgeW91IHByb2dyYW0gZ2FtZXMgeW91IGNvdWxkIGNyZWF0ZSBhIGxvY2FsZSBmb3IgeW91ciBrZXkgbWFwcGluZ3MuIEluc3RlYWQgb2Yga2V5IDY1IG1hcHBlZFxuXHQgKiB0byAnYScgeW91IGNvdWxkIG1hcCBpdCB0byAnanVtcCcuXG5cdCAqIEBwYXJhbSAge1N0cmluZ31cdGxvY2FsZU5hbWVcdFRoZSBuYW1lIG9mIHRoZSBuZXcgbG9jYWxlLlxuXHQgKiBAcGFyYW0gIHtPYmplY3R9XHRsb2NhbGVNYXBcdFRoZSBsb2NhbGUgbWFwLlxuXHQgKi9cblx0ZnVuY3Rpb24gcmVnaXN0ZXJMb2NhbGUobG9jYWxlTmFtZSwgbG9jYWxlTWFwKSB7XG5cblx0XHQvL3ZhbGlkYXRlIGFyZ3VtZW50c1xuXHRcdGlmKHR5cGVvZiBsb2NhbGVOYW1lICE9PSAnc3RyaW5nJykgeyB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWdpc3RlciBuZXcgbG9jYWxlLiBUaGUgbG9jYWxlIG5hbWUgbXVzdCBiZSBhIHN0cmluZy4nKTsgfVxuXHRcdGlmKHR5cGVvZiBsb2NhbGVNYXAgIT09ICdvYmplY3QnKSB7IHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlZ2lzdGVyICcgKyBsb2NhbGVOYW1lICsgJyBsb2NhbGUuIFRoZSBsb2NhbGUgbWFwIG11c3QgYmUgYW4gb2JqZWN0LicpOyB9XG5cdFx0aWYodHlwZW9mIGxvY2FsZU1hcC5tYXAgIT09ICdvYmplY3QnKSB7IHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlZ2lzdGVyICcgKyBsb2NhbGVOYW1lICsgJyBsb2NhbGUuIFRoZSBsb2NhbGUgbWFwIGlzIGludmFsaWQuJyk7IH1cblxuXHRcdC8vc3Rhc2ggdGhlIGxvY2FsZVxuXHRcdGlmKCFsb2NhbGVNYXAubWFjcm9zKSB7IGxvY2FsZU1hcC5tYWNyb3MgPSBbXTsgfVxuXHRcdGxvY2FsZXNbbG9jYWxlTmFtZV0gPSBsb2NhbGVNYXA7XG5cdH1cblxuXHQvKipcblx0ICogU3dhcHMgdGhlIGN1cnJlbnQgbG9jYWxlLlxuXHQgKiBAcGFyYW0gIHtTdHJpbmd9XHRsb2NhbGVOYW1lXHRUaGUgbG9jYWxlIHRvIGFjdGl2YXRlLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9XG5cdCAqL1xuXHRmdW5jdGlvbiBnZXRTZXRMb2NhbGUobG9jYWxlTmFtZSkge1xuXG5cdFx0Ly9pZiBhIG5ldyBsb2NhbGUgaXMgZ2l2ZW4gdGhlbiBzZXQgaXRcblx0XHRpZihsb2NhbGVOYW1lKSB7XG5cdFx0XHRpZih0eXBlb2YgbG9jYWxlTmFtZSAhPT0gJ3N0cmluZycpIHsgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc2V0IGxvY2FsZS4gVGhlIGxvY2FsZSBuYW1lIG11c3QgYmUgYSBzdHJpbmcuJyk7IH1cblx0XHRcdGlmKCFsb2NhbGVzW2xvY2FsZU5hbWVdKSB7IHRocm93IG5ldyBFcnJvcignQ2Fubm90IHNldCBsb2NhbGUgdG8gJyArIGxvY2FsZU5hbWUgKyAnIGJlY2F1c2UgaXQgZG9lcyBub3QgZXhpc3QuIElmIHlvdSB3b3VsZCBsaWtlIHRvIHN1Ym1pdCBhICcgKyBsb2NhbGVOYW1lICsgJyBsb2NhbGUgbWFwIGZvciBLZXlib2FyZEpTIHBsZWFzZSBzdWJtaXQgaXQgYXQgaHR0cHM6Ly9naXRodWIuY29tL1JvYmVydFdIdXJzdC9LZXlib2FyZEpTL2lzc3Vlcy4nKTsgfVxuXG5cdFx0XHQvL3NldCB0aGUgY3VycmVudCBtYXAgYW5kIG1hY3Jvc1xuXHRcdFx0bWFwID0gbG9jYWxlc1tsb2NhbGVOYW1lXS5tYXA7XG5cdFx0XHRtYWNyb3MgPSBsb2NhbGVzW2xvY2FsZU5hbWVdLm1hY3JvcztcblxuXHRcdFx0Ly9zZXQgdGhlIGN1cnJlbnQgbG9jYWxlXG5cdFx0XHRsb2NhbGUgPSBsb2NhbGVOYW1lO1xuXHRcdH1cblxuXHRcdC8vcmV0dXJuIHRoZSBjdXJyZW50IGxvY2FsZVxuXHRcdHJldHVybiBsb2NhbGU7XG5cdH1cbn0pO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFdpdGhBZGRvbnMnKTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBBdXRvRm9jdXNNaXhpblxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGZvY3VzTm9kZSA9IHJlcXVpcmUoXCIuL2ZvY3VzTm9kZVwiKTtcblxudmFyIEF1dG9Gb2N1c01peGluID0ge1xuICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMucHJvcHMuYXV0b0ZvY3VzKSB7XG4gICAgICBmb2N1c05vZGUodGhpcy5nZXRET01Ob2RlKCkpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBdXRvRm9jdXNNaXhpbjtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQmVmb3JlSW5wdXRFdmVudFBsdWdpblxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZShcIi4vRXZlbnRDb25zdGFudHNcIik7XG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHJlcXVpcmUoXCIuL0V2ZW50UHJvcGFnYXRvcnNcIik7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKFwiLi9FeGVjdXRpb25FbnZpcm9ubWVudFwiKTtcbnZhciBTeW50aGV0aWNJbnB1dEV2ZW50ID0gcmVxdWlyZShcIi4vU3ludGhldGljSW5wdXRFdmVudFwiKTtcblxudmFyIGtleU9mID0gcmVxdWlyZShcIi4va2V5T2ZcIik7XG5cbnZhciBjYW5Vc2VUZXh0SW5wdXRFdmVudCA9IChcbiAgRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmXG4gICdUZXh0RXZlbnQnIGluIHdpbmRvdyAmJlxuICAhKCdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50IHx8IGlzUHJlc3RvKCkpXG4pO1xuXG4vKipcbiAqIE9wZXJhIDw9IDEyIGluY2x1ZGVzIFRleHRFdmVudCBpbiB3aW5kb3csIGJ1dCBkb2VzIG5vdCBmaXJlXG4gKiB0ZXh0IGlucHV0IGV2ZW50cy4gUmVseSBvbiBrZXlwcmVzcyBpbnN0ZWFkLlxuICovXG5mdW5jdGlvbiBpc1ByZXN0bygpIHtcbiAgdmFyIG9wZXJhID0gd2luZG93Lm9wZXJhO1xuICByZXR1cm4gKFxuICAgIHR5cGVvZiBvcGVyYSA9PT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2Ygb3BlcmEudmVyc2lvbiA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHBhcnNlSW50KG9wZXJhLnZlcnNpb24oKSwgMTApIDw9IDEyXG4gICk7XG59XG5cbnZhciBTUEFDRUJBUl9DT0RFID0gMzI7XG52YXIgU1BBQ0VCQVJfQ0hBUiA9IFN0cmluZy5mcm9tQ2hhckNvZGUoU1BBQ0VCQVJfQ09ERSk7XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcblxuLy8gRXZlbnRzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIHByb3BlcnR5IG5hbWVzLlxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIGJlZm9yZUlucHV0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHtvbkJlZm9yZUlucHV0OiBudWxsfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2Yoe29uQmVmb3JlSW5wdXRDYXB0dXJlOiBudWxsfSlcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW1xuICAgICAgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvbkVuZCxcbiAgICAgIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3MsXG4gICAgICB0b3BMZXZlbFR5cGVzLnRvcFRleHRJbnB1dCxcbiAgICAgIHRvcExldmVsVHlwZXMudG9wUGFzdGVcbiAgICBdXG4gIH1cbn07XG5cbi8vIFRyYWNrIGNoYXJhY3RlcnMgaW5zZXJ0ZWQgdmlhIGtleXByZXNzIGFuZCBjb21wb3NpdGlvbiBldmVudHMuXG52YXIgZmFsbGJhY2tDaGFycyA9IG51bGw7XG5cbi8qKlxuICogUmV0dXJuIHdoZXRoZXIgYSBuYXRpdmUga2V5cHJlc3MgZXZlbnQgaXMgYXNzdW1lZCB0byBiZSBhIGNvbW1hbmQuXG4gKiBUaGlzIGlzIHJlcXVpcmVkIGJlY2F1c2UgRmlyZWZveCBmaXJlcyBga2V5cHJlc3NgIGV2ZW50cyBmb3Iga2V5IGNvbW1hbmRzXG4gKiAoY3V0LCBjb3B5LCBzZWxlY3QtYWxsLCBldGMuKSBldmVuIHRob3VnaCBubyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiAoXG4gICAgKG5hdGl2ZUV2ZW50LmN0cmxLZXkgfHwgbmF0aXZlRXZlbnQuYWx0S2V5IHx8IG5hdGl2ZUV2ZW50Lm1ldGFLZXkpICYmXG4gICAgLy8gY3RybEtleSAmJiBhbHRLZXkgaXMgZXF1aXZhbGVudCB0byBBbHRHciwgYW5kIGlzIG5vdCBhIGNvbW1hbmQuXG4gICAgIShuYXRpdmVFdmVudC5jdHJsS2V5ICYmIG5hdGl2ZUV2ZW50LmFsdEtleSlcbiAgKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gYG9uQmVmb3JlSW5wdXRgIGV2ZW50IHRvIG1hdGNoXG4gKiBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDEzMTEwNS8jZXZlbnRzLWlucHV0ZXZlbnRzLlxuICpcbiAqIFRoaXMgZXZlbnQgcGx1Z2luIGlzIGJhc2VkIG9uIHRoZSBuYXRpdmUgYHRleHRJbnB1dGAgZXZlbnRcbiAqIGF2YWlsYWJsZSBpbiBDaHJvbWUsIFNhZmFyaSwgT3BlcmEsIGFuZCBJRS4gVGhpcyBldmVudCBmaXJlcyBhZnRlclxuICogYG9uS2V5UHJlc3NgIGFuZCBgb25Db21wb3NpdGlvbkVuZGAsIGJ1dCBiZWZvcmUgYG9uSW5wdXRgLlxuICpcbiAqIGBiZWZvcmVJbnB1dGAgaXMgc3BlYydkIGJ1dCBub3QgaW1wbGVtZW50ZWQgaW4gYW55IGJyb3dzZXJzLCBhbmRcbiAqIHRoZSBgaW5wdXRgIGV2ZW50IGRvZXMgbm90IHByb3ZpZGUgYW55IHVzZWZ1bCBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGhhc1xuICogYWN0dWFsbHkgYmVlbiBhZGRlZCwgY29udHJhcnkgdG8gdGhlIHNwZWMuIFRodXMsIGB0ZXh0SW5wdXRgIGlzIHRoZSBiZXN0XG4gKiBhdmFpbGFibGUgZXZlbnQgdG8gaWRlbnRpZnkgdGhlIGNoYXJhY3RlcnMgdGhhdCBoYXZlIGFjdHVhbGx5IGJlZW4gaW5zZXJ0ZWRcbiAqIGludG8gdGhlIHRhcmdldCBub2RlLlxuICovXG52YXIgQmVmb3JlSW5wdXRFdmVudFBsdWdpbiA9IHtcblxuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRvcExldmVsVGFyZ2V0IFRoZSBsaXN0ZW5pbmcgY29tcG9uZW50IHJvb3Qgbm9kZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVGFyZ2V0SUQgSUQgb2YgYHRvcExldmVsVGFyZ2V0YC5cbiAgICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICAgKiBAcmV0dXJuIHsqfSBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAgICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuZXh0cmFjdEV2ZW50c31cbiAgICovXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uKFxuICAgICAgdG9wTGV2ZWxUeXBlLFxuICAgICAgdG9wTGV2ZWxUYXJnZXQsXG4gICAgICB0b3BMZXZlbFRhcmdldElELFxuICAgICAgbmF0aXZlRXZlbnQpIHtcblxuICAgIHZhciBjaGFycztcblxuICAgIGlmIChjYW5Vc2VUZXh0SW5wdXRFdmVudCkge1xuICAgICAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleVByZXNzOlxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIElmIG5hdGl2ZSBgdGV4dElucHV0YCBldmVudHMgYXJlIGF2YWlsYWJsZSwgb3VyIGdvYWwgaXMgdG8gbWFrZVxuICAgICAgICAgICAqIHVzZSBvZiB0aGVtLiBIb3dldmVyLCB0aGVyZSBpcyBhIHNwZWNpYWwgY2FzZTogdGhlIHNwYWNlYmFyIGtleS5cbiAgICAgICAgICAgKiBJbiBXZWJraXQsIHByZXZlbnRpbmcgZGVmYXVsdCBvbiBhIHNwYWNlYmFyIGB0ZXh0SW5wdXRgIGV2ZW50XG4gICAgICAgICAgICogY2FuY2VscyBjaGFyYWN0ZXIgaW5zZXJ0aW9uLCBidXQgaXQgKmFsc28qIGNhdXNlcyB0aGUgYnJvd3NlclxuICAgICAgICAgICAqIHRvIGZhbGwgYmFjayB0byBpdHMgZGVmYXVsdCBzcGFjZWJhciBiZWhhdmlvciBvZiBzY3JvbGxpbmcgdGhlXG4gICAgICAgICAgICogcGFnZS5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIFRyYWNraW5nIGF0OlxuICAgICAgICAgICAqIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNTUxMDNcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIFRvIGF2b2lkIHRoaXMgaXNzdWUsIHVzZSB0aGUga2V5cHJlc3MgZXZlbnQgYXMgaWYgbm8gYHRleHRJbnB1dGBcbiAgICAgICAgICAgKiBldmVudCBpcyBhdmFpbGFibGUuXG4gICAgICAgICAgICovXG4gICAgICAgICAgdmFyIHdoaWNoID0gbmF0aXZlRXZlbnQud2hpY2g7XG4gICAgICAgICAgaWYgKHdoaWNoICE9PSBTUEFDRUJBUl9DT0RFKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2hhcnMgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHdoaWNoKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVGV4dElucHV0OlxuICAgICAgICAgIC8vIFJlY29yZCB0aGUgY2hhcmFjdGVycyB0byBiZSBhZGRlZCB0byB0aGUgRE9NLlxuICAgICAgICAgIGNoYXJzID0gbmF0aXZlRXZlbnQuZGF0YTtcblxuICAgICAgICAgIC8vIElmIGl0J3MgYSBzcGFjZWJhciBjaGFyYWN0ZXIsIGFzc3VtZSB0aGF0IHdlIGhhdmUgYWxyZWFkeSBoYW5kbGVkXG4gICAgICAgICAgLy8gaXQgYXQgdGhlIGtleXByZXNzIGxldmVsIGFuZCBiYWlsIGltbWVkaWF0ZWx5LlxuICAgICAgICAgIGlmIChjaGFycyA9PT0gU1BBQ0VCQVJfQ0hBUikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIE90aGVyd2lzZSwgY2Fycnkgb24uXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyBGb3Igb3RoZXIgbmF0aXZlIGV2ZW50IHR5cGVzLCBkbyBub3RoaW5nLlxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFBhc3RlOlxuICAgICAgICAgIC8vIElmIGEgcGFzdGUgZXZlbnQgb2NjdXJzIGFmdGVyIGEga2V5cHJlc3MsIHRocm93IG91dCB0aGUgaW5wdXRcbiAgICAgICAgICAvLyBjaGFycy4gUGFzdGUgZXZlbnRzIHNob3VsZCBub3QgbGVhZCB0byBCZWZvcmVJbnB1dCBldmVudHMuXG4gICAgICAgICAgZmFsbGJhY2tDaGFycyA9IG51bGw7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzczpcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBBcyBvZiB2MjcsIEZpcmVmb3ggbWF5IGZpcmUga2V5cHJlc3MgZXZlbnRzIGV2ZW4gd2hlbiBubyBjaGFyYWN0ZXJcbiAgICAgICAgICAgKiB3aWxsIGJlIGluc2VydGVkLiBBIGZldyBwb3NzaWJpbGl0aWVzOlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogLSBgd2hpY2hgIGlzIGAwYC4gQXJyb3cga2V5cywgRXNjIGtleSwgZXRjLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogLSBgd2hpY2hgIGlzIHRoZSBwcmVzc2VkIGtleSBjb2RlLCBidXQgbm8gY2hhciBpcyBhdmFpbGFibGUuXG4gICAgICAgICAgICogICBFeDogJ0FsdEdyICsgZGAgaW4gUG9saXNoLiBUaGVyZSBpcyBubyBtb2RpZmllZCBjaGFyYWN0ZXIgZm9yXG4gICAgICAgICAgICogICB0aGlzIGtleSBjb21iaW5hdGlvbiBhbmQgbm8gY2hhcmFjdGVyIGlzIGluc2VydGVkIGludG8gdGhlXG4gICAgICAgICAgICogICBkb2N1bWVudCwgYnV0IEZGIGZpcmVzIHRoZSBrZXlwcmVzcyBmb3IgY2hhciBjb2RlIGAxMDBgIGFueXdheS5cbiAgICAgICAgICAgKiAgIE5vIGBpbnB1dGAgZXZlbnQgd2lsbCBvY2N1ci5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIC0gYHdoaWNoYCBpcyB0aGUgcHJlc3NlZCBrZXkgY29kZSwgYnV0IGEgY29tbWFuZCBjb21iaW5hdGlvbiBpc1xuICAgICAgICAgICAqICAgYmVpbmcgdXNlZC4gRXg6IGBDbWQrQ2AuIE5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZCwgYW5kIG5vXG4gICAgICAgICAgICogICBgaW5wdXRgIGV2ZW50IHdpbGwgb2NjdXIuXG4gICAgICAgICAgICovXG4gICAgICAgICAgaWYgKG5hdGl2ZUV2ZW50LndoaWNoICYmICFpc0tleXByZXNzQ29tbWFuZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICAgIGZhbGxiYWNrQ2hhcnMgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5hdGl2ZUV2ZW50LndoaWNoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvbkVuZDpcbiAgICAgICAgICBmYWxsYmFja0NoYXJzID0gbmF0aXZlRXZlbnQuZGF0YTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gSWYgbm8gY2hhbmdlcyBoYXZlIG9jY3VycmVkIHRvIHRoZSBmYWxsYmFjayBzdHJpbmcsIG5vIHJlbGV2YW50XG4gICAgICAvLyBldmVudCBoYXMgZmlyZWQgYW5kIHdlJ3JlIGRvbmUuXG4gICAgICBpZiAoZmFsbGJhY2tDaGFycyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNoYXJzID0gZmFsbGJhY2tDaGFycztcbiAgICB9XG5cbiAgICAvLyBJZiBubyBjaGFyYWN0ZXJzIGFyZSBiZWluZyBpbnNlcnRlZCwgbm8gQmVmb3JlSW5wdXQgZXZlbnQgc2hvdWxkXG4gICAgLy8gYmUgZmlyZWQuXG4gICAgaWYgKCFjaGFycykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBldmVudCA9IFN5bnRoZXRpY0lucHV0RXZlbnQuZ2V0UG9vbGVkKFxuICAgICAgZXZlbnRUeXBlcy5iZWZvcmVJbnB1dCxcbiAgICAgIHRvcExldmVsVGFyZ2V0SUQsXG4gICAgICBuYXRpdmVFdmVudFxuICAgICk7XG5cbiAgICBldmVudC5kYXRhID0gY2hhcnM7XG4gICAgZmFsbGJhY2tDaGFycyA9IG51bGw7XG4gICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmVmb3JlSW5wdXRFdmVudFBsdWdpbjtcbiIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQ1NTQ29yZVxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xuXG4vKipcbiAqIFRoZSBDU1NDb3JlIG1vZHVsZSBzcGVjaWZpZXMgdGhlIEFQSSAoYW5kIGltcGxlbWVudHMgbW9zdCBvZiB0aGUgbWV0aG9kcylcbiAqIHRoYXQgc2hvdWxkIGJlIHVzZWQgd2hlbiBkZWFsaW5nIHdpdGggdGhlIGRpc3BsYXkgb2YgZWxlbWVudHMgKHZpYSB0aGVpclxuICogQ1NTIGNsYXNzZXMgYW5kIHZpc2liaWxpdHkgb24gc2NyZWVuLiBJdCBpcyBhbiBBUEkgZm9jdXNlZCBvbiBtdXRhdGluZyB0aGVcbiAqIGRpc3BsYXkgYW5kIG5vdCByZWFkaW5nIGl0IGFzIG5vIGxvZ2ljYWwgc3RhdGUgc2hvdWxkIGJlIGVuY29kZWQgaW4gdGhlXG4gKiBkaXNwbGF5IG9mIGVsZW1lbnRzLlxuICovXG5cbnZhciBDU1NDb3JlID0ge1xuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSBjbGFzcyBwYXNzZWQgaW4gdG8gdGhlIGVsZW1lbnQgaWYgaXQgZG9lc24ndCBhbHJlYWR5IGhhdmUgaXQuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gZWxlbWVudCB0aGUgZWxlbWVudCB0byBzZXQgdGhlIGNsYXNzIG9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgdGhlIENTUyBjbGFzc05hbWVcbiAgICogQHJldHVybiB7RE9NRWxlbWVudH0gdGhlIGVsZW1lbnQgcGFzc2VkIGluXG4gICAqL1xuICBhZGRDbGFzczogZnVuY3Rpb24oZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICEvXFxzLy50ZXN0KGNsYXNzTmFtZSksXG4gICAgICAnQ1NTQ29yZS5hZGRDbGFzcyB0YWtlcyBvbmx5IGEgc2luZ2xlIGNsYXNzIG5hbWUuIFwiJXNcIiBjb250YWlucyAnICtcbiAgICAgICdtdWx0aXBsZSBjbGFzc2VzLicsIGNsYXNzTmFtZVxuICAgICkgOiBpbnZhcmlhbnQoIS9cXHMvLnRlc3QoY2xhc3NOYW1lKSkpO1xuXG4gICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0KSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuICAgICAgfSBlbHNlIGlmICghQ1NTQ29yZS5oYXNDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpKSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc05hbWUgKyAnICcgKyBjbGFzc05hbWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBjbGFzcyBwYXNzZWQgaW4gZnJvbSB0aGUgZWxlbWVudFxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGVsZW1lbnQgdGhlIGVsZW1lbnQgdG8gc2V0IHRoZSBjbGFzcyBvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIHRoZSBDU1MgY2xhc3NOYW1lXG4gICAqIEByZXR1cm4ge0RPTUVsZW1lbnR9IHRoZSBlbGVtZW50IHBhc3NlZCBpblxuICAgKi9cbiAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAhL1xccy8udGVzdChjbGFzc05hbWUpLFxuICAgICAgJ0NTU0NvcmUucmVtb3ZlQ2xhc3MgdGFrZXMgb25seSBhIHNpbmdsZSBjbGFzcyBuYW1lLiBcIiVzXCIgY29udGFpbnMgJyArXG4gICAgICAnbXVsdGlwbGUgY2xhc3Nlcy4nLCBjbGFzc05hbWVcbiAgICApIDogaW52YXJpYW50KCEvXFxzLy50ZXN0KGNsYXNzTmFtZSkpKTtcblxuICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgICAgIH0gZWxzZSBpZiAoQ1NTQ29yZS5oYXNDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpKSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc05hbWVcbiAgICAgICAgICAucmVwbGFjZShuZXcgUmVnRXhwKCcoXnxcXFxccyknICsgY2xhc3NOYW1lICsgJyg/OlxcXFxzfCQpJywgJ2cnKSwgJyQxJylcbiAgICAgICAgICAucmVwbGFjZSgvXFxzKy9nLCAnICcpIC8vIG11bHRpcGxlIHNwYWNlcyB0byBvbmVcbiAgICAgICAgICAucmVwbGFjZSgvXlxccyp8XFxzKiQvZywgJycpOyAvLyB0cmltIHRoZSBlbmRzXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBIZWxwZXIgdG8gYWRkIG9yIHJlbW92ZSBhIGNsYXNzIGZyb20gYW4gZWxlbWVudCBiYXNlZCBvbiBhIGNvbmRpdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBlbGVtZW50IHRoZSBlbGVtZW50IHRvIHNldCB0aGUgY2xhc3Mgb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSB0aGUgQ1NTIGNsYXNzTmFtZVxuICAgKiBAcGFyYW0geyp9IGJvb2wgY29uZGl0aW9uIHRvIHdoZXRoZXIgdG8gYWRkIG9yIHJlbW92ZSB0aGUgY2xhc3NcbiAgICogQHJldHVybiB7RE9NRWxlbWVudH0gdGhlIGVsZW1lbnQgcGFzc2VkIGluXG4gICAqL1xuICBjb25kaXRpb25DbGFzczogZnVuY3Rpb24oZWxlbWVudCwgY2xhc3NOYW1lLCBib29sKSB7XG4gICAgcmV0dXJuIChib29sID8gQ1NTQ29yZS5hZGRDbGFzcyA6IENTU0NvcmUucmVtb3ZlQ2xhc3MpKGVsZW1lbnQsIGNsYXNzTmFtZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRlc3RzIHdoZXRoZXIgdGhlIGVsZW1lbnQgaGFzIHRoZSBjbGFzcyBzcGVjaWZpZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NTm9kZXxET01XaW5kb3d9IGVsZW1lbnQgdGhlIGVsZW1lbnQgdG8gc2V0IHRoZSBjbGFzcyBvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIHRoZSBDU1MgY2xhc3NOYW1lXG4gICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBlbGVtZW50IGhhcyB0aGUgY2xhc3MsIGZhbHNlIGlmIG5vdFxuICAgKi9cbiAgaGFzQ2xhc3M6IGZ1bmN0aW9uKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAhL1xccy8udGVzdChjbGFzc05hbWUpLFxuICAgICAgJ0NTUy5oYXNDbGFzcyB0YWtlcyBvbmx5IGEgc2luZ2xlIGNsYXNzIG5hbWUuJ1xuICAgICkgOiBpbnZhcmlhbnQoIS9cXHMvLnRlc3QoY2xhc3NOYW1lKSkpO1xuICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xuICAgICAgcmV0dXJuICEhY2xhc3NOYW1lICYmIGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiAoJyAnICsgZWxlbWVudC5jbGFzc05hbWUgKyAnICcpLmluZGV4T2YoJyAnICsgY2xhc3NOYW1lICsgJyAnKSA+IC0xO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ1NTQ29yZTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIENTU1Byb3BlcnR5XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ1NTIHByb3BlcnRpZXMgd2hpY2ggYWNjZXB0IG51bWJlcnMgYnV0IGFyZSBub3QgaW4gdW5pdHMgb2YgXCJweFwiLlxuICovXG52YXIgaXNVbml0bGVzc051bWJlciA9IHtcbiAgY29sdW1uQ291bnQ6IHRydWUsXG4gIGZpbGxPcGFjaXR5OiB0cnVlLFxuICBmbGV4OiB0cnVlLFxuICBmbGV4R3JvdzogdHJ1ZSxcbiAgZmxleFNocmluazogdHJ1ZSxcbiAgZm9udFdlaWdodDogdHJ1ZSxcbiAgbGluZUNsYW1wOiB0cnVlLFxuICBsaW5lSGVpZ2h0OiB0cnVlLFxuICBvcGFjaXR5OiB0cnVlLFxuICBvcmRlcjogdHJ1ZSxcbiAgb3JwaGFuczogdHJ1ZSxcbiAgd2lkb3dzOiB0cnVlLFxuICB6SW5kZXg6IHRydWUsXG4gIHpvb206IHRydWVcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCB2ZW5kb3Itc3BlY2lmaWMgcHJlZml4LCBlZzogV2Via2l0XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHN0eWxlIG5hbWUsIGVnOiB0cmFuc2l0aW9uRHVyYXRpb25cbiAqIEByZXR1cm4ge3N0cmluZ30gc3R5bGUgbmFtZSBwcmVmaXhlZCB3aXRoIGBwcmVmaXhgLCBwcm9wZXJseSBjYW1lbENhc2VkLCBlZzpcbiAqIFdlYmtpdFRyYW5zaXRpb25EdXJhdGlvblxuICovXG5mdW5jdGlvbiBwcmVmaXhLZXkocHJlZml4LCBrZXkpIHtcbiAgcmV0dXJuIHByZWZpeCArIGtleS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGtleS5zdWJzdHJpbmcoMSk7XG59XG5cbi8qKlxuICogU3VwcG9ydCBzdHlsZSBuYW1lcyB0aGF0IG1heSBjb21lIHBhc3NlZCBpbiBwcmVmaXhlZCBieSBhZGRpbmcgcGVybXV0YXRpb25zXG4gKiBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi9cbnZhciBwcmVmaXhlcyA9IFsnV2Via2l0JywgJ21zJywgJ01veicsICdPJ107XG5cbi8vIFVzaW5nIE9iamVjdC5rZXlzIGhlcmUsIG9yIGVsc2UgdGhlIHZhbmlsbGEgZm9yLWluIGxvb3AgbWFrZXMgSUU4IGdvIGludG8gYW5cbi8vIGluZmluaXRlIGxvb3AsIGJlY2F1c2UgaXQgaXRlcmF0ZXMgb3ZlciB0aGUgbmV3bHkgYWRkZWQgcHJvcHMgdG9vLlxuT2JqZWN0LmtleXMoaXNVbml0bGVzc051bWJlcikuZm9yRWFjaChmdW5jdGlvbihwcm9wKSB7XG4gIHByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24ocHJlZml4KSB7XG4gICAgaXNVbml0bGVzc051bWJlcltwcmVmaXhLZXkocHJlZml4LCBwcm9wKV0gPSBpc1VuaXRsZXNzTnVtYmVyW3Byb3BdO1xuICB9KTtcbn0pO1xuXG4vKipcbiAqIE1vc3Qgc3R5bGUgcHJvcGVydGllcyBjYW4gYmUgdW5zZXQgYnkgZG9pbmcgLnN0eWxlW3Byb3BdID0gJycgYnV0IElFOFxuICogZG9lc24ndCBsaWtlIGRvaW5nIHRoYXQgd2l0aCBzaG9ydGhhbmQgcHJvcGVydGllcyBzbyBmb3IgdGhlIHByb3BlcnRpZXMgdGhhdFxuICogSUU4IGJyZWFrcyBvbiwgd2hpY2ggYXJlIGxpc3RlZCBoZXJlLCB3ZSBpbnN0ZWFkIHVuc2V0IGVhY2ggb2YgdGhlXG4gKiBpbmRpdmlkdWFsIHByb3BlcnRpZXMuIFNlZSBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjM4NS5cbiAqIFRoZSA0LXZhbHVlICdjbG9jaycgcHJvcGVydGllcyBsaWtlIG1hcmdpbiwgcGFkZGluZywgYm9yZGVyLXdpZHRoIHNlZW0gdG9cbiAqIGJlaGF2ZSB3aXRob3V0IGFueSBwcm9ibGVtcy4gQ3VyaW91c2x5LCBsaXN0LXN0eWxlIHdvcmtzIHRvbyB3aXRob3V0IGFueVxuICogc3BlY2lhbCBwcm9kZGluZy5cbiAqL1xudmFyIHNob3J0aGFuZFByb3BlcnR5RXhwYW5zaW9ucyA9IHtcbiAgYmFja2dyb3VuZDoge1xuICAgIGJhY2tncm91bmRJbWFnZTogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kUG9zaXRpb246IHRydWUsXG4gICAgYmFja2dyb3VuZFJlcGVhdDogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IHRydWVcbiAgfSxcbiAgYm9yZGVyOiB7XG4gICAgYm9yZGVyV2lkdGg6IHRydWUsXG4gICAgYm9yZGVyU3R5bGU6IHRydWUsXG4gICAgYm9yZGVyQ29sb3I6IHRydWVcbiAgfSxcbiAgYm9yZGVyQm90dG9tOiB7XG4gICAgYm9yZGVyQm90dG9tV2lkdGg6IHRydWUsXG4gICAgYm9yZGVyQm90dG9tU3R5bGU6IHRydWUsXG4gICAgYm9yZGVyQm90dG9tQ29sb3I6IHRydWVcbiAgfSxcbiAgYm9yZGVyTGVmdDoge1xuICAgIGJvcmRlckxlZnRXaWR0aDogdHJ1ZSxcbiAgICBib3JkZXJMZWZ0U3R5bGU6IHRydWUsXG4gICAgYm9yZGVyTGVmdENvbG9yOiB0cnVlXG4gIH0sXG4gIGJvcmRlclJpZ2h0OiB7XG4gICAgYm9yZGVyUmlnaHRXaWR0aDogdHJ1ZSxcbiAgICBib3JkZXJSaWdodFN0eWxlOiB0cnVlLFxuICAgIGJvcmRlclJpZ2h0Q29sb3I6IHRydWVcbiAgfSxcbiAgYm9yZGVyVG9wOiB7XG4gICAgYm9yZGVyVG9wV2lkdGg6IHRydWUsXG4gICAgYm9yZGVyVG9wU3R5bGU6IHRydWUsXG4gICAgYm9yZGVyVG9wQ29sb3I6IHRydWVcbiAgfSxcbiAgZm9udDoge1xuICAgIGZvbnRTdHlsZTogdHJ1ZSxcbiAgICBmb250VmFyaWFudDogdHJ1ZSxcbiAgICBmb250V2VpZ2h0OiB0cnVlLFxuICAgIGZvbnRTaXplOiB0cnVlLFxuICAgIGxpbmVIZWlnaHQ6IHRydWUsXG4gICAgZm9udEZhbWlseTogdHJ1ZVxuICB9XG59O1xuXG52YXIgQ1NTUHJvcGVydHkgPSB7XG4gIGlzVW5pdGxlc3NOdW1iZXI6IGlzVW5pdGxlc3NOdW1iZXIsXG4gIHNob3J0aGFuZFByb3BlcnR5RXhwYW5zaW9uczogc2hvcnRoYW5kUHJvcGVydHlFeHBhbnNpb25zXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENTU1Byb3BlcnR5O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIENTU1Byb3BlcnR5T3BlcmF0aW9uc1xuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIENTU1Byb3BlcnR5ID0gcmVxdWlyZShcIi4vQ1NTUHJvcGVydHlcIik7XG5cbnZhciBkYW5nZXJvdXNTdHlsZVZhbHVlID0gcmVxdWlyZShcIi4vZGFuZ2Vyb3VzU3R5bGVWYWx1ZVwiKTtcbnZhciBoeXBoZW5hdGVTdHlsZU5hbWUgPSByZXF1aXJlKFwiLi9oeXBoZW5hdGVTdHlsZU5hbWVcIik7XG52YXIgbWVtb2l6ZVN0cmluZ09ubHkgPSByZXF1aXJlKFwiLi9tZW1vaXplU3RyaW5nT25seVwiKTtcblxudmFyIHByb2Nlc3NTdHlsZU5hbWUgPSBtZW1vaXplU3RyaW5nT25seShmdW5jdGlvbihzdHlsZU5hbWUpIHtcbiAgcmV0dXJuIGh5cGhlbmF0ZVN0eWxlTmFtZShzdHlsZU5hbWUpO1xufSk7XG5cbi8qKlxuICogT3BlcmF0aW9ucyBmb3IgZGVhbGluZyB3aXRoIENTUyBwcm9wZXJ0aWVzLlxuICovXG52YXIgQ1NTUHJvcGVydHlPcGVyYXRpb25zID0ge1xuXG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIGEgbWFwcGluZyBvZiBzdHlsZSBwcm9wZXJ0aWVzIGZvciB1c2UgYXMgaW5saW5lIHN0eWxlczpcbiAgICpcbiAgICogICA+IGNyZWF0ZU1hcmt1cEZvclN0eWxlcyh7d2lkdGg6ICcyMDBweCcsIGhlaWdodDogMH0pXG4gICAqICAgXCJ3aWR0aDoyMDBweDtoZWlnaHQ6MDtcIlxuICAgKlxuICAgKiBVbmRlZmluZWQgdmFsdWVzIGFyZSBpZ25vcmVkIHNvIHRoYXQgZGVjbGFyYXRpdmUgcHJvZ3JhbW1pbmcgaXMgZWFzaWVyLlxuICAgKiBUaGUgcmVzdWx0IHNob3VsZCBiZSBIVE1MLWVzY2FwZWQgYmVmb3JlIGluc2VydGlvbiBpbnRvIHRoZSBET00uXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzdHlsZXNcbiAgICogQHJldHVybiB7P3N0cmluZ31cbiAgICovXG4gIGNyZWF0ZU1hcmt1cEZvclN0eWxlczogZnVuY3Rpb24oc3R5bGVzKSB7XG4gICAgdmFyIHNlcmlhbGl6ZWQgPSAnJztcbiAgICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICBpZiAoIXN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHN0eWxlVmFsdWUgPSBzdHlsZXNbc3R5bGVOYW1lXTtcbiAgICAgIGlmIChzdHlsZVZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgc2VyaWFsaXplZCArPSBwcm9jZXNzU3R5bGVOYW1lKHN0eWxlTmFtZSkgKyAnOic7XG4gICAgICAgIHNlcmlhbGl6ZWQgKz0gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShzdHlsZU5hbWUsIHN0eWxlVmFsdWUpICsgJzsnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZCB8fCBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2YWx1ZSBmb3IgbXVsdGlwbGUgc3R5bGVzIG9uIGEgbm9kZS4gIElmIGEgdmFsdWUgaXMgc3BlY2lmaWVkIGFzXG4gICAqICcnIChlbXB0eSBzdHJpbmcpLCB0aGUgY29ycmVzcG9uZGluZyBzdHlsZSBwcm9wZXJ0eSB3aWxsIGJlIHVuc2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAgICogQHBhcmFtIHtvYmplY3R9IHN0eWxlc1xuICAgKi9cbiAgc2V0VmFsdWVGb3JTdHlsZXM6IGZ1bmN0aW9uKG5vZGUsIHN0eWxlcykge1xuICAgIHZhciBzdHlsZSA9IG5vZGUuc3R5bGU7XG4gICAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgICAgaWYgKCFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBzdHlsZVZhbHVlID0gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShzdHlsZU5hbWUsIHN0eWxlc1tzdHlsZU5hbWVdKTtcbiAgICAgIGlmIChzdHlsZVZhbHVlKSB7XG4gICAgICAgIHN0eWxlW3N0eWxlTmFtZV0gPSBzdHlsZVZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGV4cGFuc2lvbiA9IENTU1Byb3BlcnR5LnNob3J0aGFuZFByb3BlcnR5RXhwYW5zaW9uc1tzdHlsZU5hbWVdO1xuICAgICAgICBpZiAoZXhwYW5zaW9uKSB7XG4gICAgICAgICAgLy8gU2hvcnRoYW5kIHByb3BlcnR5IHRoYXQgSUU4IHdvbid0IGxpa2UgdW5zZXR0aW5nLCBzbyB1bnNldCBlYWNoXG4gICAgICAgICAgLy8gY29tcG9uZW50IHRvIHBsYWNhdGUgaXRcbiAgICAgICAgICBmb3IgKHZhciBpbmRpdmlkdWFsU3R5bGVOYW1lIGluIGV4cGFuc2lvbikge1xuICAgICAgICAgICAgc3R5bGVbaW5kaXZpZHVhbFN0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3R5bGVbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ1NTUHJvcGVydHlPcGVyYXRpb25zO1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBDYWxsYmFja1F1ZXVlXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoXCIuL1Bvb2xlZENsYXNzXCIpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xudmFyIG1peEludG8gPSByZXF1aXJlKFwiLi9taXhJbnRvXCIpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgcHNldWRvLWV2ZW50IG1vZHVsZSB0byBoZWxwIGtlZXAgdHJhY2sgb2YgY29tcG9uZW50cyB3YWl0aW5nIHRvXG4gKiBiZSBub3RpZmllZCB3aGVuIHRoZWlyIERPTSByZXByZXNlbnRhdGlvbnMgYXJlIGF2YWlsYWJsZSBmb3IgdXNlLlxuICpcbiAqIFRoaXMgaW1wbGVtZW50cyBgUG9vbGVkQ2xhc3NgLCBzbyB5b3Ugc2hvdWxkIG5ldmVyIG5lZWQgdG8gaW5zdGFudGlhdGUgdGhpcy5cbiAqIEluc3RlYWQsIHVzZSBgQ2FsbGJhY2tRdWV1ZS5nZXRQb29sZWQoKWAuXG4gKlxuICogQGNsYXNzIFJlYWN0TW91bnRSZWFkeVxuICogQGltcGxlbWVudHMgUG9vbGVkQ2xhc3NcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBDYWxsYmFja1F1ZXVlKCkge1xuICB0aGlzLl9jYWxsYmFja3MgPSBudWxsO1xuICB0aGlzLl9jb250ZXh0cyA9IG51bGw7XG59XG5cbm1peEludG8oQ2FsbGJhY2tRdWV1ZSwge1xuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbiBgbm90aWZ5QWxsYCBpcyBpbnZva2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBJbnZva2VkIHdoZW4gYG5vdGlmeUFsbGAgaXMgaW52b2tlZC5cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBjb250ZXh0IENvbnRleHQgdG8gY2FsbCBgY2FsbGJhY2tgIHdpdGguXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZTogZnVuY3Rpb24oY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwgW107XG4gICAgdGhpcy5fY29udGV4dHMgPSB0aGlzLl9jb250ZXh0cyB8fCBbXTtcbiAgICB0aGlzLl9jYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgdGhpcy5fY29udGV4dHMucHVzaChjb250ZXh0KTtcbiAgfSxcblxuICAvKipcbiAgICogSW52b2tlcyBhbGwgZW5xdWV1ZWQgY2FsbGJhY2tzIGFuZCBjbGVhcnMgdGhlIHF1ZXVlLiBUaGlzIGlzIGludm9rZWQgYWZ0ZXJcbiAgICogdGhlIERPTSByZXByZXNlbnRhdGlvbiBvZiBhIGNvbXBvbmVudCBoYXMgYmVlbiBjcmVhdGVkIG9yIHVwZGF0ZWQuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgbm90aWZ5QWxsOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzO1xuICAgIHZhciBjb250ZXh0cyA9IHRoaXMuX2NvbnRleHRzO1xuICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAgIGNhbGxiYWNrcy5sZW5ndGggPT09IGNvbnRleHRzLmxlbmd0aCxcbiAgICAgICAgXCJNaXNtYXRjaGVkIGxpc3Qgb2YgY29udGV4dHMgaW4gY2FsbGJhY2sgcXVldWVcIlxuICAgICAgKSA6IGludmFyaWFudChjYWxsYmFja3MubGVuZ3RoID09PSBjb250ZXh0cy5sZW5ndGgpKTtcbiAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IG51bGw7XG4gICAgICB0aGlzLl9jb250ZXh0cyA9IG51bGw7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY2FsbGJhY2tzW2ldLmNhbGwoY29udGV4dHNbaV0pO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgICBjb250ZXh0cy5sZW5ndGggPSAwO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVzZXRzIHRoZSBpbnRlcm5hbCBxdWV1ZS5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0gbnVsbDtcbiAgICB0aGlzLl9jb250ZXh0cyA9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGBQb29sZWRDbGFzc2AgbG9va3MgZm9yIHRoaXMuXG4gICAqL1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cblxufSk7XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhDYWxsYmFja1F1ZXVlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYWxsYmFja1F1ZXVlO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQ2hhbmdlRXZlbnRQbHVnaW5cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZShcIi4vRXZlbnRDb25zdGFudHNcIik7XG52YXIgRXZlbnRQbHVnaW5IdWIgPSByZXF1aXJlKFwiLi9FdmVudFBsdWdpbkh1YlwiKTtcbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZShcIi4vRXZlbnRQcm9wYWdhdG9yc1wiKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoXCIuL0V4ZWN1dGlvbkVudmlyb25tZW50XCIpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoXCIuL1JlYWN0VXBkYXRlc1wiKTtcbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoXCIuL1N5bnRoZXRpY0V2ZW50XCIpO1xuXG52YXIgaXNFdmVudFN1cHBvcnRlZCA9IHJlcXVpcmUoXCIuL2lzRXZlbnRTdXBwb3J0ZWRcIik7XG52YXIgaXNUZXh0SW5wdXRFbGVtZW50ID0gcmVxdWlyZShcIi4vaXNUZXh0SW5wdXRFbGVtZW50XCIpO1xudmFyIGtleU9mID0gcmVxdWlyZShcIi4va2V5T2ZcIik7XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcblxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIGNoYW5nZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7b25DaGFuZ2U6IG51bGx9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7b25DaGFuZ2VDYXB0dXJlOiBudWxsfSlcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW1xuICAgICAgdG9wTGV2ZWxUeXBlcy50b3BCbHVyLFxuICAgICAgdG9wTGV2ZWxUeXBlcy50b3BDaGFuZ2UsXG4gICAgICB0b3BMZXZlbFR5cGVzLnRvcENsaWNrLFxuICAgICAgdG9wTGV2ZWxUeXBlcy50b3BGb2N1cyxcbiAgICAgIHRvcExldmVsVHlwZXMudG9wSW5wdXQsXG4gICAgICB0b3BMZXZlbFR5cGVzLnRvcEtleURvd24sXG4gICAgICB0b3BMZXZlbFR5cGVzLnRvcEtleVVwLFxuICAgICAgdG9wTGV2ZWxUeXBlcy50b3BTZWxlY3Rpb25DaGFuZ2VcbiAgICBdXG4gIH1cbn07XG5cbi8qKlxuICogRm9yIElFIHNoaW1zXG4gKi9cbnZhciBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50SUQgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9IG51bGw7XG52YXIgYWN0aXZlRWxlbWVudFZhbHVlUHJvcCA9IG51bGw7XG5cbi8qKlxuICogU0VDVElPTjogaGFuZGxlIGBjaGFuZ2VgIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIHNob3VsZFVzZUNoYW5nZUV2ZW50KGVsZW0pIHtcbiAgcmV0dXJuIChcbiAgICBlbGVtLm5vZGVOYW1lID09PSAnU0VMRUNUJyB8fFxuICAgIChlbGVtLm5vZGVOYW1lID09PSAnSU5QVVQnICYmIGVsZW0udHlwZSA9PT0gJ2ZpbGUnKVxuICApO1xufVxuXG52YXIgZG9lc0NoYW5nZUV2ZW50QnViYmxlID0gZmFsc2U7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIC8vIFNlZSBgaGFuZGxlQ2hhbmdlYCBjb21tZW50IGJlbG93XG4gIGRvZXNDaGFuZ2VFdmVudEJ1YmJsZSA9IGlzRXZlbnRTdXBwb3J0ZWQoJ2NoYW5nZScpICYmIChcbiAgICAhKCdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50KSB8fCBkb2N1bWVudC5kb2N1bWVudE1vZGUgPiA4XG4gICk7XG59XG5cbmZ1bmN0aW9uIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIGV2ZW50ID0gU3ludGhldGljRXZlbnQuZ2V0UG9vbGVkKFxuICAgIGV2ZW50VHlwZXMuY2hhbmdlLFxuICAgIGFjdGl2ZUVsZW1lbnRJRCxcbiAgICBuYXRpdmVFdmVudFxuICApO1xuICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuXG4gIC8vIElmIGNoYW5nZSBhbmQgcHJvcGVydHljaGFuZ2UgYnViYmxlZCwgd2UnZCBqdXN0IGJpbmQgdG8gaXQgbGlrZSBhbGwgdGhlXG4gIC8vIG90aGVyIGV2ZW50cyBhbmQgaGF2ZSBpdCBnbyB0aHJvdWdoIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci4gU2luY2UgaXRcbiAgLy8gZG9lc24ndCwgd2UgbWFudWFsbHkgbGlzdGVuIGZvciB0aGUgZXZlbnRzIGFuZCBzbyB3ZSBoYXZlIHRvIGVucXVldWUgYW5kXG4gIC8vIHByb2Nlc3MgdGhlIGFic3RyYWN0IGV2ZW50IG1hbnVhbGx5LlxuICAvL1xuICAvLyBCYXRjaGluZyBpcyBuZWNlc3NhcnkgaGVyZSBpbiBvcmRlciB0byBlbnN1cmUgdGhhdCBhbGwgZXZlbnQgaGFuZGxlcnMgcnVuXG4gIC8vIGJlZm9yZSB0aGUgbmV4dCByZXJlbmRlciAoaW5jbHVkaW5nIGV2ZW50IGhhbmRsZXJzIGF0dGFjaGVkIHRvIGFuY2VzdG9yXG4gIC8vIGVsZW1lbnRzIGluc3RlYWQgb2YgZGlyZWN0bHkgb24gdGhlIGlucHV0KS4gV2l0aG91dCB0aGlzLCBjb250cm9sbGVkXG4gIC8vIGNvbXBvbmVudHMgZG9uJ3Qgd29yayBwcm9wZXJseSBpbiBjb25qdW5jdGlvbiB3aXRoIGV2ZW50IGJ1YmJsaW5nIGJlY2F1c2VcbiAgLy8gdGhlIGNvbXBvbmVudCBpcyByZXJlbmRlcmVkIGFuZCB0aGUgdmFsdWUgcmV2ZXJ0ZWQgYmVmb3JlIGFsbCB0aGUgZXZlbnRcbiAgLy8gaGFuZGxlcnMgY2FuIHJ1bi4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzA4LlxuICBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXMocnVuRXZlbnRJbkJhdGNoLCBldmVudCk7XG59XG5cbmZ1bmN0aW9uIHJ1bkV2ZW50SW5CYXRjaChldmVudCkge1xuICBFdmVudFBsdWdpbkh1Yi5lbnF1ZXVlRXZlbnRzKGV2ZW50KTtcbiAgRXZlbnRQbHVnaW5IdWIucHJvY2Vzc0V2ZW50UXVldWUoKTtcbn1cblxuZnVuY3Rpb24gc3RhcnRXYXRjaGluZ0ZvckNoYW5nZUV2ZW50SUU4KHRhcmdldCwgdGFyZ2V0SUQpIHtcbiAgYWN0aXZlRWxlbWVudCA9IHRhcmdldDtcbiAgYWN0aXZlRWxlbWVudElEID0gdGFyZ2V0SUQ7XG4gIGFjdGl2ZUVsZW1lbnQuYXR0YWNoRXZlbnQoJ29uY2hhbmdlJywgbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudCk7XG59XG5cbmZ1bmN0aW9uIHN0b3BXYXRjaGluZ0ZvckNoYW5nZUV2ZW50SUU4KCkge1xuICBpZiAoIWFjdGl2ZUVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYWN0aXZlRWxlbWVudC5kZXRhY2hFdmVudCgnb25jaGFuZ2UnLCBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KTtcbiAgYWN0aXZlRWxlbWVudCA9IG51bGw7XG4gIGFjdGl2ZUVsZW1lbnRJRCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldElERm9yQ2hhbmdlRXZlbnQoXG4gICAgdG9wTGV2ZWxUeXBlLFxuICAgIHRvcExldmVsVGFyZ2V0LFxuICAgIHRvcExldmVsVGFyZ2V0SUQpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BDaGFuZ2UpIHtcbiAgICByZXR1cm4gdG9wTGV2ZWxUYXJnZXRJRDtcbiAgfVxufVxuZnVuY3Rpb24gaGFuZGxlRXZlbnRzRm9yQ2hhbmdlRXZlbnRJRTgoXG4gICAgdG9wTGV2ZWxUeXBlLFxuICAgIHRvcExldmVsVGFyZ2V0LFxuICAgIHRvcExldmVsVGFyZ2V0SUQpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BGb2N1cykge1xuICAgIC8vIHN0b3BXYXRjaGluZygpIHNob3VsZCBiZSBhIG5vb3AgaGVyZSBidXQgd2UgY2FsbCBpdCBqdXN0IGluIGNhc2Ugd2VcbiAgICAvLyBtaXNzZWQgYSBibHVyIGV2ZW50IHNvbWVob3cuXG4gICAgc3RvcFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgoKTtcbiAgICBzdGFydFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgodG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQpO1xuICB9IGVsc2UgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BCbHVyKSB7XG4gICAgc3RvcFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgoKTtcbiAgfVxufVxuXG5cbi8qKlxuICogU0VDVElPTjogaGFuZGxlIGBpbnB1dGAgZXZlbnRcbiAqL1xudmFyIGlzSW5wdXRFdmVudFN1cHBvcnRlZCA9IGZhbHNlO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICAvLyBJRTkgY2xhaW1zIHRvIHN1cHBvcnQgdGhlIGlucHV0IGV2ZW50IGJ1dCBmYWlscyB0byB0cmlnZ2VyIGl0IHdoZW5cbiAgLy8gZGVsZXRpbmcgdGV4dCwgc28gd2UgaWdub3JlIGl0cyBpbnB1dCBldmVudHNcbiAgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID0gaXNFdmVudFN1cHBvcnRlZCgnaW5wdXQnKSAmJiAoXG4gICAgISgnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCkgfHwgZG9jdW1lbnQuZG9jdW1lbnRNb2RlID4gOVxuICApO1xufVxuXG4vKipcbiAqIChGb3Igb2xkIElFLikgUmVwbGFjZW1lbnQgZ2V0dGVyL3NldHRlciBmb3IgdGhlIGB2YWx1ZWAgcHJvcGVydHkgdGhhdCBnZXRzXG4gKiBzZXQgb24gdGhlIGFjdGl2ZSBlbGVtZW50LlxuICovXG52YXIgbmV3VmFsdWVQcm9wID0gIHtcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYWN0aXZlRWxlbWVudFZhbHVlUHJvcC5nZXQuY2FsbCh0aGlzKTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbih2YWwpIHtcbiAgICAvLyBDYXN0IHRvIGEgc3RyaW5nIHNvIHdlIGNhbiBkbyBlcXVhbGl0eSBjaGVja3MuXG4gICAgYWN0aXZlRWxlbWVudFZhbHVlID0gJycgKyB2YWw7XG4gICAgYWN0aXZlRWxlbWVudFZhbHVlUHJvcC5zZXQuY2FsbCh0aGlzLCB2YWwpO1xuICB9XG59O1xuXG4vKipcbiAqIChGb3Igb2xkIElFLikgU3RhcnRzIHRyYWNraW5nIHByb3BlcnR5Y2hhbmdlIGV2ZW50cyBvbiB0aGUgcGFzc2VkLWluIGVsZW1lbnRcbiAqIGFuZCBvdmVycmlkZSB0aGUgdmFsdWUgcHJvcGVydHkgc28gdGhhdCB3ZSBjYW4gZGlzdGluZ3Vpc2ggdXNlciBldmVudHMgZnJvbVxuICogdmFsdWUgY2hhbmdlcyBpbiBKUy5cbiAqL1xuZnVuY3Rpb24gc3RhcnRXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKHRhcmdldCwgdGFyZ2V0SUQpIHtcbiAgYWN0aXZlRWxlbWVudCA9IHRhcmdldDtcbiAgYWN0aXZlRWxlbWVudElEID0gdGFyZ2V0SUQ7XG4gIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9IHRhcmdldC52YWx1ZTtcbiAgYWN0aXZlRWxlbWVudFZhbHVlUHJvcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoXG4gICAgdGFyZ2V0LmNvbnN0cnVjdG9yLnByb3RvdHlwZSxcbiAgICAndmFsdWUnXG4gICk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFjdGl2ZUVsZW1lbnQsICd2YWx1ZScsIG5ld1ZhbHVlUHJvcCk7XG4gIGFjdGl2ZUVsZW1lbnQuYXR0YWNoRXZlbnQoJ29ucHJvcGVydHljaGFuZ2UnLCBoYW5kbGVQcm9wZXJ0eUNoYW5nZSk7XG59XG5cbi8qKlxuICogKEZvciBvbGQgSUUuKSBSZW1vdmVzIHRoZSBldmVudCBsaXN0ZW5lcnMgZnJvbSB0aGUgY3VycmVudGx5LXRyYWNrZWQgZWxlbWVudCxcbiAqIGlmIGFueSBleGlzdHMuXG4gKi9cbmZ1bmN0aW9uIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCkge1xuICBpZiAoIWFjdGl2ZUVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBkZWxldGUgcmVzdG9yZXMgdGhlIG9yaWdpbmFsIHByb3BlcnR5IGRlZmluaXRpb25cbiAgZGVsZXRlIGFjdGl2ZUVsZW1lbnQudmFsdWU7XG4gIGFjdGl2ZUVsZW1lbnQuZGV0YWNoRXZlbnQoJ29ucHJvcGVydHljaGFuZ2UnLCBoYW5kbGVQcm9wZXJ0eUNoYW5nZSk7XG5cbiAgYWN0aXZlRWxlbWVudCA9IG51bGw7XG4gIGFjdGl2ZUVsZW1lbnRJRCA9IG51bGw7XG4gIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9IG51bGw7XG4gIGFjdGl2ZUVsZW1lbnRWYWx1ZVByb3AgPSBudWxsO1xufVxuXG4vKipcbiAqIChGb3Igb2xkIElFLikgSGFuZGxlcyBhIHByb3BlcnR5Y2hhbmdlIGV2ZW50LCBzZW5kaW5nIGEgYGNoYW5nZWAgZXZlbnQgaWZcbiAqIHRoZSB2YWx1ZSBvZiB0aGUgYWN0aXZlIGVsZW1lbnQgaGFzIGNoYW5nZWQuXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZVByb3BlcnR5Q2hhbmdlKG5hdGl2ZUV2ZW50KSB7XG4gIGlmIChuYXRpdmVFdmVudC5wcm9wZXJ0eU5hbWUgIT09ICd2YWx1ZScpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHZhbHVlID0gbmF0aXZlRXZlbnQuc3JjRWxlbWVudC52YWx1ZTtcbiAgaWYgKHZhbHVlID09PSBhY3RpdmVFbGVtZW50VmFsdWUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYWN0aXZlRWxlbWVudFZhbHVlID0gdmFsdWU7XG5cbiAgbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudChuYXRpdmVFdmVudCk7XG59XG5cbi8qKlxuICogSWYgYSBgY2hhbmdlYCBldmVudCBzaG91bGQgYmUgZmlyZWQsIHJldHVybnMgdGhlIHRhcmdldCdzIElELlxuICovXG5mdW5jdGlvbiBnZXRUYXJnZXRJREZvcklucHV0RXZlbnQoXG4gICAgdG9wTGV2ZWxUeXBlLFxuICAgIHRvcExldmVsVGFyZ2V0LFxuICAgIHRvcExldmVsVGFyZ2V0SUQpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BJbnB1dCkge1xuICAgIC8vIEluIG1vZGVybiBicm93c2VycyAoaS5lLiwgbm90IElFOCBvciBJRTkpLCB0aGUgaW5wdXQgZXZlbnQgaXMgZXhhY3RseVxuICAgIC8vIHdoYXQgd2Ugd2FudCBzbyBmYWxsIHRocm91Z2ggaGVyZSBhbmQgdHJpZ2dlciBhbiBhYnN0cmFjdCBldmVudFxuICAgIHJldHVybiB0b3BMZXZlbFRhcmdldElEO1xuICB9XG59XG5cbi8vIEZvciBJRTggYW5kIElFOS5cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRJRShcbiAgICB0b3BMZXZlbFR5cGUsXG4gICAgdG9wTGV2ZWxUYXJnZXQsXG4gICAgdG9wTGV2ZWxUYXJnZXRJRCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzKSB7XG4gICAgLy8gSW4gSUU4LCB3ZSBjYW4gY2FwdHVyZSBhbG1vc3QgYWxsIC52YWx1ZSBjaGFuZ2VzIGJ5IGFkZGluZyBhXG4gICAgLy8gcHJvcGVydHljaGFuZ2UgaGFuZGxlciBhbmQgbG9va2luZyBmb3IgZXZlbnRzIHdpdGggcHJvcGVydHlOYW1lXG4gICAgLy8gZXF1YWwgdG8gJ3ZhbHVlJ1xuICAgIC8vIEluIElFOSwgcHJvcGVydHljaGFuZ2UgZmlyZXMgZm9yIG1vc3QgaW5wdXQgZXZlbnRzIGJ1dCBpcyBidWdneSBhbmRcbiAgICAvLyBkb2Vzbid0IGZpcmUgd2hlbiB0ZXh0IGlzIGRlbGV0ZWQsIGJ1dCBjb252ZW5pZW50bHksIHNlbGVjdGlvbmNoYW5nZVxuICAgIC8vIGFwcGVhcnMgdG8gZmlyZSBpbiBhbGwgb2YgdGhlIHJlbWFpbmluZyBjYXNlcyBzbyB3ZSBjYXRjaCB0aG9zZSBhbmRcbiAgICAvLyBmb3J3YXJkIHRoZSBldmVudCBpZiB0aGUgdmFsdWUgaGFzIGNoYW5nZWRcbiAgICAvLyBJbiBlaXRoZXIgY2FzZSwgd2UgZG9uJ3Qgd2FudCB0byBjYWxsIHRoZSBldmVudCBoYW5kbGVyIGlmIHRoZSB2YWx1ZVxuICAgIC8vIGlzIGNoYW5nZWQgZnJvbSBKUyBzbyB3ZSByZWRlZmluZSBhIHNldHRlciBmb3IgYC52YWx1ZWAgdGhhdCB1cGRhdGVzXG4gICAgLy8gb3VyIGFjdGl2ZUVsZW1lbnRWYWx1ZSB2YXJpYWJsZSwgYWxsb3dpbmcgdXMgdG8gaWdub3JlIHRob3NlIGNoYW5nZXNcbiAgICAvL1xuICAgIC8vIHN0b3BXYXRjaGluZygpIHNob3VsZCBiZSBhIG5vb3AgaGVyZSBidXQgd2UgY2FsbCBpdCBqdXN0IGluIGNhc2Ugd2VcbiAgICAvLyBtaXNzZWQgYSBibHVyIGV2ZW50IHNvbWVob3cuXG4gICAgc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKTtcbiAgICBzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UodG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQpO1xuICB9IGVsc2UgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BCbHVyKSB7XG4gICAgc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKTtcbiAgfVxufVxuXG4vLyBGb3IgSUU4IGFuZCBJRTkuXG5mdW5jdGlvbiBnZXRUYXJnZXRJREZvcklucHV0RXZlbnRJRShcbiAgICB0b3BMZXZlbFR5cGUsXG4gICAgdG9wTGV2ZWxUYXJnZXQsXG4gICAgdG9wTGV2ZWxUYXJnZXRJRCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcFNlbGVjdGlvbkNoYW5nZSB8fFxuICAgICAgdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcEtleVVwIHx8XG4gICAgICB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wS2V5RG93bikge1xuICAgIC8vIE9uIHRoZSBzZWxlY3Rpb25jaGFuZ2UgZXZlbnQsIHRoZSB0YXJnZXQgaXMganVzdCBkb2N1bWVudCB3aGljaCBpc24ndFxuICAgIC8vIGhlbHBmdWwgZm9yIHVzIHNvIGp1c3QgY2hlY2sgYWN0aXZlRWxlbWVudCBpbnN0ZWFkLlxuICAgIC8vXG4gICAgLy8gOTklIG9mIHRoZSB0aW1lLCBrZXlkb3duIGFuZCBrZXl1cCBhcmVuJ3QgbmVjZXNzYXJ5LiBJRTggZmFpbHMgdG8gZmlyZVxuICAgIC8vIHByb3BlcnR5Y2hhbmdlIG9uIHRoZSBmaXJzdCBpbnB1dCBldmVudCBhZnRlciBzZXR0aW5nIGB2YWx1ZWAgZnJvbSBhXG4gICAgLy8gc2NyaXB0IGFuZCBmaXJlcyBvbmx5IGtleWRvd24sIGtleXByZXNzLCBrZXl1cC4gQ2F0Y2hpbmcga2V5dXAgdXN1YWxseVxuICAgIC8vIGdldHMgaXQgYW5kIGNhdGNoaW5nIGtleWRvd24gbGV0cyB1cyBmaXJlIGFuIGV2ZW50IGZvciB0aGUgZmlyc3RcbiAgICAvLyBrZXlzdHJva2UgaWYgdXNlciBkb2VzIGEga2V5IHJlcGVhdCAoaXQnbGwgYmUgYSBsaXR0bGUgZGVsYXllZDogcmlnaHRcbiAgICAvLyBiZWZvcmUgdGhlIHNlY29uZCBrZXlzdHJva2UpLiBPdGhlciBpbnB1dCBtZXRob2RzIChlLmcuLCBwYXN0ZSkgc2VlbSB0b1xuICAgIC8vIGZpcmUgc2VsZWN0aW9uY2hhbmdlIG5vcm1hbGx5LlxuICAgIGlmIChhY3RpdmVFbGVtZW50ICYmIGFjdGl2ZUVsZW1lbnQudmFsdWUgIT09IGFjdGl2ZUVsZW1lbnRWYWx1ZSkge1xuICAgICAgYWN0aXZlRWxlbWVudFZhbHVlID0gYWN0aXZlRWxlbWVudC52YWx1ZTtcbiAgICAgIHJldHVybiBhY3RpdmVFbGVtZW50SUQ7XG4gICAgfVxuICB9XG59XG5cblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGNsaWNrYCBldmVudFxuICovXG5mdW5jdGlvbiBzaG91bGRVc2VDbGlja0V2ZW50KGVsZW0pIHtcbiAgLy8gVXNlIHRoZSBgY2xpY2tgIGV2ZW50IHRvIGRldGVjdCBjaGFuZ2VzIHRvIGNoZWNrYm94IGFuZCByYWRpbyBpbnB1dHMuXG4gIC8vIFRoaXMgYXBwcm9hY2ggd29ya3MgYWNyb3NzIGFsbCBicm93c2Vycywgd2hlcmVhcyBgY2hhbmdlYCBkb2VzIG5vdCBmaXJlXG4gIC8vIHVudGlsIGBibHVyYCBpbiBJRTguXG4gIHJldHVybiAoXG4gICAgZWxlbS5ub2RlTmFtZSA9PT0gJ0lOUFVUJyAmJlxuICAgIChlbGVtLnR5cGUgPT09ICdjaGVja2JveCcgfHwgZWxlbS50eXBlID09PSAncmFkaW8nKVxuICApO1xufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJREZvckNsaWNrRXZlbnQoXG4gICAgdG9wTGV2ZWxUeXBlLFxuICAgIHRvcExldmVsVGFyZ2V0LFxuICAgIHRvcExldmVsVGFyZ2V0SUQpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BDbGljaykge1xuICAgIHJldHVybiB0b3BMZXZlbFRhcmdldElEO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBwbHVnaW4gY3JlYXRlcyBhbiBgb25DaGFuZ2VgIGV2ZW50IHRoYXQgbm9ybWFsaXplcyBjaGFuZ2UgZXZlbnRzXG4gKiBhY3Jvc3MgZm9ybSBlbGVtZW50cy4gVGhpcyBldmVudCBmaXJlcyBhdCBhIHRpbWUgd2hlbiBpdCdzIHBvc3NpYmxlIHRvXG4gKiBjaGFuZ2UgdGhlIGVsZW1lbnQncyB2YWx1ZSB3aXRob3V0IHNlZWluZyBhIGZsaWNrZXIuXG4gKlxuICogU3VwcG9ydGVkIGVsZW1lbnRzIGFyZTpcbiAqIC0gaW5wdXQgKHNlZSBgaXNUZXh0SW5wdXRFbGVtZW50YClcbiAqIC0gdGV4dGFyZWFcbiAqIC0gc2VsZWN0XG4gKi9cbnZhciBDaGFuZ2VFdmVudFBsdWdpbiA9IHtcblxuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRvcExldmVsVGFyZ2V0IFRoZSBsaXN0ZW5pbmcgY29tcG9uZW50IHJvb3Qgbm9kZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVGFyZ2V0SUQgSUQgb2YgYHRvcExldmVsVGFyZ2V0YC5cbiAgICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICAgKiBAcmV0dXJuIHsqfSBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAgICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuZXh0cmFjdEV2ZW50c31cbiAgICovXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uKFxuICAgICAgdG9wTGV2ZWxUeXBlLFxuICAgICAgdG9wTGV2ZWxUYXJnZXQsXG4gICAgICB0b3BMZXZlbFRhcmdldElELFxuICAgICAgbmF0aXZlRXZlbnQpIHtcblxuICAgIHZhciBnZXRUYXJnZXRJREZ1bmMsIGhhbmRsZUV2ZW50RnVuYztcbiAgICBpZiAoc2hvdWxkVXNlQ2hhbmdlRXZlbnQodG9wTGV2ZWxUYXJnZXQpKSB7XG4gICAgICBpZiAoZG9lc0NoYW5nZUV2ZW50QnViYmxlKSB7XG4gICAgICAgIGdldFRhcmdldElERnVuYyA9IGdldFRhcmdldElERm9yQ2hhbmdlRXZlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYW5kbGVFdmVudEZ1bmMgPSBoYW5kbGVFdmVudHNGb3JDaGFuZ2VFdmVudElFODtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVGV4dElucHV0RWxlbWVudCh0b3BMZXZlbFRhcmdldCkpIHtcbiAgICAgIGlmIChpc0lucHV0RXZlbnRTdXBwb3J0ZWQpIHtcbiAgICAgICAgZ2V0VGFyZ2V0SURGdW5jID0gZ2V0VGFyZ2V0SURGb3JJbnB1dEV2ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2V0VGFyZ2V0SURGdW5jID0gZ2V0VGFyZ2V0SURGb3JJbnB1dEV2ZW50SUU7XG4gICAgICAgIGhhbmRsZUV2ZW50RnVuYyA9IGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRJRTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNob3VsZFVzZUNsaWNrRXZlbnQodG9wTGV2ZWxUYXJnZXQpKSB7XG4gICAgICBnZXRUYXJnZXRJREZ1bmMgPSBnZXRUYXJnZXRJREZvckNsaWNrRXZlbnQ7XG4gICAgfVxuXG4gICAgaWYgKGdldFRhcmdldElERnVuYykge1xuICAgICAgdmFyIHRhcmdldElEID0gZ2V0VGFyZ2V0SURGdW5jKFxuICAgICAgICB0b3BMZXZlbFR5cGUsXG4gICAgICAgIHRvcExldmVsVGFyZ2V0LFxuICAgICAgICB0b3BMZXZlbFRhcmdldElEXG4gICAgICApO1xuICAgICAgaWYgKHRhcmdldElEKSB7XG4gICAgICAgIHZhciBldmVudCA9IFN5bnRoZXRpY0V2ZW50LmdldFBvb2xlZChcbiAgICAgICAgICBldmVudFR5cGVzLmNoYW5nZSxcbiAgICAgICAgICB0YXJnZXRJRCxcbiAgICAgICAgICBuYXRpdmVFdmVudFxuICAgICAgICApO1xuICAgICAgICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhbmRsZUV2ZW50RnVuYykge1xuICAgICAgaGFuZGxlRXZlbnRGdW5jKFxuICAgICAgICB0b3BMZXZlbFR5cGUsXG4gICAgICAgIHRvcExldmVsVGFyZ2V0LFxuICAgICAgICB0b3BMZXZlbFRhcmdldElEXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENoYW5nZUV2ZW50UGx1Z2luO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIENsaWVudFJlYWN0Um9vdEluZGV4XG4gKiBAdHlwZWNoZWNrc1xuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgbmV4dFJlYWN0Um9vdEluZGV4ID0gMDtcblxudmFyIENsaWVudFJlYWN0Um9vdEluZGV4ID0ge1xuICBjcmVhdGVSZWFjdFJvb3RJbmRleDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5leHRSZWFjdFJvb3RJbmRleCsrO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENsaWVudFJlYWN0Um9vdEluZGV4O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIENvbXBvc2l0aW9uRXZlbnRQbHVnaW5cbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoXCIuL0V2ZW50Q29uc3RhbnRzXCIpO1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKFwiLi9FdmVudFByb3BhZ2F0b3JzXCIpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZShcIi4vRXhlY3V0aW9uRW52aXJvbm1lbnRcIik7XG52YXIgUmVhY3RJbnB1dFNlbGVjdGlvbiA9IHJlcXVpcmUoXCIuL1JlYWN0SW5wdXRTZWxlY3Rpb25cIik7XG52YXIgU3ludGhldGljQ29tcG9zaXRpb25FdmVudCA9IHJlcXVpcmUoXCIuL1N5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnRcIik7XG5cbnZhciBnZXRUZXh0Q29udGVudEFjY2Vzc29yID0gcmVxdWlyZShcIi4vZ2V0VGV4dENvbnRlbnRBY2Nlc3NvclwiKTtcbnZhciBrZXlPZiA9IHJlcXVpcmUoXCIuL2tleU9mXCIpO1xuXG52YXIgRU5EX0tFWUNPREVTID0gWzksIDEzLCAyNywgMzJdOyAvLyBUYWIsIFJldHVybiwgRXNjLCBTcGFjZVxudmFyIFNUQVJUX0tFWUNPREUgPSAyMjk7XG5cbnZhciB1c2VDb21wb3NpdGlvbkV2ZW50ID0gKFxuICBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiZcbiAgJ0NvbXBvc2l0aW9uRXZlbnQnIGluIHdpbmRvd1xuKTtcblxuLy8gSW4gSUU5Kywgd2UgaGF2ZSBhY2Nlc3MgdG8gY29tcG9zaXRpb24gZXZlbnRzLCBidXQgdGhlIGRhdGEgc3VwcGxpZWRcbi8vIGJ5IHRoZSBuYXRpdmUgY29tcG9zaXRpb25lbmQgZXZlbnQgbWF5IGJlIGluY29ycmVjdC4gSW4gS29yZWFuLCBmb3IgZXhhbXBsZSxcbi8vIHRoZSBjb21wb3NpdGlvbmVuZCBldmVudCBjb250YWlucyBvbmx5IG9uZSBjaGFyYWN0ZXIgcmVnYXJkbGVzcyBvZlxuLy8gaG93IG1hbnkgY2hhcmFjdGVycyBoYXZlIGJlZW4gY29tcG9zZWQgc2luY2UgY29tcG9zaXRpb25zdGFydC5cbi8vIFdlIHRoZXJlZm9yZSB1c2UgdGhlIGZhbGxiYWNrIGRhdGEgd2hpbGUgc3RpbGwgdXNpbmcgdGhlIG5hdGl2ZVxuLy8gZXZlbnRzIGFzIHRyaWdnZXJzLlxudmFyIHVzZUZhbGxiYWNrRGF0YSA9IChcbiAgIXVzZUNvbXBvc2l0aW9uRXZlbnQgfHxcbiAgKFxuICAgICdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50ICYmXG4gICAgZG9jdW1lbnQuZG9jdW1lbnRNb2RlID4gOCAmJlxuICAgIGRvY3VtZW50LmRvY3VtZW50TW9kZSA8PSAxMVxuICApXG4pO1xuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG52YXIgY3VycmVudENvbXBvc2l0aW9uID0gbnVsbDtcblxuLy8gRXZlbnRzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIHByb3BlcnR5IG5hbWVzLlxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIGNvbXBvc2l0aW9uRW5kOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHtvbkNvbXBvc2l0aW9uRW5kOiBudWxsfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2Yoe29uQ29tcG9zaXRpb25FbmRDYXB0dXJlOiBudWxsfSlcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW1xuICAgICAgdG9wTGV2ZWxUeXBlcy50b3BCbHVyLFxuICAgICAgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvbkVuZCxcbiAgICAgIHRvcExldmVsVHlwZXMudG9wS2V5RG93bixcbiAgICAgIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3MsXG4gICAgICB0b3BMZXZlbFR5cGVzLnRvcEtleVVwLFxuICAgICAgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd25cbiAgICBdXG4gIH0sXG4gIGNvbXBvc2l0aW9uU3RhcnQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2Yoe29uQ29tcG9zaXRpb25TdGFydDogbnVsbH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHtvbkNvbXBvc2l0aW9uU3RhcnRDYXB0dXJlOiBudWxsfSlcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW1xuICAgICAgdG9wTGV2ZWxUeXBlcy50b3BCbHVyLFxuICAgICAgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvblN0YXJ0LFxuICAgICAgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duLFxuICAgICAgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzcyxcbiAgICAgIHRvcExldmVsVHlwZXMudG9wS2V5VXAsXG4gICAgICB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93blxuICAgIF1cbiAgfSxcbiAgY29tcG9zaXRpb25VcGRhdGU6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2Yoe29uQ29tcG9zaXRpb25VcGRhdGU6IG51bGx9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7b25Db21wb3NpdGlvblVwZGF0ZUNhcHR1cmU6IG51bGx9KVxuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbXG4gICAgICB0b3BMZXZlbFR5cGVzLnRvcEJsdXIsXG4gICAgICB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uVXBkYXRlLFxuICAgICAgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duLFxuICAgICAgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzcyxcbiAgICAgIHRvcExldmVsVHlwZXMudG9wS2V5VXAsXG4gICAgICB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93blxuICAgIF1cbiAgfVxufTtcblxuLyoqXG4gKiBUcmFuc2xhdGUgbmF0aXZlIHRvcCBsZXZlbCBldmVudHMgaW50byBldmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvc2l0aW9uRXZlbnRUeXBlKHRvcExldmVsVHlwZSkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvblN0YXJ0OlxuICAgICAgcmV0dXJuIGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydDtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25FbmQ6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZDtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25VcGRhdGU6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvblVwZGF0ZTtcbiAgfVxufVxuXG4vKipcbiAqIERvZXMgb3VyIGZhbGxiYWNrIGJlc3QtZ3Vlc3MgbW9kZWwgdGhpbmsgdGhpcyBldmVudCBzaWduaWZpZXMgdGhhdFxuICogY29tcG9zaXRpb24gaGFzIGJlZ3VuP1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGYWxsYmFja1N0YXJ0KHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIChcbiAgICB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wS2V5RG93biAmJlxuICAgIG5hdGl2ZUV2ZW50LmtleUNvZGUgPT09IFNUQVJUX0tFWUNPREVcbiAgKTtcbn1cblxuLyoqXG4gKiBEb2VzIG91ciBmYWxsYmFjayBtb2RlIHRoaW5rIHRoYXQgdGhpcyBldmVudCBpcyB0aGUgZW5kIG9mIGNvbXBvc2l0aW9uP1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGYWxsYmFja0VuZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleVVwOlxuICAgICAgLy8gQ29tbWFuZCBrZXlzIGluc2VydCBvciBjbGVhciBJTUUgaW5wdXQuXG4gICAgICByZXR1cm4gKEVORF9LRVlDT0RFUy5pbmRleE9mKG5hdGl2ZUV2ZW50LmtleUNvZGUpICE9PSAtMSk7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleURvd246XG4gICAgICAvLyBFeHBlY3QgSU1FIGtleUNvZGUgb24gZWFjaCBrZXlkb3duLiBJZiB3ZSBnZXQgYW55IG90aGVyXG4gICAgICAvLyBjb2RlIHdlIG11c3QgaGF2ZSBleGl0ZWQgZWFybGllci5cbiAgICAgIHJldHVybiAobmF0aXZlRXZlbnQua2V5Q29kZSAhPT0gU1RBUlRfS0VZQ09ERSk7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleVByZXNzOlxuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd246XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEJsdXI6XG4gICAgICAvLyBFdmVudHMgYXJlIG5vdCBwb3NzaWJsZSB3aXRob3V0IGNhbmNlbGxpbmcgSU1FLlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEhlbHBlciBjbGFzcyBzdG9yZXMgaW5mb3JtYXRpb24gYWJvdXQgc2VsZWN0aW9uIGFuZCBkb2N1bWVudCBzdGF0ZVxuICogc28gd2UgY2FuIGZpZ3VyZSBvdXQgd2hhdCBjaGFuZ2VkIGF0IGEgbGF0ZXIgZGF0ZS5cbiAqXG4gKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSByb290XG4gKi9cbmZ1bmN0aW9uIEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZShyb290KSB7XG4gIHRoaXMucm9vdCA9IHJvb3Q7XG4gIHRoaXMuc3RhcnRTZWxlY3Rpb24gPSBSZWFjdElucHV0U2VsZWN0aW9uLmdldFNlbGVjdGlvbihyb290KTtcbiAgdGhpcy5zdGFydFZhbHVlID0gdGhpcy5nZXRUZXh0KCk7XG59XG5cbi8qKlxuICogR2V0IGN1cnJlbnQgdGV4dCBvZiBpbnB1dC5cbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbkZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZS5wcm90b3R5cGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5yb290LnZhbHVlIHx8IHRoaXMucm9vdFtnZXRUZXh0Q29udGVudEFjY2Vzc29yKCldO1xufTtcblxuLyoqXG4gKiBUZXh0IHRoYXQgaGFzIGNoYW5nZWQgc2luY2UgdGhlIHN0YXJ0IG9mIGNvbXBvc2l0aW9uLlxuICpcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlLnByb3RvdHlwZS5nZXREYXRhID0gZnVuY3Rpb24oKSB7XG4gIHZhciBlbmRWYWx1ZSA9IHRoaXMuZ2V0VGV4dCgpO1xuICB2YXIgcHJlZml4TGVuZ3RoID0gdGhpcy5zdGFydFNlbGVjdGlvbi5zdGFydDtcbiAgdmFyIHN1ZmZpeExlbmd0aCA9IHRoaXMuc3RhcnRWYWx1ZS5sZW5ndGggLSB0aGlzLnN0YXJ0U2VsZWN0aW9uLmVuZDtcblxuICByZXR1cm4gZW5kVmFsdWUuc3Vic3RyKFxuICAgIHByZWZpeExlbmd0aCxcbiAgICBlbmRWYWx1ZS5sZW5ndGggLSBzdWZmaXhMZW5ndGggLSBwcmVmaXhMZW5ndGhcbiAgKTtcbn07XG5cbi8qKlxuICogVGhpcyBwbHVnaW4gY3JlYXRlcyBgb25Db21wb3NpdGlvblN0YXJ0YCwgYG9uQ29tcG9zaXRpb25VcGRhdGVgIGFuZFxuICogYG9uQ29tcG9zaXRpb25FbmRgIGV2ZW50cyBvbiBpbnB1dHMsIHRleHRhcmVhcyBhbmQgY29udGVudEVkaXRhYmxlXG4gKiBub2Rlcy5cbiAqL1xudmFyIENvbXBvc2l0aW9uRXZlbnRQbHVnaW4gPSB7XG5cbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0b3BMZXZlbFRhcmdldCBUaGUgbGlzdGVuaW5nIGNvbXBvbmVudCByb290IG5vZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFRhcmdldElEIElEIG9mIGB0b3BMZXZlbFRhcmdldGAuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAgICogQHJldHVybiB7Kn0gQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gICAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmV4dHJhY3RFdmVudHN9XG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbihcbiAgICAgIHRvcExldmVsVHlwZSxcbiAgICAgIHRvcExldmVsVGFyZ2V0LFxuICAgICAgdG9wTGV2ZWxUYXJnZXRJRCxcbiAgICAgIG5hdGl2ZUV2ZW50KSB7XG5cbiAgICB2YXIgZXZlbnRUeXBlO1xuICAgIHZhciBkYXRhO1xuXG4gICAgaWYgKHVzZUNvbXBvc2l0aW9uRXZlbnQpIHtcbiAgICAgIGV2ZW50VHlwZSA9IGdldENvbXBvc2l0aW9uRXZlbnRUeXBlKHRvcExldmVsVHlwZSk7XG4gICAgfSBlbHNlIGlmICghY3VycmVudENvbXBvc2l0aW9uKSB7XG4gICAgICBpZiAoaXNGYWxsYmFja1N0YXJ0KHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpKSB7XG4gICAgICAgIGV2ZW50VHlwZSA9IGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzRmFsbGJhY2tFbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICAgIGV2ZW50VHlwZSA9IGV2ZW50VHlwZXMuY29tcG9zaXRpb25FbmQ7XG4gICAgfVxuXG4gICAgaWYgKHVzZUZhbGxiYWNrRGF0YSkge1xuICAgICAgLy8gVGhlIGN1cnJlbnQgY29tcG9zaXRpb24gaXMgc3RvcmVkIHN0YXRpY2FsbHkgYW5kIG11c3Qgbm90IGJlXG4gICAgICAvLyBvdmVyd3JpdHRlbiB3aGlsZSBjb21wb3NpdGlvbiBjb250aW51ZXMuXG4gICAgICBpZiAoIWN1cnJlbnRDb21wb3NpdGlvbiAmJiBldmVudFR5cGUgPT09IGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydCkge1xuICAgICAgICBjdXJyZW50Q29tcG9zaXRpb24gPSBuZXcgRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlKHRvcExldmVsVGFyZ2V0KTtcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlID09PSBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kKSB7XG4gICAgICAgIGlmIChjdXJyZW50Q29tcG9zaXRpb24pIHtcbiAgICAgICAgICBkYXRhID0gY3VycmVudENvbXBvc2l0aW9uLmdldERhdGEoKTtcbiAgICAgICAgICBjdXJyZW50Q29tcG9zaXRpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50VHlwZSkge1xuICAgICAgdmFyIGV2ZW50ID0gU3ludGhldGljQ29tcG9zaXRpb25FdmVudC5nZXRQb29sZWQoXG4gICAgICAgIGV2ZW50VHlwZSxcbiAgICAgICAgdG9wTGV2ZWxUYXJnZXRJRCxcbiAgICAgICAgbmF0aXZlRXZlbnRcbiAgICAgICk7XG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICAvLyBJbmplY3QgZGF0YSBnZW5lcmF0ZWQgZnJvbSBmYWxsYmFjayBwYXRoIGludG8gdGhlIHN5bnRoZXRpYyBldmVudC5cbiAgICAgICAgLy8gVGhpcyBtYXRjaGVzIHRoZSBwcm9wZXJ0eSBvZiBuYXRpdmUgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZS5cbiAgICAgICAgZXZlbnQuZGF0YSA9IGRhdGE7XG4gICAgICB9XG4gICAgICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb3NpdGlvbkV2ZW50UGx1Z2luO1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBET01DaGlsZHJlbk9wZXJhdGlvbnNcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBEYW5nZXIgPSByZXF1aXJlKFwiLi9EYW5nZXJcIik7XG52YXIgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMgPSByZXF1aXJlKFwiLi9SZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlc1wiKTtcblxudmFyIGdldFRleHRDb250ZW50QWNjZXNzb3IgPSByZXF1aXJlKFwiLi9nZXRUZXh0Q29udGVudEFjY2Vzc29yXCIpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcblxuLyoqXG4gKiBUaGUgRE9NIHByb3BlcnR5IHRvIHVzZSB3aGVuIHNldHRpbmcgdGV4dCBjb250ZW50LlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgdGV4dENvbnRlbnRBY2Nlc3NvciA9IGdldFRleHRDb250ZW50QWNjZXNzb3IoKTtcblxuLyoqXG4gKiBJbnNlcnRzIGBjaGlsZE5vZGVgIGFzIGEgY2hpbGQgb2YgYHBhcmVudE5vZGVgIGF0IHRoZSBgaW5kZXhgLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gcGFyZW50Tm9kZSBQYXJlbnQgbm9kZSBpbiB3aGljaCB0byBpbnNlcnQuXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNoaWxkTm9kZSBDaGlsZCBub2RlIHRvIGluc2VydC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBhdCB3aGljaCB0byBpbnNlcnQgdGhlIGNoaWxkLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGluc2VydENoaWxkQXQocGFyZW50Tm9kZSwgY2hpbGROb2RlLCBpbmRleCkge1xuICAvLyBCeSBleHBsb2l0aW5nIGFycmF5cyByZXR1cm5pbmcgYHVuZGVmaW5lZGAgZm9yIGFuIHVuZGVmaW5lZCBpbmRleCwgd2UgY2FuXG4gIC8vIHJlbHkgZXhjbHVzaXZlbHkgb24gYGluc2VydEJlZm9yZShub2RlLCBudWxsKWAgaW5zdGVhZCBvZiBhbHNvIHVzaW5nXG4gIC8vIGBhcHBlbmRDaGlsZChub2RlKWAuIEhvd2V2ZXIsIHVzaW5nIGB1bmRlZmluZWRgIGlzIG5vdCBhbGxvd2VkIGJ5IGFsbFxuICAvLyBicm93c2VycyBzbyB3ZSBtdXN0IHJlcGxhY2UgaXQgd2l0aCBgbnVsbGAuXG4gIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKFxuICAgIGNoaWxkTm9kZSxcbiAgICBwYXJlbnROb2RlLmNoaWxkTm9kZXNbaW5kZXhdIHx8IG51bGxcbiAgKTtcbn1cblxudmFyIHVwZGF0ZVRleHRDb250ZW50O1xuaWYgKHRleHRDb250ZW50QWNjZXNzb3IgPT09ICd0ZXh0Q29udGVudCcpIHtcbiAgLyoqXG4gICAqIFNldHMgdGhlIHRleHQgY29udGVudCBvZiBgbm9kZWAgdG8gYHRleHRgLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGUgTm9kZSB0byBjaGFuZ2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgTmV3IHRleHQgY29udGVudFxuICAgKi9cbiAgdXBkYXRlVGV4dENvbnRlbnQgPSBmdW5jdGlvbihub2RlLCB0ZXh0KSB7XG4gICAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG4gIH07XG59IGVsc2Uge1xuICAvKipcbiAgICogU2V0cyB0aGUgdGV4dCBjb250ZW50IG9mIGBub2RlYCB0byBgdGV4dGAuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZSBOb2RlIHRvIGNoYW5nZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBOZXcgdGV4dCBjb250ZW50XG4gICAqL1xuICB1cGRhdGVUZXh0Q29udGVudCA9IGZ1bmN0aW9uKG5vZGUsIHRleHQpIHtcbiAgICAvLyBJbiBvcmRlciB0byBwcmVzZXJ2ZSBuZXdsaW5lcyBjb3JyZWN0bHksIHdlIGNhbid0IHVzZSAuaW5uZXJUZXh0IHRvIHNldFxuICAgIC8vIHRoZSBjb250ZW50cyAoc2VlICMxMDgwKSwgc28gd2UgZW1wdHkgdGhlIGVsZW1lbnQgdGhlbiBhcHBlbmQgYSB0ZXh0IG5vZGVcbiAgICB3aGlsZSAobm9kZS5maXJzdENoaWxkKSB7XG4gICAgICBub2RlLnJlbW92ZUNoaWxkKG5vZGUuZmlyc3RDaGlsZCk7XG4gICAgfVxuICAgIGlmICh0ZXh0KSB7XG4gICAgICB2YXIgZG9jID0gbm9kZS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50O1xuICAgICAgbm9kZS5hcHBlbmRDaGlsZChkb2MuY3JlYXRlVGV4dE5vZGUodGV4dCkpO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBPcGVyYXRpb25zIGZvciB1cGRhdGluZyB3aXRoIERPTSBjaGlsZHJlbi5cbiAqL1xudmFyIERPTUNoaWxkcmVuT3BlcmF0aW9ucyA9IHtcblxuICBkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cDogRGFuZ2VyLmRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwLFxuXG4gIHVwZGF0ZVRleHRDb250ZW50OiB1cGRhdGVUZXh0Q29udGVudCxcblxuICAvKipcbiAgICogVXBkYXRlcyBhIGNvbXBvbmVudCdzIGNoaWxkcmVuIGJ5IHByb2Nlc3NpbmcgYSBzZXJpZXMgb2YgdXBkYXRlcy4gVGhlXG4gICAqIHVwZGF0ZSBjb25maWd1cmF0aW9ucyBhcmUgZWFjaCBleHBlY3RlZCB0byBoYXZlIGEgYHBhcmVudE5vZGVgIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge2FycmF5PG9iamVjdD59IHVwZGF0ZXMgTGlzdCBvZiB1cGRhdGUgY29uZmlndXJhdGlvbnMuXG4gICAqIEBwYXJhbSB7YXJyYXk8c3RyaW5nPn0gbWFya3VwTGlzdCBMaXN0IG9mIG1hcmt1cCBzdHJpbmdzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByb2Nlc3NVcGRhdGVzOiBmdW5jdGlvbih1cGRhdGVzLCBtYXJrdXBMaXN0KSB7XG4gICAgdmFyIHVwZGF0ZTtcbiAgICAvLyBNYXBwaW5nIGZyb20gcGFyZW50IElEcyB0byBpbml0aWFsIGNoaWxkIG9yZGVyaW5ncy5cbiAgICB2YXIgaW5pdGlhbENoaWxkcmVuID0gbnVsbDtcbiAgICAvLyBMaXN0IG9mIGNoaWxkcmVuIHRoYXQgd2lsbCBiZSBtb3ZlZCBvciByZW1vdmVkLlxuICAgIHZhciB1cGRhdGVkQ2hpbGRyZW4gPSBudWxsO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IHVwZGF0ZSA9IHVwZGF0ZXNbaV07IGkrKykge1xuICAgICAgaWYgKHVwZGF0ZS50eXBlID09PSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5NT1ZFX0VYSVNUSU5HIHx8XG4gICAgICAgICAgdXBkYXRlLnR5cGUgPT09IFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLlJFTU9WRV9OT0RFKSB7XG4gICAgICAgIHZhciB1cGRhdGVkSW5kZXggPSB1cGRhdGUuZnJvbUluZGV4O1xuICAgICAgICB2YXIgdXBkYXRlZENoaWxkID0gdXBkYXRlLnBhcmVudE5vZGUuY2hpbGROb2Rlc1t1cGRhdGVkSW5kZXhdO1xuICAgICAgICB2YXIgcGFyZW50SUQgPSB1cGRhdGUucGFyZW50SUQ7XG5cbiAgICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICAgICB1cGRhdGVkQ2hpbGQsXG4gICAgICAgICAgJ3Byb2Nlc3NVcGRhdGVzKCk6IFVuYWJsZSB0byBmaW5kIGNoaWxkICVzIG9mIGVsZW1lbnQuIFRoaXMgJyArXG4gICAgICAgICAgJ3Byb2JhYmx5IG1lYW5zIHRoZSBET00gd2FzIHVuZXhwZWN0ZWRseSBtdXRhdGVkIChlLmcuLCBieSB0aGUgJyArXG4gICAgICAgICAgJ2Jyb3dzZXIpLCB1c3VhbGx5IGR1ZSB0byBmb3JnZXR0aW5nIGEgPHRib2R5PiB3aGVuIHVzaW5nIHRhYmxlcywgJyArXG4gICAgICAgICAgJ25lc3RpbmcgPHA+IG9yIDxhPiB0YWdzLCBvciB1c2luZyBub24tU1ZHIGVsZW1lbnRzIGluIGFuIDxzdmc+ICcrXG4gICAgICAgICAgJ3BhcmVudC4gVHJ5IGluc3BlY3RpbmcgdGhlIGNoaWxkIG5vZGVzIG9mIHRoZSBlbGVtZW50IHdpdGggUmVhY3QgJyArXG4gICAgICAgICAgJ0lEIGAlc2AuJyxcbiAgICAgICAgICB1cGRhdGVkSW5kZXgsXG4gICAgICAgICAgcGFyZW50SURcbiAgICAgICAgKSA6IGludmFyaWFudCh1cGRhdGVkQ2hpbGQpKTtcblxuICAgICAgICBpbml0aWFsQ2hpbGRyZW4gPSBpbml0aWFsQ2hpbGRyZW4gfHwge307XG4gICAgICAgIGluaXRpYWxDaGlsZHJlbltwYXJlbnRJRF0gPSBpbml0aWFsQ2hpbGRyZW5bcGFyZW50SURdIHx8IFtdO1xuICAgICAgICBpbml0aWFsQ2hpbGRyZW5bcGFyZW50SURdW3VwZGF0ZWRJbmRleF0gPSB1cGRhdGVkQ2hpbGQ7XG5cbiAgICAgICAgdXBkYXRlZENoaWxkcmVuID0gdXBkYXRlZENoaWxkcmVuIHx8IFtdO1xuICAgICAgICB1cGRhdGVkQ2hpbGRyZW4ucHVzaCh1cGRhdGVkQ2hpbGQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZW5kZXJlZE1hcmt1cCA9IERhbmdlci5kYW5nZXJvdXNseVJlbmRlck1hcmt1cChtYXJrdXBMaXN0KTtcblxuICAgIC8vIFJlbW92ZSB1cGRhdGVkIGNoaWxkcmVuIGZpcnN0IHNvIHRoYXQgYHRvSW5kZXhgIGlzIGNvbnNpc3RlbnQuXG4gICAgaWYgKHVwZGF0ZWRDaGlsZHJlbikge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB1cGRhdGVkQ2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdXBkYXRlZENoaWxkcmVuW2pdLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodXBkYXRlZENoaWxkcmVuW2pdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBrID0gMDsgdXBkYXRlID0gdXBkYXRlc1trXTsgaysrKSB7XG4gICAgICBzd2l0Y2ggKHVwZGF0ZS50eXBlKSB7XG4gICAgICAgIGNhc2UgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuSU5TRVJUX01BUktVUDpcbiAgICAgICAgICBpbnNlcnRDaGlsZEF0KFxuICAgICAgICAgICAgdXBkYXRlLnBhcmVudE5vZGUsXG4gICAgICAgICAgICByZW5kZXJlZE1hcmt1cFt1cGRhdGUubWFya3VwSW5kZXhdLFxuICAgICAgICAgICAgdXBkYXRlLnRvSW5kZXhcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLk1PVkVfRVhJU1RJTkc6XG4gICAgICAgICAgaW5zZXJ0Q2hpbGRBdChcbiAgICAgICAgICAgIHVwZGF0ZS5wYXJlbnROb2RlLFxuICAgICAgICAgICAgaW5pdGlhbENoaWxkcmVuW3VwZGF0ZS5wYXJlbnRJRF1bdXBkYXRlLmZyb21JbmRleF0sXG4gICAgICAgICAgICB1cGRhdGUudG9JbmRleFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuVEVYVF9DT05URU5UOlxuICAgICAgICAgIHVwZGF0ZVRleHRDb250ZW50KFxuICAgICAgICAgICAgdXBkYXRlLnBhcmVudE5vZGUsXG4gICAgICAgICAgICB1cGRhdGUudGV4dENvbnRlbnRcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLlJFTU9WRV9OT0RFOlxuICAgICAgICAgIC8vIEFscmVhZHkgcmVtb3ZlZCBieSB0aGUgZm9yLWxvb3AgYWJvdmUuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRE9NQ2hpbGRyZW5PcGVyYXRpb25zO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERPTVByb3BlcnR5XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbi8qanNsaW50IGJpdHdpc2U6IHRydWUgKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbnZhciBET01Qcm9wZXJ0eUluamVjdGlvbiA9IHtcbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSBub3JtYWxpemVkLCBjYW1lbGNhc2VkIHByb3BlcnR5IG5hbWVzIHRvIGEgY29uZmlndXJhdGlvbiB0aGF0XG4gICAqIHNwZWNpZmllcyBob3cgdGhlIGFzc29jaWF0ZWQgRE9NIHByb3BlcnR5IHNob3VsZCBiZSBhY2Nlc3NlZCBvciByZW5kZXJlZC5cbiAgICovXG4gIE1VU1RfVVNFX0FUVFJJQlVURTogMHgxLFxuICBNVVNUX1VTRV9QUk9QRVJUWTogMHgyLFxuICBIQVNfU0lERV9FRkZFQ1RTOiAweDQsXG4gIEhBU19CT09MRUFOX1ZBTFVFOiAweDgsXG4gIEhBU19OVU1FUklDX1ZBTFVFOiAweDEwLFxuICBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRTogMHgyMCB8IDB4MTAsXG4gIEhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUU6IDB4NDAsXG5cbiAgLyoqXG4gICAqIEluamVjdCBzb21lIHNwZWNpYWxpemVkIGtub3dsZWRnZSBhYm91dCB0aGUgRE9NLiBUaGlzIHRha2VzIGEgY29uZmlnIG9iamVjdFxuICAgKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogaXNDdXN0b21BdHRyaWJ1dGU6IGZ1bmN0aW9uIHRoYXQgZ2l2ZW4gYW4gYXR0cmlidXRlIG5hbWUgd2lsbCByZXR1cm4gdHJ1ZVxuICAgKiBpZiBpdCBjYW4gYmUgaW5zZXJ0ZWQgaW50byB0aGUgRE9NIHZlcmJhdGltLiBVc2VmdWwgZm9yIGRhdGEtKiBvciBhcmlhLSpcbiAgICogYXR0cmlidXRlcyB3aGVyZSBpdCdzIGltcG9zc2libGUgdG8gZW51bWVyYXRlIGFsbCBvZiB0aGUgcG9zc2libGVcbiAgICogYXR0cmlidXRlIG5hbWVzLFxuICAgKlxuICAgKiBQcm9wZXJ0aWVzOiBvYmplY3QgbWFwcGluZyBET00gcHJvcGVydHkgbmFtZSB0byBvbmUgb2YgdGhlXG4gICAqIERPTVByb3BlcnR5SW5qZWN0aW9uIGNvbnN0YW50cyBvciBudWxsLiBJZiB5b3VyIGF0dHJpYnV0ZSBpc24ndCBpbiBoZXJlLFxuICAgKiBpdCB3b24ndCBnZXQgd3JpdHRlbiB0byB0aGUgRE9NLlxuICAgKlxuICAgKiBET01BdHRyaWJ1dGVOYW1lczogb2JqZWN0IG1hcHBpbmcgUmVhY3QgYXR0cmlidXRlIG5hbWUgdG8gdGhlIERPTVxuICAgKiBhdHRyaWJ1dGUgbmFtZS4gQXR0cmlidXRlIG5hbWVzIG5vdCBzcGVjaWZpZWQgdXNlIHRoZSAqKmxvd2VyY2FzZSoqXG4gICAqIG5vcm1hbGl6ZWQgbmFtZS5cbiAgICpcbiAgICogRE9NUHJvcGVydHlOYW1lczogc2ltaWxhciB0byBET01BdHRyaWJ1dGVOYW1lcyBidXQgZm9yIERPTSBwcm9wZXJ0aWVzLlxuICAgKiBQcm9wZXJ0eSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSB0aGUgbm9ybWFsaXplZCBuYW1lLlxuICAgKlxuICAgKiBET01NdXRhdGlvbk1ldGhvZHM6IFByb3BlcnRpZXMgdGhhdCByZXF1aXJlIHNwZWNpYWwgbXV0YXRpb24gbWV0aG9kcy4gSWZcbiAgICogYHZhbHVlYCBpcyB1bmRlZmluZWQsIHRoZSBtdXRhdGlvbiBtZXRob2Qgc2hvdWxkIHVuc2V0IHRoZSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGRvbVByb3BlcnR5Q29uZmlnIHRoZSBjb25maWcgYXMgZGVzY3JpYmVkIGFib3ZlLlxuICAgKi9cbiAgaW5qZWN0RE9NUHJvcGVydHlDb25maWc6IGZ1bmN0aW9uKGRvbVByb3BlcnR5Q29uZmlnKSB7XG4gICAgdmFyIFByb3BlcnRpZXMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5Qcm9wZXJ0aWVzIHx8IHt9O1xuICAgIHZhciBET01BdHRyaWJ1dGVOYW1lcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTUF0dHJpYnV0ZU5hbWVzIHx8IHt9O1xuICAgIHZhciBET01Qcm9wZXJ0eU5hbWVzID0gZG9tUHJvcGVydHlDb25maWcuRE9NUHJvcGVydHlOYW1lcyB8fCB7fTtcbiAgICB2YXIgRE9NTXV0YXRpb25NZXRob2RzID0gZG9tUHJvcGVydHlDb25maWcuRE9NTXV0YXRpb25NZXRob2RzIHx8IHt9O1xuXG4gICAgaWYgKGRvbVByb3BlcnR5Q29uZmlnLmlzQ3VzdG9tQXR0cmlidXRlKSB7XG4gICAgICBET01Qcm9wZXJ0eS5faXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnMucHVzaChcbiAgICAgICAgZG9tUHJvcGVydHlDb25maWcuaXNDdXN0b21BdHRyaWJ1dGVcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gUHJvcGVydGllcykge1xuICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICAgIURPTVByb3BlcnR5LmlzU3RhbmRhcmROYW1lLmhhc093blByb3BlcnR5KHByb3BOYW1lKSxcbiAgICAgICAgJ2luamVjdERPTVByb3BlcnR5Q29uZmlnKC4uLik6IFlvdVxcJ3JlIHRyeWluZyB0byBpbmplY3QgRE9NIHByb3BlcnR5ICcgK1xuICAgICAgICAnXFwnJXNcXCcgd2hpY2ggaGFzIGFscmVhZHkgYmVlbiBpbmplY3RlZC4gWW91IG1heSBiZSBhY2NpZGVudGFsbHkgJyArXG4gICAgICAgICdpbmplY3RpbmcgdGhlIHNhbWUgRE9NIHByb3BlcnR5IGNvbmZpZyB0d2ljZSwgb3IgeW91IG1heSBiZSAnICtcbiAgICAgICAgJ2luamVjdGluZyB0d28gY29uZmlncyB0aGF0IGhhdmUgY29uZmxpY3RpbmcgcHJvcGVydHkgbmFtZXMuJyxcbiAgICAgICAgcHJvcE5hbWVcbiAgICAgICkgOiBpbnZhcmlhbnQoIURPTVByb3BlcnR5LmlzU3RhbmRhcmROYW1lLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkpO1xuXG4gICAgICBET01Qcm9wZXJ0eS5pc1N0YW5kYXJkTmFtZVtwcm9wTmFtZV0gPSB0cnVlO1xuXG4gICAgICB2YXIgbG93ZXJDYXNlZCA9IHByb3BOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZVtsb3dlckNhc2VkXSA9IHByb3BOYW1lO1xuXG4gICAgICBpZiAoRE9NQXR0cmlidXRlTmFtZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gRE9NQXR0cmlidXRlTmFtZXNbcHJvcE5hbWVdO1xuICAgICAgICBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZVthdHRyaWJ1dGVOYW1lXSA9IHByb3BOYW1lO1xuICAgICAgICBET01Qcm9wZXJ0eS5nZXRBdHRyaWJ1dGVOYW1lW3Byb3BOYW1lXSA9IGF0dHJpYnV0ZU5hbWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBET01Qcm9wZXJ0eS5nZXRBdHRyaWJ1dGVOYW1lW3Byb3BOYW1lXSA9IGxvd2VyQ2FzZWQ7XG4gICAgICB9XG5cbiAgICAgIERPTVByb3BlcnR5LmdldFByb3BlcnR5TmFtZVtwcm9wTmFtZV0gPVxuICAgICAgICBET01Qcm9wZXJ0eU5hbWVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSA/XG4gICAgICAgICAgRE9NUHJvcGVydHlOYW1lc1twcm9wTmFtZV0gOlxuICAgICAgICAgIHByb3BOYW1lO1xuXG4gICAgICBpZiAoRE9NTXV0YXRpb25NZXRob2RzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBET01Qcm9wZXJ0eS5nZXRNdXRhdGlvbk1ldGhvZFtwcm9wTmFtZV0gPSBET01NdXRhdGlvbk1ldGhvZHNbcHJvcE5hbWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgRE9NUHJvcGVydHkuZ2V0TXV0YXRpb25NZXRob2RbcHJvcE5hbWVdID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHByb3BDb25maWcgPSBQcm9wZXJ0aWVzW3Byb3BOYW1lXTtcbiAgICAgIERPTVByb3BlcnR5Lm11c3RVc2VBdHRyaWJ1dGVbcHJvcE5hbWVdID1cbiAgICAgICAgcHJvcENvbmZpZyAmIERPTVByb3BlcnR5SW5qZWN0aW9uLk1VU1RfVVNFX0FUVFJJQlVURTtcbiAgICAgIERPTVByb3BlcnR5Lm11c3RVc2VQcm9wZXJ0eVtwcm9wTmFtZV0gPVxuICAgICAgICBwcm9wQ29uZmlnICYgRE9NUHJvcGVydHlJbmplY3Rpb24uTVVTVF9VU0VfUFJPUEVSVFk7XG4gICAgICBET01Qcm9wZXJ0eS5oYXNTaWRlRWZmZWN0c1twcm9wTmFtZV0gPVxuICAgICAgICBwcm9wQ29uZmlnICYgRE9NUHJvcGVydHlJbmplY3Rpb24uSEFTX1NJREVfRUZGRUNUUztcbiAgICAgIERPTVByb3BlcnR5Lmhhc0Jvb2xlYW5WYWx1ZVtwcm9wTmFtZV0gPVxuICAgICAgICBwcm9wQ29uZmlnICYgRE9NUHJvcGVydHlJbmplY3Rpb24uSEFTX0JPT0xFQU5fVkFMVUU7XG4gICAgICBET01Qcm9wZXJ0eS5oYXNOdW1lcmljVmFsdWVbcHJvcE5hbWVdID1cbiAgICAgICAgcHJvcENvbmZpZyAmIERPTVByb3BlcnR5SW5qZWN0aW9uLkhBU19OVU1FUklDX1ZBTFVFO1xuICAgICAgRE9NUHJvcGVydHkuaGFzUG9zaXRpdmVOdW1lcmljVmFsdWVbcHJvcE5hbWVdID1cbiAgICAgICAgcHJvcENvbmZpZyAmIERPTVByb3BlcnR5SW5qZWN0aW9uLkhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFO1xuICAgICAgRE9NUHJvcGVydHkuaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZVtwcm9wTmFtZV0gPVxuICAgICAgICBwcm9wQ29uZmlnICYgRE9NUHJvcGVydHlJbmplY3Rpb24uSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRTtcblxuICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICAgIURPTVByb3BlcnR5Lm11c3RVc2VBdHRyaWJ1dGVbcHJvcE5hbWVdIHx8XG4gICAgICAgICAgIURPTVByb3BlcnR5Lm11c3RVc2VQcm9wZXJ0eVtwcm9wTmFtZV0sXG4gICAgICAgICdET01Qcm9wZXJ0eTogQ2Fubm90IHJlcXVpcmUgdXNpbmcgYm90aCBhdHRyaWJ1dGUgYW5kIHByb3BlcnR5OiAlcycsXG4gICAgICAgIHByb3BOYW1lXG4gICAgICApIDogaW52YXJpYW50KCFET01Qcm9wZXJ0eS5tdXN0VXNlQXR0cmlidXRlW3Byb3BOYW1lXSB8fFxuICAgICAgICAhRE9NUHJvcGVydHkubXVzdFVzZVByb3BlcnR5W3Byb3BOYW1lXSkpO1xuICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICAgRE9NUHJvcGVydHkubXVzdFVzZVByb3BlcnR5W3Byb3BOYW1lXSB8fFxuICAgICAgICAgICFET01Qcm9wZXJ0eS5oYXNTaWRlRWZmZWN0c1twcm9wTmFtZV0sXG4gICAgICAgICdET01Qcm9wZXJ0eTogUHJvcGVydGllcyB0aGF0IGhhdmUgc2lkZSBlZmZlY3RzIG11c3QgdXNlIHByb3BlcnR5OiAlcycsXG4gICAgICAgIHByb3BOYW1lXG4gICAgICApIDogaW52YXJpYW50KERPTVByb3BlcnR5Lm11c3RVc2VQcm9wZXJ0eVtwcm9wTmFtZV0gfHxcbiAgICAgICAgIURPTVByb3BlcnR5Lmhhc1NpZGVFZmZlY3RzW3Byb3BOYW1lXSkpO1xuICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICAgISFET01Qcm9wZXJ0eS5oYXNCb29sZWFuVmFsdWVbcHJvcE5hbWVdICtcbiAgICAgICAgICAhIURPTVByb3BlcnR5Lmhhc051bWVyaWNWYWx1ZVtwcm9wTmFtZV0gK1xuICAgICAgICAgICEhRE9NUHJvcGVydHkuaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZVtwcm9wTmFtZV0gPD0gMSxcbiAgICAgICAgJ0RPTVByb3BlcnR5OiBWYWx1ZSBjYW4gYmUgb25lIG9mIGJvb2xlYW4sIG92ZXJsb2FkZWQgYm9vbGVhbiwgb3IgJyArXG4gICAgICAgICdudW1lcmljIHZhbHVlLCBidXQgbm90IGEgY29tYmluYXRpb246ICVzJyxcbiAgICAgICAgcHJvcE5hbWVcbiAgICAgICkgOiBpbnZhcmlhbnQoISFET01Qcm9wZXJ0eS5oYXNCb29sZWFuVmFsdWVbcHJvcE5hbWVdICtcbiAgICAgICAgISFET01Qcm9wZXJ0eS5oYXNOdW1lcmljVmFsdWVbcHJvcE5hbWVdICtcbiAgICAgICAgISFET01Qcm9wZXJ0eS5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlW3Byb3BOYW1lXSA8PSAxKSk7XG4gICAgfVxuICB9XG59O1xudmFyIGRlZmF1bHRWYWx1ZUNhY2hlID0ge307XG5cbi8qKlxuICogRE9NUHJvcGVydHkgZXhwb3J0cyBsb29rdXAgb2JqZWN0cyB0aGF0IGNhbiBiZSB1c2VkIGxpa2UgZnVuY3Rpb25zOlxuICpcbiAqICAgPiBET01Qcm9wZXJ0eS5pc1ZhbGlkWydpZCddXG4gKiAgIHRydWVcbiAqICAgPiBET01Qcm9wZXJ0eS5pc1ZhbGlkWydmb29iYXInXVxuICogICB1bmRlZmluZWRcbiAqXG4gKiBBbHRob3VnaCB0aGlzIG1heSBiZSBjb25mdXNpbmcsIGl0IHBlcmZvcm1zIGJldHRlciBpbiBnZW5lcmFsLlxuICpcbiAqIEBzZWUgaHR0cDovL2pzcGVyZi5jb20va2V5LWV4aXN0c1xuICogQHNlZSBodHRwOi8vanNwZXJmLmNvbS9rZXktbWlzc2luZ1xuICovXG52YXIgRE9NUHJvcGVydHkgPSB7XG5cbiAgSURfQVRUUklCVVRFX05BTUU6ICdkYXRhLXJlYWN0aWQnLFxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBhIHByb3BlcnR5IG5hbWUgaXMgYSBzdGFuZGFyZCBwcm9wZXJ0eS5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIGlzU3RhbmRhcmROYW1lOiB7fSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIGxvd2VyY2FzZSBwcm9wZXJ0eSBuYW1lcyB0byB0aGUgcHJvcGVybHkgY2FzZWQgdmVyc2lvbiwgdXNlZFxuICAgKiB0byB3YXJuIGluIHRoZSBjYXNlIG9mIG1pc3NpbmcgcHJvcGVydGllcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIGdldFBvc3NpYmxlU3RhbmRhcmROYW1lOiB7fSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIG5vcm1hbGl6ZWQgbmFtZXMgdG8gYXR0cmlidXRlIG5hbWVzIHRoYXQgZGlmZmVyLiBBdHRyaWJ1dGVcbiAgICogbmFtZXMgYXJlIHVzZWQgd2hlbiByZW5kZXJpbmcgbWFya3VwIG9yIHdpdGggYCpBdHRyaWJ1dGUoKWAuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBnZXRBdHRyaWJ1dGVOYW1lOiB7fSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIG5vcm1hbGl6ZWQgbmFtZXMgdG8gcHJvcGVydGllcyBvbiBET00gbm9kZSBpbnN0YW5jZXMuXG4gICAqIChUaGlzIGluY2x1ZGVzIHByb3BlcnRpZXMgdGhhdCBtdXRhdGUgZHVlIHRvIGV4dGVybmFsIGZhY3RvcnMuKVxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0UHJvcGVydHlOYW1lOiB7fSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIG5vcm1hbGl6ZWQgbmFtZXMgdG8gbXV0YXRpb24gbWV0aG9kcy4gVGhpcyB3aWxsIG9ubHkgZXhpc3QgaWZcbiAgICogbXV0YXRpb24gY2Fubm90IGJlIHNldCBzaW1wbHkgYnkgdGhlIHByb3BlcnR5IG9yIGBzZXRBdHRyaWJ1dGUoKWAuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBnZXRNdXRhdGlvbk1ldGhvZDoge30sXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgYWNjZXNzZWQgYW5kIG11dGF0ZWQgYXMgYW4gb2JqZWN0IHByb3BlcnR5LlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgbXVzdFVzZUF0dHJpYnV0ZToge30sXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgYWNjZXNzZWQgYW5kIG11dGF0ZWQgdXNpbmcgYCpBdHRyaWJ1dGUoKWAuXG4gICAqIChUaGlzIGluY2x1ZGVzIGFueXRoaW5nIHRoYXQgZmFpbHMgYDxwcm9wTmFtZT4gaW4gPGVsZW1lbnQ+YC4pXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBtdXN0VXNlUHJvcGVydHk6IHt9LFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIG9yIG5vdCBzZXR0aW5nIGEgdmFsdWUgY2F1c2VzIHNpZGUgZWZmZWN0cyBzdWNoIGFzIHRyaWdnZXJpbmdcbiAgICogcmVzb3VyY2VzIHRvIGJlIGxvYWRlZCBvciB0ZXh0IHNlbGVjdGlvbiBjaGFuZ2VzLiBXZSBtdXN0IGVuc3VyZSB0aGF0XG4gICAqIHRoZSB2YWx1ZSBpcyBvbmx5IHNldCBpZiBpdCBoYXMgY2hhbmdlZC5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIGhhc1NpZGVFZmZlY3RzOiB7fSxcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBoYXNCb29sZWFuVmFsdWU6IHt9LFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIG51bWVyaWMgb3IgcGFyc2UgYXMgYVxuICAgKiBudW1lcmljIGFuZCBzaG91bGQgYmUgcmVtb3ZlZCB3aGVuIHNldCB0byBhIGZhbHNleSB2YWx1ZS5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIGhhc051bWVyaWNWYWx1ZToge30sXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgcG9zaXRpdmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIHBvc2l0aXZlXG4gICAqIG51bWVyaWMgYW5kIHNob3VsZCBiZSByZW1vdmVkIHdoZW4gc2V0IHRvIGEgZmFsc2V5IHZhbHVlLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgaGFzUG9zaXRpdmVOdW1lcmljVmFsdWU6IHt9LFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBjYW4gYmUgdXNlZCBhcyBhIGZsYWcgYXMgd2VsbCBhcyB3aXRoIGEgdmFsdWUuIFJlbW92ZWRcbiAgICogd2hlbiBzdHJpY3RseSBlcXVhbCB0byBmYWxzZTsgcHJlc2VudCB3aXRob3V0IGEgdmFsdWUgd2hlbiBzdHJpY3RseSBlcXVhbFxuICAgKiB0byB0cnVlOyBwcmVzZW50IHdpdGggYSB2YWx1ZSBvdGhlcndpc2UuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBoYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlOiB7fSxcblxuICAvKipcbiAgICogQWxsIG9mIHRoZSBpc0N1c3RvbUF0dHJpYnV0ZSgpIGZ1bmN0aW9ucyB0aGF0IGhhdmUgYmVlbiBpbmplY3RlZC5cbiAgICovXG4gIF9pc0N1c3RvbUF0dHJpYnV0ZUZ1bmN0aW9uczogW10sXG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIGEgcHJvcGVydHkgbmFtZSBpcyBhIGN1c3RvbSBhdHRyaWJ1dGUuXG4gICAqIEBtZXRob2RcbiAgICovXG4gIGlzQ3VzdG9tQXR0cmlidXRlOiBmdW5jdGlvbihhdHRyaWJ1dGVOYW1lKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBET01Qcm9wZXJ0eS5faXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpc0N1c3RvbUF0dHJpYnV0ZUZuID0gRE9NUHJvcGVydHkuX2lzQ3VzdG9tQXR0cmlidXRlRnVuY3Rpb25zW2ldO1xuICAgICAgaWYgKGlzQ3VzdG9tQXR0cmlidXRlRm4oYXR0cmlidXRlTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGVmYXVsdCBwcm9wZXJ0eSB2YWx1ZSBmb3IgYSBET00gcHJvcGVydHkgKGkuZS4sIG5vdCBhblxuICAgKiBhdHRyaWJ1dGUpLiBNb3N0IGRlZmF1bHQgdmFsdWVzIGFyZSAnJyBvciBmYWxzZSwgYnV0IG5vdCBhbGwuIFdvcnNlIHlldCxcbiAgICogc29tZSAoaW4gcGFydGljdWxhciwgYHR5cGVgKSB2YXJ5IGRlcGVuZGluZyBvbiB0aGUgdHlwZSBvZiBlbGVtZW50LlxuICAgKlxuICAgKiBUT0RPOiBJcyBpdCBiZXR0ZXIgdG8gZ3JhYiBhbGwgdGhlIHBvc3NpYmxlIHByb3BlcnRpZXMgd2hlbiBjcmVhdGluZyBhblxuICAgKiBlbGVtZW50IHRvIGF2b2lkIGhhdmluZyB0byBjcmVhdGUgdGhlIHNhbWUgZWxlbWVudCB0d2ljZT9cbiAgICovXG4gIGdldERlZmF1bHRWYWx1ZUZvclByb3BlcnR5OiBmdW5jdGlvbihub2RlTmFtZSwgcHJvcCkge1xuICAgIHZhciBub2RlRGVmYXVsdHMgPSBkZWZhdWx0VmFsdWVDYWNoZVtub2RlTmFtZV07XG4gICAgdmFyIHRlc3RFbGVtZW50O1xuICAgIGlmICghbm9kZURlZmF1bHRzKSB7XG4gICAgICBkZWZhdWx0VmFsdWVDYWNoZVtub2RlTmFtZV0gPSBub2RlRGVmYXVsdHMgPSB7fTtcbiAgICB9XG4gICAgaWYgKCEocHJvcCBpbiBub2RlRGVmYXVsdHMpKSB7XG4gICAgICB0ZXN0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobm9kZU5hbWUpO1xuICAgICAgbm9kZURlZmF1bHRzW3Byb3BdID0gdGVzdEVsZW1lbnRbcHJvcF07XG4gICAgfVxuICAgIHJldHVybiBub2RlRGVmYXVsdHNbcHJvcF07XG4gIH0sXG5cbiAgaW5qZWN0aW9uOiBET01Qcm9wZXJ0eUluamVjdGlvblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBET01Qcm9wZXJ0eTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBET01Qcm9wZXJ0eU9wZXJhdGlvbnNcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoXCIuL0RPTVByb3BlcnR5XCIpO1xuXG52YXIgZXNjYXBlVGV4dEZvckJyb3dzZXIgPSByZXF1aXJlKFwiLi9lc2NhcGVUZXh0Rm9yQnJvd3NlclwiKTtcbnZhciBtZW1vaXplU3RyaW5nT25seSA9IHJlcXVpcmUoXCIuL21lbW9pemVTdHJpbmdPbmx5XCIpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKFwiLi93YXJuaW5nXCIpO1xuXG5mdW5jdGlvbiBzaG91bGRJZ25vcmVWYWx1ZShuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCB8fFxuICAgIChET01Qcm9wZXJ0eS5oYXNCb29sZWFuVmFsdWVbbmFtZV0gJiYgIXZhbHVlKSB8fFxuICAgIChET01Qcm9wZXJ0eS5oYXNOdW1lcmljVmFsdWVbbmFtZV0gJiYgaXNOYU4odmFsdWUpKSB8fFxuICAgIChET01Qcm9wZXJ0eS5oYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZVtuYW1lXSAmJiAodmFsdWUgPCAxKSkgfHxcbiAgICAoRE9NUHJvcGVydHkuaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZVtuYW1lXSAmJiB2YWx1ZSA9PT0gZmFsc2UpO1xufVxuXG52YXIgcHJvY2Vzc0F0dHJpYnV0ZU5hbWVBbmRQcmVmaXggPSBtZW1vaXplU3RyaW5nT25seShmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiBlc2NhcGVUZXh0Rm9yQnJvd3NlcihuYW1lKSArICc9XCInO1xufSk7XG5cbmlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgdmFyIHJlYWN0UHJvcHMgPSB7XG4gICAgY2hpbGRyZW46IHRydWUsXG4gICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHRydWUsXG4gICAga2V5OiB0cnVlLFxuICAgIHJlZjogdHJ1ZVxuICB9O1xuICB2YXIgd2FybmVkUHJvcGVydGllcyA9IHt9O1xuXG4gIHZhciB3YXJuVW5rbm93blByb3BlcnR5ID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGlmIChyZWFjdFByb3BzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHJlYWN0UHJvcHNbbmFtZV0gfHxcbiAgICAgICAgd2FybmVkUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgLy8gZGF0YS0qIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGxvd2VyY2FzZTsgc3VnZ2VzdCB0aGUgbG93ZXJjYXNlIHZlcnNpb25cbiAgICB2YXIgc3RhbmRhcmROYW1lID0gKFxuICAgICAgRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUobG93ZXJDYXNlZE5hbWUpID9cbiAgICAgICAgbG93ZXJDYXNlZE5hbWUgOlxuICAgICAgRE9NUHJvcGVydHkuZ2V0UG9zc2libGVTdGFuZGFyZE5hbWUuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpID9cbiAgICAgICAgRE9NUHJvcGVydHkuZ2V0UG9zc2libGVTdGFuZGFyZE5hbWVbbG93ZXJDYXNlZE5hbWVdIDpcbiAgICAgICAgbnVsbFxuICAgICk7XG5cbiAgICAvLyBGb3Igbm93LCBvbmx5IHdhcm4gd2hlbiB3ZSBoYXZlIGEgc3VnZ2VzdGVkIGNvcnJlY3Rpb24uIFRoaXMgcHJldmVudHNcbiAgICAvLyBsb2dnaW5nIHRvbyBtdWNoIHdoZW4gdXNpbmcgdHJhbnNmZXJQcm9wc1RvLlxuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKFxuICAgICAgc3RhbmRhcmROYW1lID09IG51bGwsXG4gICAgICAnVW5rbm93biBET00gcHJvcGVydHkgJyArIG5hbWUgKyAnLiBEaWQgeW91IG1lYW4gJyArIHN0YW5kYXJkTmFtZSArICc/J1xuICAgICkgOiBudWxsKTtcblxuICB9O1xufVxuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBET00gcHJvcGVydGllcy5cbiAqL1xudmFyIERPTVByb3BlcnR5T3BlcmF0aW9ucyA9IHtcblxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIHRoZSBJRCBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFVuZXNjYXBlZCBJRC5cbiAgICogQHJldHVybiB7c3RyaW5nfSBNYXJrdXAgc3RyaW5nLlxuICAgKi9cbiAgY3JlYXRlTWFya3VwRm9ySUQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgcmV0dXJuIHByb2Nlc3NBdHRyaWJ1dGVOYW1lQW5kUHJlZml4KERPTVByb3BlcnR5LklEX0FUVFJJQlVURV9OQU1FKSArXG4gICAgICBlc2NhcGVUZXh0Rm9yQnJvd3NlcihpZCkgKyAnXCInO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIG1hcmt1cCBmb3IgYSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcmV0dXJuIHs/c3RyaW5nfSBNYXJrdXAgc3RyaW5nLCBvciBudWxsIGlmIHRoZSBwcm9wZXJ0eSB3YXMgaW52YWxpZC5cbiAgICovXG4gIGNyZWF0ZU1hcmt1cEZvclByb3BlcnR5OiBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChET01Qcm9wZXJ0eS5pc1N0YW5kYXJkTmFtZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJlxuICAgICAgICBET01Qcm9wZXJ0eS5pc1N0YW5kYXJkTmFtZVtuYW1lXSkge1xuICAgICAgaWYgKHNob3VsZElnbm9yZVZhbHVlKG5hbWUsIHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IERPTVByb3BlcnR5LmdldEF0dHJpYnV0ZU5hbWVbbmFtZV07XG4gICAgICBpZiAoRE9NUHJvcGVydHkuaGFzQm9vbGVhblZhbHVlW25hbWVdIHx8XG4gICAgICAgICAgKERPTVByb3BlcnR5Lmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWVbbmFtZV0gJiYgdmFsdWUgPT09IHRydWUpKSB7XG4gICAgICAgIHJldHVybiBlc2NhcGVUZXh0Rm9yQnJvd3NlcihhdHRyaWJ1dGVOYW1lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcm9jZXNzQXR0cmlidXRlTmFtZUFuZFByZWZpeChhdHRyaWJ1dGVOYW1lKSArXG4gICAgICAgIGVzY2FwZVRleHRGb3JCcm93c2VyKHZhbHVlKSArICdcIic7XG4gICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb2Nlc3NBdHRyaWJ1dGVOYW1lQW5kUHJlZml4KG5hbWUpICtcbiAgICAgICAgZXNjYXBlVGV4dEZvckJyb3dzZXIodmFsdWUpICsgJ1wiJztcbiAgICB9IGVsc2UgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgd2FyblVua25vd25Qcm9wZXJ0eShuYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIGZvciBhIHByb3BlcnR5IG9uIGEgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICovXG4gIHNldFZhbHVlRm9yUHJvcGVydHk6IGZ1bmN0aW9uKG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKERPTVByb3BlcnR5LmlzU3RhbmRhcmROYW1lLmhhc093blByb3BlcnR5KG5hbWUpICYmXG4gICAgICAgIERPTVByb3BlcnR5LmlzU3RhbmRhcmROYW1lW25hbWVdKSB7XG4gICAgICB2YXIgbXV0YXRpb25NZXRob2QgPSBET01Qcm9wZXJ0eS5nZXRNdXRhdGlvbk1ldGhvZFtuYW1lXTtcbiAgICAgIGlmIChtdXRhdGlvbk1ldGhvZCkge1xuICAgICAgICBtdXRhdGlvbk1ldGhvZChub2RlLCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHNob3VsZElnbm9yZVZhbHVlKG5hbWUsIHZhbHVlKSkge1xuICAgICAgICB0aGlzLmRlbGV0ZVZhbHVlRm9yUHJvcGVydHkobm9kZSwgbmFtZSk7XG4gICAgICB9IGVsc2UgaWYgKERPTVByb3BlcnR5Lm11c3RVc2VBdHRyaWJ1dGVbbmFtZV0pIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoRE9NUHJvcGVydHkuZ2V0QXR0cmlidXRlTmFtZVtuYW1lXSwgJycgKyB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcHJvcE5hbWUgPSBET01Qcm9wZXJ0eS5nZXRQcm9wZXJ0eU5hbWVbbmFtZV07XG4gICAgICAgIGlmICghRE9NUHJvcGVydHkuaGFzU2lkZUVmZmVjdHNbbmFtZV0gfHwgbm9kZVtwcm9wTmFtZV0gIT09IHZhbHVlKSB7XG4gICAgICAgICAgbm9kZVtwcm9wTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgJycgKyB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgIHdhcm5Vbmtub3duUHJvcGVydHkobmFtZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEZWxldGVzIHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKi9cbiAgZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eTogZnVuY3Rpb24obm9kZSwgbmFtZSkge1xuICAgIGlmIChET01Qcm9wZXJ0eS5pc1N0YW5kYXJkTmFtZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJlxuICAgICAgICBET01Qcm9wZXJ0eS5pc1N0YW5kYXJkTmFtZVtuYW1lXSkge1xuICAgICAgdmFyIG11dGF0aW9uTWV0aG9kID0gRE9NUHJvcGVydHkuZ2V0TXV0YXRpb25NZXRob2RbbmFtZV07XG4gICAgICBpZiAobXV0YXRpb25NZXRob2QpIHtcbiAgICAgICAgbXV0YXRpb25NZXRob2Qobm9kZSwgdW5kZWZpbmVkKTtcbiAgICAgIH0gZWxzZSBpZiAoRE9NUHJvcGVydHkubXVzdFVzZUF0dHJpYnV0ZVtuYW1lXSkge1xuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShET01Qcm9wZXJ0eS5nZXRBdHRyaWJ1dGVOYW1lW25hbWVdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwcm9wTmFtZSA9IERPTVByb3BlcnR5LmdldFByb3BlcnR5TmFtZVtuYW1lXTtcbiAgICAgICAgdmFyIGRlZmF1bHRWYWx1ZSA9IERPTVByb3BlcnR5LmdldERlZmF1bHRWYWx1ZUZvclByb3BlcnR5KFxuICAgICAgICAgIG5vZGUubm9kZU5hbWUsXG4gICAgICAgICAgcHJvcE5hbWVcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKCFET01Qcm9wZXJ0eS5oYXNTaWRlRWZmZWN0c1tuYW1lXSB8fFxuICAgICAgICAgICAgbm9kZVtwcm9wTmFtZV0gIT09IGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgIG5vZGVbcHJvcE5hbWVdID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgfSBlbHNlIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgIHdhcm5Vbmtub3duUHJvcGVydHkobmFtZSk7XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRE9NUHJvcGVydHlPcGVyYXRpb25zO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERhbmdlclxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4vKmpzbGludCBldmlsOiB0cnVlLCBzdWI6IHRydWUgKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoXCIuL0V4ZWN1dGlvbkVudmlyb25tZW50XCIpO1xuXG52YXIgY3JlYXRlTm9kZXNGcm9tTWFya3VwID0gcmVxdWlyZShcIi4vY3JlYXRlTm9kZXNGcm9tTWFya3VwXCIpO1xudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKFwiLi9lbXB0eUZ1bmN0aW9uXCIpO1xudmFyIGdldE1hcmt1cFdyYXAgPSByZXF1aXJlKFwiLi9nZXRNYXJrdXBXcmFwXCIpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcblxudmFyIE9QRU5fVEFHX05BTUVfRVhQID0gL14oPFteIFxcLz5dKykvO1xudmFyIFJFU1VMVF9JTkRFWF9BVFRSID0gJ2RhdGEtZGFuZ2VyLWluZGV4JztcblxuLyoqXG4gKiBFeHRyYWN0cyB0aGUgYG5vZGVOYW1lYCBmcm9tIGEgc3RyaW5nIG9mIG1hcmt1cC5cbiAqXG4gKiBOT1RFOiBFeHRyYWN0aW5nIHRoZSBgbm9kZU5hbWVgIGRvZXMgbm90IHJlcXVpcmUgYSByZWd1bGFyIGV4cHJlc3Npb24gbWF0Y2hcbiAqIGJlY2F1c2Ugd2UgbWFrZSBhc3N1bXB0aW9ucyBhYm91dCBSZWFjdC1nZW5lcmF0ZWQgbWFya3VwIChpLmUuIHRoZXJlIGFyZSBub1xuICogc3BhY2VzIHN1cnJvdW5kaW5nIHRoZSBvcGVuaW5nIHRhZyBhbmQgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGF0dHJpYnV0ZSkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBTdHJpbmcgb2YgbWFya3VwLlxuICogQHJldHVybiB7c3RyaW5nfSBOb2RlIG5hbWUgb2YgdGhlIHN1cHBsaWVkIG1hcmt1cC5cbiAqIEBzZWUgaHR0cDovL2pzcGVyZi5jb20vZXh0cmFjdC1ub2RlbmFtZVxuICovXG5mdW5jdGlvbiBnZXROb2RlTmFtZShtYXJrdXApIHtcbiAgcmV0dXJuIG1hcmt1cC5zdWJzdHJpbmcoMSwgbWFya3VwLmluZGV4T2YoJyAnKSk7XG59XG5cbnZhciBEYW5nZXIgPSB7XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgbWFya3VwIGludG8gYW4gYXJyYXkgb2Ygbm9kZXMuIFRoZSBtYXJrdXAgaXMgZXhwZWN0ZWQgdG8gcmVuZGVyXG4gICAqIGludG8gYSBsaXN0IG9mIHJvb3Qgbm9kZXMuIEFsc28sIHRoZSBsZW5ndGggb2YgYHJlc3VsdExpc3RgIGFuZFxuICAgKiBgbWFya3VwTGlzdGAgc2hvdWxkIGJlIHRoZSBzYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge2FycmF5PHN0cmluZz59IG1hcmt1cExpc3QgTGlzdCBvZiBtYXJrdXAgc3RyaW5ncyB0byByZW5kZXIuXG4gICAqIEByZXR1cm4ge2FycmF5PERPTUVsZW1lbnQ+fSBMaXN0IG9mIHJlbmRlcmVkIG5vZGVzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGRhbmdlcm91c2x5UmVuZGVyTWFya3VwOiBmdW5jdGlvbihtYXJrdXBMaXN0KSB7XG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgIEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSxcbiAgICAgICdkYW5nZXJvdXNseVJlbmRlck1hcmt1cCguLi4pOiBDYW5ub3QgcmVuZGVyIG1hcmt1cCBpbiBhIFdvcmtlciAnICtcbiAgICAgICd0aHJlYWQuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIHRoZSBmcmFtZXdvcmsuIFBsZWFzZSByZXBvcnQgJyArXG4gICAgICAnaW1tZWRpYXRlbHkuJ1xuICAgICkgOiBpbnZhcmlhbnQoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSk7XG4gICAgdmFyIG5vZGVOYW1lO1xuICAgIHZhciBtYXJrdXBCeU5vZGVOYW1lID0ge307XG4gICAgLy8gR3JvdXAgbWFya3VwIGJ5IGBub2RlTmFtZWAgaWYgYSB3cmFwIGlzIG5lY2Vzc2FyeSwgZWxzZSBieSAnKicuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXJrdXBMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgICBtYXJrdXBMaXN0W2ldLFxuICAgICAgICAnZGFuZ2Vyb3VzbHlSZW5kZXJNYXJrdXAoLi4uKTogTWlzc2luZyBtYXJrdXAuJ1xuICAgICAgKSA6IGludmFyaWFudChtYXJrdXBMaXN0W2ldKSk7XG4gICAgICBub2RlTmFtZSA9IGdldE5vZGVOYW1lKG1hcmt1cExpc3RbaV0pO1xuICAgICAgbm9kZU5hbWUgPSBnZXRNYXJrdXBXcmFwKG5vZGVOYW1lKSA/IG5vZGVOYW1lIDogJyonO1xuICAgICAgbWFya3VwQnlOb2RlTmFtZVtub2RlTmFtZV0gPSBtYXJrdXBCeU5vZGVOYW1lW25vZGVOYW1lXSB8fCBbXTtcbiAgICAgIG1hcmt1cEJ5Tm9kZU5hbWVbbm9kZU5hbWVdW2ldID0gbWFya3VwTGlzdFtpXTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdExpc3QgPSBbXTtcbiAgICB2YXIgcmVzdWx0TGlzdEFzc2lnbm1lbnRDb3VudCA9IDA7XG4gICAgZm9yIChub2RlTmFtZSBpbiBtYXJrdXBCeU5vZGVOYW1lKSB7XG4gICAgICBpZiAoIW1hcmt1cEJ5Tm9kZU5hbWUuaGFzT3duUHJvcGVydHkobm9kZU5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIG1hcmt1cExpc3RCeU5vZGVOYW1lID0gbWFya3VwQnlOb2RlTmFtZVtub2RlTmFtZV07XG5cbiAgICAgIC8vIFRoaXMgZm9yLWluIGxvb3Agc2tpcHMgdGhlIGhvbGVzIG9mIHRoZSBzcGFyc2UgYXJyYXkuIFRoZSBvcmRlciBvZlxuICAgICAgLy8gaXRlcmF0aW9uIHNob3VsZCBmb2xsb3cgdGhlIG9yZGVyIG9mIGFzc2lnbm1lbnQsIHdoaWNoIGhhcHBlbnMgdG8gbWF0Y2hcbiAgICAgIC8vIG51bWVyaWNhbCBpbmRleCBvcmRlciwgYnV0IHdlIGRvbid0IHJlbHkgb24gdGhhdC5cbiAgICAgIGZvciAodmFyIHJlc3VsdEluZGV4IGluIG1hcmt1cExpc3RCeU5vZGVOYW1lKSB7XG4gICAgICAgIGlmIChtYXJrdXBMaXN0QnlOb2RlTmFtZS5oYXNPd25Qcm9wZXJ0eShyZXN1bHRJbmRleCkpIHtcbiAgICAgICAgICB2YXIgbWFya3VwID0gbWFya3VwTGlzdEJ5Tm9kZU5hbWVbcmVzdWx0SW5kZXhdO1xuXG4gICAgICAgICAgLy8gUHVzaCB0aGUgcmVxdWVzdGVkIG1hcmt1cCB3aXRoIGFuIGFkZGl0aW9uYWwgUkVTVUxUX0lOREVYX0FUVFJcbiAgICAgICAgICAvLyBhdHRyaWJ1dGUuICBJZiB0aGUgbWFya3VwIGRvZXMgbm90IHN0YXJ0IHdpdGggYSA8IGNoYXJhY3RlciwgaXRcbiAgICAgICAgICAvLyB3aWxsIGJlIGRpc2NhcmRlZCBiZWxvdyAod2l0aCBhbiBhcHByb3ByaWF0ZSBjb25zb2xlLmVycm9yKS5cbiAgICAgICAgICBtYXJrdXBMaXN0QnlOb2RlTmFtZVtyZXN1bHRJbmRleF0gPSBtYXJrdXAucmVwbGFjZShcbiAgICAgICAgICAgIE9QRU5fVEFHX05BTUVfRVhQLFxuICAgICAgICAgICAgLy8gVGhpcyBpbmRleCB3aWxsIGJlIHBhcnNlZCBiYWNrIG91dCBiZWxvdy5cbiAgICAgICAgICAgICckMSAnICsgUkVTVUxUX0lOREVYX0FUVFIgKyAnPVwiJyArIHJlc3VsdEluZGV4ICsgJ1wiICdcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbmRlciBlYWNoIGdyb3VwIG9mIG1hcmt1cCB3aXRoIHNpbWlsYXIgd3JhcHBpbmcgYG5vZGVOYW1lYC5cbiAgICAgIHZhciByZW5kZXJOb2RlcyA9IGNyZWF0ZU5vZGVzRnJvbU1hcmt1cChcbiAgICAgICAgbWFya3VwTGlzdEJ5Tm9kZU5hbWUuam9pbignJyksXG4gICAgICAgIGVtcHR5RnVuY3Rpb24gLy8gRG8gbm90aGluZyBzcGVjaWFsIHdpdGggPHNjcmlwdD4gdGFncy5cbiAgICAgICk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCByZW5kZXJOb2Rlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcmVuZGVyTm9kZSA9IHJlbmRlck5vZGVzW2ldO1xuICAgICAgICBpZiAocmVuZGVyTm9kZS5oYXNBdHRyaWJ1dGUgJiZcbiAgICAgICAgICAgIHJlbmRlck5vZGUuaGFzQXR0cmlidXRlKFJFU1VMVF9JTkRFWF9BVFRSKSkge1xuXG4gICAgICAgICAgcmVzdWx0SW5kZXggPSArcmVuZGVyTm9kZS5nZXRBdHRyaWJ1dGUoUkVTVUxUX0lOREVYX0FUVFIpO1xuICAgICAgICAgIHJlbmRlck5vZGUucmVtb3ZlQXR0cmlidXRlKFJFU1VMVF9JTkRFWF9BVFRSKTtcblxuICAgICAgICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAgICAgICAhcmVzdWx0TGlzdC5oYXNPd25Qcm9wZXJ0eShyZXN1bHRJbmRleCksXG4gICAgICAgICAgICAnRGFuZ2VyOiBBc3NpZ25pbmcgdG8gYW4gYWxyZWFkeS1vY2N1cGllZCByZXN1bHQgaW5kZXguJ1xuICAgICAgICAgICkgOiBpbnZhcmlhbnQoIXJlc3VsdExpc3QuaGFzT3duUHJvcGVydHkocmVzdWx0SW5kZXgpKSk7XG5cbiAgICAgICAgICByZXN1bHRMaXN0W3Jlc3VsdEluZGV4XSA9IHJlbmRlck5vZGU7XG5cbiAgICAgICAgICAvLyBUaGlzIHNob3VsZCBtYXRjaCByZXN1bHRMaXN0Lmxlbmd0aCBhbmQgbWFya3VwTGlzdC5sZW5ndGggd2hlblxuICAgICAgICAgIC8vIHdlJ3JlIGRvbmUuXG4gICAgICAgICAgcmVzdWx0TGlzdEFzc2lnbm1lbnRDb3VudCArPSAxO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiRGFuZ2VyOiBEaXNjYXJkaW5nIHVuZXhwZWN0ZWQgbm9kZTpcIixcbiAgICAgICAgICAgIHJlbmRlck5vZGVcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWx0aG91Z2ggcmVzdWx0TGlzdCB3YXMgcG9wdWxhdGVkIG91dCBvZiBvcmRlciwgaXQgc2hvdWxkIG5vdyBiZSBhIGRlbnNlXG4gICAgLy8gYXJyYXkuXG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgIHJlc3VsdExpc3RBc3NpZ25tZW50Q291bnQgPT09IHJlc3VsdExpc3QubGVuZ3RoLFxuICAgICAgJ0RhbmdlcjogRGlkIG5vdCBhc3NpZ24gdG8gZXZlcnkgaW5kZXggb2YgcmVzdWx0TGlzdC4nXG4gICAgKSA6IGludmFyaWFudChyZXN1bHRMaXN0QXNzaWdubWVudENvdW50ID09PSByZXN1bHRMaXN0Lmxlbmd0aCkpO1xuXG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgIHJlc3VsdExpc3QubGVuZ3RoID09PSBtYXJrdXBMaXN0Lmxlbmd0aCxcbiAgICAgICdEYW5nZXI6IEV4cGVjdGVkIG1hcmt1cCB0byByZW5kZXIgJXMgbm9kZXMsIGJ1dCByZW5kZXJlZCAlcy4nLFxuICAgICAgbWFya3VwTGlzdC5sZW5ndGgsXG4gICAgICByZXN1bHRMaXN0Lmxlbmd0aFxuICAgICkgOiBpbnZhcmlhbnQocmVzdWx0TGlzdC5sZW5ndGggPT09IG1hcmt1cExpc3QubGVuZ3RoKSk7XG5cbiAgICByZXR1cm4gcmVzdWx0TGlzdDtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYSBub2RlIHdpdGggYSBzdHJpbmcgb2YgbWFya3VwIGF0IGl0cyBjdXJyZW50IHBvc2l0aW9uIHdpdGhpbiBpdHNcbiAgICogcGFyZW50LiBUaGUgbWFya3VwIG11c3QgcmVuZGVyIGludG8gYSBzaW5nbGUgcm9vdCBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG9sZENoaWxkIENoaWxkIG5vZGUgdG8gcmVwbGFjZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBNYXJrdXAgdG8gcmVuZGVyIGluIHBsYWNlIG9mIHRoZSBjaGlsZCBub2RlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwOiBmdW5jdGlvbihvbGRDaGlsZCwgbWFya3VwKSB7XG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgIEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSxcbiAgICAgICdkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCguLi4pOiBDYW5ub3QgcmVuZGVyIG1hcmt1cCBpbiBhICcgK1xuICAgICAgJ3dvcmtlciB0aHJlYWQuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIHRoZSBmcmFtZXdvcmsuIFBsZWFzZSByZXBvcnQgJyArXG4gICAgICAnaW1tZWRpYXRlbHkuJ1xuICAgICkgOiBpbnZhcmlhbnQoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSk7XG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChtYXJrdXAsICdkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCguLi4pOiBNaXNzaW5nIG1hcmt1cC4nKSA6IGludmFyaWFudChtYXJrdXApKTtcbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgb2xkQ2hpbGQudGFnTmFtZS50b0xvd2VyQ2FzZSgpICE9PSAnaHRtbCcsXG4gICAgICAnZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAoLi4uKTogQ2Fubm90IHJlcGxhY2UgbWFya3VwIG9mIHRoZSAnICtcbiAgICAgICc8aHRtbD4gbm9kZS4gVGhpcyBpcyBiZWNhdXNlIGJyb3dzZXIgcXVpcmtzIG1ha2UgdGhpcyB1bnJlbGlhYmxlICcgK1xuICAgICAgJ2FuZC9vciBzbG93LiBJZiB5b3Ugd2FudCB0byByZW5kZXIgdG8gdGhlIHJvb3QgeW91IG11c3QgdXNlICcgK1xuICAgICAgJ3NlcnZlciByZW5kZXJpbmcuIFNlZSByZW5kZXJDb21wb25lbnRUb1N0cmluZygpLidcbiAgICApIDogaW52YXJpYW50KG9sZENoaWxkLnRhZ05hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ2h0bWwnKSk7XG5cbiAgICB2YXIgbmV3Q2hpbGQgPSBjcmVhdGVOb2Rlc0Zyb21NYXJrdXAobWFya3VwLCBlbXB0eUZ1bmN0aW9uKVswXTtcbiAgICBvbGRDaGlsZC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChuZXdDaGlsZCwgb2xkQ2hpbGQpO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGFuZ2VyO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXJcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuIHZhciBrZXlPZiA9IHJlcXVpcmUoXCIuL2tleU9mXCIpO1xuXG4vKipcbiAqIE1vZHVsZSB0aGF0IGlzIGluamVjdGFibGUgaW50byBgRXZlbnRQbHVnaW5IdWJgLCB0aGF0IHNwZWNpZmllcyBhXG4gKiBkZXRlcm1pbmlzdGljIG9yZGVyaW5nIG9mIGBFdmVudFBsdWdpbmBzLiBBIGNvbnZlbmllbnQgd2F5IHRvIHJlYXNvbiBhYm91dFxuICogcGx1Z2lucywgd2l0aG91dCBoYXZpbmcgdG8gcGFja2FnZSBldmVyeSBvbmUgb2YgdGhlbS4gVGhpcyBpcyBiZXR0ZXIgdGhhblxuICogaGF2aW5nIHBsdWdpbnMgYmUgb3JkZXJlZCBpbiB0aGUgc2FtZSBvcmRlciB0aGF0IHRoZXkgYXJlIGluamVjdGVkIGJlY2F1c2VcbiAqIHRoYXQgb3JkZXJpbmcgd291bGQgYmUgaW5mbHVlbmNlZCBieSB0aGUgcGFja2FnaW5nIG9yZGVyLlxuICogYFJlc3BvbmRlckV2ZW50UGx1Z2luYCBtdXN0IG9jY3VyIGJlZm9yZSBgU2ltcGxlRXZlbnRQbHVnaW5gIHNvIHRoYXRcbiAqIHByZXZlbnRpbmcgZGVmYXVsdCBvbiBldmVudHMgaXMgY29udmVuaWVudCBpbiBgU2ltcGxlRXZlbnRQbHVnaW5gIGhhbmRsZXJzLlxuICovXG52YXIgRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXIgPSBbXG4gIGtleU9mKHtSZXNwb25kZXJFdmVudFBsdWdpbjogbnVsbH0pLFxuICBrZXlPZih7U2ltcGxlRXZlbnRQbHVnaW46IG51bGx9KSxcbiAga2V5T2Yoe1RhcEV2ZW50UGx1Z2luOiBudWxsfSksXG4gIGtleU9mKHtFbnRlckxlYXZlRXZlbnRQbHVnaW46IG51bGx9KSxcbiAga2V5T2Yoe0NoYW5nZUV2ZW50UGx1Z2luOiBudWxsfSksXG4gIGtleU9mKHtTZWxlY3RFdmVudFBsdWdpbjogbnVsbH0pLFxuICBrZXlPZih7Q29tcG9zaXRpb25FdmVudFBsdWdpbjogbnVsbH0pLFxuICBrZXlPZih7QmVmb3JlSW5wdXRFdmVudFBsdWdpbjogbnVsbH0pLFxuICBrZXlPZih7QW5hbHl0aWNzRXZlbnRQbHVnaW46IG51bGx9KSxcbiAga2V5T2Yoe01vYmlsZVNhZmFyaUNsaWNrRXZlbnRQbHVnaW46IG51bGx9KVxuXTtcblxubW9kdWxlLmV4cG9ydHMgPSBEZWZhdWx0RXZlbnRQbHVnaW5PcmRlcjtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFbnRlckxlYXZlRXZlbnRQbHVnaW5cbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoXCIuL0V2ZW50Q29uc3RhbnRzXCIpO1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKFwiLi9FdmVudFByb3BhZ2F0b3JzXCIpO1xudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSByZXF1aXJlKFwiLi9TeW50aGV0aWNNb3VzZUV2ZW50XCIpO1xuXG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoXCIuL1JlYWN0TW91bnRcIik7XG52YXIga2V5T2YgPSByZXF1aXJlKFwiLi9rZXlPZlwiKTtcblxudmFyIHRvcExldmVsVHlwZXMgPSBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xudmFyIGdldEZpcnN0UmVhY3RET00gPSBSZWFjdE1vdW50LmdldEZpcnN0UmVhY3RET007XG5cbnZhciBldmVudFR5cGVzID0ge1xuICBtb3VzZUVudGVyOiB7XG4gICAgcmVnaXN0cmF0aW9uTmFtZToga2V5T2Yoe29uTW91c2VFbnRlcjogbnVsbH0pLFxuICAgIGRlcGVuZGVuY2llczogW1xuICAgICAgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU91dCxcbiAgICAgIHRvcExldmVsVHlwZXMudG9wTW91c2VPdmVyXG4gICAgXVxuICB9LFxuICBtb3VzZUxlYXZlOiB7XG4gICAgcmVnaXN0cmF0aW9uTmFtZToga2V5T2Yoe29uTW91c2VMZWF2ZTogbnVsbH0pLFxuICAgIGRlcGVuZGVuY2llczogW1xuICAgICAgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU91dCxcbiAgICAgIHRvcExldmVsVHlwZXMudG9wTW91c2VPdmVyXG4gICAgXVxuICB9XG59O1xuXG52YXIgZXh0cmFjdGVkRXZlbnRzID0gW251bGwsIG51bGxdO1xuXG52YXIgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luID0ge1xuXG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgLyoqXG4gICAqIEZvciBhbG1vc3QgZXZlcnkgaW50ZXJhY3Rpb24gd2UgY2FyZSBhYm91dCwgdGhlcmUgd2lsbCBiZSBib3RoIGEgdG9wLWxldmVsXG4gICAqIGBtb3VzZW92ZXJgIGFuZCBgbW91c2VvdXRgIGV2ZW50IHRoYXQgb2NjdXJzLiBPbmx5IHVzZSBgbW91c2VvdXRgIHNvIHRoYXRcbiAgICogd2UgZG8gbm90IGV4dHJhY3QgZHVwbGljYXRlIGV2ZW50cy4gSG93ZXZlciwgbW92aW5nIHRoZSBtb3VzZSBpbnRvIHRoZVxuICAgKiBicm93c2VyIGZyb20gb3V0c2lkZSB3aWxsIG5vdCBmaXJlIGEgYG1vdXNlb3V0YCBldmVudC4gSW4gdGhpcyBjYXNlLCB3ZSB1c2VcbiAgICogdGhlIGBtb3VzZW92ZXJgIHRvcC1sZXZlbCBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0b3BMZXZlbFRhcmdldCBUaGUgbGlzdGVuaW5nIGNvbXBvbmVudCByb290IG5vZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFRhcmdldElEIElEIG9mIGB0b3BMZXZlbFRhcmdldGAuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAgICogQHJldHVybiB7Kn0gQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gICAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmV4dHJhY3RFdmVudHN9XG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbihcbiAgICAgIHRvcExldmVsVHlwZSxcbiAgICAgIHRvcExldmVsVGFyZ2V0LFxuICAgICAgdG9wTGV2ZWxUYXJnZXRJRCxcbiAgICAgIG5hdGl2ZUV2ZW50KSB7XG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU92ZXIgJiZcbiAgICAgICAgKG5hdGl2ZUV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgbmF0aXZlRXZlbnQuZnJvbUVsZW1lbnQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRvcExldmVsVHlwZSAhPT0gdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU91dCAmJlxuICAgICAgICB0b3BMZXZlbFR5cGUgIT09IHRvcExldmVsVHlwZXMudG9wTW91c2VPdmVyKSB7XG4gICAgICAvLyBNdXN0IG5vdCBiZSBhIG1vdXNlIGluIG9yIG1vdXNlIG91dCAtIGlnbm9yaW5nLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHdpbjtcbiAgICBpZiAodG9wTGV2ZWxUYXJnZXQud2luZG93ID09PSB0b3BMZXZlbFRhcmdldCkge1xuICAgICAgLy8gYHRvcExldmVsVGFyZ2V0YCBpcyBwcm9iYWJseSBhIHdpbmRvdyBvYmplY3QuXG4gICAgICB3aW4gPSB0b3BMZXZlbFRhcmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVE9ETzogRmlndXJlIG91dCB3aHkgYG93bmVyRG9jdW1lbnRgIGlzIHNvbWV0aW1lcyB1bmRlZmluZWQgaW4gSUU4LlxuICAgICAgdmFyIGRvYyA9IHRvcExldmVsVGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG4gICAgICBpZiAoZG9jKSB7XG4gICAgICAgIHdpbiA9IGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luID0gd2luZG93O1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBmcm9tLCB0bztcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3V0KSB7XG4gICAgICBmcm9tID0gdG9wTGV2ZWxUYXJnZXQ7XG4gICAgICB0byA9XG4gICAgICAgIGdldEZpcnN0UmVhY3RET00obmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldCB8fCBuYXRpdmVFdmVudC50b0VsZW1lbnQpIHx8XG4gICAgICAgIHdpbjtcbiAgICB9IGVsc2Uge1xuICAgICAgZnJvbSA9IHdpbjtcbiAgICAgIHRvID0gdG9wTGV2ZWxUYXJnZXQ7XG4gICAgfVxuXG4gICAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgICAvLyBOb3RoaW5nIHBlcnRhaW5zIHRvIG91ciBtYW5hZ2VkIGNvbXBvbmVudHMuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgZnJvbUlEID0gZnJvbSA/IFJlYWN0TW91bnQuZ2V0SUQoZnJvbSkgOiAnJztcbiAgICB2YXIgdG9JRCA9IHRvID8gUmVhY3RNb3VudC5nZXRJRCh0bykgOiAnJztcblxuICAgIHZhciBsZWF2ZSA9IFN5bnRoZXRpY01vdXNlRXZlbnQuZ2V0UG9vbGVkKFxuICAgICAgZXZlbnRUeXBlcy5tb3VzZUxlYXZlLFxuICAgICAgZnJvbUlELFxuICAgICAgbmF0aXZlRXZlbnRcbiAgICApO1xuICAgIGxlYXZlLnR5cGUgPSAnbW91c2VsZWF2ZSc7XG4gICAgbGVhdmUudGFyZ2V0ID0gZnJvbTtcbiAgICBsZWF2ZS5yZWxhdGVkVGFyZ2V0ID0gdG87XG5cbiAgICB2YXIgZW50ZXIgPSBTeW50aGV0aWNNb3VzZUV2ZW50LmdldFBvb2xlZChcbiAgICAgIGV2ZW50VHlwZXMubW91c2VFbnRlcixcbiAgICAgIHRvSUQsXG4gICAgICBuYXRpdmVFdmVudFxuICAgICk7XG4gICAgZW50ZXIudHlwZSA9ICdtb3VzZWVudGVyJztcbiAgICBlbnRlci50YXJnZXQgPSB0bztcbiAgICBlbnRlci5yZWxhdGVkVGFyZ2V0ID0gZnJvbTtcblxuICAgIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzKGxlYXZlLCBlbnRlciwgZnJvbUlELCB0b0lEKTtcblxuICAgIGV4dHJhY3RlZEV2ZW50c1swXSA9IGxlYXZlO1xuICAgIGV4dHJhY3RlZEV2ZW50c1sxXSA9IGVudGVyO1xuXG4gICAgcmV0dXJuIGV4dHJhY3RlZEV2ZW50cztcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVudGVyTGVhdmVFdmVudFBsdWdpbjtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFdmVudENvbnN0YW50c1xuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIga2V5TWlycm9yID0gcmVxdWlyZShcIi4va2V5TWlycm9yXCIpO1xuXG52YXIgUHJvcGFnYXRpb25QaGFzZXMgPSBrZXlNaXJyb3Ioe2J1YmJsZWQ6IG51bGwsIGNhcHR1cmVkOiBudWxsfSk7XG5cbi8qKlxuICogVHlwZXMgb2YgcmF3IHNpZ25hbHMgZnJvbSB0aGUgYnJvd3NlciBjYXVnaHQgYXQgdGhlIHRvcCBsZXZlbC5cbiAqL1xudmFyIHRvcExldmVsVHlwZXMgPSBrZXlNaXJyb3Ioe1xuICB0b3BCbHVyOiBudWxsLFxuICB0b3BDaGFuZ2U6IG51bGwsXG4gIHRvcENsaWNrOiBudWxsLFxuICB0b3BDb21wb3NpdGlvbkVuZDogbnVsbCxcbiAgdG9wQ29tcG9zaXRpb25TdGFydDogbnVsbCxcbiAgdG9wQ29tcG9zaXRpb25VcGRhdGU6IG51bGwsXG4gIHRvcENvbnRleHRNZW51OiBudWxsLFxuICB0b3BDb3B5OiBudWxsLFxuICB0b3BDdXQ6IG51bGwsXG4gIHRvcERvdWJsZUNsaWNrOiBudWxsLFxuICB0b3BEcmFnOiBudWxsLFxuICB0b3BEcmFnRW5kOiBudWxsLFxuICB0b3BEcmFnRW50ZXI6IG51bGwsXG4gIHRvcERyYWdFeGl0OiBudWxsLFxuICB0b3BEcmFnTGVhdmU6IG51bGwsXG4gIHRvcERyYWdPdmVyOiBudWxsLFxuICB0b3BEcmFnU3RhcnQ6IG51bGwsXG4gIHRvcERyb3A6IG51bGwsXG4gIHRvcEVycm9yOiBudWxsLFxuICB0b3BGb2N1czogbnVsbCxcbiAgdG9wSW5wdXQ6IG51bGwsXG4gIHRvcEtleURvd246IG51bGwsXG4gIHRvcEtleVByZXNzOiBudWxsLFxuICB0b3BLZXlVcDogbnVsbCxcbiAgdG9wTG9hZDogbnVsbCxcbiAgdG9wTW91c2VEb3duOiBudWxsLFxuICB0b3BNb3VzZU1vdmU6IG51bGwsXG4gIHRvcE1vdXNlT3V0OiBudWxsLFxuICB0b3BNb3VzZU92ZXI6IG51bGwsXG4gIHRvcE1vdXNlVXA6IG51bGwsXG4gIHRvcFBhc3RlOiBudWxsLFxuICB0b3BSZXNldDogbnVsbCxcbiAgdG9wU2Nyb2xsOiBudWxsLFxuICB0b3BTZWxlY3Rpb25DaGFuZ2U6IG51bGwsXG4gIHRvcFN1Ym1pdDogbnVsbCxcbiAgdG9wVGV4dElucHV0OiBudWxsLFxuICB0b3BUb3VjaENhbmNlbDogbnVsbCxcbiAgdG9wVG91Y2hFbmQ6IG51bGwsXG4gIHRvcFRvdWNoTW92ZTogbnVsbCxcbiAgdG9wVG91Y2hTdGFydDogbnVsbCxcbiAgdG9wV2hlZWw6IG51bGxcbn0pO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSB7XG4gIHRvcExldmVsVHlwZXM6IHRvcExldmVsVHlwZXMsXG4gIFByb3BhZ2F0aW9uUGhhc2VzOiBQcm9wYWdhdGlvblBoYXNlc1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudENvbnN0YW50cztcbiIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIEBwcm92aWRlc01vZHVsZSBFdmVudExpc3RlbmVyXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZShcIi4vZW1wdHlGdW5jdGlvblwiKTtcblxuLyoqXG4gKiBVcHN0cmVhbSB2ZXJzaW9uIG9mIGV2ZW50IGxpc3RlbmVyLiBEb2VzIG5vdCB0YWtlIGludG8gYWNjb3VudCBzcGVjaWZpY1xuICogbmF0dXJlIG9mIHBsYXRmb3JtLlxuICovXG52YXIgRXZlbnRMaXN0ZW5lciA9IHtcbiAgLyoqXG4gICAqIExpc3RlbiB0byBET00gZXZlbnRzIGR1cmluZyB0aGUgYnViYmxlIHBoYXNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0YXJnZXQgRE9NIGVsZW1lbnQgdG8gcmVnaXN0ZXIgbGlzdGVuZXIgb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgRXZlbnQgdHlwZSwgZS5nLiAnY2xpY2snIG9yICdtb3VzZW92ZXInLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7b2JqZWN0fSBPYmplY3Qgd2l0aCBhIGByZW1vdmVgIG1ldGhvZC5cbiAgICovXG4gIGxpc3RlbjogZnVuY3Rpb24odGFyZ2V0LCBldmVudFR5cGUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRhcmdldC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCBmYWxzZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHRhcmdldC5hdHRhY2hFdmVudCkge1xuICAgICAgdGFyZ2V0LmF0dGFjaEV2ZW50KCdvbicgKyBldmVudFR5cGUsIGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGFyZ2V0LmRldGFjaEV2ZW50KCdvbicgKyBldmVudFR5cGUsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIExpc3RlbiB0byBET00gZXZlbnRzIGR1cmluZyB0aGUgY2FwdHVyZSBwaGFzZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdGFyZ2V0IERPTSBlbGVtZW50IHRvIHJlZ2lzdGVyIGxpc3RlbmVyIG9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIEV2ZW50IHR5cGUsIGUuZy4gJ2NsaWNrJyBvciAnbW91c2VvdmVyJy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IHdpdGggYSBgcmVtb3ZlYCBtZXRob2QuXG4gICAqL1xuICBjYXB0dXJlOiBmdW5jdGlvbih0YXJnZXQsIGV2ZW50VHlwZSwgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRhcmdldC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgJ0F0dGVtcHRlZCB0byBsaXN0ZW4gdG8gZXZlbnRzIGR1cmluZyB0aGUgY2FwdHVyZSBwaGFzZSBvbiBhICcgK1xuICAgICAgICAgICdicm93c2VyIHRoYXQgZG9lcyBub3Qgc3VwcG9ydCB0aGUgY2FwdHVyZSBwaGFzZS4gWW91ciBhcHBsaWNhdGlvbiAnICtcbiAgICAgICAgICAnd2lsbCBub3QgcmVjZWl2ZSBzb21lIGV2ZW50cy4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGVtcHR5RnVuY3Rpb25cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIHRydWUpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0sXG5cbiAgcmVnaXN0ZXJEZWZhdWx0OiBmdW5jdGlvbigpIHt9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50TGlzdGVuZXI7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRXZlbnRQbHVnaW5IdWJcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIEV2ZW50UGx1Z2luUmVnaXN0cnkgPSByZXF1aXJlKFwiLi9FdmVudFBsdWdpblJlZ2lzdHJ5XCIpO1xudmFyIEV2ZW50UGx1Z2luVXRpbHMgPSByZXF1aXJlKFwiLi9FdmVudFBsdWdpblV0aWxzXCIpO1xuXG52YXIgYWNjdW11bGF0ZSA9IHJlcXVpcmUoXCIuL2FjY3VtdWxhdGVcIik7XG52YXIgZm9yRWFjaEFjY3VtdWxhdGVkID0gcmVxdWlyZShcIi4vZm9yRWFjaEFjY3VtdWxhdGVkXCIpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcbnZhciBpc0V2ZW50U3VwcG9ydGVkID0gcmVxdWlyZShcIi4vaXNFdmVudFN1cHBvcnRlZFwiKTtcbnZhciBtb25pdG9yQ29kZVVzZSA9IHJlcXVpcmUoXCIuL21vbml0b3JDb2RlVXNlXCIpO1xuXG4vKipcbiAqIEludGVybmFsIHN0b3JlIGZvciBldmVudCBsaXN0ZW5lcnNcbiAqL1xudmFyIGxpc3RlbmVyQmFuayA9IHt9O1xuXG4vKipcbiAqIEludGVybmFsIHF1ZXVlIG9mIGV2ZW50cyB0aGF0IGhhdmUgYWNjdW11bGF0ZWQgdGhlaXIgZGlzcGF0Y2hlcyBhbmQgYXJlXG4gKiB3YWl0aW5nIHRvIGhhdmUgdGhlaXIgZGlzcGF0Y2hlcyBleGVjdXRlZC5cbiAqL1xudmFyIGV2ZW50UXVldWUgPSBudWxsO1xuXG4vKipcbiAqIERpc3BhdGNoZXMgYW4gZXZlbnQgYW5kIHJlbGVhc2VzIGl0IGJhY2sgaW50byB0aGUgcG9vbCwgdW5sZXNzIHBlcnNpc3RlbnQuXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBldmVudCBTeW50aGV0aWMgZXZlbnQgdG8gYmUgZGlzcGF0Y2hlZC5cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UgPSBmdW5jdGlvbihldmVudCkge1xuICBpZiAoZXZlbnQpIHtcbiAgICB2YXIgZXhlY3V0ZURpc3BhdGNoID0gRXZlbnRQbHVnaW5VdGlscy5leGVjdXRlRGlzcGF0Y2g7XG4gICAgLy8gUGx1Z2lucyBjYW4gcHJvdmlkZSBjdXN0b20gYmVoYXZpb3Igd2hlbiBkaXNwYXRjaGluZyBldmVudHMuXG4gICAgdmFyIFBsdWdpbk1vZHVsZSA9IEV2ZW50UGx1Z2luUmVnaXN0cnkuZ2V0UGx1Z2luTW9kdWxlRm9yRXZlbnQoZXZlbnQpO1xuICAgIGlmIChQbHVnaW5Nb2R1bGUgJiYgUGx1Z2luTW9kdWxlLmV4ZWN1dGVEaXNwYXRjaCkge1xuICAgICAgZXhlY3V0ZURpc3BhdGNoID0gUGx1Z2luTW9kdWxlLmV4ZWN1dGVEaXNwYXRjaDtcbiAgICB9XG4gICAgRXZlbnRQbHVnaW5VdGlscy5leGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIoZXZlbnQsIGV4ZWN1dGVEaXNwYXRjaCk7XG5cbiAgICBpZiAoIWV2ZW50LmlzUGVyc2lzdGVudCgpKSB7XG4gICAgICBldmVudC5jb25zdHJ1Y3Rvci5yZWxlYXNlKGV2ZW50KTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogLSBgSW5zdGFuY2VIYW5kbGVgOiBbcmVxdWlyZWRdIE1vZHVsZSB0aGF0IHBlcmZvcm1zIGxvZ2ljYWwgdHJhdmVyc2FscyBvZiBET01cbiAqICAgaGllcmFyY2h5IGdpdmVuIGlkcyBvZiB0aGUgbG9naWNhbCBET00gZWxlbWVudHMgaW52b2x2ZWQuXG4gKi9cbnZhciBJbnN0YW5jZUhhbmRsZSA9IG51bGw7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlSW5zdGFuY2VIYW5kbGUoKSB7XG4gIHZhciBpbnZhbGlkID0gIUluc3RhbmNlSGFuZGxlfHxcbiAgICAhSW5zdGFuY2VIYW5kbGUudHJhdmVyc2VUd29QaGFzZSB8fFxuICAgICFJbnN0YW5jZUhhbmRsZS50cmF2ZXJzZUVudGVyTGVhdmU7XG4gIGlmIChpbnZhbGlkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnN0YW5jZUhhbmRsZSBub3QgaW5qZWN0ZWQgYmVmb3JlIHVzZSEnKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgYSB1bmlmaWVkIGludGVyZmFjZSBmb3IgZXZlbnQgcGx1Z2lucyB0byBiZSBpbnN0YWxsZWQgYW5kIGNvbmZpZ3VyZWQuXG4gKlxuICogRXZlbnQgcGx1Z2lucyBjYW4gaW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIGBleHRyYWN0RXZlbnRzYCB7ZnVuY3Rpb24oc3RyaW5nLCBET01FdmVudFRhcmdldCwgc3RyaW5nLCBvYmplY3QpOiAqfVxuICogICAgIFJlcXVpcmVkLiBXaGVuIGEgdG9wLWxldmVsIGV2ZW50IGlzIGZpcmVkLCB0aGlzIG1ldGhvZCBpcyBleHBlY3RlZCB0b1xuICogICAgIGV4dHJhY3Qgc3ludGhldGljIGV2ZW50cyB0aGF0IHdpbGwgaW4gdHVybiBiZSBxdWV1ZWQgYW5kIGRpc3BhdGNoZWQuXG4gKlxuICogICBgZXZlbnRUeXBlc2Age29iamVjdH1cbiAqICAgICBPcHRpb25hbCwgcGx1Z2lucyB0aGF0IGZpcmUgZXZlbnRzIG11c3QgcHVibGlzaCBhIG1hcHBpbmcgb2YgcmVnaXN0cmF0aW9uXG4gKiAgICAgbmFtZXMgdGhhdCBhcmUgdXNlZCB0byByZWdpc3RlciBsaXN0ZW5lcnMuIFZhbHVlcyBvZiB0aGlzIG1hcHBpbmcgbXVzdFxuICogICAgIGJlIG9iamVjdHMgdGhhdCBjb250YWluIGByZWdpc3RyYXRpb25OYW1lYCBvciBgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNgLlxuICpcbiAqICAgYGV4ZWN1dGVEaXNwYXRjaGAge2Z1bmN0aW9uKG9iamVjdCwgZnVuY3Rpb24sIHN0cmluZyl9XG4gKiAgICAgT3B0aW9uYWwsIGFsbG93cyBwbHVnaW5zIHRvIG92ZXJyaWRlIGhvdyBhbiBldmVudCBnZXRzIGRpc3BhdGNoZWQuIEJ5XG4gKiAgICAgZGVmYXVsdCwgdGhlIGxpc3RlbmVyIGlzIHNpbXBseSBpbnZva2VkLlxuICpcbiAqIEVhY2ggcGx1Z2luIHRoYXQgaXMgaW5qZWN0ZWQgaW50byBgRXZlbnRzUGx1Z2luSHViYCBpcyBpbW1lZGlhdGVseSBvcGVyYWJsZS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbnZhciBFdmVudFBsdWdpbkh1YiA9IHtcblxuICAvKipcbiAgICogTWV0aG9kcyBmb3IgaW5qZWN0aW5nIGRlcGVuZGVuY2llcy5cbiAgICovXG4gIGluamVjdGlvbjoge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IEluamVjdGVkTW91bnRcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgaW5qZWN0TW91bnQ6IEV2ZW50UGx1Z2luVXRpbHMuaW5qZWN0aW9uLmluamVjdE1vdW50LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IEluamVjdGVkSW5zdGFuY2VIYW5kbGVcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgaW5qZWN0SW5zdGFuY2VIYW5kbGU6IGZ1bmN0aW9uKEluamVjdGVkSW5zdGFuY2VIYW5kbGUpIHtcbiAgICAgIEluc3RhbmNlSGFuZGxlID0gSW5qZWN0ZWRJbnN0YW5jZUhhbmRsZTtcbiAgICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgICAgdmFsaWRhdGVJbnN0YW5jZUhhbmRsZSgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRJbnN0YW5jZUhhbmRsZTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAgIHZhbGlkYXRlSW5zdGFuY2VIYW5kbGUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBJbnN0YW5jZUhhbmRsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHthcnJheX0gSW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGluamVjdEV2ZW50UGx1Z2luT3JkZXI6IEV2ZW50UGx1Z2luUmVnaXN0cnkuaW5qZWN0RXZlbnRQbHVnaW5PcmRlcixcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zIE1hcCBmcm9tIG5hbWVzIHRvIHBsdWdpbiBtb2R1bGVzLlxuICAgICAqL1xuICAgIGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZTogRXZlbnRQbHVnaW5SZWdpc3RyeS5pbmplY3RFdmVudFBsdWdpbnNCeU5hbWVcblxuICB9LFxuXG4gIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnczogRXZlbnRQbHVnaW5SZWdpc3RyeS5ldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MsXG5cbiAgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXM6IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMsXG5cbiAgLyoqXG4gICAqIFN0b3JlcyBgbGlzdGVuZXJgIGF0IGBsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV1baWRdYC4gSXMgaWRlbXBvdGVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIElEIG9mIHRoZSBET00gZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgTmFtZSBvZiBsaXN0ZW5lciAoZS5nLiBgb25DbGlja2ApLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gbGlzdGVuZXIgVGhlIGNhbGxiYWNrIHRvIHN0b3JlLlxuICAgKi9cbiAgcHV0TGlzdGVuZXI6IGZ1bmN0aW9uKGlkLCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcikge1xuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAhbGlzdGVuZXIgfHwgdHlwZW9mIGxpc3RlbmVyID09PSAnZnVuY3Rpb24nLFxuICAgICAgJ0V4cGVjdGVkICVzIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24sIGluc3RlYWQgZ290IHR5cGUgJXMnLFxuICAgICAgcmVnaXN0cmF0aW9uTmFtZSwgdHlwZW9mIGxpc3RlbmVyXG4gICAgKSA6IGludmFyaWFudCghbGlzdGVuZXIgfHwgdHlwZW9mIGxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSk7XG5cbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAvLyBJRTggaGFzIG5vIEFQSSBmb3IgZXZlbnQgY2FwdHVyaW5nIGFuZCB0aGUgYG9uU2Nyb2xsYCBldmVudCBkb2Vzbid0XG4gICAgICAvLyBidWJibGUuXG4gICAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSA9PT0gJ29uU2Nyb2xsJyAmJlxuICAgICAgICAgICFpc0V2ZW50U3VwcG9ydGVkKCdzY3JvbGwnLCB0cnVlKSkge1xuICAgICAgICBtb25pdG9yQ29kZVVzZSgncmVhY3Rfbm9fc2Nyb2xsX2V2ZW50Jyk7XG4gICAgICAgIGNvbnNvbGUud2FybignVGhpcyBicm93c2VyIGRvZXNuXFwndCBzdXBwb3J0IHRoZSBgb25TY3JvbGxgIGV2ZW50Jyk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSA9XG4gICAgICBsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV0gfHwgKGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXSA9IHt9KTtcbiAgICBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZVtpZF0gPSBsaXN0ZW5lcjtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIElEIG9mIHRoZSBET00gZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgTmFtZSBvZiBsaXN0ZW5lciAoZS5nLiBgb25DbGlja2ApLlxuICAgKiBAcmV0dXJuIHs/ZnVuY3Rpb259IFRoZSBzdG9yZWQgY2FsbGJhY2suXG4gICAqL1xuICBnZXRMaXN0ZW5lcjogZnVuY3Rpb24oaWQsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICB2YXIgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUgPSBsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV07XG4gICAgcmV0dXJuIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lICYmIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lW2lkXTtcbiAgfSxcblxuICAvKipcbiAgICogRGVsZXRlcyBhIGxpc3RlbmVyIGZyb20gdGhlIHJlZ2lzdHJhdGlvbiBiYW5rLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgb2YgdGhlIERPTSBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqL1xuICBkZWxldGVMaXN0ZW5lcjogZnVuY3Rpb24oaWQsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICB2YXIgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUgPSBsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV07XG4gICAgaWYgKGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgICBkZWxldGUgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWVbaWRdO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGVsZXRlcyBhbGwgbGlzdGVuZXJzIGZvciB0aGUgRE9NIGVsZW1lbnQgd2l0aCB0aGUgc3VwcGxpZWQgSUQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiB0aGUgRE9NIGVsZW1lbnQuXG4gICAqL1xuICBkZWxldGVBbGxMaXN0ZW5lcnM6IGZ1bmN0aW9uKGlkKSB7XG4gICAgZm9yICh2YXIgcmVnaXN0cmF0aW9uTmFtZSBpbiBsaXN0ZW5lckJhbmspIHtcbiAgICAgIGRlbGV0ZSBsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV1baWRdO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQWxsb3dzIHJlZ2lzdGVyZWQgcGx1Z2lucyBhbiBvcHBvcnR1bml0eSB0byBleHRyYWN0IGV2ZW50cyBmcm9tIHRvcC1sZXZlbFxuICAgKiBuYXRpdmUgYnJvd3NlciBldmVudHMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdG9wTGV2ZWxUYXJnZXQgVGhlIGxpc3RlbmluZyBjb21wb25lbnQgcm9vdCBub2RlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUYXJnZXRJRCBJRCBvZiBgdG9wTGV2ZWxUYXJnZXRgLlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gICAqIEByZXR1cm4geyp9IEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uKFxuICAgICAgdG9wTGV2ZWxUeXBlLFxuICAgICAgdG9wTGV2ZWxUYXJnZXQsXG4gICAgICB0b3BMZXZlbFRhcmdldElELFxuICAgICAgbmF0aXZlRXZlbnQpIHtcbiAgICB2YXIgZXZlbnRzO1xuICAgIHZhciBwbHVnaW5zID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5wbHVnaW5zO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gcGx1Z2lucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIC8vIE5vdCBldmVyeSBwbHVnaW4gaW4gdGhlIG9yZGVyaW5nIG1heSBiZSBsb2FkZWQgYXQgcnVudGltZS5cbiAgICAgIHZhciBwb3NzaWJsZVBsdWdpbiA9IHBsdWdpbnNbaV07XG4gICAgICBpZiAocG9zc2libGVQbHVnaW4pIHtcbiAgICAgICAgdmFyIGV4dHJhY3RlZEV2ZW50cyA9IHBvc3NpYmxlUGx1Z2luLmV4dHJhY3RFdmVudHMoXG4gICAgICAgICAgdG9wTGV2ZWxUeXBlLFxuICAgICAgICAgIHRvcExldmVsVGFyZ2V0LFxuICAgICAgICAgIHRvcExldmVsVGFyZ2V0SUQsXG4gICAgICAgICAgbmF0aXZlRXZlbnRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGV4dHJhY3RlZEV2ZW50cykge1xuICAgICAgICAgIGV2ZW50cyA9IGFjY3VtdWxhdGUoZXZlbnRzLCBleHRyYWN0ZWRFdmVudHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBldmVudHM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEVucXVldWVzIGEgc3ludGhldGljIGV2ZW50IHRoYXQgc2hvdWxkIGJlIGRpc3BhdGNoZWQgd2hlblxuICAgKiBgcHJvY2Vzc0V2ZW50UXVldWVgIGlzIGludm9rZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZXZlbnRzIEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVFdmVudHM6IGZ1bmN0aW9uKGV2ZW50cykge1xuICAgIGlmIChldmVudHMpIHtcbiAgICAgIGV2ZW50UXVldWUgPSBhY2N1bXVsYXRlKGV2ZW50UXVldWUsIGV2ZW50cyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIGFsbCBzeW50aGV0aWMgZXZlbnRzIG9uIHRoZSBldmVudCBxdWV1ZS5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcm9jZXNzRXZlbnRRdWV1ZTogZnVuY3Rpb24oKSB7XG4gICAgLy8gU2V0IGBldmVudFF1ZXVlYCB0byBudWxsIGJlZm9yZSBwcm9jZXNzaW5nIGl0IHNvIHRoYXQgd2UgY2FuIHRlbGwgaWYgbW9yZVxuICAgIC8vIGV2ZW50cyBnZXQgZW5xdWV1ZWQgd2hpbGUgcHJvY2Vzc2luZy5cbiAgICB2YXIgcHJvY2Vzc2luZ0V2ZW50UXVldWUgPSBldmVudFF1ZXVlO1xuICAgIGV2ZW50UXVldWUgPSBudWxsO1xuICAgIGZvckVhY2hBY2N1bXVsYXRlZChwcm9jZXNzaW5nRXZlbnRRdWV1ZSwgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlKTtcbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgIWV2ZW50UXVldWUsXG4gICAgICAncHJvY2Vzc0V2ZW50UXVldWUoKTogQWRkaXRpb25hbCBldmVudHMgd2VyZSBlbnF1ZXVlZCB3aGlsZSBwcm9jZXNzaW5nICcgK1xuICAgICAgJ2FuIGV2ZW50IHF1ZXVlLiBTdXBwb3J0IGZvciB0aGlzIGhhcyBub3QgeWV0IGJlZW4gaW1wbGVtZW50ZWQuJ1xuICAgICkgOiBpbnZhcmlhbnQoIWV2ZW50UXVldWUpKTtcbiAgfSxcblxuICAvKipcbiAgICogVGhlc2UgYXJlIG5lZWRlZCBmb3IgdGVzdHMgb25seS4gRG8gbm90IHVzZSFcbiAgICovXG4gIF9fcHVyZ2U6IGZ1bmN0aW9uKCkge1xuICAgIGxpc3RlbmVyQmFuayA9IHt9O1xuICB9LFxuXG4gIF9fZ2V0TGlzdGVuZXJCYW5rOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbGlzdGVuZXJCYW5rO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRQbHVnaW5IdWI7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRXZlbnRQbHVnaW5SZWdpc3RyeVxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcblxuLyoqXG4gKiBJbmplY3RhYmxlIG9yZGVyaW5nIG9mIGV2ZW50IHBsdWdpbnMuXG4gKi9cbnZhciBFdmVudFBsdWdpbk9yZGVyID0gbnVsbDtcblxuLyoqXG4gKiBJbmplY3RhYmxlIG1hcHBpbmcgZnJvbSBuYW1lcyB0byBldmVudCBwbHVnaW4gbW9kdWxlcy5cbiAqL1xudmFyIG5hbWVzVG9QbHVnaW5zID0ge307XG5cbi8qKlxuICogUmVjb21wdXRlcyB0aGUgcGx1Z2luIGxpc3QgdXNpbmcgdGhlIGluamVjdGVkIHBsdWdpbnMgYW5kIHBsdWdpbiBvcmRlcmluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNvbXB1dGVQbHVnaW5PcmRlcmluZygpIHtcbiAgaWYgKCFFdmVudFBsdWdpbk9yZGVyKSB7XG4gICAgLy8gV2FpdCB1bnRpbCBhbiBgRXZlbnRQbHVnaW5PcmRlcmAgaXMgaW5qZWN0ZWQuXG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAodmFyIHBsdWdpbk5hbWUgaW4gbmFtZXNUb1BsdWdpbnMpIHtcbiAgICB2YXIgUGx1Z2luTW9kdWxlID0gbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV07XG4gICAgdmFyIHBsdWdpbkluZGV4ID0gRXZlbnRQbHVnaW5PcmRlci5pbmRleE9mKHBsdWdpbk5hbWUpO1xuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICBwbHVnaW5JbmRleCA+IC0xLFxuICAgICAgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgZXZlbnQgcGx1Z2lucyB0aGF0IGRvIG5vdCBleGlzdCBpbiAnICtcbiAgICAgICd0aGUgcGx1Z2luIG9yZGVyaW5nLCBgJXNgLicsXG4gICAgICBwbHVnaW5OYW1lXG4gICAgKSA6IGludmFyaWFudChwbHVnaW5JbmRleCA+IC0xKSk7XG4gICAgaWYgKEV2ZW50UGx1Z2luUmVnaXN0cnkucGx1Z2luc1twbHVnaW5JbmRleF0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgUGx1Z2luTW9kdWxlLmV4dHJhY3RFdmVudHMsXG4gICAgICAnRXZlbnRQbHVnaW5SZWdpc3RyeTogRXZlbnQgcGx1Z2lucyBtdXN0IGltcGxlbWVudCBhbiBgZXh0cmFjdEV2ZW50c2AgJyArXG4gICAgICAnbWV0aG9kLCBidXQgYCVzYCBkb2VzIG5vdC4nLFxuICAgICAgcGx1Z2luTmFtZVxuICAgICkgOiBpbnZhcmlhbnQoUGx1Z2luTW9kdWxlLmV4dHJhY3RFdmVudHMpKTtcbiAgICBFdmVudFBsdWdpblJlZ2lzdHJ5LnBsdWdpbnNbcGx1Z2luSW5kZXhdID0gUGx1Z2luTW9kdWxlO1xuICAgIHZhciBwdWJsaXNoZWRFdmVudHMgPSBQbHVnaW5Nb2R1bGUuZXZlbnRUeXBlcztcbiAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gcHVibGlzaGVkRXZlbnRzKSB7XG4gICAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgICBwdWJsaXNoRXZlbnRGb3JQbHVnaW4oXG4gICAgICAgICAgcHVibGlzaGVkRXZlbnRzW2V2ZW50TmFtZV0sXG4gICAgICAgICAgUGx1Z2luTW9kdWxlLFxuICAgICAgICAgIGV2ZW50TmFtZVxuICAgICAgICApLFxuICAgICAgICAnRXZlbnRQbHVnaW5SZWdpc3RyeTogRmFpbGVkIHRvIHB1Ymxpc2ggZXZlbnQgYCVzYCBmb3IgcGx1Z2luIGAlc2AuJyxcbiAgICAgICAgZXZlbnROYW1lLFxuICAgICAgICBwbHVnaW5OYW1lXG4gICAgICApIDogaW52YXJpYW50KHB1Ymxpc2hFdmVudEZvclBsdWdpbihcbiAgICAgICAgcHVibGlzaGVkRXZlbnRzW2V2ZW50TmFtZV0sXG4gICAgICAgIFBsdWdpbk1vZHVsZSxcbiAgICAgICAgZXZlbnROYW1lXG4gICAgICApKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUHVibGlzaGVzIGFuIGV2ZW50IHNvIHRoYXQgaXQgY2FuIGJlIGRpc3BhdGNoZWQgYnkgdGhlIHN1cHBsaWVkIHBsdWdpbi5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgRGlzcGF0Y2ggY29uZmlndXJhdGlvbiBmb3IgdGhlIGV2ZW50LlxuICogQHBhcmFtIHtvYmplY3R9IFBsdWdpbk1vZHVsZSBQbHVnaW4gcHVibGlzaGluZyB0aGUgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCB3YXMgc3VjY2Vzc2Z1bGx5IHB1Ymxpc2hlZC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHB1Ymxpc2hFdmVudEZvclBsdWdpbihkaXNwYXRjaENvbmZpZywgUGx1Z2luTW9kdWxlLCBldmVudE5hbWUpIHtcbiAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAhRXZlbnRQbHVnaW5SZWdpc3RyeS5ldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSxcbiAgICAnRXZlbnRQbHVnaW5IdWI6IE1vcmUgdGhhbiBvbmUgcGx1Z2luIGF0dGVtcHRlZCB0byBwdWJsaXNoIHRoZSBzYW1lICcgK1xuICAgICdldmVudCBuYW1lLCBgJXNgLicsXG4gICAgZXZlbnROYW1lXG4gICkgOiBpbnZhcmlhbnQoIUV2ZW50UGx1Z2luUmVnaXN0cnkuZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzLmhhc093blByb3BlcnR5KGV2ZW50TmFtZSkpKTtcbiAgRXZlbnRQbHVnaW5SZWdpc3RyeS5ldmVudE5hbWVEaXNwYXRjaENvbmZpZ3NbZXZlbnROYW1lXSA9IGRpc3BhdGNoQ29uZmlnO1xuXG4gIHZhciBwaGFzZWRSZWdpc3RyYXRpb25OYW1lcyA9IGRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzO1xuICBpZiAocGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICBmb3IgKHZhciBwaGFzZU5hbWUgaW4gcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICAgIGlmIChwaGFzZWRSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShwaGFzZU5hbWUpKSB7XG4gICAgICAgIHZhciBwaGFzZWRSZWdpc3RyYXRpb25OYW1lID0gcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNbcGhhc2VOYW1lXTtcbiAgICAgICAgcHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUoXG4gICAgICAgICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZSxcbiAgICAgICAgICBQbHVnaW5Nb2R1bGUsXG4gICAgICAgICAgZXZlbnROYW1lXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShcbiAgICAgIGRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUsXG4gICAgICBQbHVnaW5Nb2R1bGUsXG4gICAgICBldmVudE5hbWVcbiAgICApO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBQdWJsaXNoZXMgYSByZWdpc3RyYXRpb24gbmFtZSB0aGF0IGlzIHVzZWQgdG8gaWRlbnRpZnkgZGlzcGF0Y2hlZCBldmVudHMgYW5kXG4gKiBjYW4gYmUgdXNlZCB3aXRoIGBFdmVudFBsdWdpbkh1Yi5wdXRMaXN0ZW5lcmAgdG8gcmVnaXN0ZXIgbGlzdGVuZXJzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIFJlZ2lzdHJhdGlvbiBuYW1lIHRvIGFkZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBQbHVnaW5Nb2R1bGUgUGx1Z2luIHB1Ymxpc2hpbmcgdGhlIGV2ZW50LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUocmVnaXN0cmF0aW9uTmFtZSwgUGx1Z2luTW9kdWxlLCBldmVudE5hbWUpIHtcbiAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAhRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXSxcbiAgICAnRXZlbnRQbHVnaW5IdWI6IE1vcmUgdGhhbiBvbmUgcGx1Z2luIGF0dGVtcHRlZCB0byBwdWJsaXNoIHRoZSBzYW1lICcgK1xuICAgICdyZWdpc3RyYXRpb24gbmFtZSwgYCVzYC4nLFxuICAgIHJlZ2lzdHJhdGlvbk5hbWVcbiAgKSA6IGludmFyaWFudCghRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXSkpO1xuICBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdID0gUGx1Z2luTW9kdWxlO1xuICBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV0gPVxuICAgIFBsdWdpbk1vZHVsZS5ldmVudFR5cGVzW2V2ZW50TmFtZV0uZGVwZW5kZW5jaWVzO1xufVxuXG4vKipcbiAqIFJlZ2lzdGVycyBwbHVnaW5zIHNvIHRoYXQgdGhleSBjYW4gZXh0cmFjdCBhbmQgZGlzcGF0Y2ggZXZlbnRzLlxuICpcbiAqIEBzZWUge0V2ZW50UGx1Z2luSHVifVxuICovXG52YXIgRXZlbnRQbHVnaW5SZWdpc3RyeSA9IHtcblxuICAvKipcbiAgICogT3JkZXJlZCBsaXN0IG9mIGluamVjdGVkIHBsdWdpbnMuXG4gICAqL1xuICBwbHVnaW5zOiBbXSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIGV2ZW50IG5hbWUgdG8gZGlzcGF0Y2ggY29uZmlnXG4gICAqL1xuICBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3M6IHt9LFxuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gcmVnaXN0cmF0aW9uIG5hbWUgdG8gcGx1Z2luIG1vZHVsZVxuICAgKi9cbiAgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXM6IHt9LFxuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gcmVnaXN0cmF0aW9uIG5hbWUgdG8gZXZlbnQgbmFtZVxuICAgKi9cbiAgcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llczoge30sXG5cbiAgLyoqXG4gICAqIEluamVjdHMgYW4gb3JkZXJpbmcgb2YgcGx1Z2lucyAoYnkgcGx1Z2luIG5hbWUpLiBUaGlzIGFsbG93cyB0aGUgb3JkZXJpbmdcbiAgICogdG8gYmUgZGVjb3VwbGVkIGZyb20gaW5qZWN0aW9uIG9mIHRoZSBhY3R1YWwgcGx1Z2lucyBzbyB0aGF0IG9yZGVyaW5nIGlzXG4gICAqIGFsd2F5cyBkZXRlcm1pbmlzdGljIHJlZ2FyZGxlc3Mgb2YgcGFja2FnaW5nLCBvbi10aGUtZmx5IGluamVjdGlvbiwgZXRjLlxuICAgKlxuICAgKiBAcGFyYW0ge2FycmF5fSBJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXJcbiAgICogQGludGVybmFsXG4gICAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmluamVjdGlvbi5pbmplY3RFdmVudFBsdWdpbk9yZGVyfVxuICAgKi9cbiAgaW5qZWN0RXZlbnRQbHVnaW5PcmRlcjogZnVuY3Rpb24oSW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyKSB7XG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICFFdmVudFBsdWdpbk9yZGVyLFxuICAgICAgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgZXZlbnQgcGx1Z2luIG9yZGVyaW5nIG1vcmUgdGhhbiAnICtcbiAgICAgICdvbmNlLiBZb3UgYXJlIGxpa2VseSB0cnlpbmcgdG8gbG9hZCBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QuJ1xuICAgICkgOiBpbnZhcmlhbnQoIUV2ZW50UGx1Z2luT3JkZXIpKTtcbiAgICAvLyBDbG9uZSB0aGUgb3JkZXJpbmcgc28gaXQgY2Fubm90IGJlIGR5bmFtaWNhbGx5IG11dGF0ZWQuXG4gICAgRXZlbnRQbHVnaW5PcmRlciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKEluamVjdGVkRXZlbnRQbHVnaW5PcmRlcik7XG4gICAgcmVjb21wdXRlUGx1Z2luT3JkZXJpbmcoKTtcbiAgfSxcblxuICAvKipcbiAgICogSW5qZWN0cyBwbHVnaW5zIHRvIGJlIHVzZWQgYnkgYEV2ZW50UGx1Z2luSHViYC4gVGhlIHBsdWdpbiBuYW1lcyBtdXN0IGJlXG4gICAqIGluIHRoZSBvcmRlcmluZyBpbmplY3RlZCBieSBgaW5qZWN0RXZlbnRQbHVnaW5PcmRlcmAuXG4gICAqXG4gICAqIFBsdWdpbnMgY2FuIGJlIGluamVjdGVkIGFzIHBhcnQgb2YgcGFnZSBpbml0aWFsaXphdGlvbiBvciBvbi10aGUtZmx5LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5qZWN0ZWROYW1lc1RvUGx1Z2lucyBNYXAgZnJvbSBuYW1lcyB0byBwbHVnaW4gbW9kdWxlcy5cbiAgICogQGludGVybmFsXG4gICAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmluamVjdGlvbi5pbmplY3RFdmVudFBsdWdpbnNCeU5hbWV9XG4gICAqL1xuICBpbmplY3RFdmVudFBsdWdpbnNCeU5hbWU6IGZ1bmN0aW9uKGluamVjdGVkTmFtZXNUb1BsdWdpbnMpIHtcbiAgICB2YXIgaXNPcmRlcmluZ0RpcnR5ID0gZmFsc2U7XG4gICAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBpbmplY3RlZE5hbWVzVG9QbHVnaW5zKSB7XG4gICAgICBpZiAoIWluamVjdGVkTmFtZXNUb1BsdWdpbnMuaGFzT3duUHJvcGVydHkocGx1Z2luTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgUGx1Z2luTW9kdWxlID0gaW5qZWN0ZWROYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXTtcbiAgICAgIGlmICghbmFtZXNUb1BsdWdpbnMuaGFzT3duUHJvcGVydHkocGx1Z2luTmFtZSkgfHxcbiAgICAgICAgICBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSAhPT0gUGx1Z2luTW9kdWxlKSB7XG4gICAgICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAgICAgIW5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdLFxuICAgICAgICAgICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBDYW5ub3QgaW5qZWN0IHR3byBkaWZmZXJlbnQgZXZlbnQgcGx1Z2lucyAnICtcbiAgICAgICAgICAndXNpbmcgdGhlIHNhbWUgbmFtZSwgYCVzYC4nLFxuICAgICAgICAgIHBsdWdpbk5hbWVcbiAgICAgICAgKSA6IGludmFyaWFudCghbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0pKTtcbiAgICAgICAgbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gPSBQbHVnaW5Nb2R1bGU7XG4gICAgICAgIGlzT3JkZXJpbmdEaXJ0eSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc09yZGVyaW5nRGlydHkpIHtcbiAgICAgIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBMb29rcyB1cCB0aGUgcGx1Z2luIGZvciB0aGUgc3VwcGxpZWQgZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudCBBIHN5bnRoZXRpYyBldmVudC5cbiAgICogQHJldHVybiB7P29iamVjdH0gVGhlIHBsdWdpbiB0aGF0IGNyZWF0ZWQgdGhlIHN1cHBsaWVkIGV2ZW50LlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldFBsdWdpbk1vZHVsZUZvckV2ZW50OiBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBkaXNwYXRjaENvbmZpZyA9IGV2ZW50LmRpc3BhdGNoQ29uZmlnO1xuICAgIGlmIChkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgICByZXR1cm4gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tcbiAgICAgICAgZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZVxuICAgICAgXSB8fCBudWxsO1xuICAgIH1cbiAgICBmb3IgKHZhciBwaGFzZSBpbiBkaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgICAgaWYgKCFkaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShwaGFzZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgUGx1Z2luTW9kdWxlID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tcbiAgICAgICAgZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNbcGhhc2VdXG4gICAgICBdO1xuICAgICAgaWYgKFBsdWdpbk1vZHVsZSkge1xuICAgICAgICByZXR1cm4gUGx1Z2luTW9kdWxlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogRXhwb3NlZCBmb3IgdW5pdCB0ZXN0aW5nLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Jlc2V0RXZlbnRQbHVnaW5zOiBmdW5jdGlvbigpIHtcbiAgICBFdmVudFBsdWdpbk9yZGVyID0gbnVsbDtcbiAgICBmb3IgKHZhciBwbHVnaW5OYW1lIGluIG5hbWVzVG9QbHVnaW5zKSB7XG4gICAgICBpZiAobmFtZXNUb1BsdWdpbnMuaGFzT3duUHJvcGVydHkocGx1Z2luTmFtZSkpIHtcbiAgICAgICAgZGVsZXRlIG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgICBFdmVudFBsdWdpblJlZ2lzdHJ5LnBsdWdpbnMubGVuZ3RoID0gMDtcblxuICAgIHZhciBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LmV2ZW50TmFtZURpc3BhdGNoQ29uZmlncztcbiAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzKSB7XG4gICAgICBpZiAoZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzLmhhc093blByb3BlcnR5KGV2ZW50TmFtZSkpIHtcbiAgICAgICAgZGVsZXRlIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnc1tldmVudE5hbWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZWdpc3RyYXRpb25OYW1lTW9kdWxlcyA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXM7XG4gICAgZm9yICh2YXIgcmVnaXN0cmF0aW9uTmFtZSBpbiByZWdpc3RyYXRpb25OYW1lTW9kdWxlcykge1xuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHJlZ2lzdHJhdGlvbk5hbWUpKSB7XG4gICAgICAgIGRlbGV0ZSByZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEV2ZW50UGx1Z2luVXRpbHNcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZShcIi4vRXZlbnRDb25zdGFudHNcIik7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbi8qKlxuICogSW5qZWN0ZWQgZGVwZW5kZW5jaWVzOlxuICovXG5cbi8qKlxuICogLSBgTW91bnRgOiBbcmVxdWlyZWRdIE1vZHVsZSB0aGF0IGNhbiBjb252ZXJ0IGJldHdlZW4gUmVhY3QgZG9tIElEcyBhbmRcbiAqICAgYWN0dWFsIG5vZGUgcmVmZXJlbmNlcy5cbiAqL1xudmFyIGluamVjdGlvbiA9IHtcbiAgTW91bnQ6IG51bGwsXG4gIGluamVjdE1vdW50OiBmdW5jdGlvbihJbmplY3RlZE1vdW50KSB7XG4gICAgaW5qZWN0aW9uLk1vdW50ID0gSW5qZWN0ZWRNb3VudDtcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgICBJbmplY3RlZE1vdW50ICYmIEluamVjdGVkTW91bnQuZ2V0Tm9kZSxcbiAgICAgICAgJ0V2ZW50UGx1Z2luVXRpbHMuaW5qZWN0aW9uLmluamVjdE1vdW50KC4uLik6IEluamVjdGVkIE1vdW50IG1vZHVsZSAnICtcbiAgICAgICAgJ2lzIG1pc3NpbmcgZ2V0Tm9kZS4nXG4gICAgICApIDogaW52YXJpYW50KEluamVjdGVkTW91bnQgJiYgSW5qZWN0ZWRNb3VudC5nZXROb2RlKSk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG5cbmZ1bmN0aW9uIGlzRW5kaXNoKHRvcExldmVsVHlwZSkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlVXAgfHxcbiAgICAgICAgIHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BUb3VjaEVuZCB8fFxuICAgICAgICAgdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcFRvdWNoQ2FuY2VsO1xufVxuXG5mdW5jdGlvbiBpc01vdmVpc2godG9wTGV2ZWxUeXBlKSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wTW91c2VNb3ZlIHx8XG4gICAgICAgICB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wVG91Y2hNb3ZlO1xufVxuZnVuY3Rpb24gaXNTdGFydGlzaCh0b3BMZXZlbFR5cGUpIHtcbiAgcmV0dXJuIHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd24gfHxcbiAgICAgICAgIHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BUb3VjaFN0YXJ0O1xufVxuXG5cbnZhciB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcztcbmlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMgPSBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBkaXNwYXRjaExpc3RlbmVycyA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgICB2YXIgZGlzcGF0Y2hJRHMgPSBldmVudC5fZGlzcGF0Y2hJRHM7XG5cbiAgICB2YXIgbGlzdGVuZXJzSXNBcnIgPSBBcnJheS5pc0FycmF5KGRpc3BhdGNoTGlzdGVuZXJzKTtcbiAgICB2YXIgaWRzSXNBcnIgPSBBcnJheS5pc0FycmF5KGRpc3BhdGNoSURzKTtcbiAgICB2YXIgSURzTGVuID0gaWRzSXNBcnIgPyBkaXNwYXRjaElEcy5sZW5ndGggOiBkaXNwYXRjaElEcyA/IDEgOiAwO1xuICAgIHZhciBsaXN0ZW5lcnNMZW4gPSBsaXN0ZW5lcnNJc0FyciA/XG4gICAgICBkaXNwYXRjaExpc3RlbmVycy5sZW5ndGggOlxuICAgICAgZGlzcGF0Y2hMaXN0ZW5lcnMgPyAxIDogMDtcblxuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICBpZHNJc0FyciA9PT0gbGlzdGVuZXJzSXNBcnIgJiYgSURzTGVuID09PSBsaXN0ZW5lcnNMZW4sXG4gICAgICAnRXZlbnRQbHVnaW5VdGlsczogSW52YWxpZCBgZXZlbnRgLidcbiAgICApIDogaW52YXJpYW50KGlkc0lzQXJyID09PSBsaXN0ZW5lcnNJc0FyciAmJiBJRHNMZW4gPT09IGxpc3RlbmVyc0xlbikpO1xuICB9O1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNiKGV2ZW50LCBsaXN0ZW5lciwgaWQpYC4gQXZvaWRzIHVzaW5nIGNhbGwgaWYgbm8gc2NvcGUgaXNcbiAqIHByb3ZpZGVkLiBUaGUgYChsaXN0ZW5lcixpZClgIHBhaXIgZWZmZWN0aXZlbHkgZm9ybXMgdGhlIFwiZGlzcGF0Y2hcIiBidXQgYXJlXG4gKiBrZXB0IHNlcGFyYXRlIHRvIGNvbnNlcnZlIG1lbW9yeS5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaEV2ZW50RGlzcGF0Y2goZXZlbnQsIGNiKSB7XG4gIHZhciBkaXNwYXRjaExpc3RlbmVycyA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgdmFyIGRpc3BhdGNoSURzID0gZXZlbnQuX2Rpc3BhdGNoSURzO1xuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMoZXZlbnQpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGRpc3BhdGNoTGlzdGVuZXJzKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gTGlzdGVuZXJzIGFuZCBJRHMgYXJlIHR3byBwYXJhbGxlbCBhcnJheXMgdGhhdCBhcmUgYWx3YXlzIGluIHN5bmMuXG4gICAgICBjYihldmVudCwgZGlzcGF0Y2hMaXN0ZW5lcnNbaV0sIGRpc3BhdGNoSURzW2ldKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnMpIHtcbiAgICBjYihldmVudCwgZGlzcGF0Y2hMaXN0ZW5lcnMsIGRpc3BhdGNoSURzKTtcbiAgfVxufVxuXG4vKipcbiAqIERlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgUGx1Z2luTW9kdWxlLmV4ZWN1dGVEaXNwYXRjaCgpLlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gU3ludGhldGljRXZlbnQgdG8gaGFuZGxlXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBBcHBsaWNhdGlvbi1sZXZlbCBjYWxsYmFja1xuICogQHBhcmFtIHtzdHJpbmd9IGRvbUlEIERPTSBpZCB0byBwYXNzIHRvIHRoZSBjYWxsYmFjay5cbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBsaXN0ZW5lciwgZG9tSUQpIHtcbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IGluamVjdGlvbi5Nb3VudC5nZXROb2RlKGRvbUlEKTtcbiAgdmFyIHJldHVyblZhbHVlID0gbGlzdGVuZXIoZXZlbnQsIGRvbUlEKTtcbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IG51bGw7XG4gIHJldHVybiByZXR1cm5WYWx1ZTtcbn1cblxuLyoqXG4gKiBTdGFuZGFyZC9zaW1wbGUgaXRlcmF0aW9uIHRocm91Z2ggYW4gZXZlbnQncyBjb2xsZWN0ZWQgZGlzcGF0Y2hlcy5cbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyKGV2ZW50LCBleGVjdXRlRGlzcGF0Y2gpIHtcbiAgZm9yRWFjaEV2ZW50RGlzcGF0Y2goZXZlbnQsIGV4ZWN1dGVEaXNwYXRjaCk7XG4gIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IG51bGw7XG4gIGV2ZW50Ll9kaXNwYXRjaElEcyA9IG51bGw7XG59XG5cbi8qKlxuICogU3RhbmRhcmQvc2ltcGxlIGl0ZXJhdGlvbiB0aHJvdWdoIGFuIGV2ZW50J3MgY29sbGVjdGVkIGRpc3BhdGNoZXMsIGJ1dCBzdG9wc1xuICogYXQgdGhlIGZpcnN0IGRpc3BhdGNoIGV4ZWN1dGlvbiByZXR1cm5pbmcgdHJ1ZSwgYW5kIHJldHVybnMgdGhhdCBpZC5cbiAqXG4gKiBAcmV0dXJuIGlkIG9mIHRoZSBmaXJzdCBkaXNwYXRjaCBleGVjdXRpb24gd2hvJ3MgbGlzdGVuZXIgcmV0dXJucyB0cnVlLCBvclxuICogbnVsbCBpZiBubyBsaXN0ZW5lciByZXR1cm5lZCB0cnVlLlxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlSW1wbChldmVudCkge1xuICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gIHZhciBkaXNwYXRjaElEcyA9IGV2ZW50Ll9kaXNwYXRjaElEcztcbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycykpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIExpc3RlbmVycyBhbmQgSURzIGFyZSB0d28gcGFyYWxsZWwgYXJyYXlzIHRoYXQgYXJlIGFsd2F5cyBpbiBzeW5jLlxuICAgICAgaWYgKGRpc3BhdGNoTGlzdGVuZXJzW2ldKGV2ZW50LCBkaXNwYXRjaElEc1tpXSkpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoSURzW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChkaXNwYXRjaExpc3RlbmVycykge1xuICAgIGlmIChkaXNwYXRjaExpc3RlbmVycyhldmVudCwgZGlzcGF0Y2hJRHMpKSB7XG4gICAgICByZXR1cm4gZGlzcGF0Y2hJRHM7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEBzZWUgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZUltcGxcbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZShldmVudCkge1xuICB2YXIgcmV0ID0gZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZUltcGwoZXZlbnQpO1xuICBldmVudC5fZGlzcGF0Y2hJRHMgPSBudWxsO1xuICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBudWxsO1xuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIEV4ZWN1dGlvbiBvZiBhIFwiZGlyZWN0XCIgZGlzcGF0Y2ggLSB0aGVyZSBtdXN0IGJlIGF0IG1vc3Qgb25lIGRpc3BhdGNoXG4gKiBhY2N1bXVsYXRlZCBvbiB0aGUgZXZlbnQgb3IgaXQgaXMgY29uc2lkZXJlZCBhbiBlcnJvci4gSXQgZG9lc24ndCByZWFsbHkgbWFrZVxuICogc2Vuc2UgZm9yIGFuIGV2ZW50IHdpdGggbXVsdGlwbGUgZGlzcGF0Y2hlcyAoYnViYmxlZCkgdG8ga2VlcCB0cmFjayBvZiB0aGVcbiAqIHJldHVybiB2YWx1ZXMgYXQgZWFjaCBkaXNwYXRjaCBleGVjdXRpb24sIGJ1dCBpdCBkb2VzIHRlbmQgdG8gbWFrZSBzZW5zZSB3aGVuXG4gKiBkZWFsaW5nIHdpdGggXCJkaXJlY3RcIiBkaXNwYXRjaGVzLlxuICpcbiAqIEByZXR1cm4gVGhlIHJldHVybiB2YWx1ZSBvZiBleGVjdXRpbmcgdGhlIHNpbmdsZSBkaXNwYXRjaC5cbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZURpcmVjdERpc3BhdGNoKGV2ZW50KSB7XG4gIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyhldmVudCk7XG4gIH1cbiAgdmFyIGRpc3BhdGNoTGlzdGVuZXIgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gIHZhciBkaXNwYXRjaElEID0gZXZlbnQuX2Rpc3BhdGNoSURzO1xuICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICFBcnJheS5pc0FycmF5KGRpc3BhdGNoTGlzdGVuZXIpLFxuICAgICdleGVjdXRlRGlyZWN0RGlzcGF0Y2goLi4uKTogSW52YWxpZCBgZXZlbnRgLidcbiAgKSA6IGludmFyaWFudCghQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVyKSkpO1xuICB2YXIgcmVzID0gZGlzcGF0Y2hMaXN0ZW5lciA/XG4gICAgZGlzcGF0Y2hMaXN0ZW5lcihldmVudCwgZGlzcGF0Y2hJRCkgOlxuICAgIG51bGw7XG4gIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IG51bGw7XG4gIGV2ZW50Ll9kaXNwYXRjaElEcyA9IG51bGw7XG4gIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnRcbiAqIEByZXR1cm4ge2Jvb2x9IFRydWUgaWZmIG51bWJlciBvZiBkaXNwYXRjaGVzIGFjY3VtdWxhdGVkIGlzIGdyZWF0ZXIgdGhhbiAwLlxuICovXG5mdW5jdGlvbiBoYXNEaXNwYXRjaGVzKGV2ZW50KSB7XG4gIHJldHVybiAhIWV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbn1cblxuLyoqXG4gKiBHZW5lcmFsIHV0aWxpdGllcyB0aGF0IGFyZSB1c2VmdWwgaW4gY3JlYXRpbmcgY3VzdG9tIEV2ZW50IFBsdWdpbnMuXG4gKi9cbnZhciBFdmVudFBsdWdpblV0aWxzID0ge1xuICBpc0VuZGlzaDogaXNFbmRpc2gsXG4gIGlzTW92ZWlzaDogaXNNb3ZlaXNoLFxuICBpc1N0YXJ0aXNoOiBpc1N0YXJ0aXNoLFxuXG4gIGV4ZWN1dGVEaXJlY3REaXNwYXRjaDogZXhlY3V0ZURpcmVjdERpc3BhdGNoLFxuICBleGVjdXRlRGlzcGF0Y2g6IGV4ZWN1dGVEaXNwYXRjaCxcbiAgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyOiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIsXG4gIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWU6IGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWUsXG4gIGhhc0Rpc3BhdGNoZXM6IGhhc0Rpc3BhdGNoZXMsXG4gIGluamVjdGlvbjogaW5qZWN0aW9uLFxuICB1c2VUb3VjaEV2ZW50czogZmFsc2Vcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRQbHVnaW5VdGlscztcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFdmVudFByb3BhZ2F0b3JzXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoXCIuL0V2ZW50Q29uc3RhbnRzXCIpO1xudmFyIEV2ZW50UGx1Z2luSHViID0gcmVxdWlyZShcIi4vRXZlbnRQbHVnaW5IdWJcIik7XG5cbnZhciBhY2N1bXVsYXRlID0gcmVxdWlyZShcIi4vYWNjdW11bGF0ZVwiKTtcbnZhciBmb3JFYWNoQWNjdW11bGF0ZWQgPSByZXF1aXJlKFwiLi9mb3JFYWNoQWNjdW11bGF0ZWRcIik7XG5cbnZhciBQcm9wYWdhdGlvblBoYXNlcyA9IEV2ZW50Q29uc3RhbnRzLlByb3BhZ2F0aW9uUGhhc2VzO1xudmFyIGdldExpc3RlbmVyID0gRXZlbnRQbHVnaW5IdWIuZ2V0TGlzdGVuZXI7XG5cbi8qKlxuICogU29tZSBldmVudCB0eXBlcyBoYXZlIGEgbm90aW9uIG9mIGRpZmZlcmVudCByZWdpc3RyYXRpb24gbmFtZXMgZm9yIGRpZmZlcmVudFxuICogXCJwaGFzZXNcIiBvZiBwcm9wYWdhdGlvbi4gVGhpcyBmaW5kcyBsaXN0ZW5lcnMgYnkgYSBnaXZlbiBwaGFzZS5cbiAqL1xuZnVuY3Rpb24gbGlzdGVuZXJBdFBoYXNlKGlkLCBldmVudCwgcHJvcGFnYXRpb25QaGFzZSkge1xuICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9XG4gICAgZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNbcHJvcGFnYXRpb25QaGFzZV07XG4gIHJldHVybiBnZXRMaXN0ZW5lcihpZCwgcmVnaXN0cmF0aW9uTmFtZSk7XG59XG5cbi8qKlxuICogVGFncyBhIGBTeW50aGV0aWNFdmVudGAgd2l0aCBkaXNwYXRjaGVkIGxpc3RlbmVycy4gQ3JlYXRpbmcgdGhpcyBmdW5jdGlvblxuICogaGVyZSwgYWxsb3dzIHVzIHRvIG5vdCBoYXZlIHRvIGJpbmQgb3IgY3JlYXRlIGZ1bmN0aW9ucyBmb3IgZWFjaCBldmVudC5cbiAqIE11dGF0aW5nIHRoZSBldmVudCdzIG1lbWJlcnMgYWxsb3dzIHVzIHRvIG5vdCBoYXZlIHRvIGNyZWF0ZSBhIHdyYXBwaW5nXG4gKiBcImRpc3BhdGNoXCIgb2JqZWN0IHRoYXQgcGFpcnMgdGhlIGV2ZW50IHdpdGggdGhlIGxpc3RlbmVyLlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzKGRvbUlELCB1cHdhcmRzLCBldmVudCkge1xuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgaWYgKCFkb21JRCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEaXNwYXRjaGluZyBpZCBtdXN0IG5vdCBiZSBudWxsJyk7XG4gICAgfVxuICB9XG4gIHZhciBwaGFzZSA9IHVwd2FyZHMgPyBQcm9wYWdhdGlvblBoYXNlcy5idWJibGVkIDogUHJvcGFnYXRpb25QaGFzZXMuY2FwdHVyZWQ7XG4gIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyQXRQaGFzZShkb21JRCwgZXZlbnQsIHBoYXNlKTtcbiAgaWYgKGxpc3RlbmVyKSB7XG4gICAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gYWNjdW11bGF0ZShldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMsIGxpc3RlbmVyKTtcbiAgICBldmVudC5fZGlzcGF0Y2hJRHMgPSBhY2N1bXVsYXRlKGV2ZW50Ll9kaXNwYXRjaElEcywgZG9tSUQpO1xuICB9XG59XG5cbi8qKlxuICogQ29sbGVjdCBkaXNwYXRjaGVzIChtdXN0IGJlIGVudGlyZWx5IGNvbGxlY3RlZCBiZWZvcmUgZGlzcGF0Y2hpbmcgLSBzZWUgdW5pdFxuICogdGVzdHMpLiBMYXppbHkgYWxsb2NhdGUgdGhlIGFycmF5IHRvIGNvbnNlcnZlIG1lbW9yeS4gIFdlIG11c3QgbG9vcCB0aHJvdWdoXG4gKiBlYWNoIGV2ZW50IGFuZCBwZXJmb3JtIHRoZSB0cmF2ZXJzYWwgZm9yIGVhY2ggb25lLiBXZSBjYW4gbm90IHBlcmZvcm0gYVxuICogc2luZ2xlIHRyYXZlcnNhbCBmb3IgdGhlIGVudGlyZSBjb2xsZWN0aW9uIG9mIGV2ZW50cyBiZWNhdXNlIGVhY2ggZXZlbnQgbWF5XG4gKiBoYXZlIGEgZGlmZmVyZW50IHRhcmdldC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZShldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICBFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uZ2V0SW5zdGFuY2VIYW5kbGUoKS50cmF2ZXJzZVR3b1BoYXNlKFxuICAgICAgZXZlbnQuZGlzcGF0Y2hNYXJrZXIsXG4gICAgICBhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzLFxuICAgICAgZXZlbnRcbiAgICApO1xuICB9XG59XG5cblxuLyoqXG4gKiBBY2N1bXVsYXRlcyB3aXRob3V0IHJlZ2FyZCB0byBkaXJlY3Rpb24sIGRvZXMgbm90IGxvb2sgZm9yIHBoYXNlZFxuICogcmVnaXN0cmF0aW9uIG5hbWVzLiBTYW1lIGFzIGBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZWAgYnV0IHdpdGhvdXRcbiAqIHJlcXVpcmluZyB0aGF0IHRoZSBgZGlzcGF0Y2hNYXJrZXJgIGJlIHRoZSBzYW1lIGFzIHRoZSBkaXNwYXRjaGVkIElELlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlzcGF0Y2hlcyhpZCwgaWdub3JlZERpcmVjdGlvbiwgZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWU7XG4gICAgdmFyIGxpc3RlbmVyID0gZ2V0TGlzdGVuZXIoaWQsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gYWNjdW11bGF0ZShldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMsIGxpc3RlbmVyKTtcbiAgICAgIGV2ZW50Ll9kaXNwYXRjaElEcyA9IGFjY3VtdWxhdGUoZXZlbnQuX2Rpc3BhdGNoSURzLCBpZCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWNjdW11bGF0ZXMgZGlzcGF0Y2hlcyBvbiBhbiBgU3ludGhldGljRXZlbnRgLCBidXQgb25seSBmb3IgdGhlXG4gKiBgZGlzcGF0Y2hNYXJrZXJgLlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnRcbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGUoZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICBhY2N1bXVsYXRlRGlzcGF0Y2hlcyhldmVudC5kaXNwYXRjaE1hcmtlciwgbnVsbCwgZXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnRzKSB7XG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGUpO1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXMobGVhdmUsIGVudGVyLCBmcm9tSUQsIHRvSUQpIHtcbiAgRXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmdldEluc3RhbmNlSGFuZGxlKCkudHJhdmVyc2VFbnRlckxlYXZlKFxuICAgIGZyb21JRCxcbiAgICB0b0lELFxuICAgIGFjY3VtdWxhdGVEaXNwYXRjaGVzLFxuICAgIGxlYXZlLFxuICAgIGVudGVyXG4gICk7XG59XG5cblxuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXMoZXZlbnRzKSB7XG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlKTtcbn1cblxuXG5cbi8qKlxuICogQSBzbWFsbCBzZXQgb2YgcHJvcGFnYXRpb24gcGF0dGVybnMsIGVhY2ggb2Ygd2hpY2ggd2lsbCBhY2NlcHQgYSBzbWFsbCBhbW91bnRcbiAqIG9mIGluZm9ybWF0aW9uLCBhbmQgZ2VuZXJhdGUgYSBzZXQgb2YgXCJkaXNwYXRjaCByZWFkeSBldmVudCBvYmplY3RzXCIgLSB3aGljaFxuICogYXJlIHNldHMgb2YgZXZlbnRzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gYW5ub3RhdGVkIHdpdGggYSBzZXQgb2YgZGlzcGF0Y2hlZFxuICogbGlzdGVuZXIgZnVuY3Rpb25zL2lkcy4gVGhlIEFQSSBpcyBkZXNpZ25lZCB0aGlzIHdheSB0byBkaXNjb3VyYWdlIHRoZXNlXG4gKiBwcm9wYWdhdGlvbiBzdHJhdGVnaWVzIGZyb20gYWN0dWFsbHkgZXhlY3V0aW5nIHRoZSBkaXNwYXRjaGVzLCBzaW5jZSB3ZVxuICogYWx3YXlzIHdhbnQgdG8gY29sbGVjdCB0aGUgZW50aXJlIHNldCBvZiBkaXNwYXRjaGVzIGJlZm9yZSBleGVjdXRpbmcgZXZlbnQgYVxuICogc2luZ2xlIG9uZS5cbiAqXG4gKiBAY29uc3RydWN0b3IgRXZlbnRQcm9wYWdhdG9yc1xuICovXG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHtcbiAgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlczogYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyxcbiAgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXM6IGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzLFxuICBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXM6IGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlc1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFByb3BhZ2F0b3JzO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRXhlY3V0aW9uRW52aXJvbm1lbnRcbiAqL1xuXG4vKmpzbGludCBldmlsOiB0cnVlICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgY2FuVXNlRE9NID0gISEoXG4gIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gIHdpbmRvdy5kb2N1bWVudCAmJlxuICB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudFxuKTtcblxuLyoqXG4gKiBTaW1wbGUsIGxpZ2h0d2VpZ2h0IG1vZHVsZSBhc3Npc3Rpbmcgd2l0aCB0aGUgZGV0ZWN0aW9uIGFuZCBjb250ZXh0IG9mXG4gKiBXb3JrZXIuIEhlbHBzIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY2llcyBhbmQgYWxsb3dzIGNvZGUgdG8gcmVhc29uIGFib3V0XG4gKiB3aGV0aGVyIG9yIG5vdCB0aGV5IGFyZSBpbiBhIFdvcmtlciwgZXZlbiBpZiB0aGV5IG5ldmVyIGluY2x1ZGUgdGhlIG1haW5cbiAqIGBSZWFjdFdvcmtlcmAgZGVwZW5kZW5jeS5cbiAqL1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0ge1xuXG4gIGNhblVzZURPTTogY2FuVXNlRE9NLFxuXG4gIGNhblVzZVdvcmtlcnM6IHR5cGVvZiBXb3JrZXIgIT09ICd1bmRlZmluZWQnLFxuXG4gIGNhblVzZUV2ZW50TGlzdGVuZXJzOlxuICAgIGNhblVzZURPTSAmJiAhISh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciB8fCB3aW5kb3cuYXR0YWNoRXZlbnQpLFxuXG4gIGNhblVzZVZpZXdwb3J0OiBjYW5Vc2VET00gJiYgISF3aW5kb3cuc2NyZWVuLFxuXG4gIGlzSW5Xb3JrZXI6ICFjYW5Vc2VET00gLy8gRm9yIG5vdywgdGhpcyBpcyB0cnVlIC0gbWlnaHQgY2hhbmdlIGluIHRoZSBmdXR1cmUuXG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXhlY3V0aW9uRW52aXJvbm1lbnQ7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgSFRNTERPTVByb3BlcnR5Q29uZmlnXG4gKi9cblxuLypqc2xpbnQgYml0d2lzZTogdHJ1ZSovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKFwiLi9ET01Qcm9wZXJ0eVwiKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoXCIuL0V4ZWN1dGlvbkVudmlyb25tZW50XCIpO1xuXG52YXIgTVVTVF9VU0VfQVRUUklCVVRFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLk1VU1RfVVNFX0FUVFJJQlVURTtcbnZhciBNVVNUX1VTRV9QUk9QRVJUWSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5NVVNUX1VTRV9QUk9QRVJUWTtcbnZhciBIQVNfQk9PTEVBTl9WQUxVRSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5IQVNfQk9PTEVBTl9WQUxVRTtcbnZhciBIQVNfU0lERV9FRkZFQ1RTID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLkhBU19TSURFX0VGRkVDVFM7XG52YXIgSEFTX05VTUVSSUNfVkFMVUUgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uSEFTX05VTUVSSUNfVkFMVUU7XG52YXIgSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUgPVxuICBET01Qcm9wZXJ0eS5pbmplY3Rpb24uSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUU7XG52YXIgSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSA9XG4gIERPTVByb3BlcnR5LmluamVjdGlvbi5IQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFO1xuXG52YXIgaGFzU1ZHO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICB2YXIgaW1wbGVtZW50YXRpb24gPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbjtcbiAgaGFzU1ZHID0gKFxuICAgIGltcGxlbWVudGF0aW9uICYmXG4gICAgaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSAmJlxuICAgIGltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoXG4gICAgICAnaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvZmVhdHVyZSNCYXNpY1N0cnVjdHVyZScsXG4gICAgICAnMS4xJ1xuICAgIClcbiAgKTtcbn1cblxuXG52YXIgSFRNTERPTVByb3BlcnR5Q29uZmlnID0ge1xuICBpc0N1c3RvbUF0dHJpYnV0ZTogUmVnRXhwLnByb3RvdHlwZS50ZXN0LmJpbmQoXG4gICAgL14oZGF0YXxhcmlhKS1bYS16X11bYS16XFxkXy5cXC1dKiQvXG4gICksXG4gIFByb3BlcnRpZXM6IHtcbiAgICAvKipcbiAgICAgKiBTdGFuZGFyZCBQcm9wZXJ0aWVzXG4gICAgICovXG4gICAgYWNjZXB0OiBudWxsLFxuICAgIGFjY2Vzc0tleTogbnVsbCxcbiAgICBhY3Rpb246IG51bGwsXG4gICAgYWxsb3dGdWxsU2NyZWVuOiBNVVNUX1VTRV9BVFRSSUJVVEUgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBhbGxvd1RyYW5zcGFyZW5jeTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGFsdDogbnVsbCxcbiAgICBhc3luYzogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgYXV0b0NvbXBsZXRlOiBudWxsLFxuICAgIC8vIGF1dG9Gb2N1cyBpcyBwb2x5ZmlsbGVkL25vcm1hbGl6ZWQgYnkgQXV0b0ZvY3VzTWl4aW5cbiAgICAvLyBhdXRvRm9jdXM6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGF1dG9QbGF5OiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjZWxsUGFkZGluZzogbnVsbCxcbiAgICBjZWxsU3BhY2luZzogbnVsbCxcbiAgICBjaGFyU2V0OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgY2hlY2tlZDogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICAvLyBUbyBzZXQgY2xhc3NOYW1lIG9uIFNWRyBlbGVtZW50cywgaXQncyBuZWNlc3NhcnkgdG8gdXNlIC5zZXRBdHRyaWJ1dGU7XG4gICAgLy8gdGhpcyB3b3JrcyBvbiBIVE1MIGVsZW1lbnRzIHRvbyBpbiBhbGwgYnJvd3NlcnMgZXhjZXB0IElFOC4gQ29udmVuaWVudGx5LFxuICAgIC8vIElFOCBkb2Vzbid0IHN1cHBvcnQgU1ZHIGFuZCBzbyB3ZSBjYW4gc2ltcGx5IHVzZSB0aGUgYXR0cmlidXRlIGluXG4gICAgLy8gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IFNWRyBhbmQgdGhlIHByb3BlcnR5IGluIGJyb3dzZXJzIHRoYXQgZG9uJ3QsXG4gICAgLy8gcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIEhUTUwgb3IgU1ZHLlxuICAgIGNsYXNzTmFtZTogaGFzU1ZHID8gTVVTVF9VU0VfQVRUUklCVVRFIDogTVVTVF9VU0VfUFJPUEVSVFksXG4gICAgY29sczogTVVTVF9VU0VfQVRUUklCVVRFIHwgSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgY29sU3BhbjogbnVsbCxcbiAgICBjb250ZW50OiBudWxsLFxuICAgIGNvbnRlbnRFZGl0YWJsZTogbnVsbCxcbiAgICBjb250ZXh0TWVudTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGNvbnRyb2xzOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGNvb3JkczogbnVsbCxcbiAgICBjcm9zc09yaWdpbjogbnVsbCxcbiAgICBkYXRhOiBudWxsLCAvLyBGb3IgYDxvYmplY3QgLz5gIGFjdHMgYXMgYHNyY2AuXG4gICAgZGF0ZVRpbWU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBkZWZlcjogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZGlyOiBudWxsLFxuICAgIGRpc2FibGVkOiBNVVNUX1VTRV9BVFRSSUJVVEUgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBkb3dubG9hZDogSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSxcbiAgICBkcmFnZ2FibGU6IG51bGwsXG4gICAgZW5jVHlwZTogbnVsbCxcbiAgICBmb3JtOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZm9ybU5vVmFsaWRhdGU6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGZyYW1lQm9yZGVyOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgaGVpZ2h0OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgaGlkZGVuOiBNVVNUX1VTRV9BVFRSSUJVVEUgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBocmVmOiBudWxsLFxuICAgIGhyZWZMYW5nOiBudWxsLFxuICAgIGh0bWxGb3I6IG51bGwsXG4gICAgaHR0cEVxdWl2OiBudWxsLFxuICAgIGljb246IG51bGwsXG4gICAgaWQ6IE1VU1RfVVNFX1BST1BFUlRZLFxuICAgIGxhYmVsOiBudWxsLFxuICAgIGxhbmc6IG51bGwsXG4gICAgbGlzdDogbnVsbCxcbiAgICBsb29wOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIG1heDogbnVsbCxcbiAgICBtYXhMZW5ndGg6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBtZWRpYUdyb3VwOiBudWxsLFxuICAgIG1ldGhvZDogbnVsbCxcbiAgICBtaW46IG51bGwsXG4gICAgbXVsdGlwbGU6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgbXV0ZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgbmFtZTogbnVsbCxcbiAgICBub1ZhbGlkYXRlOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBwYXR0ZXJuOiBudWxsLFxuICAgIHBsYWNlaG9sZGVyOiBudWxsLFxuICAgIHBvc3RlcjogbnVsbCxcbiAgICBwcmVsb2FkOiBudWxsLFxuICAgIHJhZGlvR3JvdXA6IG51bGwsXG4gICAgcmVhZE9ubHk6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcmVsOiBudWxsLFxuICAgIHJlcXVpcmVkOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICByb2xlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgcm93czogTVVTVF9VU0VfQVRUUklCVVRFIHwgSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgcm93U3BhbjogbnVsbCxcbiAgICBzYW5kYm94OiBudWxsLFxuICAgIHNjb3BlOiBudWxsLFxuICAgIHNjcm9sbExlZnQ6IE1VU1RfVVNFX1BST1BFUlRZLFxuICAgIHNjcm9sbGluZzogbnVsbCxcbiAgICBzY3JvbGxUb3A6IE1VU1RfVVNFX1BST1BFUlRZLFxuICAgIHNlYW1sZXNzOiBNVVNUX1VTRV9BVFRSSUJVVEUgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBzZWxlY3RlZDogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBzaGFwZTogbnVsbCxcbiAgICBzaXplOiBNVVNUX1VTRV9BVFRSSUJVVEUgfCBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSxcbiAgICBzcGFuOiBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSxcbiAgICBzcGVsbENoZWNrOiBudWxsLFxuICAgIHNyYzogbnVsbCxcbiAgICBzcmNEb2M6IE1VU1RfVVNFX1BST1BFUlRZLFxuICAgIHNyY1NldDogbnVsbCxcbiAgICBzdGFydDogSEFTX05VTUVSSUNfVkFMVUUsXG4gICAgc3RlcDogbnVsbCxcbiAgICBzdHlsZTogbnVsbCxcbiAgICB0YWJJbmRleDogbnVsbCxcbiAgICB0YXJnZXQ6IG51bGwsXG4gICAgdGl0bGU6IG51bGwsXG4gICAgdHlwZTogbnVsbCxcbiAgICB1c2VNYXA6IG51bGwsXG4gICAgdmFsdWU6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX1NJREVfRUZGRUNUUyxcbiAgICB3aWR0aDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHdtb2RlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG5cbiAgICAvKipcbiAgICAgKiBOb24tc3RhbmRhcmQgUHJvcGVydGllc1xuICAgICAqL1xuICAgIGF1dG9DYXBpdGFsaXplOiBudWxsLCAvLyBTdXBwb3J0ZWQgaW4gTW9iaWxlIFNhZmFyaSBmb3Iga2V5Ym9hcmQgaGludHNcbiAgICBhdXRvQ29ycmVjdDogbnVsbCwgLy8gU3VwcG9ydGVkIGluIE1vYmlsZSBTYWZhcmkgZm9yIGtleWJvYXJkIGhpbnRzXG4gICAgaXRlbVByb3A6IE1VU1RfVVNFX0FUVFJJQlVURSwgLy8gTWljcm9kYXRhOiBodHRwOi8vc2NoZW1hLm9yZy9kb2NzL2dzLmh0bWxcbiAgICBpdGVtU2NvcGU6IE1VU1RfVVNFX0FUVFJJQlVURSB8IEhBU19CT09MRUFOX1ZBTFVFLCAvLyBNaWNyb2RhdGE6IGh0dHA6Ly9zY2hlbWEub3JnL2RvY3MvZ3MuaHRtbFxuICAgIGl0ZW1UeXBlOiBNVVNUX1VTRV9BVFRSSUJVVEUsIC8vIE1pY3JvZGF0YTogaHR0cDovL3NjaGVtYS5vcmcvZG9jcy9ncy5odG1sXG4gICAgcHJvcGVydHk6IG51bGwgLy8gU3VwcG9ydHMgT0cgaW4gbWV0YSB0YWdzXG4gIH0sXG4gIERPTUF0dHJpYnV0ZU5hbWVzOiB7XG4gICAgY2xhc3NOYW1lOiAnY2xhc3MnLFxuICAgIGh0bWxGb3I6ICdmb3InLFxuICAgIGh0dHBFcXVpdjogJ2h0dHAtZXF1aXYnXG4gIH0sXG4gIERPTVByb3BlcnR5TmFtZXM6IHtcbiAgICBhdXRvQ2FwaXRhbGl6ZTogJ2F1dG9jYXBpdGFsaXplJyxcbiAgICBhdXRvQ29tcGxldGU6ICdhdXRvY29tcGxldGUnLFxuICAgIGF1dG9Db3JyZWN0OiAnYXV0b2NvcnJlY3QnLFxuICAgIGF1dG9Gb2N1czogJ2F1dG9mb2N1cycsXG4gICAgYXV0b1BsYXk6ICdhdXRvcGxheScsXG4gICAgZW5jVHlwZTogJ2VuY3R5cGUnLFxuICAgIGhyZWZMYW5nOiAnaHJlZmxhbmcnLFxuICAgIHJhZGlvR3JvdXA6ICdyYWRpb2dyb3VwJyxcbiAgICBzcGVsbENoZWNrOiAnc3BlbGxjaGVjaycsXG4gICAgc3JjRG9jOiAnc3JjZG9jJyxcbiAgICBzcmNTZXQ6ICdzcmNzZXQnXG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSFRNTERPTVByb3BlcnR5Q29uZmlnO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIExpbmtlZFN0YXRlTWl4aW5cbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBSZWFjdExpbmsgPSByZXF1aXJlKFwiLi9SZWFjdExpbmtcIik7XG52YXIgUmVhY3RTdGF0ZVNldHRlcnMgPSByZXF1aXJlKFwiLi9SZWFjdFN0YXRlU2V0dGVyc1wiKTtcblxuLyoqXG4gKiBBIHNpbXBsZSBtaXhpbiBhcm91bmQgUmVhY3RMaW5rLmZvclN0YXRlKCkuXG4gKi9cbnZhciBMaW5rZWRTdGF0ZU1peGluID0ge1xuICAvKipcbiAgICogQ3JlYXRlIGEgUmVhY3RMaW5rIHRoYXQncyBsaW5rZWQgdG8gcGFydCBvZiB0aGlzIGNvbXBvbmVudCdzIHN0YXRlLiBUaGVcbiAgICogUmVhY3RMaW5rIHdpbGwgaGF2ZSB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGlzLnN0YXRlW2tleV0gYW5kIHdpbGwgY2FsbFxuICAgKiBzZXRTdGF0ZSgpIHdoZW4gYSBjaGFuZ2UgaXMgcmVxdWVzdGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IHN0YXRlIGtleSB0byB1cGRhdGUuIE5vdGU6IHlvdSBtYXkgd2FudCB0byB1c2Uga2V5T2YoKVxuICAgKiBpZiB5b3UncmUgdXNpbmcgR29vZ2xlIENsb3N1cmUgQ29tcGlsZXIgYWR2YW5jZWQgbW9kZS5cbiAgICogQHJldHVybiB7UmVhY3RMaW5rfSBSZWFjdExpbmsgaW5zdGFuY2UgbGlua2luZyB0byB0aGUgc3RhdGUuXG4gICAqL1xuICBsaW5rU3RhdGU6IGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBuZXcgUmVhY3RMaW5rKFxuICAgICAgdGhpcy5zdGF0ZVtrZXldLFxuICAgICAgUmVhY3RTdGF0ZVNldHRlcnMuY3JlYXRlU3RhdGVLZXlTZXR0ZXIodGhpcywga2V5KVxuICAgICk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTGlua2VkU3RhdGVNaXhpbjtcbiIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgTGlua2VkVmFsdWVVdGlsc1xuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIFJlYWN0UHJvcFR5cGVzID0gcmVxdWlyZShcIi4vUmVhY3RQcm9wVHlwZXNcIik7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbnZhciBoYXNSZWFkT25seVZhbHVlID0ge1xuICAnYnV0dG9uJzogdHJ1ZSxcbiAgJ2NoZWNrYm94JzogdHJ1ZSxcbiAgJ2ltYWdlJzogdHJ1ZSxcbiAgJ2hpZGRlbic6IHRydWUsXG4gICdyYWRpbyc6IHRydWUsXG4gICdyZXNldCc6IHRydWUsXG4gICdzdWJtaXQnOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBfYXNzZXJ0U2luZ2xlTGluayhpbnB1dCkge1xuICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgIGlucHV0LnByb3BzLmNoZWNrZWRMaW5rID09IG51bGwgfHwgaW5wdXQucHJvcHMudmFsdWVMaW5rID09IG51bGwsXG4gICAgJ0Nhbm5vdCBwcm92aWRlIGEgY2hlY2tlZExpbmsgYW5kIGEgdmFsdWVMaW5rLiBJZiB5b3Ugd2FudCB0byB1c2UgJyArXG4gICAgJ2NoZWNrZWRMaW5rLCB5b3UgcHJvYmFibHkgZG9uXFwndCB3YW50IHRvIHVzZSB2YWx1ZUxpbmsgYW5kIHZpY2UgdmVyc2EuJ1xuICApIDogaW52YXJpYW50KGlucHV0LnByb3BzLmNoZWNrZWRMaW5rID09IG51bGwgfHwgaW5wdXQucHJvcHMudmFsdWVMaW5rID09IG51bGwpKTtcbn1cbmZ1bmN0aW9uIF9hc3NlcnRWYWx1ZUxpbmsoaW5wdXQpIHtcbiAgX2Fzc2VydFNpbmdsZUxpbmsoaW5wdXQpO1xuICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgIGlucHV0LnByb3BzLnZhbHVlID09IG51bGwgJiYgaW5wdXQucHJvcHMub25DaGFuZ2UgPT0gbnVsbCxcbiAgICAnQ2Fubm90IHByb3ZpZGUgYSB2YWx1ZUxpbmsgYW5kIGEgdmFsdWUgb3Igb25DaGFuZ2UgZXZlbnQuIElmIHlvdSB3YW50ICcgK1xuICAgICd0byB1c2UgdmFsdWUgb3Igb25DaGFuZ2UsIHlvdSBwcm9iYWJseSBkb25cXCd0IHdhbnQgdG8gdXNlIHZhbHVlTGluay4nXG4gICkgOiBpbnZhcmlhbnQoaW5wdXQucHJvcHMudmFsdWUgPT0gbnVsbCAmJiBpbnB1dC5wcm9wcy5vbkNoYW5nZSA9PSBudWxsKSk7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRDaGVja2VkTGluayhpbnB1dCkge1xuICBfYXNzZXJ0U2luZ2xlTGluayhpbnB1dCk7XG4gIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgaW5wdXQucHJvcHMuY2hlY2tlZCA9PSBudWxsICYmIGlucHV0LnByb3BzLm9uQ2hhbmdlID09IG51bGwsXG4gICAgJ0Nhbm5vdCBwcm92aWRlIGEgY2hlY2tlZExpbmsgYW5kIGEgY2hlY2tlZCBwcm9wZXJ0eSBvciBvbkNoYW5nZSBldmVudC4gJyArXG4gICAgJ0lmIHlvdSB3YW50IHRvIHVzZSBjaGVja2VkIG9yIG9uQ2hhbmdlLCB5b3UgcHJvYmFibHkgZG9uXFwndCB3YW50IHRvICcgK1xuICAgICd1c2UgY2hlY2tlZExpbmsnXG4gICkgOiBpbnZhcmlhbnQoaW5wdXQucHJvcHMuY2hlY2tlZCA9PSBudWxsICYmIGlucHV0LnByb3BzLm9uQ2hhbmdlID09IG51bGwpKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBlIGNoYW5nZSBldmVudCB0byBoYW5kbGVcbiAqL1xuZnVuY3Rpb24gX2hhbmRsZUxpbmtlZFZhbHVlQ2hhbmdlKGUpIHtcbiAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgdGhpcy5wcm9wcy52YWx1ZUxpbmsucmVxdWVzdENoYW5nZShlLnRhcmdldC52YWx1ZSk7XG59XG5cbi8qKlxuICAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGUgY2hhbmdlIGV2ZW50IHRvIGhhbmRsZVxuICAqL1xuZnVuY3Rpb24gX2hhbmRsZUxpbmtlZENoZWNrQ2hhbmdlKGUpIHtcbiAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgdGhpcy5wcm9wcy5jaGVja2VkTGluay5yZXF1ZXN0Q2hhbmdlKGUudGFyZ2V0LmNoZWNrZWQpO1xufVxuXG4vKipcbiAqIFByb3ZpZGUgYSBsaW5rZWQgYHZhbHVlYCBhdHRyaWJ1dGUgZm9yIGNvbnRyb2xsZWQgZm9ybXMuIFlvdSBzaG91bGQgbm90IHVzZVxuICogdGhpcyBvdXRzaWRlIG9mIHRoZSBSZWFjdERPTSBjb250cm9sbGVkIGZvcm0gY29tcG9uZW50cy5cbiAqL1xudmFyIExpbmtlZFZhbHVlVXRpbHMgPSB7XG4gIE1peGluOiB7XG4gICAgcHJvcFR5cGVzOiB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgICAgIGlmICghcHJvcHNbcHJvcE5hbWVdIHx8XG4gICAgICAgICAgICBoYXNSZWFkT25seVZhbHVlW3Byb3BzLnR5cGVdIHx8XG4gICAgICAgICAgICBwcm9wcy5vbkNoYW5nZSB8fFxuICAgICAgICAgICAgcHJvcHMucmVhZE9ubHkgfHxcbiAgICAgICAgICAgIHByb3BzLmRpc2FibGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAgICAgICAgJ1lvdSBwcm92aWRlZCBhIGB2YWx1ZWAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICtcbiAgICAgICAgICAnYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiAnICtcbiAgICAgICAgICAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdFZhbHVlYC4gT3RoZXJ3aXNlLCAnICtcbiAgICAgICAgICAnc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuJ1xuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIGNoZWNrZWQ6IGZ1bmN0aW9uKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgICAgICBpZiAoIXByb3BzW3Byb3BOYW1lXSB8fFxuICAgICAgICAgICAgcHJvcHMub25DaGFuZ2UgfHxcbiAgICAgICAgICAgIHByb3BzLnJlYWRPbmx5IHx8XG4gICAgICAgICAgICBwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgICAgICAgICdZb3UgcHJvdmlkZWQgYSBgY2hlY2tlZGAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICtcbiAgICAgICAgICAnYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiAnICtcbiAgICAgICAgICAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdENoZWNrZWRgLiBPdGhlcndpc2UsICcgK1xuICAgICAgICAgICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgb25DaGFuZ2U6IFJlYWN0UHJvcFR5cGVzLmZ1bmNcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGlucHV0IEZvcm0gY29tcG9uZW50XG4gICAqIEByZXR1cm4geyp9IGN1cnJlbnQgdmFsdWUgb2YgdGhlIGlucHV0IGVpdGhlciBmcm9tIHZhbHVlIHByb3Agb3IgbGluay5cbiAgICovXG4gIGdldFZhbHVlOiBmdW5jdGlvbihpbnB1dCkge1xuICAgIGlmIChpbnB1dC5wcm9wcy52YWx1ZUxpbmspIHtcbiAgICAgIF9hc3NlcnRWYWx1ZUxpbmsoaW5wdXQpO1xuICAgICAgcmV0dXJuIGlucHV0LnByb3BzLnZhbHVlTGluay52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0LnByb3BzLnZhbHVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBpbnB1dCBGb3JtIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHsqfSBjdXJyZW50IGNoZWNrZWQgc3RhdHVzIG9mIHRoZSBpbnB1dCBlaXRoZXIgZnJvbSBjaGVja2VkIHByb3BcbiAgICogICAgICAgICAgICAgb3IgbGluay5cbiAgICovXG4gIGdldENoZWNrZWQ6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgaWYgKGlucHV0LnByb3BzLmNoZWNrZWRMaW5rKSB7XG4gICAgICBfYXNzZXJ0Q2hlY2tlZExpbmsoaW5wdXQpO1xuICAgICAgcmV0dXJuIGlucHV0LnByb3BzLmNoZWNrZWRMaW5rLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXQucHJvcHMuY2hlY2tlZDtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gaW5wdXQgRm9ybSBjb21wb25lbnRcbiAgICogQHJldHVybiB7ZnVuY3Rpb259IGNoYW5nZSBjYWxsYmFjayBlaXRoZXIgZnJvbSBvbkNoYW5nZSBwcm9wIG9yIGxpbmsuXG4gICAqL1xuICBnZXRPbkNoYW5nZTogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQucHJvcHMudmFsdWVMaW5rKSB7XG4gICAgICBfYXNzZXJ0VmFsdWVMaW5rKGlucHV0KTtcbiAgICAgIHJldHVybiBfaGFuZGxlTGlua2VkVmFsdWVDaGFuZ2U7XG4gICAgfSBlbHNlIGlmIChpbnB1dC5wcm9wcy5jaGVja2VkTGluaykge1xuICAgICAgX2Fzc2VydENoZWNrZWRMaW5rKGlucHV0KTtcbiAgICAgIHJldHVybiBfaGFuZGxlTGlua2VkQ2hlY2tDaGFuZ2U7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dC5wcm9wcy5vbkNoYW5nZTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMaW5rZWRWYWx1ZVV0aWxzO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBMb2NhbEV2ZW50VHJhcE1peGluXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSByZXF1aXJlKFwiLi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJcIik7XG5cbnZhciBhY2N1bXVsYXRlID0gcmVxdWlyZShcIi4vYWNjdW11bGF0ZVwiKTtcbnZhciBmb3JFYWNoQWNjdW11bGF0ZWQgPSByZXF1aXJlKFwiLi9mb3JFYWNoQWNjdW11bGF0ZWRcIik7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xuXG5mdW5jdGlvbiByZW1vdmUoZXZlbnQpIHtcbiAgZXZlbnQucmVtb3ZlKCk7XG59XG5cbnZhciBMb2NhbEV2ZW50VHJhcE1peGluID0ge1xuICB0cmFwQnViYmxlZEV2ZW50OmZ1bmN0aW9uKHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lKSB7XG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudCh0aGlzLmlzTW91bnRlZCgpLCAnTXVzdCBiZSBtb3VudGVkIHRvIHRyYXAgZXZlbnRzJykgOiBpbnZhcmlhbnQodGhpcy5pc01vdW50ZWQoKSkpO1xuICAgIHZhciBsaXN0ZW5lciA9IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KFxuICAgICAgdG9wTGV2ZWxUeXBlLFxuICAgICAgaGFuZGxlckJhc2VOYW1lLFxuICAgICAgdGhpcy5nZXRET01Ob2RlKClcbiAgICApO1xuICAgIHRoaXMuX2xvY2FsRXZlbnRMaXN0ZW5lcnMgPSBhY2N1bXVsYXRlKHRoaXMuX2xvY2FsRXZlbnRMaXN0ZW5lcnMsIGxpc3RlbmVyKTtcbiAgfSxcblxuICAvLyB0cmFwQ2FwdHVyZWRFdmVudCB3b3VsZCBsb29rIG5lYXJseSBpZGVudGljYWwuIFdlIGRvbid0IGltcGxlbWVudCB0aGF0XG4gIC8vIG1ldGhvZCBiZWNhdXNlIGl0IGlzbid0IGN1cnJlbnRseSBuZWVkZWQuXG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQ6ZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2xvY2FsRXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIGZvckVhY2hBY2N1bXVsYXRlZCh0aGlzLl9sb2NhbEV2ZW50TGlzdGVuZXJzLCByZW1vdmUpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMb2NhbEV2ZW50VHJhcE1peGluO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgTW9iaWxlU2FmYXJpQ2xpY2tFdmVudFBsdWdpblxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZShcIi4vRXZlbnRDb25zdGFudHNcIik7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZShcIi4vZW1wdHlGdW5jdGlvblwiKTtcblxudmFyIHRvcExldmVsVHlwZXMgPSBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuXG4vKipcbiAqIE1vYmlsZSBTYWZhcmkgZG9lcyBub3QgZmlyZSBwcm9wZXJseSBidWJibGUgY2xpY2sgZXZlbnRzIG9uIG5vbi1pbnRlcmFjdGl2ZVxuICogZWxlbWVudHMsIHdoaWNoIG1lYW5zIGRlbGVnYXRlZCBjbGljayBsaXN0ZW5lcnMgZG8gbm90IGZpcmUuIFRoZSB3b3JrYXJvdW5kXG4gKiBmb3IgdGhpcyBidWcgaW52b2x2ZXMgYXR0YWNoaW5nIGFuIGVtcHR5IGNsaWNrIGxpc3RlbmVyIG9uIHRoZSB0YXJnZXQgbm9kZS5cbiAqXG4gKiBUaGlzIHBhcnRpY3VsYXIgcGx1Z2luIHdvcmtzIGFyb3VuZCB0aGUgYnVnIGJ5IGF0dGFjaGluZyBhbiBlbXB0eSBjbGlja1xuICogbGlzdGVuZXIgb24gYHRvdWNoc3RhcnRgICh3aGljaCBkb2VzIGZpcmUgb24gZXZlcnkgZWxlbWVudCkuXG4gKi9cbnZhciBNb2JpbGVTYWZhcmlDbGlja0V2ZW50UGx1Z2luID0ge1xuXG4gIGV2ZW50VHlwZXM6IG51bGwsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdG9wTGV2ZWxUYXJnZXQgVGhlIGxpc3RlbmluZyBjb21wb25lbnQgcm9vdCBub2RlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUYXJnZXRJRCBJRCBvZiBgdG9wTGV2ZWxUYXJnZXRgLlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gICAqIEByZXR1cm4geyp9IEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxuICAgKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5leHRyYWN0RXZlbnRzfVxuICAgKi9cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24oXG4gICAgICB0b3BMZXZlbFR5cGUsXG4gICAgICB0b3BMZXZlbFRhcmdldCxcbiAgICAgIHRvcExldmVsVGFyZ2V0SUQsXG4gICAgICBuYXRpdmVFdmVudCkge1xuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wVG91Y2hTdGFydCkge1xuICAgICAgdmFyIHRhcmdldCA9IG5hdGl2ZUV2ZW50LnRhcmdldDtcbiAgICAgIGlmICh0YXJnZXQgJiYgIXRhcmdldC5vbmNsaWNrKSB7XG4gICAgICAgIHRhcmdldC5vbmNsaWNrID0gZW1wdHlGdW5jdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNb2JpbGVTYWZhcmlDbGlja0V2ZW50UGx1Z2luO1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBQb29sZWRDbGFzc1xuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xuXG4vKipcbiAqIFN0YXRpYyBwb29sZXJzLiBTZXZlcmFsIGN1c3RvbSB2ZXJzaW9ucyBmb3IgZWFjaCBwb3RlbnRpYWwgbnVtYmVyIG9mXG4gKiBhcmd1bWVudHMuIEEgY29tcGxldGVseSBnZW5lcmljIHBvb2xlciBpcyBlYXN5IHRvIGltcGxlbWVudCwgYnV0IHdvdWxkXG4gKiByZXF1aXJlIGFjY2Vzc2luZyB0aGUgYGFyZ3VtZW50c2Agb2JqZWN0LiBJbiBlYWNoIG9mIHRoZXNlLCBgdGhpc2AgcmVmZXJzIHRvXG4gKiB0aGUgQ2xhc3MgaXRzZWxmLCBub3QgYW4gaW5zdGFuY2UuIElmIGFueSBvdGhlcnMgYXJlIG5lZWRlZCwgc2ltcGx5IGFkZCB0aGVtXG4gKiBoZXJlLCBvciBpbiB0aGVpciBvd24gZmlsZXMuXG4gKi9cbnZhciBvbmVBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uKGNvcHlGaWVsZHNGcm9tKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGNvcHlGaWVsZHNGcm9tKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhjb3B5RmllbGRzRnJvbSk7XG4gIH1cbn07XG5cbnZhciB0d29Bcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uKGExLCBhMikge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGExLCBhMik7XG4gIH1cbn07XG5cbnZhciB0aHJlZUFyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24oYTEsIGEyLCBhMykge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhhMSwgYTIsIGEzKTtcbiAgfVxufTtcblxudmFyIGZpdmVBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uKGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzLCBhNCwgYTUpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGExLCBhMiwgYTMsIGE0LCBhNSk7XG4gIH1cbn07XG5cbnZhciBzdGFuZGFyZFJlbGVhc2VyID0gZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICBpbnN0YW5jZSBpbnN0YW5jZW9mIEtsYXNzLFxuICAgICdUcnlpbmcgdG8gcmVsZWFzZSBhbiBpbnN0YW5jZSBpbnRvIGEgcG9vbCBvZiBhIGRpZmZlcmVudCB0eXBlLidcbiAgKSA6IGludmFyaWFudChpbnN0YW5jZSBpbnN0YW5jZW9mIEtsYXNzKSk7XG4gIGlmIChpbnN0YW5jZS5kZXN0cnVjdG9yKSB7XG4gICAgaW5zdGFuY2UuZGVzdHJ1Y3RvcigpO1xuICB9XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoIDwgS2xhc3MucG9vbFNpemUpIHtcbiAgICBLbGFzcy5pbnN0YW5jZVBvb2wucHVzaChpbnN0YW5jZSk7XG4gIH1cbn07XG5cbnZhciBERUZBVUxUX1BPT0xfU0laRSA9IDEwO1xudmFyIERFRkFVTFRfUE9PTEVSID0gb25lQXJndW1lbnRQb29sZXI7XG5cbi8qKlxuICogQXVnbWVudHMgYENvcHlDb25zdHJ1Y3RvcmAgdG8gYmUgYSBwb29sYWJsZSBjbGFzcywgYXVnbWVudGluZyBvbmx5IHRoZSBjbGFzc1xuICogaXRzZWxmIChzdGF0aWNhbGx5KSBub3QgYWRkaW5nIGFueSBwcm90b3R5cGljYWwgZmllbGRzLiBBbnkgQ29weUNvbnN0cnVjdG9yXG4gKiB5b3UgZ2l2ZSB0aGlzIG1heSBoYXZlIGEgYHBvb2xTaXplYCBwcm9wZXJ0eSwgYW5kIHdpbGwgbG9vayBmb3IgYVxuICogcHJvdG90eXBpY2FsIGBkZXN0cnVjdG9yYCBvbiBpbnN0YW5jZXMgKG9wdGlvbmFsKS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBDb3B5Q29uc3RydWN0b3IgQ29uc3RydWN0b3IgdGhhdCBjYW4gYmUgdXNlZCB0byByZXNldC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHBvb2xlciBDdXN0b21pemFibGUgcG9vbGVyLlxuICovXG52YXIgYWRkUG9vbGluZ1RvID0gZnVuY3Rpb24oQ29weUNvbnN0cnVjdG9yLCBwb29sZXIpIHtcbiAgdmFyIE5ld0tsYXNzID0gQ29weUNvbnN0cnVjdG9yO1xuICBOZXdLbGFzcy5pbnN0YW5jZVBvb2wgPSBbXTtcbiAgTmV3S2xhc3MuZ2V0UG9vbGVkID0gcG9vbGVyIHx8IERFRkFVTFRfUE9PTEVSO1xuICBpZiAoIU5ld0tsYXNzLnBvb2xTaXplKSB7XG4gICAgTmV3S2xhc3MucG9vbFNpemUgPSBERUZBVUxUX1BPT0xfU0laRTtcbiAgfVxuICBOZXdLbGFzcy5yZWxlYXNlID0gc3RhbmRhcmRSZWxlYXNlcjtcbiAgcmV0dXJuIE5ld0tsYXNzO1xufTtcblxudmFyIFBvb2xlZENsYXNzID0ge1xuICBhZGRQb29saW5nVG86IGFkZFBvb2xpbmdUbyxcbiAgb25lQXJndW1lbnRQb29sZXI6IG9uZUFyZ3VtZW50UG9vbGVyLFxuICB0d29Bcmd1bWVudFBvb2xlcjogdHdvQXJndW1lbnRQb29sZXIsXG4gIHRocmVlQXJndW1lbnRQb29sZXI6IHRocmVlQXJndW1lbnRQb29sZXIsXG4gIGZpdmVBcmd1bWVudFBvb2xlcjogZml2ZUFyZ3VtZW50UG9vbGVyXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvb2xlZENsYXNzO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBET01Qcm9wZXJ0eU9wZXJhdGlvbnMgPSByZXF1aXJlKFwiLi9ET01Qcm9wZXJ0eU9wZXJhdGlvbnNcIik7XG52YXIgRXZlbnRQbHVnaW5VdGlscyA9IHJlcXVpcmUoXCIuL0V2ZW50UGx1Z2luVXRpbHNcIik7XG52YXIgUmVhY3RDaGlsZHJlbiA9IHJlcXVpcmUoXCIuL1JlYWN0Q2hpbGRyZW5cIik7XG52YXIgUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKFwiLi9SZWFjdENvbXBvbmVudFwiKTtcbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCA9IHJlcXVpcmUoXCIuL1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50XCIpO1xudmFyIFJlYWN0Q29udGV4dCA9IHJlcXVpcmUoXCIuL1JlYWN0Q29udGV4dFwiKTtcbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoXCIuL1JlYWN0Q3VycmVudE93bmVyXCIpO1xudmFyIFJlYWN0RGVzY3JpcHRvciA9IHJlcXVpcmUoXCIuL1JlYWN0RGVzY3JpcHRvclwiKTtcbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoXCIuL1JlYWN0RE9NXCIpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50ID0gcmVxdWlyZShcIi4vUmVhY3RET01Db21wb25lbnRcIik7XG52YXIgUmVhY3REZWZhdWx0SW5qZWN0aW9uID0gcmVxdWlyZShcIi4vUmVhY3REZWZhdWx0SW5qZWN0aW9uXCIpO1xudmFyIFJlYWN0SW5zdGFuY2VIYW5kbGVzID0gcmVxdWlyZShcIi4vUmVhY3RJbnN0YW5jZUhhbmRsZXNcIik7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoXCIuL1JlYWN0TW91bnRcIik7XG52YXIgUmVhY3RNdWx0aUNoaWxkID0gcmVxdWlyZShcIi4vUmVhY3RNdWx0aUNoaWxkXCIpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoXCIuL1JlYWN0UGVyZlwiKTtcbnZhciBSZWFjdFByb3BUeXBlcyA9IHJlcXVpcmUoXCIuL1JlYWN0UHJvcFR5cGVzXCIpO1xudmFyIFJlYWN0U2VydmVyUmVuZGVyaW5nID0gcmVxdWlyZShcIi4vUmVhY3RTZXJ2ZXJSZW5kZXJpbmdcIik7XG52YXIgUmVhY3RUZXh0Q29tcG9uZW50ID0gcmVxdWlyZShcIi4vUmVhY3RUZXh0Q29tcG9uZW50XCIpO1xuXG52YXIgb25seUNoaWxkID0gcmVxdWlyZShcIi4vb25seUNoaWxkXCIpO1xuXG5SZWFjdERlZmF1bHRJbmplY3Rpb24uaW5qZWN0KCk7XG5cbnZhciBSZWFjdCA9IHtcbiAgQ2hpbGRyZW46IHtcbiAgICBtYXA6IFJlYWN0Q2hpbGRyZW4ubWFwLFxuICAgIGZvckVhY2g6IFJlYWN0Q2hpbGRyZW4uZm9yRWFjaCxcbiAgICBjb3VudDogUmVhY3RDaGlsZHJlbi5jb3VudCxcbiAgICBvbmx5OiBvbmx5Q2hpbGRcbiAgfSxcbiAgRE9NOiBSZWFjdERPTSxcbiAgUHJvcFR5cGVzOiBSZWFjdFByb3BUeXBlcyxcbiAgaW5pdGlhbGl6ZVRvdWNoRXZlbnRzOiBmdW5jdGlvbihzaG91bGRVc2VUb3VjaCkge1xuICAgIEV2ZW50UGx1Z2luVXRpbHMudXNlVG91Y2hFdmVudHMgPSBzaG91bGRVc2VUb3VjaDtcbiAgfSxcbiAgY3JlYXRlQ2xhc3M6IFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50LmNyZWF0ZUNsYXNzLFxuICBjcmVhdGVEZXNjcmlwdG9yOiBmdW5jdGlvbih0eXBlLCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgcmV0dXJuIHR5cGUuYXBwbHkobnVsbCwgYXJncyk7XG4gIH0sXG4gIGNvbnN0cnVjdEFuZFJlbmRlckNvbXBvbmVudDogUmVhY3RNb3VudC5jb25zdHJ1Y3RBbmRSZW5kZXJDb21wb25lbnQsXG4gIGNvbnN0cnVjdEFuZFJlbmRlckNvbXBvbmVudEJ5SUQ6IFJlYWN0TW91bnQuY29uc3RydWN0QW5kUmVuZGVyQ29tcG9uZW50QnlJRCxcbiAgcmVuZGVyQ29tcG9uZW50OiBSZWFjdFBlcmYubWVhc3VyZShcbiAgICAnUmVhY3QnLFxuICAgICdyZW5kZXJDb21wb25lbnQnLFxuICAgIFJlYWN0TW91bnQucmVuZGVyQ29tcG9uZW50XG4gICksXG4gIHJlbmRlckNvbXBvbmVudFRvU3RyaW5nOiBSZWFjdFNlcnZlclJlbmRlcmluZy5yZW5kZXJDb21wb25lbnRUb1N0cmluZyxcbiAgcmVuZGVyQ29tcG9uZW50VG9TdGF0aWNNYXJrdXA6XG4gICAgUmVhY3RTZXJ2ZXJSZW5kZXJpbmcucmVuZGVyQ29tcG9uZW50VG9TdGF0aWNNYXJrdXAsXG4gIHVubW91bnRDb21wb25lbnRBdE5vZGU6IFJlYWN0TW91bnQudW5tb3VudENvbXBvbmVudEF0Tm9kZSxcbiAgaXNWYWxpZENsYXNzOiBSZWFjdERlc2NyaXB0b3IuaXNWYWxpZEZhY3RvcnksXG4gIGlzVmFsaWRDb21wb25lbnQ6IFJlYWN0RGVzY3JpcHRvci5pc1ZhbGlkRGVzY3JpcHRvcixcbiAgd2l0aENvbnRleHQ6IFJlYWN0Q29udGV4dC53aXRoQ29udGV4dCxcbiAgX19pbnRlcm5hbHM6IHtcbiAgICBDb21wb25lbnQ6IFJlYWN0Q29tcG9uZW50LFxuICAgIEN1cnJlbnRPd25lcjogUmVhY3RDdXJyZW50T3duZXIsXG4gICAgRE9NQ29tcG9uZW50OiBSZWFjdERPTUNvbXBvbmVudCxcbiAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnM6IERPTVByb3BlcnR5T3BlcmF0aW9ucyxcbiAgICBJbnN0YW5jZUhhbmRsZXM6IFJlYWN0SW5zdGFuY2VIYW5kbGVzLFxuICAgIE1vdW50OiBSZWFjdE1vdW50LFxuICAgIE11bHRpQ2hpbGQ6IFJlYWN0TXVsdGlDaGlsZCxcbiAgICBUZXh0Q29tcG9uZW50OiBSZWFjdFRleHRDb21wb25lbnRcbiAgfVxufTtcblxuaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICB2YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKFwiLi9FeGVjdXRpb25FbnZpcm9ubWVudFwiKTtcbiAgaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJlxuICAgICAgd2luZG93LnRvcCA9PT0gd2luZG93LnNlbGYgJiZcbiAgICAgIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQ2hyb21lJykgPiAtMSkge1xuICAgIGNvbnNvbGUuZGVidWcoXG4gICAgICAnRG93bmxvYWQgdGhlIFJlYWN0IERldlRvb2xzIGZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOiAnICtcbiAgICAgICdodHRwOi8vZmIubWUvcmVhY3QtZGV2dG9vbHMnXG4gICAgKTtcblxuICAgIHZhciBleHBlY3RlZEZlYXR1cmVzID0gW1xuICAgICAgLy8gc2hpbXNcbiAgICAgIEFycmF5LmlzQXJyYXksXG4gICAgICBBcnJheS5wcm90b3R5cGUuZXZlcnksXG4gICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCxcbiAgICAgIEFycmF5LnByb3RvdHlwZS5pbmRleE9mLFxuICAgICAgQXJyYXkucHJvdG90eXBlLm1hcCxcbiAgICAgIERhdGUubm93LFxuICAgICAgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQsXG4gICAgICBPYmplY3Qua2V5cyxcbiAgICAgIFN0cmluZy5wcm90b3R5cGUuc3BsaXQsXG4gICAgICBTdHJpbmcucHJvdG90eXBlLnRyaW0sXG5cbiAgICAgIC8vIHNoYW1zXG4gICAgICBPYmplY3QuY3JlYXRlLFxuICAgICAgT2JqZWN0LmZyZWV6ZVxuICAgIF07XG5cbiAgICBmb3IgKHZhciBpIGluIGV4cGVjdGVkRmVhdHVyZXMpIHtcbiAgICAgIGlmICghZXhwZWN0ZWRGZWF0dXJlc1tpXSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICdPbmUgb3IgbW9yZSBFUzUgc2hpbS9zaGFtcyBleHBlY3RlZCBieSBSZWFjdCBhcmUgbm90IGF2YWlsYWJsZTogJyArXG4gICAgICAgICAgJ2h0dHA6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLXBvbHlmaWxscydcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIFZlcnNpb24gZXhpc3RzIG9ubHkgaW4gdGhlIG9wZW4tc291cmNlIHZlcnNpb24gb2YgUmVhY3QsIG5vdCBpbiBGYWNlYm9vaydzXG4vLyBpbnRlcm5hbCB2ZXJzaW9uLlxuUmVhY3QudmVyc2lvbiA9ICcwLjExLjEnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0QnJvd3NlckNvbXBvbmVudE1peGluXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBSZWFjdEVtcHR5Q29tcG9uZW50ID0gcmVxdWlyZShcIi4vUmVhY3RFbXB0eUNvbXBvbmVudFwiKTtcbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZShcIi4vUmVhY3RNb3VudFwiKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcblxudmFyIFJlYWN0QnJvd3NlckNvbXBvbmVudE1peGluID0ge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgRE9NIG5vZGUgcmVuZGVyZWQgYnkgdGhpcyBjb21wb25lbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge0RPTUVsZW1lbnR9IFRoZSByb290IG5vZGUgb2YgdGhpcyBjb21wb25lbnQuXG4gICAqIEBmaW5hbFxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBnZXRET01Ob2RlOiBmdW5jdGlvbigpIHtcbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgdGhpcy5pc01vdW50ZWQoKSxcbiAgICAgICdnZXRET01Ob2RlKCk6IEEgY29tcG9uZW50IG11c3QgYmUgbW91bnRlZCB0byBoYXZlIGEgRE9NIG5vZGUuJ1xuICAgICkgOiBpbnZhcmlhbnQodGhpcy5pc01vdW50ZWQoKSkpO1xuICAgIGlmIChSZWFjdEVtcHR5Q29tcG9uZW50LmlzTnVsbENvbXBvbmVudElEKHRoaXMuX3Jvb3ROb2RlSUQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIFJlYWN0TW91bnQuZ2V0Tm9kZSh0aGlzLl9yb290Tm9kZUlEKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbjtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlclxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZShcIi4vRXZlbnRDb25zdGFudHNcIik7XG52YXIgRXZlbnRQbHVnaW5IdWIgPSByZXF1aXJlKFwiLi9FdmVudFBsdWdpbkh1YlwiKTtcbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0gcmVxdWlyZShcIi4vRXZlbnRQbHVnaW5SZWdpc3RyeVwiKTtcbnZhciBSZWFjdEV2ZW50RW1pdHRlck1peGluID0gcmVxdWlyZShcIi4vUmVhY3RFdmVudEVtaXR0ZXJNaXhpblwiKTtcbnZhciBWaWV3cG9ydE1ldHJpY3MgPSByZXF1aXJlKFwiLi9WaWV3cG9ydE1ldHJpY3NcIik7XG5cbnZhciBpc0V2ZW50U3VwcG9ydGVkID0gcmVxdWlyZShcIi4vaXNFdmVudFN1cHBvcnRlZFwiKTtcbnZhciBtZXJnZSA9IHJlcXVpcmUoXCIuL21lcmdlXCIpO1xuXG4vKipcbiAqIFN1bW1hcnkgb2YgYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgZXZlbnQgaGFuZGxpbmc6XG4gKlxuICogIC0gVG9wLWxldmVsIGRlbGVnYXRpb24gaXMgdXNlZCB0byB0cmFwIG1vc3QgbmF0aXZlIGJyb3dzZXIgZXZlbnRzLiBUaGlzXG4gKiAgICBtYXkgb25seSBvY2N1ciBpbiB0aGUgbWFpbiB0aHJlYWQgYW5kIGlzIHRoZSByZXNwb25zaWJpbGl0eSBvZlxuICogICAgUmVhY3RFdmVudExpc3RlbmVyLCB3aGljaCBpcyBpbmplY3RlZCBhbmQgY2FuIHRoZXJlZm9yZSBzdXBwb3J0IHBsdWdnYWJsZVxuICogICAgZXZlbnQgc291cmNlcy4gVGhpcyBpcyB0aGUgb25seSB3b3JrIHRoYXQgb2NjdXJzIGluIHRoZSBtYWluIHRocmVhZC5cbiAqXG4gKiAgLSBXZSBub3JtYWxpemUgYW5kIGRlLWR1cGxpY2F0ZSBldmVudHMgdG8gYWNjb3VudCBmb3IgYnJvd3NlciBxdWlya3MuIFRoaXNcbiAqICAgIG1heSBiZSBkb25lIGluIHRoZSB3b3JrZXIgdGhyZWFkLlxuICpcbiAqICAtIEZvcndhcmQgdGhlc2UgbmF0aXZlIGV2ZW50cyAod2l0aCB0aGUgYXNzb2NpYXRlZCB0b3AtbGV2ZWwgdHlwZSB1c2VkIHRvXG4gKiAgICB0cmFwIGl0KSB0byBgRXZlbnRQbHVnaW5IdWJgLCB3aGljaCBpbiB0dXJuIHdpbGwgYXNrIHBsdWdpbnMgaWYgdGhleSB3YW50XG4gKiAgICB0byBleHRyYWN0IGFueSBzeW50aGV0aWMgZXZlbnRzLlxuICpcbiAqICAtIFRoZSBgRXZlbnRQbHVnaW5IdWJgIHdpbGwgdGhlbiBwcm9jZXNzIGVhY2ggZXZlbnQgYnkgYW5ub3RhdGluZyB0aGVtIHdpdGhcbiAqICAgIFwiZGlzcGF0Y2hlc1wiLCBhIHNlcXVlbmNlIG9mIGxpc3RlbmVycyBhbmQgSURzIHRoYXQgY2FyZSBhYm91dCB0aGF0IGV2ZW50LlxuICpcbiAqICAtIFRoZSBgRXZlbnRQbHVnaW5IdWJgIHRoZW4gZGlzcGF0Y2hlcyB0aGUgZXZlbnRzLlxuICpcbiAqIE92ZXJ2aWV3IG9mIFJlYWN0IGFuZCB0aGUgZXZlbnQgc3lzdGVtOlxuICpcbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqIHwgICAgRE9NICAgICB8ICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqICAgICAgIHwgICAgICAgICAgIC5cbiAqICAgICAgIHYgICAgICAgICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqIHwgUmVhY3RFdmVudCB8ICAgIC5cbiAqIHwgIExpc3RlbmVyICB8ICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC4gICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgICstLS0tLS0tLSt8U2ltcGxlRXZlbnR8XG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgfCAgICAgICAgIHxQbHVnaW4gICAgIHxcbiAqICstLS0tLXwtLS0tLS0rICAgIC4gICAgICAgICAgICAgICB2ICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogfCAgICAgfCAgICAgIHwgICAgLiAgICArLS0tLS0tLS0tLS0tLS0rICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tK1xuICogfCAgICAgKy0tLS0tLS0tLS0tLi0tLT58RXZlbnRQbHVnaW5IdWJ8ICAgICAgICAgICAgICAgICAgICB8ICAgIEV2ZW50ICAgfFxuICogfCAgICAgICAgICAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0rICB8IFByb3BhZ2F0b3JzfFxuICogfCBSZWFjdEV2ZW50IHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICB8VGFwRXZlbnQgICB8ICB8LS0tLS0tLS0tLS0tfFxuICogfCAgRW1pdHRlciAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8PC0tLSt8UGx1Z2luICAgICB8ICB8b3RoZXIgcGx1Z2lufFxuICogfCAgICAgICAgICAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0rICB8ICB1dGlsaXRpZXMgfFxuICogfCAgICAgKy0tLS0tLS0tLS0tLi0tLT58ICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tK1xuICogfCAgICAgfCAgICAgIHwgICAgLiAgICArLS0tLS0tLS0tLS0tLS0rXG4gKiArLS0tLS18LS0tLS0tKyAgICAuICAgICAgICAgICAgICAgIF4gICAgICAgICstLS0tLS0tLS0tLStcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICAgfCAgICAgICAgfEVudGVyL0xlYXZlfFxuICogICAgICAgKyAgICAgICAgICAgLiAgICAgICAgICAgICAgICArLS0tLS0tLSt8UGx1Z2luICAgICB8XG4gKiArLS0tLS0tLS0tLS0tLSsgICAuICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbiAqIHwgYXBwbGljYXRpb24gfCAgIC5cbiAqIHwtLS0tLS0tLS0tLS0tfCAgIC5cbiAqIHwgICAgICAgICAgICAgfCAgIC5cbiAqIHwgICAgICAgICAgICAgfCAgIC5cbiAqICstLS0tLS0tLS0tLS0tKyAgIC5cbiAqICAgICAgICAgICAgICAgICAgIC5cbiAqICAgIFJlYWN0IENvcmUgICAgIC4gIEdlbmVyYWwgUHVycG9zZSBFdmVudCBQbHVnaW4gU3lzdGVtXG4gKi9cblxudmFyIGFscmVhZHlMaXN0ZW5pbmdUbyA9IHt9O1xudmFyIGlzTW9uaXRvcmluZ1Njcm9sbFZhbHVlID0gZmFsc2U7XG52YXIgcmVhY3RUb3BMaXN0ZW5lcnNDb3VudGVyID0gMDtcblxuLy8gRm9yIGV2ZW50cyBsaWtlICdzdWJtaXQnIHdoaWNoIGRvbid0IGNvbnNpc3RlbnRseSBidWJibGUgKHdoaWNoIHdlIHRyYXAgYXQgYVxuLy8gbG93ZXIgbm9kZSB0aGFuIGBkb2N1bWVudGApLCBiaW5kaW5nIGF0IGBkb2N1bWVudGAgd291bGQgY2F1c2UgZHVwbGljYXRlXG4vLyBldmVudHMgc28gd2UgZG9uJ3QgaW5jbHVkZSB0aGVtIGhlcmVcbnZhciB0b3BFdmVudE1hcHBpbmcgPSB7XG4gIHRvcEJsdXI6ICdibHVyJyxcbiAgdG9wQ2hhbmdlOiAnY2hhbmdlJyxcbiAgdG9wQ2xpY2s6ICdjbGljaycsXG4gIHRvcENvbXBvc2l0aW9uRW5kOiAnY29tcG9zaXRpb25lbmQnLFxuICB0b3BDb21wb3NpdGlvblN0YXJ0OiAnY29tcG9zaXRpb25zdGFydCcsXG4gIHRvcENvbXBvc2l0aW9uVXBkYXRlOiAnY29tcG9zaXRpb251cGRhdGUnLFxuICB0b3BDb250ZXh0TWVudTogJ2NvbnRleHRtZW51JyxcbiAgdG9wQ29weTogJ2NvcHknLFxuICB0b3BDdXQ6ICdjdXQnLFxuICB0b3BEb3VibGVDbGljazogJ2RibGNsaWNrJyxcbiAgdG9wRHJhZzogJ2RyYWcnLFxuICB0b3BEcmFnRW5kOiAnZHJhZ2VuZCcsXG4gIHRvcERyYWdFbnRlcjogJ2RyYWdlbnRlcicsXG4gIHRvcERyYWdFeGl0OiAnZHJhZ2V4aXQnLFxuICB0b3BEcmFnTGVhdmU6ICdkcmFnbGVhdmUnLFxuICB0b3BEcmFnT3ZlcjogJ2RyYWdvdmVyJyxcbiAgdG9wRHJhZ1N0YXJ0OiAnZHJhZ3N0YXJ0JyxcbiAgdG9wRHJvcDogJ2Ryb3AnLFxuICB0b3BGb2N1czogJ2ZvY3VzJyxcbiAgdG9wSW5wdXQ6ICdpbnB1dCcsXG4gIHRvcEtleURvd246ICdrZXlkb3duJyxcbiAgdG9wS2V5UHJlc3M6ICdrZXlwcmVzcycsXG4gIHRvcEtleVVwOiAna2V5dXAnLFxuICB0b3BNb3VzZURvd246ICdtb3VzZWRvd24nLFxuICB0b3BNb3VzZU1vdmU6ICdtb3VzZW1vdmUnLFxuICB0b3BNb3VzZU91dDogJ21vdXNlb3V0JyxcbiAgdG9wTW91c2VPdmVyOiAnbW91c2VvdmVyJyxcbiAgdG9wTW91c2VVcDogJ21vdXNldXAnLFxuICB0b3BQYXN0ZTogJ3Bhc3RlJyxcbiAgdG9wU2Nyb2xsOiAnc2Nyb2xsJyxcbiAgdG9wU2VsZWN0aW9uQ2hhbmdlOiAnc2VsZWN0aW9uY2hhbmdlJyxcbiAgdG9wVGV4dElucHV0OiAndGV4dElucHV0JyxcbiAgdG9wVG91Y2hDYW5jZWw6ICd0b3VjaGNhbmNlbCcsXG4gIHRvcFRvdWNoRW5kOiAndG91Y2hlbmQnLFxuICB0b3BUb3VjaE1vdmU6ICd0b3VjaG1vdmUnLFxuICB0b3BUb3VjaFN0YXJ0OiAndG91Y2hzdGFydCcsXG4gIHRvcFdoZWVsOiAnd2hlZWwnXG59O1xuXG4vKipcbiAqIFRvIGVuc3VyZSBubyBjb25mbGljdHMgd2l0aCBvdGhlciBwb3RlbnRpYWwgUmVhY3QgaW5zdGFuY2VzIG9uIHRoZSBwYWdlXG4gKi9cbnZhciB0b3BMaXN0ZW5lcnNJREtleSA9IFwiX3JlYWN0TGlzdGVuZXJzSURcIiArIFN0cmluZyhNYXRoLnJhbmRvbSgpKS5zbGljZSgyKTtcblxuZnVuY3Rpb24gZ2V0TGlzdGVuaW5nRm9yRG9jdW1lbnQobW91bnRBdCkge1xuICAvLyBJbiBJRTgsIGBtb3VudEF0YCBpcyBhIGhvc3Qgb2JqZWN0IGFuZCBkb2Vzbid0IGhhdmUgYGhhc093blByb3BlcnR5YFxuICAvLyBkaXJlY3RseS5cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW91bnRBdCwgdG9wTGlzdGVuZXJzSURLZXkpKSB7XG4gICAgbW91bnRBdFt0b3BMaXN0ZW5lcnNJREtleV0gPSByZWFjdFRvcExpc3RlbmVyc0NvdW50ZXIrKztcbiAgICBhbHJlYWR5TGlzdGVuaW5nVG9bbW91bnRBdFt0b3BMaXN0ZW5lcnNJREtleV1dID0ge307XG4gIH1cbiAgcmV0dXJuIGFscmVhZHlMaXN0ZW5pbmdUb1ttb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XV07XG59XG5cbi8qKlxuICogYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgaXMgdXNlZCB0byBhdHRhY2ggdG9wLWxldmVsIGV2ZW50IGxpc3RlbmVycy4gRm9yXG4gKiBleGFtcGxlOlxuICpcbiAqICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnB1dExpc3RlbmVyKCdteUlEJywgJ29uQ2xpY2snLCBteUZ1bmN0aW9uKTtcbiAqXG4gKiBUaGlzIHdvdWxkIGFsbG9jYXRlIGEgXCJyZWdpc3RyYXRpb25cIiBvZiBgKCdvbkNsaWNrJywgbXlGdW5jdGlvbilgIG9uICdteUlEJy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciA9IG1lcmdlKFJlYWN0RXZlbnRFbWl0dGVyTWl4aW4sIHtcblxuICAvKipcbiAgICogSW5qZWN0YWJsZSBldmVudCBiYWNrZW5kXG4gICAqL1xuICBSZWFjdEV2ZW50TGlzdGVuZXI6IG51bGwsXG5cbiAgaW5qZWN0aW9uOiB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFJlYWN0RXZlbnRMaXN0ZW5lclxuICAgICAqL1xuICAgIGluamVjdFJlYWN0RXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24oUmVhY3RFdmVudExpc3RlbmVyKSB7XG4gICAgICBSZWFjdEV2ZW50TGlzdGVuZXIuc2V0SGFuZGxlVG9wTGV2ZWwoXG4gICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5oYW5kbGVUb3BMZXZlbFxuICAgICAgKTtcbiAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIgPSBSZWFjdEV2ZW50TGlzdGVuZXI7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIHdoZXRoZXIgb3Igbm90IGFueSBjcmVhdGVkIGNhbGxiYWNrcyBzaG91bGQgYmUgZW5hYmxlZC5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkIFRydWUgaWYgY2FsbGJhY2tzIHNob3VsZCBiZSBlbmFibGVkLlxuICAgKi9cbiAgc2V0RW5hYmxlZDogZnVuY3Rpb24oZW5hYmxlZCkge1xuICAgIGlmIChSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyKSB7XG4gICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnNldEVuYWJsZWQoZW5hYmxlZCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGNhbGxiYWNrcyBhcmUgZW5hYmxlZC5cbiAgICovXG4gIGlzRW5hYmxlZDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICEhKFxuICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lciAmJlxuICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci5pc0VuYWJsZWQoKVxuICAgICk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdlIGxpc3RlbiBmb3IgYnViYmxlZCB0b3VjaCBldmVudHMgb24gdGhlIGRvY3VtZW50IG9iamVjdC5cbiAgICpcbiAgICogRmlyZWZveCB2OC4wMSAoYW5kIHBvc3NpYmx5IG90aGVycykgZXhoaWJpdGVkIHN0cmFuZ2UgYmVoYXZpb3Igd2hlblxuICAgKiBtb3VudGluZyBgb25tb3VzZW1vdmVgIGV2ZW50cyBhdCBzb21lIG5vZGUgdGhhdCB3YXMgbm90IHRoZSBkb2N1bWVudFxuICAgKiBlbGVtZW50LiBUaGUgc3ltcHRvbXMgd2VyZSB0aGF0IGlmIHlvdXIgbW91c2UgaXMgbm90IG1vdmluZyBvdmVyIHNvbWV0aGluZ1xuICAgKiBjb250YWluZWQgd2l0aGluIHRoYXQgbW91bnQgcG9pbnQgKGZvciBleGFtcGxlIG9uIHRoZSBiYWNrZ3JvdW5kKSB0aGVcbiAgICogdG9wLWxldmVsIGxpc3RlbmVycyBmb3IgYG9ubW91c2Vtb3ZlYCB3b24ndCBiZSBjYWxsZWQuIEhvd2V2ZXIsIGlmIHlvdVxuICAgKiByZWdpc3RlciB0aGUgYG1vdXNlbW92ZWAgb24gdGhlIGRvY3VtZW50IG9iamVjdCwgdGhlbiBpdCB3aWxsIG9mIGNvdXJzZVxuICAgKiBjYXRjaCBhbGwgYG1vdXNlbW92ZWBzLiBUaGlzIGFsb25nIHdpdGggaU9TIHF1aXJrcywganVzdGlmaWVzIHJlc3RyaWN0aW5nXG4gICAqIHRvcC1sZXZlbCBsaXN0ZW5lcnMgdG8gdGhlIGRvY3VtZW50IG9iamVjdCBvbmx5LCBhdCBsZWFzdCBmb3IgdGhlc2VcbiAgICogbW92ZW1lbnQgdHlwZXMgb2YgZXZlbnRzIGFuZCBwb3NzaWJseSBhbGwgZXZlbnRzLlxuICAgKlxuICAgKiBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvYmxvZy9hcmNoaXZlcy8yMDEwLzA5L2NsaWNrX2V2ZW50X2RlbC5odG1sXG4gICAqXG4gICAqIEFsc28sIGBrZXl1cGAvYGtleXByZXNzYC9ga2V5ZG93bmAgZG8gbm90IGJ1YmJsZSB0byB0aGUgd2luZG93IG9uIElFLCBidXRcbiAgICogdGhleSBidWJibGUgdG8gZG9jdW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRlbnREb2N1bWVudEhhbmRsZSBEb2N1bWVudCB3aGljaCBvd25zIHRoZSBjb250YWluZXJcbiAgICovXG4gIGxpc3RlblRvOiBmdW5jdGlvbihyZWdpc3RyYXRpb25OYW1lLCBjb250ZW50RG9jdW1lbnRIYW5kbGUpIHtcbiAgICB2YXIgbW91bnRBdCA9IGNvbnRlbnREb2N1bWVudEhhbmRsZTtcbiAgICB2YXIgaXNMaXN0ZW5pbmcgPSBnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudChtb3VudEF0KTtcbiAgICB2YXIgZGVwZW5kZW5jaWVzID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5cbiAgICAgIHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV07XG5cbiAgICB2YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBkZXBlbmRlbmNpZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgZGVwZW5kZW5jeSA9IGRlcGVuZGVuY2llc1tpXTtcbiAgICAgIGlmICghKFxuICAgICAgICAgICAgaXNMaXN0ZW5pbmcuaGFzT3duUHJvcGVydHkoZGVwZW5kZW5jeSkgJiZcbiAgICAgICAgICAgIGlzTGlzdGVuaW5nW2RlcGVuZGVuY3ldXG4gICAgICAgICAgKSkge1xuICAgICAgICBpZiAoZGVwZW5kZW5jeSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BXaGVlbCkge1xuICAgICAgICAgIGlmIChpc0V2ZW50U3VwcG9ydGVkKCd3aGVlbCcpKSB7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQoXG4gICAgICAgICAgICAgIHRvcExldmVsVHlwZXMudG9wV2hlZWwsXG4gICAgICAgICAgICAgICd3aGVlbCcsXG4gICAgICAgICAgICAgIG1vdW50QXRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdtb3VzZXdoZWVsJykpIHtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudChcbiAgICAgICAgICAgICAgdG9wTGV2ZWxUeXBlcy50b3BXaGVlbCxcbiAgICAgICAgICAgICAgJ21vdXNld2hlZWwnLFxuICAgICAgICAgICAgICBtb3VudEF0XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGaXJlZm94IG5lZWRzIHRvIGNhcHR1cmUgYSBkaWZmZXJlbnQgbW91c2Ugc2Nyb2xsIGV2ZW50LlxuICAgICAgICAgICAgLy8gQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2RvbS9ldmVudHMvdGVzdHMvc2Nyb2xsLmh0bWxcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudChcbiAgICAgICAgICAgICAgdG9wTGV2ZWxUeXBlcy50b3BXaGVlbCxcbiAgICAgICAgICAgICAgJ0RPTU1vdXNlU2Nyb2xsJyxcbiAgICAgICAgICAgICAgbW91bnRBdFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZGVwZW5kZW5jeSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BTY3JvbGwpIHtcblxuICAgICAgICAgIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdzY3JvbGwnLCB0cnVlKSkge1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQ2FwdHVyZWRFdmVudChcbiAgICAgICAgICAgICAgdG9wTGV2ZWxUeXBlcy50b3BTY3JvbGwsXG4gICAgICAgICAgICAgICdzY3JvbGwnLFxuICAgICAgICAgICAgICBtb3VudEF0XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQoXG4gICAgICAgICAgICAgIHRvcExldmVsVHlwZXMudG9wU2Nyb2xsLFxuICAgICAgICAgICAgICAnc2Nyb2xsJyxcbiAgICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci5XSU5ET1dfSEFORExFXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChkZXBlbmRlbmN5ID09PSB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzIHx8XG4gICAgICAgICAgICBkZXBlbmRlbmN5ID09PSB0b3BMZXZlbFR5cGVzLnRvcEJsdXIpIHtcblxuICAgICAgICAgIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdmb2N1cycsIHRydWUpKSB7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBDYXB0dXJlZEV2ZW50KFxuICAgICAgICAgICAgICB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzLFxuICAgICAgICAgICAgICAnZm9jdXMnLFxuICAgICAgICAgICAgICBtb3VudEF0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQ2FwdHVyZWRFdmVudChcbiAgICAgICAgICAgICAgdG9wTGV2ZWxUeXBlcy50b3BCbHVyLFxuICAgICAgICAgICAgICAnYmx1cicsXG4gICAgICAgICAgICAgIG1vdW50QXRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdmb2N1c2luJykpIHtcbiAgICAgICAgICAgIC8vIElFIGhhcyBgZm9jdXNpbmAgYW5kIGBmb2N1c291dGAgZXZlbnRzIHdoaWNoIGJ1YmJsZS5cbiAgICAgICAgICAgIC8vIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMDgvMDQvZGVsZWdhdGluZ190aGUuaHRtbFxuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KFxuICAgICAgICAgICAgICB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzLFxuICAgICAgICAgICAgICAnZm9jdXNpbicsXG4gICAgICAgICAgICAgIG1vdW50QXRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQoXG4gICAgICAgICAgICAgIHRvcExldmVsVHlwZXMudG9wQmx1cixcbiAgICAgICAgICAgICAgJ2ZvY3Vzb3V0JyxcbiAgICAgICAgICAgICAgbW91bnRBdFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB0byBtYWtlIHN1cmUgYmx1ciBhbmQgZm9jdXMgZXZlbnQgbGlzdGVuZXJzIGFyZSBvbmx5IGF0dGFjaGVkIG9uY2VcbiAgICAgICAgICBpc0xpc3RlbmluZ1t0b3BMZXZlbFR5cGVzLnRvcEJsdXJdID0gdHJ1ZTtcbiAgICAgICAgICBpc0xpc3RlbmluZ1t0b3BMZXZlbFR5cGVzLnRvcEZvY3VzXSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodG9wRXZlbnRNYXBwaW5nLmhhc093blByb3BlcnR5KGRlcGVuZGVuY3kpKSB7XG4gICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KFxuICAgICAgICAgICAgZGVwZW5kZW5jeSxcbiAgICAgICAgICAgIHRvcEV2ZW50TWFwcGluZ1tkZXBlbmRlbmN5XSxcbiAgICAgICAgICAgIG1vdW50QXRcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaXNMaXN0ZW5pbmdbZGVwZW5kZW5jeV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB0cmFwQnViYmxlZEV2ZW50OiBmdW5jdGlvbih0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKSB7XG4gICAgcmV0dXJuIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudChcbiAgICAgIHRvcExldmVsVHlwZSxcbiAgICAgIGhhbmRsZXJCYXNlTmFtZSxcbiAgICAgIGhhbmRsZVxuICAgICk7XG4gIH0sXG5cbiAgdHJhcENhcHR1cmVkRXZlbnQ6IGZ1bmN0aW9uKHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpIHtcbiAgICByZXR1cm4gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQ2FwdHVyZWRFdmVudChcbiAgICAgIHRvcExldmVsVHlwZSxcbiAgICAgIGhhbmRsZXJCYXNlTmFtZSxcbiAgICAgIGhhbmRsZVxuICAgICk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIExpc3RlbnMgdG8gd2luZG93IHNjcm9sbCBhbmQgcmVzaXplIGV2ZW50cy4gV2UgY2FjaGUgc2Nyb2xsIHZhbHVlcyBzbyB0aGF0XG4gICAqIGFwcGxpY2F0aW9uIGNvZGUgY2FuIGFjY2VzcyB0aGVtIHdpdGhvdXQgdHJpZ2dlcmluZyByZWZsb3dzLlxuICAgKlxuICAgKiBOT1RFOiBTY3JvbGwgZXZlbnRzIGRvIG5vdCBidWJibGUuXG4gICAqXG4gICAqIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9kb20vZXZlbnRzL3Njcm9sbC5odG1sXG4gICAqL1xuICBlbnN1cmVTY3JvbGxWYWx1ZU1vbml0b3Jpbmc6IGZ1bmN0aW9uKCl7XG4gICAgaWYgKCFpc01vbml0b3JpbmdTY3JvbGxWYWx1ZSkge1xuICAgICAgdmFyIHJlZnJlc2ggPSBWaWV3cG9ydE1ldHJpY3MucmVmcmVzaFNjcm9sbFZhbHVlcztcbiAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIubW9uaXRvclNjcm9sbFZhbHVlKHJlZnJlc2gpO1xuICAgICAgaXNNb25pdG9yaW5nU2Nyb2xsVmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfSxcblxuICBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3M6IEV2ZW50UGx1Z2luSHViLmV2ZW50TmFtZURpc3BhdGNoQ29uZmlncyxcblxuICByZWdpc3RyYXRpb25OYW1lTW9kdWxlczogRXZlbnRQbHVnaW5IdWIucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMsXG5cbiAgcHV0TGlzdGVuZXI6IEV2ZW50UGx1Z2luSHViLnB1dExpc3RlbmVyLFxuXG4gIGdldExpc3RlbmVyOiBFdmVudFBsdWdpbkh1Yi5nZXRMaXN0ZW5lcixcblxuICBkZWxldGVMaXN0ZW5lcjogRXZlbnRQbHVnaW5IdWIuZGVsZXRlTGlzdGVuZXIsXG5cbiAgZGVsZXRlQWxsTGlzdGVuZXJzOiBFdmVudFBsdWdpbkh1Yi5kZWxldGVBbGxMaXN0ZW5lcnNcblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENTU1RyYW5zaXRpb25Hcm91cFxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKFwiLi9SZWFjdFwiKTtcblxudmFyIFJlYWN0VHJhbnNpdGlvbkdyb3VwID0gcmVxdWlyZShcIi4vUmVhY3RUcmFuc2l0aW9uR3JvdXBcIik7XG52YXIgUmVhY3RDU1NUcmFuc2l0aW9uR3JvdXBDaGlsZCA9IHJlcXVpcmUoXCIuL1JlYWN0Q1NTVHJhbnNpdGlvbkdyb3VwQ2hpbGRcIik7XG5cbnZhciBSZWFjdENTU1RyYW5zaXRpb25Hcm91cCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdSZWFjdENTU1RyYW5zaXRpb25Hcm91cCcsXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgdHJhbnNpdGlvbk5hbWU6IFJlYWN0LlByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgICB0cmFuc2l0aW9uRW50ZXI6IFJlYWN0LlByb3BUeXBlcy5ib29sLFxuICAgIHRyYW5zaXRpb25MZWF2ZTogUmVhY3QuUHJvcFR5cGVzLmJvb2xcbiAgfSxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0cmFuc2l0aW9uRW50ZXI6IHRydWUsXG4gICAgICB0cmFuc2l0aW9uTGVhdmU6IHRydWVcbiAgICB9O1xuICB9LFxuXG4gIF93cmFwQ2hpbGQ6IGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgLy8gV2UgbmVlZCB0byBwcm92aWRlIHRoaXMgY2hpbGRGYWN0b3J5IHNvIHRoYXRcbiAgICAvLyBSZWFjdENTU1RyYW5zaXRpb25Hcm91cENoaWxkIGNhbiByZWNlaXZlIHVwZGF0ZXMgdG8gbmFtZSwgZW50ZXIsIGFuZFxuICAgIC8vIGxlYXZlIHdoaWxlIGl0IGlzIGxlYXZpbmcuXG4gICAgcmV0dXJuIFJlYWN0Q1NTVHJhbnNpdGlvbkdyb3VwQ2hpbGQoXG4gICAgICB7XG4gICAgICAgIG5hbWU6IHRoaXMucHJvcHMudHJhbnNpdGlvbk5hbWUsXG4gICAgICAgIGVudGVyOiB0aGlzLnByb3BzLnRyYW5zaXRpb25FbnRlcixcbiAgICAgICAgbGVhdmU6IHRoaXMucHJvcHMudHJhbnNpdGlvbkxlYXZlXG4gICAgICB9LFxuICAgICAgY2hpbGRcbiAgICApO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmZXJQcm9wc1RvKFxuICAgICAgUmVhY3RUcmFuc2l0aW9uR3JvdXAoXG4gICAgICAgIHtjaGlsZEZhY3Rvcnk6IHRoaXMuX3dyYXBDaGlsZH0sXG4gICAgICAgIHRoaXMucHJvcHMuY2hpbGRyZW5cbiAgICAgIClcbiAgICApO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENTU1RyYW5zaXRpb25Hcm91cDtcbiIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q1NTVHJhbnNpdGlvbkdyb3VwQ2hpbGRcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIFJlYWN0ID0gcmVxdWlyZShcIi4vUmVhY3RcIik7XG5cbnZhciBDU1NDb3JlID0gcmVxdWlyZShcIi4vQ1NTQ29yZVwiKTtcbnZhciBSZWFjdFRyYW5zaXRpb25FdmVudHMgPSByZXF1aXJlKFwiLi9SZWFjdFRyYW5zaXRpb25FdmVudHNcIik7XG5cbnZhciBvbmx5Q2hpbGQgPSByZXF1aXJlKFwiLi9vbmx5Q2hpbGRcIik7XG5cbi8vIFdlIGRvbid0IHJlbW92ZSB0aGUgZWxlbWVudCBmcm9tIHRoZSBET00gdW50aWwgd2UgcmVjZWl2ZSBhbiBhbmltYXRpb25lbmQgb3Jcbi8vIHRyYW5zaXRpb25lbmQgZXZlbnQuIElmIHRoZSB1c2VyIHNjcmV3cyB1cCBhbmQgZm9yZ2V0cyB0byBhZGQgYW4gYW5pbWF0aW9uXG4vLyB0aGVpciBub2RlIHdpbGwgYmUgc3R1Y2sgaW4gdGhlIERPTSBmb3JldmVyLCBzbyB3ZSBkZXRlY3QgaWYgYW4gYW5pbWF0aW9uXG4vLyBkb2VzIG5vdCBzdGFydCBhbmQgaWYgaXQgZG9lc24ndCwgd2UganVzdCBjYWxsIHRoZSBlbmQgbGlzdGVuZXIgaW1tZWRpYXRlbHkuXG52YXIgVElDSyA9IDE3O1xudmFyIE5PX0VWRU5UX1RJTUVPVVQgPSA1MDAwO1xuXG52YXIgbm9FdmVudExpc3RlbmVyID0gbnVsbDtcblxuXG5pZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gIG5vRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKCkge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgICd0cmFuc2l0aW9uKCk6IHRyaWVkIHRvIHBlcmZvcm0gYW4gYW5pbWF0aW9uIHdpdGhvdXQgJyArXG4gICAgICAnYW4gYW5pbWF0aW9uZW5kIG9yIHRyYW5zaXRpb25lbmQgZXZlbnQgYWZ0ZXIgdGltZW91dCAoJyArXG4gICAgICBOT19FVkVOVF9USU1FT1VUICsgJ21zKS4gWW91IHNob3VsZCBlaXRoZXIgZGlzYWJsZSB0aGlzICcgK1xuICAgICAgJ3RyYW5zaXRpb24gaW4gSlMgb3IgYWRkIGEgQ1NTIGFuaW1hdGlvbi90cmFuc2l0aW9uLidcbiAgICApO1xuICB9O1xufVxuXG52YXIgUmVhY3RDU1NUcmFuc2l0aW9uR3JvdXBDaGlsZCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdSZWFjdENTU1RyYW5zaXRpb25Hcm91cENoaWxkJyxcblxuICB0cmFuc2l0aW9uOiBmdW5jdGlvbihhbmltYXRpb25UeXBlLCBmaW5pc2hDYWxsYmFjaykge1xuICAgIHZhciBub2RlID0gdGhpcy5nZXRET01Ob2RlKCk7XG4gICAgdmFyIGNsYXNzTmFtZSA9IHRoaXMucHJvcHMubmFtZSArICctJyArIGFuaW1hdGlvblR5cGU7XG4gICAgdmFyIGFjdGl2ZUNsYXNzTmFtZSA9IGNsYXNzTmFtZSArICctYWN0aXZlJztcbiAgICB2YXIgbm9FdmVudFRpbWVvdXQgPSBudWxsO1xuXG4gICAgdmFyIGVuZExpc3RlbmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChub0V2ZW50VGltZW91dCk7XG4gICAgICB9XG5cbiAgICAgIENTU0NvcmUucmVtb3ZlQ2xhc3Mobm9kZSwgY2xhc3NOYW1lKTtcbiAgICAgIENTU0NvcmUucmVtb3ZlQ2xhc3Mobm9kZSwgYWN0aXZlQ2xhc3NOYW1lKTtcblxuICAgICAgUmVhY3RUcmFuc2l0aW9uRXZlbnRzLnJlbW92ZUVuZEV2ZW50TGlzdGVuZXIobm9kZSwgZW5kTGlzdGVuZXIpO1xuXG4gICAgICAvLyBVc3VhbGx5IHRoaXMgb3B0aW9uYWwgY2FsbGJhY2sgaXMgdXNlZCBmb3IgaW5mb3JtaW5nIGFuIG93bmVyIG9mXG4gICAgICAvLyBhIGxlYXZlIGFuaW1hdGlvbiBhbmQgdGVsbGluZyBpdCB0byByZW1vdmUgdGhlIGNoaWxkLlxuICAgICAgZmluaXNoQ2FsbGJhY2sgJiYgZmluaXNoQ2FsbGJhY2soKTtcbiAgICB9O1xuXG4gICAgUmVhY3RUcmFuc2l0aW9uRXZlbnRzLmFkZEVuZEV2ZW50TGlzdGVuZXIobm9kZSwgZW5kTGlzdGVuZXIpO1xuXG4gICAgQ1NTQ29yZS5hZGRDbGFzcyhub2RlLCBjbGFzc05hbWUpO1xuXG4gICAgLy8gTmVlZCB0byBkbyB0aGlzIHRvIGFjdHVhbGx5IHRyaWdnZXIgYSB0cmFuc2l0aW9uLlxuICAgIHRoaXMucXVldWVDbGFzcyhhY3RpdmVDbGFzc05hbWUpO1xuXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgbm9FdmVudFRpbWVvdXQgPSBzZXRUaW1lb3V0KG5vRXZlbnRMaXN0ZW5lciwgTk9fRVZFTlRfVElNRU9VVCk7XG4gICAgfVxuICB9LFxuXG4gIHF1ZXVlQ2xhc3M6IGZ1bmN0aW9uKGNsYXNzTmFtZSkge1xuICAgIHRoaXMuY2xhc3NOYW1lUXVldWUucHVzaChjbGFzc05hbWUpO1xuXG4gICAgaWYgKCF0aGlzLnRpbWVvdXQpIHtcbiAgICAgIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5mbHVzaENsYXNzTmFtZVF1ZXVlLCBUSUNLKTtcbiAgICB9XG4gIH0sXG5cbiAgZmx1c2hDbGFzc05hbWVRdWV1ZTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuaXNNb3VudGVkKCkpIHtcbiAgICAgIHRoaXMuY2xhc3NOYW1lUXVldWUuZm9yRWFjaChcbiAgICAgICAgQ1NTQ29yZS5hZGRDbGFzcy5iaW5kKENTU0NvcmUsIHRoaXMuZ2V0RE9NTm9kZSgpKVxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5jbGFzc05hbWVRdWV1ZS5sZW5ndGggPSAwO1xuICAgIHRoaXMudGltZW91dCA9IG51bGw7XG4gIH0sXG5cbiAgY29tcG9uZW50V2lsbE1vdW50OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNsYXNzTmFtZVF1ZXVlID0gW107XG4gIH0sXG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xuICAgIH1cbiAgfSxcblxuICBjb21wb25lbnRXaWxsRW50ZXI6IGZ1bmN0aW9uKGRvbmUpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5lbnRlcikge1xuICAgICAgdGhpcy50cmFuc2l0aW9uKCdlbnRlcicsIGRvbmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb25lKCk7XG4gICAgfVxuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxMZWF2ZTogZnVuY3Rpb24oZG9uZSkge1xuICAgIGlmICh0aGlzLnByb3BzLmxlYXZlKSB7XG4gICAgICB0aGlzLnRyYW5zaXRpb24oJ2xlYXZlJywgZG9uZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvbmUoKTtcbiAgICB9XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gb25seUNoaWxkKHRoaXMucHJvcHMuY2hpbGRyZW4pO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENTU1RyYW5zaXRpb25Hcm91cENoaWxkO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q2hpbGRyZW5cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZShcIi4vUG9vbGVkQ2xhc3NcIik7XG5cbnZhciB0cmF2ZXJzZUFsbENoaWxkcmVuID0gcmVxdWlyZShcIi4vdHJhdmVyc2VBbGxDaGlsZHJlblwiKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZShcIi4vd2FybmluZ1wiKTtcblxudmFyIHR3b0FyZ3VtZW50UG9vbGVyID0gUG9vbGVkQ2xhc3MudHdvQXJndW1lbnRQb29sZXI7XG52YXIgdGhyZWVBcmd1bWVudFBvb2xlciA9IFBvb2xlZENsYXNzLnRocmVlQXJndW1lbnRQb29sZXI7XG5cbi8qKlxuICogUG9vbGVkQ2xhc3MgcmVwcmVzZW50aW5nIHRoZSBib29ra2VlcGluZyBhc3NvY2lhdGVkIHdpdGggcGVyZm9ybWluZyBhIGNoaWxkXG4gKiB0cmF2ZXJzYWwuIEFsbG93cyBhdm9pZGluZyBiaW5kaW5nIGNhbGxiYWNrcy5cbiAqXG4gKiBAY29uc3RydWN0b3IgRm9yRWFjaEJvb2tLZWVwaW5nXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gZm9yRWFjaEZ1bmN0aW9uIEZ1bmN0aW9uIHRvIHBlcmZvcm0gdHJhdmVyc2FsIHdpdGguXG4gKiBAcGFyYW0gez8qfSBmb3JFYWNoQ29udGV4dCBDb250ZXh0IHRvIHBlcmZvcm0gY29udGV4dCB3aXRoLlxuICovXG5mdW5jdGlvbiBGb3JFYWNoQm9va0tlZXBpbmcoZm9yRWFjaEZ1bmN0aW9uLCBmb3JFYWNoQ29udGV4dCkge1xuICB0aGlzLmZvckVhY2hGdW5jdGlvbiA9IGZvckVhY2hGdW5jdGlvbjtcbiAgdGhpcy5mb3JFYWNoQ29udGV4dCA9IGZvckVhY2hDb250ZXh0O1xufVxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKEZvckVhY2hCb29rS2VlcGluZywgdHdvQXJndW1lbnRQb29sZXIpO1xuXG5mdW5jdGlvbiBmb3JFYWNoU2luZ2xlQ2hpbGQodHJhdmVyc2VDb250ZXh0LCBjaGlsZCwgbmFtZSwgaSkge1xuICB2YXIgZm9yRWFjaEJvb2tLZWVwaW5nID0gdHJhdmVyc2VDb250ZXh0O1xuICBmb3JFYWNoQm9va0tlZXBpbmcuZm9yRWFjaEZ1bmN0aW9uLmNhbGwoXG4gICAgZm9yRWFjaEJvb2tLZWVwaW5nLmZvckVhY2hDb250ZXh0LCBjaGlsZCwgaSk7XG59XG5cbi8qKlxuICogSXRlcmF0ZXMgdGhyb3VnaCBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogVGhlIHByb3ZpZGVkIGZvckVhY2hGdW5jKGNoaWxkLCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZvckVhY2hGdW5jLlxuICogQHBhcmFtIHsqfSBmb3JFYWNoQ29udGV4dCBDb250ZXh0IGZvciBmb3JFYWNoQ29udGV4dC5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cblxuICB2YXIgdHJhdmVyc2VDb250ZXh0ID1cbiAgICBGb3JFYWNoQm9va0tlZXBpbmcuZ2V0UG9vbGVkKGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCk7XG4gIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hTaW5nbGVDaGlsZCwgdHJhdmVyc2VDb250ZXh0KTtcbiAgRm9yRWFjaEJvb2tLZWVwaW5nLnJlbGVhc2UodHJhdmVyc2VDb250ZXh0KTtcbn1cblxuLyoqXG4gKiBQb29sZWRDbGFzcyByZXByZXNlbnRpbmcgdGhlIGJvb2trZWVwaW5nIGFzc29jaWF0ZWQgd2l0aCBwZXJmb3JtaW5nIGEgY2hpbGRcbiAqIG1hcHBpbmcuIEFsbG93cyBhdm9pZGluZyBiaW5kaW5nIGNhbGxiYWNrcy5cbiAqXG4gKiBAY29uc3RydWN0b3IgTWFwQm9va0tlZXBpbmdcbiAqIEBwYXJhbSB7ISp9IG1hcFJlc3VsdCBPYmplY3QgY29udGFpbmluZyB0aGUgb3JkZXJlZCBtYXAgb2YgcmVzdWx0cy5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBtYXBGdW5jdGlvbiBGdW5jdGlvbiB0byBwZXJmb3JtIG1hcHBpbmcgd2l0aC5cbiAqIEBwYXJhbSB7Pyp9IG1hcENvbnRleHQgQ29udGV4dCB0byBwZXJmb3JtIG1hcHBpbmcgd2l0aC5cbiAqL1xuZnVuY3Rpb24gTWFwQm9va0tlZXBpbmcobWFwUmVzdWx0LCBtYXBGdW5jdGlvbiwgbWFwQ29udGV4dCkge1xuICB0aGlzLm1hcFJlc3VsdCA9IG1hcFJlc3VsdDtcbiAgdGhpcy5tYXBGdW5jdGlvbiA9IG1hcEZ1bmN0aW9uO1xuICB0aGlzLm1hcENvbnRleHQgPSBtYXBDb250ZXh0O1xufVxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKE1hcEJvb2tLZWVwaW5nLCB0aHJlZUFyZ3VtZW50UG9vbGVyKTtcblxuZnVuY3Rpb24gbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkLCBuYW1lLCBpKSB7XG4gIHZhciBtYXBCb29rS2VlcGluZyA9IHRyYXZlcnNlQ29udGV4dDtcbiAgdmFyIG1hcFJlc3VsdCA9IG1hcEJvb2tLZWVwaW5nLm1hcFJlc3VsdDtcblxuICB2YXIga2V5VW5pcXVlID0gIW1hcFJlc3VsdC5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbiAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcoXG4gICAga2V5VW5pcXVlLFxuICAgICdSZWFjdENoaWxkcmVuLm1hcCguLi4pOiBFbmNvdW50ZXJlZCB0d28gY2hpbGRyZW4gd2l0aCB0aGUgc2FtZSBrZXksICcgK1xuICAgICdgJXNgLiBDaGlsZCBrZXlzIG11c3QgYmUgdW5pcXVlOyB3aGVuIHR3byBjaGlsZHJlbiBzaGFyZSBhIGtleSwgb25seSAnICtcbiAgICAndGhlIGZpcnN0IGNoaWxkIHdpbGwgYmUgdXNlZC4nLFxuICAgIG5hbWVcbiAgKSA6IG51bGwpO1xuXG4gIGlmIChrZXlVbmlxdWUpIHtcbiAgICB2YXIgbWFwcGVkQ2hpbGQgPVxuICAgICAgbWFwQm9va0tlZXBpbmcubWFwRnVuY3Rpb24uY2FsbChtYXBCb29rS2VlcGluZy5tYXBDb250ZXh0LCBjaGlsZCwgaSk7XG4gICAgbWFwUmVzdWx0W25hbWVdID0gbWFwcGVkQ2hpbGQ7XG4gIH1cbn1cblxuLyoqXG4gKiBNYXBzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBUaGUgcHJvdmlkZWQgbWFwRnVuY3Rpb24oY2hpbGQsIGtleSwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIFRPRE86IFRoaXMgbWF5IGxpa2VseSBicmVhayBhbnkgY2FsbHMgdG8gYFJlYWN0Q2hpbGRyZW4ubWFwYCB0aGF0IHdlcmVcbiAqIHByZXZpb3VzbHkgcmVseWluZyBvbiB0aGUgZmFjdCB0aGF0IHdlIGd1YXJkZWQgYWdhaW5zdCBudWxsIGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBtYXBGdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gbWFwQ29udGV4dCBDb250ZXh0IGZvciBtYXBGdW5jdGlvbi5cbiAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9yZGVyZWQgbWFwIG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jLCBjb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG5cbiAgdmFyIG1hcFJlc3VsdCA9IHt9O1xuICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gTWFwQm9va0tlZXBpbmcuZ2V0UG9vbGVkKG1hcFJlc3VsdCwgZnVuYywgY29udGV4dCk7XG4gIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIG1hcFNpbmdsZUNoaWxkSW50b0NvbnRleHQsIHRyYXZlcnNlQ29udGV4dCk7XG4gIE1hcEJvb2tLZWVwaW5nLnJlbGVhc2UodHJhdmVyc2VDb250ZXh0KTtcbiAgcmV0dXJuIG1hcFJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaFNpbmdsZUNoaWxkRHVtbXkodHJhdmVyc2VDb250ZXh0LCBjaGlsZCwgbmFtZSwgaSkge1xuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBDb3VudCB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXNcbiAqIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4uXG4gKi9cbmZ1bmN0aW9uIGNvdW50Q2hpbGRyZW4oY2hpbGRyZW4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hTaW5nbGVDaGlsZER1bW15LCBudWxsKTtcbn1cblxudmFyIFJlYWN0Q2hpbGRyZW4gPSB7XG4gIGZvckVhY2g6IGZvckVhY2hDaGlsZHJlbixcbiAgbWFwOiBtYXBDaGlsZHJlbixcbiAgY291bnQ6IGNvdW50Q2hpbGRyZW5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDaGlsZHJlbjtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENvbXBvbmVudFxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgUmVhY3REZXNjcmlwdG9yID0gcmVxdWlyZShcIi4vUmVhY3REZXNjcmlwdG9yXCIpO1xudmFyIFJlYWN0T3duZXIgPSByZXF1aXJlKFwiLi9SZWFjdE93bmVyXCIpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoXCIuL1JlYWN0VXBkYXRlc1wiKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcbnZhciBrZXlNaXJyb3IgPSByZXF1aXJlKFwiLi9rZXlNaXJyb3JcIik7XG52YXIgbWVyZ2UgPSByZXF1aXJlKFwiLi9tZXJnZVwiKTtcblxuLyoqXG4gKiBFdmVyeSBSZWFjdCBjb21wb25lbnQgaXMgaW4gb25lIG9mIHRoZXNlIGxpZmUgY3ljbGVzLlxuICovXG52YXIgQ29tcG9uZW50TGlmZUN5Y2xlID0ga2V5TWlycm9yKHtcbiAgLyoqXG4gICAqIE1vdW50ZWQgY29tcG9uZW50cyBoYXZlIGEgRE9NIG5vZGUgcmVwcmVzZW50YXRpb24gYW5kIGFyZSBjYXBhYmxlIG9mXG4gICAqIHJlY2VpdmluZyBuZXcgcHJvcHMuXG4gICAqL1xuICBNT1VOVEVEOiBudWxsLFxuICAvKipcbiAgICogVW5tb3VudGVkIGNvbXBvbmVudHMgYXJlIGluYWN0aXZlIGFuZCBjYW5ub3QgcmVjZWl2ZSBuZXcgcHJvcHMuXG4gICAqL1xuICBVTk1PVU5URUQ6IG51bGxcbn0pO1xuXG52YXIgaW5qZWN0ZWQgPSBmYWxzZTtcblxuLyoqXG4gKiBPcHRpb25hbGx5IGluamVjdGFibGUgZW52aXJvbm1lbnQgZGVwZW5kZW50IGNsZWFudXAgaG9vay4gKHNlcnZlciB2cy5cbiAqIGJyb3dzZXIgZXRjKS4gRXhhbXBsZTogQSBicm93c2VyIHN5c3RlbSBjYWNoZXMgRE9NIG5vZGVzIGJhc2VkIG9uIGNvbXBvbmVudFxuICogSUQgYW5kIG11c3QgcmVtb3ZlIHRoYXQgY2FjaGUgZW50cnkgd2hlbiB0aGlzIGluc3RhbmNlIGlzIHVubW91bnRlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgdW5tb3VudElERnJvbUVudmlyb25tZW50ID0gbnVsbDtcblxuLyoqXG4gKiBUaGUgXCJpbWFnZVwiIG9mIGEgY29tcG9uZW50IHRyZWUsIGlzIHRoZSBwbGF0Zm9ybSBzcGVjaWZpYyAodHlwaWNhbGx5XG4gKiBzZXJpYWxpemVkKSBkYXRhIHRoYXQgcmVwcmVzZW50cyBhIHRyZWUgb2YgbG93ZXIgbGV2ZWwgVUkgYnVpbGRpbmcgYmxvY2tzLlxuICogT24gdGhlIHdlYiwgdGhpcyBcImltYWdlXCIgaXMgSFRNTCBtYXJrdXAgd2hpY2ggZGVzY3JpYmVzIGEgY29uc3RydWN0aW9uIG9mXG4gKiBsb3cgbGV2ZWwgYGRpdmAgYW5kIGBzcGFuYCBub2Rlcy4gT3RoZXIgcGxhdGZvcm1zIG1heSBoYXZlIGRpZmZlcmVudFxuICogZW5jb2Rpbmcgb2YgdGhpcyBcImltYWdlXCIuIFRoaXMgbXVzdCBiZSBpbmplY3RlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgbW91bnRJbWFnZUludG9Ob2RlID0gbnVsbDtcblxuLyoqXG4gKiBDb21wb25lbnRzIGFyZSB0aGUgYmFzaWMgdW5pdHMgb2YgY29tcG9zaXRpb24gaW4gUmVhY3QuXG4gKlxuICogRXZlcnkgY29tcG9uZW50IGFjY2VwdHMgYSBzZXQgb2Yga2V5ZWQgaW5wdXQgcGFyYW1ldGVycyBrbm93biBhcyBcInByb3BzXCIgdGhhdFxuICogYXJlIGluaXRpYWxpemVkIGJ5IHRoZSBjb25zdHJ1Y3Rvci4gT25jZSBhIGNvbXBvbmVudCBpcyBtb3VudGVkLCB0aGUgcHJvcHNcbiAqIGNhbiBiZSBtdXRhdGVkIHVzaW5nIGBzZXRQcm9wc2Agb3IgYHJlcGxhY2VQcm9wc2AuXG4gKlxuICogRXZlcnkgY29tcG9uZW50IGlzIGNhcGFibGUgb2YgdGhlIGZvbGxvd2luZyBvcGVyYXRpb25zOlxuICpcbiAqICAgYG1vdW50Q29tcG9uZW50YFxuICogICAgIEluaXRpYWxpemVzIHRoZSBjb21wb25lbnQsIHJlbmRlcnMgbWFya3VwLCBhbmQgcmVnaXN0ZXJzIGV2ZW50IGxpc3RlbmVycy5cbiAqXG4gKiAgIGByZWNlaXZlQ29tcG9uZW50YFxuICogICAgIFVwZGF0ZXMgdGhlIHJlbmRlcmVkIERPTSBub2RlcyB0byBtYXRjaCB0aGUgZ2l2ZW4gY29tcG9uZW50LlxuICpcbiAqICAgYHVubW91bnRDb21wb25lbnRgXG4gKiAgICAgUmVsZWFzZXMgYW55IHJlc291cmNlcyBhbGxvY2F0ZWQgYnkgdGhpcyBjb21wb25lbnQuXG4gKlxuICogQ29tcG9uZW50cyBjYW4gYWxzbyBiZSBcIm93bmVkXCIgYnkgb3RoZXIgY29tcG9uZW50cy4gQmVpbmcgb3duZWQgYnkgYW5vdGhlclxuICogY29tcG9uZW50IG1lYW5zIGJlaW5nIGNvbnN0cnVjdGVkIGJ5IHRoYXQgY29tcG9uZW50LiBUaGlzIGlzIGRpZmZlcmVudCBmcm9tXG4gKiBiZWluZyB0aGUgY2hpbGQgb2YgYSBjb21wb25lbnQsIHdoaWNoIG1lYW5zIGhhdmluZyBhIERPTSByZXByZXNlbnRhdGlvbiB0aGF0XG4gKiBpcyBhIGNoaWxkIG9mIHRoZSBET00gcmVwcmVzZW50YXRpb24gb2YgdGhhdCBjb21wb25lbnQuXG4gKlxuICogQGNsYXNzIFJlYWN0Q29tcG9uZW50XG4gKi9cbnZhciBSZWFjdENvbXBvbmVudCA9IHtcblxuICBpbmplY3Rpb246IHtcbiAgICBpbmplY3RFbnZpcm9ubWVudDogZnVuY3Rpb24oUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCkge1xuICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICAgIWluamVjdGVkLFxuICAgICAgICAnUmVhY3RDb21wb25lbnQ6IGluamVjdEVudmlyb25tZW50KCkgY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2UuJ1xuICAgICAgKSA6IGludmFyaWFudCghaW5qZWN0ZWQpKTtcbiAgICAgIG1vdW50SW1hZ2VJbnRvTm9kZSA9IFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQubW91bnRJbWFnZUludG9Ob2RlO1xuICAgICAgdW5tb3VudElERnJvbUVudmlyb25tZW50ID1cbiAgICAgICAgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC51bm1vdW50SURGcm9tRW52aXJvbm1lbnQ7XG4gICAgICBSZWFjdENvbXBvbmVudC5CYWNrZW5kSURPcGVyYXRpb25zID1cbiAgICAgICAgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5CYWNrZW5kSURPcGVyYXRpb25zO1xuICAgICAgaW5qZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBMaWZlQ3ljbGU6IENvbXBvbmVudExpZmVDeWNsZSxcblxuICAvKipcbiAgICogSW5qZWN0ZWQgbW9kdWxlIHRoYXQgcHJvdmlkZXMgYWJpbGl0eSB0byBtdXRhdGUgaW5kaXZpZHVhbCBwcm9wZXJ0aWVzLlxuICAgKiBJbmplY3RlZCBpbnRvIHRoZSBiYXNlIGNsYXNzIGJlY2F1c2UgbWFueSBkaWZmZXJlbnQgc3ViY2xhc3NlcyBuZWVkIGFjY2Vzc1xuICAgKiB0byB0aGlzLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIEJhY2tlbmRJRE9wZXJhdGlvbnM6IG51bGwsXG5cbiAgLyoqXG4gICAqIEJhc2UgZnVuY3Rpb25hbGl0eSBmb3IgZXZlcnkgUmVhY3RDb21wb25lbnQgY29uc3RydWN0b3IuIE1peGVkIGludG8gdGhlXG4gICAqIGBSZWFjdENvbXBvbmVudGAgcHJvdG90eXBlLCBidXQgZXhwb3NlZCBzdGF0aWNhbGx5IGZvciBlYXN5IGFjY2Vzcy5cbiAgICpcbiAgICogQGxlbmRzIHtSZWFjdENvbXBvbmVudC5wcm90b3R5cGV9XG4gICAqL1xuICBNaXhpbjoge1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKiBAZmluYWxcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgaXNNb3VudGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9saWZlQ3ljbGVTdGF0ZSA9PT0gQ29tcG9uZW50TGlmZUN5Y2xlLk1PVU5URUQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHByb3BzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxQcm9wcyBTdWJzZXQgb2YgdGhlIG5leHQgcHJvcHMuXG4gICAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBwcm9wcyBhcmUgdXBkYXRlZC5cbiAgICAgKiBAZmluYWxcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgc2V0UHJvcHM6IGZ1bmN0aW9uKHBhcnRpYWxQcm9wcywgY2FsbGJhY2spIHtcbiAgICAgIC8vIE1lcmdlIHdpdGggdGhlIHBlbmRpbmcgZGVzY3JpcHRvciBpZiBpdCBleGlzdHMsIG90aGVyd2lzZSB3aXRoIGV4aXN0aW5nXG4gICAgICAvLyBkZXNjcmlwdG9yIHByb3BzLlxuICAgICAgdmFyIGRlc2NyaXB0b3IgPSB0aGlzLl9wZW5kaW5nRGVzY3JpcHRvciB8fCB0aGlzLl9kZXNjcmlwdG9yO1xuICAgICAgdGhpcy5yZXBsYWNlUHJvcHMoXG4gICAgICAgIG1lcmdlKGRlc2NyaXB0b3IucHJvcHMsIHBhcnRpYWxQcm9wcyksXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHByb3BzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHByb3BzIE5ldyBwcm9wcy5cbiAgICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHByb3BzIGFyZSB1cGRhdGVkLlxuICAgICAqIEBmaW5hbFxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICByZXBsYWNlUHJvcHM6IGZ1bmN0aW9uKHByb3BzLCBjYWxsYmFjaykge1xuICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICAgdGhpcy5pc01vdW50ZWQoKSxcbiAgICAgICAgJ3JlcGxhY2VQcm9wcyguLi4pOiBDYW4gb25seSB1cGRhdGUgYSBtb3VudGVkIGNvbXBvbmVudC4nXG4gICAgICApIDogaW52YXJpYW50KHRoaXMuaXNNb3VudGVkKCkpKTtcbiAgICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAgIHRoaXMuX21vdW50RGVwdGggPT09IDAsXG4gICAgICAgICdyZXBsYWNlUHJvcHMoLi4uKTogWW91IGNhbGxlZCBgc2V0UHJvcHNgIG9yIGByZXBsYWNlUHJvcHNgIG9uIGEgJyArXG4gICAgICAgICdjb21wb25lbnQgd2l0aCBhIHBhcmVudC4gVGhpcyBpcyBhbiBhbnRpLXBhdHRlcm4gc2luY2UgcHJvcHMgd2lsbCAnICtcbiAgICAgICAgJ2dldCByZWFjdGl2ZWx5IHVwZGF0ZWQgd2hlbiByZW5kZXJlZC4gSW5zdGVhZCwgY2hhbmdlIHRoZSBvd25lclxcJ3MgJyArXG4gICAgICAgICdgcmVuZGVyYCBtZXRob2QgdG8gcGFzcyB0aGUgY29ycmVjdCB2YWx1ZSBhcyBwcm9wcyB0byB0aGUgY29tcG9uZW50ICcgK1xuICAgICAgICAnd2hlcmUgaXQgaXMgY3JlYXRlZC4nXG4gICAgICApIDogaW52YXJpYW50KHRoaXMuX21vdW50RGVwdGggPT09IDApKTtcbiAgICAgIC8vIFRoaXMgaXMgYSBkZW9wdGltaXplZCBwYXRoLiBXZSBvcHRpbWl6ZSBmb3IgYWx3YXlzIGhhdmluZyBhIGRlc2NyaXB0b3IuXG4gICAgICAvLyBUaGlzIGNyZWF0ZXMgYW4gZXh0cmEgaW50ZXJuYWwgZGVzY3JpcHRvci5cbiAgICAgIHRoaXMuX3BlbmRpbmdEZXNjcmlwdG9yID0gUmVhY3REZXNjcmlwdG9yLmNsb25lQW5kUmVwbGFjZVByb3BzKFxuICAgICAgICB0aGlzLl9wZW5kaW5nRGVzY3JpcHRvciB8fCB0aGlzLl9kZXNjcmlwdG9yLFxuICAgICAgICBwcm9wc1xuICAgICAgKTtcbiAgICAgIFJlYWN0VXBkYXRlcy5lbnF1ZXVlVXBkYXRlKHRoaXMsIGNhbGxiYWNrKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2NoZWR1bGUgYSBwYXJ0aWFsIHVwZGF0ZSB0byB0aGUgcHJvcHMuIE9ubHkgdXNlZCBmb3IgaW50ZXJuYWwgdGVzdGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsUHJvcHMgU3Vic2V0IG9mIHRoZSBuZXh0IHByb3BzLlxuICAgICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgcHJvcHMgYXJlIHVwZGF0ZWQuXG4gICAgICogQGZpbmFsXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX3NldFByb3BzSW50ZXJuYWw6IGZ1bmN0aW9uKHBhcnRpYWxQcm9wcywgY2FsbGJhY2spIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBkZW9wdGltaXplZCBwYXRoLiBXZSBvcHRpbWl6ZSBmb3IgYWx3YXlzIGhhdmluZyBhIGRlc2NyaXB0b3IuXG4gICAgICAvLyBUaGlzIGNyZWF0ZXMgYW4gZXh0cmEgaW50ZXJuYWwgZGVzY3JpcHRvci5cbiAgICAgIHZhciBkZXNjcmlwdG9yID0gdGhpcy5fcGVuZGluZ0Rlc2NyaXB0b3IgfHwgdGhpcy5fZGVzY3JpcHRvcjtcbiAgICAgIHRoaXMuX3BlbmRpbmdEZXNjcmlwdG9yID0gUmVhY3REZXNjcmlwdG9yLmNsb25lQW5kUmVwbGFjZVByb3BzKFxuICAgICAgICBkZXNjcmlwdG9yLFxuICAgICAgICBtZXJnZShkZXNjcmlwdG9yLnByb3BzLCBwYXJ0aWFsUHJvcHMpXG4gICAgICApO1xuICAgICAgUmVhY3RVcGRhdGVzLmVucXVldWVVcGRhdGUodGhpcywgY2FsbGJhY2spO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBCYXNlIGNvbnN0cnVjdG9yIGZvciBhbGwgUmVhY3QgY29tcG9uZW50cy5cbiAgICAgKlxuICAgICAqIFN1YmNsYXNzZXMgdGhhdCBvdmVycmlkZSB0aGlzIG1ldGhvZCBzaG91bGQgbWFrZSBzdXJlIHRvIGludm9rZVxuICAgICAqIGBSZWFjdENvbXBvbmVudC5NaXhpbi5jb25zdHJ1Y3QuY2FsbCh0aGlzLCAuLi4pYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3REZXNjcmlwdG9yfSBkZXNjcmlwdG9yXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgY29uc3RydWN0OiBmdW5jdGlvbihkZXNjcmlwdG9yKSB7XG4gICAgICAvLyBUaGlzIGlzIHRoZSBwdWJsaWMgZXhwb3NlZCBwcm9wcyBvYmplY3QgYWZ0ZXIgaXQgaGFzIGJlZW4gcHJvY2Vzc2VkXG4gICAgICAvLyB3aXRoIGRlZmF1bHQgcHJvcHMuIFRoZSBkZXNjcmlwdG9yJ3MgcHJvcHMgcmVwcmVzZW50cyB0aGUgdHJ1ZSBpbnRlcm5hbFxuICAgICAgLy8gc3RhdGUgb2YgdGhlIHByb3BzLlxuICAgICAgdGhpcy5wcm9wcyA9IGRlc2NyaXB0b3IucHJvcHM7XG4gICAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBjb21wb25lbnQuXG4gICAgICAvLyBUaGlzIGlzIGFjY2Vzc2libGUgdGhyb3VnaCB0aGUgZGVzY3JpcHRvciBidXQgd2UgbWFpbnRhaW4gYW4gZXh0cmFcbiAgICAgIC8vIGZpZWxkIGZvciBjb21wYXRpYmlsaXR5IHdpdGggZGV2dG9vbHMgYW5kIGFzIGEgd2F5IHRvIG1ha2UgYW5cbiAgICAgIC8vIGluY3JlbWVudGFsIHVwZGF0ZS4gVE9ETzogQ29uc2lkZXIgZGVwcmVjYXRpbmcgdGhpcyBmaWVsZC5cbiAgICAgIHRoaXMuX293bmVyID0gZGVzY3JpcHRvci5fb3duZXI7XG5cbiAgICAgIC8vIEFsbCBjb21wb25lbnRzIHN0YXJ0IHVubW91bnRlZC5cbiAgICAgIHRoaXMuX2xpZmVDeWNsZVN0YXRlID0gQ29tcG9uZW50TGlmZUN5Y2xlLlVOTU9VTlRFRDtcblxuICAgICAgLy8gU2VlIFJlYWN0VXBkYXRlcy5cbiAgICAgIHRoaXMuX3BlbmRpbmdDYWxsYmFja3MgPSBudWxsO1xuXG4gICAgICAvLyBXZSBrZWVwIHRoZSBvbGQgZGVzY3JpcHRvciBhbmQgYSByZWZlcmVuY2UgdG8gdGhlIHBlbmRpbmcgZGVzY3JpcHRvclxuICAgICAgLy8gdG8gdHJhY2sgdXBkYXRlcy5cbiAgICAgIHRoaXMuX2Rlc2NyaXB0b3IgPSBkZXNjcmlwdG9yO1xuICAgICAgdGhpcy5fcGVuZGluZ0Rlc2NyaXB0b3IgPSBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgY29tcG9uZW50LCByZW5kZXJzIG1hcmt1cCwgYW5kIHJlZ2lzdGVycyBldmVudCBsaXN0ZW5lcnMuXG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGlzIGRvZXMgbm90IGluc2VydCBhbnkgbm9kZXMgaW50byB0aGUgRE9NLlxuICAgICAqXG4gICAgICogU3ViY2xhc3NlcyB0aGF0IG92ZXJyaWRlIHRoaXMgbWV0aG9kIHNob3VsZCBtYWtlIHN1cmUgdG8gaW52b2tlXG4gICAgICogYFJlYWN0Q29tcG9uZW50Lk1peGluLm1vdW50Q29tcG9uZW50LmNhbGwodGhpcywgLi4uKWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcm9vdElEIERPTSBJRCBvZiB0aGUgcm9vdCBub2RlLlxuICAgICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtb3VudERlcHRoIG51bWJlciBvZiBjb21wb25lbnRzIGluIHRoZSBvd25lciBoaWVyYXJjaHkuXG4gICAgICogQHJldHVybiB7P3N0cmluZ30gUmVuZGVyZWQgbWFya3VwIHRvIGJlIGluc2VydGVkIGludG8gdGhlIERPTS5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24ocm9vdElELCB0cmFuc2FjdGlvbiwgbW91bnREZXB0aCkge1xuICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICAgIXRoaXMuaXNNb3VudGVkKCksXG4gICAgICAgICdtb3VudENvbXBvbmVudCglcywgLi4uKTogQ2FuIG9ubHkgbW91bnQgYW4gdW5tb3VudGVkIGNvbXBvbmVudC4gJyArXG4gICAgICAgICdNYWtlIHN1cmUgdG8gYXZvaWQgc3RvcmluZyBjb21wb25lbnRzIGJldHdlZW4gcmVuZGVycyBvciByZXVzaW5nIGEgJyArXG4gICAgICAgICdzaW5nbGUgY29tcG9uZW50IGluc3RhbmNlIGluIG11bHRpcGxlIHBsYWNlcy4nLFxuICAgICAgICByb290SURcbiAgICAgICkgOiBpbnZhcmlhbnQoIXRoaXMuaXNNb3VudGVkKCkpKTtcbiAgICAgIHZhciBwcm9wcyA9IHRoaXMuX2Rlc2NyaXB0b3IucHJvcHM7XG4gICAgICBpZiAocHJvcHMucmVmICE9IG51bGwpIHtcbiAgICAgICAgdmFyIG93bmVyID0gdGhpcy5fZGVzY3JpcHRvci5fb3duZXI7XG4gICAgICAgIFJlYWN0T3duZXIuYWRkQ29tcG9uZW50QXNSZWZUbyh0aGlzLCBwcm9wcy5yZWYsIG93bmVyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3Jvb3ROb2RlSUQgPSByb290SUQ7XG4gICAgICB0aGlzLl9saWZlQ3ljbGVTdGF0ZSA9IENvbXBvbmVudExpZmVDeWNsZS5NT1VOVEVEO1xuICAgICAgdGhpcy5fbW91bnREZXB0aCA9IG1vdW50RGVwdGg7XG4gICAgICAvLyBFZmZlY3RpdmVseTogcmV0dXJuICcnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWxlYXNlcyBhbnkgcmVzb3VyY2VzIGFsbG9jYXRlZCBieSBgbW91bnRDb21wb25lbnRgLlxuICAgICAqXG4gICAgICogTk9URTogVGhpcyBkb2VzIG5vdCByZW1vdmUgYW55IG5vZGVzIGZyb20gdGhlIERPTS5cbiAgICAgKlxuICAgICAqIFN1YmNsYXNzZXMgdGhhdCBvdmVycmlkZSB0aGlzIG1ldGhvZCBzaG91bGQgbWFrZSBzdXJlIHRvIGludm9rZVxuICAgICAqIGBSZWFjdENvbXBvbmVudC5NaXhpbi51bm1vdW50Q29tcG9uZW50LmNhbGwodGhpcylgLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24oKSB7XG4gICAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgICB0aGlzLmlzTW91bnRlZCgpLFxuICAgICAgICAndW5tb3VudENvbXBvbmVudCgpOiBDYW4gb25seSB1bm1vdW50IGEgbW91bnRlZCBjb21wb25lbnQuJ1xuICAgICAgKSA6IGludmFyaWFudCh0aGlzLmlzTW91bnRlZCgpKSk7XG4gICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgaWYgKHByb3BzLnJlZiAhPSBudWxsKSB7XG4gICAgICAgIFJlYWN0T3duZXIucmVtb3ZlQ29tcG9uZW50QXNSZWZGcm9tKHRoaXMsIHByb3BzLnJlZiwgdGhpcy5fb3duZXIpO1xuICAgICAgfVxuICAgICAgdW5tb3VudElERnJvbUVudmlyb25tZW50KHRoaXMuX3Jvb3ROb2RlSUQpO1xuICAgICAgdGhpcy5fcm9vdE5vZGVJRCA9IG51bGw7XG4gICAgICB0aGlzLl9saWZlQ3ljbGVTdGF0ZSA9IENvbXBvbmVudExpZmVDeWNsZS5VTk1PVU5URUQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgbmV3IGluc3RhbmNlIG9mIHRoaXMgY29tcG9uZW50LCB1cGRhdGVzIHRoZSByZW5kZXJlZCBET00gbm9kZXNcbiAgICAgKiBhcyBpZiB0aGF0IGluc3RhbmNlIHdhcyByZW5kZXJlZCBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogU3ViY2xhc3NlcyB0aGF0IG92ZXJyaWRlIHRoaXMgbWV0aG9kIHNob3VsZCBtYWtlIHN1cmUgdG8gaW52b2tlXG4gICAgICogYFJlYWN0Q29tcG9uZW50Lk1peGluLnJlY2VpdmVDb21wb25lbnQuY2FsbCh0aGlzLCAuLi4pYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0Q29tcG9uZW50IE5leHQgc2V0IG9mIHByb3BlcnRpZXMuXG4gICAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHJlY2VpdmVDb21wb25lbnQ6IGZ1bmN0aW9uKG5leHREZXNjcmlwdG9yLCB0cmFuc2FjdGlvbikge1xuICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICAgdGhpcy5pc01vdW50ZWQoKSxcbiAgICAgICAgJ3JlY2VpdmVDb21wb25lbnQoLi4uKTogQ2FuIG9ubHkgdXBkYXRlIGEgbW91bnRlZCBjb21wb25lbnQuJ1xuICAgICAgKSA6IGludmFyaWFudCh0aGlzLmlzTW91bnRlZCgpKSk7XG4gICAgICB0aGlzLl9wZW5kaW5nRGVzY3JpcHRvciA9IG5leHREZXNjcmlwdG9yO1xuICAgICAgdGhpcy5wZXJmb3JtVXBkYXRlSWZOZWNlc3NhcnkodHJhbnNhY3Rpb24pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJZiBgX3BlbmRpbmdEZXNjcmlwdG9yYCBpcyBzZXQsIHVwZGF0ZSB0aGUgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeTogZnVuY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICAgIGlmICh0aGlzLl9wZW5kaW5nRGVzY3JpcHRvciA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBwcmV2RGVzY3JpcHRvciA9IHRoaXMuX2Rlc2NyaXB0b3I7XG4gICAgICB2YXIgbmV4dERlc2NyaXB0b3IgPSB0aGlzLl9wZW5kaW5nRGVzY3JpcHRvcjtcbiAgICAgIHRoaXMuX2Rlc2NyaXB0b3IgPSBuZXh0RGVzY3JpcHRvcjtcbiAgICAgIHRoaXMucHJvcHMgPSBuZXh0RGVzY3JpcHRvci5wcm9wcztcbiAgICAgIHRoaXMuX293bmVyID0gbmV4dERlc2NyaXB0b3IuX293bmVyO1xuICAgICAgdGhpcy5fcGVuZGluZ0Rlc2NyaXB0b3IgPSBudWxsO1xuICAgICAgdGhpcy51cGRhdGVDb21wb25lbnQodHJhbnNhY3Rpb24sIHByZXZEZXNjcmlwdG9yKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgY29tcG9uZW50J3MgY3VycmVudGx5IG1vdW50ZWQgcmVwcmVzZW50YXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHByZXZEZXNjcmlwdG9yXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbih0cmFuc2FjdGlvbiwgcHJldkRlc2NyaXB0b3IpIHtcbiAgICAgIHZhciBuZXh0RGVzY3JpcHRvciA9IHRoaXMuX2Rlc2NyaXB0b3I7XG5cbiAgICAgIC8vIElmIGVpdGhlciB0aGUgb3duZXIgb3IgYSBgcmVmYCBoYXMgY2hhbmdlZCwgbWFrZSBzdXJlIHRoZSBuZXdlc3Qgb3duZXJcbiAgICAgIC8vIGhhcyBzdG9yZWQgYSByZWZlcmVuY2UgdG8gYHRoaXNgLCBhbmQgdGhlIHByZXZpb3VzIG93bmVyIChpZiBkaWZmZXJlbnQpXG4gICAgICAvLyBoYXMgZm9yZ290dGVuIHRoZSByZWZlcmVuY2UgdG8gYHRoaXNgLiBXZSB1c2UgdGhlIGRlc2NyaXB0b3IgaW5zdGVhZFxuICAgICAgLy8gb2YgdGhlIHB1YmxpYyB0aGlzLnByb3BzIGJlY2F1c2UgdGhlIHBvc3QgcHJvY2Vzc2luZyBjYW5ub3QgZGV0ZXJtaW5lXG4gICAgICAvLyBhIHJlZi4gVGhlIHJlZiBjb25jZXB0dWFsbHkgbGl2ZXMgb24gdGhlIGRlc2NyaXB0b3IuXG5cbiAgICAgIC8vIFRPRE86IFNob3VsZCB0aGlzIGV2ZW4gYmUgcG9zc2libGU/IFRoZSBvd25lciBjYW5ub3QgY2hhbmdlIGJlY2F1c2VcbiAgICAgIC8vIGl0J3MgZm9yYmlkZGVuIGJ5IHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50LiBUaGUgcmVmIGNhbiBjaGFuZ2VcbiAgICAgIC8vIGlmIHlvdSBzd2FwIHRoZSBrZXlzIG9mIGJ1dCBub3QgdGhlIHJlZnMuIFJlY29uc2lkZXIgd2hlcmUgdGhpcyBjaGVja1xuICAgICAgLy8gaXMgbWFkZS4gSXQgcHJvYmFibHkgYmVsb25ncyB3aGVyZSB0aGUga2V5IGNoZWNraW5nIGFuZFxuICAgICAgLy8gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCBpcyBkb25lLlxuXG4gICAgICBpZiAobmV4dERlc2NyaXB0b3IuX293bmVyICE9PSBwcmV2RGVzY3JpcHRvci5fb3duZXIgfHxcbiAgICAgICAgICBuZXh0RGVzY3JpcHRvci5wcm9wcy5yZWYgIT09IHByZXZEZXNjcmlwdG9yLnByb3BzLnJlZikge1xuICAgICAgICBpZiAocHJldkRlc2NyaXB0b3IucHJvcHMucmVmICE9IG51bGwpIHtcbiAgICAgICAgICBSZWFjdE93bmVyLnJlbW92ZUNvbXBvbmVudEFzUmVmRnJvbShcbiAgICAgICAgICAgIHRoaXMsIHByZXZEZXNjcmlwdG9yLnByb3BzLnJlZiwgcHJldkRlc2NyaXB0b3IuX293bmVyXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb3JyZWN0LCBldmVuIGlmIHRoZSBvd25lciBpcyB0aGUgc2FtZSwgYW5kIG9ubHkgdGhlIHJlZiBoYXMgY2hhbmdlZC5cbiAgICAgICAgaWYgKG5leHREZXNjcmlwdG9yLnByb3BzLnJlZiAhPSBudWxsKSB7XG4gICAgICAgICAgUmVhY3RPd25lci5hZGRDb21wb25lbnRBc1JlZlRvKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIG5leHREZXNjcmlwdG9yLnByb3BzLnJlZixcbiAgICAgICAgICAgIG5leHREZXNjcmlwdG9yLl9vd25lclxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTW91bnRzIHRoaXMgY29tcG9uZW50IGFuZCBpbnNlcnRzIGl0IGludG8gdGhlIERPTS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByb290SUQgRE9NIElEIG9mIHRoZSByb290IG5vZGUuXG4gICAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdG8gbW91bnQgaW50by5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZFJldXNlTWFya3VwIElmIHRydWUsIGRvIG5vdCBpbnNlcnQgbWFya3VwXG4gICAgICogQGZpbmFsXG4gICAgICogQGludGVybmFsXG4gICAgICogQHNlZSB7UmVhY3RNb3VudC5yZW5kZXJDb21wb25lbnR9XG4gICAgICovXG4gICAgbW91bnRDb21wb25lbnRJbnRvTm9kZTogZnVuY3Rpb24ocm9vdElELCBjb250YWluZXIsIHNob3VsZFJldXNlTWFya3VwKSB7XG4gICAgICB2YXIgdHJhbnNhY3Rpb24gPSBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5nZXRQb29sZWQoKTtcbiAgICAgIHRyYW5zYWN0aW9uLnBlcmZvcm0oXG4gICAgICAgIHRoaXMuX21vdW50Q29tcG9uZW50SW50b05vZGUsXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHJvb3RJRCxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgc2hvdWxkUmV1c2VNYXJrdXBcbiAgICAgICk7XG4gICAgICBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5yZWxlYXNlKHRyYW5zYWN0aW9uKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJvb3RJRCBET00gSUQgb2YgdGhlIHJvb3Qgbm9kZS5cbiAgICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byBtb3VudCBpbnRvLlxuICAgICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZFJldXNlTWFya3VwIElmIHRydWUsIGRvIG5vdCBpbnNlcnQgbWFya3VwXG4gICAgICogQGZpbmFsXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbW91bnRDb21wb25lbnRJbnRvTm9kZTogZnVuY3Rpb24oXG4gICAgICAgIHJvb3RJRCxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgc2hvdWxkUmV1c2VNYXJrdXApIHtcbiAgICAgIHZhciBtYXJrdXAgPSB0aGlzLm1vdW50Q29tcG9uZW50KHJvb3RJRCwgdHJhbnNhY3Rpb24sIDApO1xuICAgICAgbW91bnRJbWFnZUludG9Ob2RlKG1hcmt1cCwgY29udGFpbmVyLCBzaG91bGRSZXVzZU1hcmt1cCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGlzIGNvbXBvbmVudCBpcyBvd25lZCBieSB0aGUgc3VwcGxpZWQgYG93bmVyYCBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBvd25lciBDb21wb25lbnQgdG8gY2hlY2suXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb3duZXJzYCBvd25zIHRoaXMgY29tcG9uZW50LlxuICAgICAqIEBmaW5hbFxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGlzT3duZWRCeTogZnVuY3Rpb24ob3duZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLl9vd25lciA9PT0gb3duZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgYW5vdGhlciBjb21wb25lbnQsIHRoYXQgc2hhcmVzIHRoZSBzYW1lIG93bmVyIGFzIHRoaXMgb25lLCBieSByZWYuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmIG9mIGEgc2libGluZyBDb21wb25lbnQuXG4gICAgICogQHJldHVybiB7P1JlYWN0Q29tcG9uZW50fSB0aGUgYWN0dWFsIHNpYmxpbmcgQ29tcG9uZW50LlxuICAgICAqIEBmaW5hbFxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGdldFNpYmxpbmdCeVJlZjogZnVuY3Rpb24ocmVmKSB7XG4gICAgICB2YXIgb3duZXIgPSB0aGlzLl9vd25lcjtcbiAgICAgIGlmICghb3duZXIgfHwgIW93bmVyLnJlZnMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3duZXIucmVmc1tyZWZdO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbXBvbmVudDtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudFxuICovXG5cbi8qanNsaW50IGV2aWw6IHRydWUgKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBSZWFjdERPTUlET3BlcmF0aW9ucyA9IHJlcXVpcmUoXCIuL1JlYWN0RE9NSURPcGVyYXRpb25zXCIpO1xudmFyIFJlYWN0TWFya3VwQ2hlY2tzdW0gPSByZXF1aXJlKFwiLi9SZWFjdE1hcmt1cENoZWNrc3VtXCIpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKFwiLi9SZWFjdE1vdW50XCIpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoXCIuL1JlYWN0UGVyZlwiKTtcbnZhciBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uID0gcmVxdWlyZShcIi4vUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvblwiKTtcblxudmFyIGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lciA9IHJlcXVpcmUoXCIuL2dldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lclwiKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG52YXIgc2V0SW5uZXJIVE1MID0gcmVxdWlyZShcIi4vc2V0SW5uZXJIVE1MXCIpO1xuXG5cbnZhciBFTEVNRU5UX05PREVfVFlQRSA9IDE7XG52YXIgRE9DX05PREVfVFlQRSA9IDk7XG5cblxuLyoqXG4gKiBBYnN0cmFjdHMgYXdheSBhbGwgZnVuY3Rpb25hbGl0eSBvZiBgUmVhY3RDb21wb25lbnRgIHJlcXVpcmVzIGtub3dsZWRnZSBvZlxuICogdGhlIGJyb3dzZXIgY29udGV4dC5cbiAqL1xudmFyIFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50ID0ge1xuICBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uOiBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLFxuXG4gIEJhY2tlbmRJRE9wZXJhdGlvbnM6IFJlYWN0RE9NSURPcGVyYXRpb25zLFxuXG4gIC8qKlxuICAgKiBJZiBhIHBhcnRpY3VsYXIgZW52aXJvbm1lbnQgcmVxdWlyZXMgdGhhdCBzb21lIHJlc291cmNlcyBiZSBjbGVhbmVkIHVwLFxuICAgKiBzcGVjaWZ5IHRoaXMgaW4gdGhlIGluamVjdGVkIE1peGluLiBJbiB0aGUgRE9NLCB3ZSB3b3VsZCBsaWtlbHkgd2FudCB0b1xuICAgKiBwdXJnZSBhbnkgY2FjaGVkIG5vZGUgSUQgbG9va3Vwcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHVubW91bnRJREZyb21FbnZpcm9ubWVudDogZnVuY3Rpb24ocm9vdE5vZGVJRCkge1xuICAgIFJlYWN0TW91bnQucHVyZ2VJRChyb290Tm9kZUlEKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBNYXJrdXAgc3RyaW5nIHRvIHBsYWNlIGludG8gdGhlIERPTSBFbGVtZW50LlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gRWxlbWVudCB0byBpbnNlcnQgbWFya3VwIGludG8uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkUmV1c2VNYXJrdXAgU2hvdWxkIHJldXNlIHRoZSBleGlzdGluZyBtYXJrdXAgaW4gdGhlXG4gICAqIGNvbnRhaW5lciBpZiBwb3NzaWJsZS5cbiAgICovXG4gIG1vdW50SW1hZ2VJbnRvTm9kZTogUmVhY3RQZXJmLm1lYXN1cmUoXG4gICAgJ1JlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50JyxcbiAgICAnbW91bnRJbWFnZUludG9Ob2RlJyxcbiAgICBmdW5jdGlvbihtYXJrdXAsIGNvbnRhaW5lciwgc2hvdWxkUmV1c2VNYXJrdXApIHtcbiAgICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAgIGNvbnRhaW5lciAmJiAoXG4gICAgICAgICAgY29udGFpbmVyLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREVfVFlQRSB8fFxuICAgICAgICAgICAgY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NfTk9ERV9UWVBFXG4gICAgICAgICksXG4gICAgICAgICdtb3VudENvbXBvbmVudEludG9Ob2RlKC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IHZhbGlkLidcbiAgICAgICkgOiBpbnZhcmlhbnQoY29udGFpbmVyICYmIChcbiAgICAgICAgY29udGFpbmVyLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREVfVFlQRSB8fFxuICAgICAgICAgIGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRVxuICAgICAgKSkpO1xuXG4gICAgICBpZiAoc2hvdWxkUmV1c2VNYXJrdXApIHtcbiAgICAgICAgaWYgKFJlYWN0TWFya3VwQ2hlY2tzdW0uY2FuUmV1c2VNYXJrdXAoXG4gICAgICAgICAgbWFya3VwLFxuICAgICAgICAgIGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgICAgICAgY29udGFpbmVyLm5vZGVUeXBlICE9PSBET0NfTk9ERV9UWVBFLFxuICAgICAgICAgICAgJ1lvdVxcJ3JlIHRyeWluZyB0byByZW5kZXIgYSBjb21wb25lbnQgdG8gdGhlIGRvY3VtZW50IHVzaW5nICcgK1xuICAgICAgICAgICAgJ3NlcnZlciByZW5kZXJpbmcgYnV0IHRoZSBjaGVja3N1bSB3YXMgaW52YWxpZC4gVGhpcyB1c3VhbGx5ICcgK1xuICAgICAgICAgICAgJ21lYW5zIHlvdSByZW5kZXJlZCBhIGRpZmZlcmVudCBjb21wb25lbnQgdHlwZSBvciBwcm9wcyBvbiAnICtcbiAgICAgICAgICAgICd0aGUgY2xpZW50IGZyb20gdGhlIG9uZSBvbiB0aGUgc2VydmVyLCBvciB5b3VyIHJlbmRlcigpICcgK1xuICAgICAgICAgICAgJ21ldGhvZHMgYXJlIGltcHVyZS4gUmVhY3QgY2Fubm90IGhhbmRsZSB0aGlzIGNhc2UgZHVlIHRvICcgK1xuICAgICAgICAgICAgJ2Nyb3NzLWJyb3dzZXIgcXVpcmtzIGJ5IHJlbmRlcmluZyBhdCB0aGUgZG9jdW1lbnQgcm9vdC4gWW91ICcgK1xuICAgICAgICAgICAgJ3Nob3VsZCBsb29rIGZvciBlbnZpcm9ubWVudCBkZXBlbmRlbnQgY29kZSBpbiB5b3VyIGNvbXBvbmVudHMgJyArXG4gICAgICAgICAgICAnYW5kIGVuc3VyZSB0aGUgcHJvcHMgYXJlIHRoZSBzYW1lIGNsaWVudCBhbmQgc2VydmVyIHNpZGUuJ1xuICAgICAgICAgICkgOiBpbnZhcmlhbnQoY29udGFpbmVyLm5vZGVUeXBlICE9PSBET0NfTk9ERV9UWVBFKSk7XG5cbiAgICAgICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICdSZWFjdCBhdHRlbXB0ZWQgdG8gdXNlIHJldXNlIG1hcmt1cCBpbiBhIGNvbnRhaW5lciBidXQgdGhlICcgK1xuICAgICAgICAgICAgICAnY2hlY2tzdW0gd2FzIGludmFsaWQuIFRoaXMgZ2VuZXJhbGx5IG1lYW5zIHRoYXQgeW91IGFyZSAnICtcbiAgICAgICAgICAgICAgJ3VzaW5nIHNlcnZlciByZW5kZXJpbmcgYW5kIHRoZSBtYXJrdXAgZ2VuZXJhdGVkIG9uIHRoZSAnICtcbiAgICAgICAgICAgICAgJ3NlcnZlciB3YXMgbm90IHdoYXQgdGhlIGNsaWVudCB3YXMgZXhwZWN0aW5nLiBSZWFjdCBpbmplY3RlZCAnICtcbiAgICAgICAgICAgICAgJ25ldyBtYXJrdXAgdG8gY29tcGVuc2F0ZSB3aGljaCB3b3JrcyBidXQgeW91IGhhdmUgbG9zdCBtYW55ICcgK1xuICAgICAgICAgICAgICAnb2YgdGhlIGJlbmVmaXRzIG9mIHNlcnZlciByZW5kZXJpbmcuIEluc3RlYWQsIGZpZ3VyZSBvdXQgJyArXG4gICAgICAgICAgICAgICd3aHkgdGhlIG1hcmt1cCBiZWluZyBnZW5lcmF0ZWQgaXMgZGlmZmVyZW50IG9uIHRoZSBjbGllbnQgJyArXG4gICAgICAgICAgICAgICdvciBzZXJ2ZXIuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICAgY29udGFpbmVyLm5vZGVUeXBlICE9PSBET0NfTk9ERV9UWVBFLFxuICAgICAgICAnWW91XFwncmUgdHJ5aW5nIHRvIHJlbmRlciBhIGNvbXBvbmVudCB0byB0aGUgZG9jdW1lbnQgYnV0ICcgK1xuICAgICAgICAgICd5b3UgZGlkblxcJ3QgdXNlIHNlcnZlciByZW5kZXJpbmcuIFdlIGNhblxcJ3QgZG8gdGhpcyAnICtcbiAgICAgICAgICAnd2l0aG91dCB1c2luZyBzZXJ2ZXIgcmVuZGVyaW5nIGR1ZSB0byBjcm9zcy1icm93c2VyIHF1aXJrcy4gJyArXG4gICAgICAgICAgJ1NlZSByZW5kZXJDb21wb25lbnRUb1N0cmluZygpIGZvciBzZXJ2ZXIgcmVuZGVyaW5nLidcbiAgICAgICkgOiBpbnZhcmlhbnQoY29udGFpbmVyLm5vZGVUeXBlICE9PSBET0NfTk9ERV9UWVBFKSk7XG5cbiAgICAgIHNldElubmVySFRNTChjb250YWluZXIsIG1hcmt1cCk7XG4gICAgfVxuICApXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4qIEBwcm92aWRlc01vZHVsZSBSZWFjdENvbXBvbmVudFdpdGhQdXJlUmVuZGVyTWl4aW5cbiovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgc2hhbGxvd0VxdWFsID0gcmVxdWlyZShcIi4vc2hhbGxvd0VxdWFsXCIpO1xuXG4vKipcbiAqIElmIHlvdXIgUmVhY3QgY29tcG9uZW50J3MgcmVuZGVyIGZ1bmN0aW9uIGlzIFwicHVyZVwiLCBlLmcuIGl0IHdpbGwgcmVuZGVyIHRoZVxuICogc2FtZSByZXN1bHQgZ2l2ZW4gdGhlIHNhbWUgcHJvcHMgYW5kIHN0YXRlLCBwcm92aWRlIHRoaXMgTWl4aW4gZm9yIGFcbiAqIGNvbnNpZGVyYWJsZSBwZXJmb3JtYW5jZSBib29zdC5cbiAqXG4gKiBNb3N0IFJlYWN0IGNvbXBvbmVudHMgaGF2ZSBwdXJlIHJlbmRlciBmdW5jdGlvbnMuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgIHZhciBSZWFjdENvbXBvbmVudFdpdGhQdXJlUmVuZGVyTWl4aW4gPVxuICogICAgIHJlcXVpcmUoJ1JlYWN0Q29tcG9uZW50V2l0aFB1cmVSZW5kZXJNaXhpbicpO1xuICogICBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gKiAgICAgbWl4aW5zOiBbUmVhY3RDb21wb25lbnRXaXRoUHVyZVJlbmRlck1peGluXSxcbiAqXG4gKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAqICAgICAgIHJldHVybiA8ZGl2IGNsYXNzTmFtZT17dGhpcy5wcm9wcy5jbGFzc05hbWV9PmZvbzwvZGl2PjtcbiAqICAgICB9XG4gKiAgIH0pO1xuICpcbiAqIE5vdGU6IFRoaXMgb25seSBjaGVja3Mgc2hhbGxvdyBlcXVhbGl0eSBmb3IgcHJvcHMgYW5kIHN0YXRlLiBJZiB0aGVzZSBjb250YWluXG4gKiBjb21wbGV4IGRhdGEgc3RydWN0dXJlcyB0aGlzIG1peGluIG1heSBoYXZlIGZhbHNlLW5lZ2F0aXZlcyBmb3IgZGVlcGVyXG4gKiBkaWZmZXJlbmNlcy4gT25seSBtaXhpbiB0byBjb21wb25lbnRzIHdoaWNoIGhhdmUgc2ltcGxlIHByb3BzIGFuZCBzdGF0ZSwgb3JcbiAqIHVzZSBgZm9yY2VVcGRhdGUoKWAgd2hlbiB5b3Uga25vdyBkZWVwIGRhdGEgc3RydWN0dXJlcyBoYXZlIGNoYW5nZWQuXG4gKi9cbnZhciBSZWFjdENvbXBvbmVudFdpdGhQdXJlUmVuZGVyTWl4aW4gPSB7XG4gIHNob3VsZENvbXBvbmVudFVwZGF0ZTogZnVuY3Rpb24obmV4dFByb3BzLCBuZXh0U3RhdGUpIHtcbiAgICByZXR1cm4gIXNoYWxsb3dFcXVhbCh0aGlzLnByb3BzLCBuZXh0UHJvcHMpIHx8XG4gICAgICAgICAgICFzaGFsbG93RXF1YWwodGhpcy5zdGF0ZSwgbmV4dFN0YXRlKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbXBvbmVudFdpdGhQdXJlUmVuZGVyTWl4aW47XG4iLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoXCIuL1JlYWN0Q29tcG9uZW50XCIpO1xudmFyIFJlYWN0Q29udGV4dCA9IHJlcXVpcmUoXCIuL1JlYWN0Q29udGV4dFwiKTtcbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoXCIuL1JlYWN0Q3VycmVudE93bmVyXCIpO1xudmFyIFJlYWN0RGVzY3JpcHRvciA9IHJlcXVpcmUoXCIuL1JlYWN0RGVzY3JpcHRvclwiKTtcbnZhciBSZWFjdERlc2NyaXB0b3JWYWxpZGF0b3IgPSByZXF1aXJlKFwiLi9SZWFjdERlc2NyaXB0b3JWYWxpZGF0b3JcIik7XG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudCA9IHJlcXVpcmUoXCIuL1JlYWN0RW1wdHlDb21wb25lbnRcIik7XG52YXIgUmVhY3RFcnJvclV0aWxzID0gcmVxdWlyZShcIi4vUmVhY3RFcnJvclV0aWxzXCIpO1xudmFyIFJlYWN0T3duZXIgPSByZXF1aXJlKFwiLi9SZWFjdE93bmVyXCIpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoXCIuL1JlYWN0UGVyZlwiKTtcbnZhciBSZWFjdFByb3BUcmFuc2ZlcmVyID0gcmVxdWlyZShcIi4vUmVhY3RQcm9wVHJhbnNmZXJlclwiKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25zID0gcmVxdWlyZShcIi4vUmVhY3RQcm9wVHlwZUxvY2F0aW9uc1wiKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHJlcXVpcmUoXCIuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzXCIpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoXCIuL1JlYWN0VXBkYXRlc1wiKTtcblxudmFyIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKFwiLi9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50XCIpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcbnZhciBrZXlNaXJyb3IgPSByZXF1aXJlKFwiLi9rZXlNaXJyb3JcIik7XG52YXIgbWVyZ2UgPSByZXF1aXJlKFwiLi9tZXJnZVwiKTtcbnZhciBtaXhJbnRvID0gcmVxdWlyZShcIi4vbWl4SW50b1wiKTtcbnZhciBtb25pdG9yQ29kZVVzZSA9IHJlcXVpcmUoXCIuL21vbml0b3JDb2RlVXNlXCIpO1xudmFyIG1hcE9iamVjdCA9IHJlcXVpcmUoXCIuL21hcE9iamVjdFwiKTtcbnZhciBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoXCIuL3Nob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50XCIpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKFwiLi93YXJuaW5nXCIpO1xuXG4vKipcbiAqIFBvbGljaWVzIHRoYXQgZGVzY3JpYmUgbWV0aG9kcyBpbiBgUmVhY3RDb21wb3NpdGVDb21wb25lbnRJbnRlcmZhY2VgLlxuICovXG52YXIgU3BlY1BvbGljeSA9IGtleU1pcnJvcih7XG4gIC8qKlxuICAgKiBUaGVzZSBtZXRob2RzIG1heSBiZSBkZWZpbmVkIG9ubHkgb25jZSBieSB0aGUgY2xhc3Mgc3BlY2lmaWNhdGlvbiBvciBtaXhpbi5cbiAgICovXG4gIERFRklORV9PTkNFOiBudWxsLFxuICAvKipcbiAgICogVGhlc2UgbWV0aG9kcyBtYXkgYmUgZGVmaW5lZCBieSBib3RoIHRoZSBjbGFzcyBzcGVjaWZpY2F0aW9uIGFuZCBtaXhpbnMuXG4gICAqIFN1YnNlcXVlbnQgZGVmaW5pdGlvbnMgd2lsbCBiZSBjaGFpbmVkLiBUaGVzZSBtZXRob2RzIG11c3QgcmV0dXJuIHZvaWQuXG4gICAqL1xuICBERUZJTkVfTUFOWTogbnVsbCxcbiAgLyoqXG4gICAqIFRoZXNlIG1ldGhvZHMgYXJlIG92ZXJyaWRpbmcgdGhlIGJhc2UgUmVhY3RDb21wb3NpdGVDb21wb25lbnQgY2xhc3MuXG4gICAqL1xuICBPVkVSUklERV9CQVNFOiBudWxsLFxuICAvKipcbiAgICogVGhlc2UgbWV0aG9kcyBhcmUgc2ltaWxhciB0byBERUZJTkVfTUFOWSwgZXhjZXB0IHdlIGFzc3VtZSB0aGV5IHJldHVyblxuICAgKiBvYmplY3RzLiBXZSB0cnkgdG8gbWVyZ2UgdGhlIGtleXMgb2YgdGhlIHJldHVybiB2YWx1ZXMgb2YgYWxsIHRoZSBtaXhlZCBpblxuICAgKiBmdW5jdGlvbnMuIElmIHRoZXJlIGlzIGEga2V5IGNvbmZsaWN0IHdlIHRocm93LlxuICAgKi9cbiAgREVGSU5FX01BTllfTUVSR0VEOiBudWxsXG59KTtcblxuXG52YXIgaW5qZWN0ZWRNaXhpbnMgPSBbXTtcblxuLyoqXG4gKiBDb21wb3NpdGUgY29tcG9uZW50cyBhcmUgaGlnaGVyLWxldmVsIGNvbXBvbmVudHMgdGhhdCBjb21wb3NlIG90aGVyIGNvbXBvc2l0ZVxuICogb3IgbmF0aXZlIGNvbXBvbmVudHMuXG4gKlxuICogVG8gY3JlYXRlIGEgbmV3IHR5cGUgb2YgYFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50YCwgcGFzcyBhIHNwZWNpZmljYXRpb24gb2ZcbiAqIHlvdXIgbmV3IGNsYXNzIHRvIGBSZWFjdC5jcmVhdGVDbGFzc2AuIFRoZSBvbmx5IHJlcXVpcmVtZW50IG9mIHlvdXIgY2xhc3NcbiAqIHNwZWNpZmljYXRpb24gaXMgdGhhdCB5b3UgaW1wbGVtZW50IGEgYHJlbmRlcmAgbWV0aG9kLlxuICpcbiAqICAgdmFyIE15Q29tcG9uZW50ID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gKiAgICAgICByZXR1cm4gPGRpdj5IZWxsbyBXb3JsZDwvZGl2PjtcbiAqICAgICB9XG4gKiAgIH0pO1xuICpcbiAqIFRoZSBjbGFzcyBzcGVjaWZpY2F0aW9uIHN1cHBvcnRzIGEgc3BlY2lmaWMgcHJvdG9jb2wgb2YgbWV0aG9kcyB0aGF0IGhhdmVcbiAqIHNwZWNpYWwgbWVhbmluZyAoZS5nLiBgcmVuZGVyYCkuIFNlZSBgUmVhY3RDb21wb3NpdGVDb21wb25lbnRJbnRlcmZhY2VgIGZvclxuICogbW9yZSB0aGUgY29tcHJlaGVuc2l2ZSBwcm90b2NvbC4gQW55IG90aGVyIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgaW4gdGhlXG4gKiBjbGFzcyBzcGVjaWZpY2F0aW9uIHdpbGwgYXZhaWxhYmxlIG9uIHRoZSBwcm90b3R5cGUuXG4gKlxuICogQGludGVyZmFjZSBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudEludGVyZmFjZVxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudEludGVyZmFjZSA9IHtcblxuICAvKipcbiAgICogQW4gYXJyYXkgb2YgTWl4aW4gb2JqZWN0cyB0byBpbmNsdWRlIHdoZW4gZGVmaW5pbmcgeW91ciBjb21wb25lbnQuXG4gICAqXG4gICAqIEB0eXBlIHthcnJheX1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBtaXhpbnM6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIEFuIG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgdGhhdCBzaG91bGQgYmUgZGVmaW5lZCBvblxuICAgKiB0aGUgY29tcG9uZW50J3MgY29uc3RydWN0b3IgaW5zdGVhZCBvZiBpdHMgcHJvdG90eXBlIChzdGF0aWMgbWV0aG9kcykuXG4gICAqXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgc3RhdGljczogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogRGVmaW5pdGlvbiBvZiBwcm9wIHR5cGVzIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHR5cGUge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBwcm9wVHlwZXM6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIERlZmluaXRpb24gb2YgY29udGV4dCB0eXBlcyBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAqXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29udGV4dFR5cGVzOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBEZWZpbml0aW9uIG9mIGNvbnRleHQgdHlwZXMgdGhpcyBjb21wb25lbnQgc2V0cyBmb3IgaXRzIGNoaWxkcmVuLlxuICAgKlxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNoaWxkQ29udGV4dFR5cGVzOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8vID09PT0gRGVmaW5pdGlvbiBtZXRob2RzID09PT1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC4gVmFsdWVzIGluIHRoZSBtYXBwaW5nIHdpbGwgYmUgc2V0IG9uXG4gICAqIGB0aGlzLnByb3BzYCBpZiB0aGF0IHByb3AgaXMgbm90IHNwZWNpZmllZCAoaS5lLiB1c2luZyBhbiBgaW5gIGNoZWNrKS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgaW52b2tlZCBiZWZvcmUgYGdldEluaXRpYWxTdGF0ZWAgYW5kIHRoZXJlZm9yZSBjYW5ub3QgcmVseVxuICAgKiBvbiBgdGhpcy5zdGF0ZWAgb3IgdXNlIGB0aGlzLnNldFN0YXRlYC5cbiAgICpcbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGdldERlZmF1bHRQcm9wczogU3BlY1BvbGljeS5ERUZJTkVfTUFOWV9NRVJHRUQsXG5cbiAgLyoqXG4gICAqIEludm9rZWQgb25jZSBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgYmUgdXNlZFxuICAgKiBhcyB0aGUgaW5pdGlhbCB2YWx1ZSBvZiBgdGhpcy5zdGF0ZWAuXG4gICAqXG4gICAqICAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICogICAgIHJldHVybiB7XG4gICAqICAgICAgIGlzT246IGZhbHNlLFxuICAgKiAgICAgICBmb29CYXo6IG5ldyBCYXpGb28oKVxuICAgKiAgICAgfVxuICAgKiAgIH1cbiAgICpcbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGdldEluaXRpYWxTdGF0ZTogU3BlY1BvbGljeS5ERUZJTkVfTUFOWV9NRVJHRUQsXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBnZXRDaGlsZENvbnRleHQ6IFNwZWNQb2xpY3kuREVGSU5FX01BTllfTUVSR0VELFxuXG4gIC8qKlxuICAgKiBVc2VzIHByb3BzIGZyb20gYHRoaXMucHJvcHNgIGFuZCBzdGF0ZSBmcm9tIGB0aGlzLnN0YXRlYCB0byByZW5kZXIgdGhlXG4gICAqIHN0cnVjdHVyZSBvZiB0aGUgY29tcG9uZW50LlxuICAgKlxuICAgKiBObyBndWFyYW50ZWVzIGFyZSBtYWRlIGFib3V0IHdoZW4gb3IgaG93IG9mdGVuIHRoaXMgbWV0aG9kIGlzIGludm9rZWQsIHNvXG4gICAqIGl0IG11c3Qgbm90IGhhdmUgc2lkZSBlZmZlY3RzLlxuICAgKlxuICAgKiAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAqICAgICB2YXIgbmFtZSA9IHRoaXMucHJvcHMubmFtZTtcbiAgICogICAgIHJldHVybiA8ZGl2PkhlbGxvLCB7bmFtZX0hPC9kaXY+O1xuICAgKiAgIH1cbiAgICpcbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9XG4gICAqIEBub3NpZGVlZmZlY3RzXG4gICAqIEByZXF1aXJlZFxuICAgKi9cbiAgcmVuZGVyOiBTcGVjUG9saWN5LkRFRklORV9PTkNFLFxuXG5cblxuICAvLyA9PT09IERlbGVnYXRlIG1ldGhvZHMgPT09PVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBpbml0aWFsbHkgY3JlYXRlZCBhbmQgYWJvdXQgdG8gYmUgbW91bnRlZC5cbiAgICogVGhpcyBtYXkgaGF2ZSBzaWRlIGVmZmVjdHMsIGJ1dCBhbnkgZXh0ZXJuYWwgc3Vic2NyaXB0aW9ucyBvciBkYXRhIGNyZWF0ZWRcbiAgICogYnkgdGhpcyBtZXRob2QgbXVzdCBiZSBjbGVhbmVkIHVwIGluIGBjb21wb25lbnRXaWxsVW5tb3VudGAuXG4gICAqXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50V2lsbE1vdW50OiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBoYXMgYmVlbiBtb3VudGVkIGFuZCBoYXMgYSBET00gcmVwcmVzZW50YXRpb24uXG4gICAqIEhvd2V2ZXIsIHRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSBET00gbm9kZSBpcyBpbiB0aGUgZG9jdW1lbnQuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIG9wZXJhdGUgb24gdGhlIERPTSB3aGVuIHRoZSBjb21wb25lbnQgaGFzXG4gICAqIGJlZW4gbW91bnRlZCAoaW5pdGlhbGl6ZWQgYW5kIHJlbmRlcmVkKSBmb3IgdGhlIGZpcnN0IHRpbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gcm9vdE5vZGUgRE9NIGVsZW1lbnQgcmVwcmVzZW50aW5nIHRoZSBjb21wb25lbnQuXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50RGlkTW91bnQ6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIEludm9rZWQgYmVmb3JlIHRoZSBjb21wb25lbnQgcmVjZWl2ZXMgbmV3IHByb3BzLlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byByZWFjdCB0byBhIHByb3AgdHJhbnNpdGlvbiBieSB1cGRhdGluZyB0aGVcbiAgICogc3RhdGUgdXNpbmcgYHRoaXMuc2V0U3RhdGVgLiBDdXJyZW50IHByb3BzIGFyZSBhY2Nlc3NlZCB2aWEgYHRoaXMucHJvcHNgLlxuICAgKlxuICAgKiAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IGZ1bmN0aW9uKG5leHRQcm9wcywgbmV4dENvbnRleHQpIHtcbiAgICogICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgKiAgICAgICBsaWtlc0luY3JlYXNpbmc6IG5leHRQcm9wcy5saWtlQ291bnQgPiB0aGlzLnByb3BzLmxpa2VDb3VudFxuICAgKiAgICAgfSk7XG4gICAqICAgfVxuICAgKlxuICAgKiBOT1RFOiBUaGVyZSBpcyBubyBlcXVpdmFsZW50IGBjb21wb25lbnRXaWxsUmVjZWl2ZVN0YXRlYC4gQW4gaW5jb21pbmcgcHJvcFxuICAgKiB0cmFuc2l0aW9uIG1heSBjYXVzZSBhIHN0YXRlIGNoYW5nZSwgYnV0IHRoZSBvcHBvc2l0ZSBpcyBub3QgdHJ1ZS4gSWYgeW91XG4gICAqIG5lZWQgaXQsIHlvdSBhcmUgcHJvYmFibHkgbG9va2luZyBmb3IgYGNvbXBvbmVudFdpbGxVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogSW52b2tlZCB3aGlsZSBkZWNpZGluZyBpZiB0aGUgY29tcG9uZW50IHNob3VsZCBiZSB1cGRhdGVkIGFzIGEgcmVzdWx0IG9mXG4gICAqIHJlY2VpdmluZyBuZXcgcHJvcHMsIHN0YXRlIGFuZC9vciBjb250ZXh0LlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBgcmV0dXJuIGZhbHNlYCB3aGVuIHlvdSdyZSBjZXJ0YWluIHRoYXQgdGhlXG4gICAqIHRyYW5zaXRpb24gdG8gdGhlIG5ldyBwcm9wcy9zdGF0ZS9jb250ZXh0IHdpbGwgbm90IHJlcXVpcmUgYSBjb21wb25lbnRcbiAgICogdXBkYXRlLlxuICAgKlxuICAgKiAgIHNob3VsZENvbXBvbmVudFVwZGF0ZTogZnVuY3Rpb24obmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0KSB7XG4gICAqICAgICByZXR1cm4gIWVxdWFsKG5leHRQcm9wcywgdGhpcy5wcm9wcykgfHxcbiAgICogICAgICAgIWVxdWFsKG5leHRTdGF0ZSwgdGhpcy5zdGF0ZSkgfHxcbiAgICogICAgICAgIWVxdWFsKG5leHRDb250ZXh0LCB0aGlzLmNvbnRleHQpO1xuICAgKiAgIH1cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRTdGF0ZVxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRDb250ZXh0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGNvbXBvbmVudCBzaG91bGQgdXBkYXRlLlxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIHNob3VsZENvbXBvbmVudFVwZGF0ZTogU3BlY1BvbGljeS5ERUZJTkVfT05DRSxcblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgYWJvdXQgdG8gdXBkYXRlIGR1ZSB0byBhIHRyYW5zaXRpb24gZnJvbVxuICAgKiBgdGhpcy5wcm9wc2AsIGB0aGlzLnN0YXRlYCBhbmQgYHRoaXMuY29udGV4dGAgdG8gYG5leHRQcm9wc2AsIGBuZXh0U3RhdGVgXG4gICAqIGFuZCBgbmV4dENvbnRleHRgLlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBwZXJmb3JtIHByZXBhcmF0aW9uIGJlZm9yZSBhbiB1cGRhdGUgb2NjdXJzLlxuICAgKlxuICAgKiBOT1RFOiBZb3UgKipjYW5ub3QqKiB1c2UgYHRoaXMuc2V0U3RhdGUoKWAgaW4gdGhpcyBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0U3RhdGVcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0Q29udGV4dFxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50V2lsbFVwZGF0ZTogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQncyBET00gcmVwcmVzZW50YXRpb24gaGFzIGJlZW4gdXBkYXRlZC5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gb3BlcmF0ZSBvbiB0aGUgRE9NIHdoZW4gdGhlIGNvbXBvbmVudCBoYXNcbiAgICogYmVlbiB1cGRhdGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJldlByb3BzXG4gICAqIEBwYXJhbSB7P29iamVjdH0gcHJldlN0YXRlXG4gICAqIEBwYXJhbSB7P29iamVjdH0gcHJldkNvbnRleHRcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSByb290Tm9kZSBET00gZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIGNvbXBvbmVudC5cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnREaWRVcGRhdGU6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGFib3V0IHRvIGJlIHJlbW92ZWQgZnJvbSBpdHMgcGFyZW50IGFuZCBoYXZlXG4gICAqIGl0cyBET00gcmVwcmVzZW50YXRpb24gZGVzdHJveWVkLlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBkZWFsbG9jYXRlIGFueSBleHRlcm5hbCByZXNvdXJjZXMuXG4gICAqXG4gICAqIE5PVEU6IFRoZXJlIGlzIG5vIGBjb21wb25lbnREaWRVbm1vdW50YCBzaW5jZSB5b3VyIGNvbXBvbmVudCB3aWxsIGhhdmUgYmVlblxuICAgKiBkZXN0cm95ZWQgYnkgdGhhdCBwb2ludC5cbiAgICpcbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnRXaWxsVW5tb3VudDogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuXG5cbiAgLy8gPT09PSBBZHZhbmNlZCBtZXRob2RzID09PT1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgY29tcG9uZW50J3MgY3VycmVudGx5IG1vdW50ZWQgRE9NIHJlcHJlc2VudGF0aW9uLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCB0aGlzIGltcGxlbWVudHMgUmVhY3QncyByZW5kZXJpbmcgYW5kIHJlY29uY2lsaWF0aW9uIGFsZ29yaXRobS5cbiAgICogU29waGlzdGljYXRlZCBjbGllbnRzIG1heSB3aXNoIHRvIG92ZXJyaWRlIHRoaXMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQGludGVybmFsXG4gICAqIEBvdmVycmlkYWJsZVxuICAgKi9cbiAgdXBkYXRlQ29tcG9uZW50OiBTcGVjUG9saWN5Lk9WRVJSSURFX0JBU0VcblxufTtcblxuLyoqXG4gKiBNYXBwaW5nIGZyb20gY2xhc3Mgc3BlY2lmaWNhdGlvbiBrZXlzIHRvIHNwZWNpYWwgcHJvY2Vzc2luZyBmdW5jdGlvbnMuXG4gKlxuICogQWx0aG91Z2ggdGhlc2UgYXJlIGRlY2xhcmVkIGxpa2UgaW5zdGFuY2UgcHJvcGVydGllcyBpbiB0aGUgc3BlY2lmaWNhdGlvblxuICogd2hlbiBkZWZpbmluZyBjbGFzc2VzIHVzaW5nIGBSZWFjdC5jcmVhdGVDbGFzc2AsIHRoZXkgYXJlIGFjdHVhbGx5IHN0YXRpY1xuICogYW5kIGFyZSBhY2Nlc3NpYmxlIG9uIHRoZSBjb25zdHJ1Y3RvciBpbnN0ZWFkIG9mIHRoZSBwcm90b3R5cGUuIERlc3BpdGVcbiAqIGJlaW5nIHN0YXRpYywgdGhleSBtdXN0IGJlIGRlZmluZWQgb3V0c2lkZSBvZiB0aGUgXCJzdGF0aWNzXCIga2V5IHVuZGVyXG4gKiB3aGljaCBhbGwgb3RoZXIgc3RhdGljIG1ldGhvZHMgYXJlIGRlZmluZWQuXG4gKi9cbnZhciBSRVNFUlZFRF9TUEVDX0tFWVMgPSB7XG4gIGRpc3BsYXlOYW1lOiBmdW5jdGlvbihDb25zdHJ1Y3RvciwgZGlzcGxheU5hbWUpIHtcbiAgICBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuICB9LFxuICBtaXhpbnM6IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBtaXhpbnMpIHtcbiAgICBpZiAobWl4aW5zKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1peGlucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3RvciwgbWl4aW5zW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGNoaWxkQ29udGV4dFR5cGVzOiBmdW5jdGlvbihDb25zdHJ1Y3RvciwgY2hpbGRDb250ZXh0VHlwZXMpIHtcbiAgICB2YWxpZGF0ZVR5cGVEZWYoXG4gICAgICBDb25zdHJ1Y3RvcixcbiAgICAgIGNoaWxkQ29udGV4dFR5cGVzLFxuICAgICAgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5jaGlsZENvbnRleHRcbiAgICApO1xuICAgIENvbnN0cnVjdG9yLmNoaWxkQ29udGV4dFR5cGVzID0gbWVyZ2UoXG4gICAgICBDb25zdHJ1Y3Rvci5jaGlsZENvbnRleHRUeXBlcyxcbiAgICAgIGNoaWxkQ29udGV4dFR5cGVzXG4gICAgKTtcbiAgfSxcbiAgY29udGV4dFR5cGVzOiBmdW5jdGlvbihDb25zdHJ1Y3RvciwgY29udGV4dFR5cGVzKSB7XG4gICAgdmFsaWRhdGVUeXBlRGVmKFxuICAgICAgQ29uc3RydWN0b3IsXG4gICAgICBjb250ZXh0VHlwZXMsXG4gICAgICBSZWFjdFByb3BUeXBlTG9jYXRpb25zLmNvbnRleHRcbiAgICApO1xuICAgIENvbnN0cnVjdG9yLmNvbnRleHRUeXBlcyA9IG1lcmdlKENvbnN0cnVjdG9yLmNvbnRleHRUeXBlcywgY29udGV4dFR5cGVzKTtcbiAgfSxcbiAgLyoqXG4gICAqIFNwZWNpYWwgY2FzZSBnZXREZWZhdWx0UHJvcHMgd2hpY2ggc2hvdWxkIG1vdmUgaW50byBzdGF0aWNzIGJ1dCByZXF1aXJlc1xuICAgKiBhdXRvbWF0aWMgbWVyZ2luZy5cbiAgICovXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24oQ29uc3RydWN0b3IsIGdldERlZmF1bHRQcm9wcykge1xuICAgIGlmIChDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMpIHtcbiAgICAgIENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcyA9IGNyZWF0ZU1lcmdlZFJlc3VsdEZ1bmN0aW9uKFxuICAgICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMsXG4gICAgICAgIGdldERlZmF1bHRQcm9wc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzID0gZ2V0RGVmYXVsdFByb3BzO1xuICAgIH1cbiAgfSxcbiAgcHJvcFR5cGVzOiBmdW5jdGlvbihDb25zdHJ1Y3RvciwgcHJvcFR5cGVzKSB7XG4gICAgdmFsaWRhdGVUeXBlRGVmKFxuICAgICAgQ29uc3RydWN0b3IsXG4gICAgICBwcm9wVHlwZXMsXG4gICAgICBSZWFjdFByb3BUeXBlTG9jYXRpb25zLnByb3BcbiAgICApO1xuICAgIENvbnN0cnVjdG9yLnByb3BUeXBlcyA9IG1lcmdlKENvbnN0cnVjdG9yLnByb3BUeXBlcywgcHJvcFR5cGVzKTtcbiAgfSxcbiAgc3RhdGljczogZnVuY3Rpb24oQ29uc3RydWN0b3IsIHN0YXRpY3MpIHtcbiAgICBtaXhTdGF0aWNTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3RhdGljcyk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShjb21wb25lbnQpIHtcbiAgdmFyIG93bmVyID0gY29tcG9uZW50Ll9vd25lciB8fCBudWxsO1xuICBpZiAob3duZXIgJiYgb3duZXIuY29uc3RydWN0b3IgJiYgb3duZXIuY29uc3RydWN0b3IuZGlzcGxheU5hbWUpIHtcbiAgICByZXR1cm4gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG93bmVyLmNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lICtcbiAgICAgICdgLic7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVR5cGVEZWYoQ29uc3RydWN0b3IsIHR5cGVEZWYsIGxvY2F0aW9uKSB7XG4gIGZvciAodmFyIHByb3BOYW1lIGluIHR5cGVEZWYpIHtcbiAgICBpZiAodHlwZURlZi5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAgIHR5cGVvZiB0eXBlRGVmW3Byb3BOYW1lXSA9PSAnZnVuY3Rpb24nLFxuICAgICAgICAnJXM6ICVzIHR5cGUgYCVzYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSAnICtcbiAgICAgICAgJ1JlYWN0LlByb3BUeXBlcy4nLFxuICAgICAgICBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnLFxuICAgICAgICBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sXG4gICAgICAgIHByb3BOYW1lXG4gICAgICApIDogaW52YXJpYW50KHR5cGVvZiB0eXBlRGVmW3Byb3BOYW1lXSA9PSAnZnVuY3Rpb24nKSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTWV0aG9kT3ZlcnJpZGUocHJvdG8sIG5hbWUpIHtcbiAgdmFyIHNwZWNQb2xpY3kgPSBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudEludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgUmVhY3RDb21wb3NpdGVDb21wb25lbnRJbnRlcmZhY2VbbmFtZV0gOlxuICAgIG51bGw7XG5cbiAgLy8gRGlzYWxsb3cgb3ZlcnJpZGluZyBvZiBiYXNlIGNsYXNzIG1ldGhvZHMgdW5sZXNzIGV4cGxpY2l0bHkgYWxsb3dlZC5cbiAgaWYgKFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50TWl4aW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5PVkVSUklERV9CQVNFLFxuICAgICAgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50SW50ZXJmYWNlOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gb3ZlcnJpZGUgJyArXG4gICAgICAnYCVzYCBmcm9tIHlvdXIgY2xhc3Mgc3BlY2lmaWNhdGlvbi4gRW5zdXJlIHRoYXQgeW91ciBtZXRob2QgbmFtZXMgJyArXG4gICAgICAnZG8gbm90IG92ZXJsYXAgd2l0aCBSZWFjdCBtZXRob2RzLicsXG4gICAgICBuYW1lXG4gICAgKSA6IGludmFyaWFudChzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5Lk9WRVJSSURFX0JBU0UpKTtcbiAgfVxuXG4gIC8vIERpc2FsbG93IGRlZmluaW5nIG1ldGhvZHMgbW9yZSB0aGFuIG9uY2UgdW5sZXNzIGV4cGxpY2l0bHkgYWxsb3dlZC5cbiAgaWYgKHByb3RvLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgIHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuREVGSU5FX01BTlkgfHxcbiAgICAgIHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuREVGSU5FX01BTllfTUVSR0VELFxuICAgICAgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50SW50ZXJmYWNlOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gZGVmaW5lICcgK1xuICAgICAgJ2Alc2Agb24geW91ciBjb21wb25lbnQgbW9yZSB0aGFuIG9uY2UuIFRoaXMgY29uZmxpY3QgbWF5IGJlIGR1ZSAnICtcbiAgICAgICd0byBhIG1peGluLicsXG4gICAgICBuYW1lXG4gICAgKSA6IGludmFyaWFudChzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5LkRFRklORV9NQU5ZIHx8XG4gICAgc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5ERUZJTkVfTUFOWV9NRVJHRUQpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUxpZmVDeWNsZU9uUmVwbGFjZVN0YXRlKGluc3RhbmNlKSB7XG4gIHZhciBjb21wb3NpdGVMaWZlQ3ljbGVTdGF0ZSA9IGluc3RhbmNlLl9jb21wb3NpdGVMaWZlQ3ljbGVTdGF0ZTtcbiAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICBpbnN0YW5jZS5pc01vdW50ZWQoKSB8fFxuICAgICAgY29tcG9zaXRlTGlmZUN5Y2xlU3RhdGUgPT09IENvbXBvc2l0ZUxpZmVDeWNsZS5NT1VOVElORyxcbiAgICAncmVwbGFjZVN0YXRlKC4uLik6IENhbiBvbmx5IHVwZGF0ZSBhIG1vdW50ZWQgb3IgbW91bnRpbmcgY29tcG9uZW50LidcbiAgKSA6IGludmFyaWFudChpbnN0YW5jZS5pc01vdW50ZWQoKSB8fFxuICAgIGNvbXBvc2l0ZUxpZmVDeWNsZVN0YXRlID09PSBDb21wb3NpdGVMaWZlQ3ljbGUuTU9VTlRJTkcpKTtcbiAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChjb21wb3NpdGVMaWZlQ3ljbGVTdGF0ZSAhPT0gQ29tcG9zaXRlTGlmZUN5Y2xlLlJFQ0VJVklOR19TVEFURSxcbiAgICAncmVwbGFjZVN0YXRlKC4uLik6IENhbm5vdCB1cGRhdGUgZHVyaW5nIGFuIGV4aXN0aW5nIHN0YXRlIHRyYW5zaXRpb24gJyArXG4gICAgJyhzdWNoIGFzIHdpdGhpbiBgcmVuZGVyYCkuIFRoaXMgY291bGQgcG90ZW50aWFsbHkgY2F1c2UgYW4gaW5maW5pdGUgJyArXG4gICAgJ2xvb3Agc28gaXQgaXMgZm9yYmlkZGVuLidcbiAgKSA6IGludmFyaWFudChjb21wb3NpdGVMaWZlQ3ljbGVTdGF0ZSAhPT0gQ29tcG9zaXRlTGlmZUN5Y2xlLlJFQ0VJVklOR19TVEFURSkpO1xuICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KGNvbXBvc2l0ZUxpZmVDeWNsZVN0YXRlICE9PSBDb21wb3NpdGVMaWZlQ3ljbGUuVU5NT1VOVElORyxcbiAgICAncmVwbGFjZVN0YXRlKC4uLik6IENhbm5vdCB1cGRhdGUgd2hpbGUgdW5tb3VudGluZyBjb21wb25lbnQuIFRoaXMgJyArXG4gICAgJ3VzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCBzZXRTdGF0ZSgpIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJ1xuICApIDogaW52YXJpYW50KGNvbXBvc2l0ZUxpZmVDeWNsZVN0YXRlICE9PSBDb21wb3NpdGVMaWZlQ3ljbGUuVU5NT1VOVElORykpO1xufVxuXG4vKipcbiAqIEN1c3RvbSB2ZXJzaW9uIG9mIGBtaXhJbnRvYCB3aGljaCBoYW5kbGVzIHBvbGljeSB2YWxpZGF0aW9uIGFuZCByZXNlcnZlZFxuICogc3BlY2lmaWNhdGlvbiBrZXlzIHdoZW4gYnVpbGRpbmcgYFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50YCBjbGFzc3Nlcy5cbiAqL1xuZnVuY3Rpb24gbWl4U3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHNwZWMpIHtcbiAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAhUmVhY3REZXNjcmlwdG9yLmlzVmFsaWRGYWN0b3J5KHNwZWMpLFxuICAgICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudDogWW91XFwncmUgYXR0ZW1wdGluZyB0byAnICtcbiAgICAndXNlIGEgY29tcG9uZW50IGNsYXNzIGFzIGEgbWl4aW4uIEluc3RlYWQsIGp1c3QgdXNlIGEgcmVndWxhciBvYmplY3QuJ1xuICApIDogaW52YXJpYW50KCFSZWFjdERlc2NyaXB0b3IuaXNWYWxpZEZhY3Rvcnkoc3BlYykpKTtcbiAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAhUmVhY3REZXNjcmlwdG9yLmlzVmFsaWREZXNjcmlwdG9yKHNwZWMpLFxuICAgICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudDogWW91XFwncmUgYXR0ZW1wdGluZyB0byAnICtcbiAgICAndXNlIGEgY29tcG9uZW50IGFzIGEgbWl4aW4uIEluc3RlYWQsIGp1c3QgdXNlIGEgcmVndWxhciBvYmplY3QuJ1xuICApIDogaW52YXJpYW50KCFSZWFjdERlc2NyaXB0b3IuaXNWYWxpZERlc2NyaXB0b3Ioc3BlYykpKTtcblxuICB2YXIgcHJvdG8gPSBDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIGZvciAodmFyIG5hbWUgaW4gc3BlYykge1xuICAgIHZhciBwcm9wZXJ0eSA9IHNwZWNbbmFtZV07XG4gICAgaWYgKCFzcGVjLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YWxpZGF0ZU1ldGhvZE92ZXJyaWRlKHByb3RvLCBuYW1lKTtcblxuICAgIGlmIChSRVNFUlZFRF9TUEVDX0tFWVMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIFJFU0VSVkVEX1NQRUNfS0VZU1tuYW1lXShDb25zdHJ1Y3RvciwgcHJvcGVydHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZXR1cCBtZXRob2RzIG9uIHByb3RvdHlwZTpcbiAgICAgIC8vIFRoZSBmb2xsb3dpbmcgbWVtYmVyIG1ldGhvZHMgc2hvdWxkIG5vdCBiZSBhdXRvbWF0aWNhbGx5IGJvdW5kOlxuICAgICAgLy8gMS4gRXhwZWN0ZWQgUmVhY3RDb21wb3NpdGVDb21wb25lbnQgbWV0aG9kcyAoaW4gdGhlIFwiaW50ZXJmYWNlXCIpLlxuICAgICAgLy8gMi4gT3ZlcnJpZGRlbiBtZXRob2RzICh0aGF0IHdlcmUgbWl4ZWQgaW4pLlxuICAgICAgdmFyIGlzQ29tcG9zaXRlQ29tcG9uZW50TWV0aG9kID1cbiAgICAgICAgUmVhY3RDb21wb3NpdGVDb21wb25lbnRJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkobmFtZSk7XG4gICAgICB2YXIgaXNBbHJlYWR5RGVmaW5lZCA9IHByb3RvLmhhc093blByb3BlcnR5KG5hbWUpO1xuICAgICAgdmFyIG1hcmtlZERvbnRCaW5kID0gcHJvcGVydHkgJiYgcHJvcGVydHkuX19yZWFjdERvbnRCaW5kO1xuICAgICAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgcHJvcGVydHkgPT09ICdmdW5jdGlvbic7XG4gICAgICB2YXIgc2hvdWxkQXV0b0JpbmQgPVxuICAgICAgICBpc0Z1bmN0aW9uICYmXG4gICAgICAgICFpc0NvbXBvc2l0ZUNvbXBvbmVudE1ldGhvZCAmJlxuICAgICAgICAhaXNBbHJlYWR5RGVmaW5lZCAmJlxuICAgICAgICAhbWFya2VkRG9udEJpbmQ7XG5cbiAgICAgIGlmIChzaG91bGRBdXRvQmluZCkge1xuICAgICAgICBpZiAoIXByb3RvLl9fcmVhY3RBdXRvQmluZE1hcCkge1xuICAgICAgICAgIHByb3RvLl9fcmVhY3RBdXRvQmluZE1hcCA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHByb3RvLl9fcmVhY3RBdXRvQmluZE1hcFtuYW1lXSA9IHByb3BlcnR5O1xuICAgICAgICBwcm90b1tuYW1lXSA9IHByb3BlcnR5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzQWxyZWFkeURlZmluZWQpIHtcbiAgICAgICAgICB2YXIgc3BlY1BvbGljeSA9IFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50SW50ZXJmYWNlW25hbWVdO1xuXG4gICAgICAgICAgLy8gVGhlc2UgY2FzZXMgc2hvdWxkIGFscmVhZHkgYmUgY2F1Z2h0IGJ5IHZhbGlkYXRlTWV0aG9kT3ZlcnJpZGVcbiAgICAgICAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgICAgICAgaXNDb21wb3NpdGVDb21wb25lbnRNZXRob2QgJiYgKFxuICAgICAgICAgICAgICBzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5LkRFRklORV9NQU5ZX01FUkdFRCB8fFxuICAgICAgICAgICAgICBzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5LkRFRklORV9NQU5ZXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50OiBVbmV4cGVjdGVkIHNwZWMgcG9saWN5ICVzIGZvciBrZXkgJXMgJyArXG4gICAgICAgICAgICAnd2hlbiBtaXhpbmcgaW4gY29tcG9uZW50IHNwZWNzLicsXG4gICAgICAgICAgICBzcGVjUG9saWN5LFxuICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICkgOiBpbnZhcmlhbnQoaXNDb21wb3NpdGVDb21wb25lbnRNZXRob2QgJiYgKFxuICAgICAgICAgICAgc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5ERUZJTkVfTUFOWV9NRVJHRUQgfHxcbiAgICAgICAgICAgIHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuREVGSU5FX01BTllcbiAgICAgICAgICApKSk7XG5cbiAgICAgICAgICAvLyBGb3IgbWV0aG9kcyB3aGljaCBhcmUgZGVmaW5lZCBtb3JlIHRoYW4gb25jZSwgY2FsbCB0aGUgZXhpc3RpbmdcbiAgICAgICAgICAvLyBtZXRob2RzIGJlZm9yZSBjYWxsaW5nIHRoZSBuZXcgcHJvcGVydHksIG1lcmdpbmcgaWYgYXBwcm9wcmlhdGUuXG4gICAgICAgICAgaWYgKHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuREVGSU5FX01BTllfTUVSR0VEKSB7XG4gICAgICAgICAgICBwcm90b1tuYW1lXSA9IGNyZWF0ZU1lcmdlZFJlc3VsdEZ1bmN0aW9uKHByb3RvW25hbWVdLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5LkRFRklORV9NQU5ZKSB7XG4gICAgICAgICAgICBwcm90b1tuYW1lXSA9IGNyZWF0ZUNoYWluZWRGdW5jdGlvbihwcm90b1tuYW1lXSwgcHJvcGVydHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm90b1tuYW1lXSA9IHByb3BlcnR5O1xuICAgICAgICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgICAgICAgIC8vIEFkZCB2ZXJib3NlIGRpc3BsYXlOYW1lIHRvIHRoZSBmdW5jdGlvbiwgd2hpY2ggaGVscHMgd2hlbiBsb29raW5nXG4gICAgICAgICAgICAvLyBhdCBwcm9maWxpbmcgdG9vbHMuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3BlcnR5ID09PSAnZnVuY3Rpb24nICYmIHNwZWMuZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICAgICAgcHJvdG9bbmFtZV0uZGlzcGxheU5hbWUgPSBzcGVjLmRpc3BsYXlOYW1lICsgJ18nICsgbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWl4U3RhdGljU3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHN0YXRpY3MpIHtcbiAgaWYgKCFzdGF0aWNzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAodmFyIG5hbWUgaW4gc3RhdGljcykge1xuICAgIHZhciBwcm9wZXJ0eSA9IHN0YXRpY3NbbmFtZV07XG4gICAgaWYgKCFzdGF0aWNzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgaXNJbmhlcml0ZWQgPSBuYW1lIGluIENvbnN0cnVjdG9yO1xuICAgIHZhciByZXN1bHQgPSBwcm9wZXJ0eTtcbiAgICBpZiAoaXNJbmhlcml0ZWQpIHtcbiAgICAgIHZhciBleGlzdGluZ1Byb3BlcnR5ID0gQ29uc3RydWN0b3JbbmFtZV07XG4gICAgICB2YXIgZXhpc3RpbmdUeXBlID0gdHlwZW9mIGV4aXN0aW5nUHJvcGVydHk7XG4gICAgICB2YXIgcHJvcGVydHlUeXBlID0gdHlwZW9mIHByb3BlcnR5O1xuICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICAgZXhpc3RpbmdUeXBlID09PSAnZnVuY3Rpb24nICYmIHByb3BlcnR5VHlwZSA9PT0gJ2Z1bmN0aW9uJyxcbiAgICAgICAgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50OiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gZGVmaW5lICcgK1xuICAgICAgICAnYCVzYCBvbiB5b3VyIGNvbXBvbmVudCBtb3JlIHRoYW4gb25jZSwgYnV0IHRoYXQgaXMgb25seSBzdXBwb3J0ZWQgJyArXG4gICAgICAgICdmb3IgZnVuY3Rpb25zLCB3aGljaCBhcmUgY2hhaW5lZCB0b2dldGhlci4gVGhpcyBjb25mbGljdCBtYXkgYmUgJyArXG4gICAgICAgICdkdWUgdG8gYSBtaXhpbi4nLFxuICAgICAgICBuYW1lXG4gICAgICApIDogaW52YXJpYW50KGV4aXN0aW5nVHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wZXJ0eVR5cGUgPT09ICdmdW5jdGlvbicpKTtcbiAgICAgIHJlc3VsdCA9IGNyZWF0ZUNoYWluZWRGdW5jdGlvbihleGlzdGluZ1Byb3BlcnR5LCBwcm9wZXJ0eSk7XG4gICAgfVxuICAgIENvbnN0cnVjdG9yW25hbWVdID0gcmVzdWx0O1xuICB9XG59XG5cbi8qKlxuICogTWVyZ2UgdHdvIG9iamVjdHMsIGJ1dCB0aHJvdyBpZiBib3RoIGNvbnRhaW4gdGhlIHNhbWUga2V5LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvbmUgVGhlIGZpcnN0IG9iamVjdCwgd2hpY2ggaXMgbXV0YXRlZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSB0d28gVGhlIHNlY29uZCBvYmplY3RcbiAqIEByZXR1cm4ge29iamVjdH0gb25lIGFmdGVyIGl0IGhhcyBiZWVuIG11dGF0ZWQgdG8gY29udGFpbiBldmVyeXRoaW5nIGluIHR3by5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VPYmplY3RzV2l0aE5vRHVwbGljYXRlS2V5cyhvbmUsIHR3bykge1xuICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgIG9uZSAmJiB0d28gJiYgdHlwZW9mIG9uZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHR3byA9PT0gJ29iamVjdCcsXG4gICAgJ21lcmdlT2JqZWN0c1dpdGhOb0R1cGxpY2F0ZUtleXMoKTogQ2Fubm90IG1lcmdlIG5vbi1vYmplY3RzJ1xuICApIDogaW52YXJpYW50KG9uZSAmJiB0d28gJiYgdHlwZW9mIG9uZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHR3byA9PT0gJ29iamVjdCcpKTtcblxuICBtYXBPYmplY3QodHdvLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgIG9uZVtrZXldID09PSB1bmRlZmluZWQsXG4gICAgICAnbWVyZ2VPYmplY3RzV2l0aE5vRHVwbGljYXRlS2V5cygpOiAnICtcbiAgICAgICdUcmllZCB0byBtZXJnZSB0d28gb2JqZWN0cyB3aXRoIHRoZSBzYW1lIGtleTogJXMnLFxuICAgICAga2V5XG4gICAgKSA6IGludmFyaWFudChvbmVba2V5XSA9PT0gdW5kZWZpbmVkKSk7XG4gICAgb25lW2tleV0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiBvbmU7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0d28gZnVuY3Rpb25zIGFuZCBtZXJnZXMgdGhlaXIgcmV0dXJuIHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbmUgRnVuY3Rpb24gdG8gaW52b2tlIGZpcnN0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gdHdvIEZ1bmN0aW9uIHRvIGludm9rZSBzZWNvbmQuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gRnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSB0d28gYXJndW1lbnQgZnVuY3Rpb25zLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTWVyZ2VkUmVzdWx0RnVuY3Rpb24ob25lLCB0d28pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZFJlc3VsdCgpIHtcbiAgICB2YXIgYSA9IG9uZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHZhciBiID0gdHdvLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKGEgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGI7XG4gICAgfSBlbHNlIGlmIChiID09IG51bGwpIHtcbiAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VPYmplY3RzV2l0aE5vRHVwbGljYXRlS2V5cyhhLCBiKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHR3byBmdW5jdGlvbnMgYW5kIGlnbm9yZXMgdGhlaXIgcmV0dXJuIHZhbGVzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uZSBGdW5jdGlvbiB0byBpbnZva2UgZmlyc3QuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB0d28gRnVuY3Rpb24gdG8gaW52b2tlIHNlY29uZC5cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSBGdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIHR3byBhcmd1bWVudCBmdW5jdGlvbnMuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjcmVhdGVDaGFpbmVkRnVuY3Rpb24ob25lLCB0d28pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNoYWluZWRGdW5jdGlvbigpIHtcbiAgICBvbmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0d28uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBgUmVhY3RDb21wb3NpdGVDb21wb25lbnRgIG1haW50YWlucyBhbiBhdXhpbGlhcnkgbGlmZSBjeWNsZSBzdGF0ZSBpblxuICogYHRoaXMuX2NvbXBvc2l0ZUxpZmVDeWNsZVN0YXRlYCAod2hpY2ggY2FuIGJlIG51bGwpLlxuICpcbiAqIFRoaXMgaXMgZGlmZmVyZW50IGZyb20gdGhlIGxpZmUgY3ljbGUgc3RhdGUgbWFpbnRhaW5lZCBieSBgUmVhY3RDb21wb25lbnRgIGluXG4gKiBgdGhpcy5fbGlmZUN5Y2xlU3RhdGVgLiBUaGUgZm9sbG93aW5nIGRpYWdyYW0gc2hvd3MgaG93IHRoZSBzdGF0ZXMgb3ZlcmxhcCBpblxuICogdGltZS4gVGhlcmUgYXJlIHRpbWVzIHdoZW4gdGhlIENvbXBvc2l0ZUxpZmVDeWNsZSBpcyBudWxsIC0gYXQgdGhvc2UgdGltZXMgaXRcbiAqIGlzIG9ubHkgbWVhbmluZ2Z1bCB0byBsb29rIGF0IENvbXBvbmVudExpZmVDeWNsZSBhbG9uZS5cbiAqXG4gKiBUb3AgUm93OiBSZWFjdENvbXBvbmVudC5Db21wb25lbnRMaWZlQ3ljbGVcbiAqIExvdyBSb3c6IFJlYWN0Q29tcG9uZW50LkNvbXBvc2l0ZUxpZmVDeWNsZVxuICpcbiAqICstLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLStcbiAqIHwgIFVOICAgfCAgICAgICAgICAgICAgICAgICAgTU9VTlRFRCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICBVTiAgIHxcbiAqIHxNT1VOVEVEfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgTU9VTlRFRHxcbiAqICstLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLStcbiAqIHwgICAgICAgXi0tLS0tLS0tKyAgICstLS0tLS0rICAgKy0tLS0tLSsgICArLS0tLS0tKyAgICstLS0tLS0tLV4gICAgICAgIHxcbiAqIHwgICAgICAgfCAgICAgICAgfCAgIHwgICAgICB8ICAgfCAgICAgIHwgICB8ICAgICAgfCAgIHwgICAgICAgIHwgICAgICAgIHxcbiAqIHwgICAgMC0tfE1PVU5USU5HfC0wLXxSRUNFSVZ8LTAtfFJFQ0VJVnwtMC18UkVDRUlWfC0wLXwgICBVTiAgIHwtLS0+MCAgIHxcbiAqIHwgICAgICAgfCAgICAgICAgfCAgIHxQUk9QUyB8ICAgfCBQUk9QU3wgICB8IFNUQVRFfCAgIHxNT1VOVElOR3wgICAgICAgIHxcbiAqIHwgICAgICAgfCAgICAgICAgfCAgIHwgICAgICB8ICAgfCAgICAgIHwgICB8ICAgICAgfCAgIHwgICAgICAgIHwgICAgICAgIHxcbiAqIHwgICAgICAgfCAgICAgICAgfCAgIHwgICAgICB8ICAgfCAgICAgIHwgICB8ICAgICAgfCAgIHwgICAgICAgIHwgICAgICAgIHxcbiAqIHwgICAgICAgKy0tLS0tLS0tKyAgICstLS0tLS0rICAgKy0tLS0tLSsgICArLS0tLS0tKyAgICstLS0tLS0tLSsgICAgICAgIHxcbiAqIHwgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgIHxcbiAqICstLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLStcbiAqL1xudmFyIENvbXBvc2l0ZUxpZmVDeWNsZSA9IGtleU1pcnJvcih7XG4gIC8qKlxuICAgKiBDb21wb25lbnRzIGluIHRoZSBwcm9jZXNzIG9mIGJlaW5nIG1vdW50ZWQgcmVzcG9uZCB0byBzdGF0ZSBjaGFuZ2VzXG4gICAqIGRpZmZlcmVudGx5LlxuICAgKi9cbiAgTU9VTlRJTkc6IG51bGwsXG4gIC8qKlxuICAgKiBDb21wb25lbnRzIGluIHRoZSBwcm9jZXNzIG9mIGJlaW5nIHVubW91bnRlZCBhcmUgZ3VhcmRlZCBhZ2FpbnN0IHN0YXRlXG4gICAqIGNoYW5nZXMuXG4gICAqL1xuICBVTk1PVU5USU5HOiBudWxsLFxuICAvKipcbiAgICogQ29tcG9uZW50cyB0aGF0IGFyZSBtb3VudGVkIGFuZCByZWNlaXZpbmcgbmV3IHByb3BzIHJlc3BvbmQgdG8gc3RhdGVcbiAgICogY2hhbmdlcyBkaWZmZXJlbnRseS5cbiAgICovXG4gIFJFQ0VJVklOR19QUk9QUzogbnVsbCxcbiAgLyoqXG4gICAqIENvbXBvbmVudHMgdGhhdCBhcmUgbW91bnRlZCBhbmQgcmVjZWl2aW5nIG5ldyBzdGF0ZSBhcmUgZ3VhcmRlZCBhZ2FpbnN0XG4gICAqIGFkZGl0aW9uYWwgc3RhdGUgY2hhbmdlcy5cbiAgICovXG4gIFJFQ0VJVklOR19TVEFURTogbnVsbFxufSk7XG5cbi8qKlxuICogQGxlbmRzIHtSZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5wcm90b3R5cGV9XG4gKi9cbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudE1peGluID0ge1xuXG4gIC8qKlxuICAgKiBCYXNlIGNvbnN0cnVjdG9yIGZvciBhbGwgY29tcG9zaXRlIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdERlc2NyaXB0b3J9IGRlc2NyaXB0b3JcbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0OiBmdW5jdGlvbihkZXNjcmlwdG9yKSB7XG4gICAgLy8gQ2hpbGRyZW4gY2FuIGJlIGVpdGhlciBhbiBhcnJheSBvciBtb3JlIHRoYW4gb25lIGFyZ3VtZW50XG4gICAgUmVhY3RDb21wb25lbnQuTWl4aW4uY29uc3RydWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgUmVhY3RPd25lci5NaXhpbi5jb25zdHJ1Y3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHRoaXMuc3RhdGUgPSBudWxsO1xuICAgIHRoaXMuX3BlbmRpbmdTdGF0ZSA9IG51bGw7XG5cbiAgICAvLyBUaGlzIGlzIHRoZSBwdWJsaWMgcG9zdC1wcm9jZXNzZWQgY29udGV4dC4gVGhlIHJlYWwgY29udGV4dCBhbmQgcGVuZGluZ1xuICAgIC8vIGNvbnRleHQgbGl2ZXMgb24gdGhlIGRlc2NyaXB0b3IuXG4gICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcblxuICAgIHRoaXMuX2NvbXBvc2l0ZUxpZmVDeWNsZVN0YXRlID0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAZmluYWxcbiAgICovXG4gIGlzTW91bnRlZDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFJlYWN0Q29tcG9uZW50Lk1peGluLmlzTW91bnRlZC5jYWxsKHRoaXMpICYmXG4gICAgICB0aGlzLl9jb21wb3NpdGVMaWZlQ3ljbGVTdGF0ZSAhPT0gQ29tcG9zaXRlTGlmZUN5Y2xlLk1PVU5USU5HO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgY29tcG9uZW50LCByZW5kZXJzIG1hcmt1cCwgYW5kIHJlZ2lzdGVycyBldmVudCBsaXN0ZW5lcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByb290SUQgRE9NIElEIG9mIHRoZSByb290IG5vZGUuXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gbW91bnREZXB0aCBudW1iZXIgb2YgY29tcG9uZW50cyBpbiB0aGUgb3duZXIgaGllcmFyY2h5XG4gICAqIEByZXR1cm4gez9zdHJpbmd9IFJlbmRlcmVkIG1hcmt1cCB0byBiZSBpbnNlcnRlZCBpbnRvIHRoZSBET00uXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG1vdW50Q29tcG9uZW50OiBSZWFjdFBlcmYubWVhc3VyZShcbiAgICAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnLFxuICAgICdtb3VudENvbXBvbmVudCcsXG4gICAgZnVuY3Rpb24ocm9vdElELCB0cmFuc2FjdGlvbiwgbW91bnREZXB0aCkge1xuICAgICAgUmVhY3RDb21wb25lbnQuTWl4aW4ubW91bnRDb21wb25lbnQuY2FsbChcbiAgICAgICAgdGhpcyxcbiAgICAgICAgcm9vdElELFxuICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgbW91bnREZXB0aFxuICAgICAgKTtcbiAgICAgIHRoaXMuX2NvbXBvc2l0ZUxpZmVDeWNsZVN0YXRlID0gQ29tcG9zaXRlTGlmZUN5Y2xlLk1PVU5USU5HO1xuXG4gICAgICBpZiAodGhpcy5fX3JlYWN0QXV0b0JpbmRNYXApIHtcbiAgICAgICAgdGhpcy5fYmluZEF1dG9CaW5kTWV0aG9kcygpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbnRleHQgPSB0aGlzLl9wcm9jZXNzQ29udGV4dCh0aGlzLl9kZXNjcmlwdG9yLl9jb250ZXh0KTtcbiAgICAgIHRoaXMucHJvcHMgPSB0aGlzLl9wcm9jZXNzUHJvcHModGhpcy5wcm9wcyk7XG5cbiAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLmdldEluaXRpYWxTdGF0ZSA/IHRoaXMuZ2V0SW5pdGlhbFN0YXRlKCkgOiBudWxsO1xuICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICAgdHlwZW9mIHRoaXMuc3RhdGUgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHRoaXMuc3RhdGUpLFxuICAgICAgICAnJXMuZ2V0SW5pdGlhbFN0YXRlKCk6IG11c3QgcmV0dXJuIGFuIG9iamVjdCBvciBudWxsJyxcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnXG4gICAgICApIDogaW52YXJpYW50KHR5cGVvZiB0aGlzLnN0YXRlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheSh0aGlzLnN0YXRlKSkpO1xuXG4gICAgICB0aGlzLl9wZW5kaW5nU3RhdGUgPSBudWxsO1xuICAgICAgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgIGlmICh0aGlzLmNvbXBvbmVudFdpbGxNb3VudCkge1xuICAgICAgICB0aGlzLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgICAvLyBXaGVuIG1vdW50aW5nLCBjYWxscyB0byBgc2V0U3RhdGVgIGJ5IGBjb21wb25lbnRXaWxsTW91bnRgIHdpbGwgc2V0XG4gICAgICAgIC8vIGB0aGlzLl9wZW5kaW5nU3RhdGVgIHdpdGhvdXQgdHJpZ2dlcmluZyBhIHJlLXJlbmRlci5cbiAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdTdGF0ZSkge1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLl9wZW5kaW5nU3RhdGU7XG4gICAgICAgICAgdGhpcy5fcGVuZGluZ1N0YXRlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudCA9IGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQoXG4gICAgICAgIHRoaXMuX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCgpXG4gICAgICApO1xuXG4gICAgICAvLyBEb25lIHdpdGggbW91bnRpbmcsIGBzZXRTdGF0ZWAgd2lsbCBub3cgdHJpZ2dlciBVSSBjaGFuZ2VzLlxuICAgICAgdGhpcy5fY29tcG9zaXRlTGlmZUN5Y2xlU3RhdGUgPSBudWxsO1xuICAgICAgdmFyIG1hcmt1cCA9IHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50Lm1vdW50Q29tcG9uZW50KFxuICAgICAgICByb290SUQsXG4gICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICBtb3VudERlcHRoICsgMVxuICAgICAgKTtcbiAgICAgIGlmICh0aGlzLmNvbXBvbmVudERpZE1vdW50KSB7XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUodGhpcy5jb21wb25lbnREaWRNb3VudCwgdGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFya3VwO1xuICAgIH1cbiAgKSxcblxuICAvKipcbiAgICogUmVsZWFzZXMgYW55IHJlc291cmNlcyBhbGxvY2F0ZWQgYnkgYG1vdW50Q29tcG9uZW50YC5cbiAgICpcbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fY29tcG9zaXRlTGlmZUN5Y2xlU3RhdGUgPSBDb21wb3NpdGVMaWZlQ3ljbGUuVU5NT1VOVElORztcbiAgICBpZiAodGhpcy5jb21wb25lbnRXaWxsVW5tb3VudCkge1xuICAgICAgdGhpcy5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuICAgIH1cbiAgICB0aGlzLl9jb21wb3NpdGVMaWZlQ3ljbGVTdGF0ZSA9IG51bGw7XG5cbiAgICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudC51bm1vdW50Q29tcG9uZW50KCk7XG4gICAgdGhpcy5fcmVuZGVyZWRDb21wb25lbnQgPSBudWxsO1xuXG4gICAgUmVhY3RDb21wb25lbnQuTWl4aW4udW5tb3VudENvbXBvbmVudC5jYWxsKHRoaXMpO1xuXG4gICAgLy8gU29tZSBleGlzdGluZyBjb21wb25lbnRzIHJlbHkgb24gdGhpcy5wcm9wcyBldmVuIGFmdGVyIHRoZXkndmUgYmVlblxuICAgIC8vIGRlc3Ryb3llZCAoaW4gZXZlbnQgaGFuZGxlcnMpLlxuICAgIC8vIFRPRE86IHRoaXMucHJvcHMgPSBudWxsO1xuICAgIC8vIFRPRE86IHRoaXMuc3RhdGUgPSBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGByZXBsYWNlU3RhdGVgIHRvIG11dGF0ZVxuICAgKiBzdGF0ZS4gWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICAgKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICAgKlxuICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBjYWxscyB0byBgc2V0U3RhdGVgIHdpbGwgcnVuIHN5bmNocm9ub3VzbHksXG4gICAqIGFzIHRoZXkgbWF5IGV2ZW50dWFsbHkgYmUgYmF0Y2hlZCB0b2dldGhlci4gIFlvdSBjYW4gcHJvdmlkZSBhbiBvcHRpb25hbFxuICAgKiBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiB0aGUgY2FsbCB0byBzZXRTdGF0ZSBpcyBhY3R1YWxseVxuICAgKiBjb21wbGV0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gICAqIEBmaW5hbFxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBzZXRTdGF0ZTogZnVuY3Rpb24ocGFydGlhbFN0YXRlLCBjYWxsYmFjaykge1xuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICB0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnb2JqZWN0JyB8fCBwYXJ0aWFsU3RhdGUgPT0gbnVsbCxcbiAgICAgICdzZXRTdGF0ZSguLi4pOiB0YWtlcyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzIHRvIHVwZGF0ZS4nXG4gICAgKSA6IGludmFyaWFudCh0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnb2JqZWN0JyB8fCBwYXJ0aWFsU3RhdGUgPT0gbnVsbCkpO1xuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpe1xuICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcoXG4gICAgICAgIHBhcnRpYWxTdGF0ZSAhPSBudWxsLFxuICAgICAgICAnc2V0U3RhdGUoLi4uKTogWW91IHBhc3NlZCBhbiB1bmRlZmluZWQgb3IgbnVsbCBzdGF0ZSBvYmplY3Q7ICcgK1xuICAgICAgICAnaW5zdGVhZCwgdXNlIGZvcmNlVXBkYXRlKCkuJ1xuICAgICAgKSA6IG51bGwpO1xuICAgIH1cbiAgICAvLyBNZXJnZSB3aXRoIGBfcGVuZGluZ1N0YXRlYCBpZiBpdCBleGlzdHMsIG90aGVyd2lzZSB3aXRoIGV4aXN0aW5nIHN0YXRlLlxuICAgIHRoaXMucmVwbGFjZVN0YXRlKFxuICAgICAgbWVyZ2UodGhpcy5fcGVuZGluZ1N0YXRlIHx8IHRoaXMuc3RhdGUsIHBhcnRpYWxTdGF0ZSksXG4gICAgICBjYWxsYmFja1xuICAgICk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyBvciBgc2V0U3RhdGVgIHRvIG11dGF0ZSBzdGF0ZS5cbiAgICogWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICAgKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gICAqIEBmaW5hbFxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICByZXBsYWNlU3RhdGU6IGZ1bmN0aW9uKGNvbXBsZXRlU3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgdmFsaWRhdGVMaWZlQ3ljbGVPblJlcGxhY2VTdGF0ZSh0aGlzKTtcbiAgICB0aGlzLl9wZW5kaW5nU3RhdGUgPSBjb21wbGV0ZVN0YXRlO1xuICAgIGlmICh0aGlzLl9jb21wb3NpdGVMaWZlQ3ljbGVTdGF0ZSAhPT0gQ29tcG9zaXRlTGlmZUN5Y2xlLk1PVU5USU5HKSB7XG4gICAgICAvLyBJZiB3ZSdyZSBpbiBhIGNvbXBvbmVudFdpbGxNb3VudCBoYW5kbGVyLCBkb24ndCBlbnF1ZXVlIGEgcmVyZW5kZXJcbiAgICAgIC8vIGJlY2F1c2UgUmVhY3RVcGRhdGVzIGFzc3VtZXMgd2UncmUgaW4gYSBicm93c2VyIGNvbnRleHQgKHdoaWNoIGlzIHdyb25nXG4gICAgICAvLyBmb3Igc2VydmVyIHJlbmRlcmluZykgYW5kIHdlJ3JlIGFib3V0IHRvIGRvIGEgcmVuZGVyIGFueXdheS5cbiAgICAgIC8vIFRPRE86IFRoZSBjYWxsYmFjayBoZXJlIGlzIGlnbm9yZWQgd2hlbiBzZXRTdGF0ZSBpcyBjYWxsZWQgZnJvbVxuICAgICAgLy8gY29tcG9uZW50V2lsbE1vdW50LiBFaXRoZXIgZml4IGl0IG9yIGRpc2FsbG93IGRvaW5nIHNvIGNvbXBsZXRlbHkgaW5cbiAgICAgIC8vIGZhdm9yIG9mIGdldEluaXRpYWxTdGF0ZS5cbiAgICAgIFJlYWN0VXBkYXRlcy5lbnF1ZXVlVXBkYXRlKHRoaXMsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbHRlcnMgdGhlIGNvbnRleHQgb2JqZWN0IHRvIG9ubHkgY29udGFpbiBrZXlzIHNwZWNpZmllZCBpblxuICAgKiBgY29udGV4dFR5cGVzYCwgYW5kIGFzc2VydHMgdGhhdCB0aGV5IGFyZSB2YWxpZC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybiB7P29iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wcm9jZXNzQ29udGV4dDogZnVuY3Rpb24oY29udGV4dCkge1xuICAgIHZhciBtYXNrZWRDb250ZXh0ID0gbnVsbDtcbiAgICB2YXIgY29udGV4dFR5cGVzID0gdGhpcy5jb25zdHJ1Y3Rvci5jb250ZXh0VHlwZXM7XG4gICAgaWYgKGNvbnRleHRUeXBlcykge1xuICAgICAgbWFza2VkQ29udGV4dCA9IHt9O1xuICAgICAgZm9yICh2YXIgY29udGV4dE5hbWUgaW4gY29udGV4dFR5cGVzKSB7XG4gICAgICAgIG1hc2tlZENvbnRleHRbY29udGV4dE5hbWVdID0gY29udGV4dFtjb250ZXh0TmFtZV07XG4gICAgICB9XG4gICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrUHJvcFR5cGVzKFxuICAgICAgICAgIGNvbnRleHRUeXBlcyxcbiAgICAgICAgICBtYXNrZWRDb250ZXh0LFxuICAgICAgICAgIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMuY29udGV4dFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFza2VkQ29udGV4dDtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGN1cnJlbnRDb250ZXh0XG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wcm9jZXNzQ2hpbGRDb250ZXh0OiBmdW5jdGlvbihjdXJyZW50Q29udGV4dCkge1xuICAgIHZhciBjaGlsZENvbnRleHQgPSB0aGlzLmdldENoaWxkQ29udGV4dCAmJiB0aGlzLmdldENoaWxkQ29udGV4dCgpO1xuICAgIHZhciBkaXNwbGF5TmFtZSA9IHRoaXMuY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JztcbiAgICBpZiAoY2hpbGRDb250ZXh0KSB7XG4gICAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgICB0eXBlb2YgdGhpcy5jb25zdHJ1Y3Rvci5jaGlsZENvbnRleHRUeXBlcyA9PT0gJ29iamVjdCcsXG4gICAgICAgICclcy5nZXRDaGlsZENvbnRleHQoKTogY2hpbGRDb250ZXh0VHlwZXMgbXVzdCBiZSBkZWZpbmVkIGluIG9yZGVyIHRvICcgK1xuICAgICAgICAndXNlIGdldENoaWxkQ29udGV4dCgpLicsXG4gICAgICAgIGRpc3BsYXlOYW1lXG4gICAgICApIDogaW52YXJpYW50KHR5cGVvZiB0aGlzLmNvbnN0cnVjdG9yLmNoaWxkQ29udGV4dFR5cGVzID09PSAnb2JqZWN0JykpO1xuICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgICB0aGlzLl9jaGVja1Byb3BUeXBlcyhcbiAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLmNoaWxkQ29udGV4dFR5cGVzLFxuICAgICAgICAgIGNoaWxkQ29udGV4dCxcbiAgICAgICAgICBSZWFjdFByb3BUeXBlTG9jYXRpb25zLmNoaWxkQ29udGV4dFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgbmFtZSBpbiBjaGlsZENvbnRleHQpIHtcbiAgICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICAgICBuYW1lIGluIHRoaXMuY29uc3RydWN0b3IuY2hpbGRDb250ZXh0VHlwZXMsXG4gICAgICAgICAgJyVzLmdldENoaWxkQ29udGV4dCgpOiBrZXkgXCIlc1wiIGlzIG5vdCBkZWZpbmVkIGluIGNoaWxkQ29udGV4dFR5cGVzLicsXG4gICAgICAgICAgZGlzcGxheU5hbWUsXG4gICAgICAgICAgbmFtZVxuICAgICAgICApIDogaW52YXJpYW50KG5hbWUgaW4gdGhpcy5jb25zdHJ1Y3Rvci5jaGlsZENvbnRleHRUeXBlcykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1lcmdlKGN1cnJlbnRDb250ZXh0LCBjaGlsZENvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gY3VycmVudENvbnRleHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFByb2Nlc3NlcyBwcm9wcyBieSBzZXR0aW5nIGRlZmF1bHQgdmFsdWVzIGZvciB1bnNwZWNpZmllZCBwcm9wcyBhbmRcbiAgICogYXNzZXJ0aW5nIHRoYXQgdGhlIHByb3BzIGFyZSB2YWxpZC4gRG9lcyBub3QgbXV0YXRlIGl0cyBhcmd1bWVudDsgcmV0dXJuc1xuICAgKiBhIG5ldyBwcm9wcyBvYmplY3Qgd2l0aCBkZWZhdWx0cyBtZXJnZWQgaW4uXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXdQcm9wc1xuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcHJvY2Vzc1Byb3BzOiBmdW5jdGlvbihuZXdQcm9wcykge1xuICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0aGlzLmNvbnN0cnVjdG9yLmRlZmF1bHRQcm9wcztcbiAgICB2YXIgcHJvcHM7XG4gICAgaWYgKGRlZmF1bHRQcm9wcykge1xuICAgICAgcHJvcHMgPSBtZXJnZShuZXdQcm9wcyk7XG4gICAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9wc1twcm9wTmFtZV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwcm9wcyA9IG5ld1Byb3BzO1xuICAgIH1cbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICB2YXIgcHJvcFR5cGVzID0gdGhpcy5jb25zdHJ1Y3Rvci5wcm9wVHlwZXM7XG4gICAgICBpZiAocHJvcFR5cGVzKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgcHJvcHMsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMucHJvcCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm9wcztcbiAgfSxcblxuICAvKipcbiAgICogQXNzZXJ0IHRoYXQgdGhlIHByb3BzIGFyZSB2YWxpZFxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcFR5cGVzIE1hcCBvZiBwcm9wIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2hlY2tQcm9wVHlwZXM6IGZ1bmN0aW9uKHByb3BUeXBlcywgcHJvcHMsIGxvY2F0aW9uKSB7XG4gICAgLy8gVE9ETzogU3RvcCB2YWxpZGF0aW5nIHByb3AgdHlwZXMgaGVyZSBhbmQgb25seSB1c2UgdGhlIGRlc2NyaXB0b3JcbiAgICAvLyB2YWxpZGF0aW9uLlxuICAgIHZhciBjb21wb25lbnROYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZTtcbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBwcm9wVHlwZXMpIHtcbiAgICAgIGlmIChwcm9wVHlwZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciA9XG4gICAgICAgICAgcHJvcFR5cGVzW3Byb3BOYW1lXShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uKTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAvLyBXZSBtYXkgd2FudCB0byBleHRlbmQgdGhpcyBsb2dpYyBmb3Igc2ltaWxhciBlcnJvcnMgaW5cbiAgICAgICAgICAvLyByZW5kZXJDb21wb25lbnQgY2FsbHMsIHNvIEknbSBhYnN0cmFjdGluZyBpdCBhd2F5IGludG9cbiAgICAgICAgICAvLyBhIGZ1bmN0aW9uIHRvIG1pbmltaXplIHJlZmFjdG9yaW5nIGluIHRoZSBmdXR1cmVcbiAgICAgICAgICB2YXIgYWRkZW5kdW0gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0odGhpcyk7XG4gICAgICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcoZmFsc2UsIGVycm9yLm1lc3NhZ2UgKyBhZGRlbmR1bSkgOiBudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSWYgYW55IG9mIGBfcGVuZGluZ0Rlc2NyaXB0b3JgLCBgX3BlbmRpbmdTdGF0ZWAsIG9yIGBfcGVuZGluZ0ZvcmNlVXBkYXRlYFxuICAgKiBpcyBzZXQsIHVwZGF0ZSB0aGUgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5OiBmdW5jdGlvbih0cmFuc2FjdGlvbikge1xuICAgIHZhciBjb21wb3NpdGVMaWZlQ3ljbGVTdGF0ZSA9IHRoaXMuX2NvbXBvc2l0ZUxpZmVDeWNsZVN0YXRlO1xuICAgIC8vIERvIG5vdCB0cmlnZ2VyIGEgc3RhdGUgdHJhbnNpdGlvbiBpZiB3ZSBhcmUgaW4gdGhlIG1pZGRsZSBvZiBtb3VudGluZyBvclxuICAgIC8vIHJlY2VpdmluZyBwcm9wcyBiZWNhdXNlIGJvdGggb2YgdGhvc2Ugd2lsbCBhbHJlYWR5IGJlIGRvaW5nIHRoaXMuXG4gICAgaWYgKGNvbXBvc2l0ZUxpZmVDeWNsZVN0YXRlID09PSBDb21wb3NpdGVMaWZlQ3ljbGUuTU9VTlRJTkcgfHxcbiAgICAgICAgY29tcG9zaXRlTGlmZUN5Y2xlU3RhdGUgPT09IENvbXBvc2l0ZUxpZmVDeWNsZS5SRUNFSVZJTkdfUFJPUFMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcGVuZGluZ0Rlc2NyaXB0b3IgPT0gbnVsbCAmJlxuICAgICAgICB0aGlzLl9wZW5kaW5nU3RhdGUgPT0gbnVsbCAmJlxuICAgICAgICAhdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5leHRDb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuICAgIHZhciBuZXh0UHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBuZXh0RGVzY3JpcHRvciA9IHRoaXMuX2Rlc2NyaXB0b3I7XG4gICAgaWYgKHRoaXMuX3BlbmRpbmdEZXNjcmlwdG9yICE9IG51bGwpIHtcbiAgICAgIG5leHREZXNjcmlwdG9yID0gdGhpcy5fcGVuZGluZ0Rlc2NyaXB0b3I7XG4gICAgICBuZXh0Q29udGV4dCA9IHRoaXMuX3Byb2Nlc3NDb250ZXh0KG5leHREZXNjcmlwdG9yLl9jb250ZXh0KTtcbiAgICAgIG5leHRQcm9wcyA9IHRoaXMuX3Byb2Nlc3NQcm9wcyhuZXh0RGVzY3JpcHRvci5wcm9wcyk7XG4gICAgICB0aGlzLl9wZW5kaW5nRGVzY3JpcHRvciA9IG51bGw7XG5cbiAgICAgIHRoaXMuX2NvbXBvc2l0ZUxpZmVDeWNsZVN0YXRlID0gQ29tcG9zaXRlTGlmZUN5Y2xlLlJFQ0VJVklOR19QUk9QUztcbiAgICAgIGlmICh0aGlzLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcywgbmV4dENvbnRleHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX2NvbXBvc2l0ZUxpZmVDeWNsZVN0YXRlID0gQ29tcG9zaXRlTGlmZUN5Y2xlLlJFQ0VJVklOR19TVEFURTtcblxuICAgIHZhciBuZXh0U3RhdGUgPSB0aGlzLl9wZW5kaW5nU3RhdGUgfHwgdGhpcy5zdGF0ZTtcbiAgICB0aGlzLl9wZW5kaW5nU3RhdGUgPSBudWxsO1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhciBzaG91bGRVcGRhdGUgPVxuICAgICAgICB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUgfHxcbiAgICAgICAgIXRoaXMuc2hvdWxkQ29tcG9uZW50VXBkYXRlIHx8XG4gICAgICAgIHRoaXMuc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCk7XG5cbiAgICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzaG91bGRVcGRhdGUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAodGhpcy5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSArXG4gICAgICAgICAgICAnLnNob3VsZENvbXBvbmVudFVwZGF0ZSgpOiBSZXR1cm5lZCB1bmRlZmluZWQgaW5zdGVhZCBvZiBhICcgK1xuICAgICAgICAgICAgJ2Jvb2xlYW4gdmFsdWUuIE1ha2Ugc3VyZSB0byByZXR1cm4gdHJ1ZSBvciBmYWxzZS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdGb3JjZVVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICAvLyBXaWxsIHNldCBgdGhpcy5wcm9wc2AsIGB0aGlzLnN0YXRlYCBhbmQgYHRoaXMuY29udGV4dGAuXG4gICAgICAgIHRoaXMuX3BlcmZvcm1Db21wb25lbnRVcGRhdGUoXG4gICAgICAgICAgbmV4dERlc2NyaXB0b3IsXG4gICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgIG5leHRTdGF0ZSxcbiAgICAgICAgICBuZXh0Q29udGV4dCxcbiAgICAgICAgICB0cmFuc2FjdGlvblxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgaXQncyBkZXRlcm1pbmVkIHRoYXQgYSBjb21wb25lbnQgc2hvdWxkIG5vdCB1cGRhdGUsIHdlIHN0aWxsIHdhbnRcbiAgICAgICAgLy8gdG8gc2V0IHByb3BzIGFuZCBzdGF0ZS5cbiAgICAgICAgdGhpcy5fZGVzY3JpcHRvciA9IG5leHREZXNjcmlwdG9yO1xuICAgICAgICB0aGlzLnByb3BzID0gbmV4dFByb3BzO1xuICAgICAgICB0aGlzLnN0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBuZXh0Q29udGV4dDtcblxuICAgICAgICAvLyBPd25lciBjYW5ub3QgY2hhbmdlIGJlY2F1c2Ugc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQgZG9lc24ndCBhbGxvd1xuICAgICAgICAvLyBpdC4gVE9ETzogUmVtb3ZlIHRoaXMuX293bmVyIGNvbXBsZXRlbHkuXG4gICAgICAgIHRoaXMuX293bmVyID0gbmV4dERlc2NyaXB0b3IuX293bmVyO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLl9jb21wb3NpdGVMaWZlQ3ljbGVTdGF0ZSA9IG51bGw7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBNZXJnZXMgbmV3IHByb3BzIGFuZCBzdGF0ZSwgbm90aWZpZXMgZGVsZWdhdGUgbWV0aG9kcyBvZiB1cGRhdGUgYW5kXG4gICAqIHBlcmZvcm1zIHVwZGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdERlc2NyaXB0b3J9IG5leHREZXNjcmlwdG9yIE5leHQgZGVzY3JpcHRvclxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzIE5leHQgcHVibGljIG9iamVjdCB0byBzZXQgYXMgcHJvcGVydGllcy5cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0U3RhdGUgTmV4dCBvYmplY3QgdG8gc2V0IGFzIHN0YXRlLlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRDb250ZXh0IE5leHQgcHVibGljIG9iamVjdCB0byBzZXQgYXMgY29udGV4dC5cbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3BlcmZvcm1Db21wb25lbnRVcGRhdGU6IGZ1bmN0aW9uKFxuICAgIG5leHREZXNjcmlwdG9yLFxuICAgIG5leHRQcm9wcyxcbiAgICBuZXh0U3RhdGUsXG4gICAgbmV4dENvbnRleHQsXG4gICAgdHJhbnNhY3Rpb25cbiAgKSB7XG4gICAgdmFyIHByZXZEZXNjcmlwdG9yID0gdGhpcy5fZGVzY3JpcHRvcjtcbiAgICB2YXIgcHJldlByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgcHJldlN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICB2YXIgcHJldkNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cbiAgICBpZiAodGhpcy5jb21wb25lbnRXaWxsVXBkYXRlKSB7XG4gICAgICB0aGlzLmNvbXBvbmVudFdpbGxVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0KTtcbiAgICB9XG5cbiAgICB0aGlzLl9kZXNjcmlwdG9yID0gbmV4dERlc2NyaXB0b3I7XG4gICAgdGhpcy5wcm9wcyA9IG5leHRQcm9wcztcbiAgICB0aGlzLnN0YXRlID0gbmV4dFN0YXRlO1xuICAgIHRoaXMuY29udGV4dCA9IG5leHRDb250ZXh0O1xuXG4gICAgLy8gT3duZXIgY2Fubm90IGNoYW5nZSBiZWNhdXNlIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50IGRvZXNuJ3QgYWxsb3dcbiAgICAvLyBpdC4gVE9ETzogUmVtb3ZlIHRoaXMuX293bmVyIGNvbXBsZXRlbHkuXG4gICAgdGhpcy5fb3duZXIgPSBuZXh0RGVzY3JpcHRvci5fb3duZXI7XG5cbiAgICB0aGlzLnVwZGF0ZUNvbXBvbmVudChcbiAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgcHJldkRlc2NyaXB0b3JcbiAgICApO1xuXG4gICAgaWYgKHRoaXMuY29tcG9uZW50RGlkVXBkYXRlKSB7XG4gICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKFxuICAgICAgICB0aGlzLmNvbXBvbmVudERpZFVwZGF0ZS5iaW5kKHRoaXMsIHByZXZQcm9wcywgcHJldlN0YXRlLCBwcmV2Q29udGV4dCksXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfVxuICB9LFxuXG4gIHJlY2VpdmVDb21wb25lbnQ6IGZ1bmN0aW9uKG5leHREZXNjcmlwdG9yLCB0cmFuc2FjdGlvbikge1xuICAgIGlmIChuZXh0RGVzY3JpcHRvciA9PT0gdGhpcy5fZGVzY3JpcHRvciAmJlxuICAgICAgICBuZXh0RGVzY3JpcHRvci5fb3duZXIgIT0gbnVsbCkge1xuICAgICAgLy8gU2luY2UgZGVzY3JpcHRvcnMgYXJlIGltbXV0YWJsZSBhZnRlciB0aGUgb3duZXIgaXMgcmVuZGVyZWQsXG4gICAgICAvLyB3ZSBjYW4gZG8gYSBjaGVhcCBpZGVudGl0eSBjb21wYXJlIGhlcmUgdG8gZGV0ZXJtaW5lIGlmIHRoaXMgaXMgYVxuICAgICAgLy8gc3VwZXJmbHVvdXMgcmVjb25jaWxlLiBJdCdzIHBvc3NpYmxlIGZvciBzdGF0ZSB0byBiZSBtdXRhYmxlIGJ1dCBzdWNoXG4gICAgICAvLyBjaGFuZ2Ugc2hvdWxkIHRyaWdnZXIgYW4gdXBkYXRlIG9mIHRoZSBvd25lciB3aGljaCB3b3VsZCByZWNyZWF0ZVxuICAgICAgLy8gdGhlIGRlc2NyaXB0b3IuIFdlIGV4cGxpY2l0bHkgY2hlY2sgZm9yIHRoZSBleGlzdGVuY2Ugb2YgYW4gb3duZXIgc2luY2VcbiAgICAgIC8vIGl0J3MgcG9zc2libGUgZm9yIGEgZGVzY3JpcHRvciBjcmVhdGVkIG91dHNpZGUgYSBjb21wb3NpdGUgdG8gYmVcbiAgICAgIC8vIGRlZXBseSBtdXRhdGVkIGFuZCByZXVzZWQuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgUmVhY3RDb21wb25lbnQuTWl4aW4ucmVjZWl2ZUNvbXBvbmVudC5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgIG5leHREZXNjcmlwdG9yLFxuICAgICAgdHJhbnNhY3Rpb25cbiAgICApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBjb21wb25lbnQncyBjdXJyZW50bHkgbW91bnRlZCBET00gcmVwcmVzZW50YXRpb24uXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHRoaXMgaW1wbGVtZW50cyBSZWFjdCdzIHJlbmRlcmluZyBhbmQgcmVjb25jaWxpYXRpb24gYWxnb3JpdGhtLlxuICAgKiBTb3BoaXN0aWNhdGVkIGNsaWVudHMgbWF5IHdpc2ggdG8gb3ZlcnJpZGUgdGhpcy5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1JlYWN0RGVzY3JpcHRvcn0gcHJldkRlc2NyaXB0b3JcbiAgICogQGludGVybmFsXG4gICAqIEBvdmVycmlkYWJsZVxuICAgKi9cbiAgdXBkYXRlQ29tcG9uZW50OiBSZWFjdFBlcmYubWVhc3VyZShcbiAgICAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnLFxuICAgICd1cGRhdGVDb21wb25lbnQnLFxuICAgIGZ1bmN0aW9uKHRyYW5zYWN0aW9uLCBwcmV2UGFyZW50RGVzY3JpcHRvcikge1xuICAgICAgUmVhY3RDb21wb25lbnQuTWl4aW4udXBkYXRlQ29tcG9uZW50LmNhbGwoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICBwcmV2UGFyZW50RGVzY3JpcHRvclxuICAgICAgKTtcblxuICAgICAgdmFyIHByZXZDb21wb25lbnRJbnN0YW5jZSA9IHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50O1xuICAgICAgdmFyIHByZXZEZXNjcmlwdG9yID0gcHJldkNvbXBvbmVudEluc3RhbmNlLl9kZXNjcmlwdG9yO1xuICAgICAgdmFyIG5leHREZXNjcmlwdG9yID0gdGhpcy5fcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KCk7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQocHJldkRlc2NyaXB0b3IsIG5leHREZXNjcmlwdG9yKSkge1xuICAgICAgICBwcmV2Q29tcG9uZW50SW5zdGFuY2UucmVjZWl2ZUNvbXBvbmVudChuZXh0RGVzY3JpcHRvciwgdHJhbnNhY3Rpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhlc2UgdHdvIElEcyBhcmUgYWN0dWFsbHkgdGhlIHNhbWUhIEJ1dCBub3RoaW5nIHNob3VsZCByZWx5IG9uIHRoYXQuXG4gICAgICAgIHZhciB0aGlzSUQgPSB0aGlzLl9yb290Tm9kZUlEO1xuICAgICAgICB2YXIgcHJldkNvbXBvbmVudElEID0gcHJldkNvbXBvbmVudEluc3RhbmNlLl9yb290Tm9kZUlEO1xuICAgICAgICBwcmV2Q29tcG9uZW50SW5zdGFuY2UudW5tb3VudENvbXBvbmVudCgpO1xuICAgICAgICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudCA9IGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQobmV4dERlc2NyaXB0b3IpO1xuICAgICAgICB2YXIgbmV4dE1hcmt1cCA9IHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50Lm1vdW50Q29tcG9uZW50KFxuICAgICAgICAgIHRoaXNJRCxcbiAgICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgICB0aGlzLl9tb3VudERlcHRoICsgMVxuICAgICAgICApO1xuICAgICAgICBSZWFjdENvbXBvbmVudC5CYWNrZW5kSURPcGVyYXRpb25zLmRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRChcbiAgICAgICAgICBwcmV2Q29tcG9uZW50SUQsXG4gICAgICAgICAgbmV4dE1hcmt1cFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgKSxcblxuICAvKipcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZFVwZGF0ZUNvbXBvbmVudGAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHVwZGF0ZSBpcyBjb21wbGV0ZS5cbiAgICogQGZpbmFsXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGZvcmNlVXBkYXRlOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHZhciBjb21wb3NpdGVMaWZlQ3ljbGVTdGF0ZSA9IHRoaXMuX2NvbXBvc2l0ZUxpZmVDeWNsZVN0YXRlO1xuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICB0aGlzLmlzTW91bnRlZCgpIHx8XG4gICAgICAgIGNvbXBvc2l0ZUxpZmVDeWNsZVN0YXRlID09PSBDb21wb3NpdGVMaWZlQ3ljbGUuTU9VTlRJTkcsXG4gICAgICAnZm9yY2VVcGRhdGUoLi4uKTogQ2FuIG9ubHkgZm9yY2UgYW4gdXBkYXRlIG9uIG1vdW50ZWQgb3IgbW91bnRpbmcgJyArXG4gICAgICAgICdjb21wb25lbnRzLidcbiAgICApIDogaW52YXJpYW50KHRoaXMuaXNNb3VudGVkKCkgfHxcbiAgICAgIGNvbXBvc2l0ZUxpZmVDeWNsZVN0YXRlID09PSBDb21wb3NpdGVMaWZlQ3ljbGUuTU9VTlRJTkcpKTtcbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgY29tcG9zaXRlTGlmZUN5Y2xlU3RhdGUgIT09IENvbXBvc2l0ZUxpZmVDeWNsZS5SRUNFSVZJTkdfU1RBVEUgJiZcbiAgICAgIGNvbXBvc2l0ZUxpZmVDeWNsZVN0YXRlICE9PSBDb21wb3NpdGVMaWZlQ3ljbGUuVU5NT1VOVElORyxcbiAgICAgICdmb3JjZVVwZGF0ZSguLi4pOiBDYW5ub3QgZm9yY2UgYW4gdXBkYXRlIHdoaWxlIHVubW91bnRpbmcgY29tcG9uZW50ICcgK1xuICAgICAgJ29yIGR1cmluZyBhbiBleGlzdGluZyBzdGF0ZSB0cmFuc2l0aW9uIChzdWNoIGFzIHdpdGhpbiBgcmVuZGVyYCkuJ1xuICAgICkgOiBpbnZhcmlhbnQoY29tcG9zaXRlTGlmZUN5Y2xlU3RhdGUgIT09IENvbXBvc2l0ZUxpZmVDeWNsZS5SRUNFSVZJTkdfU1RBVEUgJiZcbiAgICBjb21wb3NpdGVMaWZlQ3ljbGVTdGF0ZSAhPT0gQ29tcG9zaXRlTGlmZUN5Y2xlLlVOTU9VTlRJTkcpKTtcbiAgICB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgIFJlYWN0VXBkYXRlcy5lbnF1ZXVlVXBkYXRlKHRoaXMsIGNhbGxiYWNrKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQ6IFJlYWN0UGVyZi5tZWFzdXJlKFxuICAgICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcsXG4gICAgJ19yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQnLFxuICAgIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlbmRlcmVkQ29tcG9uZW50O1xuICAgICAgdmFyIHByZXZpb3VzQ29udGV4dCA9IFJlYWN0Q29udGV4dC5jdXJyZW50O1xuICAgICAgUmVhY3RDb250ZXh0LmN1cnJlbnQgPSB0aGlzLl9wcm9jZXNzQ2hpbGRDb250ZXh0KFxuICAgICAgICB0aGlzLl9kZXNjcmlwdG9yLl9jb250ZXh0XG4gICAgICApO1xuICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHRoaXM7XG4gICAgICB0cnkge1xuICAgICAgICByZW5kZXJlZENvbXBvbmVudCA9IHRoaXMucmVuZGVyKCk7XG4gICAgICAgIGlmIChyZW5kZXJlZENvbXBvbmVudCA9PT0gbnVsbCB8fCByZW5kZXJlZENvbXBvbmVudCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZW5kZXJlZENvbXBvbmVudCA9IFJlYWN0RW1wdHlDb21wb25lbnQuZ2V0RW1wdHlDb21wb25lbnQoKTtcbiAgICAgICAgICBSZWFjdEVtcHR5Q29tcG9uZW50LnJlZ2lzdGVyTnVsbENvbXBvbmVudElEKHRoaXMuX3Jvb3ROb2RlSUQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIFJlYWN0RW1wdHlDb21wb25lbnQuZGVyZWdpc3Rlck51bGxDb21wb25lbnRJRCh0aGlzLl9yb290Tm9kZUlEKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDb250ZXh0LmN1cnJlbnQgPSBwcmV2aW91c0NvbnRleHQ7XG4gICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICAgUmVhY3REZXNjcmlwdG9yLmlzVmFsaWREZXNjcmlwdG9yKHJlbmRlcmVkQ29tcG9uZW50KSxcbiAgICAgICAgJyVzLnJlbmRlcigpOiBBIHZhbGlkIFJlYWN0Q29tcG9uZW50IG11c3QgYmUgcmV0dXJuZWQuIFlvdSBtYXkgaGF2ZSAnICtcbiAgICAgICAgICAncmV0dXJuZWQgdW5kZWZpbmVkLCBhbiBhcnJheSBvciBzb21lIG90aGVyIGludmFsaWQgb2JqZWN0LicsXG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50J1xuICAgICAgKSA6IGludmFyaWFudChSZWFjdERlc2NyaXB0b3IuaXNWYWxpZERlc2NyaXB0b3IocmVuZGVyZWRDb21wb25lbnQpKSk7XG4gICAgICByZXR1cm4gcmVuZGVyZWRDb21wb25lbnQ7XG4gICAgfVxuICApLFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2JpbmRBdXRvQmluZE1ldGhvZHM6IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGF1dG9CaW5kS2V5IGluIHRoaXMuX19yZWFjdEF1dG9CaW5kTWFwKSB7XG4gICAgICBpZiAoIXRoaXMuX19yZWFjdEF1dG9CaW5kTWFwLmhhc093blByb3BlcnR5KGF1dG9CaW5kS2V5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBtZXRob2QgPSB0aGlzLl9fcmVhY3RBdXRvQmluZE1hcFthdXRvQmluZEtleV07XG4gICAgICB0aGlzW2F1dG9CaW5kS2V5XSA9IHRoaXMuX2JpbmRBdXRvQmluZE1ldGhvZChSZWFjdEVycm9yVXRpbHMuZ3VhcmQoXG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSArICcuJyArIGF1dG9CaW5kS2V5XG4gICAgICApKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEJpbmRzIGEgbWV0aG9kIHRvIHRoZSBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG1ldGhvZCBNZXRob2QgdG8gYmUgYm91bmQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYmluZEF1dG9CaW5kTWV0aG9kOiBmdW5jdGlvbihtZXRob2QpIHtcbiAgICB2YXIgY29tcG9uZW50ID0gdGhpcztcbiAgICB2YXIgYm91bmRNZXRob2QgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBtZXRob2QuYXBwbHkoY29tcG9uZW50LCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQ29udGV4dCA9IGNvbXBvbmVudDtcbiAgICAgIGJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZE1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZEFyZ3VtZW50cyA9IG51bGw7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudC5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZTtcbiAgICAgIHZhciBfYmluZCA9IGJvdW5kTWV0aG9kLmJpbmQ7XG4gICAgICBib3VuZE1ldGhvZC5iaW5kID0gZnVuY3Rpb24obmV3VGhpcyApIHt2YXIgYXJncz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSk7XG4gICAgICAgIC8vIFVzZXIgaXMgdHJ5aW5nIHRvIGJpbmQoKSBhbiBhdXRvYm91bmQgbWV0aG9kOyB3ZSBlZmZlY3RpdmVseSB3aWxsXG4gICAgICAgIC8vIGlnbm9yZSB0aGUgdmFsdWUgb2YgXCJ0aGlzXCIgdGhhdCB0aGUgdXNlciBpcyB0cnlpbmcgdG8gdXNlLCBzb1xuICAgICAgICAvLyBsZXQncyB3YXJuLlxuICAgICAgICBpZiAobmV3VGhpcyAhPT0gY29tcG9uZW50ICYmIG5ld1RoaXMgIT09IG51bGwpIHtcbiAgICAgICAgICBtb25pdG9yQ29kZVVzZSgncmVhY3RfYmluZF93YXJuaW5nJywgeyBjb21wb25lbnQ6IGNvbXBvbmVudE5hbWUgfSk7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgJ2JpbmQoKTogUmVhY3QgY29tcG9uZW50IG1ldGhvZHMgbWF5IG9ubHkgYmUgYm91bmQgdG8gdGhlICcgK1xuICAgICAgICAgICAgJ2NvbXBvbmVudCBpbnN0YW5jZS4gU2VlICcgKyBjb21wb25lbnROYW1lXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmICghYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICBtb25pdG9yQ29kZVVzZSgncmVhY3RfYmluZF93YXJuaW5nJywgeyBjb21wb25lbnQ6IGNvbXBvbmVudE5hbWUgfSk7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgJ2JpbmQoKTogWW91IGFyZSBiaW5kaW5nIGEgY29tcG9uZW50IG1ldGhvZCB0byB0aGUgY29tcG9uZW50LiAnICtcbiAgICAgICAgICAgICdSZWFjdCBkb2VzIHRoaXMgZm9yIHlvdSBhdXRvbWF0aWNhbGx5IGluIGEgaGlnaC1wZXJmb3JtYW5jZSAnICtcbiAgICAgICAgICAgICd3YXksIHNvIHlvdSBjYW4gc2FmZWx5IHJlbW92ZSB0aGlzIGNhbGwuIFNlZSAnICsgY29tcG9uZW50TmFtZVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIGJvdW5kTWV0aG9kO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZWJvdW5kTWV0aG9kID0gX2JpbmQuYXBwbHkoYm91bmRNZXRob2QsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJlYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQ29udGV4dCA9IGNvbXBvbmVudDtcbiAgICAgICAgcmVib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRNZXRob2QgPSBtZXRob2Q7XG4gICAgICAgIHJlYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQXJndW1lbnRzID0gYXJncztcbiAgICAgICAgcmV0dXJuIHJlYm91bmRNZXRob2Q7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gYm91bmRNZXRob2Q7XG4gIH1cbn07XG5cbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudEJhc2UgPSBmdW5jdGlvbigpIHt9O1xubWl4SW50byhSZWFjdENvbXBvc2l0ZUNvbXBvbmVudEJhc2UsIFJlYWN0Q29tcG9uZW50Lk1peGluKTtcbm1peEludG8oUmVhY3RDb21wb3NpdGVDb21wb25lbnRCYXNlLCBSZWFjdE93bmVyLk1peGluKTtcbm1peEludG8oUmVhY3RDb21wb3NpdGVDb21wb25lbnRCYXNlLCBSZWFjdFByb3BUcmFuc2ZlcmVyLk1peGluKTtcbm1peEludG8oUmVhY3RDb21wb3NpdGVDb21wb25lbnRCYXNlLCBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudE1peGluKTtcblxuLyoqXG4gKiBNb2R1bGUgZm9yIGNyZWF0aW5nIGNvbXBvc2l0ZSBjb21wb25lbnRzLlxuICpcbiAqIEBjbGFzcyBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudFxuICogQGV4dGVuZHMgUmVhY3RDb21wb25lbnRcbiAqIEBleHRlbmRzIFJlYWN0T3duZXJcbiAqIEBleHRlbmRzIFJlYWN0UHJvcFRyYW5zZmVyZXJcbiAqL1xudmFyIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50ID0ge1xuXG4gIExpZmVDeWNsZTogQ29tcG9zaXRlTGlmZUN5Y2xlLFxuXG4gIEJhc2U6IFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50QmFzZSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNvbXBvc2l0ZSBjb21wb25lbnQgY2xhc3MgZ2l2ZW4gYSBjbGFzcyBzcGVjaWZpY2F0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gc3BlYyBDbGFzcyBzcGVjaWZpY2F0aW9uICh3aGljaCBtdXN0IGRlZmluZSBgcmVuZGVyYCkuXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9ufSBDb21wb25lbnQgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNyZWF0ZUNsYXNzOiBmdW5jdGlvbihzcGVjKSB7XG4gICAgdmFyIENvbnN0cnVjdG9yID0gZnVuY3Rpb24ocHJvcHMsIG93bmVyKSB7XG4gICAgICB0aGlzLmNvbnN0cnVjdChwcm9wcywgb3duZXIpO1xuICAgIH07XG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gbmV3IFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50QmFzZSgpO1xuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yO1xuXG4gICAgaW5qZWN0ZWRNaXhpbnMuZm9yRWFjaChcbiAgICAgIG1peFNwZWNJbnRvQ29tcG9uZW50LmJpbmQobnVsbCwgQ29uc3RydWN0b3IpXG4gICAgKTtcblxuICAgIG1peFNwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzcGVjKTtcblxuICAgIC8vIEluaXRpYWxpemUgdGhlIGRlZmF1bHRQcm9wcyBwcm9wZXJ0eSBhZnRlciBhbGwgbWl4aW5zIGhhdmUgYmVlbiBtZXJnZWRcbiAgICBpZiAoQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKSB7XG4gICAgICBDb25zdHJ1Y3Rvci5kZWZhdWx0UHJvcHMgPSBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMoKTtcbiAgICB9XG5cbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgQ29uc3RydWN0b3IucHJvdG90eXBlLnJlbmRlcixcbiAgICAgICdjcmVhdGVDbGFzcyguLi4pOiBDbGFzcyBzcGVjaWZpY2F0aW9uIG11c3QgaW1wbGVtZW50IGEgYHJlbmRlcmAgbWV0aG9kLidcbiAgICApIDogaW52YXJpYW50KENvbnN0cnVjdG9yLnByb3RvdHlwZS5yZW5kZXIpKTtcblxuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgIGlmIChDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29tcG9uZW50U2hvdWxkVXBkYXRlKSB7XG4gICAgICAgIG1vbml0b3JDb2RlVXNlKFxuICAgICAgICAgICdyZWFjdF9jb21wb25lbnRfc2hvdWxkX3VwZGF0ZV93YXJuaW5nJyxcbiAgICAgICAgICB7IGNvbXBvbmVudDogc3BlYy5kaXNwbGF5TmFtZSB9XG4gICAgICAgICk7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAoc3BlYy5kaXNwbGF5TmFtZSB8fCAnQSBjb21wb25lbnQnKSArICcgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICtcbiAgICAgICAgICAnY29tcG9uZW50U2hvdWxkVXBkYXRlKCkuIERpZCB5b3UgbWVhbiBzaG91bGRDb21wb25lbnRVcGRhdGUoKT8gJyArXG4gICAgICAgICAgJ1RoZSBuYW1lIGlzIHBocmFzZWQgYXMgYSBxdWVzdGlvbiBiZWNhdXNlIHRoZSBmdW5jdGlvbiBpcyAnICtcbiAgICAgICAgICAnZXhwZWN0ZWQgdG8gcmV0dXJuIGEgdmFsdWUuJ1xuICAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZWR1Y2UgdGltZSBzcGVudCBkb2luZyBsb29rdXBzIGJ5IHNldHRpbmcgdGhlc2Ugb24gdGhlIHByb3RvdHlwZS5cbiAgICBmb3IgKHZhciBtZXRob2ROYW1lIGluIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50SW50ZXJmYWNlKSB7XG4gICAgICBpZiAoIUNvbnN0cnVjdG9yLnByb3RvdHlwZVttZXRob2ROYW1lXSkge1xuICAgICAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkZXNjcmlwdG9yRmFjdG9yeSA9IFJlYWN0RGVzY3JpcHRvci5jcmVhdGVGYWN0b3J5KENvbnN0cnVjdG9yKTtcblxuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgIHJldHVybiBSZWFjdERlc2NyaXB0b3JWYWxpZGF0b3IuY3JlYXRlRmFjdG9yeShcbiAgICAgICAgZGVzY3JpcHRvckZhY3RvcnksXG4gICAgICAgIENvbnN0cnVjdG9yLnByb3BUeXBlcyxcbiAgICAgICAgQ29uc3RydWN0b3IuY29udGV4dFR5cGVzXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBkZXNjcmlwdG9yRmFjdG9yeTtcbiAgfSxcblxuICBpbmplY3Rpb246IHtcbiAgICBpbmplY3RNaXhpbjogZnVuY3Rpb24obWl4aW4pIHtcbiAgICAgIGluamVjdGVkTWl4aW5zLnB1c2gobWl4aW4pO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudDtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q29udGV4dFxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgbWVyZ2UgPSByZXF1aXJlKFwiLi9tZXJnZVwiKTtcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBjb250ZXh0LlxuICpcbiAqIFRoZSBjb250ZXh0IGlzIGF1dG9tYXRpY2FsbHkgcGFzc2VkIGRvd24gdGhlIGNvbXBvbmVudCBvd25lcnNoaXAgaGllcmFyY2h5XG4gKiBhbmQgaXMgYWNjZXNzaWJsZSB2aWEgYHRoaXMuY29udGV4dGAgb24gUmVhY3RDb21wb3NpdGVDb21wb25lbnRzLlxuICovXG52YXIgUmVhY3RDb250ZXh0ID0ge1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHR5cGUge29iamVjdH1cbiAgICovXG4gIGN1cnJlbnQ6IHt9LFxuXG4gIC8qKlxuICAgKiBUZW1wb3JhcmlseSBleHRlbmRzIHRoZSBjdXJyZW50IGNvbnRleHQgd2hpbGUgZXhlY3V0aW5nIHNjb3BlZENhbGxiYWNrLlxuICAgKlxuICAgKiBBIHR5cGljYWwgdXNlIGNhc2UgbWlnaHQgbG9vayBsaWtlXG4gICAqXG4gICAqICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgKiAgICB2YXIgY2hpbGRyZW4gPSBSZWFjdENvbnRleHQud2l0aENvbnRleHQoe2ZvbzogJ2Zvbyd9ICgpID0+IChcbiAgICpcbiAgICogICAgKSk7XG4gICAqICAgIHJldHVybiA8ZGl2PntjaGlsZHJlbn08L2Rpdj47XG4gICAqICB9XG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXdDb250ZXh0IE5ldyBjb250ZXh0IHRvIG1lcmdlIGludG8gdGhlIGV4aXN0aW5nIGNvbnRleHRcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gc2NvcGVkQ2FsbGJhY2sgQ2FsbGJhY2sgdG8gcnVuIHdpdGggdGhlIG5ldyBjb250ZXh0XG4gICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fGFycmF5PFJlYWN0Q29tcG9uZW50Pn1cbiAgICovXG4gIHdpdGhDb250ZXh0OiBmdW5jdGlvbihuZXdDb250ZXh0LCBzY29wZWRDYWxsYmFjaykge1xuICAgIHZhciByZXN1bHQ7XG4gICAgdmFyIHByZXZpb3VzQ29udGV4dCA9IFJlYWN0Q29udGV4dC5jdXJyZW50O1xuICAgIFJlYWN0Q29udGV4dC5jdXJyZW50ID0gbWVyZ2UocHJldmlvdXNDb250ZXh0LCBuZXdDb250ZXh0KTtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gc2NvcGVkQ2FsbGJhY2soKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgUmVhY3RDb250ZXh0LmN1cnJlbnQgPSBwcmV2aW91c0NvbnRleHQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbnRleHQ7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDdXJyZW50T3duZXJcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBvd25lci5cbiAqXG4gKiBUaGUgY3VycmVudCBvd25lciBpcyB0aGUgY29tcG9uZW50IHdobyBzaG91bGQgb3duIGFueSBjb21wb25lbnRzIHRoYXQgYXJlXG4gKiBjdXJyZW50bHkgYmVpbmcgY29uc3RydWN0ZWQuXG4gKlxuICogVGhlIGRlcHRoIGluZGljYXRlIGhvdyBtYW55IGNvbXBvc2l0ZSBjb21wb25lbnRzIGFyZSBhYm92ZSB0aGlzIHJlbmRlciBsZXZlbC5cbiAqL1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0ge1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHR5cGUge1JlYWN0Q29tcG9uZW50fVxuICAgKi9cbiAgY3VycmVudDogbnVsbFxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q3VycmVudE93bmVyO1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTVxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIFJlYWN0RGVzY3JpcHRvciA9IHJlcXVpcmUoXCIuL1JlYWN0RGVzY3JpcHRvclwiKTtcbnZhciBSZWFjdERlc2NyaXB0b3JWYWxpZGF0b3IgPSByZXF1aXJlKFwiLi9SZWFjdERlc2NyaXB0b3JWYWxpZGF0b3JcIik7XG52YXIgUmVhY3RET01Db21wb25lbnQgPSByZXF1aXJlKFwiLi9SZWFjdERPTUNvbXBvbmVudFwiKTtcblxudmFyIG1lcmdlSW50byA9IHJlcXVpcmUoXCIuL21lcmdlSW50b1wiKTtcbnZhciBtYXBPYmplY3QgPSByZXF1aXJlKFwiLi9tYXBPYmplY3RcIik7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBSZWFjdCBjbGFzcyB0aGF0IGlzIGlkZW1wb3RlbnQgYW5kIGNhcGFibGUgb2YgY29udGFpbmluZyBvdGhlclxuICogUmVhY3QgY29tcG9uZW50cy4gSXQgYWNjZXB0cyBldmVudCBsaXN0ZW5lcnMgYW5kIERPTSBwcm9wZXJ0aWVzIHRoYXQgYXJlXG4gKiB2YWxpZCBhY2NvcmRpbmcgdG8gYERPTVByb3BlcnR5YC5cbiAqXG4gKiAgLSBFdmVudCBsaXN0ZW5lcnM6IGBvbkNsaWNrYCwgYG9uTW91c2VEb3duYCwgZXRjLlxuICogIC0gRE9NIHByb3BlcnRpZXM6IGBjbGFzc05hbWVgLCBgbmFtZWAsIGB0aXRsZWAsIGV0Yy5cbiAqXG4gKiBUaGUgYHN0eWxlYCBwcm9wZXJ0eSBmdW5jdGlvbnMgZGlmZmVyZW50bHkgZnJvbSB0aGUgRE9NIEFQSS4gSXQgYWNjZXB0cyBhblxuICogb2JqZWN0IG1hcHBpbmcgb2Ygc3R5bGUgcHJvcGVydGllcyB0byB2YWx1ZXMuXG4gKlxuICogQHBhcmFtIHtib29sZWFufSBvbWl0Q2xvc2UgVHJ1ZSBpZiB0aGUgY2xvc2UgdGFnIHNob3VsZCBiZSBvbWl0dGVkLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUYWcgbmFtZSAoZS5nLiBgZGl2YCkuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjcmVhdGVET01Db21wb25lbnRDbGFzcyhvbWl0Q2xvc2UsIHRhZykge1xuICB2YXIgQ29uc3RydWN0b3IgPSBmdW5jdGlvbihkZXNjcmlwdG9yKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3QoZGVzY3JpcHRvcik7XG4gIH07XG4gIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IG5ldyBSZWFjdERPTUNvbXBvbmVudCh0YWcsIG9taXRDbG9zZSk7XG4gIENvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yO1xuICBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSA9IHRhZztcblxuICB2YXIgQ29udmVuaWVuY2VDb25zdHJ1Y3RvciA9IFJlYWN0RGVzY3JpcHRvci5jcmVhdGVGYWN0b3J5KENvbnN0cnVjdG9yKTtcblxuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgcmV0dXJuIFJlYWN0RGVzY3JpcHRvclZhbGlkYXRvci5jcmVhdGVGYWN0b3J5KFxuICAgICAgQ29udmVuaWVuY2VDb25zdHJ1Y3RvclxuICAgICk7XG4gIH1cblxuICByZXR1cm4gQ29udmVuaWVuY2VDb25zdHJ1Y3Rvcjtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwcGluZyBmcm9tIHN1cHBvcnRlZCBIVE1MIHRhZ3MgdG8gYFJlYWN0RE9NQ29tcG9uZW50YCBjbGFzc2VzLlxuICogVGhpcyBpcyBhbHNvIGFjY2Vzc2libGUgdmlhIGBSZWFjdC5ET01gLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xudmFyIFJlYWN0RE9NID0gbWFwT2JqZWN0KHtcbiAgYTogZmFsc2UsXG4gIGFiYnI6IGZhbHNlLFxuICBhZGRyZXNzOiBmYWxzZSxcbiAgYXJlYTogdHJ1ZSxcbiAgYXJ0aWNsZTogZmFsc2UsXG4gIGFzaWRlOiBmYWxzZSxcbiAgYXVkaW86IGZhbHNlLFxuICBiOiBmYWxzZSxcbiAgYmFzZTogdHJ1ZSxcbiAgYmRpOiBmYWxzZSxcbiAgYmRvOiBmYWxzZSxcbiAgYmlnOiBmYWxzZSxcbiAgYmxvY2txdW90ZTogZmFsc2UsXG4gIGJvZHk6IGZhbHNlLFxuICBicjogdHJ1ZSxcbiAgYnV0dG9uOiBmYWxzZSxcbiAgY2FudmFzOiBmYWxzZSxcbiAgY2FwdGlvbjogZmFsc2UsXG4gIGNpdGU6IGZhbHNlLFxuICBjb2RlOiBmYWxzZSxcbiAgY29sOiB0cnVlLFxuICBjb2xncm91cDogZmFsc2UsXG4gIGRhdGE6IGZhbHNlLFxuICBkYXRhbGlzdDogZmFsc2UsXG4gIGRkOiBmYWxzZSxcbiAgZGVsOiBmYWxzZSxcbiAgZGV0YWlsczogZmFsc2UsXG4gIGRmbjogZmFsc2UsXG4gIGRpdjogZmFsc2UsXG4gIGRsOiBmYWxzZSxcbiAgZHQ6IGZhbHNlLFxuICBlbTogZmFsc2UsXG4gIGVtYmVkOiB0cnVlLFxuICBmaWVsZHNldDogZmFsc2UsXG4gIGZpZ2NhcHRpb246IGZhbHNlLFxuICBmaWd1cmU6IGZhbHNlLFxuICBmb290ZXI6IGZhbHNlLFxuICBmb3JtOiBmYWxzZSwgLy8gTk9URTogSW5qZWN0ZWQsIHNlZSBgUmVhY3RET01Gb3JtYC5cbiAgaDE6IGZhbHNlLFxuICBoMjogZmFsc2UsXG4gIGgzOiBmYWxzZSxcbiAgaDQ6IGZhbHNlLFxuICBoNTogZmFsc2UsXG4gIGg2OiBmYWxzZSxcbiAgaGVhZDogZmFsc2UsXG4gIGhlYWRlcjogZmFsc2UsXG4gIGhyOiB0cnVlLFxuICBodG1sOiBmYWxzZSxcbiAgaTogZmFsc2UsXG4gIGlmcmFtZTogZmFsc2UsXG4gIGltZzogdHJ1ZSxcbiAgaW5wdXQ6IHRydWUsXG4gIGluczogZmFsc2UsXG4gIGtiZDogZmFsc2UsXG4gIGtleWdlbjogdHJ1ZSxcbiAgbGFiZWw6IGZhbHNlLFxuICBsZWdlbmQ6IGZhbHNlLFxuICBsaTogZmFsc2UsXG4gIGxpbms6IHRydWUsXG4gIG1haW46IGZhbHNlLFxuICBtYXA6IGZhbHNlLFxuICBtYXJrOiBmYWxzZSxcbiAgbWVudTogZmFsc2UsXG4gIG1lbnVpdGVtOiBmYWxzZSwgLy8gTk9URTogQ2xvc2UgdGFnIHNob3VsZCBiZSBvbWl0dGVkLCBidXQgY2F1c2VzIHByb2JsZW1zLlxuICBtZXRhOiB0cnVlLFxuICBtZXRlcjogZmFsc2UsXG4gIG5hdjogZmFsc2UsXG4gIG5vc2NyaXB0OiBmYWxzZSxcbiAgb2JqZWN0OiBmYWxzZSxcbiAgb2w6IGZhbHNlLFxuICBvcHRncm91cDogZmFsc2UsXG4gIG9wdGlvbjogZmFsc2UsXG4gIG91dHB1dDogZmFsc2UsXG4gIHA6IGZhbHNlLFxuICBwYXJhbTogdHJ1ZSxcbiAgcHJlOiBmYWxzZSxcbiAgcHJvZ3Jlc3M6IGZhbHNlLFxuICBxOiBmYWxzZSxcbiAgcnA6IGZhbHNlLFxuICBydDogZmFsc2UsXG4gIHJ1Ynk6IGZhbHNlLFxuICBzOiBmYWxzZSxcbiAgc2FtcDogZmFsc2UsXG4gIHNjcmlwdDogZmFsc2UsXG4gIHNlY3Rpb246IGZhbHNlLFxuICBzZWxlY3Q6IGZhbHNlLFxuICBzbWFsbDogZmFsc2UsXG4gIHNvdXJjZTogdHJ1ZSxcbiAgc3BhbjogZmFsc2UsXG4gIHN0cm9uZzogZmFsc2UsXG4gIHN0eWxlOiBmYWxzZSxcbiAgc3ViOiBmYWxzZSxcbiAgc3VtbWFyeTogZmFsc2UsXG4gIHN1cDogZmFsc2UsXG4gIHRhYmxlOiBmYWxzZSxcbiAgdGJvZHk6IGZhbHNlLFxuICB0ZDogZmFsc2UsXG4gIHRleHRhcmVhOiBmYWxzZSwgLy8gTk9URTogSW5qZWN0ZWQsIHNlZSBgUmVhY3RET01UZXh0YXJlYWAuXG4gIHRmb290OiBmYWxzZSxcbiAgdGg6IGZhbHNlLFxuICB0aGVhZDogZmFsc2UsXG4gIHRpbWU6IGZhbHNlLFxuICB0aXRsZTogZmFsc2UsXG4gIHRyOiBmYWxzZSxcbiAgdHJhY2s6IHRydWUsXG4gIHU6IGZhbHNlLFxuICB1bDogZmFsc2UsXG4gICd2YXInOiBmYWxzZSxcbiAgdmlkZW86IGZhbHNlLFxuICB3YnI6IHRydWUsXG5cbiAgLy8gU1ZHXG4gIGNpcmNsZTogZmFsc2UsXG4gIGRlZnM6IGZhbHNlLFxuICBlbGxpcHNlOiBmYWxzZSxcbiAgZzogZmFsc2UsXG4gIGxpbmU6IGZhbHNlLFxuICBsaW5lYXJHcmFkaWVudDogZmFsc2UsXG4gIG1hc2s6IGZhbHNlLFxuICBwYXRoOiBmYWxzZSxcbiAgcGF0dGVybjogZmFsc2UsXG4gIHBvbHlnb246IGZhbHNlLFxuICBwb2x5bGluZTogZmFsc2UsXG4gIHJhZGlhbEdyYWRpZW50OiBmYWxzZSxcbiAgcmVjdDogZmFsc2UsXG4gIHN0b3A6IGZhbHNlLFxuICBzdmc6IGZhbHNlLFxuICB0ZXh0OiBmYWxzZSxcbiAgdHNwYW46IGZhbHNlXG59LCBjcmVhdGVET01Db21wb25lbnRDbGFzcyk7XG5cbnZhciBpbmplY3Rpb24gPSB7XG4gIGluamVjdENvbXBvbmVudENsYXNzZXM6IGZ1bmN0aW9uKGNvbXBvbmVudENsYXNzZXMpIHtcbiAgICBtZXJnZUludG8oUmVhY3RET00sIGNvbXBvbmVudENsYXNzZXMpO1xuICB9XG59O1xuXG5SZWFjdERPTS5pbmplY3Rpb24gPSBpbmplY3Rpb247XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET007XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUJ1dHRvblxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgQXV0b0ZvY3VzTWl4aW4gPSByZXF1aXJlKFwiLi9BdXRvRm9jdXNNaXhpblwiKTtcbnZhciBSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbiA9IHJlcXVpcmUoXCIuL1JlYWN0QnJvd3NlckNvbXBvbmVudE1peGluXCIpO1xudmFyIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50ID0gcmVxdWlyZShcIi4vUmVhY3RDb21wb3NpdGVDb21wb25lbnRcIik7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKFwiLi9SZWFjdERPTVwiKTtcblxudmFyIGtleU1pcnJvciA9IHJlcXVpcmUoXCIuL2tleU1pcnJvclwiKTtcblxuLy8gU3RvcmUgYSByZWZlcmVuY2UgdG8gdGhlIDxidXR0b24+IGBSZWFjdERPTUNvbXBvbmVudGAuXG52YXIgYnV0dG9uID0gUmVhY3RET00uYnV0dG9uO1xuXG52YXIgbW91c2VMaXN0ZW5lck5hbWVzID0ga2V5TWlycm9yKHtcbiAgb25DbGljazogdHJ1ZSxcbiAgb25Eb3VibGVDbGljazogdHJ1ZSxcbiAgb25Nb3VzZURvd246IHRydWUsXG4gIG9uTW91c2VNb3ZlOiB0cnVlLFxuICBvbk1vdXNlVXA6IHRydWUsXG4gIG9uQ2xpY2tDYXB0dXJlOiB0cnVlLFxuICBvbkRvdWJsZUNsaWNrQ2FwdHVyZTogdHJ1ZSxcbiAgb25Nb3VzZURvd25DYXB0dXJlOiB0cnVlLFxuICBvbk1vdXNlTW92ZUNhcHR1cmU6IHRydWUsXG4gIG9uTW91c2VVcENhcHR1cmU6IHRydWVcbn0pO1xuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8YnV0dG9uPiBuYXRpdmUgY29tcG9uZW50IHRoYXQgZG9lcyBub3QgcmVjZWl2ZSBtb3VzZSBldmVudHNcbiAqIHdoZW4gYGRpc2FibGVkYCBpcyBzZXQuXG4gKi9cbnZhciBSZWFjdERPTUJ1dHRvbiA9IFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50LmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdSZWFjdERPTUJ1dHRvbicsXG5cbiAgbWl4aW5zOiBbQXV0b0ZvY3VzTWl4aW4sIFJlYWN0QnJvd3NlckNvbXBvbmVudE1peGluXSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwcm9wcyA9IHt9O1xuXG4gICAgLy8gQ29weSB0aGUgcHJvcHM7IGV4Y2VwdCB0aGUgbW91c2UgbGlzdGVuZXJzIGlmIHdlJ3JlIGRpc2FibGVkXG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMucHJvcHMpIHtcbiAgICAgIGlmICh0aGlzLnByb3BzLmhhc093blByb3BlcnR5KGtleSkgJiZcbiAgICAgICAgICAoIXRoaXMucHJvcHMuZGlzYWJsZWQgfHwgIW1vdXNlTGlzdGVuZXJOYW1lc1trZXldKSkge1xuICAgICAgICBwcm9wc1trZXldID0gdGhpcy5wcm9wc1trZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBidXR0b24ocHJvcHMsIHRoaXMucHJvcHMuY2hpbGRyZW4pO1xuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NQnV0dG9uO1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUNvbXBvbmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIENTU1Byb3BlcnR5T3BlcmF0aW9ucyA9IHJlcXVpcmUoXCIuL0NTU1Byb3BlcnR5T3BlcmF0aW9uc1wiKTtcbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoXCIuL0RPTVByb3BlcnR5XCIpO1xudmFyIERPTVByb3BlcnR5T3BlcmF0aW9ucyA9IHJlcXVpcmUoXCIuL0RPTVByb3BlcnR5T3BlcmF0aW9uc1wiKTtcbnZhciBSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbiA9IHJlcXVpcmUoXCIuL1JlYWN0QnJvd3NlckNvbXBvbmVudE1peGluXCIpO1xudmFyIFJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZShcIi4vUmVhY3RDb21wb25lbnRcIik7XG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcIi4vUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyXCIpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKFwiLi9SZWFjdE1vdW50XCIpO1xudmFyIFJlYWN0TXVsdGlDaGlsZCA9IHJlcXVpcmUoXCIuL1JlYWN0TXVsdGlDaGlsZFwiKTtcbnZhciBSZWFjdFBlcmYgPSByZXF1aXJlKFwiLi9SZWFjdFBlcmZcIik7XG5cbnZhciBlc2NhcGVUZXh0Rm9yQnJvd3NlciA9IHJlcXVpcmUoXCIuL2VzY2FwZVRleHRGb3JCcm93c2VyXCIpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcbnZhciBrZXlPZiA9IHJlcXVpcmUoXCIuL2tleU9mXCIpO1xudmFyIG1lcmdlID0gcmVxdWlyZShcIi4vbWVyZ2VcIik7XG52YXIgbWl4SW50byA9IHJlcXVpcmUoXCIuL21peEludG9cIik7XG5cbnZhciBkZWxldGVMaXN0ZW5lciA9IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5kZWxldGVMaXN0ZW5lcjtcbnZhciBsaXN0ZW5UbyA9IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5saXN0ZW5UbztcbnZhciByZWdpc3RyYXRpb25OYW1lTW9kdWxlcyA9IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5yZWdpc3RyYXRpb25OYW1lTW9kdWxlcztcblxuLy8gRm9yIHF1aWNrbHkgbWF0Y2hpbmcgY2hpbGRyZW4gdHlwZSwgdG8gdGVzdCBpZiBjYW4gYmUgdHJlYXRlZCBhcyBjb250ZW50LlxudmFyIENPTlRFTlRfVFlQRVMgPSB7J3N0cmluZyc6IHRydWUsICdudW1iZXInOiB0cnVlfTtcblxudmFyIFNUWUxFID0ga2V5T2Yoe3N0eWxlOiBudWxsfSk7XG5cbnZhciBFTEVNRU5UX05PREVfVFlQRSA9IDE7XG5cbi8qKlxuICogQHBhcmFtIHs/b2JqZWN0fSBwcm9wc1xuICovXG5mdW5jdGlvbiBhc3NlcnRWYWxpZFByb3BzKHByb3BzKSB7XG4gIGlmICghcHJvcHMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gTm90ZSB0aGUgdXNlIG9mIGA9PWAgd2hpY2ggY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZC5cbiAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICBwcm9wcy5jaGlsZHJlbiA9PSBudWxsIHx8IHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09IG51bGwsXG4gICAgJ0NhbiBvbmx5IHNldCBvbmUgb2YgYGNoaWxkcmVuYCBvciBgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLidcbiAgKSA6IGludmFyaWFudChwcm9wcy5jaGlsZHJlbiA9PSBudWxsIHx8IHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09IG51bGwpKTtcbiAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICBwcm9wcy5zdHlsZSA9PSBudWxsIHx8IHR5cGVvZiBwcm9wcy5zdHlsZSA9PT0gJ29iamVjdCcsXG4gICAgJ1RoZSBgc3R5bGVgIHByb3AgZXhwZWN0cyBhIG1hcHBpbmcgZnJvbSBzdHlsZSBwcm9wZXJ0aWVzIHRvIHZhbHVlcywgJyArXG4gICAgJ25vdCBhIHN0cmluZy4nXG4gICkgOiBpbnZhcmlhbnQocHJvcHMuc3R5bGUgPT0gbnVsbCB8fCB0eXBlb2YgcHJvcHMuc3R5bGUgPT09ICdvYmplY3QnKSk7XG59XG5cbmZ1bmN0aW9uIHB1dExpc3RlbmVyKGlkLCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lciwgdHJhbnNhY3Rpb24pIHtcbiAgdmFyIGNvbnRhaW5lciA9IFJlYWN0TW91bnQuZmluZFJlYWN0Q29udGFpbmVyRm9ySUQoaWQpO1xuICBpZiAoY29udGFpbmVyKSB7XG4gICAgdmFyIGRvYyA9IGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFX1RZUEUgP1xuICAgICAgY29udGFpbmVyLm93bmVyRG9jdW1lbnQgOlxuICAgICAgY29udGFpbmVyO1xuICAgIGxpc3RlblRvKHJlZ2lzdHJhdGlvbk5hbWUsIGRvYyk7XG4gIH1cbiAgdHJhbnNhY3Rpb24uZ2V0UHV0TGlzdGVuZXJRdWV1ZSgpLmVucXVldWVQdXRMaXN0ZW5lcihcbiAgICBpZCxcbiAgICByZWdpc3RyYXRpb25OYW1lLFxuICAgIGxpc3RlbmVyXG4gICk7XG59XG5cblxuLyoqXG4gKiBAY29uc3RydWN0b3IgUmVhY3RET01Db21wb25lbnRcbiAqIEBleHRlbmRzIFJlYWN0Q29tcG9uZW50XG4gKiBAZXh0ZW5kcyBSZWFjdE11bHRpQ2hpbGRcbiAqL1xuZnVuY3Rpb24gUmVhY3RET01Db21wb25lbnQodGFnLCBvbWl0Q2xvc2UpIHtcbiAgdGhpcy5fdGFnT3BlbiA9ICc8JyArIHRhZztcbiAgdGhpcy5fdGFnQ2xvc2UgPSBvbWl0Q2xvc2UgPyAnJyA6ICc8LycgKyB0YWcgKyAnPic7XG4gIHRoaXMudGFnTmFtZSA9IHRhZy50b1VwcGVyQ2FzZSgpO1xufVxuXG5SZWFjdERPTUNvbXBvbmVudC5NaXhpbiA9IHtcblxuICAvKipcbiAgICogR2VuZXJhdGVzIHJvb3QgdGFnIG1hcmt1cCB0aGVuIHJlY3Vyc2VzLiBUaGlzIG1ldGhvZCBoYXMgc2lkZSBlZmZlY3RzIGFuZFxuICAgKiBpcyBub3QgaWRlbXBvdGVudC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByb290SUQgVGhlIHJvb3QgRE9NIElEIGZvciB0aGlzIG5vZGUuXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gbW91bnREZXB0aCBudW1iZXIgb2YgY29tcG9uZW50cyBpbiB0aGUgb3duZXIgaGllcmFyY2h5XG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGNvbXB1dGVkIG1hcmt1cC5cbiAgICovXG4gIG1vdW50Q29tcG9uZW50OiBSZWFjdFBlcmYubWVhc3VyZShcbiAgICAnUmVhY3RET01Db21wb25lbnQnLFxuICAgICdtb3VudENvbXBvbmVudCcsXG4gICAgZnVuY3Rpb24ocm9vdElELCB0cmFuc2FjdGlvbiwgbW91bnREZXB0aCkge1xuICAgICAgUmVhY3RDb21wb25lbnQuTWl4aW4ubW91bnRDb21wb25lbnQuY2FsbChcbiAgICAgICAgdGhpcyxcbiAgICAgICAgcm9vdElELFxuICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgbW91bnREZXB0aFxuICAgICAgKTtcbiAgICAgIGFzc2VydFZhbGlkUHJvcHModGhpcy5wcm9wcyk7XG4gICAgICByZXR1cm4gKFxuICAgICAgICB0aGlzLl9jcmVhdGVPcGVuVGFnTWFya3VwQW5kUHV0TGlzdGVuZXJzKHRyYW5zYWN0aW9uKSArXG4gICAgICAgIHRoaXMuX2NyZWF0ZUNvbnRlbnRNYXJrdXAodHJhbnNhY3Rpb24pICtcbiAgICAgICAgdGhpcy5fdGFnQ2xvc2VcbiAgICAgICk7XG4gICAgfVxuICApLFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIG1hcmt1cCBmb3IgdGhlIG9wZW4gdGFnIGFuZCBhbGwgYXR0cmlidXRlcy5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaGFzIHNpZGUgZWZmZWN0cyBiZWNhdXNlIGV2ZW50cyBnZXQgcmVnaXN0ZXJlZC5cbiAgICpcbiAgICogSXRlcmF0aW5nIG92ZXIgb2JqZWN0IHByb3BlcnRpZXMgaXMgZmFzdGVyIHRoYW4gaXRlcmF0aW5nIG92ZXIgYXJyYXlzLlxuICAgKiBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL29iai12cy1hcnItaXRlcmF0aW9uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IE1hcmt1cCBvZiBvcGVuaW5nIHRhZy5cbiAgICovXG4gIF9jcmVhdGVPcGVuVGFnTWFya3VwQW5kUHV0TGlzdGVuZXJzOiBmdW5jdGlvbih0cmFuc2FjdGlvbikge1xuICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHJldCA9IHRoaXMuX3RhZ09wZW47XG5cbiAgICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgICBpZiAoIXByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgIHB1dExpc3RlbmVyKHRoaXMuX3Jvb3ROb2RlSUQsIHByb3BLZXksIHByb3BWYWx1ZSwgdHJhbnNhY3Rpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICAgICAgaWYgKHByb3BWYWx1ZSkge1xuICAgICAgICAgICAgcHJvcFZhbHVlID0gcHJvcHMuc3R5bGUgPSBtZXJnZShwcm9wcy5zdHlsZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHByb3BWYWx1ZSA9IENTU1Byb3BlcnR5T3BlcmF0aW9ucy5jcmVhdGVNYXJrdXBGb3JTdHlsZXMocHJvcFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWFya3VwID1cbiAgICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuY3JlYXRlTWFya3VwRm9yUHJvcGVydHkocHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgaWYgKG1hcmt1cCkge1xuICAgICAgICAgIHJldCArPSAnICcgKyBtYXJrdXA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGb3Igc3RhdGljIHBhZ2VzLCBubyBuZWVkIHRvIHB1dCBSZWFjdCBJRCBhbmQgY2hlY2tzdW0uIFNhdmVzIGxvdHMgb2ZcbiAgICAvLyBieXRlcy5cbiAgICBpZiAodHJhbnNhY3Rpb24ucmVuZGVyVG9TdGF0aWNNYXJrdXApIHtcbiAgICAgIHJldHVybiByZXQgKyAnPic7XG4gICAgfVxuXG4gICAgdmFyIG1hcmt1cEZvcklEID0gRE9NUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvcklEKHRoaXMuX3Jvb3ROb2RlSUQpO1xuICAgIHJldHVybiByZXQgKyAnICcgKyBtYXJrdXBGb3JJRCArICc+JztcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIHRoZSBjb250ZW50IGJldHdlZW4gdGhlIHRhZ3MuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IENvbnRlbnQgbWFya3VwLlxuICAgKi9cbiAgX2NyZWF0ZUNvbnRlbnRNYXJrdXA6IGZ1bmN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgLy8gSW50ZW50aW9uYWwgdXNlIG9mICE9IHRvIGF2b2lkIGNhdGNoaW5nIHplcm8vZmFsc2UuXG4gICAgdmFyIGlubmVySFRNTCA9IHRoaXMucHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw7XG4gICAgaWYgKGlubmVySFRNTCAhPSBudWxsKSB7XG4gICAgICBpZiAoaW5uZXJIVE1MLl9faHRtbCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBpbm5lckhUTUwuX19odG1sO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY29udGVudFRvVXNlID1cbiAgICAgICAgQ09OVEVOVF9UWVBFU1t0eXBlb2YgdGhpcy5wcm9wcy5jaGlsZHJlbl0gPyB0aGlzLnByb3BzLmNoaWxkcmVuIDogbnVsbDtcbiAgICAgIHZhciBjaGlsZHJlblRvVXNlID0gY29udGVudFRvVXNlICE9IG51bGwgPyBudWxsIDogdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICAgIGlmIChjb250ZW50VG9Vc2UgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZXNjYXBlVGV4dEZvckJyb3dzZXIoY29udGVudFRvVXNlKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGRyZW5Ub1VzZSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBtb3VudEltYWdlcyA9IHRoaXMubW91bnRDaGlsZHJlbihcbiAgICAgICAgICBjaGlsZHJlblRvVXNlLFxuICAgICAgICAgIHRyYW5zYWN0aW9uXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBtb3VudEltYWdlcy5qb2luKCcnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9LFxuXG4gIHJlY2VpdmVDb21wb25lbnQ6IGZ1bmN0aW9uKG5leHREZXNjcmlwdG9yLCB0cmFuc2FjdGlvbikge1xuICAgIGlmIChuZXh0RGVzY3JpcHRvciA9PT0gdGhpcy5fZGVzY3JpcHRvciAmJlxuICAgICAgICBuZXh0RGVzY3JpcHRvci5fb3duZXIgIT0gbnVsbCkge1xuICAgICAgLy8gU2luY2UgZGVzY3JpcHRvcnMgYXJlIGltbXV0YWJsZSBhZnRlciB0aGUgb3duZXIgaXMgcmVuZGVyZWQsXG4gICAgICAvLyB3ZSBjYW4gZG8gYSBjaGVhcCBpZGVudGl0eSBjb21wYXJlIGhlcmUgdG8gZGV0ZXJtaW5lIGlmIHRoaXMgaXMgYVxuICAgICAgLy8gc3VwZXJmbHVvdXMgcmVjb25jaWxlLiBJdCdzIHBvc3NpYmxlIGZvciBzdGF0ZSB0byBiZSBtdXRhYmxlIGJ1dCBzdWNoXG4gICAgICAvLyBjaGFuZ2Ugc2hvdWxkIHRyaWdnZXIgYW4gdXBkYXRlIG9mIHRoZSBvd25lciB3aGljaCB3b3VsZCByZWNyZWF0ZVxuICAgICAgLy8gdGhlIGRlc2NyaXB0b3IuIFdlIGV4cGxpY2l0bHkgY2hlY2sgZm9yIHRoZSBleGlzdGVuY2Ugb2YgYW4gb3duZXIgc2luY2VcbiAgICAgIC8vIGl0J3MgcG9zc2libGUgZm9yIGEgZGVzY3JpcHRvciBjcmVhdGVkIG91dHNpZGUgYSBjb21wb3NpdGUgdG8gYmVcbiAgICAgIC8vIGRlZXBseSBtdXRhdGVkIGFuZCByZXVzZWQuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgUmVhY3RDb21wb25lbnQuTWl4aW4ucmVjZWl2ZUNvbXBvbmVudC5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgIG5leHREZXNjcmlwdG9yLFxuICAgICAgdHJhbnNhY3Rpb25cbiAgICApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgbmF0aXZlIERPTSBjb21wb25lbnQgYWZ0ZXIgaXQgaGFzIGFscmVhZHkgYmVlbiBhbGxvY2F0ZWQgYW5kXG4gICAqIGF0dGFjaGVkIHRvIHRoZSBET00uIFJlY29uY2lsZXMgdGhlIHJvb3QgRE9NIG5vZGUsIHRoZW4gcmVjdXJzZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtSZWFjdERlc2NyaXB0b3J9IHByZXZEZXNjcmlwdG9yXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAb3ZlcnJpZGFibGVcbiAgICovXG4gIHVwZGF0ZUNvbXBvbmVudDogUmVhY3RQZXJmLm1lYXN1cmUoXG4gICAgJ1JlYWN0RE9NQ29tcG9uZW50JyxcbiAgICAndXBkYXRlQ29tcG9uZW50JyxcbiAgICBmdW5jdGlvbih0cmFuc2FjdGlvbiwgcHJldkRlc2NyaXB0b3IpIHtcbiAgICAgIGFzc2VydFZhbGlkUHJvcHModGhpcy5fZGVzY3JpcHRvci5wcm9wcyk7XG4gICAgICBSZWFjdENvbXBvbmVudC5NaXhpbi51cGRhdGVDb21wb25lbnQuY2FsbChcbiAgICAgICAgdGhpcyxcbiAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICAgIHByZXZEZXNjcmlwdG9yXG4gICAgICApO1xuICAgICAgdGhpcy5fdXBkYXRlRE9NUHJvcGVydGllcyhwcmV2RGVzY3JpcHRvci5wcm9wcywgdHJhbnNhY3Rpb24pO1xuICAgICAgdGhpcy5fdXBkYXRlRE9NQ2hpbGRyZW4ocHJldkRlc2NyaXB0b3IucHJvcHMsIHRyYW5zYWN0aW9uKTtcbiAgICB9XG4gICksXG5cbiAgLyoqXG4gICAqIFJlY29uY2lsZXMgdGhlIHByb3BlcnRpZXMgYnkgZGV0ZWN0aW5nIGRpZmZlcmVuY2VzIGluIHByb3BlcnR5IHZhbHVlcyBhbmRcbiAgICogdXBkYXRpbmcgdGhlIERPTSBhcyBuZWNlc3NhcnkuIFRoaXMgZnVuY3Rpb24gaXMgcHJvYmFibHkgdGhlIHNpbmdsZSBtb3N0XG4gICAqIGNyaXRpY2FsIHBhdGggZm9yIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbi5cbiAgICpcbiAgICogVE9ETzogQmVuY2htYXJrIHdoZXRoZXIgY2hlY2tpbmcgZm9yIGNoYW5nZWQgdmFsdWVzIGluIG1lbW9yeSBhY3R1YWxseVxuICAgKiAgICAgICBpbXByb3ZlcyBwZXJmb3JtYW5jZSAoZXNwZWNpYWxseSBzdGF0aWNhbGx5IHBvc2l0aW9uZWQgZWxlbWVudHMpLlxuICAgKiBUT0RPOiBCZW5jaG1hcmsgdGhlIGVmZmVjdHMgb2YgcHV0dGluZyB0aGlzIGF0IHRoZSB0b3Agc2luY2UgOTklIG9mIHByb3BzXG4gICAqICAgICAgIGRvIG5vdCBjaGFuZ2UgZm9yIGEgZ2l2ZW4gcmVjb25jaWxpYXRpb24uXG4gICAqIFRPRE86IEJlbmNobWFyayBhcmVhcyB0aGF0IGNhbiBiZSBpbXByb3ZlZCB3aXRoIGNhY2hpbmcuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBsYXN0UHJvcHNcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKi9cbiAgX3VwZGF0ZURPTVByb3BlcnRpZXM6IGZ1bmN0aW9uKGxhc3RQcm9wcywgdHJhbnNhY3Rpb24pIHtcbiAgICB2YXIgbmV4dFByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgcHJvcEtleTtcbiAgICB2YXIgc3R5bGVOYW1lO1xuICAgIHZhciBzdHlsZVVwZGF0ZXM7XG4gICAgZm9yIChwcm9wS2V5IGluIGxhc3RQcm9wcykge1xuICAgICAgaWYgKG5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fFxuICAgICAgICAgIWxhc3RQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgICB2YXIgbGFzdFN0eWxlID0gbGFzdFByb3BzW3Byb3BLZXldO1xuICAgICAgICBmb3IgKHN0eWxlTmFtZSBpbiBsYXN0U3R5bGUpIHtcbiAgICAgICAgICBpZiAobGFzdFN0eWxlLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHN0eWxlVXBkYXRlcyB8fCB7fTtcbiAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgIGRlbGV0ZUxpc3RlbmVyKHRoaXMuX3Jvb3ROb2RlSUQsIHByb3BLZXkpO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICBET01Qcm9wZXJ0eS5pc1N0YW5kYXJkTmFtZVtwcm9wS2V5XSB8fFxuICAgICAgICAgIERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKHByb3BLZXkpKSB7XG4gICAgICAgIFJlYWN0Q29tcG9uZW50LkJhY2tlbmRJRE9wZXJhdGlvbnMuZGVsZXRlUHJvcGVydHlCeUlEKFxuICAgICAgICAgIHRoaXMuX3Jvb3ROb2RlSUQsXG4gICAgICAgICAgcHJvcEtleVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHByb3BLZXkgaW4gbmV4dFByb3BzKSB7XG4gICAgICB2YXIgbmV4dFByb3AgPSBuZXh0UHJvcHNbcHJvcEtleV07XG4gICAgICB2YXIgbGFzdFByb3AgPSBsYXN0UHJvcHNbcHJvcEtleV07XG4gICAgICBpZiAoIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCBuZXh0UHJvcCA9PT0gbGFzdFByb3ApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgICAgaWYgKG5leHRQcm9wKSB7XG4gICAgICAgICAgbmV4dFByb3AgPSBuZXh0UHJvcHMuc3R5bGUgPSBtZXJnZShuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RQcm9wKSB7XG4gICAgICAgICAgLy8gVW5zZXQgc3R5bGVzIG9uIGBsYXN0UHJvcGAgYnV0IG5vdCBvbiBgbmV4dFByb3BgLlxuICAgICAgICAgIGZvciAoc3R5bGVOYW1lIGluIGxhc3RQcm9wKSB7XG4gICAgICAgICAgICBpZiAobGFzdFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSAmJlxuICAgICAgICAgICAgICAgICghbmV4dFByb3AgfHwgIW5leHRQcm9wLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpKSB7XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHN0eWxlVXBkYXRlcyB8fCB7fTtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gVXBkYXRlIHN0eWxlcyB0aGF0IGNoYW5nZWQgc2luY2UgYGxhc3RQcm9wYC5cbiAgICAgICAgICBmb3IgKHN0eWxlTmFtZSBpbiBuZXh0UHJvcCkge1xuICAgICAgICAgICAgaWYgKG5leHRQcm9wLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkgJiZcbiAgICAgICAgICAgICAgICBsYXN0UHJvcFtzdHlsZU5hbWVdICE9PSBuZXh0UHJvcFtzdHlsZU5hbWVdKSB7XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHN0eWxlVXBkYXRlcyB8fCB7fTtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSBuZXh0UHJvcFtzdHlsZU5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBSZWxpZXMgb24gYHVwZGF0ZVN0eWxlc0J5SURgIG5vdCBtdXRhdGluZyBgc3R5bGVVcGRhdGVzYC5cbiAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSBuZXh0UHJvcDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICBwdXRMaXN0ZW5lcih0aGlzLl9yb290Tm9kZUlELCBwcm9wS2V5LCBuZXh0UHJvcCwgdHJhbnNhY3Rpb24pO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICBET01Qcm9wZXJ0eS5pc1N0YW5kYXJkTmFtZVtwcm9wS2V5XSB8fFxuICAgICAgICAgIERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKHByb3BLZXkpKSB7XG4gICAgICAgIFJlYWN0Q29tcG9uZW50LkJhY2tlbmRJRE9wZXJhdGlvbnMudXBkYXRlUHJvcGVydHlCeUlEKFxuICAgICAgICAgIHRoaXMuX3Jvb3ROb2RlSUQsXG4gICAgICAgICAgcHJvcEtleSxcbiAgICAgICAgICBuZXh0UHJvcFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3R5bGVVcGRhdGVzKSB7XG4gICAgICBSZWFjdENvbXBvbmVudC5CYWNrZW5kSURPcGVyYXRpb25zLnVwZGF0ZVN0eWxlc0J5SUQoXG4gICAgICAgIHRoaXMuX3Jvb3ROb2RlSUQsXG4gICAgICAgIHN0eWxlVXBkYXRlc1xuICAgICAgKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlY29uY2lsZXMgdGhlIGNoaWxkcmVuIHdpdGggdGhlIHZhcmlvdXMgcHJvcGVydGllcyB0aGF0IGFmZmVjdCB0aGVcbiAgICogY2hpbGRyZW4gY29udGVudC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGxhc3RQcm9wc1xuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqL1xuICBfdXBkYXRlRE9NQ2hpbGRyZW46IGZ1bmN0aW9uKGxhc3RQcm9wcywgdHJhbnNhY3Rpb24pIHtcbiAgICB2YXIgbmV4dFByb3BzID0gdGhpcy5wcm9wcztcblxuICAgIHZhciBsYXN0Q29udGVudCA9XG4gICAgICBDT05URU5UX1RZUEVTW3R5cGVvZiBsYXN0UHJvcHMuY2hpbGRyZW5dID8gbGFzdFByb3BzLmNoaWxkcmVuIDogbnVsbDtcbiAgICB2YXIgbmV4dENvbnRlbnQgPVxuICAgICAgQ09OVEVOVF9UWVBFU1t0eXBlb2YgbmV4dFByb3BzLmNoaWxkcmVuXSA/IG5leHRQcm9wcy5jaGlsZHJlbiA6IG51bGw7XG5cbiAgICB2YXIgbGFzdEh0bWwgPVxuICAgICAgbGFzdFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICYmXG4gICAgICBsYXN0UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwuX19odG1sO1xuICAgIHZhciBuZXh0SHRtbCA9XG4gICAgICBuZXh0UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgJiZcbiAgICAgIG5leHRQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWw7XG5cbiAgICAvLyBOb3RlIHRoZSB1c2Ugb2YgYCE9YCB3aGljaCBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkLlxuICAgIHZhciBsYXN0Q2hpbGRyZW4gPSBsYXN0Q29udGVudCAhPSBudWxsID8gbnVsbCA6IGxhc3RQcm9wcy5jaGlsZHJlbjtcbiAgICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dENvbnRlbnQgIT0gbnVsbCA/IG51bGwgOiBuZXh0UHJvcHMuY2hpbGRyZW47XG5cbiAgICAvLyBJZiB3ZSdyZSBzd2l0Y2hpbmcgZnJvbSBjaGlsZHJlbiB0byBjb250ZW50L2h0bWwgb3IgdmljZSB2ZXJzYSwgcmVtb3ZlXG4gICAgLy8gdGhlIG9sZCBjb250ZW50XG4gICAgdmFyIGxhc3RIYXNDb250ZW50T3JIdG1sID0gbGFzdENvbnRlbnQgIT0gbnVsbCB8fCBsYXN0SHRtbCAhPSBudWxsO1xuICAgIHZhciBuZXh0SGFzQ29udGVudE9ySHRtbCA9IG5leHRDb250ZW50ICE9IG51bGwgfHwgbmV4dEh0bWwgIT0gbnVsbDtcbiAgICBpZiAobGFzdENoaWxkcmVuICE9IG51bGwgJiYgbmV4dENoaWxkcmVuID09IG51bGwpIHtcbiAgICAgIHRoaXMudXBkYXRlQ2hpbGRyZW4obnVsbCwgdHJhbnNhY3Rpb24pO1xuICAgIH0gZWxzZSBpZiAobGFzdEhhc0NvbnRlbnRPckh0bWwgJiYgIW5leHRIYXNDb250ZW50T3JIdG1sKSB7XG4gICAgICB0aGlzLnVwZGF0ZVRleHRDb250ZW50KCcnKTtcbiAgICB9XG5cbiAgICBpZiAobmV4dENvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgaWYgKGxhc3RDb250ZW50ICE9PSBuZXh0Q29udGVudCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVRleHRDb250ZW50KCcnICsgbmV4dENvbnRlbnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmV4dEh0bWwgIT0gbnVsbCkge1xuICAgICAgaWYgKGxhc3RIdG1sICE9PSBuZXh0SHRtbCkge1xuICAgICAgICBSZWFjdENvbXBvbmVudC5CYWNrZW5kSURPcGVyYXRpb25zLnVwZGF0ZUlubmVySFRNTEJ5SUQoXG4gICAgICAgICAgdGhpcy5fcm9vdE5vZGVJRCxcbiAgICAgICAgICBuZXh0SHRtbFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmV4dENoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgIHRoaXMudXBkYXRlQ2hpbGRyZW4obmV4dENoaWxkcmVuLCB0cmFuc2FjdGlvbik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyBhbGwgZXZlbnQgcmVnaXN0cmF0aW9ucyBmb3IgdGhpcyBpbnN0YW5jZS4gRG9lcyBub3QgcmVtb3ZlIGZyb21cbiAgICogdGhlIERPTS4gVGhhdCBtdXN0IGJlIGRvbmUgYnkgdGhlIHBhcmVudC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnVubW91bnRDaGlsZHJlbigpO1xuICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5kZWxldGVBbGxMaXN0ZW5lcnModGhpcy5fcm9vdE5vZGVJRCk7XG4gICAgUmVhY3RDb21wb25lbnQuTWl4aW4udW5tb3VudENvbXBvbmVudC5jYWxsKHRoaXMpO1xuICB9XG5cbn07XG5cbm1peEludG8oUmVhY3RET01Db21wb25lbnQsIFJlYWN0Q29tcG9uZW50Lk1peGluKTtcbm1peEludG8oUmVhY3RET01Db21wb25lbnQsIFJlYWN0RE9NQ29tcG9uZW50Lk1peGluKTtcbm1peEludG8oUmVhY3RET01Db21wb25lbnQsIFJlYWN0TXVsdGlDaGlsZC5NaXhpbik7XG5taXhJbnRvKFJlYWN0RE9NQ29tcG9uZW50LCBSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbik7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01Db21wb25lbnQ7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUZvcm1cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZShcIi4vRXZlbnRDb25zdGFudHNcIik7XG52YXIgTG9jYWxFdmVudFRyYXBNaXhpbiA9IHJlcXVpcmUoXCIuL0xvY2FsRXZlbnRUcmFwTWl4aW5cIik7XG52YXIgUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW4gPSByZXF1aXJlKFwiLi9SZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpblwiKTtcbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCA9IHJlcXVpcmUoXCIuL1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50XCIpO1xudmFyIFJlYWN0RE9NID0gcmVxdWlyZShcIi4vUmVhY3RET01cIik7XG5cbi8vIFN0b3JlIGEgcmVmZXJlbmNlIHRvIHRoZSA8Zm9ybT4gYFJlYWN0RE9NQ29tcG9uZW50YC5cbnZhciBmb3JtID0gUmVhY3RET00uZm9ybTtcblxuLyoqXG4gKiBTaW5jZSBvblN1Ym1pdCBkb2Vzbid0IGJ1YmJsZSBPUiBjYXB0dXJlIG9uIHRoZSB0b3AgbGV2ZWwgaW4gSUU4LCB3ZSBuZWVkXG4gKiB0byBjYXB0dXJlIGl0IG9uIHRoZSA8Zm9ybT4gZWxlbWVudCBpdHNlbGYuIFRoZXJlIGFyZSBsb3RzIG9mIGhhY2tzIHdlIGNvdWxkXG4gKiBkbyB0byBhY2NvbXBsaXNoIHRoaXMsIGJ1dCB0aGUgbW9zdCByZWxpYWJsZSBpcyB0byBtYWtlIDxmb3JtPiBhXG4gKiBjb21wb3NpdGUgY29tcG9uZW50IGFuZCB1c2UgYGNvbXBvbmVudERpZE1vdW50YCB0byBhdHRhY2ggdGhlIGV2ZW50IGhhbmRsZXJzLlxuICovXG52YXIgUmVhY3RET01Gb3JtID0gUmVhY3RDb21wb3NpdGVDb21wb25lbnQuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ1JlYWN0RE9NRm9ybScsXG5cbiAgbWl4aW5zOiBbUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW4sIExvY2FsRXZlbnRUcmFwTWl4aW5dLFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgLy8gVE9ETzogSW5zdGVhZCBvZiB1c2luZyBgUmVhY3RET01gIGRpcmVjdGx5LCB3ZSBzaG91bGQgdXNlIEpTWC4gSG93ZXZlcixcbiAgICAvLyBganNoaW50YCBmYWlscyB0byBwYXJzZSBKU1ggc28gaW4gb3JkZXIgZm9yIGxpbnRpbmcgdG8gd29yayBpbiB0aGUgb3BlblxuICAgIC8vIHNvdXJjZSByZXBvLCB3ZSBuZWVkIHRvIGp1c3QgdXNlIGBSZWFjdERPTS5mb3JtYC5cbiAgICByZXR1cm4gdGhpcy50cmFuc2ZlclByb3BzVG8oZm9ybShudWxsLCB0aGlzLnByb3BzLmNoaWxkcmVuKSk7XG4gIH0sXG5cbiAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudHJhcEJ1YmJsZWRFdmVudChFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzLnRvcFJlc2V0LCAncmVzZXQnKTtcbiAgICB0aGlzLnRyYXBCdWJibGVkRXZlbnQoRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcy50b3BTdWJtaXQsICdzdWJtaXQnKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01Gb3JtO1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUlET3BlcmF0aW9uc1xuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4vKmpzbGludCBldmlsOiB0cnVlICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgQ1NTUHJvcGVydHlPcGVyYXRpb25zID0gcmVxdWlyZShcIi4vQ1NTUHJvcGVydHlPcGVyYXRpb25zXCIpO1xudmFyIERPTUNoaWxkcmVuT3BlcmF0aW9ucyA9IHJlcXVpcmUoXCIuL0RPTUNoaWxkcmVuT3BlcmF0aW9uc1wiKTtcbnZhciBET01Qcm9wZXJ0eU9wZXJhdGlvbnMgPSByZXF1aXJlKFwiLi9ET01Qcm9wZXJ0eU9wZXJhdGlvbnNcIik7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoXCIuL1JlYWN0TW91bnRcIik7XG52YXIgUmVhY3RQZXJmID0gcmVxdWlyZShcIi4vUmVhY3RQZXJmXCIpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xudmFyIHNldElubmVySFRNTCA9IHJlcXVpcmUoXCIuL3NldElubmVySFRNTFwiKTtcblxuLyoqXG4gKiBFcnJvcnMgZm9yIHByb3BlcnRpZXMgdGhhdCBzaG91bGQgbm90IGJlIHVwZGF0ZWQgd2l0aCBgdXBkYXRlUHJvcGVydHlCeUlkKClgLlxuICpcbiAqIEB0eXBlIHtvYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgSU5WQUxJRF9QUk9QRVJUWV9FUlJPUlMgPSB7XG4gIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOlxuICAgICdgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIG11c3QgYmUgc2V0IHVzaW5nIGB1cGRhdGVJbm5lckhUTUxCeUlEKClgLicsXG4gIHN0eWxlOiAnYHN0eWxlYCBtdXN0IGJlIHNldCB1c2luZyBgdXBkYXRlU3R5bGVzQnlJRCgpYC4nXG59O1xuXG4vKipcbiAqIE9wZXJhdGlvbnMgdXNlZCB0byBwcm9jZXNzIHVwZGF0ZXMgdG8gRE9NIG5vZGVzLiBUaGlzIGlzIG1hZGUgaW5qZWN0YWJsZSB2aWFcbiAqIGBSZWFjdENvbXBvbmVudC5CYWNrZW5kSURPcGVyYXRpb25zYC5cbiAqL1xudmFyIFJlYWN0RE9NSURPcGVyYXRpb25zID0ge1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgRE9NIG5vZGUgd2l0aCBuZXcgcHJvcGVydHkgdmFsdWVzLiBUaGlzIHNob3VsZCBvbmx5IGJlIHVzZWQgdG9cbiAgICogdXBkYXRlIERPTSBwcm9wZXJ0aWVzIGluIGBET01Qcm9wZXJ0eWAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiB0aGUgbm9kZSB0byB1cGRhdGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEEgdmFsaWQgcHJvcGVydHkgbmFtZSwgc2VlIGBET01Qcm9wZXJ0eWAuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgTmV3IHZhbHVlIG9mIHRoZSBwcm9wZXJ0eS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB1cGRhdGVQcm9wZXJ0eUJ5SUQ6IFJlYWN0UGVyZi5tZWFzdXJlKFxuICAgICdSZWFjdERPTUlET3BlcmF0aW9ucycsXG4gICAgJ3VwZGF0ZVByb3BlcnR5QnlJRCcsXG4gICAgZnVuY3Rpb24oaWQsIG5hbWUsIHZhbHVlKSB7XG4gICAgICB2YXIgbm9kZSA9IFJlYWN0TW91bnQuZ2V0Tm9kZShpZCk7XG4gICAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgICAhSU5WQUxJRF9QUk9QRVJUWV9FUlJPUlMuaGFzT3duUHJvcGVydHkobmFtZSksXG4gICAgICAgICd1cGRhdGVQcm9wZXJ0eUJ5SUQoLi4uKTogJXMnLFxuICAgICAgICBJTlZBTElEX1BST1BFUlRZX0VSUk9SU1tuYW1lXVxuICAgICAgKSA6IGludmFyaWFudCghSU5WQUxJRF9QUk9QRVJUWV9FUlJPUlMuaGFzT3duUHJvcGVydHkobmFtZSkpKTtcblxuICAgICAgLy8gSWYgd2UncmUgdXBkYXRpbmcgdG8gbnVsbCBvciB1bmRlZmluZWQsIHdlIHNob3VsZCByZW1vdmUgdGhlIHByb3BlcnR5XG4gICAgICAvLyBmcm9tIHRoZSBET00gbm9kZSBpbnN0ZWFkIG9mIGluYWR2ZXJ0YW50bHkgc2V0dGluZyB0byBhIHN0cmluZy4gVGhpc1xuICAgICAgLy8gYnJpbmdzIHVzIGluIGxpbmUgd2l0aCB0aGUgc2FtZSBiZWhhdmlvciB3ZSBoYXZlIG9uIGluaXRpYWwgcmVuZGVyLlxuICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yUHJvcGVydHkobm9kZSwgbmFtZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLmRlbGV0ZVZhbHVlRm9yUHJvcGVydHkobm9kZSwgbmFtZSk7XG4gICAgICB9XG4gICAgfVxuICApLFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgRE9NIG5vZGUgdG8gcmVtb3ZlIGEgcHJvcGVydHkuIFRoaXMgc2hvdWxkIG9ubHkgYmUgdXNlZCB0byByZW1vdmVcbiAgICogRE9NIHByb3BlcnRpZXMgaW4gYERPTVByb3BlcnR5YC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIElEIG9mIHRoZSBub2RlIHRvIHVwZGF0ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQSBwcm9wZXJ0eSBuYW1lIHRvIHJlbW92ZSwgc2VlIGBET01Qcm9wZXJ0eWAuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZGVsZXRlUHJvcGVydHlCeUlEOiBSZWFjdFBlcmYubWVhc3VyZShcbiAgICAnUmVhY3RET01JRE9wZXJhdGlvbnMnLFxuICAgICdkZWxldGVQcm9wZXJ0eUJ5SUQnLFxuICAgIGZ1bmN0aW9uKGlkLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgdmFyIG5vZGUgPSBSZWFjdE1vdW50LmdldE5vZGUoaWQpO1xuICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICAgIUlOVkFMSURfUFJPUEVSVFlfRVJST1JTLmhhc093blByb3BlcnR5KG5hbWUpLFxuICAgICAgICAndXBkYXRlUHJvcGVydHlCeUlEKC4uLik6ICVzJyxcbiAgICAgICAgSU5WQUxJRF9QUk9QRVJUWV9FUlJPUlNbbmFtZV1cbiAgICAgICkgOiBpbnZhcmlhbnQoIUlOVkFMSURfUFJPUEVSVFlfRVJST1JTLmhhc093blByb3BlcnR5KG5hbWUpKSk7XG4gICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eShub2RlLCBuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICApLFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgRE9NIG5vZGUgd2l0aCBuZXcgc3R5bGUgdmFsdWVzLiBJZiBhIHZhbHVlIGlzIHNwZWNpZmllZCBhcyAnJyxcbiAgICogdGhlIGNvcnJlc3BvbmRpbmcgc3R5bGUgcHJvcGVydHkgd2lsbCBiZSB1bnNldC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIElEIG9mIHRoZSBub2RlIHRvIHVwZGF0ZS5cbiAgICogQHBhcmFtIHtvYmplY3R9IHN0eWxlcyBNYXBwaW5nIGZyb20gc3R5bGVzIHRvIHZhbHVlcy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB1cGRhdGVTdHlsZXNCeUlEOiBSZWFjdFBlcmYubWVhc3VyZShcbiAgICAnUmVhY3RET01JRE9wZXJhdGlvbnMnLFxuICAgICd1cGRhdGVTdHlsZXNCeUlEJyxcbiAgICBmdW5jdGlvbihpZCwgc3R5bGVzKSB7XG4gICAgICB2YXIgbm9kZSA9IFJlYWN0TW91bnQuZ2V0Tm9kZShpZCk7XG4gICAgICBDU1NQcm9wZXJ0eU9wZXJhdGlvbnMuc2V0VmFsdWVGb3JTdHlsZXMobm9kZSwgc3R5bGVzKTtcbiAgICB9XG4gICksXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYSBET00gbm9kZSdzIGlubmVySFRNTC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIElEIG9mIHRoZSBub2RlIHRvIHVwZGF0ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGh0bWwgQW4gSFRNTCBzdHJpbmcuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdXBkYXRlSW5uZXJIVE1MQnlJRDogUmVhY3RQZXJmLm1lYXN1cmUoXG4gICAgJ1JlYWN0RE9NSURPcGVyYXRpb25zJyxcbiAgICAndXBkYXRlSW5uZXJIVE1MQnlJRCcsXG4gICAgZnVuY3Rpb24oaWQsIGh0bWwpIHtcbiAgICAgIHZhciBub2RlID0gUmVhY3RNb3VudC5nZXROb2RlKGlkKTtcbiAgICAgIHNldElubmVySFRNTChub2RlLCBodG1sKTtcbiAgICB9XG4gICksXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYSBET00gbm9kZSdzIHRleHQgY29udGVudCBzZXQgYnkgYHByb3BzLmNvbnRlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgb2YgdGhlIG5vZGUgdG8gdXBkYXRlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudCBUZXh0IGNvbnRlbnQuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdXBkYXRlVGV4dENvbnRlbnRCeUlEOiBSZWFjdFBlcmYubWVhc3VyZShcbiAgICAnUmVhY3RET01JRE9wZXJhdGlvbnMnLFxuICAgICd1cGRhdGVUZXh0Q29udGVudEJ5SUQnLFxuICAgIGZ1bmN0aW9uKGlkLCBjb250ZW50KSB7XG4gICAgICB2YXIgbm9kZSA9IFJlYWN0TW91bnQuZ2V0Tm9kZShpZCk7XG4gICAgICBET01DaGlsZHJlbk9wZXJhdGlvbnMudXBkYXRlVGV4dENvbnRlbnQobm9kZSwgY29udGVudCk7XG4gICAgfVxuICApLFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhIERPTSBub2RlIHRoYXQgZXhpc3RzIGluIHRoZSBkb2N1bWVudCB3aXRoIG1hcmt1cC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIElEIG9mIGNoaWxkIHRvIGJlIHJlcGxhY2VkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIERhbmdlcm91cyBtYXJrdXAgdG8gaW5qZWN0IGluIHBsYWNlIG9mIGNoaWxkLlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHNlZSB7RGFuZ2VyLmRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwfVxuICAgKi9cbiAgZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXBCeUlEOiBSZWFjdFBlcmYubWVhc3VyZShcbiAgICAnUmVhY3RET01JRE9wZXJhdGlvbnMnLFxuICAgICdkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cEJ5SUQnLFxuICAgIGZ1bmN0aW9uKGlkLCBtYXJrdXApIHtcbiAgICAgIHZhciBub2RlID0gUmVhY3RNb3VudC5nZXROb2RlKGlkKTtcbiAgICAgIERPTUNoaWxkcmVuT3BlcmF0aW9ucy5kYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cChub2RlLCBtYXJrdXApO1xuICAgIH1cbiAgKSxcblxuICAvKipcbiAgICogVXBkYXRlcyBhIGNvbXBvbmVudCdzIGNoaWxkcmVuIGJ5IHByb2Nlc3NpbmcgYSBzZXJpZXMgb2YgdXBkYXRlcy5cbiAgICpcbiAgICogQHBhcmFtIHthcnJheTxvYmplY3Q+fSB1cGRhdGVzIExpc3Qgb2YgdXBkYXRlIGNvbmZpZ3VyYXRpb25zLlxuICAgKiBAcGFyYW0ge2FycmF5PHN0cmluZz59IG1hcmt1cCBMaXN0IG9mIG1hcmt1cCBzdHJpbmdzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGRhbmdlcm91c2x5UHJvY2Vzc0NoaWxkcmVuVXBkYXRlczogUmVhY3RQZXJmLm1lYXN1cmUoXG4gICAgJ1JlYWN0RE9NSURPcGVyYXRpb25zJyxcbiAgICAnZGFuZ2Vyb3VzbHlQcm9jZXNzQ2hpbGRyZW5VcGRhdGVzJyxcbiAgICBmdW5jdGlvbih1cGRhdGVzLCBtYXJrdXApIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdXBkYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB1cGRhdGVzW2ldLnBhcmVudE5vZGUgPSBSZWFjdE1vdW50LmdldE5vZGUodXBkYXRlc1tpXS5wYXJlbnRJRCk7XG4gICAgICB9XG4gICAgICBET01DaGlsZHJlbk9wZXJhdGlvbnMucHJvY2Vzc1VwZGF0ZXModXBkYXRlcywgbWFya3VwKTtcbiAgICB9XG4gIClcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01JRE9wZXJhdGlvbnM7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUltZ1xuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKFwiLi9FdmVudENvbnN0YW50c1wiKTtcbnZhciBMb2NhbEV2ZW50VHJhcE1peGluID0gcmVxdWlyZShcIi4vTG9jYWxFdmVudFRyYXBNaXhpblwiKTtcbnZhciBSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbiA9IHJlcXVpcmUoXCIuL1JlYWN0QnJvd3NlckNvbXBvbmVudE1peGluXCIpO1xudmFyIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50ID0gcmVxdWlyZShcIi4vUmVhY3RDb21wb3NpdGVDb21wb25lbnRcIik7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKFwiLi9SZWFjdERPTVwiKTtcblxuLy8gU3RvcmUgYSByZWZlcmVuY2UgdG8gdGhlIDxpbWc+IGBSZWFjdERPTUNvbXBvbmVudGAuXG52YXIgaW1nID0gUmVhY3RET00uaW1nO1xuXG4vKipcbiAqIFNpbmNlIG9uTG9hZCBkb2Vzbid0IGJ1YmJsZSBPUiBjYXB0dXJlIG9uIHRoZSB0b3AgbGV2ZWwgaW4gSUU4LCB3ZSBuZWVkIHRvXG4gKiBjYXB0dXJlIGl0IG9uIHRoZSA8aW1nPiBlbGVtZW50IGl0c2VsZi4gVGhlcmUgYXJlIGxvdHMgb2YgaGFja3Mgd2UgY291bGQgZG9cbiAqIHRvIGFjY29tcGxpc2ggdGhpcywgYnV0IHRoZSBtb3N0IHJlbGlhYmxlIGlzIHRvIG1ha2UgPGltZz4gYSBjb21wb3NpdGVcbiAqIGNvbXBvbmVudCBhbmQgdXNlIGBjb21wb25lbnREaWRNb3VudGAgdG8gYXR0YWNoIHRoZSBldmVudCBoYW5kbGVycy5cbiAqL1xudmFyIFJlYWN0RE9NSW1nID0gUmVhY3RDb21wb3NpdGVDb21wb25lbnQuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ1JlYWN0RE9NSW1nJyxcbiAgdGFnTmFtZTogJ0lNRycsXG5cbiAgbWl4aW5zOiBbUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW4sIExvY2FsRXZlbnRUcmFwTWl4aW5dLFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGltZyh0aGlzLnByb3BzKTtcbiAgfSxcblxuICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50cmFwQnViYmxlZEV2ZW50KEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXMudG9wTG9hZCwgJ2xvYWQnKTtcbiAgICB0aGlzLnRyYXBCdWJibGVkRXZlbnQoRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcy50b3BFcnJvciwgJ2Vycm9yJyk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NSW1nO1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUlucHV0XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBBdXRvRm9jdXNNaXhpbiA9IHJlcXVpcmUoXCIuL0F1dG9Gb2N1c01peGluXCIpO1xudmFyIERPTVByb3BlcnR5T3BlcmF0aW9ucyA9IHJlcXVpcmUoXCIuL0RPTVByb3BlcnR5T3BlcmF0aW9uc1wiKTtcbnZhciBMaW5rZWRWYWx1ZVV0aWxzID0gcmVxdWlyZShcIi4vTGlua2VkVmFsdWVVdGlsc1wiKTtcbnZhciBSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbiA9IHJlcXVpcmUoXCIuL1JlYWN0QnJvd3NlckNvbXBvbmVudE1peGluXCIpO1xudmFyIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50ID0gcmVxdWlyZShcIi4vUmVhY3RDb21wb3NpdGVDb21wb25lbnRcIik7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKFwiLi9SZWFjdERPTVwiKTtcbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZShcIi4vUmVhY3RNb3VudFwiKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcbnZhciBtZXJnZSA9IHJlcXVpcmUoXCIuL21lcmdlXCIpO1xuXG4vLyBTdG9yZSBhIHJlZmVyZW5jZSB0byB0aGUgPGlucHV0PiBgUmVhY3RET01Db21wb25lbnRgLlxudmFyIGlucHV0ID0gUmVhY3RET00uaW5wdXQ7XG5cbnZhciBpbnN0YW5jZXNCeVJlYWN0SUQgPSB7fTtcblxuLyoqXG4gKiBJbXBsZW1lbnRzIGFuIDxpbnB1dD4gbmF0aXZlIGNvbXBvbmVudCB0aGF0IGFsbG93cyBzZXR0aW5nIHRoZXNlIG9wdGlvbmFsXG4gKiBwcm9wczogYGNoZWNrZWRgLCBgdmFsdWVgLCBgZGVmYXVsdENoZWNrZWRgLCBhbmQgYGRlZmF1bHRWYWx1ZWAuXG4gKlxuICogSWYgYGNoZWNrZWRgIG9yIGB2YWx1ZWAgYXJlIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnNcbiAqIHRoYXQgYWZmZWN0IHRoZSBjaGVja2VkIHN0YXRlIG9yIHZhbHVlIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIElmIHRoZXkgYXJlIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBub3RcbiAqIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC4gSW5zdGVhZCwgdGhlIHByb3BzIG11c3QgY2hhbmdlIGluIG9yZGVyIGZvclxuICogdGhlIHJlbmRlcmVkIGVsZW1lbnQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiBUaGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIGJlIGluaXRpYWxpemVkIGFzIHVuY2hlY2tlZCAob3IgYGRlZmF1bHRDaGVja2VkYClcbiAqIHdpdGggYW4gZW1wdHkgdmFsdWUgKG9yIGBkZWZhdWx0VmFsdWVgKS5cbiAqXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTIvV0QtaHRtbDUtMjAxMjEwMjUvdGhlLWlucHV0LWVsZW1lbnQuaHRtbFxuICovXG52YXIgUmVhY3RET01JbnB1dCA9IFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50LmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdSZWFjdERPTUlucHV0JyxcblxuICBtaXhpbnM6IFtBdXRvRm9jdXNNaXhpbiwgTGlua2VkVmFsdWVVdGlscy5NaXhpbiwgUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW5dLFxuXG4gIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRlZmF1bHRWYWx1ZSA9IHRoaXMucHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgIHJldHVybiB7XG4gICAgICBjaGVja2VkOiB0aGlzLnByb3BzLmRlZmF1bHRDaGVja2VkIHx8IGZhbHNlLFxuICAgICAgdmFsdWU6IGRlZmF1bHRWYWx1ZSAhPSBudWxsID8gZGVmYXVsdFZhbHVlIDogbnVsbFxuICAgIH07XG4gIH0sXG5cbiAgc2hvdWxkQ29tcG9uZW50VXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAvLyBEZWZlciBhbnkgdXBkYXRlcyB0byB0aGlzIGNvbXBvbmVudCBkdXJpbmcgdGhlIGBvbkNoYW5nZWAgaGFuZGxlci5cbiAgICByZXR1cm4gIXRoaXMuX2lzQ2hhbmdpbmc7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAvLyBDbG9uZSBgdGhpcy5wcm9wc2Agc28gd2UgZG9uJ3QgbXV0YXRlIHRoZSBpbnB1dC5cbiAgICB2YXIgcHJvcHMgPSBtZXJnZSh0aGlzLnByb3BzKTtcblxuICAgIHByb3BzLmRlZmF1bHRDaGVja2VkID0gbnVsbDtcbiAgICBwcm9wcy5kZWZhdWx0VmFsdWUgPSBudWxsO1xuXG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZSh0aGlzKTtcbiAgICBwcm9wcy52YWx1ZSA9IHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IHRoaXMuc3RhdGUudmFsdWU7XG5cbiAgICB2YXIgY2hlY2tlZCA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0Q2hlY2tlZCh0aGlzKTtcbiAgICBwcm9wcy5jaGVja2VkID0gY2hlY2tlZCAhPSBudWxsID8gY2hlY2tlZCA6IHRoaXMuc3RhdGUuY2hlY2tlZDtcblxuICAgIHByb3BzLm9uQ2hhbmdlID0gdGhpcy5faGFuZGxlQ2hhbmdlO1xuXG4gICAgcmV0dXJuIGlucHV0KHByb3BzLCB0aGlzLnByb3BzLmNoaWxkcmVuKTtcbiAgfSxcblxuICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGlkID0gUmVhY3RNb3VudC5nZXRJRCh0aGlzLmdldERPTU5vZGUoKSk7XG4gICAgaW5zdGFuY2VzQnlSZWFjdElEW2lkXSA9IHRoaXM7XG4gIH0sXG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciByb290Tm9kZSA9IHRoaXMuZ2V0RE9NTm9kZSgpO1xuICAgIHZhciBpZCA9IFJlYWN0TW91bnQuZ2V0SUQocm9vdE5vZGUpO1xuICAgIGRlbGV0ZSBpbnN0YW5jZXNCeVJlYWN0SURbaWRdO1xuICB9LFxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZTogZnVuY3Rpb24ocHJldlByb3BzLCBwcmV2U3RhdGUsIHByZXZDb250ZXh0KSB7XG4gICAgdmFyIHJvb3ROb2RlID0gdGhpcy5nZXRET01Ob2RlKCk7XG4gICAgaWYgKHRoaXMucHJvcHMuY2hlY2tlZCAhPSBudWxsKSB7XG4gICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuc2V0VmFsdWVGb3JQcm9wZXJ0eShcbiAgICAgICAgcm9vdE5vZGUsXG4gICAgICAgICdjaGVja2VkJyxcbiAgICAgICAgdGhpcy5wcm9wcy5jaGVja2VkIHx8IGZhbHNlXG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUodGhpcyk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIC8vIENhc3QgYHZhbHVlYCB0byBhIHN0cmluZyB0byBlbnN1cmUgdGhlIHZhbHVlIGlzIHNldCBjb3JyZWN0bHkuIFdoaWxlXG4gICAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG4gICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuc2V0VmFsdWVGb3JQcm9wZXJ0eShyb290Tm9kZSwgJ3ZhbHVlJywgJycgKyB2YWx1ZSk7XG4gICAgfVxuICB9LFxuXG4gIF9oYW5kbGVDaGFuZ2U6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIHJldHVyblZhbHVlO1xuICAgIHZhciBvbkNoYW5nZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0T25DaGFuZ2UodGhpcyk7XG4gICAgaWYgKG9uQ2hhbmdlKSB7XG4gICAgICB0aGlzLl9pc0NoYW5naW5nID0gdHJ1ZTtcbiAgICAgIHJldHVyblZhbHVlID0gb25DaGFuZ2UuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICB0aGlzLl9pc0NoYW5naW5nID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgY2hlY2tlZDogZXZlbnQudGFyZ2V0LmNoZWNrZWQsXG4gICAgICB2YWx1ZTogZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgfSk7XG5cbiAgICB2YXIgbmFtZSA9IHRoaXMucHJvcHMubmFtZTtcbiAgICBpZiAodGhpcy5wcm9wcy50eXBlID09PSAncmFkaW8nICYmIG5hbWUgIT0gbnVsbCkge1xuICAgICAgdmFyIHJvb3ROb2RlID0gdGhpcy5nZXRET01Ob2RlKCk7XG4gICAgICB2YXIgcXVlcnlSb290ID0gcm9vdE5vZGU7XG5cbiAgICAgIHdoaWxlIChxdWVyeVJvb3QucGFyZW50Tm9kZSkge1xuICAgICAgICBxdWVyeVJvb3QgPSBxdWVyeVJvb3QucGFyZW50Tm9kZTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgYHJvb3ROb2RlLmZvcm1gIHdhcyBub24tbnVsbCwgdGhlbiB3ZSBjb3VsZCB0cnkgYGZvcm0uZWxlbWVudHNgLFxuICAgICAgLy8gYnV0IHRoYXQgc29tZXRpbWVzIGJlaGF2ZXMgc3RyYW5nZWx5IGluIElFOC4gV2UgY291bGQgYWxzbyB0cnkgdXNpbmdcbiAgICAgIC8vIGBmb3JtLmdldEVsZW1lbnRzQnlOYW1lYCwgYnV0IHRoYXQgd2lsbCBvbmx5IHJldHVybiBkaXJlY3QgY2hpbGRyZW5cbiAgICAgIC8vIGFuZCB3b24ndCBpbmNsdWRlIGlucHV0cyB0aGF0IHVzZSB0aGUgSFRNTDUgYGZvcm09YCBhdHRyaWJ1dGUuIFNpbmNlXG4gICAgICAvLyB0aGUgaW5wdXQgbWlnaHQgbm90IGV2ZW4gYmUgaW4gYSBmb3JtLCBsZXQncyBqdXN0IHVzZSB0aGUgZ2xvYmFsXG4gICAgICAvLyBgcXVlcnlTZWxlY3RvckFsbGAgdG8gZW5zdXJlIHdlIGRvbid0IG1pc3MgYW55dGhpbmcuXG4gICAgICB2YXIgZ3JvdXAgPSBxdWVyeVJvb3QucXVlcnlTZWxlY3RvckFsbChcbiAgICAgICAgJ2lucHV0W25hbWU9JyArIEpTT04uc3RyaW5naWZ5KCcnICsgbmFtZSkgKyAnXVt0eXBlPVwicmFkaW9cIl0nKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGdyb3VwTGVuID0gZ3JvdXAubGVuZ3RoOyBpIDwgZ3JvdXBMZW47IGkrKykge1xuICAgICAgICB2YXIgb3RoZXJOb2RlID0gZ3JvdXBbaV07XG4gICAgICAgIGlmIChvdGhlck5vZGUgPT09IHJvb3ROb2RlIHx8XG4gICAgICAgICAgICBvdGhlck5vZGUuZm9ybSAhPT0gcm9vdE5vZGUuZm9ybSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdGhlcklEID0gUmVhY3RNb3VudC5nZXRJRChvdGhlck5vZGUpO1xuICAgICAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgICAgIG90aGVySUQsXG4gICAgICAgICAgJ1JlYWN0RE9NSW5wdXQ6IE1peGluZyBSZWFjdCBhbmQgbm9uLVJlYWN0IHJhZGlvIGlucHV0cyB3aXRoIHRoZSAnICtcbiAgICAgICAgICAnc2FtZSBgbmFtZWAgaXMgbm90IHN1cHBvcnRlZC4nXG4gICAgICAgICkgOiBpbnZhcmlhbnQob3RoZXJJRCkpO1xuICAgICAgICB2YXIgb3RoZXJJbnN0YW5jZSA9IGluc3RhbmNlc0J5UmVhY3RJRFtvdGhlcklEXTtcbiAgICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICAgICBvdGhlckluc3RhbmNlLFxuICAgICAgICAgICdSZWFjdERPTUlucHV0OiBVbmtub3duIHJhZGlvIGJ1dHRvbiBJRCAlcy4nLFxuICAgICAgICAgIG90aGVySURcbiAgICAgICAgKSA6IGludmFyaWFudChvdGhlckluc3RhbmNlKSk7XG4gICAgICAgIC8vIEluIHNvbWUgY2FzZXMsIHRoaXMgd2lsbCBhY3R1YWxseSBjaGFuZ2UgdGhlIGBjaGVja2VkYCBzdGF0ZSB2YWx1ZS5cbiAgICAgICAgLy8gSW4gb3RoZXIgY2FzZXMsIHRoZXJlJ3Mgbm8gY2hhbmdlIGJ1dCB0aGlzIGZvcmNlcyBhIHJlY29uY2lsZSB1cG9uXG4gICAgICAgIC8vIHdoaWNoIGNvbXBvbmVudERpZFVwZGF0ZSB3aWxsIHJlc2V0IHRoZSBET00gcHJvcGVydHkgdG8gd2hhdGV2ZXIgaXRcbiAgICAgICAgLy8gc2hvdWxkIGJlLlxuICAgICAgICBvdGhlckluc3RhbmNlLnNldFN0YXRlKHtcbiAgICAgICAgICBjaGVja2VkOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01JbnB1dDtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTU9wdGlvblxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW4gPSByZXF1aXJlKFwiLi9SZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpblwiKTtcbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCA9IHJlcXVpcmUoXCIuL1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50XCIpO1xudmFyIFJlYWN0RE9NID0gcmVxdWlyZShcIi4vUmVhY3RET01cIik7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZShcIi4vd2FybmluZ1wiKTtcblxuLy8gU3RvcmUgYSByZWZlcmVuY2UgdG8gdGhlIDxvcHRpb24+IGBSZWFjdERPTUNvbXBvbmVudGAuXG52YXIgb3B0aW9uID0gUmVhY3RET00ub3B0aW9uO1xuXG4vKipcbiAqIEltcGxlbWVudHMgYW4gPG9wdGlvbj4gbmF0aXZlIGNvbXBvbmVudCB0aGF0IHdhcm5zIHdoZW4gYHNlbGVjdGVkYCBpcyBzZXQuXG4gKi9cbnZhciBSZWFjdERPTU9wdGlvbiA9IFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50LmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdSZWFjdERPTU9wdGlvbicsXG5cbiAgbWl4aW5zOiBbUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW5dLFxuXG4gIGNvbXBvbmVudFdpbGxNb3VudDogZnVuY3Rpb24oKSB7XG4gICAgLy8gVE9ETyAoeXVuZ3N0ZXJzKTogUmVtb3ZlIHN1cHBvcnQgZm9yIGBzZWxlY3RlZGAgaW4gPG9wdGlvbj4uXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcoXG4gICAgICAgIHRoaXMucHJvcHMuc2VsZWN0ZWQgPT0gbnVsbCxcbiAgICAgICAgJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBvbiA8c2VsZWN0PiBpbnN0ZWFkIG9mICcgK1xuICAgICAgICAnc2V0dGluZyBgc2VsZWN0ZWRgIG9uIDxvcHRpb24+LidcbiAgICAgICkgOiBudWxsKTtcbiAgICB9XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gb3B0aW9uKHRoaXMucHJvcHMsIHRoaXMucHJvcHMuY2hpbGRyZW4pO1xuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NT3B0aW9uO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01TZWxlY3RcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIEF1dG9Gb2N1c01peGluID0gcmVxdWlyZShcIi4vQXV0b0ZvY3VzTWl4aW5cIik7XG52YXIgTGlua2VkVmFsdWVVdGlscyA9IHJlcXVpcmUoXCIuL0xpbmtlZFZhbHVlVXRpbHNcIik7XG52YXIgUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW4gPSByZXF1aXJlKFwiLi9SZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpblwiKTtcbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCA9IHJlcXVpcmUoXCIuL1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50XCIpO1xudmFyIFJlYWN0RE9NID0gcmVxdWlyZShcIi4vUmVhY3RET01cIik7XG5cbnZhciBtZXJnZSA9IHJlcXVpcmUoXCIuL21lcmdlXCIpO1xuXG4vLyBTdG9yZSBhIHJlZmVyZW5jZSB0byB0aGUgPHNlbGVjdD4gYFJlYWN0RE9NQ29tcG9uZW50YC5cbnZhciBzZWxlY3QgPSBSZWFjdERPTS5zZWxlY3Q7XG5cbi8qKlxuICogVmFsaWRhdGlvbiBmdW5jdGlvbiBmb3IgYHZhbHVlYCBhbmQgYGRlZmF1bHRWYWx1ZWAuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZWxlY3RWYWx1ZVR5cGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocHJvcHMubXVsdGlwbGUpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICAgICAgKFwiVGhlIGBcIiArIHByb3BOYW1lICsgXCJgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhbiBhcnJheSBpZiBcIikgK1xuICAgICAgICAoXCJgbXVsdGlwbGVgIGlzIHRydWUuXCIpXG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgICAgICAoXCJUaGUgYFwiICsgcHJvcE5hbWUgKyBcImAgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGEgc2NhbGFyIFwiKSArXG4gICAgICAgIChcInZhbHVlIGlmIGBtdWx0aXBsZWAgaXMgZmFsc2UuXCIpXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIElmIGB2YWx1ZWAgaXMgc3VwcGxpZWQsIHVwZGF0ZXMgPG9wdGlvbj4gZWxlbWVudHMgb24gbW91bnQgYW5kIHVwZGF0ZS5cbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudCBJbnN0YW5jZSBvZiBSZWFjdERPTVNlbGVjdFxuICogQHBhcmFtIHs/Kn0gcHJvcFZhbHVlIEZvciB1bmNvbnRyb2xsZWQgY29tcG9uZW50cywgbnVsbC91bmRlZmluZWQuIEZvclxuICogY29udHJvbGxlZCBjb21wb25lbnRzLCBhIHN0cmluZyAob3Igd2l0aCBgbXVsdGlwbGVgLCBhIGxpc3Qgb2Ygc3RyaW5ncykuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB1cGRhdGVPcHRpb25zKGNvbXBvbmVudCwgcHJvcFZhbHVlKSB7XG4gIHZhciBtdWx0aXBsZSA9IGNvbXBvbmVudC5wcm9wcy5tdWx0aXBsZTtcbiAgdmFyIHZhbHVlID0gcHJvcFZhbHVlICE9IG51bGwgPyBwcm9wVmFsdWUgOiBjb21wb25lbnQuc3RhdGUudmFsdWU7XG4gIHZhciBvcHRpb25zID0gY29tcG9uZW50LmdldERPTU5vZGUoKS5vcHRpb25zO1xuICB2YXIgc2VsZWN0ZWRWYWx1ZSwgaSwgbDtcbiAgaWYgKG11bHRpcGxlKSB7XG4gICAgc2VsZWN0ZWRWYWx1ZSA9IHt9O1xuICAgIGZvciAoaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgIHNlbGVjdGVkVmFsdWVbJycgKyB2YWx1ZVtpXV0gPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzZWxlY3RlZFZhbHVlID0gJycgKyB2YWx1ZTtcbiAgfVxuICBmb3IgKGkgPSAwLCBsID0gb3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgc2VsZWN0ZWQgPSBtdWx0aXBsZSA/XG4gICAgICBzZWxlY3RlZFZhbHVlLmhhc093blByb3BlcnR5KG9wdGlvbnNbaV0udmFsdWUpIDpcbiAgICAgIG9wdGlvbnNbaV0udmFsdWUgPT09IHNlbGVjdGVkVmFsdWU7XG5cbiAgICBpZiAoc2VsZWN0ZWQgIT09IG9wdGlvbnNbaV0uc2VsZWN0ZWQpIHtcbiAgICAgIG9wdGlvbnNbaV0uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgPHNlbGVjdD4gbmF0aXZlIGNvbXBvbmVudCB0aGF0IGFsbG93cyBvcHRpb25hbGx5IHNldHRpbmcgdGhlXG4gKiBwcm9wcyBgdmFsdWVgIGFuZCBgZGVmYXVsdFZhbHVlYC4gSWYgYG11bHRpcGxlYCBpcyBmYWxzZSwgdGhlIHByb3AgbXVzdCBiZSBhXG4gKiBzdHJpbmcuIElmIGBtdWx0aXBsZWAgaXMgdHJ1ZSwgdGhlIHByb3AgbXVzdCBiZSBhbiBhcnJheSBvZiBzdHJpbmdzLlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9ucyB0aGF0IGNoYW5nZSB0aGVcbiAqIHNlbGVjdGVkIG9wdGlvbiB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cbiAqXG4gKiBJZiBpdCBpcyBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBvcHRpb25zIHdpbGwgbm90XG4gKiB1cGRhdGUgaW4gcmVzcG9uc2UgdG8gdXNlciBhY3Rpb25zLiBJbnN0ZWFkLCB0aGUgYHZhbHVlYCBwcm9wIG11c3QgY2hhbmdlIGluXG4gKiBvcmRlciBmb3IgdGhlIHJlbmRlcmVkIG9wdGlvbnMgdG8gdXBkYXRlLlxuICpcbiAqIElmIGBkZWZhdWx0VmFsdWVgIGlzIHByb3ZpZGVkLCBhbnkgb3B0aW9ucyB3aXRoIHRoZSBzdXBwbGllZCB2YWx1ZXMgd2lsbCBiZVxuICogc2VsZWN0ZWQuXG4gKi9cbnZhciBSZWFjdERPTVNlbGVjdCA9IFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50LmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdSZWFjdERPTVNlbGVjdCcsXG5cbiAgbWl4aW5zOiBbQXV0b0ZvY3VzTWl4aW4sIExpbmtlZFZhbHVlVXRpbHMuTWl4aW4sIFJlYWN0QnJvd3NlckNvbXBvbmVudE1peGluXSxcblxuICBwcm9wVHlwZXM6IHtcbiAgICBkZWZhdWx0VmFsdWU6IHNlbGVjdFZhbHVlVHlwZSxcbiAgICB2YWx1ZTogc2VsZWN0VmFsdWVUeXBlXG4gIH0sXG5cbiAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge3ZhbHVlOiB0aGlzLnByb3BzLmRlZmF1bHRWYWx1ZSB8fCAodGhpcy5wcm9wcy5tdWx0aXBsZSA/IFtdIDogJycpfTtcbiAgfSxcblxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbihuZXh0UHJvcHMpIHtcbiAgICBpZiAoIXRoaXMucHJvcHMubXVsdGlwbGUgJiYgbmV4dFByb3BzLm11bHRpcGxlKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHt2YWx1ZTogW3RoaXMuc3RhdGUudmFsdWVdfSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnByb3BzLm11bHRpcGxlICYmICFuZXh0UHJvcHMubXVsdGlwbGUpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe3ZhbHVlOiB0aGlzLnN0YXRlLnZhbHVlWzBdfSk7XG4gICAgfVxuICB9LFxuXG4gIHNob3VsZENvbXBvbmVudFVwZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgLy8gRGVmZXIgYW55IHVwZGF0ZXMgdG8gdGhpcyBjb21wb25lbnQgZHVyaW5nIHRoZSBgb25DaGFuZ2VgIGhhbmRsZXIuXG4gICAgcmV0dXJuICF0aGlzLl9pc0NoYW5naW5nO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgLy8gQ2xvbmUgYHRoaXMucHJvcHNgIHNvIHdlIGRvbid0IG11dGF0ZSB0aGUgaW5wdXQuXG4gICAgdmFyIHByb3BzID0gbWVyZ2UodGhpcy5wcm9wcyk7XG5cbiAgICBwcm9wcy5vbkNoYW5nZSA9IHRoaXMuX2hhbmRsZUNoYW5nZTtcbiAgICBwcm9wcy52YWx1ZSA9IG51bGw7XG5cbiAgICByZXR1cm4gc2VsZWN0KHByb3BzLCB0aGlzLnByb3BzLmNoaWxkcmVuKTtcbiAgfSxcblxuICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24oKSB7XG4gICAgdXBkYXRlT3B0aW9ucyh0aGlzLCBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHRoaXMpKTtcbiAgfSxcblxuICBjb21wb25lbnREaWRVcGRhdGU6IGZ1bmN0aW9uKHByZXZQcm9wcykge1xuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUodGhpcyk7XG4gICAgdmFyIHByZXZNdWx0aXBsZSA9ICEhcHJldlByb3BzLm11bHRpcGxlO1xuICAgIHZhciBtdWx0aXBsZSA9ICEhdGhpcy5wcm9wcy5tdWx0aXBsZTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCB8fCBwcmV2TXVsdGlwbGUgIT09IG11bHRpcGxlKSB7XG4gICAgICB1cGRhdGVPcHRpb25zKHRoaXMsIHZhbHVlKTtcbiAgICB9XG4gIH0sXG5cbiAgX2hhbmRsZUNoYW5nZTogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgcmV0dXJuVmFsdWU7XG4gICAgdmFyIG9uQ2hhbmdlID0gTGlua2VkVmFsdWVVdGlscy5nZXRPbkNoYW5nZSh0aGlzKTtcbiAgICBpZiAob25DaGFuZ2UpIHtcbiAgICAgIHRoaXMuX2lzQ2hhbmdpbmcgPSB0cnVlO1xuICAgICAgcmV0dXJuVmFsdWUgPSBvbkNoYW5nZS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgIHRoaXMuX2lzQ2hhbmdpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgc2VsZWN0ZWRWYWx1ZTtcbiAgICBpZiAodGhpcy5wcm9wcy5tdWx0aXBsZSkge1xuICAgICAgc2VsZWN0ZWRWYWx1ZSA9IFtdO1xuICAgICAgdmFyIG9wdGlvbnMgPSBldmVudC50YXJnZXQub3B0aW9ucztcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gb3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKG9wdGlvbnNbaV0uc2VsZWN0ZWQpIHtcbiAgICAgICAgICBzZWxlY3RlZFZhbHVlLnB1c2gob3B0aW9uc1tpXS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZWN0ZWRWYWx1ZSA9IGV2ZW50LnRhcmdldC52YWx1ZTtcbiAgICB9XG5cbiAgICB0aGlzLnNldFN0YXRlKHt2YWx1ZTogc2VsZWN0ZWRWYWx1ZX0pO1xuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVNlbGVjdDtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTVNlbGVjdGlvblxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKFwiLi9FeGVjdXRpb25FbnZpcm9ubWVudFwiKTtcblxudmFyIGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQgPSByZXF1aXJlKFwiLi9nZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0XCIpO1xudmFyIGdldFRleHRDb250ZW50QWNjZXNzb3IgPSByZXF1aXJlKFwiLi9nZXRUZXh0Q29udGVudEFjY2Vzc29yXCIpO1xuXG4vKipcbiAqIFdoaWxlIGBpc0NvbGxhcHNlZGAgaXMgYXZhaWxhYmxlIG9uIHRoZSBTZWxlY3Rpb24gb2JqZWN0IGFuZCBgY29sbGFwc2VkYFxuICogaXMgYXZhaWxhYmxlIG9uIHRoZSBSYW5nZSBvYmplY3QsIElFMTEgc29tZXRpbWVzIGdldHMgdGhlbSB3cm9uZy5cbiAqIElmIHRoZSBhbmNob3IvZm9jdXMgbm9kZXMgYW5kIG9mZnNldHMgYXJlIHRoZSBzYW1lLCB0aGUgcmFuZ2UgaXMgY29sbGFwc2VkLlxuICovXG5mdW5jdGlvbiBpc0NvbGxhcHNlZChhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpIHtcbiAgcmV0dXJuIGFuY2hvck5vZGUgPT09IGZvY3VzTm9kZSAmJiBhbmNob3JPZmZzZXQgPT09IGZvY3VzT2Zmc2V0O1xufVxuXG4vKipcbiAqIEdldCB0aGUgYXBwcm9wcmlhdGUgYW5jaG9yIGFuZCBmb2N1cyBub2RlL29mZnNldCBwYWlycyBmb3IgSUUuXG4gKlxuICogVGhlIGNhdGNoIGhlcmUgaXMgdGhhdCBJRSdzIHNlbGVjdGlvbiBBUEkgZG9lc24ndCBwcm92aWRlIGluZm9ybWF0aW9uXG4gKiBhYm91dCB3aGV0aGVyIHRoZSBzZWxlY3Rpb24gaXMgZm9yd2FyZCBvciBiYWNrd2FyZCwgc28gd2UgaGF2ZSB0b1xuICogYmVoYXZlIGFzIHRob3VnaCBpdCdzIGFsd2F5cyBmb3J3YXJkLlxuICpcbiAqIElFIHRleHQgZGlmZmVycyBmcm9tIG1vZGVybiBzZWxlY3Rpb24gaW4gdGhhdCBpdCBiZWhhdmVzIGFzIHRob3VnaFxuICogYmxvY2sgZWxlbWVudHMgZW5kIHdpdGggYSBuZXcgbGluZS4gVGhpcyBtZWFucyBjaGFyYWN0ZXIgb2Zmc2V0cyB3aWxsXG4gKiBkaWZmZXIgYmV0d2VlbiB0aGUgdHdvIEFQSXMuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldElFT2Zmc2V0cyhub2RlKSB7XG4gIHZhciBzZWxlY3Rpb24gPSBkb2N1bWVudC5zZWxlY3Rpb247XG4gIHZhciBzZWxlY3RlZFJhbmdlID0gc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gIHZhciBzZWxlY3RlZExlbmd0aCA9IHNlbGVjdGVkUmFuZ2UudGV4dC5sZW5ndGg7XG5cbiAgLy8gRHVwbGljYXRlIHNlbGVjdGlvbiBzbyB3ZSBjYW4gbW92ZSByYW5nZSB3aXRob3V0IGJyZWFraW5nIHVzZXIgc2VsZWN0aW9uLlxuICB2YXIgZnJvbVN0YXJ0ID0gc2VsZWN0ZWRSYW5nZS5kdXBsaWNhdGUoKTtcbiAgZnJvbVN0YXJ0Lm1vdmVUb0VsZW1lbnRUZXh0KG5vZGUpO1xuICBmcm9tU3RhcnQuc2V0RW5kUG9pbnQoJ0VuZFRvU3RhcnQnLCBzZWxlY3RlZFJhbmdlKTtcblxuICB2YXIgc3RhcnRPZmZzZXQgPSBmcm9tU3RhcnQudGV4dC5sZW5ndGg7XG4gIHZhciBlbmRPZmZzZXQgPSBzdGFydE9mZnNldCArIHNlbGVjdGVkTGVuZ3RoO1xuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHN0YXJ0T2Zmc2V0LFxuICAgIGVuZDogZW5kT2Zmc2V0XG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRNb2Rlcm5PZmZzZXRzKG5vZGUpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcblxuICBpZiAoc2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBhbmNob3JOb2RlID0gc2VsZWN0aW9uLmFuY2hvck5vZGU7XG4gIHZhciBhbmNob3JPZmZzZXQgPSBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0O1xuICB2YXIgZm9jdXNOb2RlID0gc2VsZWN0aW9uLmZvY3VzTm9kZTtcbiAgdmFyIGZvY3VzT2Zmc2V0ID0gc2VsZWN0aW9uLmZvY3VzT2Zmc2V0O1xuXG4gIHZhciBjdXJyZW50UmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcblxuICAvLyBJZiB0aGUgbm9kZSBhbmQgb2Zmc2V0IHZhbHVlcyBhcmUgdGhlIHNhbWUsIHRoZSBzZWxlY3Rpb24gaXMgY29sbGFwc2VkLlxuICAvLyBgU2VsZWN0aW9uLmlzQ29sbGFwc2VkYCBpcyBhdmFpbGFibGUgbmF0aXZlbHksIGJ1dCBJRSBzb21ldGltZXMgZ2V0c1xuICAvLyB0aGlzIHZhbHVlIHdyb25nLlxuICB2YXIgaXNTZWxlY3Rpb25Db2xsYXBzZWQgPSBpc0NvbGxhcHNlZChcbiAgICBzZWxlY3Rpb24uYW5jaG9yTm9kZSxcbiAgICBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LFxuICAgIHNlbGVjdGlvbi5mb2N1c05vZGUsXG4gICAgc2VsZWN0aW9uLmZvY3VzT2Zmc2V0XG4gICk7XG5cbiAgdmFyIHJhbmdlTGVuZ3RoID0gaXNTZWxlY3Rpb25Db2xsYXBzZWQgPyAwIDogY3VycmVudFJhbmdlLnRvU3RyaW5nKCkubGVuZ3RoO1xuXG4gIHZhciB0ZW1wUmFuZ2UgPSBjdXJyZW50UmFuZ2UuY2xvbmVSYW5nZSgpO1xuICB0ZW1wUmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKG5vZGUpO1xuICB0ZW1wUmFuZ2Uuc2V0RW5kKGN1cnJlbnRSYW5nZS5zdGFydENvbnRhaW5lciwgY3VycmVudFJhbmdlLnN0YXJ0T2Zmc2V0KTtcblxuICB2YXIgaXNUZW1wUmFuZ2VDb2xsYXBzZWQgPSBpc0NvbGxhcHNlZChcbiAgICB0ZW1wUmFuZ2Uuc3RhcnRDb250YWluZXIsXG4gICAgdGVtcFJhbmdlLnN0YXJ0T2Zmc2V0LFxuICAgIHRlbXBSYW5nZS5lbmRDb250YWluZXIsXG4gICAgdGVtcFJhbmdlLmVuZE9mZnNldFxuICApO1xuXG4gIHZhciBzdGFydCA9IGlzVGVtcFJhbmdlQ29sbGFwc2VkID8gMCA6IHRlbXBSYW5nZS50b1N0cmluZygpLmxlbmd0aDtcbiAgdmFyIGVuZCA9IHN0YXJ0ICsgcmFuZ2VMZW5ndGg7XG5cbiAgLy8gRGV0ZWN0IHdoZXRoZXIgdGhlIHNlbGVjdGlvbiBpcyBiYWNrd2FyZC5cbiAgdmFyIGRldGVjdGlvblJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgZGV0ZWN0aW9uUmFuZ2Uuc2V0U3RhcnQoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0KTtcbiAgZGV0ZWN0aW9uUmFuZ2Uuc2V0RW5kKGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpO1xuICB2YXIgaXNCYWNrd2FyZCA9IGRldGVjdGlvblJhbmdlLmNvbGxhcHNlZDtcbiAgZGV0ZWN0aW9uUmFuZ2UuZGV0YWNoKCk7XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogaXNCYWNrd2FyZCA/IGVuZCA6IHN0YXJ0LFxuICAgIGVuZDogaXNCYWNrd2FyZCA/IHN0YXJ0IDogZW5kXG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gb2Zmc2V0c1xuICovXG5mdW5jdGlvbiBzZXRJRU9mZnNldHMobm9kZSwgb2Zmc2V0cykge1xuICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKS5kdXBsaWNhdGUoKTtcbiAgdmFyIHN0YXJ0LCBlbmQ7XG5cbiAgaWYgKHR5cGVvZiBvZmZzZXRzLmVuZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBzdGFydCA9IG9mZnNldHMuc3RhcnQ7XG4gICAgZW5kID0gc3RhcnQ7XG4gIH0gZWxzZSBpZiAob2Zmc2V0cy5zdGFydCA+IG9mZnNldHMuZW5kKSB7XG4gICAgc3RhcnQgPSBvZmZzZXRzLmVuZDtcbiAgICBlbmQgPSBvZmZzZXRzLnN0YXJ0O1xuICB9IGVsc2Uge1xuICAgIHN0YXJ0ID0gb2Zmc2V0cy5zdGFydDtcbiAgICBlbmQgPSBvZmZzZXRzLmVuZDtcbiAgfVxuXG4gIHJhbmdlLm1vdmVUb0VsZW1lbnRUZXh0KG5vZGUpO1xuICByYW5nZS5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIHN0YXJ0KTtcbiAgcmFuZ2Uuc2V0RW5kUG9pbnQoJ0VuZFRvU3RhcnQnLCByYW5nZSk7XG4gIHJhbmdlLm1vdmVFbmQoJ2NoYXJhY3RlcicsIGVuZCAtIHN0YXJ0KTtcbiAgcmFuZ2Uuc2VsZWN0KCk7XG59XG5cbi8qKlxuICogSW4gbW9kZXJuIG5vbi1JRSBicm93c2Vycywgd2UgY2FuIHN1cHBvcnQgYm90aCBmb3J3YXJkIGFuZCBiYWNrd2FyZFxuICogc2VsZWN0aW9ucy5cbiAqXG4gKiBOb3RlOiBJRTEwKyBzdXBwb3J0cyB0aGUgU2VsZWN0aW9uIG9iamVjdCwgYnV0IGl0IGRvZXMgbm90IHN1cHBvcnRcbiAqIHRoZSBgZXh0ZW5kYCBtZXRob2QsIHdoaWNoIG1lYW5zIHRoYXQgZXZlbiBpbiBtb2Rlcm4gSUUsIGl0J3Mgbm90IHBvc3NpYmxlXG4gKiB0byBwcm9ncmFtYXRpY2FsbHkgY3JlYXRlIGEgYmFja3dhcmQgc2VsZWN0aW9uLiBUaHVzLCBmb3IgYWxsIElFXG4gKiB2ZXJzaW9ucywgd2UgdXNlIHRoZSBvbGQgSUUgQVBJIHRvIGNyZWF0ZSBvdXIgc2VsZWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvZmZzZXRzXG4gKi9cbmZ1bmN0aW9uIHNldE1vZGVybk9mZnNldHMobm9kZSwgb2Zmc2V0cykge1xuICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuXG4gIHZhciBsZW5ndGggPSBub2RlW2dldFRleHRDb250ZW50QWNjZXNzb3IoKV0ubGVuZ3RoO1xuICB2YXIgc3RhcnQgPSBNYXRoLm1pbihvZmZzZXRzLnN0YXJ0LCBsZW5ndGgpO1xuICB2YXIgZW5kID0gdHlwZW9mIG9mZnNldHMuZW5kID09PSAndW5kZWZpbmVkJyA/XG4gICAgICAgICAgICBzdGFydCA6IE1hdGgubWluKG9mZnNldHMuZW5kLCBsZW5ndGgpO1xuXG4gIC8vIElFIDExIHVzZXMgbW9kZXJuIHNlbGVjdGlvbiwgYnV0IGRvZXNuJ3Qgc3VwcG9ydCB0aGUgZXh0ZW5kIG1ldGhvZC5cbiAgLy8gRmxpcCBiYWNrd2FyZCBzZWxlY3Rpb25zLCBzbyB3ZSBjYW4gc2V0IHdpdGggYSBzaW5nbGUgcmFuZ2UuXG4gIGlmICghc2VsZWN0aW9uLmV4dGVuZCAmJiBzdGFydCA+IGVuZCkge1xuICAgIHZhciB0ZW1wID0gZW5kO1xuICAgIGVuZCA9IHN0YXJ0O1xuICAgIHN0YXJ0ID0gdGVtcDtcbiAgfVxuXG4gIHZhciBzdGFydE1hcmtlciA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQobm9kZSwgc3RhcnQpO1xuICB2YXIgZW5kTWFya2VyID0gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChub2RlLCBlbmQpO1xuXG4gIGlmIChzdGFydE1hcmtlciAmJiBlbmRNYXJrZXIpIHtcbiAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgIHJhbmdlLnNldFN0YXJ0KHN0YXJ0TWFya2VyLm5vZGUsIHN0YXJ0TWFya2VyLm9mZnNldCk7XG4gICAgc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuXG4gICAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgc2VsZWN0aW9uLmV4dGVuZChlbmRNYXJrZXIubm9kZSwgZW5kTWFya2VyLm9mZnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmdlLnNldEVuZChlbmRNYXJrZXIubm9kZSwgZW5kTWFya2VyLm9mZnNldCk7XG4gICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICAgIH1cblxuICAgIHJhbmdlLmRldGFjaCgpO1xuICB9XG59XG5cbnZhciB1c2VJRU9mZnNldHMgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgZG9jdW1lbnQuc2VsZWN0aW9uO1xuXG52YXIgUmVhY3RET01TZWxlY3Rpb24gPSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAgICovXG4gIGdldE9mZnNldHM6IHVzZUlFT2Zmc2V0cyA/IGdldElFT2Zmc2V0cyA6IGdldE1vZGVybk9mZnNldHMsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICAgKiBAcGFyYW0ge29iamVjdH0gb2Zmc2V0c1xuICAgKi9cbiAgc2V0T2Zmc2V0czogdXNlSUVPZmZzZXRzID8gc2V0SUVPZmZzZXRzIDogc2V0TW9kZXJuT2Zmc2V0c1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVNlbGVjdGlvbjtcbiIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01UZXh0YXJlYVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgQXV0b0ZvY3VzTWl4aW4gPSByZXF1aXJlKFwiLi9BdXRvRm9jdXNNaXhpblwiKTtcbnZhciBET01Qcm9wZXJ0eU9wZXJhdGlvbnMgPSByZXF1aXJlKFwiLi9ET01Qcm9wZXJ0eU9wZXJhdGlvbnNcIik7XG52YXIgTGlua2VkVmFsdWVVdGlscyA9IHJlcXVpcmUoXCIuL0xpbmtlZFZhbHVlVXRpbHNcIik7XG52YXIgUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW4gPSByZXF1aXJlKFwiLi9SZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpblwiKTtcbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCA9IHJlcXVpcmUoXCIuL1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50XCIpO1xudmFyIFJlYWN0RE9NID0gcmVxdWlyZShcIi4vUmVhY3RET01cIik7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG52YXIgbWVyZ2UgPSByZXF1aXJlKFwiLi9tZXJnZVwiKTtcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKFwiLi93YXJuaW5nXCIpO1xuXG4vLyBTdG9yZSBhIHJlZmVyZW5jZSB0byB0aGUgPHRleHRhcmVhPiBgUmVhY3RET01Db21wb25lbnRgLlxudmFyIHRleHRhcmVhID0gUmVhY3RET00udGV4dGFyZWE7XG5cbi8qKlxuICogSW1wbGVtZW50cyBhIDx0ZXh0YXJlYT4gbmF0aXZlIGNvbXBvbmVudCB0aGF0IGFsbG93cyBzZXR0aW5nIGB2YWx1ZWAsIGFuZFxuICogYGRlZmF1bHRWYWx1ZWAuIFRoaXMgZGlmZmVycyBmcm9tIHRoZSB0cmFkaXRpb25hbCBET00gQVBJIGJlY2F1c2UgdmFsdWUgaXNcbiAqIHVzdWFsbHkgc2V0IGFzIFBDREFUQSBjaGlsZHJlbi5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnMgdGhhdCBhZmZlY3QgdGhlXG4gKiB2YWx1ZSB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbFxuICogbm90IHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC4gSW5zdGVhZCwgdGhlIGB2YWx1ZWAgcHJvcCBtdXN0IGNoYW5nZSBpblxuICogb3JkZXIgZm9yIHRoZSByZW5kZXJlZCBlbGVtZW50IHRvIGJlIHVwZGF0ZWQuXG4gKlxuICogVGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBiZSBpbml0aWFsaXplZCB3aXRoIGFuIGVtcHR5IHZhbHVlLCB0aGUgcHJvcFxuICogYGRlZmF1bHRWYWx1ZWAgaWYgc3BlY2lmaWVkLCBvciB0aGUgY2hpbGRyZW4gY29udGVudCAoZGVwcmVjYXRlZCkuXG4gKi9cbnZhciBSZWFjdERPTVRleHRhcmVhID0gUmVhY3RDb21wb3NpdGVDb21wb25lbnQuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ1JlYWN0RE9NVGV4dGFyZWEnLFxuXG4gIG1peGluczogW0F1dG9Gb2N1c01peGluLCBMaW5rZWRWYWx1ZVV0aWxzLk1peGluLCBSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbl0sXG5cbiAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGVmYXVsdFZhbHVlID0gdGhpcy5wcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgLy8gVE9ETyAoeXVuZ3N0ZXJzKTogUmVtb3ZlIHN1cHBvcnQgZm9yIGNoaWxkcmVuIGNvbnRlbnQgaW4gPHRleHRhcmVhPi5cbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICAgIGlmIChjaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICdVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgaW5zdGVhZCBvZiBzZXR0aW5nICcgK1xuICAgICAgICAgICdjaGlsZHJlbiBvbiA8dGV4dGFyZWE+LidcbiAgICAgICAgKSA6IG51bGwpO1xuICAgICAgfVxuICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICAgZGVmYXVsdFZhbHVlID09IG51bGwsXG4gICAgICAgICdJZiB5b3Ugc3VwcGx5IGBkZWZhdWx0VmFsdWVgIG9uIGEgPHRleHRhcmVhPiwgZG8gbm90IHBhc3MgY2hpbGRyZW4uJ1xuICAgICAgKSA6IGludmFyaWFudChkZWZhdWx0VmFsdWUgPT0gbnVsbCkpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAgICAgY2hpbGRyZW4ubGVuZ3RoIDw9IDEsXG4gICAgICAgICAgJzx0ZXh0YXJlYT4gY2FuIG9ubHkgaGF2ZSBhdCBtb3N0IG9uZSBjaGlsZC4nXG4gICAgICAgICkgOiBpbnZhcmlhbnQoY2hpbGRyZW4ubGVuZ3RoIDw9IDEpKTtcbiAgICAgICAgY2hpbGRyZW4gPSBjaGlsZHJlblswXTtcbiAgICAgIH1cblxuICAgICAgZGVmYXVsdFZhbHVlID0gJycgKyBjaGlsZHJlbjtcbiAgICB9XG4gICAgaWYgKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICBkZWZhdWx0VmFsdWUgPSAnJztcbiAgICB9XG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZSh0aGlzKTtcbiAgICByZXR1cm4ge1xuICAgICAgLy8gV2Ugc2F2ZSB0aGUgaW5pdGlhbCB2YWx1ZSBzbyB0aGF0IGBSZWFjdERPTUNvbXBvbmVudGAgZG9lc24ndCB1cGRhdGVcbiAgICAgIC8vIGB0ZXh0Q29udGVudGAgKHVubmVjZXNzYXJ5IHNpbmNlIHdlIHVwZGF0ZSB2YWx1ZSkuXG4gICAgICAvLyBUaGUgaW5pdGlhbCB2YWx1ZSBjYW4gYmUgYSBib29sZWFuIG9yIG9iamVjdCBzbyB0aGF0J3Mgd2h5IGl0J3NcbiAgICAgIC8vIGZvcmNlZCB0byBiZSBhIHN0cmluZy5cbiAgICAgIGluaXRpYWxWYWx1ZTogJycgKyAodmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogZGVmYXVsdFZhbHVlKVxuICAgIH07XG4gIH0sXG5cbiAgc2hvdWxkQ29tcG9uZW50VXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAvLyBEZWZlciBhbnkgdXBkYXRlcyB0byB0aGlzIGNvbXBvbmVudCBkdXJpbmcgdGhlIGBvbkNoYW5nZWAgaGFuZGxlci5cbiAgICByZXR1cm4gIXRoaXMuX2lzQ2hhbmdpbmc7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAvLyBDbG9uZSBgdGhpcy5wcm9wc2Agc28gd2UgZG9uJ3QgbXV0YXRlIHRoZSBpbnB1dC5cbiAgICB2YXIgcHJvcHMgPSBtZXJnZSh0aGlzLnByb3BzKTtcblxuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PSBudWxsLFxuICAgICAgJ2BkYW5nZXJvdXNseVNldElubmVySFRNTGAgZG9lcyBub3QgbWFrZSBzZW5zZSBvbiA8dGV4dGFyZWE+LidcbiAgICApIDogaW52YXJpYW50KHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09IG51bGwpKTtcblxuICAgIHByb3BzLmRlZmF1bHRWYWx1ZSA9IG51bGw7XG4gICAgcHJvcHMudmFsdWUgPSBudWxsO1xuICAgIHByb3BzLm9uQ2hhbmdlID0gdGhpcy5faGFuZGxlQ2hhbmdlO1xuXG4gICAgLy8gQWx3YXlzIHNldCBjaGlsZHJlbiB0byB0aGUgc2FtZSB0aGluZy4gSW4gSUU5LCB0aGUgc2VsZWN0aW9uIHJhbmdlIHdpbGxcbiAgICAvLyBnZXQgcmVzZXQgaWYgYHRleHRDb250ZW50YCBpcyBtdXRhdGVkLlxuICAgIHJldHVybiB0ZXh0YXJlYShwcm9wcywgdGhpcy5zdGF0ZS5pbml0aWFsVmFsdWUpO1xuICB9LFxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZTogZnVuY3Rpb24ocHJldlByb3BzLCBwcmV2U3RhdGUsIHByZXZDb250ZXh0KSB7XG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZSh0aGlzKTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgdmFyIHJvb3ROb2RlID0gdGhpcy5nZXRET01Ob2RlKCk7XG4gICAgICAvLyBDYXN0IGB2YWx1ZWAgdG8gYSBzdHJpbmcgdG8gZW5zdXJlIHRoZSB2YWx1ZSBpcyBzZXQgY29ycmVjdGx5LiBXaGlsZVxuICAgICAgLy8gYnJvd3NlcnMgdHlwaWNhbGx5IGRvIHRoaXMgYXMgbmVjZXNzYXJ5LCBqc2RvbSBkb2Vzbid0LlxuICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yUHJvcGVydHkocm9vdE5vZGUsICd2YWx1ZScsICcnICsgdmFsdWUpO1xuICAgIH1cbiAgfSxcblxuICBfaGFuZGxlQ2hhbmdlOiBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciByZXR1cm5WYWx1ZTtcbiAgICB2YXIgb25DaGFuZ2UgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldE9uQ2hhbmdlKHRoaXMpO1xuICAgIGlmIChvbkNoYW5nZSkge1xuICAgICAgdGhpcy5faXNDaGFuZ2luZyA9IHRydWU7XG4gICAgICByZXR1cm5WYWx1ZSA9IG9uQ2hhbmdlLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgdGhpcy5faXNDaGFuZ2luZyA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLnNldFN0YXRlKHt2YWx1ZTogZXZlbnQudGFyZ2V0LnZhbHVlfSk7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NVGV4dGFyZWE7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKFwiLi9SZWFjdFVwZGF0ZXNcIik7XG52YXIgVHJhbnNhY3Rpb24gPSByZXF1aXJlKFwiLi9UcmFuc2FjdGlvblwiKTtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKFwiLi9lbXB0eUZ1bmN0aW9uXCIpO1xudmFyIG1peEludG8gPSByZXF1aXJlKFwiLi9taXhJbnRvXCIpO1xuXG52YXIgUkVTRVRfQkFUQ0hFRF9VUERBVEVTID0ge1xuICBpbml0aWFsaXplOiBlbXB0eUZ1bmN0aW9uLFxuICBjbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcyA9IGZhbHNlO1xuICB9XG59O1xuXG52YXIgRkxVU0hfQkFUQ0hFRF9VUERBVEVTID0ge1xuICBpbml0aWFsaXplOiBlbXB0eUZ1bmN0aW9uLFxuICBjbG9zZTogUmVhY3RVcGRhdGVzLmZsdXNoQmF0Y2hlZFVwZGF0ZXMuYmluZChSZWFjdFVwZGF0ZXMpXG59O1xuXG52YXIgVFJBTlNBQ1RJT05fV1JBUFBFUlMgPSBbRkxVU0hfQkFUQ0hFRF9VUERBVEVTLCBSRVNFVF9CQVRDSEVEX1VQREFURVNdO1xuXG5mdW5jdGlvbiBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5VHJhbnNhY3Rpb24oKSB7XG4gIHRoaXMucmVpbml0aWFsaXplVHJhbnNhY3Rpb24oKTtcbn1cblxubWl4SW50byhSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5VHJhbnNhY3Rpb24sIFRyYW5zYWN0aW9uLk1peGluKTtcbm1peEludG8oUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneVRyYW5zYWN0aW9uLCB7XG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBUUkFOU0FDVElPTl9XUkFQUEVSUztcbiAgfVxufSk7XG5cbnZhciB0cmFuc2FjdGlvbiA9IG5ldyBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5VHJhbnNhY3Rpb24oKTtcblxudmFyIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kgPSB7XG4gIGlzQmF0Y2hpbmdVcGRhdGVzOiBmYWxzZSxcblxuICAvKipcbiAgICogQ2FsbCB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gaW4gYSBjb250ZXh0IHdpdGhpbiB3aGljaCBjYWxscyB0byBgc2V0U3RhdGVgXG4gICAqIGFuZCBmcmllbmRzIGFyZSBiYXRjaGVkIHN1Y2ggdGhhdCBjb21wb25lbnRzIGFyZW4ndCB1cGRhdGVkIHVubmVjZXNzYXJpbHkuXG4gICAqL1xuICBiYXRjaGVkVXBkYXRlczogZnVuY3Rpb24oY2FsbGJhY2ssIGEsIGIpIHtcbiAgICB2YXIgYWxyZWFkeUJhdGNoaW5nVXBkYXRlcyA9IFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXM7XG5cbiAgICBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzID0gdHJ1ZTtcblxuICAgIC8vIFRoZSBjb2RlIGlzIHdyaXR0ZW4gdGhpcyB3YXkgdG8gYXZvaWQgZXh0cmEgYWxsb2NhdGlvbnNcbiAgICBpZiAoYWxyZWFkeUJhdGNoaW5nVXBkYXRlcykge1xuICAgICAgY2FsbGJhY2soYSwgYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYW5zYWN0aW9uLnBlcmZvcm0oY2FsbGJhY2ssIG51bGwsIGEsIGIpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5O1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERlZmF1bHRJbmplY3Rpb25cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIEJlZm9yZUlucHV0RXZlbnRQbHVnaW4gPSByZXF1aXJlKFwiLi9CZWZvcmVJbnB1dEV2ZW50UGx1Z2luXCIpO1xudmFyIENoYW5nZUV2ZW50UGx1Z2luID0gcmVxdWlyZShcIi4vQ2hhbmdlRXZlbnRQbHVnaW5cIik7XG52YXIgQ2xpZW50UmVhY3RSb290SW5kZXggPSByZXF1aXJlKFwiLi9DbGllbnRSZWFjdFJvb3RJbmRleFwiKTtcbnZhciBDb21wb3NpdGlvbkV2ZW50UGx1Z2luID0gcmVxdWlyZShcIi4vQ29tcG9zaXRpb25FdmVudFBsdWdpblwiKTtcbnZhciBEZWZhdWx0RXZlbnRQbHVnaW5PcmRlciA9IHJlcXVpcmUoXCIuL0RlZmF1bHRFdmVudFBsdWdpbk9yZGVyXCIpO1xudmFyIEVudGVyTGVhdmVFdmVudFBsdWdpbiA9IHJlcXVpcmUoXCIuL0VudGVyTGVhdmVFdmVudFBsdWdpblwiKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoXCIuL0V4ZWN1dGlvbkVudmlyb25tZW50XCIpO1xudmFyIEhUTUxET01Qcm9wZXJ0eUNvbmZpZyA9IHJlcXVpcmUoXCIuL0hUTUxET01Qcm9wZXJ0eUNvbmZpZ1wiKTtcbnZhciBNb2JpbGVTYWZhcmlDbGlja0V2ZW50UGx1Z2luID0gcmVxdWlyZShcIi4vTW9iaWxlU2FmYXJpQ2xpY2tFdmVudFBsdWdpblwiKTtcbnZhciBSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbiA9IHJlcXVpcmUoXCIuL1JlYWN0QnJvd3NlckNvbXBvbmVudE1peGluXCIpO1xudmFyIFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50ID1cbiAgcmVxdWlyZShcIi4vUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnRcIik7XG52YXIgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneSA9IHJlcXVpcmUoXCIuL1JlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3lcIik7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKFwiLi9SZWFjdERPTVwiKTtcbnZhciBSZWFjdERPTUJ1dHRvbiA9IHJlcXVpcmUoXCIuL1JlYWN0RE9NQnV0dG9uXCIpO1xudmFyIFJlYWN0RE9NRm9ybSA9IHJlcXVpcmUoXCIuL1JlYWN0RE9NRm9ybVwiKTtcbnZhciBSZWFjdERPTUltZyA9IHJlcXVpcmUoXCIuL1JlYWN0RE9NSW1nXCIpO1xudmFyIFJlYWN0RE9NSW5wdXQgPSByZXF1aXJlKFwiLi9SZWFjdERPTUlucHV0XCIpO1xudmFyIFJlYWN0RE9NT3B0aW9uID0gcmVxdWlyZShcIi4vUmVhY3RET01PcHRpb25cIik7XG52YXIgUmVhY3RET01TZWxlY3QgPSByZXF1aXJlKFwiLi9SZWFjdERPTVNlbGVjdFwiKTtcbnZhciBSZWFjdERPTVRleHRhcmVhID0gcmVxdWlyZShcIi4vUmVhY3RET01UZXh0YXJlYVwiKTtcbnZhciBSZWFjdEV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKFwiLi9SZWFjdEV2ZW50TGlzdGVuZXJcIik7XG52YXIgUmVhY3RJbmplY3Rpb24gPSByZXF1aXJlKFwiLi9SZWFjdEluamVjdGlvblwiKTtcbnZhciBSZWFjdEluc3RhbmNlSGFuZGxlcyA9IHJlcXVpcmUoXCIuL1JlYWN0SW5zdGFuY2VIYW5kbGVzXCIpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKFwiLi9SZWFjdE1vdW50XCIpO1xudmFyIFNlbGVjdEV2ZW50UGx1Z2luID0gcmVxdWlyZShcIi4vU2VsZWN0RXZlbnRQbHVnaW5cIik7XG52YXIgU2VydmVyUmVhY3RSb290SW5kZXggPSByZXF1aXJlKFwiLi9TZXJ2ZXJSZWFjdFJvb3RJbmRleFwiKTtcbnZhciBTaW1wbGVFdmVudFBsdWdpbiA9IHJlcXVpcmUoXCIuL1NpbXBsZUV2ZW50UGx1Z2luXCIpO1xudmFyIFNWR0RPTVByb3BlcnR5Q29uZmlnID0gcmVxdWlyZShcIi4vU1ZHRE9NUHJvcGVydHlDb25maWdcIik7XG5cbnZhciBjcmVhdGVGdWxsUGFnZUNvbXBvbmVudCA9IHJlcXVpcmUoXCIuL2NyZWF0ZUZ1bGxQYWdlQ29tcG9uZW50XCIpO1xuXG5mdW5jdGlvbiBpbmplY3QoKSB7XG4gIFJlYWN0SW5qZWN0aW9uLkV2ZW50RW1pdHRlci5pbmplY3RSZWFjdEV2ZW50TGlzdGVuZXIoXG4gICAgUmVhY3RFdmVudExpc3RlbmVyXG4gICk7XG5cbiAgLyoqXG4gICAqIEluamVjdCBtb2R1bGVzIGZvciByZXNvbHZpbmcgRE9NIGhpZXJhcmNoeSBhbmQgcGx1Z2luIG9yZGVyaW5nLlxuICAgKi9cbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRQbHVnaW5IdWIuaW5qZWN0RXZlbnRQbHVnaW5PcmRlcihEZWZhdWx0RXZlbnRQbHVnaW5PcmRlcik7XG4gIFJlYWN0SW5qZWN0aW9uLkV2ZW50UGx1Z2luSHViLmluamVjdEluc3RhbmNlSGFuZGxlKFJlYWN0SW5zdGFuY2VIYW5kbGVzKTtcbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRQbHVnaW5IdWIuaW5qZWN0TW91bnQoUmVhY3RNb3VudCk7XG5cbiAgLyoqXG4gICAqIFNvbWUgaW1wb3J0YW50IGV2ZW50IHBsdWdpbnMgaW5jbHVkZWQgYnkgZGVmYXVsdCAod2l0aG91dCBoYXZpbmcgdG8gcmVxdWlyZVxuICAgKiB0aGVtKS5cbiAgICovXG4gIFJlYWN0SW5qZWN0aW9uLkV2ZW50UGx1Z2luSHViLmluamVjdEV2ZW50UGx1Z2luc0J5TmFtZSh7XG4gICAgU2ltcGxlRXZlbnRQbHVnaW46IFNpbXBsZUV2ZW50UGx1Z2luLFxuICAgIEVudGVyTGVhdmVFdmVudFBsdWdpbjogRW50ZXJMZWF2ZUV2ZW50UGx1Z2luLFxuICAgIENoYW5nZUV2ZW50UGx1Z2luOiBDaGFuZ2VFdmVudFBsdWdpbixcbiAgICBDb21wb3NpdGlvbkV2ZW50UGx1Z2luOiBDb21wb3NpdGlvbkV2ZW50UGx1Z2luLFxuICAgIE1vYmlsZVNhZmFyaUNsaWNrRXZlbnRQbHVnaW46IE1vYmlsZVNhZmFyaUNsaWNrRXZlbnRQbHVnaW4sXG4gICAgU2VsZWN0RXZlbnRQbHVnaW46IFNlbGVjdEV2ZW50UGx1Z2luLFxuICAgIEJlZm9yZUlucHV0RXZlbnRQbHVnaW46IEJlZm9yZUlucHV0RXZlbnRQbHVnaW5cbiAgfSk7XG5cbiAgUmVhY3RJbmplY3Rpb24uRE9NLmluamVjdENvbXBvbmVudENsYXNzZXMoe1xuICAgIGJ1dHRvbjogUmVhY3RET01CdXR0b24sXG4gICAgZm9ybTogUmVhY3RET01Gb3JtLFxuICAgIGltZzogUmVhY3RET01JbWcsXG4gICAgaW5wdXQ6IFJlYWN0RE9NSW5wdXQsXG4gICAgb3B0aW9uOiBSZWFjdERPTU9wdGlvbixcbiAgICBzZWxlY3Q6IFJlYWN0RE9NU2VsZWN0LFxuICAgIHRleHRhcmVhOiBSZWFjdERPTVRleHRhcmVhLFxuXG4gICAgaHRtbDogY3JlYXRlRnVsbFBhZ2VDb21wb25lbnQoUmVhY3RET00uaHRtbCksXG4gICAgaGVhZDogY3JlYXRlRnVsbFBhZ2VDb21wb25lbnQoUmVhY3RET00uaGVhZCksXG4gICAgYm9keTogY3JlYXRlRnVsbFBhZ2VDb21wb25lbnQoUmVhY3RET00uYm9keSlcbiAgfSk7XG5cbiAgLy8gVGhpcyBuZWVkcyB0byBoYXBwZW4gYWZ0ZXIgY3JlYXRlRnVsbFBhZ2VDb21wb25lbnQoKSBvdGhlcndpc2UgdGhlIG1peGluXG4gIC8vIGdldHMgZG91YmxlIGluamVjdGVkLlxuICBSZWFjdEluamVjdGlvbi5Db21wb3NpdGVDb21wb25lbnQuaW5qZWN0TWl4aW4oUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW4pO1xuXG4gIFJlYWN0SW5qZWN0aW9uLkRPTVByb3BlcnR5LmluamVjdERPTVByb3BlcnR5Q29uZmlnKEhUTUxET01Qcm9wZXJ0eUNvbmZpZyk7XG4gIFJlYWN0SW5qZWN0aW9uLkRPTVByb3BlcnR5LmluamVjdERPTVByb3BlcnR5Q29uZmlnKFNWR0RPTVByb3BlcnR5Q29uZmlnKTtcblxuICBSZWFjdEluamVjdGlvbi5FbXB0eUNvbXBvbmVudC5pbmplY3RFbXB0eUNvbXBvbmVudChSZWFjdERPTS5ub3NjcmlwdCk7XG5cbiAgUmVhY3RJbmplY3Rpb24uVXBkYXRlcy5pbmplY3RSZWNvbmNpbGVUcmFuc2FjdGlvbihcbiAgICBSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudC5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uXG4gICk7XG4gIFJlYWN0SW5qZWN0aW9uLlVwZGF0ZXMuaW5qZWN0QmF0Y2hpbmdTdHJhdGVneShcbiAgICBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5XG4gICk7XG5cbiAgUmVhY3RJbmplY3Rpb24uUm9vdEluZGV4LmluamVjdENyZWF0ZVJlYWN0Um9vdEluZGV4KFxuICAgIEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/XG4gICAgICBDbGllbnRSZWFjdFJvb3RJbmRleC5jcmVhdGVSZWFjdFJvb3RJbmRleCA6XG4gICAgICBTZXJ2ZXJSZWFjdFJvb3RJbmRleC5jcmVhdGVSZWFjdFJvb3RJbmRleFxuICApO1xuXG4gIFJlYWN0SW5qZWN0aW9uLkNvbXBvbmVudC5pbmplY3RFbnZpcm9ubWVudChSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudCk7XG5cbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgIHZhciB1cmwgPSAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmIHdpbmRvdy5sb2NhdGlvbi5ocmVmKSB8fCAnJztcbiAgICBpZiAoKC9bPyZdcmVhY3RfcGVyZlxcYi8pLnRlc3QodXJsKSkge1xuICAgICAgdmFyIFJlYWN0RGVmYXVsdFBlcmYgPSByZXF1aXJlKFwiLi9SZWFjdERlZmF1bHRQZXJmXCIpO1xuICAgICAgUmVhY3REZWZhdWx0UGVyZi5zdGFydCgpO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaW5qZWN0OiBpbmplY3Rcbn07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERlZmF1bHRQZXJmXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKFwiLi9ET01Qcm9wZXJ0eVwiKTtcbnZhciBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMgPSByZXF1aXJlKFwiLi9SZWFjdERlZmF1bHRQZXJmQW5hbHlzaXNcIik7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoXCIuL1JlYWN0TW91bnRcIik7XG52YXIgUmVhY3RQZXJmID0gcmVxdWlyZShcIi4vUmVhY3RQZXJmXCIpO1xuXG52YXIgcGVyZm9ybWFuY2VOb3cgPSByZXF1aXJlKFwiLi9wZXJmb3JtYW5jZU5vd1wiKTtcblxuZnVuY3Rpb24gcm91bmRGbG9hdCh2YWwpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IodmFsICogMTAwKSAvIDEwMDtcbn1cblxuZnVuY3Rpb24gYWRkVmFsdWUob2JqLCBrZXksIHZhbCkge1xuICBvYmpba2V5XSA9IChvYmpba2V5XSB8fCAwKSArIHZhbDtcbn1cblxudmFyIFJlYWN0RGVmYXVsdFBlcmYgPSB7XG4gIF9hbGxNZWFzdXJlbWVudHM6IFtdLCAvLyBsYXN0IGl0ZW0gaW4gdGhlIGxpc3QgaXMgdGhlIGN1cnJlbnQgb25lXG4gIF9tb3VudFN0YWNrOiBbMF0sXG4gIF9pbmplY3RlZDogZmFsc2UsXG5cbiAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghUmVhY3REZWZhdWx0UGVyZi5faW5qZWN0ZWQpIHtcbiAgICAgIFJlYWN0UGVyZi5pbmplY3Rpb24uaW5qZWN0TWVhc3VyZShSZWFjdERlZmF1bHRQZXJmLm1lYXN1cmUpO1xuICAgIH1cblxuICAgIFJlYWN0RGVmYXVsdFBlcmYuX2FsbE1lYXN1cmVtZW50cy5sZW5ndGggPSAwO1xuICAgIFJlYWN0UGVyZi5lbmFibGVNZWFzdXJlID0gdHJ1ZTtcbiAgfSxcblxuICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICBSZWFjdFBlcmYuZW5hYmxlTWVhc3VyZSA9IGZhbHNlO1xuICB9LFxuXG4gIGdldExhc3RNZWFzdXJlbWVudHM6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHM7XG4gIH0sXG5cbiAgcHJpbnRFeGNsdXNpdmU6IGZ1bmN0aW9uKG1lYXN1cmVtZW50cykge1xuICAgIG1lYXN1cmVtZW50cyA9IG1lYXN1cmVtZW50cyB8fCBSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHM7XG4gICAgdmFyIHN1bW1hcnkgPSBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMuZ2V0RXhjbHVzaXZlU3VtbWFyeShtZWFzdXJlbWVudHMpO1xuICAgIGNvbnNvbGUudGFibGUoc3VtbWFyeS5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ0NvbXBvbmVudCBjbGFzcyBuYW1lJzogaXRlbS5jb21wb25lbnROYW1lLFxuICAgICAgICAnVG90YWwgaW5jbHVzaXZlIHRpbWUgKG1zKSc6IHJvdW5kRmxvYXQoaXRlbS5pbmNsdXNpdmUpLFxuICAgICAgICAnRXhjbHVzaXZlIG1vdW50IHRpbWUgKG1zKSc6IHJvdW5kRmxvYXQoaXRlbS5leGNsdXNpdmUpLFxuICAgICAgICAnRXhjbHVzaXZlIHJlbmRlciB0aW1lIChtcyknOiByb3VuZEZsb2F0KGl0ZW0ucmVuZGVyKSxcbiAgICAgICAgJ01vdW50IHRpbWUgcGVyIGluc3RhbmNlIChtcyknOiByb3VuZEZsb2F0KGl0ZW0uZXhjbHVzaXZlIC8gaXRlbS5jb3VudCksXG4gICAgICAgICdSZW5kZXIgdGltZSBwZXIgaW5zdGFuY2UgKG1zKSc6IHJvdW5kRmxvYXQoaXRlbS5yZW5kZXIgLyBpdGVtLmNvdW50KSxcbiAgICAgICAgJ0luc3RhbmNlcyc6IGl0ZW0uY291bnRcbiAgICAgIH07XG4gICAgfSkpO1xuICAgIC8vIFRPRE86IFJlYWN0RGVmYXVsdFBlcmZBbmFseXNpcy5nZXRUb3RhbFRpbWUoKSBkb2VzIG5vdCByZXR1cm4gdGhlIGNvcnJlY3RcbiAgICAvLyBudW1iZXIuXG4gIH0sXG5cbiAgcHJpbnRJbmNsdXNpdmU6IGZ1bmN0aW9uKG1lYXN1cmVtZW50cykge1xuICAgIG1lYXN1cmVtZW50cyA9IG1lYXN1cmVtZW50cyB8fCBSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHM7XG4gICAgdmFyIHN1bW1hcnkgPSBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMuZ2V0SW5jbHVzaXZlU3VtbWFyeShtZWFzdXJlbWVudHMpO1xuICAgIGNvbnNvbGUudGFibGUoc3VtbWFyeS5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ093bmVyID4gY29tcG9uZW50JzogaXRlbS5jb21wb25lbnROYW1lLFxuICAgICAgICAnSW5jbHVzaXZlIHRpbWUgKG1zKSc6IHJvdW5kRmxvYXQoaXRlbS50aW1lKSxcbiAgICAgICAgJ0luc3RhbmNlcyc6IGl0ZW0uY291bnRcbiAgICAgIH07XG4gICAgfSkpO1xuICAgIGNvbnNvbGUubG9nKFxuICAgICAgJ1RvdGFsIHRpbWU6JyxcbiAgICAgIFJlYWN0RGVmYXVsdFBlcmZBbmFseXNpcy5nZXRUb3RhbFRpbWUobWVhc3VyZW1lbnRzKS50b0ZpeGVkKDIpICsgJyBtcydcbiAgICApO1xuICB9LFxuXG4gIHByaW50V2FzdGVkOiBmdW5jdGlvbihtZWFzdXJlbWVudHMpIHtcbiAgICBtZWFzdXJlbWVudHMgPSBtZWFzdXJlbWVudHMgfHwgUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzO1xuICAgIHZhciBzdW1tYXJ5ID0gUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzLmdldEluY2x1c2l2ZVN1bW1hcnkoXG4gICAgICBtZWFzdXJlbWVudHMsXG4gICAgICB0cnVlXG4gICAgKTtcbiAgICBjb25zb2xlLnRhYmxlKHN1bW1hcnkubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICdPd25lciA+IGNvbXBvbmVudCc6IGl0ZW0uY29tcG9uZW50TmFtZSxcbiAgICAgICAgJ1dhc3RlZCB0aW1lIChtcyknOiBpdGVtLnRpbWUsXG4gICAgICAgICdJbnN0YW5jZXMnOiBpdGVtLmNvdW50XG4gICAgICB9O1xuICAgIH0pKTtcbiAgICBjb25zb2xlLmxvZyhcbiAgICAgICdUb3RhbCB0aW1lOicsXG4gICAgICBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMuZ2V0VG90YWxUaW1lKG1lYXN1cmVtZW50cykudG9GaXhlZCgyKSArICcgbXMnXG4gICAgKTtcbiAgfSxcblxuICBwcmludERPTTogZnVuY3Rpb24obWVhc3VyZW1lbnRzKSB7XG4gICAgbWVhc3VyZW1lbnRzID0gbWVhc3VyZW1lbnRzIHx8IFJlYWN0RGVmYXVsdFBlcmYuX2FsbE1lYXN1cmVtZW50cztcbiAgICB2YXIgc3VtbWFyeSA9IFJlYWN0RGVmYXVsdFBlcmZBbmFseXNpcy5nZXRET01TdW1tYXJ5KG1lYXN1cmVtZW50cyk7XG4gICAgY29uc29sZS50YWJsZShzdW1tYXJ5Lm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICByZXN1bHRbRE9NUHJvcGVydHkuSURfQVRUUklCVVRFX05BTUVdID0gaXRlbS5pZDtcbiAgICAgIHJlc3VsdFsndHlwZSddID0gaXRlbS50eXBlO1xuICAgICAgcmVzdWx0WydhcmdzJ10gPSBKU09OLnN0cmluZ2lmeShpdGVtLmFyZ3MpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KSk7XG4gICAgY29uc29sZS5sb2coXG4gICAgICAnVG90YWwgdGltZTonLFxuICAgICAgUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzLmdldFRvdGFsVGltZShtZWFzdXJlbWVudHMpLnRvRml4ZWQoMikgKyAnIG1zJ1xuICAgICk7XG4gIH0sXG5cbiAgX3JlY29yZFdyaXRlOiBmdW5jdGlvbihpZCwgZm5OYW1lLCB0b3RhbFRpbWUsIGFyZ3MpIHtcbiAgICAvLyBUT0RPOiB0b3RhbFRpbWUgaXNuJ3QgdGhhdCB1c2VmdWwgc2luY2UgaXQgZG9lc24ndCBjb3VudCBwYWludHMvcmVmbG93c1xuICAgIHZhciB3cml0ZXMgPVxuICAgICAgUmVhY3REZWZhdWx0UGVyZlxuICAgICAgICAuX2FsbE1lYXN1cmVtZW50c1tSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHMubGVuZ3RoIC0gMV1cbiAgICAgICAgLndyaXRlcztcbiAgICB3cml0ZXNbaWRdID0gd3JpdGVzW2lkXSB8fCBbXTtcbiAgICB3cml0ZXNbaWRdLnB1c2goe1xuICAgICAgdHlwZTogZm5OYW1lLFxuICAgICAgdGltZTogdG90YWxUaW1lLFxuICAgICAgYXJnczogYXJnc1xuICAgIH0pO1xuICB9LFxuXG4gIG1lYXN1cmU6IGZ1bmN0aW9uKG1vZHVsZU5hbWUsIGZuTmFtZSwgZnVuYykge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHt2YXIgYXJncz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMCk7XG4gICAgICB2YXIgdG90YWxUaW1lO1xuICAgICAgdmFyIHJ2O1xuICAgICAgdmFyIHN0YXJ0O1xuXG4gICAgICBpZiAoZm5OYW1lID09PSAnX3JlbmRlck5ld1Jvb3RDb21wb25lbnQnIHx8XG4gICAgICAgICAgZm5OYW1lID09PSAnZmx1c2hCYXRjaGVkVXBkYXRlcycpIHtcbiAgICAgICAgLy8gQSBcIm1lYXN1cmVtZW50XCIgaXMgYSBzZXQgb2YgbWV0cmljcyByZWNvcmRlZCBmb3IgZWFjaCBmbHVzaC4gV2Ugd2FudFxuICAgICAgICAvLyB0byBncm91cCB0aGUgbWV0cmljcyBmb3IgYSBnaXZlbiBmbHVzaCB0b2dldGhlciBzbyB3ZSBjYW4gbG9vayBhdCB0aGVcbiAgICAgICAgLy8gY29tcG9uZW50cyB0aGF0IHJlbmRlcmVkIGFuZCB0aGUgRE9NIG9wZXJhdGlvbnMgdGhhdCBhY3R1YWxseVxuICAgICAgICAvLyBoYXBwZW5lZCB0byBkZXRlcm1pbmUgdGhlIGFtb3VudCBvZiBcIndhc3RlZCB3b3JrXCIgcGVyZm9ybWVkLlxuICAgICAgICBSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHMucHVzaCh7XG4gICAgICAgICAgZXhjbHVzaXZlOiB7fSxcbiAgICAgICAgICBpbmNsdXNpdmU6IHt9LFxuICAgICAgICAgIHJlbmRlcjoge30sXG4gICAgICAgICAgY291bnRzOiB7fSxcbiAgICAgICAgICB3cml0ZXM6IHt9LFxuICAgICAgICAgIGRpc3BsYXlOYW1lczoge30sXG4gICAgICAgICAgdG90YWxUaW1lOiAwXG4gICAgICAgIH0pO1xuICAgICAgICBzdGFydCA9IHBlcmZvcm1hbmNlTm93KCk7XG4gICAgICAgIHJ2ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzW1xuICAgICAgICAgIFJlYWN0RGVmYXVsdFBlcmYuX2FsbE1lYXN1cmVtZW50cy5sZW5ndGggLSAxXG4gICAgICAgIF0udG90YWxUaW1lID0gcGVyZm9ybWFuY2VOb3coKSAtIHN0YXJ0O1xuICAgICAgICByZXR1cm4gcnY7XG4gICAgICB9IGVsc2UgaWYgKG1vZHVsZU5hbWUgPT09ICdSZWFjdERPTUlET3BlcmF0aW9ucycgfHxcbiAgICAgICAgbW9kdWxlTmFtZSA9PT0gJ1JlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50Jykge1xuICAgICAgICBzdGFydCA9IHBlcmZvcm1hbmNlTm93KCk7XG4gICAgICAgIHJ2ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgdG90YWxUaW1lID0gcGVyZm9ybWFuY2VOb3coKSAtIHN0YXJ0O1xuXG4gICAgICAgIGlmIChmbk5hbWUgPT09ICdtb3VudEltYWdlSW50b05vZGUnKSB7XG4gICAgICAgICAgdmFyIG1vdW50SUQgPSBSZWFjdE1vdW50LmdldElEKGFyZ3NbMV0pO1xuICAgICAgICAgIFJlYWN0RGVmYXVsdFBlcmYuX3JlY29yZFdyaXRlKG1vdW50SUQsIGZuTmFtZSwgdG90YWxUaW1lLCBhcmdzWzBdKTtcbiAgICAgICAgfSBlbHNlIGlmIChmbk5hbWUgPT09ICdkYW5nZXJvdXNseVByb2Nlc3NDaGlsZHJlblVwZGF0ZXMnKSB7XG4gICAgICAgICAgLy8gc3BlY2lhbCBmb3JtYXRcbiAgICAgICAgICBhcmdzWzBdLmZvckVhY2goZnVuY3Rpb24odXBkYXRlKSB7XG4gICAgICAgICAgICB2YXIgd3JpdGVBcmdzID0ge307XG4gICAgICAgICAgICBpZiAodXBkYXRlLmZyb21JbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB3cml0ZUFyZ3MuZnJvbUluZGV4ID0gdXBkYXRlLmZyb21JbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1cGRhdGUudG9JbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB3cml0ZUFyZ3MudG9JbmRleCA9IHVwZGF0ZS50b0luZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVwZGF0ZS50ZXh0Q29udGVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB3cml0ZUFyZ3MudGV4dENvbnRlbnQgPSB1cGRhdGUudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXBkYXRlLm1hcmt1cEluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHdyaXRlQXJncy5tYXJrdXAgPSBhcmdzWzFdW3VwZGF0ZS5tYXJrdXBJbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSZWFjdERlZmF1bHRQZXJmLl9yZWNvcmRXcml0ZShcbiAgICAgICAgICAgICAgdXBkYXRlLnBhcmVudElELFxuICAgICAgICAgICAgICB1cGRhdGUudHlwZSxcbiAgICAgICAgICAgICAgdG90YWxUaW1lLFxuICAgICAgICAgICAgICB3cml0ZUFyZ3NcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gYmFzaWMgZm9ybWF0XG4gICAgICAgICAgUmVhY3REZWZhdWx0UGVyZi5fcmVjb3JkV3JpdGUoXG4gICAgICAgICAgICBhcmdzWzBdLFxuICAgICAgICAgICAgZm5OYW1lLFxuICAgICAgICAgICAgdG90YWxUaW1lLFxuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncywgMSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydjtcbiAgICAgIH0gZWxzZSBpZiAobW9kdWxlTmFtZSA9PT0gJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JyAmJiAoXG4gICAgICAgIGZuTmFtZSA9PT0gJ21vdW50Q29tcG9uZW50JyB8fFxuICAgICAgICBmbk5hbWUgPT09ICd1cGRhdGVDb21wb25lbnQnIHx8IC8vIFRPRE86IHJlY2VpdmVDb21wb25lbnQoKT9cbiAgICAgICAgZm5OYW1lID09PSAnX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCcpKSB7XG5cbiAgICAgICAgdmFyIHJvb3ROb2RlSUQgPSBmbk5hbWUgPT09ICdtb3VudENvbXBvbmVudCcgP1xuICAgICAgICAgIGFyZ3NbMF0gOlxuICAgICAgICAgIHRoaXMuX3Jvb3ROb2RlSUQ7XG4gICAgICAgIHZhciBpc1JlbmRlciA9IGZuTmFtZSA9PT0gJ19yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQnO1xuICAgICAgICB2YXIgaXNNb3VudCA9IGZuTmFtZSA9PT0gJ21vdW50Q29tcG9uZW50JztcblxuICAgICAgICB2YXIgbW91bnRTdGFjayA9IFJlYWN0RGVmYXVsdFBlcmYuX21vdW50U3RhY2s7XG4gICAgICAgIHZhciBlbnRyeSA9IFJlYWN0RGVmYXVsdFBlcmYuX2FsbE1lYXN1cmVtZW50c1tcbiAgICAgICAgICBSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHMubGVuZ3RoIC0gMVxuICAgICAgICBdO1xuXG4gICAgICAgIGlmIChpc1JlbmRlcikge1xuICAgICAgICAgIGFkZFZhbHVlKGVudHJ5LmNvdW50cywgcm9vdE5vZGVJRCwgMSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNNb3VudCkge1xuICAgICAgICAgIG1vdW50U3RhY2sucHVzaCgwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0ID0gcGVyZm9ybWFuY2VOb3coKTtcbiAgICAgICAgcnYgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB0b3RhbFRpbWUgPSBwZXJmb3JtYW5jZU5vdygpIC0gc3RhcnQ7XG5cbiAgICAgICAgaWYgKGlzUmVuZGVyKSB7XG4gICAgICAgICAgYWRkVmFsdWUoZW50cnkucmVuZGVyLCByb290Tm9kZUlELCB0b3RhbFRpbWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTW91bnQpIHtcbiAgICAgICAgICB2YXIgc3ViTW91bnRUaW1lID0gbW91bnRTdGFjay5wb3AoKTtcbiAgICAgICAgICBtb3VudFN0YWNrW21vdW50U3RhY2subGVuZ3RoIC0gMV0gKz0gdG90YWxUaW1lO1xuICAgICAgICAgIGFkZFZhbHVlKGVudHJ5LmV4Y2x1c2l2ZSwgcm9vdE5vZGVJRCwgdG90YWxUaW1lIC0gc3ViTW91bnRUaW1lKTtcbiAgICAgICAgICBhZGRWYWx1ZShlbnRyeS5pbmNsdXNpdmUsIHJvb3ROb2RlSUQsIHRvdGFsVGltZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkVmFsdWUoZW50cnkuaW5jbHVzaXZlLCByb290Tm9kZUlELCB0b3RhbFRpbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZW50cnkuZGlzcGxheU5hbWVzW3Jvb3ROb2RlSURdID0ge1xuICAgICAgICAgIGN1cnJlbnQ6IHRoaXMuY29uc3RydWN0b3IuZGlzcGxheU5hbWUsXG4gICAgICAgICAgb3duZXI6IHRoaXMuX293bmVyID8gdGhpcy5fb3duZXIuY29uc3RydWN0b3IuZGlzcGxheU5hbWUgOiAnPHJvb3Q+J1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBydjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3REZWZhdWx0UGVyZjtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXNcbiAqL1xuXG52YXIgbWVyZ2UgPSByZXF1aXJlKFwiLi9tZXJnZVwiKTtcblxuLy8gRG9uJ3QgdHJ5IHRvIHNhdmUgdXNlcnMgbGVzcyB0aGFuIDEuMm1zIChhIG51bWJlciBJIG1hZGUgdXApXG52YXIgRE9OVF9DQVJFX1RIUkVTSE9MRCA9IDEuMjtcbnZhciBET01fT1BFUkFUSU9OX1RZUEVTID0ge1xuICAnbW91bnRJbWFnZUludG9Ob2RlJzogJ3NldCBpbm5lckhUTUwnLFxuICBJTlNFUlRfTUFSS1VQOiAnc2V0IGlubmVySFRNTCcsXG4gIE1PVkVfRVhJU1RJTkc6ICdtb3ZlJyxcbiAgUkVNT1ZFX05PREU6ICdyZW1vdmUnLFxuICBURVhUX0NPTlRFTlQ6ICdzZXQgdGV4dENvbnRlbnQnLFxuICAndXBkYXRlUHJvcGVydHlCeUlEJzogJ3VwZGF0ZSBhdHRyaWJ1dGUnLFxuICAnZGVsZXRlUHJvcGVydHlCeUlEJzogJ2RlbGV0ZSBhdHRyaWJ1dGUnLFxuICAndXBkYXRlU3R5bGVzQnlJRCc6ICd1cGRhdGUgc3R5bGVzJyxcbiAgJ3VwZGF0ZUlubmVySFRNTEJ5SUQnOiAnc2V0IGlubmVySFRNTCcsXG4gICdkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cEJ5SUQnOiAncmVwbGFjZSdcbn07XG5cbmZ1bmN0aW9uIGdldFRvdGFsVGltZShtZWFzdXJlbWVudHMpIHtcbiAgLy8gVE9ETzogcmV0dXJuIG51bWJlciBvZiBET00gb3BzPyBjb3VsZCBiZSBtaXNsZWFkaW5nLlxuICAvLyBUT0RPOiBtZWFzdXJlIGRyb3BwZWQgZnJhbWVzIGFmdGVyIHJlY29uY2lsZT9cbiAgLy8gVE9ETzogbG9nIHRvdGFsIHRpbWUgb2YgZWFjaCByZWNvbmNpbGUgYW5kIHRoZSB0b3AtbGV2ZWwgY29tcG9uZW50XG4gIC8vIGNsYXNzIHRoYXQgdHJpZ2dlcmVkIGl0LlxuICB2YXIgdG90YWxUaW1lID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZWFzdXJlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbWVhc3VyZW1lbnQgPSBtZWFzdXJlbWVudHNbaV07XG4gICAgdG90YWxUaW1lICs9IG1lYXN1cmVtZW50LnRvdGFsVGltZTtcbiAgfVxuICByZXR1cm4gdG90YWxUaW1lO1xufVxuXG5mdW5jdGlvbiBnZXRET01TdW1tYXJ5KG1lYXN1cmVtZW50cykge1xuICB2YXIgaXRlbXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZWFzdXJlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbWVhc3VyZW1lbnQgPSBtZWFzdXJlbWVudHNbaV07XG4gICAgdmFyIGlkO1xuXG4gICAgZm9yIChpZCBpbiBtZWFzdXJlbWVudC53cml0ZXMpIHtcbiAgICAgIG1lYXN1cmVtZW50LndyaXRlc1tpZF0uZm9yRWFjaChmdW5jdGlvbih3cml0ZSkge1xuICAgICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgdHlwZTogRE9NX09QRVJBVElPTl9UWVBFU1t3cml0ZS50eXBlXSB8fCB3cml0ZS50eXBlLFxuICAgICAgICAgIGFyZ3M6IHdyaXRlLmFyZ3NcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGl0ZW1zO1xufVxuXG5mdW5jdGlvbiBnZXRFeGNsdXNpdmVTdW1tYXJ5KG1lYXN1cmVtZW50cykge1xuICB2YXIgY2FuZGlkYXRlcyA9IHt9O1xuICB2YXIgZGlzcGxheU5hbWU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZWFzdXJlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbWVhc3VyZW1lbnQgPSBtZWFzdXJlbWVudHNbaV07XG4gICAgdmFyIGFsbElEcyA9IG1lcmdlKG1lYXN1cmVtZW50LmV4Y2x1c2l2ZSwgbWVhc3VyZW1lbnQuaW5jbHVzaXZlKTtcblxuICAgIGZvciAodmFyIGlkIGluIGFsbElEcykge1xuICAgICAgZGlzcGxheU5hbWUgPSBtZWFzdXJlbWVudC5kaXNwbGF5TmFtZXNbaWRdLmN1cnJlbnQ7XG5cbiAgICAgIGNhbmRpZGF0ZXNbZGlzcGxheU5hbWVdID0gY2FuZGlkYXRlc1tkaXNwbGF5TmFtZV0gfHwge1xuICAgICAgICBjb21wb25lbnROYW1lOiBkaXNwbGF5TmFtZSxcbiAgICAgICAgaW5jbHVzaXZlOiAwLFxuICAgICAgICBleGNsdXNpdmU6IDAsXG4gICAgICAgIHJlbmRlcjogMCxcbiAgICAgICAgY291bnQ6IDBcbiAgICAgIH07XG4gICAgICBpZiAobWVhc3VyZW1lbnQucmVuZGVyW2lkXSkge1xuICAgICAgICBjYW5kaWRhdGVzW2Rpc3BsYXlOYW1lXS5yZW5kZXIgKz0gbWVhc3VyZW1lbnQucmVuZGVyW2lkXTtcbiAgICAgIH1cbiAgICAgIGlmIChtZWFzdXJlbWVudC5leGNsdXNpdmVbaWRdKSB7XG4gICAgICAgIGNhbmRpZGF0ZXNbZGlzcGxheU5hbWVdLmV4Y2x1c2l2ZSArPSBtZWFzdXJlbWVudC5leGNsdXNpdmVbaWRdO1xuICAgICAgfVxuICAgICAgaWYgKG1lYXN1cmVtZW50LmluY2x1c2l2ZVtpZF0pIHtcbiAgICAgICAgY2FuZGlkYXRlc1tkaXNwbGF5TmFtZV0uaW5jbHVzaXZlICs9IG1lYXN1cmVtZW50LmluY2x1c2l2ZVtpZF07XG4gICAgICB9XG4gICAgICBpZiAobWVhc3VyZW1lbnQuY291bnRzW2lkXSkge1xuICAgICAgICBjYW5kaWRhdGVzW2Rpc3BsYXlOYW1lXS5jb3VudCArPSBtZWFzdXJlbWVudC5jb3VudHNbaWRdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIE5vdyBtYWtlIGEgc29ydGVkIGFycmF5IHdpdGggdGhlIHJlc3VsdHMuXG4gIHZhciBhcnIgPSBbXTtcbiAgZm9yIChkaXNwbGF5TmFtZSBpbiBjYW5kaWRhdGVzKSB7XG4gICAgaWYgKGNhbmRpZGF0ZXNbZGlzcGxheU5hbWVdLmV4Y2x1c2l2ZSA+PSBET05UX0NBUkVfVEhSRVNIT0xEKSB7XG4gICAgICBhcnIucHVzaChjYW5kaWRhdGVzW2Rpc3BsYXlOYW1lXSk7XG4gICAgfVxuICB9XG5cbiAgYXJyLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBiLmV4Y2x1c2l2ZSAtIGEuZXhjbHVzaXZlO1xuICB9KTtcblxuICByZXR1cm4gYXJyO1xufVxuXG5mdW5jdGlvbiBnZXRJbmNsdXNpdmVTdW1tYXJ5KG1lYXN1cmVtZW50cywgb25seUNsZWFuKSB7XG4gIHZhciBjYW5kaWRhdGVzID0ge307XG4gIHZhciBpbmNsdXNpdmVLZXk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZWFzdXJlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbWVhc3VyZW1lbnQgPSBtZWFzdXJlbWVudHNbaV07XG4gICAgdmFyIGFsbElEcyA9IG1lcmdlKG1lYXN1cmVtZW50LmV4Y2x1c2l2ZSwgbWVhc3VyZW1lbnQuaW5jbHVzaXZlKTtcbiAgICB2YXIgY2xlYW5Db21wb25lbnRzO1xuXG4gICAgaWYgKG9ubHlDbGVhbikge1xuICAgICAgY2xlYW5Db21wb25lbnRzID0gZ2V0VW5jaGFuZ2VkQ29tcG9uZW50cyhtZWFzdXJlbWVudCk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaWQgaW4gYWxsSURzKSB7XG4gICAgICBpZiAob25seUNsZWFuICYmICFjbGVhbkNvbXBvbmVudHNbaWRdKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSBtZWFzdXJlbWVudC5kaXNwbGF5TmFtZXNbaWRdO1xuXG4gICAgICAvLyBJbmNsdXNpdmUgdGltZSBpcyBub3QgdXNlZnVsIGZvciBtYW55IGNvbXBvbmVudHMgd2l0aG91dCBrbm93aW5nIHdoZXJlXG4gICAgICAvLyB0aGV5IGFyZSBpbnN0YW50aWF0ZWQuIFNvIHdlIGFnZ3JlZ2F0ZSBpbmNsdXNpdmUgdGltZSB3aXRoIGJvdGggdGhlXG4gICAgICAvLyBvd25lciBhbmQgY3VycmVudCBkaXNwbGF5TmFtZSBhcyB0aGUga2V5LlxuICAgICAgaW5jbHVzaXZlS2V5ID0gZGlzcGxheU5hbWUub3duZXIgKyAnID4gJyArIGRpc3BsYXlOYW1lLmN1cnJlbnQ7XG5cbiAgICAgIGNhbmRpZGF0ZXNbaW5jbHVzaXZlS2V5XSA9IGNhbmRpZGF0ZXNbaW5jbHVzaXZlS2V5XSB8fCB7XG4gICAgICAgIGNvbXBvbmVudE5hbWU6IGluY2x1c2l2ZUtleSxcbiAgICAgICAgdGltZTogMCxcbiAgICAgICAgY291bnQ6IDBcbiAgICAgIH07XG5cbiAgICAgIGlmIChtZWFzdXJlbWVudC5pbmNsdXNpdmVbaWRdKSB7XG4gICAgICAgIGNhbmRpZGF0ZXNbaW5jbHVzaXZlS2V5XS50aW1lICs9IG1lYXN1cmVtZW50LmluY2x1c2l2ZVtpZF07XG4gICAgICB9XG4gICAgICBpZiAobWVhc3VyZW1lbnQuY291bnRzW2lkXSkge1xuICAgICAgICBjYW5kaWRhdGVzW2luY2x1c2l2ZUtleV0uY291bnQgKz0gbWVhc3VyZW1lbnQuY291bnRzW2lkXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBOb3cgbWFrZSBhIHNvcnRlZCBhcnJheSB3aXRoIHRoZSByZXN1bHRzLlxuICB2YXIgYXJyID0gW107XG4gIGZvciAoaW5jbHVzaXZlS2V5IGluIGNhbmRpZGF0ZXMpIHtcbiAgICBpZiAoY2FuZGlkYXRlc1tpbmNsdXNpdmVLZXldLnRpbWUgPj0gRE9OVF9DQVJFX1RIUkVTSE9MRCkge1xuICAgICAgYXJyLnB1c2goY2FuZGlkYXRlc1tpbmNsdXNpdmVLZXldKTtcbiAgICB9XG4gIH1cblxuICBhcnIuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGIudGltZSAtIGEudGltZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGFycjtcbn1cblxuZnVuY3Rpb24gZ2V0VW5jaGFuZ2VkQ29tcG9uZW50cyhtZWFzdXJlbWVudCkge1xuICAvLyBGb3IgYSBnaXZlbiByZWNvbmNpbGUsIGxvb2sgYXQgd2hpY2ggY29tcG9uZW50cyBkaWQgbm90IGFjdHVhbGx5XG4gIC8vIHJlbmRlciBhbnl0aGluZyB0byB0aGUgRE9NIGFuZCByZXR1cm4gYSBtYXBwaW5nIG9mIHRoZWlyIElEIHRvXG4gIC8vIHRoZSBhbW91bnQgb2YgdGltZSBpdCB0b29rIHRvIHJlbmRlciB0aGUgZW50aXJlIHN1YnRyZWUuXG4gIHZhciBjbGVhbkNvbXBvbmVudHMgPSB7fTtcbiAgdmFyIGRpcnR5TGVhZklEcyA9IE9iamVjdC5rZXlzKG1lYXN1cmVtZW50LndyaXRlcyk7XG4gIHZhciBhbGxJRHMgPSBtZXJnZShtZWFzdXJlbWVudC5leGNsdXNpdmUsIG1lYXN1cmVtZW50LmluY2x1c2l2ZSk7XG5cbiAgZm9yICh2YXIgaWQgaW4gYWxsSURzKSB7XG4gICAgdmFyIGlzRGlydHkgPSBmYWxzZTtcbiAgICAvLyBGb3IgZWFjaCBjb21wb25lbnQgdGhhdCByZW5kZXJlZCwgc2VlIGlmIGEgY29tcG9uZW50IHRoYXQgdHJpZ2dlcmRcbiAgICAvLyBhIERPTSBvcCBpcyBpbiBpdHMgc3VidHJlZS5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnR5TGVhZklEcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGRpcnR5TGVhZklEc1tpXS5pbmRleE9mKGlkKSA9PT0gMCkge1xuICAgICAgICBpc0RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghaXNEaXJ0eSAmJiBtZWFzdXJlbWVudC5jb3VudHNbaWRdID4gMCkge1xuICAgICAgY2xlYW5Db21wb25lbnRzW2lkXSA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBjbGVhbkNvbXBvbmVudHM7XG59XG5cbnZhciBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMgPSB7XG4gIGdldEV4Y2x1c2l2ZVN1bW1hcnk6IGdldEV4Y2x1c2l2ZVN1bW1hcnksXG4gIGdldEluY2x1c2l2ZVN1bW1hcnk6IGdldEluY2x1c2l2ZVN1bW1hcnksXG4gIGdldERPTVN1bW1hcnk6IGdldERPTVN1bW1hcnksXG4gIGdldFRvdGFsVGltZTogZ2V0VG90YWxUaW1lXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RGVmYXVsdFBlcmZBbmFseXNpcztcbiIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RGVzY3JpcHRvclxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgUmVhY3RDb250ZXh0ID0gcmVxdWlyZShcIi4vUmVhY3RDb250ZXh0XCIpO1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZShcIi4vUmVhY3RDdXJyZW50T3duZXJcIik7XG5cbnZhciBtZXJnZSA9IHJlcXVpcmUoXCIuL21lcmdlXCIpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKFwiLi93YXJuaW5nXCIpO1xuXG4vKipcbiAqIFdhcm4gZm9yIG11dGF0aW9ucy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuZnVuY3Rpb24gZGVmaW5lV2FybmluZ1Byb3BlcnR5KG9iamVjdCwga2V5KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuXG4gICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5fc3RvcmUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fc3RvcmVba2V5XTtcbiAgICB9LFxuXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcoXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAnRG9uXFwndCBzZXQgdGhlICcgKyBrZXkgKyAnIHByb3BlcnR5IG9mIHRoZSBjb21wb25lbnQuICcgK1xuICAgICAgICAnTXV0YXRlIHRoZSBleGlzdGluZyBwcm9wcyBvYmplY3QgaW5zdGVhZC4nXG4gICAgICApIDogbnVsbCk7XG4gICAgICB0aGlzLl9zdG9yZVtrZXldID0gdmFsdWU7XG4gICAgfVxuXG4gIH0pO1xufVxuXG4vKipcbiAqIFRoaXMgaXMgdXBkYXRlZCB0byB0cnVlIGlmIHRoZSBtZW1icmFuZSBpcyBzdWNjZXNzZnVsbHkgY3JlYXRlZC5cbiAqL1xudmFyIHVzZU11dGF0aW9uTWVtYnJhbmUgPSBmYWxzZTtcblxuLyoqXG4gKiBXYXJuIGZvciBtdXRhdGlvbnMuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge29iamVjdH0gZGVzY3JpcHRvclxuICovXG5mdW5jdGlvbiBkZWZpbmVNdXRhdGlvbk1lbWJyYW5lKHByb3RvdHlwZSkge1xuICB0cnkge1xuICAgIHZhciBwc2V1ZG9Gcm96ZW5Qcm9wZXJ0aWVzID0ge1xuICAgICAgcHJvcHM6IHRydWVcbiAgICB9O1xuICAgIGZvciAodmFyIGtleSBpbiBwc2V1ZG9Gcm96ZW5Qcm9wZXJ0aWVzKSB7XG4gICAgICBkZWZpbmVXYXJuaW5nUHJvcGVydHkocHJvdG90eXBlLCBrZXkpO1xuICAgIH1cbiAgICB1c2VNdXRhdGlvbk1lbWJyYW5lID0gdHJ1ZTtcbiAgfSBjYXRjaCAoeCkge1xuICAgIC8vIElFIHdpbGwgZmFpbCBvbiBkZWZpbmVQcm9wZXJ0eVxuICB9XG59XG5cbi8qKlxuICogVHJhbnNmZXIgc3RhdGljIHByb3BlcnRpZXMgZnJvbSB0aGUgc291cmNlIHRvIHRoZSB0YXJnZXQuIEZ1bmN0aW9ucyBhcmVcbiAqIHJlYm91bmQgdG8gaGF2ZSB0aGlzIHJlZmxlY3QgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqL1xuZnVuY3Rpb24gcHJveHlTdGF0aWNNZXRob2RzKHRhcmdldCwgc291cmNlKSB7XG4gIGlmICh0eXBlb2Ygc291cmNlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgYm91bmQgPSB2YWx1ZS5iaW5kKHNvdXJjZSk7XG4gICAgICAgIC8vIENvcHkgYW55IHByb3BlcnRpZXMgZGVmaW5lZCBvbiB0aGUgZnVuY3Rpb24sIHN1Y2ggYXMgYGlzUmVxdWlyZWRgIG9uXG4gICAgICAgIC8vIGEgUHJvcFR5cGVzIHZhbGlkYXRvci4gKG1lcmdlSW50byByZWZ1c2VzIHRvIHdvcmsgb24gZnVuY3Rpb25zLilcbiAgICAgICAgZm9yICh2YXIgayBpbiB2YWx1ZSkge1xuICAgICAgICAgIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgYm91bmRba10gPSB2YWx1ZVtrXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0W2tleV0gPSBib3VuZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQmFzZSBjb25zdHJ1Y3RvciBmb3IgYWxsIFJlYWN0IGRlc2NyaXB0b3JzLiBUaGlzIGlzIG9ubHkgdXNlZCB0byBtYWtlIHRoaXNcbiAqIHdvcmsgd2l0aCBhIGR5bmFtaWMgaW5zdGFuY2VvZiBjaGVjay4gTm90aGluZyBzaG91bGQgbGl2ZSBvbiB0aGlzIHByb3RvdHlwZS5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3REZXNjcmlwdG9yID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICBkZWZpbmVNdXRhdGlvbk1lbWJyYW5lKFJlYWN0RGVzY3JpcHRvci5wcm90b3R5cGUpO1xufVxuXG5SZWFjdERlc2NyaXB0b3IuY3JlYXRlRmFjdG9yeSA9IGZ1bmN0aW9uKHR5cGUpIHtcblxuICB2YXIgZGVzY3JpcHRvclByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUmVhY3REZXNjcmlwdG9yLnByb3RvdHlwZSk7XG5cbiAgdmFyIGZhY3RvcnkgPSBmdW5jdGlvbihwcm9wcywgY2hpbGRyZW4pIHtcbiAgICAvLyBGb3IgY29uc2lzdGVuY3kgd2UgY3VycmVudGx5IGFsbG9jYXRlIGEgbmV3IG9iamVjdCBmb3IgZXZlcnkgZGVzY3JpcHRvci5cbiAgICAvLyBUaGlzIHByb3RlY3RzIHRoZSBkZXNjcmlwdG9yIGZyb20gYmVpbmcgbXV0YXRlZCBieSB0aGUgb3JpZ2luYWwgcHJvcHNcbiAgICAvLyBvYmplY3QgYmVpbmcgbXV0YXRlZC4gSXQgYWxzbyBwcm90ZWN0cyB0aGUgb3JpZ2luYWwgcHJvcHMgb2JqZWN0IGZyb21cbiAgICAvLyBiZWluZyBtdXRhdGVkIGJ5IGNoaWxkcmVuIGFyZ3VtZW50cyBhbmQgZGVmYXVsdCBwcm9wcy4gVGhpcyBiZWhhdmlvclxuICAgIC8vIGNvbWVzIHdpdGggYSBwZXJmb3JtYW5jZSBjb3N0IGFuZCBjb3VsZCBiZSBkZXByZWNhdGVkIGluIHRoZSBmdXR1cmUuXG4gICAgLy8gSXQgY291bGQgYWxzbyBiZSBvcHRpbWl6ZWQgd2l0aCBhIHNtYXJ0ZXIgSlNYIHRyYW5zZm9ybS5cbiAgICBpZiAocHJvcHMgPT0gbnVsbCkge1xuICAgICAgcHJvcHMgPSB7fTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9wcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHByb3BzID0gbWVyZ2UocHJvcHMpO1xuICAgIH1cblxuICAgIC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cbiAgICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcbiAgICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDFdO1xuICAgICAgfVxuICAgICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgdGhlIGRlc2NyaXB0b3Igb2JqZWN0XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuY3JlYXRlKGRlc2NyaXB0b3JQcm90b3R5cGUpO1xuXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZGVzY3JpcHRvci5cbiAgICBkZXNjcmlwdG9yLl9vd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG5cbiAgICAvLyBUT0RPOiBEZXByZWNhdGUgd2l0aENvbnRleHQsIGFuZCB0aGVuIHRoZSBjb250ZXh0IGJlY29tZXMgYWNjZXNzaWJsZVxuICAgIC8vIHRocm91Z2ggdGhlIG93bmVyLlxuICAgIGRlc2NyaXB0b3IuX2NvbnRleHQgPSBSZWFjdENvbnRleHQuY3VycmVudDtcblxuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgYW5kIHByb3BzIGFyZSBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCB0aGVtIG9uXG4gICAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgICBkZXNjcmlwdG9yLl9zdG9yZSA9IHsgdmFsaWRhdGVkOiBmYWxzZSwgcHJvcHM6IHByb3BzIH07XG5cbiAgICAgIC8vIFdlJ3JlIG5vdCBhbGxvd2VkIHRvIHNldCBwcm9wcyBkaXJlY3RseSBvbiB0aGUgb2JqZWN0IHNvIHdlIGVhcmx5XG4gICAgICAvLyByZXR1cm4gYW5kIHJlbHkgb24gdGhlIHByb3RvdHlwZSBtZW1icmFuZSB0byBmb3J3YXJkIHRvIHRoZSBiYWNraW5nXG4gICAgICAvLyBzdG9yZS5cbiAgICAgIGlmICh1c2VNdXRhdGlvbk1lbWJyYW5lKSB7XG4gICAgICAgIE9iamVjdC5mcmVlemUoZGVzY3JpcHRvcik7XG4gICAgICAgIHJldHVybiBkZXNjcmlwdG9yO1xuICAgICAgfVxuICAgIH1cblxuICAgIGRlc2NyaXB0b3IucHJvcHMgPSBwcm9wcztcbiAgICByZXR1cm4gZGVzY3JpcHRvcjtcbiAgfTtcblxuICAvLyBDdXJyZW50bHkgd2UgZXhwb3NlIHRoZSBwcm90b3R5cGUgb2YgdGhlIGRlc2NyaXB0b3Igc28gdGhhdFxuICAvLyA8Rm9vIC8+IGluc3RhbmNlb2YgRm9vIHdvcmtzLiBUaGlzIGlzIGNvbnRyb3ZlcnNpYWwgcGF0dGVybi5cbiAgZmFjdG9yeS5wcm90b3R5cGUgPSBkZXNjcmlwdG9yUHJvdG90eXBlO1xuXG4gIC8vIEV4cG9zZSB0aGUgdHlwZSBvbiB0aGUgZmFjdG9yeSBhbmQgdGhlIHByb3RvdHlwZSBzbyB0aGF0IGl0IGNhbiBiZVxuICAvLyBlYXNpbHkgYWNjZXNzZWQgb24gZGVzY3JpcHRvcnMuIEUuZy4gPEZvbyAvPi50eXBlID09PSBGb28udHlwZSBhbmQgZm9yXG4gIC8vIHN0YXRpYyBtZXRob2RzIGxpa2UgPEZvbyAvPi50eXBlLnN0YXRpY01ldGhvZCgpO1xuICAvLyBUaGlzIHNob3VsZCBub3QgYmUgbmFtZWQgY29uc3RydWN0b3Igc2luY2UgdGhpcyBtYXkgbm90IGJlIHRoZSBmdW5jdGlvblxuICAvLyB0aGF0IGNyZWF0ZWQgdGhlIGRlc2NyaXB0b3IsIGFuZCBpdCBtYXkgbm90IGV2ZW4gYmUgYSBjb25zdHJ1Y3Rvci5cbiAgZmFjdG9yeS50eXBlID0gdHlwZTtcbiAgZGVzY3JpcHRvclByb3RvdHlwZS50eXBlID0gdHlwZTtcblxuICBwcm94eVN0YXRpY01ldGhvZHMoZmFjdG9yeSwgdHlwZSk7XG5cbiAgLy8gRXhwb3NlIGEgdW5pcXVlIGNvbnN0cnVjdG9yIG9uIHRoZSBwcm90b3R5cGUgaXMgdGhhdCB0aGlzIHdvcmtzIHdpdGggdHlwZVxuICAvLyBzeXN0ZW1zIHRoYXQgY29tcGFyZSBjb25zdHJ1Y3RvciBwcm9wZXJ0aWVzOiA8Rm9vIC8+LmNvbnN0cnVjdG9yID09PSBGb29cbiAgLy8gVGhpcyBtYXkgYmUgY29udHJvdmVyc2lhbCBzaW5jZSBpdCByZXF1aXJlcyBhIGtub3duIGZhY3RvcnkgZnVuY3Rpb24uXG4gIGRlc2NyaXB0b3JQcm90b3R5cGUuY29uc3RydWN0b3IgPSBmYWN0b3J5O1xuXG4gIHJldHVybiBmYWN0b3J5O1xuXG59O1xuXG5SZWFjdERlc2NyaXB0b3IuY2xvbmVBbmRSZXBsYWNlUHJvcHMgPSBmdW5jdGlvbihvbGREZXNjcmlwdG9yLCBuZXdQcm9wcykge1xuICB2YXIgbmV3RGVzY3JpcHRvciA9IE9iamVjdC5jcmVhdGUob2xkRGVzY3JpcHRvci5jb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xuICAvLyBJdCdzIGltcG9ydGFudCB0aGF0IHRoaXMgcHJvcGVydHkgb3JkZXIgbWF0Y2hlcyB0aGUgaGlkZGVuIGNsYXNzIG9mIHRoZVxuICAvLyBvcmlnaW5hbCBkZXNjcmlwdG9yIHRvIG1haW50YWluIHBlcmYuXG4gIG5ld0Rlc2NyaXB0b3IuX293bmVyID0gb2xkRGVzY3JpcHRvci5fb3duZXI7XG4gIG5ld0Rlc2NyaXB0b3IuX2NvbnRleHQgPSBvbGREZXNjcmlwdG9yLl9jb250ZXh0O1xuXG4gIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICBuZXdEZXNjcmlwdG9yLl9zdG9yZSA9IHtcbiAgICAgIHZhbGlkYXRlZDogb2xkRGVzY3JpcHRvci5fc3RvcmUudmFsaWRhdGVkLFxuICAgICAgcHJvcHM6IG5ld1Byb3BzXG4gICAgfTtcbiAgICBpZiAodXNlTXV0YXRpb25NZW1icmFuZSkge1xuICAgICAgT2JqZWN0LmZyZWV6ZShuZXdEZXNjcmlwdG9yKTtcbiAgICAgIHJldHVybiBuZXdEZXNjcmlwdG9yO1xuICAgIH1cbiAgfVxuXG4gIG5ld0Rlc2NyaXB0b3IucHJvcHMgPSBuZXdQcm9wcztcbiAgcmV0dXJuIG5ld0Rlc2NyaXB0b3I7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIHZhbHVlIGlzIGEgdmFsaWQgZGVzY3JpcHRvciBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0geyp9XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogQHB1YmxpY1xuICovXG5SZWFjdERlc2NyaXB0b3IuaXNWYWxpZEZhY3RvcnkgPSBmdW5jdGlvbihmYWN0b3J5KSB7XG4gIHJldHVybiB0eXBlb2YgZmFjdG9yeSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgZmFjdG9yeS5wcm90b3R5cGUgaW5zdGFuY2VvZiBSZWFjdERlc2NyaXB0b3I7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgdmFsaWQgY29tcG9uZW50LlxuICogQGZpbmFsXG4gKi9cblJlYWN0RGVzY3JpcHRvci5pc1ZhbGlkRGVzY3JpcHRvciA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgUmVhY3REZXNjcmlwdG9yO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERlc2NyaXB0b3I7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3REZXNjcmlwdG9yVmFsaWRhdG9yXG4gKi9cblxuLyoqXG4gKiBSZWFjdERlc2NyaXB0b3JWYWxpZGF0b3IgcHJvdmlkZXMgYSB3cmFwcGVyIGFyb3VuZCBhIGRlc2NyaXB0b3IgZmFjdG9yeVxuICogd2hpY2ggdmFsaWRhdGVzIHRoZSBwcm9wcyBwYXNzZWQgdG8gdGhlIGRlc2NyaXB0b3IuIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmVcbiAqIHVzZWQgb25seSBpbiBERVYgYW5kIGNvdWxkIGJlIHJlcGxhY2VkIGJ5IGEgc3RhdGljIHR5cGUgY2hlY2tlciBmb3IgbGFuZ3VhZ2VzXG4gKiB0aGF0IHN1cHBvcnQgaXQuXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBSZWFjdERlc2NyaXB0b3IgPSByZXF1aXJlKFwiLi9SZWFjdERlc2NyaXB0b3JcIik7XG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucyA9IHJlcXVpcmUoXCIuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbnNcIik7XG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKFwiLi9SZWFjdEN1cnJlbnRPd25lclwiKTtcblxudmFyIG1vbml0b3JDb2RlVXNlID0gcmVxdWlyZShcIi4vbW9uaXRvckNvZGVVc2VcIik7XG5cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge1xuICAncmVhY3Rfa2V5X3dhcm5pbmcnOiB7fSxcbiAgJ3JlYWN0X251bWVyaWNfa2V5X3dhcm5pbmcnOiB7fVxufTtcbnZhciBvd25lckhhc01vbml0b3JlZE9iamVjdE1hcCA9IHt9O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG5cbnZhciBOVU1FUklDX1BST1BFUlRZX1JFR0VYID0gL15cXGQrJC87XG5cbi8qKlxuICogR2V0cyB0aGUgY3VycmVudCBvd25lcidzIGRpc3BsYXlOYW1lIGZvciB1c2UgaW4gd2FybmluZ3MuXG4gKlxuICogQGludGVybmFsXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBEaXNwbGF5IG5hbWUgb3IgdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIGdldEN1cnJlbnRPd25lckRpc3BsYXlOYW1lKCkge1xuICB2YXIgY3VycmVudCA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gIHJldHVybiBjdXJyZW50ICYmIGN1cnJlbnQuY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFdhcm4gaWYgdGhlIGNvbXBvbmVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBjb21wb25lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnQgQ29tcG9uZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgY29tcG9uZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShjb21wb25lbnQsIHBhcmVudFR5cGUpIHtcbiAgaWYgKGNvbXBvbmVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGNvbXBvbmVudC5wcm9wcy5rZXkgIT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb21wb25lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG5cbiAgd2FybkFuZE1vbml0b3JGb3JLZXlVc2UoXG4gICAgJ3JlYWN0X2tleV93YXJuaW5nJyxcbiAgICAnRWFjaCBjaGlsZCBpbiBhbiBhcnJheSBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyxcbiAgICBjb21wb25lbnQsXG4gICAgcGFyZW50VHlwZVxuICApO1xufVxuXG4vKipcbiAqIFdhcm4gaWYgdGhlIGtleSBpcyBiZWluZyBkZWZpbmVkIGFzIGFuIG9iamVjdCBwcm9wZXJ0eSBidXQgaGFzIGFuIGluY29ycmVjdFxuICogdmFsdWUuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBQcm9wZXJ0eSBuYW1lIG9mIHRoZSBrZXkuXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnQgQ29tcG9uZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgY29tcG9uZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0eUtleShuYW1lLCBjb21wb25lbnQsIHBhcmVudFR5cGUpIHtcbiAgaWYgKCFOVU1FUklDX1BST1BFUlRZX1JFR0VYLnRlc3QobmFtZSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2FybkFuZE1vbml0b3JGb3JLZXlVc2UoXG4gICAgJ3JlYWN0X251bWVyaWNfa2V5X3dhcm5pbmcnLFxuICAgICdDaGlsZCBvYmplY3RzIHNob3VsZCBoYXZlIG5vbi1udW1lcmljIGtleXMgc28gb3JkZXJpbmcgaXMgcHJlc2VydmVkLicsXG4gICAgY29tcG9uZW50LFxuICAgIHBhcmVudFR5cGVcbiAgKTtcbn1cblxuLyoqXG4gKiBTaGFyZWQgd2FybmluZyBhbmQgbW9uaXRvcmluZyBjb2RlIGZvciB0aGUga2V5IHdhcm5pbmdzLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtzdHJpbmd9IHdhcm5pbmdJRCBUaGUgaWQgdXNlZCB3aGVuIGxvZ2dpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBUaGUgYmFzZSB3YXJuaW5nIHRoYXQgZ2V0cyBvdXRwdXQuXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnQgQ29tcG9uZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgY29tcG9uZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuZnVuY3Rpb24gd2FybkFuZE1vbml0b3JGb3JLZXlVc2Uod2FybmluZ0lELCBtZXNzYWdlLCBjb21wb25lbnQsIHBhcmVudFR5cGUpIHtcbiAgdmFyIG93bmVyTmFtZSA9IGdldEN1cnJlbnRPd25lckRpc3BsYXlOYW1lKCk7XG4gIHZhciBwYXJlbnROYW1lID0gcGFyZW50VHlwZS5kaXNwbGF5TmFtZTtcblxuICB2YXIgdXNlTmFtZSA9IG93bmVyTmFtZSB8fCBwYXJlbnROYW1lO1xuICB2YXIgbWVtb2l6ZXIgPSBvd25lckhhc0tleVVzZVdhcm5pbmdbd2FybmluZ0lEXTtcbiAgaWYgKG1lbW9pemVyLmhhc093blByb3BlcnR5KHVzZU5hbWUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIG1lbW9pemVyW3VzZU5hbWVdID0gdHJ1ZTtcblxuICBtZXNzYWdlICs9IG93bmVyTmFtZSA/XG4gICAgKFwiIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIFwiICsgb3duZXJOYW1lICsgXCIuXCIpIDpcbiAgICAoXCIgQ2hlY2sgdGhlIHJlbmRlckNvbXBvbmVudCBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCIpO1xuXG4gIC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuICB2YXIgY2hpbGRPd25lck5hbWUgPSBudWxsO1xuICBpZiAoY29tcG9uZW50Ll9vd25lciAmJiBjb21wb25lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgLy8gTmFtZSBvZiB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgY2hpbGRPd25lck5hbWUgPSBjb21wb25lbnQuX293bmVyLmNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lO1xuXG4gICAgbWVzc2FnZSArPSAoXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBjaGlsZE93bmVyTmFtZSArIFwiLlwiKTtcbiAgfVxuXG4gIG1lc3NhZ2UgKz0gJyBTZWUgaHR0cDovL2ZiLm1lL3JlYWN0LXdhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nO1xuICBtb25pdG9yQ29kZVVzZSh3YXJuaW5nSUQsIHtcbiAgICBjb21wb25lbnQ6IHVzZU5hbWUsXG4gICAgY29tcG9uZW50T3duZXI6IGNoaWxkT3duZXJOYW1lXG4gIH0pO1xuICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG59XG5cbi8qKlxuICogTG9nIHRoYXQgd2UncmUgdXNpbmcgYW4gb2JqZWN0IG1hcC4gV2UncmUgY29uc2lkZXJpbmcgZGVwcmVjYXRpbmcgdGhpc1xuICogZmVhdHVyZSBhbmQgcmVwbGFjZSBpdCB3aXRoIHByb3BlciBNYXAgYW5kIEltbXV0YWJsZU1hcCBkYXRhIHN0cnVjdHVyZXMuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIG1vbml0b3JVc2VPZk9iamVjdE1hcCgpIHtcbiAgdmFyIGN1cnJlbnROYW1lID0gZ2V0Q3VycmVudE93bmVyRGlzcGxheU5hbWUoKSB8fCAnJztcbiAgaWYgKG93bmVySGFzTW9uaXRvcmVkT2JqZWN0TWFwLmhhc093blByb3BlcnR5KGN1cnJlbnROYW1lKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBvd25lckhhc01vbml0b3JlZE9iamVjdE1hcFtjdXJyZW50TmFtZV0gPSB0cnVlO1xuICBtb25pdG9yQ29kZVVzZSgncmVhY3Rfb2JqZWN0X21hcF9jaGlsZHJlbicpO1xufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGNvbXBvbmVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7Kn0gY29tcG9uZW50IFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGNvbXBvbmVudCdzIHBhcmVudCdzIHR5cGUuXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhjb21wb25lbnQsIHBhcmVudFR5cGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY29tcG9uZW50KSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tcG9uZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBjb21wb25lbnRbaV07XG4gICAgICBpZiAoUmVhY3REZXNjcmlwdG9yLmlzVmFsaWREZXNjcmlwdG9yKGNoaWxkKSkge1xuICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoUmVhY3REZXNjcmlwdG9yLmlzVmFsaWREZXNjcmlwdG9yKGNvbXBvbmVudCkpIHtcbiAgICAvLyBUaGlzIGNvbXBvbmVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgY29tcG9uZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICB9IGVsc2UgaWYgKGNvbXBvbmVudCAmJiB0eXBlb2YgY29tcG9uZW50ID09PSAnb2JqZWN0Jykge1xuICAgIG1vbml0b3JVc2VPZk9iamVjdE1hcCgpO1xuICAgIGZvciAodmFyIG5hbWUgaW4gY29tcG9uZW50KSB7XG4gICAgICB2YWxpZGF0ZVByb3BlcnR5S2V5KG5hbWUsIGNvbXBvbmVudFtuYW1lXSwgcGFyZW50VHlwZSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHByb3BzIGFyZSB2YWxpZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcFR5cGVzIE1hcCBvZiBwcm9wIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKGNvbXBvbmVudE5hbWUsIHByb3BUeXBlcywgcHJvcHMsIGxvY2F0aW9uKSB7XG4gIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BUeXBlcykge1xuICAgIGlmIChwcm9wVHlwZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICB2YXIgZXJyb3I7XG4gICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuICAgICAgdHJ5IHtcbiAgICAgICAgZXJyb3IgPSBwcm9wVHlwZXNbcHJvcE5hbWVdKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24pO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAvLyBUaGlzIHdpbGwgc29vbiB1c2UgdGhlIHdhcm5pbmcgbW9kdWxlXG4gICAgICAgIG1vbml0b3JDb2RlVXNlKFxuICAgICAgICAgICdyZWFjdF9mYWlsZWRfZGVzY3JpcHRvcl90eXBlX2NoZWNrJyxcbiAgICAgICAgICB7IG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3REZXNjcmlwdG9yVmFsaWRhdG9yID0ge1xuXG4gIC8qKlxuICAgKiBXcmFwcyBhIGRlc2NyaXB0b3IgZmFjdG9yeSBmdW5jdGlvbiBpbiBhbm90aGVyIGZ1bmN0aW9uIHdoaWNoIHZhbGlkYXRlc1xuICAgKiB0aGUgcHJvcHMgYW5kIGNvbnRleHQgb2YgdGhlIGRlc2NyaXB0b3IgYW5kIHdhcm5zIGFib3V0IGFueSBmYWlsZWQgdHlwZVxuICAgKiBjaGVja3MuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZhY3RvcnkgVGhlIG9yaWdpbmFsIGRlc2NyaXB0b3IgZmFjdG9yeVxuICAgKiBAcGFyYW0ge29iamVjdD99IHByb3BUeXBlcyBBIHByb3AgdHlwZSBkZWZpbml0aW9uIHNldFxuICAgKiBAcGFyYW0ge29iamVjdD99IGNvbnRleHRUeXBlcyBBIGNvbnRleHQgdHlwZSBkZWZpbml0aW9uIHNldFxuICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBjb21wb25lbnQgZGVzY3JpcHRvciwgd2hpY2ggbWF5IGJlIGludmFsaWQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjcmVhdGVGYWN0b3J5OiBmdW5jdGlvbihmYWN0b3J5LCBwcm9wVHlwZXMsIGNvbnRleHRUeXBlcykge1xuICAgIHZhciB2YWxpZGF0ZWRGYWN0b3J5ID0gZnVuY3Rpb24ocHJvcHMsIGNoaWxkcmVuKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IGZhY3RvcnkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCBkZXNjcmlwdG9yLnR5cGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmFtZSA9IGRlc2NyaXB0b3IudHlwZS5kaXNwbGF5TmFtZTtcbiAgICAgIGlmIChwcm9wVHlwZXMpIHtcbiAgICAgICAgY2hlY2tQcm9wVHlwZXMoXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBwcm9wVHlwZXMsXG4gICAgICAgICAgZGVzY3JpcHRvci5wcm9wcyxcbiAgICAgICAgICBSZWFjdFByb3BUeXBlTG9jYXRpb25zLnByb3BcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb250ZXh0VHlwZXMpIHtcbiAgICAgICAgY2hlY2tQcm9wVHlwZXMoXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBjb250ZXh0VHlwZXMsXG4gICAgICAgICAgZGVzY3JpcHRvci5fY29udGV4dCxcbiAgICAgICAgICBSZWFjdFByb3BUeXBlTG9jYXRpb25zLmNvbnRleHRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXNjcmlwdG9yO1xuICAgIH07XG5cbiAgICB2YWxpZGF0ZWRGYWN0b3J5LnByb3RvdHlwZSA9IGZhY3RvcnkucHJvdG90eXBlO1xuICAgIHZhbGlkYXRlZEZhY3RvcnkudHlwZSA9IGZhY3RvcnkudHlwZTtcblxuICAgIC8vIENvcHkgc3RhdGljIHByb3BlcnRpZXNcbiAgICBmb3IgKHZhciBrZXkgaW4gZmFjdG9yeSkge1xuICAgICAgaWYgKGZhY3RvcnkuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICB2YWxpZGF0ZWRGYWN0b3J5W2tleV0gPSBmYWN0b3J5W2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbGlkYXRlZEZhY3Rvcnk7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERlc2NyaXB0b3JWYWxpZGF0b3I7XG4iLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEVtcHR5Q29tcG9uZW50XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbnZhciBjb21wb25lbnQ7XG4vLyBUaGlzIHJlZ2lzdHJ5IGtlZXBzIHRyYWNrIG9mIHRoZSBSZWFjdCBJRHMgb2YgdGhlIGNvbXBvbmVudHMgdGhhdCByZW5kZXJlZCB0b1xuLy8gYG51bGxgIChpbiByZWFsaXR5IGEgcGxhY2Vob2xkZXIgc3VjaCBhcyBgbm9zY3JpcHRgKVxudmFyIG51bGxDb21wb25lbnRJZHNSZWdpc3RyeSA9IHt9O1xuXG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudEluamVjdGlvbiA9IHtcbiAgaW5qZWN0RW1wdHlDb21wb25lbnQ6IGZ1bmN0aW9uKGVtcHR5Q29tcG9uZW50KSB7XG4gICAgY29tcG9uZW50ID0gZW1wdHlDb21wb25lbnQ7XG4gIH1cbn07XG5cbi8qKlxuICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudCBUaGUgaW5qZWN0ZWQgZW1wdHkgY29tcG9uZW50LlxuICovXG5mdW5jdGlvbiBnZXRFbXB0eUNvbXBvbmVudCgpIHtcbiAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICBjb21wb25lbnQsXG4gICAgJ1RyeWluZyB0byByZXR1cm4gbnVsbCBmcm9tIGEgcmVuZGVyLCBidXQgbm8gbnVsbCBwbGFjZWhvbGRlciBjb21wb25lbnQgJyArXG4gICAgJ3dhcyBpbmplY3RlZC4nXG4gICkgOiBpbnZhcmlhbnQoY29tcG9uZW50KSk7XG4gIHJldHVybiBjb21wb25lbnQoKTtcbn1cblxuLyoqXG4gKiBNYXJrIHRoZSBjb21wb25lbnQgYXMgaGF2aW5nIHJlbmRlcmVkIHRvIG51bGwuXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgQ29tcG9uZW50J3MgYF9yb290Tm9kZUlEYC5cbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJOdWxsQ29tcG9uZW50SUQoaWQpIHtcbiAgbnVsbENvbXBvbmVudElkc1JlZ2lzdHJ5W2lkXSA9IHRydWU7XG59XG5cbi8qKlxuICogVW5tYXJrIHRoZSBjb21wb25lbnQgYXMgaGF2aW5nIHJlbmRlcmVkIHRvIG51bGw6IGl0IHJlbmRlcnMgdG8gc29tZXRoaW5nIG5vdy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBDb21wb25lbnQncyBgX3Jvb3ROb2RlSURgLlxuICovXG5mdW5jdGlvbiBkZXJlZ2lzdGVyTnVsbENvbXBvbmVudElEKGlkKSB7XG4gIGRlbGV0ZSBudWxsQ29tcG9uZW50SWRzUmVnaXN0cnlbaWRdO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBDb21wb25lbnQncyBgX3Jvb3ROb2RlSURgLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgY29tcG9uZW50IGlzIHJlbmRlcmVkIHRvIG51bGwuXG4gKi9cbmZ1bmN0aW9uIGlzTnVsbENvbXBvbmVudElEKGlkKSB7XG4gIHJldHVybiBudWxsQ29tcG9uZW50SWRzUmVnaXN0cnlbaWRdO1xufVxuXG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudCA9IHtcbiAgZGVyZWdpc3Rlck51bGxDb21wb25lbnRJRDogZGVyZWdpc3Rlck51bGxDb21wb25lbnRJRCxcbiAgZ2V0RW1wdHlDb21wb25lbnQ6IGdldEVtcHR5Q29tcG9uZW50LFxuICBpbmplY3Rpb246IFJlYWN0RW1wdHlDb21wb25lbnRJbmplY3Rpb24sXG4gIGlzTnVsbENvbXBvbmVudElEOiBpc051bGxDb21wb25lbnRJRCxcbiAgcmVnaXN0ZXJOdWxsQ29tcG9uZW50SUQ6IHJlZ2lzdGVyTnVsbENvbXBvbmVudElEXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RW1wdHlDb21wb25lbnQ7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEVycm9yVXRpbHNcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBSZWFjdEVycm9yVXRpbHMgPSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZ3VhcmRlZCB2ZXJzaW9uIG9mIGEgZnVuY3Rpb24uIFRoaXMgaXMgc3VwcG9zZWQgdG8gbWFrZSBkZWJ1Z2dpbmdcbiAgICogb2YgZXZlbnQgaGFuZGxlcnMgZWFzaWVyLiBUbyBhaWQgZGVidWdnaW5nIHdpdGggdGhlIGJyb3dzZXIncyBkZWJ1Z2dlcixcbiAgICogdGhpcyBjdXJyZW50bHkgc2ltcGx5IHJldHVybnMgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jIEZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBndWFyZFxuICAgKiBAcmV0dXJuIHtmdW5jdGlvbn1cbiAgICovXG4gIGd1YXJkOiBmdW5jdGlvbihmdW5jLCBuYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFcnJvclV0aWxzO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RXZlbnRFbWl0dGVyTWl4aW5cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIEV2ZW50UGx1Z2luSHViID0gcmVxdWlyZShcIi4vRXZlbnRQbHVnaW5IdWJcIik7XG5cbmZ1bmN0aW9uIHJ1bkV2ZW50UXVldWVJbkJhdGNoKGV2ZW50cykge1xuICBFdmVudFBsdWdpbkh1Yi5lbnF1ZXVlRXZlbnRzKGV2ZW50cyk7XG4gIEV2ZW50UGx1Z2luSHViLnByb2Nlc3NFdmVudFF1ZXVlKCk7XG59XG5cbnZhciBSZWFjdEV2ZW50RW1pdHRlck1peGluID0ge1xuXG4gIC8qKlxuICAgKiBTdHJlYW1zIGEgZmlyZWQgdG9wLWxldmVsIGV2ZW50IHRvIGBFdmVudFBsdWdpbkh1YmAgd2hlcmUgcGx1Z2lucyBoYXZlIHRoZVxuICAgKiBvcHBvcnR1bml0eSB0byBjcmVhdGUgYFJlYWN0RXZlbnRgcyB0byBiZSBkaXNwYXRjaGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB0b3BMZXZlbFRhcmdldCBUaGUgbGlzdGVuaW5nIGNvbXBvbmVudCByb290IG5vZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFRhcmdldElEIElEIG9mIGB0b3BMZXZlbFRhcmdldGAuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgZW52aXJvbm1lbnQgZXZlbnQuXG4gICAqL1xuICBoYW5kbGVUb3BMZXZlbDogZnVuY3Rpb24oXG4gICAgICB0b3BMZXZlbFR5cGUsXG4gICAgICB0b3BMZXZlbFRhcmdldCxcbiAgICAgIHRvcExldmVsVGFyZ2V0SUQsXG4gICAgICBuYXRpdmVFdmVudCkge1xuICAgIHZhciBldmVudHMgPSBFdmVudFBsdWdpbkh1Yi5leHRyYWN0RXZlbnRzKFxuICAgICAgdG9wTGV2ZWxUeXBlLFxuICAgICAgdG9wTGV2ZWxUYXJnZXQsXG4gICAgICB0b3BMZXZlbFRhcmdldElELFxuICAgICAgbmF0aXZlRXZlbnRcbiAgICApO1xuXG4gICAgcnVuRXZlbnRRdWV1ZUluQmF0Y2goZXZlbnRzKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEV2ZW50RW1pdHRlck1peGluO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RXZlbnRMaXN0ZW5lclxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIEV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKFwiLi9FdmVudExpc3RlbmVyXCIpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZShcIi4vRXhlY3V0aW9uRW52aXJvbm1lbnRcIik7XG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKFwiLi9Qb29sZWRDbGFzc1wiKTtcbnZhciBSZWFjdEluc3RhbmNlSGFuZGxlcyA9IHJlcXVpcmUoXCIuL1JlYWN0SW5zdGFuY2VIYW5kbGVzXCIpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKFwiLi9SZWFjdE1vdW50XCIpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoXCIuL1JlYWN0VXBkYXRlc1wiKTtcblxudmFyIGdldEV2ZW50VGFyZ2V0ID0gcmVxdWlyZShcIi4vZ2V0RXZlbnRUYXJnZXRcIik7XG52YXIgZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24gPSByZXF1aXJlKFwiLi9nZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvblwiKTtcbnZhciBtaXhJbnRvID0gcmVxdWlyZShcIi4vbWl4SW50b1wiKTtcblxuLyoqXG4gKiBGaW5kcyB0aGUgcGFyZW50IFJlYWN0IGNvbXBvbmVudCBvZiBgbm9kZWAuXG4gKlxuICogQHBhcmFtIHsqfSBub2RlXG4gKiBAcmV0dXJuIHs/RE9NRXZlbnRUYXJnZXR9IFBhcmVudCBjb250YWluZXIsIG9yIGBudWxsYCBpZiB0aGUgc3BlY2lmaWVkIG5vZGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgbm90IG5lc3RlZC5cbiAqL1xuZnVuY3Rpb24gZmluZFBhcmVudChub2RlKSB7XG4gIC8vIFRPRE86IEl0IG1heSBiZSBhIGdvb2QgaWRlYSB0byBjYWNoZSB0aGlzIHRvIHByZXZlbnQgdW5uZWNlc3NhcnkgRE9NXG4gIC8vIHRyYXZlcnNhbCwgYnV0IGNhY2hpbmcgaXMgZGlmZmljdWx0IHRvIGRvIGNvcnJlY3RseSB3aXRob3V0IHVzaW5nIGFcbiAgLy8gbXV0YXRpb24gb2JzZXJ2ZXIgdG8gbGlzdGVuIGZvciBhbGwgRE9NIGNoYW5nZXMuXG4gIHZhciBub2RlSUQgPSBSZWFjdE1vdW50LmdldElEKG5vZGUpO1xuICB2YXIgcm9vdElEID0gUmVhY3RJbnN0YW5jZUhhbmRsZXMuZ2V0UmVhY3RSb290SURGcm9tTm9kZUlEKG5vZGVJRCk7XG4gIHZhciBjb250YWluZXIgPSBSZWFjdE1vdW50LmZpbmRSZWFjdENvbnRhaW5lckZvcklEKHJvb3RJRCk7XG4gIHZhciBwYXJlbnQgPSBSZWFjdE1vdW50LmdldEZpcnN0UmVhY3RET00oY29udGFpbmVyKTtcbiAgcmV0dXJuIHBhcmVudDtcbn1cblxuLy8gVXNlZCB0byBzdG9yZSBhbmNlc3RvciBoaWVyYXJjaHkgaW4gdG9wIGxldmVsIGNhbGxiYWNrXG5mdW5jdGlvbiBUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICB0aGlzLnRvcExldmVsVHlwZSA9IHRvcExldmVsVHlwZTtcbiAgdGhpcy5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuICB0aGlzLmFuY2VzdG9ycyA9IFtdO1xufVxubWl4SW50byhUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcsIHtcbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50b3BMZXZlbFR5cGUgPSBudWxsO1xuICAgIHRoaXMubmF0aXZlRXZlbnQgPSBudWxsO1xuICAgIHRoaXMuYW5jZXN0b3JzLmxlbmd0aCA9IDA7XG4gIH1cbn0pO1xuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKFxuICBUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcsXG4gIFBvb2xlZENsYXNzLnR3b0FyZ3VtZW50UG9vbGVyXG4pO1xuXG5mdW5jdGlvbiBoYW5kbGVUb3BMZXZlbEltcGwoYm9va0tlZXBpbmcpIHtcbiAgdmFyIHRvcExldmVsVGFyZ2V0ID0gUmVhY3RNb3VudC5nZXRGaXJzdFJlYWN0RE9NKFxuICAgIGdldEV2ZW50VGFyZ2V0KGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50KVxuICApIHx8IHdpbmRvdztcblxuICAvLyBMb29wIHRocm91Z2ggdGhlIGhpZXJhcmNoeSwgaW4gY2FzZSB0aGVyZSdzIGFueSBuZXN0ZWQgY29tcG9uZW50cy5cbiAgLy8gSXQncyBpbXBvcnRhbnQgdGhhdCB3ZSBidWlsZCB0aGUgYXJyYXkgb2YgYW5jZXN0b3JzIGJlZm9yZSBjYWxsaW5nIGFueVxuICAvLyBldmVudCBoYW5kbGVycywgYmVjYXVzZSBldmVudCBoYW5kbGVycyBjYW4gbW9kaWZ5IHRoZSBET00sIGxlYWRpbmcgdG9cbiAgLy8gaW5jb25zaXN0ZW5jaWVzIHdpdGggUmVhY3RNb3VudCdzIG5vZGUgY2FjaGUuIFNlZSAjMTEwNS5cbiAgdmFyIGFuY2VzdG9yID0gdG9wTGV2ZWxUYXJnZXQ7XG4gIHdoaWxlIChhbmNlc3Rvcikge1xuICAgIGJvb2tLZWVwaW5nLmFuY2VzdG9ycy5wdXNoKGFuY2VzdG9yKTtcbiAgICBhbmNlc3RvciA9IGZpbmRQYXJlbnQoYW5jZXN0b3IpO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBib29rS2VlcGluZy5hbmNlc3RvcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdG9wTGV2ZWxUYXJnZXQgPSBib29rS2VlcGluZy5hbmNlc3RvcnNbaV07XG4gICAgdmFyIHRvcExldmVsVGFyZ2V0SUQgPSBSZWFjdE1vdW50LmdldElEKHRvcExldmVsVGFyZ2V0KSB8fCAnJztcbiAgICBSZWFjdEV2ZW50TGlzdGVuZXIuX2hhbmRsZVRvcExldmVsKFxuICAgICAgYm9va0tlZXBpbmcudG9wTGV2ZWxUeXBlLFxuICAgICAgdG9wTGV2ZWxUYXJnZXQsXG4gICAgICB0b3BMZXZlbFRhcmdldElELFxuICAgICAgYm9va0tlZXBpbmcubmF0aXZlRXZlbnRcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNjcm9sbFZhbHVlTW9uaXRvcihjYikge1xuICB2YXIgc2Nyb2xsUG9zaXRpb24gPSBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbih3aW5kb3cpO1xuICBjYihzY3JvbGxQb3NpdGlvbik7XG59XG5cbnZhciBSZWFjdEV2ZW50TGlzdGVuZXIgPSB7XG4gIF9lbmFibGVkOiB0cnVlLFxuICBfaGFuZGxlVG9wTGV2ZWw6IG51bGwsXG5cbiAgV0lORE9XX0hBTkRMRTogRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gd2luZG93IDogbnVsbCxcblxuICBzZXRIYW5kbGVUb3BMZXZlbDogZnVuY3Rpb24oaGFuZGxlVG9wTGV2ZWwpIHtcbiAgICBSZWFjdEV2ZW50TGlzdGVuZXIuX2hhbmRsZVRvcExldmVsID0gaGFuZGxlVG9wTGV2ZWw7XG4gIH0sXG5cbiAgc2V0RW5hYmxlZDogZnVuY3Rpb24oZW5hYmxlZCkge1xuICAgIFJlYWN0RXZlbnRMaXN0ZW5lci5fZW5hYmxlZCA9ICEhZW5hYmxlZDtcbiAgfSxcblxuICBpc0VuYWJsZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBSZWFjdEV2ZW50TGlzdGVuZXIuX2VuYWJsZWQ7XG4gIH0sXG5cblxuICAvKipcbiAgICogVHJhcHMgdG9wLWxldmVsIGV2ZW50cyBieSB1c2luZyBldmVudCBidWJibGluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaGFuZGxlckJhc2VOYW1lIEV2ZW50IG5hbWUgKGUuZy4gXCJjbGlja1wiKS5cbiAgICogQHBhcmFtIHtvYmplY3R9IGhhbmRsZSBFbGVtZW50IG9uIHdoaWNoIHRvIGF0dGFjaCBsaXN0ZW5lci5cbiAgICogQHJldHVybiB7b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBhIHJlbW92ZSBmdW5jdGlvbiB3aGljaCB3aWxsIGZvcmNlZnVsbHlcbiAgICogICAgICAgICAgICAgICAgICByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHRyYXBCdWJibGVkRXZlbnQ6IGZ1bmN0aW9uKHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpIHtcbiAgICB2YXIgZWxlbWVudCA9IGhhbmRsZTtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIEV2ZW50TGlzdGVuZXIubGlzdGVuKFxuICAgICAgZWxlbWVudCxcbiAgICAgIGhhbmRsZXJCYXNlTmFtZSxcbiAgICAgIFJlYWN0RXZlbnRMaXN0ZW5lci5kaXNwYXRjaEV2ZW50LmJpbmQobnVsbCwgdG9wTGV2ZWxUeXBlKVxuICAgICk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyYXBzIGEgdG9wLWxldmVsIGV2ZW50IGJ5IHVzaW5nIGV2ZW50IGNhcHR1cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaGFuZGxlckJhc2VOYW1lIEV2ZW50IG5hbWUgKGUuZy4gXCJjbGlja1wiKS5cbiAgICogQHBhcmFtIHtvYmplY3R9IGhhbmRsZSBFbGVtZW50IG9uIHdoaWNoIHRvIGF0dGFjaCBsaXN0ZW5lci5cbiAgICogQHJldHVybiB7b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBhIHJlbW92ZSBmdW5jdGlvbiB3aGljaCB3aWxsIGZvcmNlZnVsbHlcbiAgICogICAgICAgICAgICAgICAgICByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHRyYXBDYXB0dXJlZEV2ZW50OiBmdW5jdGlvbih0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBoYW5kbGU7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBFdmVudExpc3RlbmVyLmNhcHR1cmUoXG4gICAgICBlbGVtZW50LFxuICAgICAgaGFuZGxlckJhc2VOYW1lLFxuICAgICAgUmVhY3RFdmVudExpc3RlbmVyLmRpc3BhdGNoRXZlbnQuYmluZChudWxsLCB0b3BMZXZlbFR5cGUpXG4gICAgKTtcbiAgfSxcblxuICBtb25pdG9yU2Nyb2xsVmFsdWU6IGZ1bmN0aW9uKHJlZnJlc2gpIHtcbiAgICB2YXIgY2FsbGJhY2sgPSBzY3JvbGxWYWx1ZU1vbml0b3IuYmluZChudWxsLCByZWZyZXNoKTtcbiAgICBFdmVudExpc3RlbmVyLmxpc3Rlbih3aW5kb3csICdzY3JvbGwnLCBjYWxsYmFjayk7XG4gICAgRXZlbnRMaXN0ZW5lci5saXN0ZW4od2luZG93LCAncmVzaXplJywgY2FsbGJhY2spO1xuICB9LFxuXG4gIGRpc3BhdGNoRXZlbnQ6IGZ1bmN0aW9uKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgICBpZiAoIVJlYWN0RXZlbnRMaXN0ZW5lci5fZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBib29rS2VlcGluZyA9IFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZy5nZXRQb29sZWQoXG4gICAgICB0b3BMZXZlbFR5cGUsXG4gICAgICBuYXRpdmVFdmVudFxuICAgICk7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEV2ZW50IHF1ZXVlIGJlaW5nIHByb2Nlc3NlZCBpbiB0aGUgc2FtZSBjeWNsZSBhbGxvd3NcbiAgICAgIC8vIGBwcmV2ZW50RGVmYXVsdGAuXG4gICAgICBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXMoaGFuZGxlVG9wTGV2ZWxJbXBsLCBib29rS2VlcGluZyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZy5yZWxlYXNlKGJvb2tLZWVwaW5nKTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFdmVudExpc3RlbmVyO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0SW5qZWN0aW9uXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoXCIuL0RPTVByb3BlcnR5XCIpO1xudmFyIEV2ZW50UGx1Z2luSHViID0gcmVxdWlyZShcIi4vRXZlbnRQbHVnaW5IdWJcIik7XG52YXIgUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKFwiLi9SZWFjdENvbXBvbmVudFwiKTtcbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCA9IHJlcXVpcmUoXCIuL1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50XCIpO1xudmFyIFJlYWN0RE9NID0gcmVxdWlyZShcIi4vUmVhY3RET01cIik7XG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudCA9IHJlcXVpcmUoXCIuL1JlYWN0RW1wdHlDb21wb25lbnRcIik7XG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcIi4vUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyXCIpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoXCIuL1JlYWN0UGVyZlwiKTtcbnZhciBSZWFjdFJvb3RJbmRleCA9IHJlcXVpcmUoXCIuL1JlYWN0Um9vdEluZGV4XCIpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoXCIuL1JlYWN0VXBkYXRlc1wiKTtcblxudmFyIFJlYWN0SW5qZWN0aW9uID0ge1xuICBDb21wb25lbnQ6IFJlYWN0Q29tcG9uZW50LmluamVjdGlvbixcbiAgQ29tcG9zaXRlQ29tcG9uZW50OiBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5pbmplY3Rpb24sXG4gIERPTVByb3BlcnR5OiBET01Qcm9wZXJ0eS5pbmplY3Rpb24sXG4gIEVtcHR5Q29tcG9uZW50OiBSZWFjdEVtcHR5Q29tcG9uZW50LmluamVjdGlvbixcbiAgRXZlbnRQbHVnaW5IdWI6IEV2ZW50UGx1Z2luSHViLmluamVjdGlvbixcbiAgRE9NOiBSZWFjdERPTS5pbmplY3Rpb24sXG4gIEV2ZW50RW1pdHRlcjogUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmluamVjdGlvbixcbiAgUGVyZjogUmVhY3RQZXJmLmluamVjdGlvbixcbiAgUm9vdEluZGV4OiBSZWFjdFJvb3RJbmRleC5pbmplY3Rpb24sXG4gIFVwZGF0ZXM6IFJlYWN0VXBkYXRlcy5pbmplY3Rpb25cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RJbmplY3Rpb247XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RJbnB1dFNlbGVjdGlvblxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgUmVhY3RET01TZWxlY3Rpb24gPSByZXF1aXJlKFwiLi9SZWFjdERPTVNlbGVjdGlvblwiKTtcblxudmFyIGNvbnRhaW5zTm9kZSA9IHJlcXVpcmUoXCIuL2NvbnRhaW5zTm9kZVwiKTtcbnZhciBmb2N1c05vZGUgPSByZXF1aXJlKFwiLi9mb2N1c05vZGVcIik7XG52YXIgZ2V0QWN0aXZlRWxlbWVudCA9IHJlcXVpcmUoXCIuL2dldEFjdGl2ZUVsZW1lbnRcIik7XG5cbmZ1bmN0aW9uIGlzSW5Eb2N1bWVudChub2RlKSB7XG4gIHJldHVybiBjb250YWluc05vZGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBub2RlKTtcbn1cblxuLyoqXG4gKiBAUmVhY3RJbnB1dFNlbGVjdGlvbjogUmVhY3QgaW5wdXQgc2VsZWN0aW9uIG1vZHVsZS4gQmFzZWQgb24gU2VsZWN0aW9uLmpzLFxuICogYnV0IG1vZGlmaWVkIHRvIGJlIHN1aXRhYmxlIGZvciByZWFjdCBhbmQgaGFzIGEgY291cGxlIG9mIGJ1ZyBmaXhlcyAoZG9lc24ndFxuICogYXNzdW1lIGJ1dHRvbnMgaGF2ZSByYW5nZSBzZWxlY3Rpb25zIGFsbG93ZWQpLlxuICogSW5wdXQgc2VsZWN0aW9uIG1vZHVsZSBmb3IgUmVhY3QuXG4gKi9cbnZhciBSZWFjdElucHV0U2VsZWN0aW9uID0ge1xuXG4gIGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllczogZnVuY3Rpb24oZWxlbSkge1xuICAgIHJldHVybiBlbGVtICYmIChcbiAgICAgIChlbGVtLm5vZGVOYW1lID09PSAnSU5QVVQnICYmIGVsZW0udHlwZSA9PT0gJ3RleHQnKSB8fFxuICAgICAgZWxlbS5ub2RlTmFtZSA9PT0gJ1RFWFRBUkVBJyB8fFxuICAgICAgZWxlbS5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJ1xuICAgICk7XG4gIH0sXG5cbiAgZ2V0U2VsZWN0aW9uSW5mb3JtYXRpb246IGZ1bmN0aW9uKCkge1xuICAgIHZhciBmb2N1c2VkRWxlbSA9IGdldEFjdGl2ZUVsZW1lbnQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgZm9jdXNlZEVsZW06IGZvY3VzZWRFbGVtLFxuICAgICAgc2VsZWN0aW9uUmFuZ2U6XG4gICAgICAgICAgUmVhY3RJbnB1dFNlbGVjdGlvbi5oYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMoZm9jdXNlZEVsZW0pID9cbiAgICAgICAgICBSZWFjdElucHV0U2VsZWN0aW9uLmdldFNlbGVjdGlvbihmb2N1c2VkRWxlbSkgOlxuICAgICAgICAgIG51bGxcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmVzdG9yZVNlbGVjdGlvbjogSWYgYW55IHNlbGVjdGlvbiBpbmZvcm1hdGlvbiB3YXMgcG90ZW50aWFsbHkgbG9zdCxcbiAgICogcmVzdG9yZSBpdC4gVGhpcyBpcyB1c2VmdWwgd2hlbiBwZXJmb3JtaW5nIG9wZXJhdGlvbnMgdGhhdCBjb3VsZCByZW1vdmUgZG9tXG4gICAqIG5vZGVzIGFuZCBwbGFjZSB0aGVtIGJhY2sgaW4sIHJlc3VsdGluZyBpbiBmb2N1cyBiZWluZyBsb3N0LlxuICAgKi9cbiAgcmVzdG9yZVNlbGVjdGlvbjogZnVuY3Rpb24ocHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbikge1xuICAgIHZhciBjdXJGb2N1c2VkRWxlbSA9IGdldEFjdGl2ZUVsZW1lbnQoKTtcbiAgICB2YXIgcHJpb3JGb2N1c2VkRWxlbSA9IHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24uZm9jdXNlZEVsZW07XG4gICAgdmFyIHByaW9yU2VsZWN0aW9uUmFuZ2UgPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLnNlbGVjdGlvblJhbmdlO1xuICAgIGlmIChjdXJGb2N1c2VkRWxlbSAhPT0gcHJpb3JGb2N1c2VkRWxlbSAmJlxuICAgICAgICBpc0luRG9jdW1lbnQocHJpb3JGb2N1c2VkRWxlbSkpIHtcbiAgICAgIGlmIChSZWFjdElucHV0U2VsZWN0aW9uLmhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhwcmlvckZvY3VzZWRFbGVtKSkge1xuICAgICAgICBSZWFjdElucHV0U2VsZWN0aW9uLnNldFNlbGVjdGlvbihcbiAgICAgICAgICBwcmlvckZvY3VzZWRFbGVtLFxuICAgICAgICAgIHByaW9yU2VsZWN0aW9uUmFuZ2VcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGZvY3VzTm9kZShwcmlvckZvY3VzZWRFbGVtKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBnZXRTZWxlY3Rpb246IEdldHMgdGhlIHNlbGVjdGlvbiBib3VuZHMgb2YgYSBmb2N1c2VkIHRleHRhcmVhLCBpbnB1dCBvclxuICAgKiBjb250ZW50RWRpdGFibGUgbm9kZS5cbiAgICogLUBpbnB1dDogTG9vayB1cCBzZWxlY3Rpb24gYm91bmRzIG9mIHRoaXMgaW5wdXRcbiAgICogLUByZXR1cm4ge3N0YXJ0OiBzZWxlY3Rpb25TdGFydCwgZW5kOiBzZWxlY3Rpb25FbmR9XG4gICAqL1xuICBnZXRTZWxlY3Rpb246IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgdmFyIHNlbGVjdGlvbjtcblxuICAgIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIGlucHV0KSB7XG4gICAgICAvLyBNb2Rlcm4gYnJvd3NlciB3aXRoIGlucHV0IG9yIHRleHRhcmVhLlxuICAgICAgc2VsZWN0aW9uID0ge1xuICAgICAgICBzdGFydDogaW5wdXQuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgIGVuZDogaW5wdXQuc2VsZWN0aW9uRW5kXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQuc2VsZWN0aW9uICYmIGlucHV0Lm5vZGVOYW1lID09PSAnSU5QVVQnKSB7XG4gICAgICAvLyBJRTggaW5wdXQuXG4gICAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgICAgIC8vIFRoZXJlIGNhbiBvbmx5IGJlIG9uZSBzZWxlY3Rpb24gcGVyIGRvY3VtZW50IGluIElFLCBzbyBpdCBtdXN0XG4gICAgICAvLyBiZSBpbiBvdXIgZWxlbWVudC5cbiAgICAgIGlmIChyYW5nZS5wYXJlbnRFbGVtZW50KCkgPT09IGlucHV0KSB7XG4gICAgICAgIHNlbGVjdGlvbiA9IHtcbiAgICAgICAgICBzdGFydDogLXJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgLWlucHV0LnZhbHVlLmxlbmd0aCksXG4gICAgICAgICAgZW5kOiAtcmFuZ2UubW92ZUVuZCgnY2hhcmFjdGVyJywgLWlucHV0LnZhbHVlLmxlbmd0aClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29udGVudCBlZGl0YWJsZSBvciBvbGQgSUUgdGV4dGFyZWEuXG4gICAgICBzZWxlY3Rpb24gPSBSZWFjdERPTVNlbGVjdGlvbi5nZXRPZmZzZXRzKGlucHV0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZWN0aW9uIHx8IHtzdGFydDogMCwgZW5kOiAwfTtcbiAgfSxcblxuICAvKipcbiAgICogQHNldFNlbGVjdGlvbjogU2V0cyB0aGUgc2VsZWN0aW9uIGJvdW5kcyBvZiBhIHRleHRhcmVhIG9yIGlucHV0IGFuZCBmb2N1c2VzXG4gICAqIHRoZSBpbnB1dC5cbiAgICogLUBpbnB1dCAgICAgU2V0IHNlbGVjdGlvbiBib3VuZHMgb2YgdGhpcyBpbnB1dCBvciB0ZXh0YXJlYVxuICAgKiAtQG9mZnNldHMgICBPYmplY3Qgb2Ygc2FtZSBmb3JtIHRoYXQgaXMgcmV0dXJuZWQgZnJvbSBnZXQqXG4gICAqL1xuICBzZXRTZWxlY3Rpb246IGZ1bmN0aW9uKGlucHV0LCBvZmZzZXRzKSB7XG4gICAgdmFyIHN0YXJ0ID0gb2Zmc2V0cy5zdGFydDtcbiAgICB2YXIgZW5kID0gb2Zmc2V0cy5lbmQ7XG4gICAgaWYgKHR5cGVvZiBlbmQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBlbmQgPSBzdGFydDtcbiAgICB9XG5cbiAgICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgICAgaW5wdXQuc2VsZWN0aW9uU3RhcnQgPSBzdGFydDtcbiAgICAgIGlucHV0LnNlbGVjdGlvbkVuZCA9IE1hdGgubWluKGVuZCwgaW5wdXQudmFsdWUubGVuZ3RoKTtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50LnNlbGVjdGlvbiAmJiBpbnB1dC5ub2RlTmFtZSA9PT0gJ0lOUFVUJykge1xuICAgICAgdmFyIHJhbmdlID0gaW5wdXQuY3JlYXRlVGV4dFJhbmdlKCk7XG4gICAgICByYW5nZS5jb2xsYXBzZSh0cnVlKTtcbiAgICAgIHJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgc3RhcnQpO1xuICAgICAgcmFuZ2UubW92ZUVuZCgnY2hhcmFjdGVyJywgZW5kIC0gc3RhcnQpO1xuICAgICAgcmFuZ2Uuc2VsZWN0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RE9NU2VsZWN0aW9uLnNldE9mZnNldHMoaW5wdXQsIG9mZnNldHMpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdElucHV0U2VsZWN0aW9uO1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEluc3RhbmNlSGFuZGxlc1xuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIFJlYWN0Um9vdEluZGV4ID0gcmVxdWlyZShcIi4vUmVhY3RSb290SW5kZXhcIik7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbnZhciBTRVBBUkFUT1IgPSAnLic7XG52YXIgU0VQQVJBVE9SX0xFTkdUSCA9IFNFUEFSQVRPUi5sZW5ndGg7XG5cbi8qKlxuICogTWF4aW11bSBkZXB0aCBvZiB0cmF2ZXJzYWxzIGJlZm9yZSB3ZSBjb25zaWRlciB0aGUgcG9zc2liaWxpdHkgb2YgYSBiYWQgSUQuXG4gKi9cbnZhciBNQVhfVFJFRV9ERVBUSCA9IDEwMDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgRE9NIElEIHByZWZpeCB0byB1c2Ugd2hlbiBtb3VudGluZyBSZWFjdCBjb21wb25lbnRzLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBBIHVuaXF1ZSBpbnRlZ2VyXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFJlYWN0IHJvb3QgSUQuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZ2V0UmVhY3RSb290SURTdHJpbmcoaW5kZXgpIHtcbiAgcmV0dXJuIFNFUEFSQVRPUiArIGluZGV4LnRvU3RyaW5nKDM2KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBjaGFyYWN0ZXIgaW4gdGhlIHN1cHBsaWVkIElEIGlzIGEgc2VwYXJhdG9yIG9yIHRoZSBlbmQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIEEgUmVhY3QgRE9NIElELlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IG9mIHRoZSBjaGFyYWN0ZXIgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBjaGFyYWN0ZXIgaXMgYSBzZXBhcmF0b3Igb3IgZW5kIG9mIHRoZSBJRC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzQm91bmRhcnkoaWQsIGluZGV4KSB7XG4gIHJldHVybiBpZC5jaGFyQXQoaW5kZXgpID09PSBTRVBBUkFUT1IgfHwgaW5kZXggPT09IGlkLmxlbmd0aDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHN1cHBsaWVkIHN0cmluZyBpcyBhIHZhbGlkIFJlYWN0IERPTSBJRC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgQSBSZWFjdCBET00gSUQsIG1heWJlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc3RyaW5nIGlzIGEgdmFsaWQgUmVhY3QgRE9NIElELlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZElEKGlkKSB7XG4gIHJldHVybiBpZCA9PT0gJycgfHwgKFxuICAgIGlkLmNoYXJBdCgwKSA9PT0gU0VQQVJBVE9SICYmIGlkLmNoYXJBdChpZC5sZW5ndGggLSAxKSAhPT0gU0VQQVJBVE9SXG4gICk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBmaXJzdCBJRCBpcyBhbiBhbmNlc3RvciBvZiBvciBlcXVhbCB0byB0aGUgc2Vjb25kIElELlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhbmNlc3RvcklEXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVzY2VuZGFudElEXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBhbmNlc3RvcklEYCBpcyBhbiBhbmNlc3RvciBvZiBgZGVzY2VuZGFudElEYC5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBpc0FuY2VzdG9ySURPZihhbmNlc3RvcklELCBkZXNjZW5kYW50SUQpIHtcbiAgcmV0dXJuIChcbiAgICBkZXNjZW5kYW50SUQuaW5kZXhPZihhbmNlc3RvcklEKSA9PT0gMCAmJlxuICAgIGlzQm91bmRhcnkoZGVzY2VuZGFudElELCBhbmNlc3RvcklELmxlbmd0aClcbiAgKTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBwYXJlbnQgSUQgb2YgdGhlIHN1cHBsaWVkIFJlYWN0IERPTSBJRCwgYGlkYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgb2YgYSBjb21wb25lbnQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IElEIG9mIHRoZSBwYXJlbnQsIG9yIGFuIGVtcHR5IHN0cmluZy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldFBhcmVudElEKGlkKSB7XG4gIHJldHVybiBpZCA/IGlkLnN1YnN0cigwLCBpZC5sYXN0SW5kZXhPZihTRVBBUkFUT1IpKSA6ICcnO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG5leHQgRE9NIElEIG9uIHRoZSB0cmVlIHBhdGggZnJvbSB0aGUgc3VwcGxpZWQgYGFuY2VzdG9ySURgIHRvIHRoZVxuICogc3VwcGxpZWQgYGRlc3RpbmF0aW9uSURgLiBJZiB0aGV5IGFyZSBlcXVhbCwgdGhlIElEIGlzIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhbmNlc3RvcklEIElEIG9mIGFuIGFuY2VzdG9yIG5vZGUgb2YgYGRlc3RpbmF0aW9uSURgLlxuICogQHBhcmFtIHtzdHJpbmd9IGRlc3RpbmF0aW9uSUQgSUQgb2YgdGhlIGRlc3RpbmF0aW9uIG5vZGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5leHQgSUQgb24gdGhlIHBhdGggZnJvbSBgYW5jZXN0b3JJRGAgdG8gYGRlc3RpbmF0aW9uSURgLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0TmV4dERlc2NlbmRhbnRJRChhbmNlc3RvcklELCBkZXN0aW5hdGlvbklEKSB7XG4gIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgaXNWYWxpZElEKGFuY2VzdG9ySUQpICYmIGlzVmFsaWRJRChkZXN0aW5hdGlvbklEKSxcbiAgICAnZ2V0TmV4dERlc2NlbmRhbnRJRCglcywgJXMpOiBSZWNlaXZlZCBhbiBpbnZhbGlkIFJlYWN0IERPTSBJRC4nLFxuICAgIGFuY2VzdG9ySUQsXG4gICAgZGVzdGluYXRpb25JRFxuICApIDogaW52YXJpYW50KGlzVmFsaWRJRChhbmNlc3RvcklEKSAmJiBpc1ZhbGlkSUQoZGVzdGluYXRpb25JRCkpKTtcbiAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICBpc0FuY2VzdG9ySURPZihhbmNlc3RvcklELCBkZXN0aW5hdGlvbklEKSxcbiAgICAnZ2V0TmV4dERlc2NlbmRhbnRJRCguLi4pOiBSZWFjdCBoYXMgbWFkZSBhbiBpbnZhbGlkIGFzc3VtcHRpb24gYWJvdXQgJyArXG4gICAgJ3RoZSBET00gaGllcmFyY2h5LiBFeHBlY3RlZCBgJXNgIHRvIGJlIGFuIGFuY2VzdG9yIG9mIGAlc2AuJyxcbiAgICBhbmNlc3RvcklELFxuICAgIGRlc3RpbmF0aW9uSURcbiAgKSA6IGludmFyaWFudChpc0FuY2VzdG9ySURPZihhbmNlc3RvcklELCBkZXN0aW5hdGlvbklEKSkpO1xuICBpZiAoYW5jZXN0b3JJRCA9PT0gZGVzdGluYXRpb25JRCkge1xuICAgIHJldHVybiBhbmNlc3RvcklEO1xuICB9XG4gIC8vIFNraXAgb3ZlciB0aGUgYW5jZXN0b3IgYW5kIHRoZSBpbW1lZGlhdGUgc2VwYXJhdG9yLiBUcmF2ZXJzZSB1bnRpbCB3ZSBoaXRcbiAgLy8gYW5vdGhlciBzZXBhcmF0b3Igb3Igd2UgcmVhY2ggdGhlIGVuZCBvZiBgZGVzdGluYXRpb25JRGAuXG4gIHZhciBzdGFydCA9IGFuY2VzdG9ySUQubGVuZ3RoICsgU0VQQVJBVE9SX0xFTkdUSDtcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZGVzdGluYXRpb25JRC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChpc0JvdW5kYXJ5KGRlc3RpbmF0aW9uSUQsIGkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlc3RpbmF0aW9uSUQuc3Vic3RyKDAsIGkpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG5lYXJlc3QgY29tbW9uIGFuY2VzdG9yIElEIG9mIHR3byBJRHMuXG4gKlxuICogVXNpbmcgdGhpcyBJRCBzY2hlbWUsIHRoZSBuZWFyZXN0IGNvbW1vbiBhbmNlc3RvciBJRCBpcyB0aGUgbG9uZ2VzdCBjb21tb25cbiAqIHByZWZpeCBvZiB0aGUgdHdvIElEcyB0aGF0IGltbWVkaWF0ZWx5IHByZWNlZGVkIGEgXCJtYXJrZXJcIiBpbiBib3RoIHN0cmluZ3MuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG9uZUlEXG4gKiBAcGFyYW0ge3N0cmluZ30gdHdvSURcbiAqIEByZXR1cm4ge3N0cmluZ30gTmVhcmVzdCBjb21tb24gYW5jZXN0b3IgSUQsIG9yIHRoZSBlbXB0eSBzdHJpbmcgaWYgbm9uZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldEZpcnN0Q29tbW9uQW5jZXN0b3JJRChvbmVJRCwgdHdvSUQpIHtcbiAgdmFyIG1pbkxlbmd0aCA9IE1hdGgubWluKG9uZUlELmxlbmd0aCwgdHdvSUQubGVuZ3RoKTtcbiAgaWYgKG1pbkxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICB2YXIgbGFzdENvbW1vbk1hcmtlckluZGV4ID0gMDtcbiAgLy8gVXNlIGA8PWAgdG8gdHJhdmVyc2UgdW50aWwgdGhlIFwiRU9MXCIgb2YgdGhlIHNob3J0ZXIgc3RyaW5nLlxuICBmb3IgKHZhciBpID0gMDsgaSA8PSBtaW5MZW5ndGg7IGkrKykge1xuICAgIGlmIChpc0JvdW5kYXJ5KG9uZUlELCBpKSAmJiBpc0JvdW5kYXJ5KHR3b0lELCBpKSkge1xuICAgICAgbGFzdENvbW1vbk1hcmtlckluZGV4ID0gaTtcbiAgICB9IGVsc2UgaWYgKG9uZUlELmNoYXJBdChpKSAhPT0gdHdvSUQuY2hhckF0KGkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdmFyIGxvbmdlc3RDb21tb25JRCA9IG9uZUlELnN1YnN0cigwLCBsYXN0Q29tbW9uTWFya2VySW5kZXgpO1xuICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgIGlzVmFsaWRJRChsb25nZXN0Q29tbW9uSUQpLFxuICAgICdnZXRGaXJzdENvbW1vbkFuY2VzdG9ySUQoJXMsICVzKTogRXhwZWN0ZWQgYSB2YWxpZCBSZWFjdCBET00gSUQ6ICVzJyxcbiAgICBvbmVJRCxcbiAgICB0d29JRCxcbiAgICBsb25nZXN0Q29tbW9uSURcbiAgKSA6IGludmFyaWFudChpc1ZhbGlkSUQobG9uZ2VzdENvbW1vbklEKSkpO1xuICByZXR1cm4gbG9uZ2VzdENvbW1vbklEO1xufVxuXG4vKipcbiAqIFRyYXZlcnNlcyB0aGUgcGFyZW50IHBhdGggYmV0d2VlbiB0d28gSURzIChlaXRoZXIgdXAgb3IgZG93bikuIFRoZSBJRHMgbXVzdFxuICogbm90IGJlIHRoZSBzYW1lLCBhbmQgdGhlcmUgbXVzdCBleGlzdCBhIHBhcmVudCBwYXRoIGJldHdlZW4gdGhlbS4gSWYgdGhlXG4gKiBjYWxsYmFjayByZXR1cm5zIGBmYWxzZWAsIHRyYXZlcnNhbCBpcyBzdG9wcGVkLlxuICpcbiAqIEBwYXJhbSB7P3N0cmluZ30gc3RhcnQgSUQgYXQgd2hpY2ggdG8gc3RhcnQgdHJhdmVyc2FsLlxuICogQHBhcmFtIHs/c3RyaW5nfSBzdG9wIElEIGF0IHdoaWNoIHRvIGVuZCB0cmF2ZXJzYWwuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYiBDYWxsYmFjayB0byBpbnZva2UgZWFjaCBJRCB3aXRoLlxuICogQHBhcmFtIHs/Ym9vbGVhbn0gc2tpcEZpcnN0IFdoZXRoZXIgb3Igbm90IHRvIHNraXAgdGhlIGZpcnN0IG5vZGUuXG4gKiBAcGFyYW0gez9ib29sZWFufSBza2lwTGFzdCBXaGV0aGVyIG9yIG5vdCB0byBza2lwIHRoZSBsYXN0IG5vZGUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZVBhcmVudFBhdGgoc3RhcnQsIHN0b3AsIGNiLCBhcmcsIHNraXBGaXJzdCwgc2tpcExhc3QpIHtcbiAgc3RhcnQgPSBzdGFydCB8fCAnJztcbiAgc3RvcCA9IHN0b3AgfHwgJyc7XG4gIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgc3RhcnQgIT09IHN0b3AsXG4gICAgJ3RyYXZlcnNlUGFyZW50UGF0aCguLi4pOiBDYW5ub3QgdHJhdmVyc2UgZnJvbSBhbmQgdG8gdGhlIHNhbWUgSUQsIGAlc2AuJyxcbiAgICBzdGFydFxuICApIDogaW52YXJpYW50KHN0YXJ0ICE9PSBzdG9wKSk7XG4gIHZhciB0cmF2ZXJzZVVwID0gaXNBbmNlc3RvcklET2Yoc3RvcCwgc3RhcnQpO1xuICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgIHRyYXZlcnNlVXAgfHwgaXNBbmNlc3RvcklET2Yoc3RhcnQsIHN0b3ApLFxuICAgICd0cmF2ZXJzZVBhcmVudFBhdGgoJXMsICVzLCAuLi4pOiBDYW5ub3QgdHJhdmVyc2UgZnJvbSB0d28gSURzIHRoYXQgZG8gJyArXG4gICAgJ25vdCBoYXZlIGEgcGFyZW50IHBhdGguJyxcbiAgICBzdGFydCxcbiAgICBzdG9wXG4gICkgOiBpbnZhcmlhbnQodHJhdmVyc2VVcCB8fCBpc0FuY2VzdG9ySURPZihzdGFydCwgc3RvcCkpKTtcbiAgLy8gVHJhdmVyc2UgZnJvbSBgc3RhcnRgIHRvIGBzdG9wYCBvbmUgZGVwdGggYXQgYSB0aW1lLlxuICB2YXIgZGVwdGggPSAwO1xuICB2YXIgdHJhdmVyc2UgPSB0cmF2ZXJzZVVwID8gZ2V0UGFyZW50SUQgOiBnZXROZXh0RGVzY2VuZGFudElEO1xuICBmb3IgKHZhciBpZCA9IHN0YXJ0OyAvKiB1bnRpbCBicmVhayAqLzsgaWQgPSB0cmF2ZXJzZShpZCwgc3RvcCkpIHtcbiAgICB2YXIgcmV0O1xuICAgIGlmICgoIXNraXBGaXJzdCB8fCBpZCAhPT0gc3RhcnQpICYmICghc2tpcExhc3QgfHwgaWQgIT09IHN0b3ApKSB7XG4gICAgICByZXQgPSBjYihpZCwgdHJhdmVyc2VVcCwgYXJnKTtcbiAgICB9XG4gICAgaWYgKHJldCA9PT0gZmFsc2UgfHwgaWQgPT09IHN0b3ApIHtcbiAgICAgIC8vIE9ubHkgYnJlYWsgLy9hZnRlci8vIHZpc2l0aW5nIGBzdG9wYC5cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgZGVwdGgrKyA8IE1BWF9UUkVFX0RFUFRILFxuICAgICAgJ3RyYXZlcnNlUGFyZW50UGF0aCglcywgJXMsIC4uLik6IERldGVjdGVkIGFuIGluZmluaXRlIGxvb3Agd2hpbGUgJyArXG4gICAgICAndHJhdmVyc2luZyB0aGUgUmVhY3QgRE9NIElEIHRyZWUuIFRoaXMgbWF5IGJlIGR1ZSB0byBtYWxmb3JtZWQgSURzOiAlcycsXG4gICAgICBzdGFydCwgc3RvcFxuICAgICkgOiBpbnZhcmlhbnQoZGVwdGgrKyA8IE1BWF9UUkVFX0RFUFRIKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBNYW5hZ2VzIHRoZSBJRHMgYXNzaWduZWQgdG8gRE9NIHJlcHJlc2VudGF0aW9ucyBvZiBSZWFjdCBjb21wb25lbnRzLiBUaGlzXG4gKiB1c2VzIGEgc3BlY2lmaWMgc2NoZW1lIGluIG9yZGVyIHRvIHRyYXZlcnNlIHRoZSBET00gZWZmaWNpZW50bHkgKGUuZy4gaW5cbiAqIG9yZGVyIHRvIHNpbXVsYXRlIGV2ZW50cykuXG4gKlxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdEluc3RhbmNlSGFuZGxlcyA9IHtcblxuICAvKipcbiAgICogQ29uc3RydWN0cyBhIFJlYWN0IHJvb3QgSURcbiAgICogQHJldHVybiB7c3RyaW5nfSBBIFJlYWN0IHJvb3QgSUQuXG4gICAqL1xuICBjcmVhdGVSZWFjdFJvb3RJRDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGdldFJlYWN0Um9vdElEU3RyaW5nKFJlYWN0Um9vdEluZGV4LmNyZWF0ZVJlYWN0Um9vdEluZGV4KCkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgUmVhY3QgSUQgYnkgam9pbmluZyBhIHJvb3QgSUQgd2l0aCBhIG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByb290SUQgUm9vdCBJRCBvZiBhIHBhcmVudCBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEEgY29tcG9uZW50J3MgbmFtZSAoYXMgZmxhdHRlbmVkIGNoaWxkcmVuKS5cbiAgICogQHJldHVybiB7c3RyaW5nfSBBIFJlYWN0IElELlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNyZWF0ZVJlYWN0SUQ6IGZ1bmN0aW9uKHJvb3RJRCwgbmFtZSkge1xuICAgIHJldHVybiByb290SUQgKyBuYW1lO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBET00gSUQgb2YgdGhlIFJlYWN0IGNvbXBvbmVudCB0aGF0IGlzIHRoZSByb290IG9mIHRoZSB0cmVlIHRoYXRcbiAgICogY29udGFpbnMgdGhlIFJlYWN0IGNvbXBvbmVudCB3aXRoIHRoZSBzdXBwbGllZCBET00gSUQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBET00gSUQgb2YgYSBSZWFjdCBjb21wb25lbnQuXG4gICAqIEByZXR1cm4gez9zdHJpbmd9IERPTSBJRCBvZiB0aGUgUmVhY3QgY29tcG9uZW50IHRoYXQgaXMgdGhlIHJvb3QuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0UmVhY3RSb290SURGcm9tTm9kZUlEOiBmdW5jdGlvbihpZCkge1xuICAgIGlmIChpZCAmJiBpZC5jaGFyQXQoMCkgPT09IFNFUEFSQVRPUiAmJiBpZC5sZW5ndGggPiAxKSB7XG4gICAgICB2YXIgaW5kZXggPSBpZC5pbmRleE9mKFNFUEFSQVRPUiwgMSk7XG4gICAgICByZXR1cm4gaW5kZXggPiAtMSA/IGlkLnN1YnN0cigwLCBpbmRleCkgOiBpZDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyYXZlcnNlcyB0aGUgSUQgaGllcmFyY2h5IGFuZCBpbnZva2VzIHRoZSBzdXBwbGllZCBgY2JgIG9uIGFueSBJRHMgdGhhdFxuICAgKiBzaG91bGQgd291bGQgcmVjZWl2ZSBhIGBtb3VzZUVudGVyYCBvciBgbW91c2VMZWF2ZWAgZXZlbnQuXG4gICAqXG4gICAqIE5PVEU6IERvZXMgbm90IGludm9rZSB0aGUgY2FsbGJhY2sgb24gdGhlIG5lYXJlc3QgY29tbW9uIGFuY2VzdG9yIGJlY2F1c2VcbiAgICogbm90aGluZyBcImVudGVyZWRcIiBvciBcImxlZnRcIiB0aGF0IGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsZWF2ZUlEIElEIGJlaW5nIGxlZnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbnRlcklEIElEIGJlaW5nIGVudGVyZWQuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiIENhbGxiYWNrIHRvIGludm9rZSBvbiBlYWNoIGVudGVyZWQvbGVmdCBJRC5cbiAgICogQHBhcmFtIHsqfSB1cEFyZyBBcmd1bWVudCB0byBpbnZva2UgdGhlIGNhbGxiYWNrIHdpdGggb24gbGVmdCBJRHMuXG4gICAqIEBwYXJhbSB7Kn0gZG93bkFyZyBBcmd1bWVudCB0byBpbnZva2UgdGhlIGNhbGxiYWNrIHdpdGggb24gZW50ZXJlZCBJRHMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdHJhdmVyc2VFbnRlckxlYXZlOiBmdW5jdGlvbihsZWF2ZUlELCBlbnRlcklELCBjYiwgdXBBcmcsIGRvd25BcmcpIHtcbiAgICB2YXIgYW5jZXN0b3JJRCA9IGdldEZpcnN0Q29tbW9uQW5jZXN0b3JJRChsZWF2ZUlELCBlbnRlcklEKTtcbiAgICBpZiAoYW5jZXN0b3JJRCAhPT0gbGVhdmVJRCkge1xuICAgICAgdHJhdmVyc2VQYXJlbnRQYXRoKGxlYXZlSUQsIGFuY2VzdG9ySUQsIGNiLCB1cEFyZywgZmFsc2UsIHRydWUpO1xuICAgIH1cbiAgICBpZiAoYW5jZXN0b3JJRCAhPT0gZW50ZXJJRCkge1xuICAgICAgdHJhdmVyc2VQYXJlbnRQYXRoKGFuY2VzdG9ySUQsIGVudGVySUQsIGNiLCBkb3duQXJnLCB0cnVlLCBmYWxzZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTaW11bGF0ZXMgdGhlIHRyYXZlcnNhbCBvZiBhIHR3by1waGFzZSwgY2FwdHVyZS9idWJibGUgZXZlbnQgZGlzcGF0Y2guXG4gICAqXG4gICAqIE5PVEU6IFRoaXMgdHJhdmVyc2FsIGhhcHBlbnMgb24gSURzIHdpdGhvdXQgdG91Y2hpbmcgdGhlIERPTS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldElEIElEIG9mIHRoZSB0YXJnZXQgbm9kZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2IgQ2FsbGJhY2sgdG8gaW52b2tlLlxuICAgKiBAcGFyYW0geyp9IGFyZyBBcmd1bWVudCB0byBpbnZva2UgdGhlIGNhbGxiYWNrIHdpdGguXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdHJhdmVyc2VUd29QaGFzZTogZnVuY3Rpb24odGFyZ2V0SUQsIGNiLCBhcmcpIHtcbiAgICBpZiAodGFyZ2V0SUQpIHtcbiAgICAgIHRyYXZlcnNlUGFyZW50UGF0aCgnJywgdGFyZ2V0SUQsIGNiLCBhcmcsIHRydWUsIGZhbHNlKTtcbiAgICAgIHRyYXZlcnNlUGFyZW50UGF0aCh0YXJnZXRJRCwgJycsIGNiLCBhcmcsIGZhbHNlLCB0cnVlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyYXZlcnNlIGEgbm9kZSBJRCwgY2FsbGluZyB0aGUgc3VwcGxpZWQgYGNiYCBmb3IgZWFjaCBhbmNlc3RvciBJRC4gRm9yXG4gICAqIGV4YW1wbGUsIHBhc3NpbmcgYC4wLiRyb3ctMC4xYCB3b3VsZCByZXN1bHQgaW4gYGNiYCBnZXR0aW5nIGNhbGxlZFxuICAgKiB3aXRoIGAuMGAsIGAuMC4kcm93LTBgLCBhbmQgYC4wLiRyb3ctMC4xYC5cbiAgICpcbiAgICogTk9URTogVGhpcyB0cmF2ZXJzYWwgaGFwcGVucyBvbiBJRHMgd2l0aG91dCB0b3VjaGluZyB0aGUgRE9NLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0SUQgSUQgb2YgdGhlIHRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYiBDYWxsYmFjayB0byBpbnZva2UuXG4gICAqIEBwYXJhbSB7Kn0gYXJnIEFyZ3VtZW50IHRvIGludm9rZSB0aGUgY2FsbGJhY2sgd2l0aC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB0cmF2ZXJzZUFuY2VzdG9yczogZnVuY3Rpb24odGFyZ2V0SUQsIGNiLCBhcmcpIHtcbiAgICB0cmF2ZXJzZVBhcmVudFBhdGgoJycsIHRhcmdldElELCBjYiwgYXJnLCB0cnVlLCBmYWxzZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV4cG9zZWQgZm9yIHVuaXQgdGVzdGluZy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRGaXJzdENvbW1vbkFuY2VzdG9ySUQ6IGdldEZpcnN0Q29tbW9uQW5jZXN0b3JJRCxcblxuICAvKipcbiAgICogRXhwb3NlZCBmb3IgdW5pdCB0ZXN0aW5nLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldE5leHREZXNjZW5kYW50SUQ6IGdldE5leHREZXNjZW5kYW50SUQsXG5cbiAgaXNBbmNlc3RvcklET2Y6IGlzQW5jZXN0b3JJRE9mLFxuXG4gIFNFUEFSQVRPUjogU0VQQVJBVE9SXG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RJbnN0YW5jZUhhbmRsZXM7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdExpbmtcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogUmVhY3RMaW5rIGVuY2Fwc3VsYXRlcyBhIGNvbW1vbiBwYXR0ZXJuIGluIHdoaWNoIGEgY29tcG9uZW50IHdhbnRzIHRvIG1vZGlmeVxuICogYSBwcm9wIHJlY2VpdmVkIGZyb20gaXRzIHBhcmVudC4gUmVhY3RMaW5rIGFsbG93cyB0aGUgcGFyZW50IHRvIHBhc3MgZG93biBhXG4gKiB2YWx1ZSBjb3VwbGVkIHdpdGggYSBjYWxsYmFjayB0aGF0LCB3aGVuIGludm9rZWQsIGV4cHJlc3NlcyBhbiBpbnRlbnQgdG9cbiAqIG1vZGlmeSB0aGF0IHZhbHVlLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gKiAgIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24oKSB7XG4gKiAgICAgcmV0dXJuIHt2YWx1ZTogJyd9O1xuICogICB9LFxuICogICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICogICAgIHZhciB2YWx1ZUxpbmsgPSBuZXcgUmVhY3RMaW5rKHRoaXMuc3RhdGUudmFsdWUsIHRoaXMuX2hhbmRsZVZhbHVlQ2hhbmdlKTtcbiAqICAgICByZXR1cm4gPGlucHV0IHZhbHVlTGluaz17dmFsdWVMaW5rfSAvPjtcbiAqICAgfSxcbiAqICAgdGhpcy5faGFuZGxlVmFsdWVDaGFuZ2U6IGZ1bmN0aW9uKG5ld1ZhbHVlKSB7XG4gKiAgICAgdGhpcy5zZXRTdGF0ZSh7dmFsdWU6IG5ld1ZhbHVlfSk7XG4gKiAgIH1cbiAqIH0pO1xuICpcbiAqIFdlIGhhdmUgcHJvdmlkZWQgc29tZSBzdWdhcnkgbWl4aW5zIHRvIG1ha2UgdGhlIGNyZWF0aW9uIGFuZFxuICogY29uc3VtcHRpb24gb2YgUmVhY3RMaW5rIGVhc2llcjsgc2VlIExpbmtlZFZhbHVlVXRpbHMgYW5kIExpbmtlZFN0YXRlTWl4aW4uXG4gKi9cblxudmFyIFJlYWN0ID0gcmVxdWlyZShcIi4vUmVhY3RcIik7XG5cbi8qKlxuICogQHBhcmFtIHsqfSB2YWx1ZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBsaW5rXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSByZXF1ZXN0Q2hhbmdlIGNhbGxiYWNrIHRvIHJlcXVlc3QgYSBjaGFuZ2VcbiAqL1xuZnVuY3Rpb24gUmVhY3RMaW5rKHZhbHVlLCByZXF1ZXN0Q2hhbmdlKSB7XG4gIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgdGhpcy5yZXF1ZXN0Q2hhbmdlID0gcmVxdWVzdENoYW5nZTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgUHJvcFR5cGUgdGhhdCBlbmZvcmNlcyB0aGUgUmVhY3RMaW5rIEFQSSBhbmQgb3B0aW9uYWxseSBjaGVja3MgdGhlXG4gKiB0eXBlIG9mIHRoZSB2YWx1ZSBiZWluZyBwYXNzZWQgaW5zaWRlIHRoZSBsaW5rLiBFeGFtcGxlOlxuICpcbiAqIE15Q29tcG9uZW50LnByb3BUeXBlcyA9IHtcbiAqICAgdGFiSW5kZXhMaW5rOiBSZWFjdExpbmsuUHJvcFR5cGVzLmxpbmsoUmVhY3QuUHJvcFR5cGVzLm51bWJlcilcbiAqIH1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTGlua1R5cGVDaGVja2VyKGxpbmtUeXBlKSB7XG4gIHZhciBzaGFwZXMgPSB7XG4gICAgdmFsdWU6IHR5cGVvZiBsaW5rVHlwZSA9PT0gJ3VuZGVmaW5lZCcgP1xuICAgICAgUmVhY3QuUHJvcFR5cGVzLmFueS5pc1JlcXVpcmVkIDpcbiAgICAgIGxpbmtUeXBlLmlzUmVxdWlyZWQsXG4gICAgcmVxdWVzdENoYW5nZTogUmVhY3QuUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxuICB9O1xuICByZXR1cm4gUmVhY3QuUHJvcFR5cGVzLnNoYXBlKHNoYXBlcyk7XG59XG5cblJlYWN0TGluay5Qcm9wVHlwZXMgPSB7XG4gIGxpbms6IGNyZWF0ZUxpbmtUeXBlQ2hlY2tlclxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdExpbms7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RNYXJrdXBDaGVja3N1bVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgYWRsZXIzMiA9IHJlcXVpcmUoXCIuL2FkbGVyMzJcIik7XG5cbnZhciBSZWFjdE1hcmt1cENoZWNrc3VtID0ge1xuICBDSEVDS1NVTV9BVFRSX05BTUU6ICdkYXRhLXJlYWN0LWNoZWNrc3VtJyxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBNYXJrdXAgc3RyaW5nXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIHN0cmluZyB3aXRoIGNoZWNrc3VtIGF0dHJpYnV0ZSBhdHRhY2hlZFxuICAgKi9cbiAgYWRkQ2hlY2tzdW1Ub01hcmt1cDogZnVuY3Rpb24obWFya3VwKSB7XG4gICAgdmFyIGNoZWNrc3VtID0gYWRsZXIzMihtYXJrdXApO1xuICAgIHJldHVybiBtYXJrdXAucmVwbGFjZShcbiAgICAgICc+JyxcbiAgICAgICcgJyArIFJlYWN0TWFya3VwQ2hlY2tzdW0uQ0hFQ0tTVU1fQVRUUl9OQU1FICsgJz1cIicgKyBjaGVja3N1bSArICdcIj4nXG4gICAgKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCB0byB1c2VcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBlbGVtZW50IHJvb3QgUmVhY3QgZWxlbWVudFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciBvciBub3QgdGhlIG1hcmt1cCBpcyB0aGUgc2FtZVxuICAgKi9cbiAgY2FuUmV1c2VNYXJrdXA6IGZ1bmN0aW9uKG1hcmt1cCwgZWxlbWVudCkge1xuICAgIHZhciBleGlzdGluZ0NoZWNrc3VtID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXG4gICAgICBSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRVxuICAgICk7XG4gICAgZXhpc3RpbmdDaGVja3N1bSA9IGV4aXN0aW5nQ2hlY2tzdW0gJiYgcGFyc2VJbnQoZXhpc3RpbmdDaGVja3N1bSwgMTApO1xuICAgIHZhciBtYXJrdXBDaGVja3N1bSA9IGFkbGVyMzIobWFya3VwKTtcbiAgICByZXR1cm4gbWFya3VwQ2hlY2tzdW0gPT09IGV4aXN0aW5nQ2hlY2tzdW07XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RNYXJrdXBDaGVja3N1bTtcbiIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RNb3VudFxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKFwiLi9ET01Qcm9wZXJ0eVwiKTtcbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSByZXF1aXJlKFwiLi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJcIik7XG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKFwiLi9SZWFjdEN1cnJlbnRPd25lclwiKTtcbnZhciBSZWFjdERlc2NyaXB0b3IgPSByZXF1aXJlKFwiLi9SZWFjdERlc2NyaXB0b3JcIik7XG52YXIgUmVhY3RJbnN0YW5jZUhhbmRsZXMgPSByZXF1aXJlKFwiLi9SZWFjdEluc3RhbmNlSGFuZGxlc1wiKTtcbnZhciBSZWFjdFBlcmYgPSByZXF1aXJlKFwiLi9SZWFjdFBlcmZcIik7XG5cbnZhciBjb250YWluc05vZGUgPSByZXF1aXJlKFwiLi9jb250YWluc05vZGVcIik7XG52YXIgZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyID0gcmVxdWlyZShcIi4vZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyXCIpO1xudmFyIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKFwiLi9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50XCIpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcbnZhciBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoXCIuL3Nob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50XCIpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKFwiLi93YXJuaW5nXCIpO1xuXG52YXIgU0VQQVJBVE9SID0gUmVhY3RJbnN0YW5jZUhhbmRsZXMuU0VQQVJBVE9SO1xuXG52YXIgQVRUUl9OQU1FID0gRE9NUHJvcGVydHkuSURfQVRUUklCVVRFX05BTUU7XG52YXIgbm9kZUNhY2hlID0ge307XG5cbnZhciBFTEVNRU5UX05PREVfVFlQRSA9IDE7XG52YXIgRE9DX05PREVfVFlQRSA9IDk7XG5cbi8qKiBNYXBwaW5nIGZyb20gcmVhY3RSb290SUQgdG8gUmVhY3QgY29tcG9uZW50IGluc3RhbmNlLiAqL1xudmFyIGluc3RhbmNlc0J5UmVhY3RSb290SUQgPSB7fTtcblxuLyoqIE1hcHBpbmcgZnJvbSByZWFjdFJvb3RJRCB0byBgY29udGFpbmVyYCBub2Rlcy4gKi9cbnZhciBjb250YWluZXJzQnlSZWFjdFJvb3RJRCA9IHt9O1xuXG5pZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gIC8qKiBfX0RFVl9fLW9ubHkgbWFwcGluZyBmcm9tIHJlYWN0Um9vdElEIHRvIHJvb3QgZWxlbWVudHMuICovXG4gIHZhciByb290RWxlbWVudHNCeVJlYWN0Um9vdElEID0ge307XG59XG5cbi8vIFVzZWQgdG8gc3RvcmUgYnJlYWR0aC1maXJzdCBzZWFyY2ggc3RhdGUgaW4gZmluZENvbXBvbmVudFJvb3QuXG52YXIgZmluZENvbXBvbmVudFJvb3RSZXVzYWJsZUFycmF5ID0gW107XG5cbi8qKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdGhhdCBtYXkgY29udGFpbiBhIFJlYWN0IGNvbXBvbmVudC5cbiAqIEByZXR1cm4gez9zdHJpbmd9IEEgXCJyZWFjdFJvb3RcIiBJRCwgaWYgYSBSZWFjdCBjb21wb25lbnQgaXMgcmVuZGVyZWQuXG4gKi9cbmZ1bmN0aW9uIGdldFJlYWN0Um9vdElEKGNvbnRhaW5lcikge1xuICB2YXIgcm9vdEVsZW1lbnQgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgcmV0dXJuIHJvb3RFbGVtZW50ICYmIFJlYWN0TW91bnQuZ2V0SUQocm9vdEVsZW1lbnQpO1xufVxuXG4vKipcbiAqIEFjY2Vzc2luZyBub2RlW0FUVFJfTkFNRV0gb3IgY2FsbGluZyBnZXRBdHRyaWJ1dGUoQVRUUl9OQU1FKSBvbiBhIGZvcm1cbiAqIGVsZW1lbnQgY2FuIHJldHVybiBpdHMgY29udHJvbCB3aG9zZSBuYW1lIG9yIElEIGVxdWFscyBBVFRSX05BTUUuIEFsbFxuICogRE9NIG5vZGVzIHN1cHBvcnQgYGdldEF0dHJpYnV0ZU5vZGVgIGJ1dCB0aGlzIGNhbiBhbHNvIGdldCBjYWxsZWQgb25cbiAqIG90aGVyIG9iamVjdHMgc28ganVzdCByZXR1cm4gJycgaWYgd2UncmUgZ2l2ZW4gc29tZXRoaW5nIG90aGVyIHRoYW4gYVxuICogRE9NIG5vZGUgKHN1Y2ggYXMgd2luZG93KS5cbiAqXG4gKiBAcGFyYW0gez9ET01FbGVtZW50fERPTVdpbmRvd3xET01Eb2N1bWVudHxET01UZXh0Tm9kZX0gbm9kZSBET00gbm9kZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gSUQgb2YgdGhlIHN1cHBsaWVkIGBkb21Ob2RlYC5cbiAqL1xuZnVuY3Rpb24gZ2V0SUQobm9kZSkge1xuICB2YXIgaWQgPSBpbnRlcm5hbEdldElEKG5vZGUpO1xuICBpZiAoaWQpIHtcbiAgICBpZiAobm9kZUNhY2hlLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgdmFyIGNhY2hlZCA9IG5vZGVDYWNoZVtpZF07XG4gICAgICBpZiAoY2FjaGVkICE9PSBub2RlKSB7XG4gICAgICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAgICAgIWlzVmFsaWQoY2FjaGVkLCBpZCksXG4gICAgICAgICAgJ1JlYWN0TW91bnQ6IFR3byB2YWxpZCBidXQgdW5lcXVhbCBub2RlcyB3aXRoIHRoZSBzYW1lIGAlc2A6ICVzJyxcbiAgICAgICAgICBBVFRSX05BTUUsIGlkXG4gICAgICAgICkgOiBpbnZhcmlhbnQoIWlzVmFsaWQoY2FjaGVkLCBpZCkpKTtcblxuICAgICAgICBub2RlQ2FjaGVbaWRdID0gbm9kZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZUNhY2hlW2lkXSA9IG5vZGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGlkO1xufVxuXG5mdW5jdGlvbiBpbnRlcm5hbEdldElEKG5vZGUpIHtcbiAgLy8gSWYgbm9kZSBpcyBzb21ldGhpbmcgbGlrZSBhIHdpbmRvdywgZG9jdW1lbnQsIG9yIHRleHQgbm9kZSwgbm9uZSBvZlxuICAvLyB3aGljaCBzdXBwb3J0IGF0dHJpYnV0ZXMgb3IgYSAuZ2V0QXR0cmlidXRlIG1ldGhvZCwgZ3JhY2VmdWxseSByZXR1cm5cbiAgLy8gdGhlIGVtcHR5IHN0cmluZywgYXMgaWYgdGhlIGF0dHJpYnV0ZSB3ZXJlIG1pc3NpbmcuXG4gIHJldHVybiBub2RlICYmIG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKEFUVFJfTkFNRSkgfHwgJyc7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgUmVhY3Qtc3BlY2lmaWMgSUQgb2YgdGhlIGdpdmVuIG5vZGUuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlIFRoZSBET00gbm9kZSB3aG9zZSBJRCB3aWxsIGJlIHNldC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgdmFsdWUgb2YgdGhlIElEIGF0dHJpYnV0ZS5cbiAqL1xuZnVuY3Rpb24gc2V0SUQobm9kZSwgaWQpIHtcbiAgdmFyIG9sZElEID0gaW50ZXJuYWxHZXRJRChub2RlKTtcbiAgaWYgKG9sZElEICE9PSBpZCkge1xuICAgIGRlbGV0ZSBub2RlQ2FjaGVbb2xkSURdO1xuICB9XG4gIG5vZGUuc2V0QXR0cmlidXRlKEFUVFJfTkFNRSwgaWQpO1xuICBub2RlQ2FjaGVbaWRdID0gbm9kZTtcbn1cblxuLyoqXG4gKiBGaW5kcyB0aGUgbm9kZSB3aXRoIHRoZSBzdXBwbGllZCBSZWFjdC1nZW5lcmF0ZWQgRE9NIElELlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBBIFJlYWN0LWdlbmVyYXRlZCBET00gSUQuXG4gKiBAcmV0dXJuIHtET01FbGVtZW50fSBET00gbm9kZSB3aXRoIHRoZSBzdXBwbGVkIGBpZGAuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZShpZCkge1xuICBpZiAoIW5vZGVDYWNoZS5oYXNPd25Qcm9wZXJ0eShpZCkgfHwgIWlzVmFsaWQobm9kZUNhY2hlW2lkXSwgaWQpKSB7XG4gICAgbm9kZUNhY2hlW2lkXSA9IFJlYWN0TW91bnQuZmluZFJlYWN0Tm9kZUJ5SUQoaWQpO1xuICB9XG4gIHJldHVybiBub2RlQ2FjaGVbaWRdO1xufVxuXG4vKipcbiAqIEEgbm9kZSBpcyBcInZhbGlkXCIgaWYgaXQgaXMgY29udGFpbmVkIGJ5IGEgY3VycmVudGx5IG1vdW50ZWQgY29udGFpbmVyLlxuICpcbiAqIFRoaXMgbWVhbnMgdGhhdCB0aGUgbm9kZSBkb2VzIG5vdCBoYXZlIHRvIGJlIGNvbnRhaW5lZCBieSBhIGRvY3VtZW50IGluXG4gKiBvcmRlciB0byBiZSBjb25zaWRlcmVkIHZhbGlkLlxuICpcbiAqIEBwYXJhbSB7P0RPTUVsZW1lbnR9IG5vZGUgVGhlIGNhbmRpZGF0ZSBET00gbm9kZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgZXhwZWN0ZWQgSUQgb2YgdGhlIG5vZGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBub2RlIGlzIGNvbnRhaW5lZCBieSBhIG1vdW50ZWQgY29udGFpbmVyLlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkKG5vZGUsIGlkKSB7XG4gIGlmIChub2RlKSB7XG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgIGludGVybmFsR2V0SUQobm9kZSkgPT09IGlkLFxuICAgICAgJ1JlYWN0TW91bnQ6IFVuZXhwZWN0ZWQgbW9kaWZpY2F0aW9uIG9mIGAlc2AnLFxuICAgICAgQVRUUl9OQU1FXG4gICAgKSA6IGludmFyaWFudChpbnRlcm5hbEdldElEKG5vZGUpID09PSBpZCkpO1xuXG4gICAgdmFyIGNvbnRhaW5lciA9IFJlYWN0TW91bnQuZmluZFJlYWN0Q29udGFpbmVyRm9ySUQoaWQpO1xuICAgIGlmIChjb250YWluZXIgJiYgY29udGFpbnNOb2RlKGNvbnRhaW5lciwgbm9kZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDYXVzZXMgdGhlIGNhY2hlIHRvIGZvcmdldCBhYm91dCBvbmUgUmVhY3Qtc3BlY2lmaWMgSUQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBJRCB0byBmb3JnZXQuXG4gKi9cbmZ1bmN0aW9uIHB1cmdlSUQoaWQpIHtcbiAgZGVsZXRlIG5vZGVDYWNoZVtpZF07XG59XG5cbnZhciBkZWVwZXN0Tm9kZVNvRmFyID0gbnVsbDtcbmZ1bmN0aW9uIGZpbmREZWVwZXN0Q2FjaGVkQW5jZXN0b3JJbXBsKGFuY2VzdG9ySUQpIHtcbiAgdmFyIGFuY2VzdG9yID0gbm9kZUNhY2hlW2FuY2VzdG9ySURdO1xuICBpZiAoYW5jZXN0b3IgJiYgaXNWYWxpZChhbmNlc3RvciwgYW5jZXN0b3JJRCkpIHtcbiAgICBkZWVwZXN0Tm9kZVNvRmFyID0gYW5jZXN0b3I7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBub2RlIGlzbid0IHBvcHVsYXRlZCBpbiB0aGUgY2FjaGUsIHNvIHByZXN1bWFibHkgbm9uZSBvZiBpdHNcbiAgICAvLyBkZXNjZW5kYW50cyBhcmUuIEJyZWFrIG91dCBvZiB0aGUgbG9vcC5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGRlZXBlc3QgY2FjaGVkIG5vZGUgd2hvc2UgSUQgaXMgYSBwcmVmaXggb2YgYHRhcmdldElEYC5cbiAqL1xuZnVuY3Rpb24gZmluZERlZXBlc3RDYWNoZWRBbmNlc3Rvcih0YXJnZXRJRCkge1xuICBkZWVwZXN0Tm9kZVNvRmFyID0gbnVsbDtcbiAgUmVhY3RJbnN0YW5jZUhhbmRsZXMudHJhdmVyc2VBbmNlc3RvcnMoXG4gICAgdGFyZ2V0SUQsXG4gICAgZmluZERlZXBlc3RDYWNoZWRBbmNlc3RvckltcGxcbiAgKTtcblxuICB2YXIgZm91bmROb2RlID0gZGVlcGVzdE5vZGVTb0ZhcjtcbiAgZGVlcGVzdE5vZGVTb0ZhciA9IG51bGw7XG4gIHJldHVybiBmb3VuZE5vZGU7XG59XG5cbi8qKlxuICogTW91bnRpbmcgaXMgdGhlIHByb2Nlc3Mgb2YgaW5pdGlhbGl6aW5nIGEgUmVhY3QgY29tcG9uZW50IGJ5IGNyZWF0aW5ncyBpdHNcbiAqIHJlcHJlc2VudGF0aXZlIERPTSBlbGVtZW50cyBhbmQgaW5zZXJ0aW5nIHRoZW0gaW50byBhIHN1cHBsaWVkIGBjb250YWluZXJgLlxuICogQW55IHByaW9yIGNvbnRlbnQgaW5zaWRlIGBjb250YWluZXJgIGlzIGRlc3Ryb3llZCBpbiB0aGUgcHJvY2Vzcy5cbiAqXG4gKiAgIFJlYWN0TW91bnQucmVuZGVyQ29tcG9uZW50KFxuICogICAgIGNvbXBvbmVudCxcbiAqICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29udGFpbmVyJylcbiAqICAgKTtcbiAqXG4gKiAgIDxkaXYgaWQ9XCJjb250YWluZXJcIj4gICAgICAgICAgICAgICAgICAgPC0tIFN1cHBsaWVkIGBjb250YWluZXJgLlxuICogICAgIDxkaXYgZGF0YS1yZWFjdGlkPVwiLjNcIj4gICAgICAgICAgICAgIDwtLSBSZW5kZXJlZCByZWFjdFJvb3Qgb2YgUmVhY3RcbiAqICAgICAgIC8vIC4uLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5cbiAqICAgICA8L2Rpdj5cbiAqICAgPC9kaXY+XG4gKlxuICogSW5zaWRlIG9mIGBjb250YWluZXJgLCB0aGUgZmlyc3QgZWxlbWVudCByZW5kZXJlZCBpcyB0aGUgXCJyZWFjdFJvb3RcIi5cbiAqL1xudmFyIFJlYWN0TW91bnQgPSB7XG4gIC8qKiBFeHBvc2VkIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMgKiovXG4gIF9pbnN0YW5jZXNCeVJlYWN0Um9vdElEOiBpbnN0YW5jZXNCeVJlYWN0Um9vdElELFxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIGEgaG9vayBwcm92aWRlZCB0byBzdXBwb3J0IHJlbmRlcmluZyBSZWFjdCBjb21wb25lbnRzIHdoaWxlXG4gICAqIGVuc3VyaW5nIHRoYXQgdGhlIGFwcGFyZW50IHNjcm9sbCBwb3NpdGlvbiBvZiBpdHMgYGNvbnRhaW5lcmAgZG9lcyBub3RcbiAgICogY2hhbmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBUaGUgYGNvbnRhaW5lcmAgYmVpbmcgcmVuZGVyZWQgaW50by5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gcmVuZGVyQ2FsbGJhY2sgVGhpcyBtdXN0IGJlIGNhbGxlZCBvbmNlIHRvIGRvIHRoZSByZW5kZXIuXG4gICAqL1xuICBzY3JvbGxNb25pdG9yOiBmdW5jdGlvbihjb250YWluZXIsIHJlbmRlckNhbGxiYWNrKSB7XG4gICAgcmVuZGVyQ2FsbGJhY2soKTtcbiAgfSxcblxuICAvKipcbiAgICogVGFrZSBhIGNvbXBvbmVudCB0aGF0J3MgYWxyZWFkeSBtb3VudGVkIGludG8gdGhlIERPTSBhbmQgcmVwbGFjZSBpdHMgcHJvcHNcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gcHJldkNvbXBvbmVudCBjb21wb25lbnQgaW5zdGFuY2UgYWxyZWFkeSBpbiB0aGUgRE9NXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IG5leHRDb21wb25lbnQgY29tcG9uZW50IGluc3RhbmNlIHRvIHJlbmRlclxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBjb250YWluZXIgdG8gcmVuZGVyIGludG9cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uIHRyaWdnZXJlZCBvbiBjb21wbGV0aW9uXG4gICAqL1xuICBfdXBkYXRlUm9vdENvbXBvbmVudDogZnVuY3Rpb24oXG4gICAgICBwcmV2Q29tcG9uZW50LFxuICAgICAgbmV4dENvbXBvbmVudCxcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIGNhbGxiYWNrKSB7XG4gICAgdmFyIG5leHRQcm9wcyA9IG5leHRDb21wb25lbnQucHJvcHM7XG4gICAgUmVhY3RNb3VudC5zY3JvbGxNb25pdG9yKGNvbnRhaW5lciwgZnVuY3Rpb24oKSB7XG4gICAgICBwcmV2Q29tcG9uZW50LnJlcGxhY2VQcm9wcyhuZXh0UHJvcHMsIGNhbGxiYWNrKTtcbiAgICB9KTtcblxuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgIC8vIFJlY29yZCB0aGUgcm9vdCBlbGVtZW50IGluIGNhc2UgaXQgbGF0ZXIgZ2V0cyB0cmFuc3BsYW50ZWQuXG4gICAgICByb290RWxlbWVudHNCeVJlYWN0Um9vdElEW2dldFJlYWN0Um9vdElEKGNvbnRhaW5lcildID1cbiAgICAgICAgZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByZXZDb21wb25lbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgY29tcG9uZW50IGludG8gdGhlIGluc3RhbmNlIG1hcCBhbmQgc3RhcnRzIHNjcm9sbCB2YWx1ZVxuICAgKiBtb25pdG9yaW5nXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IG5leHRDb21wb25lbnQgY29tcG9uZW50IGluc3RhbmNlIHRvIHJlbmRlclxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBjb250YWluZXIgdG8gcmVuZGVyIGludG9cbiAgICogQHJldHVybiB7c3RyaW5nfSByZWFjdFJvb3QgSUQgcHJlZml4XG4gICAqL1xuICBfcmVnaXN0ZXJDb21wb25lbnQ6IGZ1bmN0aW9uKG5leHRDb21wb25lbnQsIGNvbnRhaW5lcikge1xuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICBjb250YWluZXIgJiYgKFxuICAgICAgICBjb250YWluZXIubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERV9UWVBFIHx8XG4gICAgICAgIGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRVxuICAgICAgKSxcbiAgICAgICdfcmVnaXN0ZXJDb21wb25lbnQoLi4uKTogVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC4nXG4gICAgKSA6IGludmFyaWFudChjb250YWluZXIgJiYgKFxuICAgICAgY29udGFpbmVyLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREVfVFlQRSB8fFxuICAgICAgY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NfTk9ERV9UWVBFXG4gICAgKSkpO1xuXG4gICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmVuc3VyZVNjcm9sbFZhbHVlTW9uaXRvcmluZygpO1xuXG4gICAgdmFyIHJlYWN0Um9vdElEID0gUmVhY3RNb3VudC5yZWdpc3RlckNvbnRhaW5lcihjb250YWluZXIpO1xuICAgIGluc3RhbmNlc0J5UmVhY3RSb290SURbcmVhY3RSb290SURdID0gbmV4dENvbXBvbmVudDtcbiAgICByZXR1cm4gcmVhY3RSb290SUQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbmRlciBhIG5ldyBjb21wb25lbnQgaW50byB0aGUgRE9NLlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBuZXh0Q29tcG9uZW50IGNvbXBvbmVudCBpbnN0YW5jZSB0byByZW5kZXJcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgY29udGFpbmVyIHRvIHJlbmRlciBpbnRvXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkUmV1c2VNYXJrdXAgaWYgd2Ugc2hvdWxkIHNraXAgdGhlIG1hcmt1cCBpbnNlcnRpb25cbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IG5leHRDb21wb25lbnRcbiAgICovXG4gIF9yZW5kZXJOZXdSb290Q29tcG9uZW50OiBSZWFjdFBlcmYubWVhc3VyZShcbiAgICAnUmVhY3RNb3VudCcsXG4gICAgJ19yZW5kZXJOZXdSb290Q29tcG9uZW50JyxcbiAgICBmdW5jdGlvbihcbiAgICAgICAgbmV4dENvbXBvbmVudCxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBzaG91bGRSZXVzZU1hcmt1cCkge1xuICAgICAgLy8gVmFyaW91cyBwYXJ0cyBvZiBvdXIgY29kZSAoc3VjaCBhcyBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCdzXG4gICAgICAvLyBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KSBhc3N1bWUgdGhhdCBjYWxscyB0byByZW5kZXIgYXJlbid0IG5lc3RlZDtcbiAgICAgIC8vIHZlcmlmeSB0aGF0IHRoYXQncyB0aGUgY2FzZS5cbiAgICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKFxuICAgICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID09IG51bGwsXG4gICAgICAgICdfcmVuZGVyTmV3Um9vdENvbXBvbmVudCgpOiBSZW5kZXIgbWV0aG9kcyBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uICcgK1xuICAgICAgICAnb2YgcHJvcHMgYW5kIHN0YXRlOyB0cmlnZ2VyaW5nIG5lc3RlZCBjb21wb25lbnQgdXBkYXRlcyBmcm9tICcgK1xuICAgICAgICAncmVuZGVyIGlzIG5vdCBhbGxvd2VkLiBJZiBuZWNlc3NhcnksIHRyaWdnZXIgbmVzdGVkIHVwZGF0ZXMgaW4gJyArXG4gICAgICAgICdjb21wb25lbnREaWRVcGRhdGUuJ1xuICAgICAgKSA6IG51bGwpO1xuXG4gICAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KG5leHRDb21wb25lbnQpO1xuICAgICAgdmFyIHJlYWN0Um9vdElEID0gUmVhY3RNb3VudC5fcmVnaXN0ZXJDb21wb25lbnQoXG4gICAgICAgIGNvbXBvbmVudEluc3RhbmNlLFxuICAgICAgICBjb250YWluZXJcbiAgICAgICk7XG4gICAgICBjb21wb25lbnRJbnN0YW5jZS5tb3VudENvbXBvbmVudEludG9Ob2RlKFxuICAgICAgICByZWFjdFJvb3RJRCxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBzaG91bGRSZXVzZU1hcmt1cFxuICAgICAgKTtcblxuICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgICAvLyBSZWNvcmQgdGhlIHJvb3QgZWxlbWVudCBpbiBjYXNlIGl0IGxhdGVyIGdldHMgdHJhbnNwbGFudGVkLlxuICAgICAgICByb290RWxlbWVudHNCeVJlYWN0Um9vdElEW3JlYWN0Um9vdElEXSA9XG4gICAgICAgICAgZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb21wb25lbnRJbnN0YW5jZTtcbiAgICB9XG4gICksXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBSZWFjdCBjb21wb25lbnQgaW50byB0aGUgRE9NIGluIHRoZSBzdXBwbGllZCBgY29udGFpbmVyYC5cbiAgICpcbiAgICogSWYgdGhlIFJlYWN0IGNvbXBvbmVudCB3YXMgcHJldmlvdXNseSByZW5kZXJlZCBpbnRvIGBjb250YWluZXJgLCB0aGlzIHdpbGxcbiAgICogcGVyZm9ybSBhbiB1cGRhdGUgb24gaXQgYW5kIG9ubHkgbXV0YXRlIHRoZSBET00gYXMgbmVjZXNzYXJ5IHRvIHJlZmxlY3QgdGhlXG4gICAqIGxhdGVzdCBSZWFjdCBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3REZXNjcmlwdG9yfSBuZXh0RGVzY3JpcHRvciBDb21wb25lbnQgZGVzY3JpcHRvciB0byByZW5kZXIuXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIHJlbmRlciBpbnRvLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdHJpZ2dlcmVkIG9uIGNvbXBsZXRpb25cbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IENvbXBvbmVudCBpbnN0YW5jZSByZW5kZXJlZCBpbiBgY29udGFpbmVyYC5cbiAgICovXG4gIHJlbmRlckNvbXBvbmVudDogZnVuY3Rpb24obmV4dERlc2NyaXB0b3IsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgUmVhY3REZXNjcmlwdG9yLmlzVmFsaWREZXNjcmlwdG9yKG5leHREZXNjcmlwdG9yKSxcbiAgICAgICdyZW5kZXJDb21wb25lbnQoKTogSW52YWxpZCBjb21wb25lbnQgZGVzY3JpcHRvci4lcycsXG4gICAgICAoXG4gICAgICAgIFJlYWN0RGVzY3JpcHRvci5pc1ZhbGlkRmFjdG9yeShuZXh0RGVzY3JpcHRvcikgP1xuICAgICAgICAgICcgSW5zdGVhZCBvZiBwYXNzaW5nIGEgY29tcG9uZW50IGNsYXNzLCBtYWtlIHN1cmUgdG8gaW5zdGFudGlhdGUgJyArXG4gICAgICAgICAgJ2l0IGZpcnN0IGJ5IGNhbGxpbmcgaXQgd2l0aCBwcm9wcy4nIDpcbiAgICAgICAgLy8gQ2hlY2sgaWYgaXQgcXVhY2tzIGxpa2UgYSBkZXNjcmlwdG9yXG4gICAgICAgIHR5cGVvZiBuZXh0RGVzY3JpcHRvci5wcm9wcyAhPT0gXCJ1bmRlZmluZWRcIiA/XG4gICAgICAgICAgJyBUaGlzIG1heSBiZSBjYXVzZWQgYnkgdW5pbnRlbnRpb25hbGx5IGxvYWRpbmcgdHdvIGluZGVwZW5kZW50ICcgK1xuICAgICAgICAgICdjb3BpZXMgb2YgUmVhY3QuJyA6XG4gICAgICAgICAgJydcbiAgICAgIClcbiAgICApIDogaW52YXJpYW50KFJlYWN0RGVzY3JpcHRvci5pc1ZhbGlkRGVzY3JpcHRvcihuZXh0RGVzY3JpcHRvcikpKTtcblxuICAgIHZhciBwcmV2Q29tcG9uZW50ID0gaW5zdGFuY2VzQnlSZWFjdFJvb3RJRFtnZXRSZWFjdFJvb3RJRChjb250YWluZXIpXTtcblxuICAgIGlmIChwcmV2Q29tcG9uZW50KSB7XG4gICAgICB2YXIgcHJldkRlc2NyaXB0b3IgPSBwcmV2Q29tcG9uZW50Ll9kZXNjcmlwdG9yO1xuICAgICAgaWYgKHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50KHByZXZEZXNjcmlwdG9yLCBuZXh0RGVzY3JpcHRvcikpIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0TW91bnQuX3VwZGF0ZVJvb3RDb21wb25lbnQoXG4gICAgICAgICAgcHJldkNvbXBvbmVudCxcbiAgICAgICAgICBuZXh0RGVzY3JpcHRvcixcbiAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFJlYWN0TW91bnQudW5tb3VudENvbXBvbmVudEF0Tm9kZShjb250YWluZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZWFjdFJvb3RFbGVtZW50ID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgdmFyIGNvbnRhaW5lckhhc1JlYWN0TWFya3VwID1cbiAgICAgIHJlYWN0Um9vdEVsZW1lbnQgJiYgUmVhY3RNb3VudC5pc1JlbmRlcmVkQnlSZWFjdChyZWFjdFJvb3RFbGVtZW50KTtcblxuICAgIHZhciBzaG91bGRSZXVzZU1hcmt1cCA9IGNvbnRhaW5lckhhc1JlYWN0TWFya3VwICYmICFwcmV2Q29tcG9uZW50O1xuXG4gICAgdmFyIGNvbXBvbmVudCA9IFJlYWN0TW91bnQuX3JlbmRlck5ld1Jvb3RDb21wb25lbnQoXG4gICAgICBuZXh0RGVzY3JpcHRvcixcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIHNob3VsZFJldXNlTWFya3VwXG4gICAgKTtcbiAgICBjYWxsYmFjayAmJiBjYWxsYmFjay5jYWxsKGNvbXBvbmVudCk7XG4gICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgfSxcblxuICAvKipcbiAgICogQ29uc3RydWN0cyBhIGNvbXBvbmVudCBpbnN0YW5jZSBvZiBgY29uc3RydWN0b3JgIHdpdGggYGluaXRpYWxQcm9wc2AgYW5kXG4gICAqIHJlbmRlcnMgaXQgaW50byB0aGUgc3VwcGxpZWQgYGNvbnRhaW5lcmAuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbnN0cnVjdG9yIFJlYWN0IGNvbXBvbmVudCBjb25zdHJ1Y3Rvci5cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBwcm9wcyBJbml0aWFsIHByb3BzIG9mIHRoZSBjb21wb25lbnQgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIHJlbmRlciBpbnRvLlxuICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH0gQ29tcG9uZW50IGluc3RhbmNlIHJlbmRlcmVkIGluIGBjb250YWluZXJgLlxuICAgKi9cbiAgY29uc3RydWN0QW5kUmVuZGVyQ29tcG9uZW50OiBmdW5jdGlvbihjb25zdHJ1Y3RvciwgcHJvcHMsIGNvbnRhaW5lcikge1xuICAgIHJldHVybiBSZWFjdE1vdW50LnJlbmRlckNvbXBvbmVudChjb25zdHJ1Y3Rvcihwcm9wcyksIGNvbnRhaW5lcik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBjb21wb25lbnQgaW5zdGFuY2Ugb2YgYGNvbnN0cnVjdG9yYCB3aXRoIGBpbml0aWFsUHJvcHNgIGFuZFxuICAgKiByZW5kZXJzIGl0IGludG8gYSBjb250YWluZXIgbm9kZSBpZGVudGlmaWVkIGJ5IHN1cHBsaWVkIGBpZGAuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbXBvbmVudENvbnN0cnVjdG9yIFJlYWN0IGNvbXBvbmVudCBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0gez9vYmplY3R9IHByb3BzIEluaXRpYWwgcHJvcHMgb2YgdGhlIGNvbXBvbmVudCBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIElEIG9mIHRoZSBET00gZWxlbWVudCB0byByZW5kZXIgaW50by5cbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IENvbXBvbmVudCBpbnN0YW5jZSByZW5kZXJlZCBpbiB0aGUgY29udGFpbmVyIG5vZGUuXG4gICAqL1xuICBjb25zdHJ1Y3RBbmRSZW5kZXJDb21wb25lbnRCeUlEOiBmdW5jdGlvbihjb25zdHJ1Y3RvciwgcHJvcHMsIGlkKSB7XG4gICAgdmFyIGRvbU5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgIGRvbU5vZGUsXG4gICAgICAnVHJpZWQgdG8gZ2V0IGVsZW1lbnQgd2l0aCBpZCBvZiBcIiVzXCIgYnV0IGl0IGlzIG5vdCBwcmVzZW50IG9uIHRoZSBwYWdlLicsXG4gICAgICBpZFxuICAgICkgOiBpbnZhcmlhbnQoZG9tTm9kZSkpO1xuICAgIHJldHVybiBSZWFjdE1vdW50LmNvbnN0cnVjdEFuZFJlbmRlckNvbXBvbmVudChjb25zdHJ1Y3RvciwgcHJvcHMsIGRvbU5vZGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBjb250YWluZXIgbm9kZSBpbnRvIHdoaWNoIFJlYWN0IGNvbXBvbmVudHMgd2lsbCBiZSByZW5kZXJlZC5cbiAgICogVGhpcyBhbHNvIGNyZWF0ZXMgdGhlIFwicmVhY3RSb290XCIgSUQgdGhhdCB3aWxsIGJlIGFzc2lnbmVkIHRvIHRoZSBlbGVtZW50XG4gICAqIHJlbmRlcmVkIHdpdGhpbi5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdG8gcmVnaXN0ZXIgYXMgYSBjb250YWluZXIuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIFwicmVhY3RSb290XCIgSUQgb2YgZWxlbWVudHMgcmVuZGVyZWQgd2l0aGluLlxuICAgKi9cbiAgcmVnaXN0ZXJDb250YWluZXI6IGZ1bmN0aW9uKGNvbnRhaW5lcikge1xuICAgIHZhciByZWFjdFJvb3RJRCA9IGdldFJlYWN0Um9vdElEKGNvbnRhaW5lcik7XG4gICAgaWYgKHJlYWN0Um9vdElEKSB7XG4gICAgICAvLyBJZiBvbmUgZXhpc3RzLCBtYWtlIHN1cmUgaXQgaXMgYSB2YWxpZCBcInJlYWN0Um9vdFwiIElELlxuICAgICAgcmVhY3RSb290SUQgPSBSZWFjdEluc3RhbmNlSGFuZGxlcy5nZXRSZWFjdFJvb3RJREZyb21Ob2RlSUQocmVhY3RSb290SUQpO1xuICAgIH1cbiAgICBpZiAoIXJlYWN0Um9vdElEKSB7XG4gICAgICAvLyBObyB2YWxpZCBcInJlYWN0Um9vdFwiIElEIGZvdW5kLCBjcmVhdGUgb25lLlxuICAgICAgcmVhY3RSb290SUQgPSBSZWFjdEluc3RhbmNlSGFuZGxlcy5jcmVhdGVSZWFjdFJvb3RJRCgpO1xuICAgIH1cbiAgICBjb250YWluZXJzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF0gPSBjb250YWluZXI7XG4gICAgcmV0dXJuIHJlYWN0Um9vdElEO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVbm1vdW50cyBhbmQgZGVzdHJveXMgdGhlIFJlYWN0IGNvbXBvbmVudCByZW5kZXJlZCBpbiB0aGUgYGNvbnRhaW5lcmAuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IGNvbnRhaW5pbmcgYSBSZWFjdCBjb21wb25lbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYSBjb21wb25lbnQgd2FzIGZvdW5kIGluIGFuZCB1bm1vdW50ZWQgZnJvbVxuICAgKiAgICAgICAgICAgICAgICAgICBgY29udGFpbmVyYFxuICAgKi9cbiAgdW5tb3VudENvbXBvbmVudEF0Tm9kZTogZnVuY3Rpb24oY29udGFpbmVyKSB7XG4gICAgLy8gVmFyaW91cyBwYXJ0cyBvZiBvdXIgY29kZSAoc3VjaCBhcyBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCdzXG4gICAgLy8gX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCkgYXNzdW1lIHRoYXQgY2FsbHMgdG8gcmVuZGVyIGFyZW4ndCBuZXN0ZWQ7XG4gICAgLy8gdmVyaWZ5IHRoYXQgdGhhdCdzIHRoZSBjYXNlLiAoU3RyaWN0bHkgc3BlYWtpbmcsIHVubW91bnRpbmcgd29uJ3QgY2F1c2UgYVxuICAgIC8vIHJlbmRlciBidXQgd2Ugc3RpbGwgZG9uJ3QgZXhwZWN0IHRvIGJlIGluIGEgcmVuZGVyIGNhbGwgaGVyZS4pXG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcoXG4gICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID09IG51bGwsXG4gICAgICAndW5tb3VudENvbXBvbmVudEF0Tm9kZSgpOiBSZW5kZXIgbWV0aG9kcyBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mICcgK1xuICAgICAgJ3Byb3BzIGFuZCBzdGF0ZTsgdHJpZ2dlcmluZyBuZXN0ZWQgY29tcG9uZW50IHVwZGF0ZXMgZnJvbSByZW5kZXIgaXMgJyArXG4gICAgICAnbm90IGFsbG93ZWQuIElmIG5lY2Vzc2FyeSwgdHJpZ2dlciBuZXN0ZWQgdXBkYXRlcyBpbiAnICtcbiAgICAgICdjb21wb25lbnREaWRVcGRhdGUuJ1xuICAgICkgOiBudWxsKTtcblxuICAgIHZhciByZWFjdFJvb3RJRCA9IGdldFJlYWN0Um9vdElEKGNvbnRhaW5lcik7XG4gICAgdmFyIGNvbXBvbmVudCA9IGluc3RhbmNlc0J5UmVhY3RSb290SURbcmVhY3RSb290SURdO1xuICAgIGlmICghY29tcG9uZW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFJlYWN0TW91bnQudW5tb3VudENvbXBvbmVudEZyb21Ob2RlKGNvbXBvbmVudCwgY29udGFpbmVyKTtcbiAgICBkZWxldGUgaW5zdGFuY2VzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF07XG4gICAgZGVsZXRlIGNvbnRhaW5lcnNCeVJlYWN0Um9vdElEW3JlYWN0Um9vdElEXTtcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICBkZWxldGUgcm9vdEVsZW1lbnRzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF07XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVbm1vdW50cyBhIGNvbXBvbmVudCBhbmQgcmVtb3ZlcyBpdCBmcm9tIHRoZSBET00uXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGluc3RhbmNlIFJlYWN0IGNvbXBvbmVudCBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdG8gdW5tb3VudCBmcm9tLlxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqIEBzZWUge1JlYWN0TW91bnQudW5tb3VudENvbXBvbmVudEF0Tm9kZX1cbiAgICovXG4gIHVubW91bnRDb21wb25lbnRGcm9tTm9kZTogZnVuY3Rpb24oaW5zdGFuY2UsIGNvbnRhaW5lcikge1xuICAgIGluc3RhbmNlLnVubW91bnRDb21wb25lbnQoKTtcblxuICAgIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IERPQ19OT0RFX1RZUEUpIHtcbiAgICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lci5kb2N1bWVudEVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLy8gaHR0cDovL2pzcGVyZi5jb20vZW1wdHlpbmctYS1ub2RlXG4gICAgd2hpbGUgKGNvbnRhaW5lci5sYXN0Q2hpbGQpIHtcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjb250YWluZXIubGFzdENoaWxkKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbmRzIHRoZSBjb250YWluZXIgRE9NIGVsZW1lbnQgdGhhdCBjb250YWlucyBSZWFjdCBjb21wb25lbnQgdG8gd2hpY2ggdGhlXG4gICAqIHN1cHBsaWVkIERPTSBgaWRgIGJlbG9uZ3MuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgSUQgb2YgYW4gZWxlbWVudCByZW5kZXJlZCBieSBhIFJlYWN0IGNvbXBvbmVudC5cbiAgICogQHJldHVybiB7P0RPTUVsZW1lbnR9IERPTSBlbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIGBpZGAuXG4gICAqL1xuICBmaW5kUmVhY3RDb250YWluZXJGb3JJRDogZnVuY3Rpb24oaWQpIHtcbiAgICB2YXIgcmVhY3RSb290SUQgPSBSZWFjdEluc3RhbmNlSGFuZGxlcy5nZXRSZWFjdFJvb3RJREZyb21Ob2RlSUQoaWQpO1xuICAgIHZhciBjb250YWluZXIgPSBjb250YWluZXJzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF07XG5cbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICB2YXIgcm9vdEVsZW1lbnQgPSByb290RWxlbWVudHNCeVJlYWN0Um9vdElEW3JlYWN0Um9vdElEXTtcbiAgICAgIGlmIChyb290RWxlbWVudCAmJiByb290RWxlbWVudC5wYXJlbnROb2RlICE9PSBjb250YWluZXIpIHtcbiAgICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICAgICAvLyBDYWxsIGludGVybmFsR2V0SUQgaGVyZSBiZWNhdXNlIGdldElEIGNhbGxzIGlzVmFsaWQgd2hpY2ggY2FsbHNcbiAgICAgICAgICAvLyBmaW5kUmVhY3RDb250YWluZXJGb3JJRCAodGhpcyBmdW5jdGlvbikuXG4gICAgICAgICAgaW50ZXJuYWxHZXRJRChyb290RWxlbWVudCkgPT09IHJlYWN0Um9vdElELFxuICAgICAgICAgICdSZWFjdE1vdW50OiBSb290IGVsZW1lbnQgSUQgZGlmZmVyZWQgZnJvbSByZWFjdFJvb3RJRC4nXG4gICAgICAgICkgOiBpbnZhcmlhbnQoLy8gQ2FsbCBpbnRlcm5hbEdldElEIGhlcmUgYmVjYXVzZSBnZXRJRCBjYWxscyBpc1ZhbGlkIHdoaWNoIGNhbGxzXG4gICAgICAgIC8vIGZpbmRSZWFjdENvbnRhaW5lckZvcklEICh0aGlzIGZ1bmN0aW9uKS5cbiAgICAgICAgaW50ZXJuYWxHZXRJRChyb290RWxlbWVudCkgPT09IHJlYWN0Um9vdElEKSk7XG5cbiAgICAgICAgdmFyIGNvbnRhaW5lckNoaWxkID0gY29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmIChjb250YWluZXJDaGlsZCAmJlxuICAgICAgICAgICAgcmVhY3RSb290SUQgPT09IGludGVybmFsR2V0SUQoY29udGFpbmVyQ2hpbGQpKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGNvbnRhaW5lciBoYXMgYSBuZXcgY2hpbGQgd2l0aCB0aGUgc2FtZSBJRCBhcyB0aGUgb2xkXG4gICAgICAgICAgLy8gcm9vdCBlbGVtZW50LCB0aGVuIHJvb3RFbGVtZW50c0J5UmVhY3RSb290SURbcmVhY3RSb290SURdIGlzXG4gICAgICAgICAgLy8ganVzdCBzdGFsZSBhbmQgbmVlZHMgdG8gYmUgdXBkYXRlZC4gVGhlIGNhc2UgdGhhdCBkZXNlcnZlcyBhXG4gICAgICAgICAgLy8gd2FybmluZyBpcyB3aGVuIHRoZSBjb250YWluZXIgaXMgZW1wdHkuXG4gICAgICAgICAgcm9vdEVsZW1lbnRzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF0gPSBjb250YWluZXJDaGlsZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAnUmVhY3RNb3VudDogUm9vdCBlbGVtZW50IGhhcyBiZWVuIHJlbW92ZWQgZnJvbSBpdHMgb3JpZ2luYWwgJyArXG4gICAgICAgICAgICAnY29udGFpbmVyLiBOZXcgY29udGFpbmVyOicsIHJvb3RFbGVtZW50LnBhcmVudE5vZGVcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfSxcblxuICAvKipcbiAgICogRmluZHMgYW4gZWxlbWVudCByZW5kZXJlZCBieSBSZWFjdCB3aXRoIHRoZSBzdXBwbGllZCBJRC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIElEIG9mIGEgRE9NIG5vZGUgaW4gdGhlIFJlYWN0IGNvbXBvbmVudC5cbiAgICogQHJldHVybiB7RE9NRWxlbWVudH0gUm9vdCBET00gbm9kZSBvZiB0aGUgUmVhY3QgY29tcG9uZW50LlxuICAgKi9cbiAgZmluZFJlYWN0Tm9kZUJ5SUQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgdmFyIHJlYWN0Um9vdCA9IFJlYWN0TW91bnQuZmluZFJlYWN0Q29udGFpbmVyRm9ySUQoaWQpO1xuICAgIHJldHVybiBSZWFjdE1vdW50LmZpbmRDb21wb25lbnRSb290KHJlYWN0Um9vdCwgaWQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcnVlIGlmIHRoZSBzdXBwbGllZCBgbm9kZWAgaXMgcmVuZGVyZWQgYnkgUmVhY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gbm9kZSBET00gRWxlbWVudCB0byBjaGVjay5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgRE9NIEVsZW1lbnQgYXBwZWFycyB0byBiZSByZW5kZXJlZCBieSBSZWFjdC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBpc1JlbmRlcmVkQnlSZWFjdDogZnVuY3Rpb24obm9kZSkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgICAvLyBOb3QgYSBET01FbGVtZW50LCB0aGVyZWZvcmUgbm90IGEgUmVhY3QgY29tcG9uZW50XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBpZCA9IFJlYWN0TW91bnQuZ2V0SUQobm9kZSk7XG4gICAgcmV0dXJuIGlkID8gaWQuY2hhckF0KDApID09PSBTRVBBUkFUT1IgOiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogVHJhdmVyc2VzIHVwIHRoZSBhbmNlc3RvcnMgb2YgdGhlIHN1cHBsaWVkIG5vZGUgdG8gZmluZCBhIG5vZGUgdGhhdCBpcyBhXG4gICAqIERPTSByZXByZXNlbnRhdGlvbiBvZiBhIFJlYWN0IGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBub2RlXG4gICAqIEByZXR1cm4gez9ET01FdmVudFRhcmdldH1cbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXRGaXJzdFJlYWN0RE9NOiBmdW5jdGlvbihub2RlKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBub2RlO1xuICAgIHdoaWxlIChjdXJyZW50ICYmIGN1cnJlbnQucGFyZW50Tm9kZSAhPT0gY3VycmVudCkge1xuICAgICAgaWYgKFJlYWN0TW91bnQuaXNSZW5kZXJlZEJ5UmVhY3QoY3VycmVudCkpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICB9XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogRmluZHMgYSBub2RlIHdpdGggdGhlIHN1cHBsaWVkIGB0YXJnZXRJRGAgaW5zaWRlIG9mIHRoZSBzdXBwbGllZFxuICAgKiBgYW5jZXN0b3JOb2RlYC4gIEV4cGxvaXRzIHRoZSBJRCBuYW1pbmcgc2NoZW1lIHRvIHBlcmZvcm0gdGhlIHNlYXJjaFxuICAgKiBxdWlja2x5LlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSBhbmNlc3Rvck5vZGUgU2VhcmNoIGZyb20gdGhpcyByb290LlxuICAgKiBAcGFyYXJtIHtzdHJpbmd9IHRhcmdldElEIElEIG9mIHRoZSBET00gcmVwcmVzZW50YXRpb24gb2YgdGhlIGNvbXBvbmVudC5cbiAgICogQHJldHVybiB7RE9NRXZlbnRUYXJnZXR9IERPTSBub2RlIHdpdGggdGhlIHN1cHBsaWVkIGB0YXJnZXRJRGAuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZmluZENvbXBvbmVudFJvb3Q6IGZ1bmN0aW9uKGFuY2VzdG9yTm9kZSwgdGFyZ2V0SUQpIHtcbiAgICB2YXIgZmlyc3RDaGlsZHJlbiA9IGZpbmRDb21wb25lbnRSb290UmV1c2FibGVBcnJheTtcbiAgICB2YXIgY2hpbGRJbmRleCA9IDA7XG5cbiAgICB2YXIgZGVlcGVzdEFuY2VzdG9yID0gZmluZERlZXBlc3RDYWNoZWRBbmNlc3Rvcih0YXJnZXRJRCkgfHwgYW5jZXN0b3JOb2RlO1xuXG4gICAgZmlyc3RDaGlsZHJlblswXSA9IGRlZXBlc3RBbmNlc3Rvci5maXJzdENoaWxkO1xuICAgIGZpcnN0Q2hpbGRyZW4ubGVuZ3RoID0gMTtcblxuICAgIHdoaWxlIChjaGlsZEluZGV4IDwgZmlyc3RDaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHZhciBjaGlsZCA9IGZpcnN0Q2hpbGRyZW5bY2hpbGRJbmRleCsrXTtcbiAgICAgIHZhciB0YXJnZXRDaGlsZDtcblxuICAgICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgIHZhciBjaGlsZElEID0gUmVhY3RNb3VudC5nZXRJRChjaGlsZCk7XG4gICAgICAgIGlmIChjaGlsZElEKSB7XG4gICAgICAgICAgLy8gRXZlbiBpZiB3ZSBmaW5kIHRoZSBub2RlIHdlJ3JlIGxvb2tpbmcgZm9yLCB3ZSBmaW5pc2ggbG9vcGluZ1xuICAgICAgICAgIC8vIHRocm91Z2ggaXRzIHNpYmxpbmdzIHRvIGVuc3VyZSB0aGV5J3JlIGNhY2hlZCBzbyB0aGF0IHdlIGRvbid0IGhhdmVcbiAgICAgICAgICAvLyB0byByZXZpc2l0IHRoaXMgbm9kZSBhZ2Fpbi4gT3RoZXJ3aXNlLCB3ZSBtYWtlIG5eMiBjYWxscyB0byBnZXRJRFxuICAgICAgICAgIC8vIHdoZW4gdmlzaXRpbmcgdGhlIG1hbnkgY2hpbGRyZW4gb2YgYSBzaW5nbGUgbm9kZSBpbiBvcmRlci5cblxuICAgICAgICAgIGlmICh0YXJnZXRJRCA9PT0gY2hpbGRJRCkge1xuICAgICAgICAgICAgdGFyZ2V0Q2hpbGQgPSBjaGlsZDtcbiAgICAgICAgICB9IGVsc2UgaWYgKFJlYWN0SW5zdGFuY2VIYW5kbGVzLmlzQW5jZXN0b3JJRE9mKGNoaWxkSUQsIHRhcmdldElEKSkge1xuICAgICAgICAgICAgLy8gSWYgd2UgZmluZCBhIGNoaWxkIHdob3NlIElEIGlzIGFuIGFuY2VzdG9yIG9mIHRoZSBnaXZlbiBJRCxcbiAgICAgICAgICAgIC8vIHRoZW4gd2UgY2FuIGJlIHN1cmUgdGhhdCB3ZSBvbmx5IHdhbnQgdG8gc2VhcmNoIHRoZSBzdWJ0cmVlXG4gICAgICAgICAgICAvLyByb290ZWQgYXQgdGhpcyBjaGlsZCwgc28gd2UgY2FuIHRocm93IG91dCB0aGUgcmVzdCBvZiB0aGVcbiAgICAgICAgICAgIC8vIHNlYXJjaCBzdGF0ZS5cbiAgICAgICAgICAgIGZpcnN0Q2hpbGRyZW4ubGVuZ3RoID0gY2hpbGRJbmRleCA9IDA7XG4gICAgICAgICAgICBmaXJzdENoaWxkcmVuLnB1c2goY2hpbGQuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSWYgdGhpcyBjaGlsZCBoYWQgbm8gSUQsIHRoZW4gdGhlcmUncyBhIGNoYW5jZSB0aGF0IGl0IHdhc1xuICAgICAgICAgIC8vIGluamVjdGVkIGF1dG9tYXRpY2FsbHkgYnkgdGhlIGJyb3dzZXIsIGFzIHdoZW4gYSBgPHRhYmxlPmBcbiAgICAgICAgICAvLyBlbGVtZW50IHNwcm91dHMgYW4gZXh0cmEgYDx0Ym9keT5gIGNoaWxkIGFzIGEgc2lkZSBlZmZlY3Qgb2ZcbiAgICAgICAgICAvLyBgLmlubmVySFRNTGAgcGFyc2luZy4gT3B0aW1pc3RpY2FsbHkgY29udGludWUgZG93biB0aGlzXG4gICAgICAgICAgLy8gYnJhbmNoLCBidXQgbm90IGJlZm9yZSBleGFtaW5pbmcgdGhlIG90aGVyIHNpYmxpbmdzLlxuICAgICAgICAgIGZpcnN0Q2hpbGRyZW4ucHVzaChjaGlsZC5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICB9XG5cbiAgICAgIGlmICh0YXJnZXRDaGlsZCkge1xuICAgICAgICAvLyBFbXB0eWluZyBmaXJzdENoaWxkcmVuL2ZpbmRDb21wb25lbnRSb290UmV1c2FibGVBcnJheSBpc1xuICAgICAgICAvLyBub3QgbmVjZXNzYXJ5IGZvciBjb3JyZWN0bmVzcywgYnV0IGl0IGhlbHBzIHRoZSBHQyByZWNsYWltXG4gICAgICAgIC8vIGFueSBub2RlcyB0aGF0IHdlcmUgbGVmdCBhdCB0aGUgZW5kIG9mIHRoZSBzZWFyY2guXG4gICAgICAgIGZpcnN0Q2hpbGRyZW4ubGVuZ3RoID0gMDtcblxuICAgICAgICByZXR1cm4gdGFyZ2V0Q2hpbGQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZmlyc3RDaGlsZHJlbi5sZW5ndGggPSAwO1xuXG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgIGZhbHNlLFxuICAgICAgJ2ZpbmRDb21wb25lbnRSb290KC4uLiwgJXMpOiBVbmFibGUgdG8gZmluZCBlbGVtZW50LiBUaGlzIHByb2JhYmx5ICcgK1xuICAgICAgJ21lYW5zIHRoZSBET00gd2FzIHVuZXhwZWN0ZWRseSBtdXRhdGVkIChlLmcuLCBieSB0aGUgYnJvd3NlciksICcgK1xuICAgICAgJ3VzdWFsbHkgZHVlIHRvIGZvcmdldHRpbmcgYSA8dGJvZHk+IHdoZW4gdXNpbmcgdGFibGVzLCBuZXN0aW5nIDxwPiAnICtcbiAgICAgICdvciA8YT4gdGFncywgb3IgdXNpbmcgbm9uLVNWRyBlbGVtZW50cyBpbiBhbiA8c3ZnPiBwYXJlbnQuIFRyeSAnICtcbiAgICAgICdpbnNwZWN0aW5nIHRoZSBjaGlsZCBub2RlcyBvZiB0aGUgZWxlbWVudCB3aXRoIFJlYWN0IElEIGAlc2AuJyxcbiAgICAgIHRhcmdldElELFxuICAgICAgUmVhY3RNb3VudC5nZXRJRChhbmNlc3Rvck5vZGUpXG4gICAgKSA6IGludmFyaWFudChmYWxzZSkpO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIFJlYWN0IElEIHV0aWxpdGllcy5cbiAgICovXG5cbiAgZ2V0UmVhY3RSb290SUQ6IGdldFJlYWN0Um9vdElELFxuXG4gIGdldElEOiBnZXRJRCxcblxuICBzZXRJRDogc2V0SUQsXG5cbiAgZ2V0Tm9kZTogZ2V0Tm9kZSxcblxuICBwdXJnZUlEOiBwdXJnZUlEXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0TW91bnQ7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE11bHRpQ2hpbGRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoXCIuL1JlYWN0Q29tcG9uZW50XCIpO1xudmFyIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzID0gcmVxdWlyZShcIi4vUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXNcIik7XG5cbnZhciBmbGF0dGVuQ2hpbGRyZW4gPSByZXF1aXJlKFwiLi9mbGF0dGVuQ2hpbGRyZW5cIik7XG52YXIgaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoXCIuL2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnRcIik7XG52YXIgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKFwiLi9zaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudFwiKTtcblxuLyoqXG4gKiBVcGRhdGluZyBjaGlsZHJlbiBvZiBhIGNvbXBvbmVudCBtYXkgdHJpZ2dlciByZWN1cnNpdmUgdXBkYXRlcy4gVGhlIGRlcHRoIGlzXG4gKiB1c2VkIHRvIGJhdGNoIHJlY3Vyc2l2ZSB1cGRhdGVzIHRvIHJlbmRlciBtYXJrdXAgbW9yZSBlZmZpY2llbnRseS5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQHByaXZhdGVcbiAqL1xudmFyIHVwZGF0ZURlcHRoID0gMDtcblxuLyoqXG4gKiBRdWV1ZSBvZiB1cGRhdGUgY29uZmlndXJhdGlvbiBvYmplY3RzLlxuICpcbiAqIEVhY2ggb2JqZWN0IGhhcyBhIGB0eXBlYCBwcm9wZXJ0eSB0aGF0IGlzIGluIGBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlc2AuXG4gKlxuICogQHR5cGUge2FycmF5PG9iamVjdD59XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgdXBkYXRlUXVldWUgPSBbXTtcblxuLyoqXG4gKiBRdWV1ZSBvZiBtYXJrdXAgdG8gYmUgcmVuZGVyZWQuXG4gKlxuICogQHR5cGUge2FycmF5PHN0cmluZz59XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgbWFya3VwUXVldWUgPSBbXTtcblxuLyoqXG4gKiBFbnF1ZXVlcyBtYXJrdXAgdG8gYmUgcmVuZGVyZWQgYW5kIGluc2VydGVkIGF0IGEgc3VwcGxpZWQgaW5kZXguXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmVudElEIElEIG9mIHRoZSBwYXJlbnQgY29tcG9uZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBNYXJrdXAgdGhhdCByZW5kZXJzIGludG8gYW4gZWxlbWVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b0luZGV4IERlc3RpbmF0aW9uIGluZGV4LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW5xdWV1ZU1hcmt1cChwYXJlbnRJRCwgbWFya3VwLCB0b0luZGV4KSB7XG4gIC8vIE5PVEU6IE51bGwgdmFsdWVzIHJlZHVjZSBoaWRkZW4gY2xhc3Nlcy5cbiAgdXBkYXRlUXVldWUucHVzaCh7XG4gICAgcGFyZW50SUQ6IHBhcmVudElELFxuICAgIHBhcmVudE5vZGU6IG51bGwsXG4gICAgdHlwZTogUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuSU5TRVJUX01BUktVUCxcbiAgICBtYXJrdXBJbmRleDogbWFya3VwUXVldWUucHVzaChtYXJrdXApIC0gMSxcbiAgICB0ZXh0Q29udGVudDogbnVsbCxcbiAgICBmcm9tSW5kZXg6IG51bGwsXG4gICAgdG9JbmRleDogdG9JbmRleFxuICB9KTtcbn1cblxuLyoqXG4gKiBFbnF1ZXVlcyBtb3ZpbmcgYW4gZXhpc3RpbmcgZWxlbWVudCB0byBhbm90aGVyIGluZGV4LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJlbnRJRCBJRCBvZiB0aGUgcGFyZW50IGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggU291cmNlIGluZGV4IG9mIHRoZSBleGlzdGluZyBlbGVtZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHRvSW5kZXggRGVzdGluYXRpb24gaW5kZXggb2YgdGhlIGVsZW1lbnQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbnF1ZXVlTW92ZShwYXJlbnRJRCwgZnJvbUluZGV4LCB0b0luZGV4KSB7XG4gIC8vIE5PVEU6IE51bGwgdmFsdWVzIHJlZHVjZSBoaWRkZW4gY2xhc3Nlcy5cbiAgdXBkYXRlUXVldWUucHVzaCh7XG4gICAgcGFyZW50SUQ6IHBhcmVudElELFxuICAgIHBhcmVudE5vZGU6IG51bGwsXG4gICAgdHlwZTogUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuTU9WRV9FWElTVElORyxcbiAgICBtYXJrdXBJbmRleDogbnVsbCxcbiAgICB0ZXh0Q29udGVudDogbnVsbCxcbiAgICBmcm9tSW5kZXg6IGZyb21JbmRleCxcbiAgICB0b0luZGV4OiB0b0luZGV4XG4gIH0pO1xufVxuXG4vKipcbiAqIEVucXVldWVzIHJlbW92aW5nIGFuIGVsZW1lbnQgYXQgYW4gaW5kZXguXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmVudElEIElEIG9mIHRoZSBwYXJlbnQgY29tcG9uZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBJbmRleCBvZiB0aGUgZWxlbWVudCB0byByZW1vdmUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbnF1ZXVlUmVtb3ZlKHBhcmVudElELCBmcm9tSW5kZXgpIHtcbiAgLy8gTk9URTogTnVsbCB2YWx1ZXMgcmVkdWNlIGhpZGRlbiBjbGFzc2VzLlxuICB1cGRhdGVRdWV1ZS5wdXNoKHtcbiAgICBwYXJlbnRJRDogcGFyZW50SUQsXG4gICAgcGFyZW50Tm9kZTogbnVsbCxcbiAgICB0eXBlOiBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5SRU1PVkVfTk9ERSxcbiAgICBtYXJrdXBJbmRleDogbnVsbCxcbiAgICB0ZXh0Q29udGVudDogbnVsbCxcbiAgICBmcm9tSW5kZXg6IGZyb21JbmRleCxcbiAgICB0b0luZGV4OiBudWxsXG4gIH0pO1xufVxuXG4vKipcbiAqIEVucXVldWVzIHNldHRpbmcgdGhlIHRleHQgY29udGVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyZW50SUQgSUQgb2YgdGhlIHBhcmVudCBjb21wb25lbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dENvbnRlbnQgVGV4dCBjb250ZW50IHRvIHNldC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVucXVldWVUZXh0Q29udGVudChwYXJlbnRJRCwgdGV4dENvbnRlbnQpIHtcbiAgLy8gTk9URTogTnVsbCB2YWx1ZXMgcmVkdWNlIGhpZGRlbiBjbGFzc2VzLlxuICB1cGRhdGVRdWV1ZS5wdXNoKHtcbiAgICBwYXJlbnRJRDogcGFyZW50SUQsXG4gICAgcGFyZW50Tm9kZTogbnVsbCxcbiAgICB0eXBlOiBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5URVhUX0NPTlRFTlQsXG4gICAgbWFya3VwSW5kZXg6IG51bGwsXG4gICAgdGV4dENvbnRlbnQ6IHRleHRDb250ZW50LFxuICAgIGZyb21JbmRleDogbnVsbCxcbiAgICB0b0luZGV4OiBudWxsXG4gIH0pO1xufVxuXG4vKipcbiAqIFByb2Nlc3NlcyBhbnkgZW5xdWV1ZWQgdXBkYXRlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwcm9jZXNzUXVldWUoKSB7XG4gIGlmICh1cGRhdGVRdWV1ZS5sZW5ndGgpIHtcbiAgICBSZWFjdENvbXBvbmVudC5CYWNrZW5kSURPcGVyYXRpb25zLmRhbmdlcm91c2x5UHJvY2Vzc0NoaWxkcmVuVXBkYXRlcyhcbiAgICAgIHVwZGF0ZVF1ZXVlLFxuICAgICAgbWFya3VwUXVldWVcbiAgICApO1xuICAgIGNsZWFyUXVldWUoKTtcbiAgfVxufVxuXG4vKipcbiAqIENsZWFycyBhbnkgZW5xdWV1ZWQgdXBkYXRlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjbGVhclF1ZXVlKCkge1xuICB1cGRhdGVRdWV1ZS5sZW5ndGggPSAwO1xuICBtYXJrdXBRdWV1ZS5sZW5ndGggPSAwO1xufVxuXG4vKipcbiAqIFJlYWN0TXVsdGlDaGlsZCBhcmUgY2FwYWJsZSBvZiByZWNvbmNpbGluZyBtdWx0aXBsZSBjaGlsZHJlbi5cbiAqXG4gKiBAY2xhc3MgUmVhY3RNdWx0aUNoaWxkXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0TXVsdGlDaGlsZCA9IHtcblxuICAvKipcbiAgICogUHJvdmlkZXMgY29tbW9uIGZ1bmN0aW9uYWxpdHkgZm9yIGNvbXBvbmVudHMgdGhhdCBtdXN0IHJlY29uY2lsZSBtdWx0aXBsZVxuICAgKiBjaGlsZHJlbi4gVGhpcyBpcyB1c2VkIGJ5IGBSZWFjdERPTUNvbXBvbmVudGAgdG8gbW91bnQsIHVwZGF0ZSwgYW5kXG4gICAqIHVubW91bnQgY2hpbGQgY29tcG9uZW50cy5cbiAgICpcbiAgICogQGxlbmRzIHtSZWFjdE11bHRpQ2hpbGQucHJvdG90eXBlfVxuICAgKi9cbiAgTWl4aW46IHtcblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIFwibW91bnQgaW1hZ2VcIiBmb3IgZWFjaCBvZiB0aGUgc3VwcGxpZWQgY2hpbGRyZW4uIEluIHRoZSBjYXNlXG4gICAgICogb2YgYFJlYWN0RE9NQ29tcG9uZW50YCwgYSBtb3VudCBpbWFnZSBpcyBhIHN0cmluZyBvZiBtYXJrdXAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IG5lc3RlZENoaWxkcmVuIE5lc3RlZCBjaGlsZCBtYXBzLlxuICAgICAqIEByZXR1cm4ge2FycmF5fSBBbiBhcnJheSBvZiBtb3VudGVkIHJlcHJlc2VudGF0aW9ucy5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBtb3VudENoaWxkcmVuOiBmdW5jdGlvbihuZXN0ZWRDaGlsZHJlbiwgdHJhbnNhY3Rpb24pIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IGZsYXR0ZW5DaGlsZHJlbihuZXN0ZWRDaGlsZHJlbik7XG4gICAgICB2YXIgbW91bnRJbWFnZXMgPSBbXTtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICB0aGlzLl9yZW5kZXJlZENoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICBmb3IgKHZhciBuYW1lIGluIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW25hbWVdO1xuICAgICAgICBpZiAoY2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAvLyBUaGUgcmVuZGVyZWQgY2hpbGRyZW4gbXVzdCBiZSB0dXJuZWQgaW50byBpbnN0YW5jZXMgYXMgdGhleSdyZVxuICAgICAgICAgIC8vIG1vdW50ZWQuXG4gICAgICAgICAgdmFyIGNoaWxkSW5zdGFuY2UgPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KGNoaWxkKTtcbiAgICAgICAgICBjaGlsZHJlbltuYW1lXSA9IGNoaWxkSW5zdGFuY2U7XG4gICAgICAgICAgLy8gSW5saW5lZCBmb3IgcGVyZm9ybWFuY2UsIHNlZSBgUmVhY3RJbnN0YW5jZUhhbmRsZXMuY3JlYXRlUmVhY3RJRGAuXG4gICAgICAgICAgdmFyIHJvb3RJRCA9IHRoaXMuX3Jvb3ROb2RlSUQgKyBuYW1lO1xuICAgICAgICAgIHZhciBtb3VudEltYWdlID0gY2hpbGRJbnN0YW5jZS5tb3VudENvbXBvbmVudChcbiAgICAgICAgICAgIHJvb3RJRCxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgdGhpcy5fbW91bnREZXB0aCArIDFcbiAgICAgICAgICApO1xuICAgICAgICAgIGNoaWxkSW5zdGFuY2UuX21vdW50SW5kZXggPSBpbmRleDtcbiAgICAgICAgICBtb3VudEltYWdlcy5wdXNoKG1vdW50SW1hZ2UpO1xuICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtb3VudEltYWdlcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZXMgYW55IHJlbmRlcmVkIGNoaWxkcmVuIHdpdGggYSB0ZXh0IGNvbnRlbnQgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5leHRDb250ZW50IFN0cmluZyBvZiBjb250ZW50LlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHVwZGF0ZVRleHRDb250ZW50OiBmdW5jdGlvbihuZXh0Q29udGVudCkge1xuICAgICAgdXBkYXRlRGVwdGgrKztcbiAgICAgIHZhciBlcnJvclRocm93biA9IHRydWU7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5fcmVuZGVyZWRDaGlsZHJlbjtcbiAgICAgICAgLy8gUmVtb3ZlIGFueSByZW5kZXJlZCBjaGlsZHJlbi5cbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBwcmV2Q2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAocHJldkNoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLl91bm1vdW50Q2hpbGRCeU5hbWUocHJldkNoaWxkcmVuW25hbWVdLCBuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IG5ldyB0ZXh0IGNvbnRlbnQuXG4gICAgICAgIHRoaXMuc2V0VGV4dENvbnRlbnQobmV4dENvbnRlbnQpO1xuICAgICAgICBlcnJvclRocm93biA9IGZhbHNlO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdXBkYXRlRGVwdGgtLTtcbiAgICAgICAgaWYgKCF1cGRhdGVEZXB0aCkge1xuICAgICAgICAgIGVycm9yVGhyb3duID8gY2xlYXJRdWV1ZSgpIDogcHJvY2Vzc1F1ZXVlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgcmVuZGVyZWQgY2hpbGRyZW4gd2l0aCBuZXcgY2hpbGRyZW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHROZXN0ZWRDaGlsZHJlbiBOZXN0ZWQgY2hpbGQgbWFwcy5cbiAgICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdXBkYXRlQ2hpbGRyZW46IGZ1bmN0aW9uKG5leHROZXN0ZWRDaGlsZHJlbiwgdHJhbnNhY3Rpb24pIHtcbiAgICAgIHVwZGF0ZURlcHRoKys7XG4gICAgICB2YXIgZXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5fdXBkYXRlQ2hpbGRyZW4obmV4dE5lc3RlZENoaWxkcmVuLCB0cmFuc2FjdGlvbik7XG4gICAgICAgIGVycm9yVGhyb3duID0gZmFsc2U7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB1cGRhdGVEZXB0aC0tO1xuICAgICAgICBpZiAoIXVwZGF0ZURlcHRoKSB7XG4gICAgICAgICAgZXJyb3JUaHJvd24gPyBjbGVhclF1ZXVlKCkgOiBwcm9jZXNzUXVldWUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbXByb3ZlIHBlcmZvcm1hbmNlIGJ5IGlzb2xhdGluZyB0aGlzIGhvdCBjb2RlIHBhdGggZnJvbSB0aGUgdHJ5L2NhdGNoXG4gICAgICogYmxvY2sgaW4gYHVwZGF0ZUNoaWxkcmVuYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dE5lc3RlZENoaWxkcmVuIE5lc3RlZCBjaGlsZCBtYXBzLlxuICAgICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICAgKiBAZmluYWxcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3VwZGF0ZUNoaWxkcmVuOiBmdW5jdGlvbihuZXh0TmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uKSB7XG4gICAgICB2YXIgbmV4dENoaWxkcmVuID0gZmxhdHRlbkNoaWxkcmVuKG5leHROZXN0ZWRDaGlsZHJlbik7XG4gICAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5fcmVuZGVyZWRDaGlsZHJlbjtcbiAgICAgIGlmICghbmV4dENoaWxkcmVuICYmICFwcmV2Q2hpbGRyZW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG5hbWU7XG4gICAgICAvLyBgbmV4dEluZGV4YCB3aWxsIGluY3JlbWVudCBmb3IgZWFjaCBjaGlsZCBpbiBgbmV4dENoaWxkcmVuYCwgYnV0XG4gICAgICAvLyBgbGFzdEluZGV4YCB3aWxsIGJlIHRoZSBsYXN0IGluZGV4IHZpc2l0ZWQgaW4gYHByZXZDaGlsZHJlbmAuXG4gICAgICB2YXIgbGFzdEluZGV4ID0gMDtcbiAgICAgIHZhciBuZXh0SW5kZXggPSAwO1xuICAgICAgZm9yIChuYW1lIGluIG5leHRDaGlsZHJlbikge1xuICAgICAgICBpZiAoIW5leHRDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmV2Q2hpbGQgPSBwcmV2Q2hpbGRyZW4gJiYgcHJldkNoaWxkcmVuW25hbWVdO1xuICAgICAgICB2YXIgcHJldkRlc2NyaXB0b3IgPSBwcmV2Q2hpbGQgJiYgcHJldkNoaWxkLl9kZXNjcmlwdG9yO1xuICAgICAgICB2YXIgbmV4dERlc2NyaXB0b3IgPSBuZXh0Q2hpbGRyZW5bbmFtZV07XG4gICAgICAgIGlmIChzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudChwcmV2RGVzY3JpcHRvciwgbmV4dERlc2NyaXB0b3IpKSB7XG4gICAgICAgICAgdGhpcy5tb3ZlQ2hpbGQocHJldkNoaWxkLCBuZXh0SW5kZXgsIGxhc3RJbmRleCk7XG4gICAgICAgICAgbGFzdEluZGV4ID0gTWF0aC5tYXgocHJldkNoaWxkLl9tb3VudEluZGV4LCBsYXN0SW5kZXgpO1xuICAgICAgICAgIHByZXZDaGlsZC5yZWNlaXZlQ29tcG9uZW50KG5leHREZXNjcmlwdG9yLCB0cmFuc2FjdGlvbik7XG4gICAgICAgICAgcHJldkNoaWxkLl9tb3VudEluZGV4ID0gbmV4dEluZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChwcmV2Q2hpbGQpIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBgbGFzdEluZGV4YCBiZWZvcmUgYF9tb3VudEluZGV4YCBnZXRzIHVuc2V0IGJ5IHVubW91bnRpbmcuXG4gICAgICAgICAgICBsYXN0SW5kZXggPSBNYXRoLm1heChwcmV2Q2hpbGQuX21vdW50SW5kZXgsIGxhc3RJbmRleCk7XG4gICAgICAgICAgICB0aGlzLl91bm1vdW50Q2hpbGRCeU5hbWUocHJldkNoaWxkLCBuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gVGhlIGNoaWxkIG11c3QgYmUgaW5zdGFudGlhdGVkIGJlZm9yZSBpdCdzIG1vdW50ZWQuXG4gICAgICAgICAgdmFyIG5leHRDaGlsZEluc3RhbmNlID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChuZXh0RGVzY3JpcHRvcik7XG4gICAgICAgICAgdGhpcy5fbW91bnRDaGlsZEJ5TmFtZUF0SW5kZXgoXG4gICAgICAgICAgICBuZXh0Q2hpbGRJbnN0YW5jZSwgbmFtZSwgbmV4dEluZGV4LCB0cmFuc2FjdGlvblxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dEluZGV4Kys7XG4gICAgICB9XG4gICAgICAvLyBSZW1vdmUgY2hpbGRyZW4gdGhhdCBhcmUgbm8gbG9uZ2VyIHByZXNlbnQuXG4gICAgICBmb3IgKG5hbWUgaW4gcHJldkNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChwcmV2Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkgJiZcbiAgICAgICAgICAgICEobmV4dENoaWxkcmVuICYmIG5leHRDaGlsZHJlbltuYW1lXSkpIHtcbiAgICAgICAgICB0aGlzLl91bm1vdW50Q2hpbGRCeU5hbWUocHJldkNoaWxkcmVuW25hbWVdLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVbm1vdW50cyBhbGwgcmVuZGVyZWQgY2hpbGRyZW4uIFRoaXMgc2hvdWxkIGJlIHVzZWQgdG8gY2xlYW4gdXAgY2hpbGRyZW5cbiAgICAgKiB3aGVuIHRoaXMgY29tcG9uZW50IGlzIHVubW91bnRlZC5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHVubW91bnRDaGlsZHJlbjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVuZGVyZWRDaGlsZHJlbiA9IHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW47XG4gICAgICBmb3IgKHZhciBuYW1lIGluIHJlbmRlcmVkQ2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIHJlbmRlcmVkQ2hpbGQgPSByZW5kZXJlZENoaWxkcmVuW25hbWVdO1xuICAgICAgICAvLyBUT0RPOiBXaGVuIGlzIHRoaXMgbm90IHRydWU/XG4gICAgICAgIGlmIChyZW5kZXJlZENoaWxkLnVubW91bnRDb21wb25lbnQpIHtcbiAgICAgICAgICByZW5kZXJlZENoaWxkLnVubW91bnRDb21wb25lbnQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fcmVuZGVyZWRDaGlsZHJlbiA9IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vdmVzIGEgY2hpbGQgY29tcG9uZW50IHRvIHRoZSBzdXBwbGllZCBpbmRleC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNoaWxkIENvbXBvbmVudCB0byBtb3ZlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b0luZGV4IERlc3RpbmF0aW9uIGluZGV4IG9mIHRoZSBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYXN0SW5kZXggTGFzdCBpbmRleCB2aXNpdGVkIG9mIHRoZSBzaWJsaW5ncyBvZiBgY2hpbGRgLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBtb3ZlQ2hpbGQ6IGZ1bmN0aW9uKGNoaWxkLCB0b0luZGV4LCBsYXN0SW5kZXgpIHtcbiAgICAgIC8vIElmIHRoZSBpbmRleCBvZiBgY2hpbGRgIGlzIGxlc3MgdGhhbiBgbGFzdEluZGV4YCwgdGhlbiBpdCBuZWVkcyB0b1xuICAgICAgLy8gYmUgbW92ZWQuIE90aGVyd2lzZSwgd2UgZG8gbm90IG5lZWQgdG8gbW92ZSBpdCBiZWNhdXNlIGEgY2hpbGQgd2lsbCBiZVxuICAgICAgLy8gaW5zZXJ0ZWQgb3IgbW92ZWQgYmVmb3JlIGBjaGlsZGAuXG4gICAgICBpZiAoY2hpbGQuX21vdW50SW5kZXggPCBsYXN0SW5kZXgpIHtcbiAgICAgICAgZW5xdWV1ZU1vdmUodGhpcy5fcm9vdE5vZGVJRCwgY2hpbGQuX21vdW50SW5kZXgsIHRvSW5kZXgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2hpbGQgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY2hpbGQgQ29tcG9uZW50IHRvIGNyZWF0ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbW91bnRJbWFnZSBNYXJrdXAgdG8gaW5zZXJ0LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjcmVhdGVDaGlsZDogZnVuY3Rpb24oY2hpbGQsIG1vdW50SW1hZ2UpIHtcbiAgICAgIGVucXVldWVNYXJrdXAodGhpcy5fcm9vdE5vZGVJRCwgbW91bnRJbWFnZSwgY2hpbGQuX21vdW50SW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgY2hpbGQgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY2hpbGQgQ2hpbGQgdG8gcmVtb3ZlLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICByZW1vdmVDaGlsZDogZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIGVucXVldWVSZW1vdmUodGhpcy5fcm9vdE5vZGVJRCwgY2hpbGQuX21vdW50SW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoaXMgdGV4dCBjb250ZW50IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0Q29udGVudCBUZXh0IGNvbnRlbnQgdG8gc2V0LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZXRUZXh0Q29udGVudDogZnVuY3Rpb24odGV4dENvbnRlbnQpIHtcbiAgICAgIGVucXVldWVUZXh0Q29udGVudCh0aGlzLl9yb290Tm9kZUlELCB0ZXh0Q29udGVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vdW50cyBhIGNoaWxkIHdpdGggdGhlIHN1cHBsaWVkIG5hbWUuXG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGlzIGlzIHBhcnQgb2YgYHVwZGF0ZUNoaWxkcmVuYCBhbmQgaXMgaGVyZSBmb3IgcmVhZGFiaWxpdHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDb21wb25lbnQgdG8gbW91bnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgY2hpbGQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IGF0IHdoaWNoIHRvIGluc2VydCB0aGUgY2hpbGQuXG4gICAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21vdW50Q2hpbGRCeU5hbWVBdEluZGV4OiBmdW5jdGlvbihjaGlsZCwgbmFtZSwgaW5kZXgsIHRyYW5zYWN0aW9uKSB7XG4gICAgICAvLyBJbmxpbmVkIGZvciBwZXJmb3JtYW5jZSwgc2VlIGBSZWFjdEluc3RhbmNlSGFuZGxlcy5jcmVhdGVSZWFjdElEYC5cbiAgICAgIHZhciByb290SUQgPSB0aGlzLl9yb290Tm9kZUlEICsgbmFtZTtcbiAgICAgIHZhciBtb3VudEltYWdlID0gY2hpbGQubW91bnRDb21wb25lbnQoXG4gICAgICAgIHJvb3RJRCxcbiAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICAgIHRoaXMuX21vdW50RGVwdGggKyAxXG4gICAgICApO1xuICAgICAgY2hpbGQuX21vdW50SW5kZXggPSBpbmRleDtcbiAgICAgIHRoaXMuY3JlYXRlQ2hpbGQoY2hpbGQsIG1vdW50SW1hZ2UpO1xuICAgICAgdGhpcy5fcmVuZGVyZWRDaGlsZHJlbiA9IHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW4gfHwge307XG4gICAgICB0aGlzLl9yZW5kZXJlZENoaWxkcmVuW25hbWVdID0gY2hpbGQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVubW91bnRzIGEgcmVuZGVyZWQgY2hpbGQgYnkgbmFtZS5cbiAgICAgKlxuICAgICAqIE5PVEU6IFRoaXMgaXMgcGFydCBvZiBgdXBkYXRlQ2hpbGRyZW5gIGFuZCBpcyBoZXJlIGZvciByZWFkYWJpbGl0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNoaWxkIENvbXBvbmVudCB0byB1bm1vdW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIGNoaWxkIGluIGB0aGlzLl9yZW5kZXJlZENoaWxkcmVuYC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91bm1vdW50Q2hpbGRCeU5hbWU6IGZ1bmN0aW9uKGNoaWxkLCBuYW1lKSB7XG4gICAgICB0aGlzLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICAgIGNoaWxkLl9tb3VudEluZGV4ID0gbnVsbDtcbiAgICAgIGNoaWxkLnVubW91bnRDb21wb25lbnQoKTtcbiAgICAgIGRlbGV0ZSB0aGlzLl9yZW5kZXJlZENoaWxkcmVuW25hbWVdO1xuICAgIH1cblxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RNdWx0aUNoaWxkO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBrZXlNaXJyb3IgPSByZXF1aXJlKFwiLi9rZXlNaXJyb3JcIik7XG5cbi8qKlxuICogV2hlbiBhIGNvbXBvbmVudCdzIGNoaWxkcmVuIGFyZSB1cGRhdGVkLCBhIHNlcmllcyBvZiB1cGRhdGUgY29uZmlndXJhdGlvblxuICogb2JqZWN0cyBhcmUgY3JlYXRlZCBpbiBvcmRlciB0byBiYXRjaCBhbmQgc2VyaWFsaXplIHRoZSByZXF1aXJlZCBjaGFuZ2VzLlxuICpcbiAqIEVudW1lcmF0ZXMgYWxsIHRoZSBwb3NzaWJsZSB0eXBlcyBvZiB1cGRhdGUgY29uZmlndXJhdGlvbnMuXG4gKlxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcyA9IGtleU1pcnJvcih7XG4gIElOU0VSVF9NQVJLVVA6IG51bGwsXG4gIE1PVkVfRVhJU1RJTkc6IG51bGwsXG4gIFJFTU9WRV9OT0RFOiBudWxsLFxuICBURVhUX0NPTlRFTlQ6IG51bGxcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzO1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE93bmVyXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoXCIuL2VtcHR5T2JqZWN0XCIpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcblxuLyoqXG4gKiBSZWFjdE93bmVycyBhcmUgY2FwYWJsZSBvZiBzdG9yaW5nIHJlZmVyZW5jZXMgdG8gb3duZWQgY29tcG9uZW50cy5cbiAqXG4gKiBBbGwgY29tcG9uZW50cyBhcmUgY2FwYWJsZSBvZiAvL2JlaW5nLy8gcmVmZXJlbmNlZCBieSBvd25lciBjb21wb25lbnRzLCBidXRcbiAqIG9ubHkgUmVhY3RPd25lciBjb21wb25lbnRzIGFyZSBjYXBhYmxlIG9mIC8vcmVmZXJlbmNpbmcvLyBvd25lZCBjb21wb25lbnRzLlxuICogVGhlIG5hbWVkIHJlZmVyZW5jZSBpcyBrbm93biBhcyBhIFwicmVmXCIuXG4gKlxuICogUmVmcyBhcmUgYXZhaWxhYmxlIHdoZW4gbW91bnRlZCBhbmQgdXBkYXRlZCBkdXJpbmcgcmVjb25jaWxpYXRpb24uXG4gKlxuICogICB2YXIgTXlDb21wb25lbnQgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAqICAgICAgIHJldHVybiAoXG4gKiAgICAgICAgIDxkaXYgb25DbGljaz17dGhpcy5oYW5kbGVDbGlja30+XG4gKiAgICAgICAgICAgPEN1c3RvbUNvbXBvbmVudCByZWY9XCJjdXN0b21cIiAvPlxuICogICAgICAgICA8L2Rpdj5cbiAqICAgICAgICk7XG4gKiAgICAgfSxcbiAqICAgICBoYW5kbGVDbGljazogZnVuY3Rpb24oKSB7XG4gKiAgICAgICB0aGlzLnJlZnMuY3VzdG9tLmhhbmRsZUNsaWNrKCk7XG4gKiAgICAgfSxcbiAqICAgICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24oKSB7XG4gKiAgICAgICB0aGlzLnJlZnMuY3VzdG9tLmluaXRpYWxpemUoKTtcbiAqICAgICB9XG4gKiAgIH0pO1xuICpcbiAqIFJlZnMgc2hvdWxkIHJhcmVseSBiZSB1c2VkLiBXaGVuIHJlZnMgYXJlIHVzZWQsIHRoZXkgc2hvdWxkIG9ubHkgYmUgZG9uZSB0b1xuICogY29udHJvbCBkYXRhIHRoYXQgaXMgbm90IGhhbmRsZWQgYnkgUmVhY3QncyBkYXRhIGZsb3cuXG4gKlxuICogQGNsYXNzIFJlYWN0T3duZXJcbiAqL1xudmFyIFJlYWN0T3duZXIgPSB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSB2YWxpZCBvd25lci5cbiAgICogQGZpbmFsXG4gICAqL1xuICBpc1ZhbGlkT3duZXI6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiAhIShcbiAgICAgIG9iamVjdCAmJlxuICAgICAgdHlwZW9mIG9iamVjdC5hdHRhY2hSZWYgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIHR5cGVvZiBvYmplY3QuZGV0YWNoUmVmID09PSAnZnVuY3Rpb24nXG4gICAgKTtcbiAgfSxcblxuICAvKipcbiAgICogQWRkcyBhIGNvbXBvbmVudCBieSByZWYgdG8gYW4gb3duZXIgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnQgQ29tcG9uZW50IHRvIHJlZmVyZW5jZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZiBOYW1lIGJ5IHdoaWNoIHRvIHJlZmVyIHRvIHRoZSBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7UmVhY3RPd25lcn0gb3duZXIgQ29tcG9uZW50IG9uIHdoaWNoIHRvIHJlY29yZCB0aGUgcmVmLlxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICBhZGRDb21wb25lbnRBc1JlZlRvOiBmdW5jdGlvbihjb21wb25lbnQsIHJlZiwgb3duZXIpIHtcbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgUmVhY3RPd25lci5pc1ZhbGlkT3duZXIob3duZXIpLFxuICAgICAgJ2FkZENvbXBvbmVudEFzUmVmVG8oLi4uKTogT25seSBhIFJlYWN0T3duZXIgY2FuIGhhdmUgcmVmcy4gVGhpcyAnICtcbiAgICAgICd1c3VhbGx5IG1lYW5zIHRoYXQgeW91XFwncmUgdHJ5aW5nIHRvIGFkZCBhIHJlZiB0byBhIGNvbXBvbmVudCB0aGF0ICcgK1xuICAgICAgJ2RvZXNuXFwndCBoYXZlIGFuIG93bmVyICh0aGF0IGlzLCB3YXMgbm90IGNyZWF0ZWQgaW5zaWRlIG9mIGFub3RoZXIgJyArXG4gICAgICAnY29tcG9uZW50XFwncyBgcmVuZGVyYCBtZXRob2QpLiBUcnkgcmVuZGVyaW5nIHRoaXMgY29tcG9uZW50IGluc2lkZSBvZiAnICtcbiAgICAgICdhIG5ldyB0b3AtbGV2ZWwgY29tcG9uZW50IHdoaWNoIHdpbGwgaG9sZCB0aGUgcmVmLidcbiAgICApIDogaW52YXJpYW50KFJlYWN0T3duZXIuaXNWYWxpZE93bmVyKG93bmVyKSkpO1xuICAgIG93bmVyLmF0dGFjaFJlZihyZWYsIGNvbXBvbmVudCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjb21wb25lbnQgYnkgcmVmIGZyb20gYW4gb3duZXIgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnQgQ29tcG9uZW50IHRvIGRlcmVmZXJlbmNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmIE5hbWUgb2YgdGhlIHJlZiB0byByZW1vdmUuXG4gICAqIEBwYXJhbSB7UmVhY3RPd25lcn0gb3duZXIgQ29tcG9uZW50IG9uIHdoaWNoIHRoZSByZWYgaXMgcmVjb3JkZWQuXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHJlbW92ZUNvbXBvbmVudEFzUmVmRnJvbTogZnVuY3Rpb24oY29tcG9uZW50LCByZWYsIG93bmVyKSB7XG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgIFJlYWN0T3duZXIuaXNWYWxpZE93bmVyKG93bmVyKSxcbiAgICAgICdyZW1vdmVDb21wb25lbnRBc1JlZkZyb20oLi4uKTogT25seSBhIFJlYWN0T3duZXIgY2FuIGhhdmUgcmVmcy4gVGhpcyAnICtcbiAgICAgICd1c3VhbGx5IG1lYW5zIHRoYXQgeW91XFwncmUgdHJ5aW5nIHRvIHJlbW92ZSBhIHJlZiB0byBhIGNvbXBvbmVudCB0aGF0ICcgK1xuICAgICAgJ2RvZXNuXFwndCBoYXZlIGFuIG93bmVyICh0aGF0IGlzLCB3YXMgbm90IGNyZWF0ZWQgaW5zaWRlIG9mIGFub3RoZXIgJyArXG4gICAgICAnY29tcG9uZW50XFwncyBgcmVuZGVyYCBtZXRob2QpLiBUcnkgcmVuZGVyaW5nIHRoaXMgY29tcG9uZW50IGluc2lkZSBvZiAnICtcbiAgICAgICdhIG5ldyB0b3AtbGV2ZWwgY29tcG9uZW50IHdoaWNoIHdpbGwgaG9sZCB0aGUgcmVmLidcbiAgICApIDogaW52YXJpYW50KFJlYWN0T3duZXIuaXNWYWxpZE93bmVyKG93bmVyKSkpO1xuICAgIC8vIENoZWNrIHRoYXQgYGNvbXBvbmVudGAgaXMgc3RpbGwgdGhlIGN1cnJlbnQgcmVmIGJlY2F1c2Ugd2UgZG8gbm90IHdhbnQgdG9cbiAgICAvLyBkZXRhY2ggdGhlIHJlZiBpZiBhbm90aGVyIGNvbXBvbmVudCBzdG9sZSBpdC5cbiAgICBpZiAob3duZXIucmVmc1tyZWZdID09PSBjb21wb25lbnQpIHtcbiAgICAgIG93bmVyLmRldGFjaFJlZihyZWYpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQSBSZWFjdENvbXBvbmVudCBtdXN0IG1peCB0aGlzIGluIHRvIGhhdmUgcmVmcy5cbiAgICpcbiAgICogQGxlbmRzIHtSZWFjdE93bmVyLnByb3RvdHlwZX1cbiAgICovXG4gIE1peGluOiB7XG5cbiAgICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIExhemlseSBhbGxvY2F0ZXMgdGhlIHJlZnMgb2JqZWN0IGFuZCBzdG9yZXMgYGNvbXBvbmVudGAgYXMgYHJlZmAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmIFJlZmVyZW5jZSBuYW1lLlxuICAgICAqIEBwYXJhbSB7Y29tcG9uZW50fSBjb21wb25lbnQgQ29tcG9uZW50IHRvIHN0b3JlIGFzIGByZWZgLlxuICAgICAqIEBmaW5hbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYXR0YWNoUmVmOiBmdW5jdGlvbihyZWYsIGNvbXBvbmVudCkge1xuICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICAgY29tcG9uZW50LmlzT3duZWRCeSh0aGlzKSxcbiAgICAgICAgJ2F0dGFjaFJlZiglcywgLi4uKTogT25seSBhIGNvbXBvbmVudFxcJ3Mgb3duZXIgY2FuIHN0b3JlIGEgcmVmIHRvIGl0LicsXG4gICAgICAgIHJlZlxuICAgICAgKSA6IGludmFyaWFudChjb21wb25lbnQuaXNPd25lZEJ5KHRoaXMpKSk7XG4gICAgICB2YXIgcmVmcyA9IHRoaXMucmVmcyA9PT0gZW1wdHlPYmplY3QgPyAodGhpcy5yZWZzID0ge30pIDogdGhpcy5yZWZzO1xuICAgICAgcmVmc1tyZWZdID0gY29tcG9uZW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXRhY2hlcyBhIHJlZmVyZW5jZSBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJlZiBOYW1lIHRvIGRlcmVmZXJlbmNlLlxuICAgICAqIEBmaW5hbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZGV0YWNoUmVmOiBmdW5jdGlvbihyZWYpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLnJlZnNbcmVmXTtcbiAgICB9XG5cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0T3duZXI7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RQZXJmXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFJlYWN0UGVyZiBpcyBhIGdlbmVyYWwgQU9QIHN5c3RlbSBkZXNpZ25lZCB0byBtZWFzdXJlIHBlcmZvcm1hbmNlLiBUaGlzXG4gKiBtb2R1bGUgb25seSBoYXMgdGhlIGhvb2tzOiBzZWUgUmVhY3REZWZhdWx0UGVyZiBmb3IgdGhlIGFuYWx5c2lzIHRvb2wuXG4gKi9cbnZhciBSZWFjdFBlcmYgPSB7XG4gIC8qKlxuICAgKiBCb29sZWFuIHRvIGVuYWJsZS9kaXNhYmxlIG1lYXN1cmVtZW50LiBTZXQgdG8gZmFsc2UgYnkgZGVmYXVsdCB0byBwcmV2ZW50XG4gICAqIGFjY2lkZW50YWwgbG9nZ2luZyBhbmQgcGVyZiBsb3NzLlxuICAgKi9cbiAgZW5hYmxlTWVhc3VyZTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEhvbGRzIG9udG8gdGhlIG1lYXN1cmUgZnVuY3Rpb24gaW4gdXNlLiBCeSBkZWZhdWx0LCBkb24ndCBtZWFzdXJlXG4gICAqIGFueXRoaW5nLCBidXQgd2UnbGwgb3ZlcnJpZGUgdGhpcyBpZiB3ZSBpbmplY3QgYSBtZWFzdXJlIGZ1bmN0aW9uLlxuICAgKi9cbiAgc3RvcmVkTWVhc3VyZTogX25vTWVhc3VyZSxcblxuICAvKipcbiAgICogVXNlIHRoaXMgdG8gd3JhcCBtZXRob2RzIHlvdSB3YW50IHRvIG1lYXN1cmUuIFplcm8gb3ZlcmhlYWQgaW4gcHJvZHVjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9iak5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZuTmFtZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9ufVxuICAgKi9cbiAgbWVhc3VyZTogZnVuY3Rpb24ob2JqTmFtZSwgZm5OYW1lLCBmdW5jKSB7XG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgdmFyIG1lYXN1cmVkRnVuYyA9IG51bGw7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChSZWFjdFBlcmYuZW5hYmxlTWVhc3VyZSkge1xuICAgICAgICAgIGlmICghbWVhc3VyZWRGdW5jKSB7XG4gICAgICAgICAgICBtZWFzdXJlZEZ1bmMgPSBSZWFjdFBlcmYuc3RvcmVkTWVhc3VyZShvYmpOYW1lLCBmbk5hbWUsIGZ1bmMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWVhc3VyZWRGdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBmdW5jO1xuICB9LFxuXG4gIGluamVjdGlvbjoge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IG1lYXN1cmVcbiAgICAgKi9cbiAgICBpbmplY3RNZWFzdXJlOiBmdW5jdGlvbihtZWFzdXJlKSB7XG4gICAgICBSZWFjdFBlcmYuc3RvcmVkTWVhc3VyZSA9IG1lYXN1cmU7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFNpbXBseSBwYXNzZXMgdGhyb3VnaCB0aGUgbWVhc3VyZWQgZnVuY3Rpb24sIHdpdGhvdXQgbWVhc3VyaW5nIGl0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBvYmpOYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gZm5OYW1lXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gX25vTWVhc3VyZShvYmpOYW1lLCBmbk5hbWUsIGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQZXJmO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UHJvcFRyYW5zZmVyZXJcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKFwiLi9lbXB0eUZ1bmN0aW9uXCIpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcbnZhciBqb2luQ2xhc3NlcyA9IHJlcXVpcmUoXCIuL2pvaW5DbGFzc2VzXCIpO1xudmFyIG1lcmdlID0gcmVxdWlyZShcIi4vbWVyZ2VcIik7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHRyYW5zZmVyIHN0cmF0ZWd5IHRoYXQgd2lsbCBtZXJnZSBwcm9wIHZhbHVlcyB1c2luZyB0aGUgc3VwcGxpZWRcbiAqIGBtZXJnZVN0cmF0ZWd5YC4gSWYgYSBwcm9wIHdhcyBwcmV2aW91c2x5IHVuc2V0LCB0aGlzIGp1c3Qgc2V0cyBpdC5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBtZXJnZVN0cmF0ZWd5XG4gKiBAcmV0dXJuIHtmdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVHJhbnNmZXJTdHJhdGVneShtZXJnZVN0cmF0ZWd5KSB7XG4gIHJldHVybiBmdW5jdGlvbihwcm9wcywga2V5LCB2YWx1ZSkge1xuICAgIGlmICghcHJvcHMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgcHJvcHNba2V5XSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9wc1trZXldID0gbWVyZ2VTdHJhdGVneShwcm9wc1trZXldLCB2YWx1ZSk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgdHJhbnNmZXJTdHJhdGVneU1lcmdlID0gY3JlYXRlVHJhbnNmZXJTdHJhdGVneShmdW5jdGlvbihhLCBiKSB7XG4gIC8vIGBtZXJnZWAgb3ZlcnJpZGVzIHRoZSBmaXJzdCBvYmplY3QncyAoYHByb3BzW2tleV1gIGFib3ZlKSBrZXlzIHVzaW5nIHRoZVxuICAvLyBzZWNvbmQgb2JqZWN0J3MgKGB2YWx1ZWApIGtleXMuIEFuIG9iamVjdCdzIHN0eWxlJ3MgZXhpc3RpbmcgYHByb3BBYCB3b3VsZFxuICAvLyBnZXQgb3ZlcnJpZGRlbi4gRmxpcCB0aGUgb3JkZXIgaGVyZS5cbiAgcmV0dXJuIG1lcmdlKGIsIGEpO1xufSk7XG5cbi8qKlxuICogVHJhbnNmZXIgc3RyYXRlZ2llcyBkaWN0YXRlIGhvdyBwcm9wcyBhcmUgdHJhbnNmZXJyZWQgYnkgYHRyYW5zZmVyUHJvcHNUb2AuXG4gKiBOT1RFOiBpZiB5b3UgYWRkIGFueSBtb3JlIGV4Y2VwdGlvbnMgdG8gdGhpcyBsaXN0IHlvdSBzaG91bGQgYmUgc3VyZSB0b1xuICogdXBkYXRlIGBjbG9uZVdpdGhQcm9wcygpYCBhY2NvcmRpbmdseS5cbiAqL1xudmFyIFRyYW5zZmVyU3RyYXRlZ2llcyA9IHtcbiAgLyoqXG4gICAqIE5ldmVyIHRyYW5zZmVyIGBjaGlsZHJlbmAuXG4gICAqL1xuICBjaGlsZHJlbjogZW1wdHlGdW5jdGlvbixcbiAgLyoqXG4gICAqIFRyYW5zZmVyIHRoZSBgY2xhc3NOYW1lYCBwcm9wIGJ5IG1lcmdpbmcgdGhlbS5cbiAgICovXG4gIGNsYXNzTmFtZTogY3JlYXRlVHJhbnNmZXJTdHJhdGVneShqb2luQ2xhc3NlcyksXG4gIC8qKlxuICAgKiBOZXZlciB0cmFuc2ZlciB0aGUgYGtleWAgcHJvcC5cbiAgICovXG4gIGtleTogZW1wdHlGdW5jdGlvbixcbiAgLyoqXG4gICAqIE5ldmVyIHRyYW5zZmVyIHRoZSBgcmVmYCBwcm9wLlxuICAgKi9cbiAgcmVmOiBlbXB0eUZ1bmN0aW9uLFxuICAvKipcbiAgICogVHJhbnNmZXIgdGhlIGBzdHlsZWAgcHJvcCAod2hpY2ggaXMgYW4gb2JqZWN0KSBieSBtZXJnaW5nIHRoZW0uXG4gICAqL1xuICBzdHlsZTogdHJhbnNmZXJTdHJhdGVneU1lcmdlXG59O1xuXG4vKipcbiAqIE11dGF0ZXMgdGhlIGZpcnN0IGFyZ3VtZW50IGJ5IHRyYW5zZmVycmluZyB0aGUgcHJvcGVydGllcyBmcm9tIHRoZSBzZWNvbmRcbiAqIGFyZ3VtZW50LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICogQHBhcmFtIHtvYmplY3R9IG5ld1Byb3BzXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIHRyYW5zZmVySW50byhwcm9wcywgbmV3UHJvcHMpIHtcbiAgZm9yICh2YXIgdGhpc0tleSBpbiBuZXdQcm9wcykge1xuICAgIGlmICghbmV3UHJvcHMuaGFzT3duUHJvcGVydHkodGhpc0tleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciB0cmFuc2ZlclN0cmF0ZWd5ID0gVHJhbnNmZXJTdHJhdGVnaWVzW3RoaXNLZXldO1xuXG4gICAgaWYgKHRyYW5zZmVyU3RyYXRlZ3kgJiYgVHJhbnNmZXJTdHJhdGVnaWVzLmhhc093blByb3BlcnR5KHRoaXNLZXkpKSB7XG4gICAgICB0cmFuc2ZlclN0cmF0ZWd5KHByb3BzLCB0aGlzS2V5LCBuZXdQcm9wc1t0aGlzS2V5XSk7XG4gICAgfSBlbHNlIGlmICghcHJvcHMuaGFzT3duUHJvcGVydHkodGhpc0tleSkpIHtcbiAgICAgIHByb3BzW3RoaXNLZXldID0gbmV3UHJvcHNbdGhpc0tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBwcm9wcztcbn1cblxuLyoqXG4gKiBSZWFjdFByb3BUcmFuc2ZlcmVyIGFyZSBjYXBhYmxlIG9mIHRyYW5zZmVycmluZyBwcm9wcyB0byBhbm90aGVyIGNvbXBvbmVudFxuICogdXNpbmcgYSBgdHJhbnNmZXJQcm9wc1RvYCBtZXRob2QuXG4gKlxuICogQGNsYXNzIFJlYWN0UHJvcFRyYW5zZmVyZXJcbiAqL1xudmFyIFJlYWN0UHJvcFRyYW5zZmVyZXIgPSB7XG5cbiAgVHJhbnNmZXJTdHJhdGVnaWVzOiBUcmFuc2ZlclN0cmF0ZWdpZXMsXG5cbiAgLyoqXG4gICAqIE1lcmdlIHR3byBwcm9wcyBvYmplY3RzIHVzaW5nIFRyYW5zZmVyU3RyYXRlZ2llcy5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG9sZFByb3BzIG9yaWdpbmFsIHByb3BzICh0aGV5IHRha2UgcHJlY2VkZW5jZSlcbiAgICogQHBhcmFtIHtvYmplY3R9IG5ld1Byb3BzIG5ldyBwcm9wcyB0byBtZXJnZSBpblxuICAgKiBAcmV0dXJuIHtvYmplY3R9IGEgbmV3IG9iamVjdCBjb250YWluaW5nIGJvdGggc2V0cyBvZiBwcm9wcyBtZXJnZWQuXG4gICAqL1xuICBtZXJnZVByb3BzOiBmdW5jdGlvbihvbGRQcm9wcywgbmV3UHJvcHMpIHtcbiAgICByZXR1cm4gdHJhbnNmZXJJbnRvKG1lcmdlKG9sZFByb3BzKSwgbmV3UHJvcHMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAbGVuZHMge1JlYWN0UHJvcFRyYW5zZmVyZXIucHJvdG90eXBlfVxuICAgKi9cbiAgTWl4aW46IHtcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZmVyIHByb3BzIGZyb20gdGhpcyBjb21wb25lbnQgdG8gYSB0YXJnZXQgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogUHJvcHMgdGhhdCBkbyBub3QgaGF2ZSBhbiBleHBsaWNpdCB0cmFuc2ZlciBzdHJhdGVneSB3aWxsIGJlIHRyYW5zZmVycmVkXG4gICAgICogb25seSBpZiB0aGUgdGFyZ2V0IGNvbXBvbmVudCBkb2VzIG5vdCBhbHJlYWR5IGhhdmUgdGhlIHByb3Agc2V0LlxuICAgICAqXG4gICAgICogVGhpcyBpcyB1c3VhbGx5IHVzZWQgdG8gcGFzcyBkb3duIHByb3BzIHRvIGEgcmV0dXJuZWQgcm9vdCBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0RGVzY3JpcHRvcn0gZGVzY3JpcHRvciBDb21wb25lbnQgcmVjZWl2aW5nIHRoZSBwcm9wZXJ0aWVzLlxuICAgICAqIEByZXR1cm4ge1JlYWN0RGVzY3JpcHRvcn0gVGhlIHN1cHBsaWVkIGBjb21wb25lbnRgLlxuICAgICAqIEBmaW5hbFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB0cmFuc2ZlclByb3BzVG86IGZ1bmN0aW9uKGRlc2NyaXB0b3IpIHtcbiAgICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAgIGRlc2NyaXB0b3IuX293bmVyID09PSB0aGlzLFxuICAgICAgICAnJXM6IFlvdSBjYW5cXCd0IGNhbGwgdHJhbnNmZXJQcm9wc1RvKCkgb24gYSBjb21wb25lbnQgdGhhdCB5b3UgJyArXG4gICAgICAgICdkb25cXCd0IG93biwgJXMuIFRoaXMgdXN1YWxseSBtZWFucyB5b3UgYXJlIGNhbGxpbmcgJyArXG4gICAgICAgICd0cmFuc2ZlclByb3BzVG8oKSBvbiBhIGNvbXBvbmVudCBwYXNzZWQgaW4gYXMgcHJvcHMgb3IgY2hpbGRyZW4uJyxcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSxcbiAgICAgICAgZGVzY3JpcHRvci50eXBlLmRpc3BsYXlOYW1lXG4gICAgICApIDogaW52YXJpYW50KGRlc2NyaXB0b3IuX293bmVyID09PSB0aGlzKSk7XG5cbiAgICAgIC8vIEJlY2F1c2UgZGVzY3JpcHRvcnMgYXJlIGltbXV0YWJsZSB3ZSBoYXZlIHRvIG1lcmdlIGludG8gdGhlIGV4aXN0aW5nXG4gICAgICAvLyBwcm9wcyBvYmplY3QgcmF0aGVyIHRoYW4gY2xvbmUgaXQuXG4gICAgICB0cmFuc2ZlckludG8oZGVzY3JpcHRvci5wcm9wcywgdGhpcy5wcm9wcyk7XG5cbiAgICAgIHJldHVybiBkZXNjcmlwdG9yO1xuICAgIH1cblxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFRyYW5zZmVyZXI7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0ge307XG5cbmlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSB7XG4gICAgcHJvcDogJ3Byb3AnLFxuICAgIGNvbnRleHQ6ICdjb250ZXh0JyxcbiAgICBjaGlsZENvbnRleHQ6ICdjaGlsZCBjb250ZXh0J1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RQcm9wVHlwZUxvY2F0aW9uc1xuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIga2V5TWlycm9yID0gcmVxdWlyZShcIi4va2V5TWlycm9yXCIpO1xuXG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucyA9IGtleU1pcnJvcih7XG4gIHByb3A6IG51bGwsXG4gIGNvbnRleHQ6IG51bGwsXG4gIGNoaWxkQ29udGV4dDogbnVsbFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9ucztcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFByb3BUeXBlc1xuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgUmVhY3REZXNjcmlwdG9yID0gcmVxdWlyZShcIi4vUmVhY3REZXNjcmlwdG9yXCIpO1xudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0gcmVxdWlyZShcIi4vUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNcIik7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZShcIi4vZW1wdHlGdW5jdGlvblwiKTtcblxuLyoqXG4gKiBDb2xsZWN0aW9uIG9mIG1ldGhvZHMgdGhhdCBhbGxvdyBkZWNsYXJhdGlvbiBhbmQgdmFsaWRhdGlvbiBvZiBwcm9wcyB0aGF0IGFyZVxuICogc3VwcGxpZWQgdG8gUmVhY3QgY29tcG9uZW50cy4gRXhhbXBsZSB1c2FnZTpcbiAqXG4gKiAgIHZhciBQcm9wcyA9IHJlcXVpcmUoJ1JlYWN0UHJvcFR5cGVzJyk7XG4gKiAgIHZhciBNeUFydGljbGUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gKiAgICAgcHJvcFR5cGVzOiB7XG4gKiAgICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgcHJvcCBuYW1lZCBcImRlc2NyaXB0aW9uXCIuXG4gKiAgICAgICBkZXNjcmlwdGlvbjogUHJvcHMuc3RyaW5nLFxuICpcbiAqICAgICAgIC8vIEEgcmVxdWlyZWQgZW51bSBwcm9wIG5hbWVkIFwiY2F0ZWdvcnlcIi5cbiAqICAgICAgIGNhdGVnb3J5OiBQcm9wcy5vbmVPZihbJ05ld3MnLCdQaG90b3MnXSkuaXNSZXF1aXJlZCxcbiAqXG4gKiAgICAgICAvLyBBIHByb3AgbmFtZWQgXCJkaWFsb2dcIiB0aGF0IHJlcXVpcmVzIGFuIGluc3RhbmNlIG9mIERpYWxvZy5cbiAqICAgICAgIGRpYWxvZzogUHJvcHMuaW5zdGFuY2VPZihEaWFsb2cpLmlzUmVxdWlyZWRcbiAqICAgICB9LFxuICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7IC4uLiB9XG4gKiAgIH0pO1xuICpcbiAqIEEgbW9yZSBmb3JtYWwgc3BlY2lmaWNhdGlvbiBvZiBob3cgdGhlc2UgbWV0aG9kcyBhcmUgdXNlZDpcbiAqXG4gKiAgIHR5cGUgOj0gYXJyYXl8Ym9vbHxmdW5jfG9iamVjdHxudW1iZXJ8c3RyaW5nfG9uZU9mKFsuLi5dKXxpbnN0YW5jZU9mKC4uLilcbiAqICAgZGVjbCA6PSBSZWFjdFByb3BUeXBlcy57dHlwZX0oLmlzUmVxdWlyZWQpP1xuICpcbiAqIEVhY2ggYW5kIGV2ZXJ5IGRlY2xhcmF0aW9uIHByb2R1Y2VzIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBzaWduYXR1cmUuIFRoaXNcbiAqIGFsbG93cyB0aGUgY3JlYXRpb24gb2YgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb25zLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgdmFyIE15TGluayA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAqICAgIHByb3BUeXBlczoge1xuICogICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgb3IgVVJJIHByb3AgbmFtZWQgXCJocmVmXCIuXG4gKiAgICAgIGhyZWY6IGZ1bmN0aW9uKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICogICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gKiAgICAgICAgaWYgKHByb3BWYWx1ZSAhPSBudWxsICYmIHR5cGVvZiBwcm9wVmFsdWUgIT09ICdzdHJpbmcnICYmXG4gKiAgICAgICAgICAgICEocHJvcFZhbHVlIGluc3RhbmNlb2YgVVJJKSkge1xuICogICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAqICAgICAgICAgICAgJ0V4cGVjdGVkIGEgc3RyaW5nIG9yIGFuIFVSSSBmb3IgJyArIHByb3BOYW1lICsgJyBpbiAnICtcbiAqICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICogICAgICAgICAgKTtcbiAqICAgICAgICB9XG4gKiAgICAgIH1cbiAqICAgIH0sXG4gKiAgICByZW5kZXI6IGZ1bmN0aW9uKCkgey4uLn1cbiAqICB9KTtcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG52YXIgQU5PTllNT1VTID0gJzw8YW5vbnltb3VzPj4nO1xuXG52YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gIGFycmF5OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYXJyYXknKSxcbiAgYm9vbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Jvb2xlYW4nKSxcbiAgZnVuYzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Z1bmN0aW9uJyksXG4gIG51bWJlcjogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ251bWJlcicpLFxuICBvYmplY3Q6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdvYmplY3QnKSxcbiAgc3RyaW5nOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3RyaW5nJyksXG5cbiAgYW55OiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpLFxuICBhcnJheU9mOiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIsXG4gIGNvbXBvbmVudDogY3JlYXRlQ29tcG9uZW50VHlwZUNoZWNrZXIoKSxcbiAgaW5zdGFuY2VPZjogY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcixcbiAgb2JqZWN0T2Y6IGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIsXG4gIG9uZU9mOiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIsXG4gIG9uZU9mVHlwZTogY3JlYXRlVW5pb25UeXBlQ2hlY2tlcixcbiAgcmVuZGVyYWJsZTogY3JlYXRlUmVuZGVyYWJsZVR5cGVDaGVja2VyKCksXG4gIHNoYXBlOiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICBmdW5jdGlvbiBjaGVja1R5cGUoaXNSZXF1aXJlZCwgcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbikge1xuICAgIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnROYW1lIHx8IEFOT05ZTU9VUztcbiAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICBpZiAoaXNSZXF1aXJlZCkge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgICAgICAgIChcIlJlcXVpcmVkIFwiICsgbG9jYXRpb25OYW1lICsgXCIgYFwiICsgcHJvcE5hbWUgKyBcImAgd2FzIG5vdCBzcGVjaWZpZWQgaW4gXCIpK1xuICAgICAgICAgIChcImBcIiArIGNvbXBvbmVudE5hbWUgKyBcImAuXCIpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uKTtcbiAgICB9XG4gIH1cblxuICB2YXIgY2hhaW5lZENoZWNrVHlwZSA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIGZhbHNlKTtcbiAgY2hhaW5lZENoZWNrVHlwZS5pc1JlcXVpcmVkID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgdHJ1ZSk7XG5cbiAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKGV4cGVjdGVkVHlwZSkge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uKSB7XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSAhPT0gZXhwZWN0ZWRUeXBlKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgLy8gYHByb3BWYWx1ZWAgYmVpbmcgaW5zdGFuY2Ugb2YsIHNheSwgZGF0ZS9yZWdleHAsIHBhc3MgdGhlICdvYmplY3QnXG4gICAgICAvLyBjaGVjaywgYnV0IHdlIGNhbiBvZmZlciBhIG1vcmUgcHJlY2lzZSBlcnJvciBtZXNzYWdlIGhlcmUgcmF0aGVyIHRoYW5cbiAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgIHZhciBwcmVjaXNlVHlwZSA9IGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSk7XG5cbiAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAgICAgIChcIkludmFsaWQgXCIgKyBsb2NhdGlvbk5hbWUgKyBcIiBgXCIgKyBwcm9wTmFtZSArIFwiYCBvZiB0eXBlIGBcIiArIHByZWNpc2VUeXBlICsgXCJgIFwiKSArXG4gICAgICAgIChcInN1cHBsaWVkIHRvIGBcIiArIGNvbXBvbmVudE5hbWUgKyBcImAsIGV4cGVjdGVkIGBcIiArIGV4cGVjdGVkVHlwZSArIFwiYC5cIilcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJucygpKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24pIHtcbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAgICAgIChcIkludmFsaWQgXCIgKyBsb2NhdGlvbk5hbWUgKyBcIiBgXCIgKyBwcm9wTmFtZSArIFwiYCBvZiB0eXBlIFwiKSArXG4gICAgICAgIChcImBcIiArIHByb3BUeXBlICsgXCJgIHN1cHBsaWVkIHRvIGBcIiArIGNvbXBvbmVudE5hbWUgKyBcImAsIGV4cGVjdGVkIGFuIGFycmF5LlwiKVxuICAgICAgKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24pO1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnRUeXBlQ2hlY2tlcigpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbikge1xuICAgIGlmICghUmVhY3REZXNjcmlwdG9yLmlzVmFsaWREZXNjcmlwdG9yKHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgICAgICAoXCJJbnZhbGlkIFwiICsgbG9jYXRpb25OYW1lICsgXCIgYFwiICsgcHJvcE5hbWUgKyBcImAgc3VwcGxpZWQgdG8gXCIpICtcbiAgICAgICAgKFwiYFwiICsgY29tcG9uZW50TmFtZSArIFwiYCwgZXhwZWN0ZWQgYSBSZWFjdCBjb21wb25lbnQuXCIpXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyKGV4cGVjdGVkQ2xhc3MpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbikge1xuICAgIGlmICghKHByb3BzW3Byb3BOYW1lXSBpbnN0YW5jZW9mIGV4cGVjdGVkQ2xhc3MpKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAgICAgIChcIkludmFsaWQgXCIgKyBsb2NhdGlvbk5hbWUgKyBcIiBgXCIgKyBwcm9wTmFtZSArIFwiYCBzdXBwbGllZCB0byBcIikgK1xuICAgICAgICAoXCJgXCIgKyBjb21wb25lbnROYW1lICsgXCJgLCBleHBlY3RlZCBpbnN0YW5jZSBvZiBgXCIgKyBleHBlY3RlZENsYXNzTmFtZSArIFwiYC5cIilcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uKSB7XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocHJvcFZhbHVlID09PSBleHBlY3RlZFZhbHVlc1tpXSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICB2YXIgdmFsdWVzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZXhwZWN0ZWRWYWx1ZXMpO1xuICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAgICAoXCJJbnZhbGlkIFwiICsgbG9jYXRpb25OYW1lICsgXCIgYFwiICsgcHJvcE5hbWUgKyBcImAgb2YgdmFsdWUgYFwiICsgcHJvcFZhbHVlICsgXCJgIFwiKSArXG4gICAgICAoXCJzdXBwbGllZCB0byBgXCIgKyBjb21wb25lbnROYW1lICsgXCJgLCBleHBlY3RlZCBvbmUgb2YgXCIgKyB2YWx1ZXNTdHJpbmcgKyBcIi5cIilcbiAgICApO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbikge1xuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICAgICAgKFwiSW52YWxpZCBcIiArIGxvY2F0aW9uTmFtZSArIFwiIGBcIiArIHByb3BOYW1lICsgXCJgIG9mIHR5cGUgXCIpICtcbiAgICAgICAgKFwiYFwiICsgcHJvcFR5cGUgKyBcImAgc3VwcGxpZWQgdG8gYFwiICsgY29tcG9uZW50TmFtZSArIFwiYCwgZXhwZWN0ZWQgYW4gb2JqZWN0LlwiKVxuICAgICAgKTtcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BWYWx1ZSkge1xuICAgICAgaWYgKHByb3BWYWx1ZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbik7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICBpZiAoY2hlY2tlcihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uKSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAgICAoXCJJbnZhbGlkIFwiICsgbG9jYXRpb25OYW1lICsgXCIgYFwiICsgcHJvcE5hbWUgKyBcImAgc3VwcGxpZWQgdG8gXCIpICtcbiAgICAgIChcImBcIiArIGNvbXBvbmVudE5hbWUgKyBcImAuXCIpXG4gICAgKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVSZW5kZXJhYmxlVHlwZUNoZWNrZXIoKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24pIHtcbiAgICBpZiAoIWlzUmVuZGVyYWJsZShwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICAgICAgKFwiSW52YWxpZCBcIiArIGxvY2F0aW9uTmFtZSArIFwiIGBcIiArIHByb3BOYW1lICsgXCJgIHN1cHBsaWVkIHRvIFwiKSArXG4gICAgICAgIChcImBcIiArIGNvbXBvbmVudE5hbWUgKyBcImAsIGV4cGVjdGVkIGEgcmVuZGVyYWJsZSBwcm9wLlwiKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24pIHtcbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAgICAgIChcIkludmFsaWQgXCIgKyBsb2NhdGlvbk5hbWUgKyBcIiBgXCIgKyBwcm9wTmFtZSArIFwiYCBvZiB0eXBlIGBcIiArIHByb3BUeXBlICsgXCJgIFwiKSArXG4gICAgICAgIChcInN1cHBsaWVkIHRvIGBcIiArIGNvbXBvbmVudE5hbWUgKyBcImAsIGV4cGVjdGVkIGBvYmplY3RgLlwiKVxuICAgICAgKTtcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24pO1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlLCAnZXhwZWN0ZWQgYG9iamVjdGAnKTtcbn1cblxuZnVuY3Rpb24gaXNSZW5kZXJhYmxlKHByb3BWYWx1ZSkge1xuICBzd2l0Y2godHlwZW9mIHByb3BWYWx1ZSkge1xuICAgIC8vIFRPRE86IHRoaXMgd2FzIHByb2JhYmx5IHdyaXR0ZW4gd2l0aCB0aGUgYXNzdW1wdGlvbiB0aGF0IHdlJ3JlIG5vdFxuICAgIC8vIHJldHVybmluZyBgdGhpcy5wcm9wcy5jb21wb25lbnRgIGRpcmVjdGx5IGZyb20gYHJlbmRlcmAuIFRoaXMgaXNcbiAgICAvLyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZCBidXQgd2Ugc2hvdWxkLCB0byBtYWtlIGl0IGNvbnNpc3RlbnQuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gIXByb3BWYWx1ZTtcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzUmVuZGVyYWJsZSk7XG4gICAgICB9XG4gICAgICBpZiAoUmVhY3REZXNjcmlwdG9yLmlzVmFsaWREZXNjcmlwdG9yKHByb3BWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrIGluIHByb3BWYWx1ZSkge1xuICAgICAgICBpZiAoIWlzUmVuZGVyYWJsZShwcm9wVmFsdWVba10pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8vIEVxdWl2YWxlbnQgb2YgYHR5cGVvZmAgYnV0IHdpdGggc3BlY2lhbCBoYW5kbGluZyBmb3IgYXJyYXkgYW5kIHJlZ2V4cC5cbmZ1bmN0aW9uIGdldFByb3BUeXBlKHByb3BWYWx1ZSkge1xuICB2YXIgcHJvcFR5cGUgPSB0eXBlb2YgcHJvcFZhbHVlO1xuICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgcmV0dXJuICdhcnJheSc7XG4gIH1cbiAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIC8vIE9sZCB3ZWJraXRzIChhdCBsZWFzdCB1bnRpbCBBbmRyb2lkIDQuMCkgcmV0dXJuICdmdW5jdGlvbicgcmF0aGVyIHRoYW5cbiAgICAvLyAnb2JqZWN0JyBmb3IgdHlwZW9mIGEgUmVnRXhwLiBXZSdsbCBub3JtYWxpemUgdGhpcyBoZXJlIHNvIHRoYXQgL2JsYS9cbiAgICAvLyBwYXNzZXMgUHJvcFR5cGVzLm9iamVjdC5cbiAgICByZXR1cm4gJ29iamVjdCc7XG4gIH1cbiAgcmV0dXJuIHByb3BUeXBlO1xufVxuXG4vLyBUaGlzIGhhbmRsZXMgbW9yZSB0eXBlcyB0aGFuIGBnZXRQcm9wVHlwZWAuIE9ubHkgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4vLyBTZWUgYGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyYC5cbmZ1bmN0aW9uIGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSkge1xuICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICBpZiAocHJvcFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHJldHVybiAnZGF0ZSc7XG4gICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIHJldHVybiAncmVnZXhwJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHByb3BUeXBlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UHV0TGlzdGVuZXJRdWV1ZVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKFwiLi9Qb29sZWRDbGFzc1wiKTtcbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSByZXF1aXJlKFwiLi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJcIik7XG5cbnZhciBtaXhJbnRvID0gcmVxdWlyZShcIi4vbWl4SW50b1wiKTtcblxuZnVuY3Rpb24gUmVhY3RQdXRMaXN0ZW5lclF1ZXVlKCkge1xuICB0aGlzLmxpc3RlbmVyc1RvUHV0ID0gW107XG59XG5cbm1peEludG8oUmVhY3RQdXRMaXN0ZW5lclF1ZXVlLCB7XG4gIGVucXVldWVQdXRMaXN0ZW5lcjogZnVuY3Rpb24ocm9vdE5vZGVJRCwgcHJvcEtleSwgcHJvcFZhbHVlKSB7XG4gICAgdGhpcy5saXN0ZW5lcnNUb1B1dC5wdXNoKHtcbiAgICAgIHJvb3ROb2RlSUQ6IHJvb3ROb2RlSUQsXG4gICAgICBwcm9wS2V5OiBwcm9wS2V5LFxuICAgICAgcHJvcFZhbHVlOiBwcm9wVmFsdWVcbiAgICB9KTtcbiAgfSxcblxuICBwdXRMaXN0ZW5lcnM6IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saXN0ZW5lcnNUb1B1dC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGxpc3RlbmVyVG9QdXQgPSB0aGlzLmxpc3RlbmVyc1RvUHV0W2ldO1xuICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnB1dExpc3RlbmVyKFxuICAgICAgICBsaXN0ZW5lclRvUHV0LnJvb3ROb2RlSUQsXG4gICAgICAgIGxpc3RlbmVyVG9QdXQucHJvcEtleSxcbiAgICAgICAgbGlzdGVuZXJUb1B1dC5wcm9wVmFsdWVcbiAgICAgICk7XG4gICAgfVxuICB9LFxuXG4gIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmxpc3RlbmVyc1RvUHV0Lmxlbmd0aCA9IDA7XG4gIH0sXG5cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZXNldCgpO1xuICB9XG59KTtcblxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKFJlYWN0UHV0TGlzdGVuZXJRdWV1ZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQdXRMaXN0ZW5lclF1ZXVlO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb25cbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBDYWxsYmFja1F1ZXVlID0gcmVxdWlyZShcIi4vQ2FsbGJhY2tRdWV1ZVwiKTtcbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoXCIuL1Bvb2xlZENsYXNzXCIpO1xudmFyIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCIuL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlclwiKTtcbnZhciBSZWFjdElucHV0U2VsZWN0aW9uID0gcmVxdWlyZShcIi4vUmVhY3RJbnB1dFNlbGVjdGlvblwiKTtcbnZhciBSZWFjdFB1dExpc3RlbmVyUXVldWUgPSByZXF1aXJlKFwiLi9SZWFjdFB1dExpc3RlbmVyUXVldWVcIik7XG52YXIgVHJhbnNhY3Rpb24gPSByZXF1aXJlKFwiLi9UcmFuc2FjdGlvblwiKTtcblxudmFyIG1peEludG8gPSByZXF1aXJlKFwiLi9taXhJbnRvXCIpO1xuXG4vKipcbiAqIEVuc3VyZXMgdGhhdCwgd2hlbiBwb3NzaWJsZSwgdGhlIHNlbGVjdGlvbiByYW5nZSAoY3VycmVudGx5IHNlbGVjdGVkIHRleHRcbiAqIGlucHV0KSBpcyBub3QgZGlzdHVyYmVkIGJ5IHBlcmZvcm1pbmcgdGhlIHRyYW5zYWN0aW9uLlxuICovXG52YXIgU0VMRUNUSU9OX1JFU1RPUkFUSU9OID0ge1xuICAvKipcbiAgICogQHJldHVybiB7U2VsZWN0aW9ufSBTZWxlY3Rpb24gaW5mb3JtYXRpb24uXG4gICAqL1xuICBpbml0aWFsaXplOiBSZWFjdElucHV0U2VsZWN0aW9uLmdldFNlbGVjdGlvbkluZm9ybWF0aW9uLFxuICAvKipcbiAgICogQHBhcmFtIHtTZWxlY3Rpb259IHNlbCBTZWxlY3Rpb24gaW5mb3JtYXRpb24gcmV0dXJuZWQgZnJvbSBgaW5pdGlhbGl6ZWAuXG4gICAqL1xuICBjbG9zZTogUmVhY3RJbnB1dFNlbGVjdGlvbi5yZXN0b3JlU2VsZWN0aW9uXG59O1xuXG4vKipcbiAqIFN1cHByZXNzZXMgZXZlbnRzIChibHVyL2ZvY3VzKSB0aGF0IGNvdWxkIGJlIGluYWR2ZXJ0ZW50bHkgZGlzcGF0Y2hlZCBkdWUgdG9cbiAqIGhpZ2ggbGV2ZWwgRE9NIG1hbmlwdWxhdGlvbnMgKGxpa2UgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgYSB0ZXh0IGlucHV0IGZyb20gdGhlXG4gKiBET00pLlxuICovXG52YXIgRVZFTlRfU1VQUFJFU1NJT04gPSB7XG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgZW5hYmxlZCBzdGF0dXMgb2YgYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgYmVmb3JlXG4gICAqIHRoZSByZWNvbmNpbGlhdGlvbi5cbiAgICovXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjdXJyZW50bHlFbmFibGVkID0gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmlzRW5hYmxlZCgpO1xuICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5zZXRFbmFibGVkKGZhbHNlKTtcbiAgICByZXR1cm4gY3VycmVudGx5RW5hYmxlZDtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtib29sZWFufSBwcmV2aW91c2x5RW5hYmxlZCBFbmFibGVkIHN0YXR1cyBvZlxuICAgKiAgIGBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJgIGJlZm9yZSB0aGUgcmVjb25jaWxpYXRpb24gb2NjdXJlZC4gYGNsb3NlYFxuICAgKiAgIHJlc3RvcmVzIHRoZSBwcmV2aW91cyB2YWx1ZS5cbiAgICovXG4gIGNsb3NlOiBmdW5jdGlvbihwcmV2aW91c2x5RW5hYmxlZCkge1xuICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5zZXRFbmFibGVkKHByZXZpb3VzbHlFbmFibGVkKTtcbiAgfVxufTtcblxuLyoqXG4gKiBQcm92aWRlcyBhIHF1ZXVlIGZvciBjb2xsZWN0aW5nIGBjb21wb25lbnREaWRNb3VudGAgYW5kXG4gKiBgY29tcG9uZW50RGlkVXBkYXRlYCBjYWxsYmFja3MgZHVyaW5nIHRoZSB0aGUgdHJhbnNhY3Rpb24uXG4gKi9cbnZhciBPTl9ET01fUkVBRFlfUVVFVUVJTkcgPSB7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgaW50ZXJuYWwgYG9uRE9NUmVhZHlgIHF1ZXVlLlxuICAgKi9cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZWFjdE1vdW50UmVhZHkucmVzZXQoKTtcbiAgfSxcblxuICAvKipcbiAgICogQWZ0ZXIgRE9NIGlzIGZsdXNoZWQsIGludm9rZSBhbGwgcmVnaXN0ZXJlZCBgb25ET01SZWFkeWAgY2FsbGJhY2tzLlxuICAgKi9cbiAgY2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVhY3RNb3VudFJlYWR5Lm5vdGlmeUFsbCgpO1xuICB9XG59O1xuXG52YXIgUFVUX0xJU1RFTkVSX1FVRVVFSU5HID0ge1xuICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnB1dExpc3RlbmVyUXVldWUucmVzZXQoKTtcbiAgfSxcblxuICBjbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5wdXRMaXN0ZW5lclF1ZXVlLnB1dExpc3RlbmVycygpO1xuICB9XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVkIHdpdGhpbiB0aGUgc2NvcGUgb2YgdGhlIGBUcmFuc2FjdGlvbmAgaW5zdGFuY2UuIENvbnNpZGVyIHRoZXNlIGFzXG4gKiBiZWluZyBtZW1iZXIgbWV0aG9kcywgYnV0IHdpdGggYW4gaW1wbGllZCBvcmRlcmluZyB3aGlsZSBiZWluZyBpc29sYXRlZCBmcm9tXG4gKiBlYWNoIG90aGVyLlxuICovXG52YXIgVFJBTlNBQ1RJT05fV1JBUFBFUlMgPSBbXG4gIFBVVF9MSVNURU5FUl9RVUVVRUlORyxcbiAgU0VMRUNUSU9OX1JFU1RPUkFUSU9OLFxuICBFVkVOVF9TVVBQUkVTU0lPTixcbiAgT05fRE9NX1JFQURZX1FVRVVFSU5HXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseTpcbiAqIC0gVGhlIG9yZGVyIHRoYXQgdGhlc2UgYXJlIGxpc3RlZCBpbiB0aGUgdHJhbnNhY3Rpb24gaXMgY3JpdGljYWw6XG4gKiAtIFN1cHByZXNzZXMgZXZlbnRzLlxuICogLSBSZXN0b3JlcyBzZWxlY3Rpb24gcmFuZ2UuXG4gKlxuICogRnV0dXJlOlxuICogLSBSZXN0b3JlIGRvY3VtZW50L292ZXJmbG93IHNjcm9sbCBwb3NpdGlvbnMgdGhhdCB3ZXJlIHVuaW50ZW50aW9uYWxseVxuICogICBtb2RpZmllZCB2aWEgRE9NIGluc2VydGlvbnMgYWJvdmUgdGhlIHRvcCB2aWV3cG9ydCBib3VuZGFyeS5cbiAqIC0gSW1wbGVtZW50L2ludGVncmF0ZSB3aXRoIGN1c3RvbWl6ZWQgY29uc3RyYWludCBiYXNlZCBsYXlvdXQgc3lzdGVtIGFuZCBrZWVwXG4gKiAgIHRyYWNrIG9mIHdoaWNoIGRpbWVuc2lvbnMgbXVzdCBiZSByZW1lYXN1cmVkLlxuICpcbiAqIEBjbGFzcyBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uXG4gKi9cbmZ1bmN0aW9uIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24oKSB7XG4gIHRoaXMucmVpbml0aWFsaXplVHJhbnNhY3Rpb24oKTtcbiAgLy8gT25seSBzZXJ2ZXItc2lkZSByZW5kZXJpbmcgcmVhbGx5IG5lZWRzIHRoaXMgb3B0aW9uIChzZWVcbiAgLy8gYFJlYWN0U2VydmVyUmVuZGVyaW5nYCksIGJ1dCBzZXJ2ZXItc2lkZSB1c2VzXG4gIC8vIGBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uYCBpbnN0ZWFkLiBUaGlzIG9wdGlvbiBpcyBoZXJlIHNvIHRoYXQgaXQnc1xuICAvLyBhY2Nlc3NpYmxlIGFuZCBkZWZhdWx0cyB0byBmYWxzZSB3aGVuIGBSZWFjdERPTUNvbXBvbmVudGAgYW5kXG4gIC8vIGBSZWFjdFRleHRDb21wb25lbnRgIGNoZWNrcyBpdCBpbiBgbW91bnRDb21wb25lbnRgLmBcbiAgdGhpcy5yZW5kZXJUb1N0YXRpY01hcmt1cCA9IGZhbHNlO1xuICB0aGlzLnJlYWN0TW91bnRSZWFkeSA9IENhbGxiYWNrUXVldWUuZ2V0UG9vbGVkKG51bGwpO1xuICB0aGlzLnB1dExpc3RlbmVyUXVldWUgPSBSZWFjdFB1dExpc3RlbmVyUXVldWUuZ2V0UG9vbGVkKCk7XG59XG5cbnZhciBNaXhpbiA9IHtcbiAgLyoqXG4gICAqIEBzZWUgVHJhbnNhY3Rpb25cbiAgICogQGFic3RyYWN0XG4gICAqIEBmaW5hbFxuICAgKiBAcmV0dXJuIHthcnJheTxvYmplY3Q+fSBMaXN0IG9mIG9wZXJhdGlvbiB3cmFwIHByb2NlZWR1cmVzLlxuICAgKiAgIFRPRE86IGNvbnZlcnQgdG8gYXJyYXk8VHJhbnNhY3Rpb25XcmFwcGVyPlxuICAgKi9cbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFRSQU5TQUNUSU9OX1dSQVBQRVJTO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBxdWV1ZSB0byBjb2xsZWN0IGBvbkRPTVJlYWR5YCBjYWxsYmFja3Mgd2l0aC5cbiAgICovXG4gIGdldFJlYWN0TW91bnRSZWFkeTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhY3RNb3VudFJlYWR5O1xuICB9LFxuXG4gIGdldFB1dExpc3RlbmVyUXVldWU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnB1dExpc3RlbmVyUXVldWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGBQb29sZWRDbGFzc2AgbG9va3MgZm9yIHRoaXMsIGFuZCB3aWxsIGludm9rZSB0aGlzIGJlZm9yZSBhbGxvd2luZyB0aGlzXG4gICAqIGluc3RhbmNlIHRvIGJlIHJlc3VzZWQuXG4gICAqL1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbigpIHtcbiAgICBDYWxsYmFja1F1ZXVlLnJlbGVhc2UodGhpcy5yZWFjdE1vdW50UmVhZHkpO1xuICAgIHRoaXMucmVhY3RNb3VudFJlYWR5ID0gbnVsbDtcblxuICAgIFJlYWN0UHV0TGlzdGVuZXJRdWV1ZS5yZWxlYXNlKHRoaXMucHV0TGlzdGVuZXJRdWV1ZSk7XG4gICAgdGhpcy5wdXRMaXN0ZW5lclF1ZXVlID0gbnVsbDtcbiAgfVxufTtcblxuXG5taXhJbnRvKFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24sIFRyYW5zYWN0aW9uLk1peGluKTtcbm1peEludG8oUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbiwgTWl4aW4pO1xuXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbik7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbjtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFJvb3RJbmRleFxuICogQHR5cGVjaGVja3NcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIFJlYWN0Um9vdEluZGV4SW5qZWN0aW9uID0ge1xuICAvKipcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gX2NyZWF0ZVJlYWN0Um9vdEluZGV4XG4gICAqL1xuICBpbmplY3RDcmVhdGVSZWFjdFJvb3RJbmRleDogZnVuY3Rpb24oX2NyZWF0ZVJlYWN0Um9vdEluZGV4KSB7XG4gICAgUmVhY3RSb290SW5kZXguY3JlYXRlUmVhY3RSb290SW5kZXggPSBfY3JlYXRlUmVhY3RSb290SW5kZXg7XG4gIH1cbn07XG5cbnZhciBSZWFjdFJvb3RJbmRleCA9IHtcbiAgY3JlYXRlUmVhY3RSb290SW5kZXg6IG51bGwsXG4gIGluamVjdGlvbjogUmVhY3RSb290SW5kZXhJbmplY3Rpb25cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RSb290SW5kZXg7XG4iLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFNlcnZlclJlbmRlcmluZ1xuICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIFJlYWN0RGVzY3JpcHRvciA9IHJlcXVpcmUoXCIuL1JlYWN0RGVzY3JpcHRvclwiKTtcbnZhciBSZWFjdEluc3RhbmNlSGFuZGxlcyA9IHJlcXVpcmUoXCIuL1JlYWN0SW5zdGFuY2VIYW5kbGVzXCIpO1xudmFyIFJlYWN0TWFya3VwQ2hlY2tzdW0gPSByZXF1aXJlKFwiLi9SZWFjdE1hcmt1cENoZWNrc3VtXCIpO1xudmFyIFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24gPVxuICByZXF1aXJlKFwiLi9SZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uXCIpO1xuXG52YXIgaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoXCIuL2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnRcIik7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xuXG4vKipcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudFxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgSFRNTCBtYXJrdXBcbiAqL1xuZnVuY3Rpb24gcmVuZGVyQ29tcG9uZW50VG9TdHJpbmcoY29tcG9uZW50KSB7XG4gIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgUmVhY3REZXNjcmlwdG9yLmlzVmFsaWREZXNjcmlwdG9yKGNvbXBvbmVudCksXG4gICAgJ3JlbmRlckNvbXBvbmVudFRvU3RyaW5nKCk6IFlvdSBtdXN0IHBhc3MgYSB2YWxpZCBSZWFjdENvbXBvbmVudC4nXG4gICkgOiBpbnZhcmlhbnQoUmVhY3REZXNjcmlwdG9yLmlzVmFsaWREZXNjcmlwdG9yKGNvbXBvbmVudCkpKTtcblxuICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICEoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSxcbiAgICAncmVuZGVyQ29tcG9uZW50VG9TdHJpbmcoKTogVGhpcyBmdW5jdGlvbiBiZWNhbWUgc3luY2hyb25vdXMgYW5kIG5vdyAnICtcbiAgICAncmV0dXJucyB0aGUgZ2VuZXJhdGVkIG1hcmt1cC4gUGxlYXNlIHJlbW92ZSB0aGUgc2Vjb25kIHBhcmFtZXRlci4nXG4gICkgOiBpbnZhcmlhbnQoIShhcmd1bWVudHMubGVuZ3RoID09PSAyICYmIHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicpKSk7XG5cbiAgdmFyIHRyYW5zYWN0aW9uO1xuICB0cnkge1xuICAgIHZhciBpZCA9IFJlYWN0SW5zdGFuY2VIYW5kbGVzLmNyZWF0ZVJlYWN0Um9vdElEKCk7XG4gICAgdHJhbnNhY3Rpb24gPSBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uLmdldFBvb2xlZChmYWxzZSk7XG5cbiAgICByZXR1cm4gdHJhbnNhY3Rpb24ucGVyZm9ybShmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQoY29tcG9uZW50KTtcbiAgICAgIHZhciBtYXJrdXAgPSBjb21wb25lbnRJbnN0YW5jZS5tb3VudENvbXBvbmVudChpZCwgdHJhbnNhY3Rpb24sIDApO1xuICAgICAgcmV0dXJuIFJlYWN0TWFya3VwQ2hlY2tzdW0uYWRkQ2hlY2tzdW1Ub01hcmt1cChtYXJrdXApO1xuICAgIH0sIG51bGwpO1xuICB9IGZpbmFsbHkge1xuICAgIFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24ucmVsZWFzZSh0cmFuc2FjdGlvbik7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnRcbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIEhUTUwgbWFya3VwLCB3aXRob3V0IHRoZSBleHRyYSBSZWFjdCBJRCBhbmQgY2hlY2tzdW1cbiogKGZvciBnZW5lcmF0aW5nIHN0YXRpYyBwYWdlcylcbiAqL1xuZnVuY3Rpb24gcmVuZGVyQ29tcG9uZW50VG9TdGF0aWNNYXJrdXAoY29tcG9uZW50KSB7XG4gIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgUmVhY3REZXNjcmlwdG9yLmlzVmFsaWREZXNjcmlwdG9yKGNvbXBvbmVudCksXG4gICAgJ3JlbmRlckNvbXBvbmVudFRvU3RhdGljTWFya3VwKCk6IFlvdSBtdXN0IHBhc3MgYSB2YWxpZCBSZWFjdENvbXBvbmVudC4nXG4gICkgOiBpbnZhcmlhbnQoUmVhY3REZXNjcmlwdG9yLmlzVmFsaWREZXNjcmlwdG9yKGNvbXBvbmVudCkpKTtcblxuICB2YXIgdHJhbnNhY3Rpb247XG4gIHRyeSB7XG4gICAgdmFyIGlkID0gUmVhY3RJbnN0YW5jZUhhbmRsZXMuY3JlYXRlUmVhY3RSb290SUQoKTtcbiAgICB0cmFuc2FjdGlvbiA9IFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24uZ2V0UG9vbGVkKHRydWUpO1xuXG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uLnBlcmZvcm0oZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KGNvbXBvbmVudCk7XG4gICAgICByZXR1cm4gY29tcG9uZW50SW5zdGFuY2UubW91bnRDb21wb25lbnQoaWQsIHRyYW5zYWN0aW9uLCAwKTtcbiAgICB9LCBudWxsKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uLnJlbGVhc2UodHJhbnNhY3Rpb24pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICByZW5kZXJDb21wb25lbnRUb1N0cmluZzogcmVuZGVyQ29tcG9uZW50VG9TdHJpbmcsXG4gIHJlbmRlckNvbXBvbmVudFRvU3RhdGljTWFya3VwOiByZW5kZXJDb21wb25lbnRUb1N0YXRpY01hcmt1cFxufTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKFwiLi9Qb29sZWRDbGFzc1wiKTtcbnZhciBDYWxsYmFja1F1ZXVlID0gcmVxdWlyZShcIi4vQ2FsbGJhY2tRdWV1ZVwiKTtcbnZhciBSZWFjdFB1dExpc3RlbmVyUXVldWUgPSByZXF1aXJlKFwiLi9SZWFjdFB1dExpc3RlbmVyUXVldWVcIik7XG52YXIgVHJhbnNhY3Rpb24gPSByZXF1aXJlKFwiLi9UcmFuc2FjdGlvblwiKTtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKFwiLi9lbXB0eUZ1bmN0aW9uXCIpO1xudmFyIG1peEludG8gPSByZXF1aXJlKFwiLi9taXhJbnRvXCIpO1xuXG4vKipcbiAqIFByb3ZpZGVzIGEgYENhbGxiYWNrUXVldWVgIHF1ZXVlIGZvciBjb2xsZWN0aW5nIGBvbkRPTVJlYWR5YCBjYWxsYmFja3NcbiAqIGR1cmluZyB0aGUgcGVyZm9ybWluZyBvZiB0aGUgdHJhbnNhY3Rpb24uXG4gKi9cbnZhciBPTl9ET01fUkVBRFlfUVVFVUVJTkcgPSB7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgaW50ZXJuYWwgYG9uRE9NUmVhZHlgIHF1ZXVlLlxuICAgKi9cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZWFjdE1vdW50UmVhZHkucmVzZXQoKTtcbiAgfSxcblxuICBjbG9zZTogZW1wdHlGdW5jdGlvblxufTtcblxudmFyIFBVVF9MSVNURU5FUl9RVUVVRUlORyA9IHtcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5wdXRMaXN0ZW5lclF1ZXVlLnJlc2V0KCk7XG4gIH0sXG5cbiAgY2xvc2U6IGVtcHR5RnVuY3Rpb25cbn07XG5cbi8qKlxuICogRXhlY3V0ZWQgd2l0aGluIHRoZSBzY29wZSBvZiB0aGUgYFRyYW5zYWN0aW9uYCBpbnN0YW5jZS4gQ29uc2lkZXIgdGhlc2UgYXNcbiAqIGJlaW5nIG1lbWJlciBtZXRob2RzLCBidXQgd2l0aCBhbiBpbXBsaWVkIG9yZGVyaW5nIHdoaWxlIGJlaW5nIGlzb2xhdGVkIGZyb21cbiAqIGVhY2ggb3RoZXIuXG4gKi9cbnZhciBUUkFOU0FDVElPTl9XUkFQUEVSUyA9IFtcbiAgUFVUX0xJU1RFTkVSX1FVRVVFSU5HLFxuICBPTl9ET01fUkVBRFlfUVVFVUVJTkdcbl07XG5cbi8qKlxuICogQGNsYXNzIFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVuZGVyVG9TdGF0aWNNYXJrdXBcbiAqL1xuZnVuY3Rpb24gUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbihyZW5kZXJUb1N0YXRpY01hcmt1cCkge1xuICB0aGlzLnJlaW5pdGlhbGl6ZVRyYW5zYWN0aW9uKCk7XG4gIHRoaXMucmVuZGVyVG9TdGF0aWNNYXJrdXAgPSByZW5kZXJUb1N0YXRpY01hcmt1cDtcbiAgdGhpcy5yZWFjdE1vdW50UmVhZHkgPSBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZChudWxsKTtcbiAgdGhpcy5wdXRMaXN0ZW5lclF1ZXVlID0gUmVhY3RQdXRMaXN0ZW5lclF1ZXVlLmdldFBvb2xlZCgpO1xufVxuXG52YXIgTWl4aW4gPSB7XG4gIC8qKlxuICAgKiBAc2VlIFRyYW5zYWN0aW9uXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAZmluYWxcbiAgICogQHJldHVybiB7YXJyYXl9IEVtcHR5IGxpc3Qgb2Ygb3BlcmF0aW9uIHdyYXAgcHJvY2VlZHVyZXMuXG4gICAqL1xuICBnZXRUcmFuc2FjdGlvbldyYXBwZXJzOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gVFJBTlNBQ1RJT05fV1JBUFBFUlM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHF1ZXVlIHRvIGNvbGxlY3QgYG9uRE9NUmVhZHlgIGNhbGxiYWNrcyB3aXRoLlxuICAgKi9cbiAgZ2V0UmVhY3RNb3VudFJlYWR5OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFjdE1vdW50UmVhZHk7XG4gIH0sXG5cbiAgZ2V0UHV0TGlzdGVuZXJRdWV1ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucHV0TGlzdGVuZXJRdWV1ZTtcbiAgfSxcblxuICAvKipcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgdGhpcywgYW5kIHdpbGwgaW52b2tlIHRoaXMgYmVmb3JlIGFsbG93aW5nIHRoaXNcbiAgICogaW5zdGFuY2UgdG8gYmUgcmVzdXNlZC5cbiAgICovXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uKCkge1xuICAgIENhbGxiYWNrUXVldWUucmVsZWFzZSh0aGlzLnJlYWN0TW91bnRSZWFkeSk7XG4gICAgdGhpcy5yZWFjdE1vdW50UmVhZHkgPSBudWxsO1xuXG4gICAgUmVhY3RQdXRMaXN0ZW5lclF1ZXVlLnJlbGVhc2UodGhpcy5wdXRMaXN0ZW5lclF1ZXVlKTtcbiAgICB0aGlzLnB1dExpc3RlbmVyUXVldWUgPSBudWxsO1xuICB9XG59O1xuXG5cbm1peEludG8oUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbiwgVHJhbnNhY3Rpb24uTWl4aW4pO1xubWl4SW50byhSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uLCBNaXhpbik7XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0U3RhdGVTZXR0ZXJzXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBSZWFjdFN0YXRlU2V0dGVycyA9IHtcbiAgLyoqXG4gICAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGNhbGxzIHRoZSBwcm92aWRlZCBmdW5jdGlvbiwgYW5kIHVzZXMgdGhlIHJlc3VsdFxuICAgKiBvZiB0aGF0IHRvIHNldCB0aGUgY29tcG9uZW50J3Mgc3RhdGUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb3NpdGVDb21wb25lbnR9IGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jUmV0dXJuaW5nU3RhdGUgUmV0dXJuZWQgY2FsbGJhY2sgdXNlcyB0aGlzIHRvXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRlcm1pbmUgaG93IHRvIHVwZGF0ZSBzdGF0ZS5cbiAgICogQHJldHVybiB7ZnVuY3Rpb259IGNhbGxiYWNrIHRoYXQgd2hlbiBpbnZva2VkIHVzZXMgZnVuY1JldHVybmluZ1N0YXRlIHRvXG4gICAqICAgICAgICAgICAgICAgICAgICBkZXRlcm1pbmVkIHRoZSBvYmplY3QgbGl0ZXJhbCB0byBzZXRTdGF0ZS5cbiAgICovXG4gIGNyZWF0ZVN0YXRlU2V0dGVyOiBmdW5jdGlvbihjb21wb25lbnQsIGZ1bmNSZXR1cm5pbmdTdGF0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbihhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgICB2YXIgcGFydGlhbFN0YXRlID0gZnVuY1JldHVybmluZ1N0YXRlLmNhbGwoY29tcG9uZW50LCBhLCBiLCBjLCBkLCBlLCBmKTtcbiAgICAgIGlmIChwYXJ0aWFsU3RhdGUpIHtcbiAgICAgICAgY29tcG9uZW50LnNldFN0YXRlKHBhcnRpYWxTdGF0ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIHNpbmdsZS1hcmd1bWVudCBjYWxsYmFjayB0aGF0IGNhbiBiZSB1c2VkIHRvIHVwZGF0ZSBhIHNpbmdsZVxuICAgKiBrZXkgaW4gdGhlIGNvbXBvbmVudCdzIHN0YXRlLlxuICAgKlxuICAgKiBOb3RlOiB0aGlzIGlzIG1lbW9pemVkIGZ1bmN0aW9uLCB3aGljaCBtYWtlcyBpdCBpbmV4cGVuc2l2ZSB0byBjYWxsLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50fSBjb21wb25lbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IGluIHRoZSBzdGF0ZSB0aGF0IHlvdSBzaG91bGQgdXBkYXRlLlxuICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gY2FsbGJhY2sgb2YgMSBhcmd1bWVudCB3aGljaCBjYWxscyBzZXRTdGF0ZSgpIHdpdGhcbiAgICogICAgICAgICAgICAgICAgICAgIHRoZSBwcm92aWRlZCBrZXlOYW1lIGFuZCBjYWxsYmFjayBhcmd1bWVudC5cbiAgICovXG4gIGNyZWF0ZVN0YXRlS2V5U2V0dGVyOiBmdW5jdGlvbihjb21wb25lbnQsIGtleSkge1xuICAgIC8vIE1lbW9pemUgdGhlIHNldHRlcnMuXG4gICAgdmFyIGNhY2hlID0gY29tcG9uZW50Ll9fa2V5U2V0dGVycyB8fCAoY29tcG9uZW50Ll9fa2V5U2V0dGVycyA9IHt9KTtcbiAgICByZXR1cm4gY2FjaGVba2V5XSB8fCAoY2FjaGVba2V5XSA9IGNyZWF0ZVN0YXRlS2V5U2V0dGVyKGNvbXBvbmVudCwga2V5KSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0YXRlS2V5U2V0dGVyKGNvbXBvbmVudCwga2V5KSB7XG4gIC8vIFBhcnRpYWwgc3RhdGUgaXMgYWxsb2NhdGVkIG91dHNpZGUgb2YgdGhlIGZ1bmN0aW9uIGNsb3N1cmUgc28gaXQgY2FuIGJlXG4gIC8vIHJldXNlZCB3aXRoIGV2ZXJ5IGNhbGwsIGF2b2lkaW5nIG1lbW9yeSBhbGxvY2F0aW9uIHdoZW4gdGhpcyBmdW5jdGlvblxuICAvLyBpcyBjYWxsZWQuXG4gIHZhciBwYXJ0aWFsU3RhdGUgPSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHN0YXRlS2V5U2V0dGVyKHZhbHVlKSB7XG4gICAgcGFydGlhbFN0YXRlW2tleV0gPSB2YWx1ZTtcbiAgICBjb21wb25lbnQuc2V0U3RhdGUocGFydGlhbFN0YXRlKTtcbiAgfTtcbn1cblxuUmVhY3RTdGF0ZVNldHRlcnMuTWl4aW4gPSB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBjYWxscyB0aGUgcHJvdmlkZWQgZnVuY3Rpb24sIGFuZCB1c2VzIHRoZSByZXN1bHRcbiAgICogb2YgdGhhdCB0byBzZXQgdGhlIGNvbXBvbmVudCdzIHN0YXRlLlxuICAgKlxuICAgKiBGb3IgZXhhbXBsZSwgdGhlc2Ugc3RhdGVtZW50cyBhcmUgZXF1aXZhbGVudDpcbiAgICpcbiAgICogICB0aGlzLnNldFN0YXRlKHt4OiAxfSk7XG4gICAqICAgdGhpcy5jcmVhdGVTdGF0ZVNldHRlcihmdW5jdGlvbih4VmFsdWUpIHtcbiAgICogICAgIHJldHVybiB7eDogeFZhbHVlfTtcbiAgICogICB9KSgxKTtcbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuY1JldHVybmluZ1N0YXRlIFJldHVybmVkIGNhbGxiYWNrIHVzZXMgdGhpcyB0b1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0ZXJtaW5lIGhvdyB0byB1cGRhdGUgc3RhdGUuXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9ufSBjYWxsYmFjayB0aGF0IHdoZW4gaW52b2tlZCB1c2VzIGZ1bmNSZXR1cm5pbmdTdGF0ZSB0b1xuICAgKiAgICAgICAgICAgICAgICAgICAgZGV0ZXJtaW5lZCB0aGUgb2JqZWN0IGxpdGVyYWwgdG8gc2V0U3RhdGUuXG4gICAqL1xuICBjcmVhdGVTdGF0ZVNldHRlcjogZnVuY3Rpb24oZnVuY1JldHVybmluZ1N0YXRlKSB7XG4gICAgcmV0dXJuIFJlYWN0U3RhdGVTZXR0ZXJzLmNyZWF0ZVN0YXRlU2V0dGVyKHRoaXMsIGZ1bmNSZXR1cm5pbmdTdGF0ZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzaW5nbGUtYXJndW1lbnQgY2FsbGJhY2sgdGhhdCBjYW4gYmUgdXNlZCB0byB1cGRhdGUgYSBzaW5nbGVcbiAgICoga2V5IGluIHRoZSBjb21wb25lbnQncyBzdGF0ZS5cbiAgICpcbiAgICogRm9yIGV4YW1wbGUsIHRoZXNlIHN0YXRlbWVudHMgYXJlIGVxdWl2YWxlbnQ6XG4gICAqXG4gICAqICAgdGhpcy5zZXRTdGF0ZSh7eDogMX0pO1xuICAgKiAgIHRoaXMuY3JlYXRlU3RhdGVLZXlTZXR0ZXIoJ3gnKSgxKTtcbiAgICpcbiAgICogTm90ZTogdGhpcyBpcyBtZW1vaXplZCBmdW5jdGlvbiwgd2hpY2ggbWFrZXMgaXQgaW5leHBlbnNpdmUgdG8gY2FsbC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IGluIHRoZSBzdGF0ZSB0aGF0IHlvdSBzaG91bGQgdXBkYXRlLlxuICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gY2FsbGJhY2sgb2YgMSBhcmd1bWVudCB3aGljaCBjYWxscyBzZXRTdGF0ZSgpIHdpdGhcbiAgICogICAgICAgICAgICAgICAgICAgIHRoZSBwcm92aWRlZCBrZXlOYW1lIGFuZCBjYWxsYmFjayBhcmd1bWVudC5cbiAgICovXG4gIGNyZWF0ZVN0YXRlS2V5U2V0dGVyOiBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gUmVhY3RTdGF0ZVNldHRlcnMuY3JlYXRlU3RhdGVLZXlTZXR0ZXIodGhpcywga2V5KTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFN0YXRlU2V0dGVycztcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFRlc3RVdGlsc1xuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKFwiLi9FdmVudENvbnN0YW50c1wiKTtcbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoXCIuL0V2ZW50UGx1Z2luSHViXCIpO1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKFwiLi9FdmVudFByb3BhZ2F0b3JzXCIpO1xudmFyIFJlYWN0ID0gcmVxdWlyZShcIi4vUmVhY3RcIik7XG52YXIgUmVhY3REZXNjcmlwdG9yID0gcmVxdWlyZShcIi4vUmVhY3REZXNjcmlwdG9yXCIpO1xudmFyIFJlYWN0RE9NID0gcmVxdWlyZShcIi4vUmVhY3RET01cIik7XG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcIi4vUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyXCIpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKFwiLi9SZWFjdE1vdW50XCIpO1xudmFyIFJlYWN0VGV4dENvbXBvbmVudCA9IHJlcXVpcmUoXCIuL1JlYWN0VGV4dENvbXBvbmVudFwiKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKFwiLi9SZWFjdFVwZGF0ZXNcIik7XG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKFwiLi9TeW50aGV0aWNFdmVudFwiKTtcblxudmFyIG1lcmdlSW50byA9IHJlcXVpcmUoXCIuL21lcmdlSW50b1wiKTtcbnZhciBjb3B5UHJvcGVydGllcyA9IHJlcXVpcmUoXCIuL2NvcHlQcm9wZXJ0aWVzXCIpO1xuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG5cbmZ1bmN0aW9uIEV2ZW50KHN1ZmZpeCkge31cblxuLyoqXG4gKiBAY2xhc3MgUmVhY3RUZXN0VXRpbHNcbiAqL1xuXG4vKipcbiAqIFRvZG86IFN1cHBvcnQgdGhlIGVudGlyZSBET00uc2NyeSBxdWVyeSBzeW50YXguIEZvciBub3csIHRoZXNlIHNpbXBsZVxuICogdXRpbGl0aWVzIHdpbGwgc3VmZmljZSBmb3IgdGVzdGluZyBwdXJwb3Nlcy5cbiAqIEBsZW5kcyBSZWFjdFRlc3RVdGlsc1xuICovXG52YXIgUmVhY3RUZXN0VXRpbHMgPSB7XG4gIHJlbmRlckludG9Eb2N1bWVudDogZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgLy8gTm9uZSBvZiBvdXIgdGVzdHMgYWN0dWFsbHkgcmVxdWlyZSBhdHRhY2hpbmcgdGhlIGNvbnRhaW5lciB0byB0aGVcbiAgICAvLyBET00sIGFuZCBkb2luZyBzbyBjcmVhdGVzIGEgbWVzcyB0aGF0IHdlIHJlbHkgb24gdGVzdCBpc29sYXRpb24gdG9cbiAgICAvLyBjbGVhbiB1cCwgc28gd2UncmUgZ29pbmcgdG8gc3RvcCBob25vcmluZyB0aGUgbmFtZSBvZiB0aGlzIG1ldGhvZFxuICAgIC8vIChhbmQgcHJvYmFibHkgcmVuYW1lIGl0IGV2ZW50dWFsbHkpIGlmIG5vIHByb2JsZW1zIGFyaXNlLlxuICAgIC8vIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChkaXYpO1xuICAgIHJldHVybiBSZWFjdC5yZW5kZXJDb21wb25lbnQoaW5zdGFuY2UsIGRpdik7XG4gIH0sXG5cbiAgaXNEZXNjcmlwdG9yOiBmdW5jdGlvbihkZXNjcmlwdG9yKSB7XG4gICAgcmV0dXJuIFJlYWN0RGVzY3JpcHRvci5pc1ZhbGlkRGVzY3JpcHRvcihkZXNjcmlwdG9yKTtcbiAgfSxcblxuICBpc0Rlc2NyaXB0b3JPZlR5cGU6IGZ1bmN0aW9uKGluc3QsIGNvbnZlbmllbmNlQ29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gKFxuICAgICAgUmVhY3REZXNjcmlwdG9yLmlzVmFsaWREZXNjcmlwdG9yKGluc3QpICYmXG4gICAgICBpbnN0LnR5cGUgPT09IGNvbnZlbmllbmNlQ29uc3RydWN0b3IudHlwZVxuICAgICk7XG4gIH0sXG5cbiAgaXNET01Db21wb25lbnQ6IGZ1bmN0aW9uKGluc3QpIHtcbiAgICByZXR1cm4gISEoaW5zdCAmJiBpbnN0Lm1vdW50Q29tcG9uZW50ICYmIGluc3QudGFnTmFtZSk7XG4gIH0sXG5cbiAgaXNET01Db21wb25lbnREZXNjcmlwdG9yOiBmdW5jdGlvbihpbnN0KSB7XG4gICAgcmV0dXJuICEhKGluc3QgJiZcbiAgICAgICAgICAgICAgUmVhY3REZXNjcmlwdG9yLmlzVmFsaWREZXNjcmlwdG9yKGluc3QpICYmXG4gICAgICAgICAgICAgICEhaW5zdC50YWdOYW1lKTtcbiAgfSxcblxuICBpc0NvbXBvc2l0ZUNvbXBvbmVudDogZnVuY3Rpb24oaW5zdCkge1xuICAgIHJldHVybiB0eXBlb2YgaW5zdC5yZW5kZXIgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgdHlwZW9mIGluc3Quc2V0U3RhdGUgPT09ICdmdW5jdGlvbic7XG4gIH0sXG5cbiAgaXNDb21wb3NpdGVDb21wb25lbnRXaXRoVHlwZTogZnVuY3Rpb24oaW5zdCwgdHlwZSkge1xuICAgIHJldHVybiAhIShSZWFjdFRlc3RVdGlscy5pc0NvbXBvc2l0ZUNvbXBvbmVudChpbnN0KSAmJlxuICAgICAgICAgICAgIChpbnN0LmNvbnN0cnVjdG9yID09PSB0eXBlLnR5cGUpKTtcbiAgfSxcblxuICBpc0NvbXBvc2l0ZUNvbXBvbmVudERlc2NyaXB0b3I6IGZ1bmN0aW9uKGluc3QpIHtcbiAgICBpZiAoIVJlYWN0RGVzY3JpcHRvci5pc1ZhbGlkRGVzY3JpcHRvcihpbnN0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBXZSBjaGVjayB0aGUgcHJvdG90eXBlIG9mIHRoZSB0eXBlIHRoYXQgd2lsbCBnZXQgbW91bnRlZCwgbm90IHRoZVxuICAgIC8vIGluc3RhbmNlIGl0c2VsZi4gVGhpcyBpcyBhIGZ1dHVyZSBwcm9vZiB3YXkgb2YgZHVjayB0eXBpbmcuXG4gICAgdmFyIHByb3RvdHlwZSA9IGluc3QudHlwZS5wcm90b3R5cGU7XG4gICAgcmV0dXJuIChcbiAgICAgIHR5cGVvZiBwcm90b3R5cGUucmVuZGVyID09PSAnZnVuY3Rpb24nICYmXG4gICAgICB0eXBlb2YgcHJvdG90eXBlLnNldFN0YXRlID09PSAnZnVuY3Rpb24nXG4gICAgKTtcbiAgfSxcblxuICBpc0NvbXBvc2l0ZUNvbXBvbmVudERlc2NyaXB0b3JXaXRoVHlwZTogZnVuY3Rpb24oaW5zdCwgdHlwZSkge1xuICAgIHJldHVybiAhIShSZWFjdFRlc3RVdGlscy5pc0NvbXBvc2l0ZUNvbXBvbmVudERlc2NyaXB0b3IoaW5zdCkgJiZcbiAgICAgICAgICAgICAoaW5zdC5jb25zdHJ1Y3RvciA9PT0gdHlwZSkpO1xuICB9LFxuXG4gIGlzVGV4dENvbXBvbmVudDogZnVuY3Rpb24oaW5zdCkge1xuICAgIHJldHVybiBpbnN0IGluc3RhbmNlb2YgUmVhY3RUZXh0Q29tcG9uZW50LnR5cGU7XG4gIH0sXG5cbiAgZmluZEFsbEluUmVuZGVyZWRUcmVlOiBmdW5jdGlvbihpbnN0LCB0ZXN0KSB7XG4gICAgaWYgKCFpbnN0KSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHZhciByZXQgPSB0ZXN0KGluc3QpID8gW2luc3RdIDogW107XG4gICAgaWYgKFJlYWN0VGVzdFV0aWxzLmlzRE9NQ29tcG9uZW50KGluc3QpKSB7XG4gICAgICB2YXIgcmVuZGVyZWRDaGlsZHJlbiA9IGluc3QuX3JlbmRlcmVkQ2hpbGRyZW47XG4gICAgICB2YXIga2V5O1xuICAgICAgZm9yIChrZXkgaW4gcmVuZGVyZWRDaGlsZHJlbikge1xuICAgICAgICBpZiAoIXJlbmRlcmVkQ2hpbGRyZW4uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldCA9IHJldC5jb25jYXQoXG4gICAgICAgICAgUmVhY3RUZXN0VXRpbHMuZmluZEFsbEluUmVuZGVyZWRUcmVlKHJlbmRlcmVkQ2hpbGRyZW5ba2V5XSwgdGVzdClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFJlYWN0VGVzdFV0aWxzLmlzQ29tcG9zaXRlQ29tcG9uZW50KGluc3QpKSB7XG4gICAgICByZXQgPSByZXQuY29uY2F0KFxuICAgICAgICBSZWFjdFRlc3RVdGlscy5maW5kQWxsSW5SZW5kZXJlZFRyZWUoaW5zdC5fcmVuZGVyZWRDb21wb25lbnQsIHRlc3QpXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBGaW5kcyBhbGwgaW5zdGFuY2Ugb2YgY29tcG9uZW50cyBpbiB0aGUgcmVuZGVyZWQgdHJlZSB0aGF0IGFyZSBET01cbiAgICogY29tcG9uZW50cyB3aXRoIHRoZSBjbGFzcyBuYW1lIG1hdGNoaW5nIGBjbGFzc05hbWVgLlxuICAgKiBAcmV0dXJuIGFuIGFycmF5IG9mIGFsbCB0aGUgbWF0Y2hlcy5cbiAgICovXG4gIHNjcnlSZW5kZXJlZERPTUNvbXBvbmVudHNXaXRoQ2xhc3M6IGZ1bmN0aW9uKHJvb3QsIGNsYXNzTmFtZSkge1xuICAgIHJldHVybiBSZWFjdFRlc3RVdGlscy5maW5kQWxsSW5SZW5kZXJlZFRyZWUocm9vdCwgZnVuY3Rpb24oaW5zdCkge1xuICAgICAgdmFyIGluc3RDbGFzc05hbWUgPSBpbnN0LnByb3BzLmNsYXNzTmFtZTtcbiAgICAgIHJldHVybiBSZWFjdFRlc3RVdGlscy5pc0RPTUNvbXBvbmVudChpbnN0KSAmJiAoXG4gICAgICAgIGluc3RDbGFzc05hbWUgJiZcbiAgICAgICAgKCcgJyArIGluc3RDbGFzc05hbWUgKyAnICcpLmluZGV4T2YoJyAnICsgY2xhc3NOYW1lICsgJyAnKSAhPT0gLTFcbiAgICAgICk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIExpa2Ugc2NyeVJlbmRlcmVkRE9NQ29tcG9uZW50c1dpdGhDbGFzcyBidXQgZXhwZWN0cyB0aGVyZSB0byBiZSBvbmUgcmVzdWx0LFxuICAgKiBhbmQgcmV0dXJucyB0aGF0IG9uZSByZXN1bHQsIG9yIHRocm93cyBleGNlcHRpb24gaWYgdGhlcmUgaXMgYW55IG90aGVyXG4gICAqIG51bWJlciBvZiBtYXRjaGVzIGJlc2lkZXMgb25lLlxuICAgKiBAcmV0dXJuIHshUmVhY3RET01Db21wb25lbnR9IFRoZSBvbmUgbWF0Y2guXG4gICAqL1xuICBmaW5kUmVuZGVyZWRET01Db21wb25lbnRXaXRoQ2xhc3M6IGZ1bmN0aW9uKHJvb3QsIGNsYXNzTmFtZSkge1xuICAgIHZhciBhbGwgPVxuICAgICAgUmVhY3RUZXN0VXRpbHMuc2NyeVJlbmRlcmVkRE9NQ29tcG9uZW50c1dpdGhDbGFzcyhyb290LCBjbGFzc05hbWUpO1xuICAgIGlmIChhbGwubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RpZCBub3QgZmluZCBleGFjdGx5IG9uZSBtYXRjaCBmb3IgY2xhc3M6JyArIGNsYXNzTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBhbGxbMF07XG4gIH0sXG5cblxuICAvKipcbiAgICogRmluZHMgYWxsIGluc3RhbmNlIG9mIGNvbXBvbmVudHMgaW4gdGhlIHJlbmRlcmVkIHRyZWUgdGhhdCBhcmUgRE9NXG4gICAqIGNvbXBvbmVudHMgd2l0aCB0aGUgdGFnIG5hbWUgbWF0Y2hpbmcgYHRhZ05hbWVgLlxuICAgKiBAcmV0dXJuIGFuIGFycmF5IG9mIGFsbCB0aGUgbWF0Y2hlcy5cbiAgICovXG4gIHNjcnlSZW5kZXJlZERPTUNvbXBvbmVudHNXaXRoVGFnOiBmdW5jdGlvbihyb290LCB0YWdOYW1lKSB7XG4gICAgcmV0dXJuIFJlYWN0VGVzdFV0aWxzLmZpbmRBbGxJblJlbmRlcmVkVHJlZShyb290LCBmdW5jdGlvbihpbnN0KSB7XG4gICAgICByZXR1cm4gUmVhY3RUZXN0VXRpbHMuaXNET01Db21wb25lbnQoaW5zdCkgJiZcbiAgICAgICAgICAgIGluc3QudGFnTmFtZSA9PT0gdGFnTmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBMaWtlIHNjcnlSZW5kZXJlZERPTUNvbXBvbmVudHNXaXRoVGFnIGJ1dCBleHBlY3RzIHRoZXJlIHRvIGJlIG9uZSByZXN1bHQsXG4gICAqIGFuZCByZXR1cm5zIHRoYXQgb25lIHJlc3VsdCwgb3IgdGhyb3dzIGV4Y2VwdGlvbiBpZiB0aGVyZSBpcyBhbnkgb3RoZXJcbiAgICogbnVtYmVyIG9mIG1hdGNoZXMgYmVzaWRlcyBvbmUuXG4gICAqIEByZXR1cm4geyFSZWFjdERPTUNvbXBvbmVudH0gVGhlIG9uZSBtYXRjaC5cbiAgICovXG4gIGZpbmRSZW5kZXJlZERPTUNvbXBvbmVudFdpdGhUYWc6IGZ1bmN0aW9uKHJvb3QsIHRhZ05hbWUpIHtcbiAgICB2YXIgYWxsID0gUmVhY3RUZXN0VXRpbHMuc2NyeVJlbmRlcmVkRE9NQ29tcG9uZW50c1dpdGhUYWcocm9vdCwgdGFnTmFtZSk7XG4gICAgaWYgKGFsbC5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRGlkIG5vdCBmaW5kIGV4YWN0bHkgb25lIG1hdGNoIGZvciB0YWc6JyArIHRhZ05hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gYWxsWzBdO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIEZpbmRzIGFsbCBpbnN0YW5jZXMgb2YgY29tcG9uZW50cyB3aXRoIHR5cGUgZXF1YWwgdG8gYGNvbXBvbmVudFR5cGVgLlxuICAgKiBAcmV0dXJuIGFuIGFycmF5IG9mIGFsbCB0aGUgbWF0Y2hlcy5cbiAgICovXG4gIHNjcnlSZW5kZXJlZENvbXBvbmVudHNXaXRoVHlwZTogZnVuY3Rpb24ocm9vdCwgY29tcG9uZW50VHlwZSkge1xuICAgIHJldHVybiBSZWFjdFRlc3RVdGlscy5maW5kQWxsSW5SZW5kZXJlZFRyZWUocm9vdCwgZnVuY3Rpb24oaW5zdCkge1xuICAgICAgcmV0dXJuIFJlYWN0VGVzdFV0aWxzLmlzQ29tcG9zaXRlQ29tcG9uZW50V2l0aFR5cGUoXG4gICAgICAgIGluc3QsXG4gICAgICAgIGNvbXBvbmVudFR5cGVcbiAgICAgICk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNhbWUgYXMgYHNjcnlSZW5kZXJlZENvbXBvbmVudHNXaXRoVHlwZWAgYnV0IGV4cGVjdHMgdGhlcmUgdG8gYmUgb25lIHJlc3VsdFxuICAgKiBhbmQgcmV0dXJucyB0aGF0IG9uZSByZXN1bHQsIG9yIHRocm93cyBleGNlcHRpb24gaWYgdGhlcmUgaXMgYW55IG90aGVyXG4gICAqIG51bWJlciBvZiBtYXRjaGVzIGJlc2lkZXMgb25lLlxuICAgKiBAcmV0dXJuIHshUmVhY3RDb21wb25lbnR9IFRoZSBvbmUgbWF0Y2guXG4gICAqL1xuICBmaW5kUmVuZGVyZWRDb21wb25lbnRXaXRoVHlwZTogZnVuY3Rpb24ocm9vdCwgY29tcG9uZW50VHlwZSkge1xuICAgIHZhciBhbGwgPSBSZWFjdFRlc3RVdGlscy5zY3J5UmVuZGVyZWRDb21wb25lbnRzV2l0aFR5cGUoXG4gICAgICByb290LFxuICAgICAgY29tcG9uZW50VHlwZVxuICAgICk7XG4gICAgaWYgKGFsbC5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0RpZCBub3QgZmluZCBleGFjdGx5IG9uZSBtYXRjaCBmb3IgY29tcG9uZW50VHlwZTonICsgY29tcG9uZW50VHlwZVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGFsbFswXTtcbiAgfSxcblxuICAvKipcbiAgICogUGFzcyBhIG1vY2tlZCBjb21wb25lbnQgbW9kdWxlIHRvIHRoaXMgbWV0aG9kIHRvIGF1Z21lbnQgaXQgd2l0aFxuICAgKiB1c2VmdWwgbWV0aG9kcyB0aGF0IGFsbG93IGl0IHRvIGJlIHVzZWQgYXMgYSBkdW1teSBSZWFjdCBjb21wb25lbnQuXG4gICAqIEluc3RlYWQgb2YgcmVuZGVyaW5nIGFzIHVzdWFsLCB0aGUgY29tcG9uZW50IHdpbGwgYmVjb21lIGEgc2ltcGxlXG4gICAqIDxkaXY+IGNvbnRhaW5pbmcgYW55IHByb3ZpZGVkIGNoaWxkcmVuLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbW9kdWxlIHRoZSBtb2NrIGZ1bmN0aW9uIG9iamVjdCBleHBvcnRlZCBmcm9tIGFcbiAgICogICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGUgdGhhdCBkZWZpbmVzIHRoZSBjb21wb25lbnQgdG8gYmUgbW9ja2VkXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gbW9ja1RhZ05hbWUgb3B0aW9uYWwgZHVtbXkgcm9vdCB0YWcgbmFtZSB0byByZXR1cm5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tIHJlbmRlciBtZXRob2QgKG92ZXJyaWRlc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZS5tb2NrVGFnTmFtZSBpZiBwcm92aWRlZClcbiAgICogQHJldHVybiB7b2JqZWN0fSB0aGUgUmVhY3RUZXN0VXRpbHMgb2JqZWN0IChmb3IgY2hhaW5pbmcpXG4gICAqL1xuICBtb2NrQ29tcG9uZW50OiBmdW5jdGlvbihtb2R1bGUsIG1vY2tUYWdOYW1lKSB7XG4gICAgdmFyIENvbnZlbmllbmNlQ29uc3RydWN0b3IgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbW9ja1RhZ05hbWUgPSBtb2NrVGFnTmFtZSB8fCBtb2R1bGUubW9ja1RhZ05hbWUgfHwgXCJkaXZcIjtcbiAgICAgICAgcmV0dXJuIFJlYWN0RE9NW21vY2tUYWdOYW1lXShudWxsLCB0aGlzLnByb3BzLmNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvcHlQcm9wZXJ0aWVzKG1vZHVsZSwgQ29udmVuaWVuY2VDb25zdHJ1Y3Rvcik7XG4gICAgbW9kdWxlLm1vY2tJbXBsZW1lbnRhdGlvbihDb252ZW5pZW5jZUNvbnN0cnVjdG9yKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTaW11bGF0ZXMgYSB0b3AgbGV2ZWwgZXZlbnQgYmVpbmcgZGlzcGF0Y2hlZCBmcm9tIGEgcmF3IGV2ZW50IHRoYXQgb2NjdXJlZFxuICAgKiBvbiBhbiBgRWxlbWVudGAgbm9kZS5cbiAgICogQHBhcmFtIHRvcExldmVsVHlwZSB7T2JqZWN0fSBBIHR5cGUgZnJvbSBgRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlc2BcbiAgICogQHBhcmFtIHshRWxlbWVudH0gbm9kZSBUaGUgZG9tIHRvIHNpbXVsYXRlIGFuIGV2ZW50IG9jY3VycmluZyBvbi5cbiAgICogQHBhcmFtIHs/RXZlbnR9IGZha2VOYXRpdmVFdmVudCBGYWtlIG5hdGl2ZSBldmVudCB0byB1c2UgaW4gU3ludGhldGljRXZlbnQuXG4gICAqL1xuICBzaW11bGF0ZU5hdGl2ZUV2ZW50T25Ob2RlOiBmdW5jdGlvbih0b3BMZXZlbFR5cGUsIG5vZGUsIGZha2VOYXRpdmVFdmVudCkge1xuICAgIGZha2VOYXRpdmVFdmVudC50YXJnZXQgPSBub2RlO1xuICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIuZGlzcGF0Y2hFdmVudChcbiAgICAgIHRvcExldmVsVHlwZSxcbiAgICAgIGZha2VOYXRpdmVFdmVudFxuICAgICk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNpbXVsYXRlcyBhIHRvcCBsZXZlbCBldmVudCBiZWluZyBkaXNwYXRjaGVkIGZyb20gYSByYXcgZXZlbnQgdGhhdCBvY2N1cmVkXG4gICAqIG9uIHRoZSBgUmVhY3RET01Db21wb25lbnRgIGBjb21wYC5cbiAgICogQHBhcmFtIHRvcExldmVsVHlwZSB7T2JqZWN0fSBBIHR5cGUgZnJvbSBgRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlc2AuXG4gICAqIEBwYXJhbSBjb21wIHshUmVhY3RET01Db21wb25lbnR9XG4gICAqIEBwYXJhbSB7P0V2ZW50fSBmYWtlTmF0aXZlRXZlbnQgRmFrZSBuYXRpdmUgZXZlbnQgdG8gdXNlIGluIFN5bnRoZXRpY0V2ZW50LlxuICAgKi9cbiAgc2ltdWxhdGVOYXRpdmVFdmVudE9uRE9NQ29tcG9uZW50OiBmdW5jdGlvbihcbiAgICAgIHRvcExldmVsVHlwZSxcbiAgICAgIGNvbXAsXG4gICAgICBmYWtlTmF0aXZlRXZlbnQpIHtcbiAgICBSZWFjdFRlc3RVdGlscy5zaW11bGF0ZU5hdGl2ZUV2ZW50T25Ob2RlKFxuICAgICAgdG9wTGV2ZWxUeXBlLFxuICAgICAgY29tcC5nZXRET01Ob2RlKCksXG4gICAgICBmYWtlTmF0aXZlRXZlbnRcbiAgICApO1xuICB9LFxuXG4gIG5hdGl2ZVRvdWNoRGF0YTogZnVuY3Rpb24oeCwgeSkge1xuICAgIHJldHVybiB7XG4gICAgICB0b3VjaGVzOiBbXG4gICAgICAgIHtwYWdlWDogeCwgcGFnZVk6IHl9XG4gICAgICBdXG4gICAgfTtcbiAgfSxcblxuICBTaW11bGF0ZTogbnVsbCxcbiAgU2ltdWxhdGVOYXRpdmU6IHt9XG59O1xuXG4vKipcbiAqIEV4cG9ydHM6XG4gKlxuICogLSBgUmVhY3RUZXN0VXRpbHMuU2ltdWxhdGUuY2xpY2soRWxlbWVudC9SZWFjdERPTUNvbXBvbmVudClgXG4gKiAtIGBSZWFjdFRlc3RVdGlscy5TaW11bGF0ZS5tb3VzZU1vdmUoRWxlbWVudC9SZWFjdERPTUNvbXBvbmVudClgXG4gKiAtIGBSZWFjdFRlc3RVdGlscy5TaW11bGF0ZS5jaGFuZ2UoRWxlbWVudC9SZWFjdERPTUNvbXBvbmVudClgXG4gKiAtIC4uLiAoQWxsIGtleXMgZnJvbSBldmVudCBwbHVnaW4gYGV2ZW50VHlwZXNgIG9iamVjdHMpXG4gKi9cbmZ1bmN0aW9uIG1ha2VTaW11bGF0b3IoZXZlbnRUeXBlKSB7XG4gIHJldHVybiBmdW5jdGlvbihkb21Db21wb25lbnRPck5vZGUsIGV2ZW50RGF0YSkge1xuICAgIHZhciBub2RlO1xuICAgIGlmIChSZWFjdFRlc3RVdGlscy5pc0RPTUNvbXBvbmVudChkb21Db21wb25lbnRPck5vZGUpKSB7XG4gICAgICBub2RlID0gZG9tQ29tcG9uZW50T3JOb2RlLmdldERPTU5vZGUoKTtcbiAgICB9IGVsc2UgaWYgKGRvbUNvbXBvbmVudE9yTm9kZS50YWdOYW1lKSB7XG4gICAgICBub2RlID0gZG9tQ29tcG9uZW50T3JOb2RlO1xuICAgIH1cblxuICAgIHZhciBmYWtlTmF0aXZlRXZlbnQgPSBuZXcgRXZlbnQoKTtcbiAgICBmYWtlTmF0aXZlRXZlbnQudGFyZ2V0ID0gbm9kZTtcbiAgICAvLyBXZSBkb24ndCB1c2UgU3ludGhldGljRXZlbnQuZ2V0UG9vbGVkIGluIG9yZGVyIHRvIG5vdCBoYXZlIHRvIHdvcnJ5IGFib3V0XG4gICAgLy8gcHJvcGVybHkgZGVzdHJveWluZyBhbnkgcHJvcGVydGllcyBhc3NpZ25lZCBmcm9tIGBldmVudERhdGFgIHVwb24gcmVsZWFzZVxuICAgIHZhciBldmVudCA9IG5ldyBTeW50aGV0aWNFdmVudChcbiAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5ldmVudE5hbWVEaXNwYXRjaENvbmZpZ3NbZXZlbnRUeXBlXSxcbiAgICAgIFJlYWN0TW91bnQuZ2V0SUQobm9kZSksXG4gICAgICBmYWtlTmF0aXZlRXZlbnRcbiAgICApO1xuICAgIG1lcmdlSW50byhldmVudCwgZXZlbnREYXRhKTtcbiAgICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuXG4gICAgUmVhY3RVcGRhdGVzLmJhdGNoZWRVcGRhdGVzKGZ1bmN0aW9uKCkge1xuICAgICAgRXZlbnRQbHVnaW5IdWIuZW5xdWV1ZUV2ZW50cyhldmVudCk7XG4gICAgICBFdmVudFBsdWdpbkh1Yi5wcm9jZXNzRXZlbnRRdWV1ZSgpO1xuICAgIH0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiBidWlsZFNpbXVsYXRvcnMoKSB7XG4gIFJlYWN0VGVzdFV0aWxzLlNpbXVsYXRlID0ge307XG5cbiAgdmFyIGV2ZW50VHlwZTtcbiAgZm9yIChldmVudFR5cGUgaW4gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmV2ZW50TmFtZURpc3BhdGNoQ29uZmlncykge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IUVsZW1lbnQgfHwgUmVhY3RET01Db21wb25lbnR9IGRvbUNvbXBvbmVudE9yTm9kZVxuICAgICAqIEBwYXJhbSB7P29iamVjdH0gZXZlbnREYXRhIEZha2UgZXZlbnQgZGF0YSB0byB1c2UgaW4gU3ludGhldGljRXZlbnQuXG4gICAgICovXG4gICAgUmVhY3RUZXN0VXRpbHMuU2ltdWxhdGVbZXZlbnRUeXBlXSA9IG1ha2VTaW11bGF0b3IoZXZlbnRUeXBlKTtcbiAgfVxufVxuXG4vLyBSZWJ1aWxkIFJlYWN0VGVzdFV0aWxzLlNpbXVsYXRlIHdoZW5ldmVyIGV2ZW50IHBsdWdpbnMgYXJlIGluamVjdGVkXG52YXIgb2xkSW5qZWN0RXZlbnRQbHVnaW5PcmRlciA9IEV2ZW50UGx1Z2luSHViLmluamVjdGlvbi5pbmplY3RFdmVudFBsdWdpbk9yZGVyO1xuRXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luT3JkZXIgPSBmdW5jdGlvbigpIHtcbiAgb2xkSW5qZWN0RXZlbnRQbHVnaW5PcmRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICBidWlsZFNpbXVsYXRvcnMoKTtcbn07XG52YXIgb2xkSW5qZWN0RXZlbnRQbHVnaW5zID0gRXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luc0J5TmFtZTtcbkV2ZW50UGx1Z2luSHViLmluamVjdGlvbi5pbmplY3RFdmVudFBsdWdpbnNCeU5hbWUgPSBmdW5jdGlvbigpIHtcbiAgb2xkSW5qZWN0RXZlbnRQbHVnaW5zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIGJ1aWxkU2ltdWxhdG9ycygpO1xufTtcblxuYnVpbGRTaW11bGF0b3JzKCk7XG5cbi8qKlxuICogRXhwb3J0czpcbiAqXG4gKiAtIGBSZWFjdFRlc3RVdGlscy5TaW11bGF0ZU5hdGl2ZS5jbGljayhFbGVtZW50L1JlYWN0RE9NQ29tcG9uZW50KWBcbiAqIC0gYFJlYWN0VGVzdFV0aWxzLlNpbXVsYXRlTmF0aXZlLm1vdXNlTW92ZShFbGVtZW50L1JlYWN0RE9NQ29tcG9uZW50KWBcbiAqIC0gYFJlYWN0VGVzdFV0aWxzLlNpbXVsYXRlTmF0aXZlLm1vdXNlSW4vUmVhY3RET01Db21wb25lbnQpYFxuICogLSBgUmVhY3RUZXN0VXRpbHMuU2ltdWxhdGVOYXRpdmUubW91c2VPdXQoRWxlbWVudC9SZWFjdERPTUNvbXBvbmVudClgXG4gKiAtIC4uLiAoQWxsIGtleXMgZnJvbSBgRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlc2ApXG4gKlxuICogTm90ZTogVG9wIGxldmVsIGV2ZW50IHR5cGVzIGFyZSBhIHN1YnNldCBvZiB0aGUgZW50aXJlIHNldCBvZiBoYW5kbGVyIHR5cGVzXG4gKiAod2hpY2ggaW5jbHVkZSBhIGJyb2FkZXIgc2V0IG9mIFwic3ludGhldGljXCIgZXZlbnRzKS4gRm9yIGV4YW1wbGUsIG9uRHJhZ0RvbmVcbiAqIGlzIGEgc3ludGhldGljIGV2ZW50LiBFeGNlcHQgd2hlbiB0ZXN0aW5nIGFuIGV2ZW50IHBsdWdpbiBvciBSZWFjdCdzIGV2ZW50XG4gKiBoYW5kbGluZyBjb2RlIHNwZWNpZmljYWxseSwgeW91IHByb2JhYmx5IHdhbnQgdG8gdXNlIFJlYWN0VGVzdFV0aWxzLlNpbXVsYXRlXG4gKiB0byBkaXNwYXRjaCBzeW50aGV0aWMgZXZlbnRzLlxuICovXG5cbmZ1bmN0aW9uIG1ha2VOYXRpdmVTaW11bGF0b3IoZXZlbnRUeXBlKSB7XG4gIHJldHVybiBmdW5jdGlvbihkb21Db21wb25lbnRPck5vZGUsIG5hdGl2ZUV2ZW50RGF0YSkge1xuICAgIHZhciBmYWtlTmF0aXZlRXZlbnQgPSBuZXcgRXZlbnQoZXZlbnRUeXBlKTtcbiAgICBtZXJnZUludG8oZmFrZU5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudERhdGEpO1xuICAgIGlmIChSZWFjdFRlc3RVdGlscy5pc0RPTUNvbXBvbmVudChkb21Db21wb25lbnRPck5vZGUpKSB7XG4gICAgICBSZWFjdFRlc3RVdGlscy5zaW11bGF0ZU5hdGl2ZUV2ZW50T25ET01Db21wb25lbnQoXG4gICAgICAgIGV2ZW50VHlwZSxcbiAgICAgICAgZG9tQ29tcG9uZW50T3JOb2RlLFxuICAgICAgICBmYWtlTmF0aXZlRXZlbnRcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICghIWRvbUNvbXBvbmVudE9yTm9kZS50YWdOYW1lKSB7XG4gICAgICAvLyBXaWxsIGFsbG93IG9uIGFjdHVhbCBkb20gbm9kZXMuXG4gICAgICBSZWFjdFRlc3RVdGlscy5zaW11bGF0ZU5hdGl2ZUV2ZW50T25Ob2RlKFxuICAgICAgICBldmVudFR5cGUsXG4gICAgICAgIGRvbUNvbXBvbmVudE9yTm9kZSxcbiAgICAgICAgZmFrZU5hdGl2ZUV2ZW50XG4gICAgICApO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIGV2ZW50VHlwZTtcbmZvciAoZXZlbnRUeXBlIGluIHRvcExldmVsVHlwZXMpIHtcbiAgLy8gRXZlbnQgdHlwZSBpcyBzdG9yZWQgYXMgJ3RvcENsaWNrJyAtIHdlIHRyYW5zZm9ybSB0aGF0IHRvICdjbGljaydcbiAgdmFyIGNvbnZlbmllbmNlTmFtZSA9IGV2ZW50VHlwZS5pbmRleE9mKCd0b3AnKSA9PT0gMCA/XG4gICAgZXZlbnRUeXBlLmNoYXJBdCgzKS50b0xvd2VyQ2FzZSgpICsgZXZlbnRUeXBlLnN1YnN0cig0KSA6IGV2ZW50VHlwZTtcbiAgLyoqXG4gICAqIEBwYXJhbSB7IUVsZW1lbnQgfHwgUmVhY3RET01Db21wb25lbnR9IGRvbUNvbXBvbmVudE9yTm9kZVxuICAgKiBAcGFyYW0gez9FdmVudH0gbmF0aXZlRXZlbnREYXRhIEZha2UgbmF0aXZlIGV2ZW50IHRvIHVzZSBpbiBTeW50aGV0aWNFdmVudC5cbiAgICovXG4gIFJlYWN0VGVzdFV0aWxzLlNpbXVsYXRlTmF0aXZlW2NvbnZlbmllbmNlTmFtZV0gPVxuICAgIG1ha2VOYXRpdmVTaW11bGF0b3IoZXZlbnRUeXBlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFRlc3RVdGlscztcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFRleHRDb21wb25lbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBET01Qcm9wZXJ0eU9wZXJhdGlvbnMgPSByZXF1aXJlKFwiLi9ET01Qcm9wZXJ0eU9wZXJhdGlvbnNcIik7XG52YXIgUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW4gPSByZXF1aXJlKFwiLi9SZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpblwiKTtcbnZhciBSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoXCIuL1JlYWN0Q29tcG9uZW50XCIpO1xudmFyIFJlYWN0RGVzY3JpcHRvciA9IHJlcXVpcmUoXCIuL1JlYWN0RGVzY3JpcHRvclwiKTtcblxudmFyIGVzY2FwZVRleHRGb3JCcm93c2VyID0gcmVxdWlyZShcIi4vZXNjYXBlVGV4dEZvckJyb3dzZXJcIik7XG52YXIgbWl4SW50byA9IHJlcXVpcmUoXCIuL21peEludG9cIik7XG5cbi8qKlxuICogVGV4dCBub2RlcyB2aW9sYXRlIGEgY291cGxlIGFzc3VtcHRpb25zIHRoYXQgUmVhY3QgbWFrZXMgYWJvdXQgY29tcG9uZW50czpcbiAqXG4gKiAgLSBXaGVuIG1vdW50aW5nIHRleHQgaW50byB0aGUgRE9NLCBhZGphY2VudCB0ZXh0IG5vZGVzIGFyZSBtZXJnZWQuXG4gKiAgLSBUZXh0IG5vZGVzIGNhbm5vdCBiZSBhc3NpZ25lZCBhIFJlYWN0IHJvb3QgSUQuXG4gKlxuICogVGhpcyBjb21wb25lbnQgaXMgdXNlZCB0byB3cmFwIHN0cmluZ3MgaW4gZWxlbWVudHMgc28gdGhhdCB0aGV5IGNhbiB1bmRlcmdvXG4gKiB0aGUgc2FtZSByZWNvbmNpbGlhdGlvbiB0aGF0IGlzIGFwcGxpZWQgdG8gZWxlbWVudHMuXG4gKlxuICogVE9ETzogSW52ZXN0aWdhdGUgcmVwcmVzZW50aW5nIFJlYWN0IGNvbXBvbmVudHMgaW4gdGhlIERPTSB3aXRoIHRleHQgbm9kZXMuXG4gKlxuICogQGNsYXNzIFJlYWN0VGV4dENvbXBvbmVudFxuICogQGV4dGVuZHMgUmVhY3RDb21wb25lbnRcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RUZXh0Q29tcG9uZW50ID0gZnVuY3Rpb24oZGVzY3JpcHRvcikge1xuICB0aGlzLmNvbnN0cnVjdChkZXNjcmlwdG9yKTtcbn07XG5cbm1peEludG8oUmVhY3RUZXh0Q29tcG9uZW50LCBSZWFjdENvbXBvbmVudC5NaXhpbik7XG5taXhJbnRvKFJlYWN0VGV4dENvbXBvbmVudCwgUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW4pO1xubWl4SW50byhSZWFjdFRleHRDb21wb25lbnQsIHtcblxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgbWFya3VwIGZvciB0aGlzIHRleHQgbm9kZS4gVGhpcyBub2RlIGlzIG5vdCBpbnRlbmRlZCB0byBoYXZlXG4gICAqIGFueSBmZWF0dXJlcyBiZXNpZGVzIGNvbnRhaW5pbmcgdGV4dCBjb250ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcm9vdElEIERPTSBJRCBvZiB0aGUgcm9vdCBub2RlLlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1vdW50RGVwdGggbnVtYmVyIG9mIGNvbXBvbmVudHMgaW4gdGhlIG93bmVyIGhpZXJhcmNoeVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IE1hcmt1cCBmb3IgdGhpcyB0ZXh0IG5vZGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgbW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uKHJvb3RJRCwgdHJhbnNhY3Rpb24sIG1vdW50RGVwdGgpIHtcbiAgICBSZWFjdENvbXBvbmVudC5NaXhpbi5tb3VudENvbXBvbmVudC5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgIHJvb3RJRCxcbiAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgbW91bnREZXB0aFxuICAgICk7XG5cbiAgICB2YXIgZXNjYXBlZFRleHQgPSBlc2NhcGVUZXh0Rm9yQnJvd3Nlcih0aGlzLnByb3BzKTtcblxuICAgIGlmICh0cmFuc2FjdGlvbi5yZW5kZXJUb1N0YXRpY01hcmt1cCkge1xuICAgICAgLy8gTm9ybWFsbHkgd2UnZCB3cmFwIHRoaXMgaW4gYSBgc3BhbmAgZm9yIHRoZSByZWFzb25zIHN0YXRlZCBhYm92ZSwgYnV0XG4gICAgICAvLyBzaW5jZSB0aGlzIGlzIGEgc2l0dWF0aW9uIHdoZXJlIFJlYWN0IHdvbid0IHRha2Ugb3ZlciAoc3RhdGljIHBhZ2VzKSxcbiAgICAgIC8vIHdlIGNhbiBzaW1wbHkgcmV0dXJuIHRoZSB0ZXh0IGFzIGl0IGlzLlxuICAgICAgcmV0dXJuIGVzY2FwZWRUZXh0O1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAnPHNwYW4gJyArIERPTVByb3BlcnR5T3BlcmF0aW9ucy5jcmVhdGVNYXJrdXBGb3JJRChyb290SUQpICsgJz4nICtcbiAgICAgICAgZXNjYXBlZFRleHQgK1xuICAgICAgJzwvc3Bhbj4nXG4gICAgKTtcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGlzIGNvbXBvbmVudCBieSB1cGRhdGluZyB0aGUgdGV4dCBjb250ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dENvbXBvbmVudCBDb250YWlucyB0aGUgbmV4dCB0ZXh0IGNvbnRlbnQuXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQGludGVybmFsXG4gICAqL1xuICByZWNlaXZlQ29tcG9uZW50OiBmdW5jdGlvbihuZXh0Q29tcG9uZW50LCB0cmFuc2FjdGlvbikge1xuICAgIHZhciBuZXh0UHJvcHMgPSBuZXh0Q29tcG9uZW50LnByb3BzO1xuICAgIGlmIChuZXh0UHJvcHMgIT09IHRoaXMucHJvcHMpIHtcbiAgICAgIHRoaXMucHJvcHMgPSBuZXh0UHJvcHM7XG4gICAgICBSZWFjdENvbXBvbmVudC5CYWNrZW5kSURPcGVyYXRpb25zLnVwZGF0ZVRleHRDb250ZW50QnlJRChcbiAgICAgICAgdGhpcy5fcm9vdE5vZGVJRCxcbiAgICAgICAgbmV4dFByb3BzXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERlc2NyaXB0b3IuY3JlYXRlRmFjdG9yeShSZWFjdFRleHRDb21wb25lbnQpO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFRyYW5zaXRpb25DaGlsZE1hcHBpbmdcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIFJlYWN0Q2hpbGRyZW4gPSByZXF1aXJlKFwiLi9SZWFjdENoaWxkcmVuXCIpO1xuXG52YXIgUmVhY3RUcmFuc2l0aW9uQ2hpbGRNYXBwaW5nID0ge1xuICAvKipcbiAgICogR2l2ZW4gYHRoaXMucHJvcHMuY2hpbGRyZW5gLCByZXR1cm4gYW4gb2JqZWN0IG1hcHBpbmcga2V5IHRvIGNoaWxkLiBKdXN0XG4gICAqIHNpbXBsZSBzeW50YWN0aWMgc3VnYXIgYXJvdW5kIFJlYWN0Q2hpbGRyZW4ubWFwKCkuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gY2hpbGRyZW4gYHRoaXMucHJvcHMuY2hpbGRyZW5gXG4gICAqIEByZXR1cm4ge29iamVjdH0gTWFwcGluZyBvZiBrZXkgdG8gY2hpbGRcbiAgICovXG4gIGdldENoaWxkTWFwcGluZzogZnVuY3Rpb24oY2hpbGRyZW4pIHtcbiAgICByZXR1cm4gUmVhY3RDaGlsZHJlbi5tYXAoY2hpbGRyZW4sIGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdoZW4geW91J3JlIGFkZGluZyBvciByZW1vdmluZyBjaGlsZHJlbiBzb21lIG1heSBiZSBhZGRlZCBvciByZW1vdmVkIGluIHRoZVxuICAgKiBzYW1lIHJlbmRlciBwYXNzLiBXZSB3YW50IG90IHNob3cgKmJvdGgqIHNpbmNlIHdlIHdhbnQgdG8gc2ltdWx0YW5lb3VzbHlcbiAgICogYW5pbWF0ZSBlbGVtZW50cyBpbiBhbmQgb3V0LiBUaGlzIGZ1bmN0aW9uIHRha2VzIGEgcHJldmlvdXMgc2V0IG9mIGtleXNcbiAgICogYW5kIGEgbmV3IHNldCBvZiBrZXlzIGFuZCBtZXJnZXMgdGhlbSB3aXRoIGl0cyBiZXN0IGd1ZXNzIG9mIHRoZSBjb3JyZWN0XG4gICAqIG9yZGVyaW5nLiBJbiB0aGUgZnV0dXJlIHdlIG1heSBleHBvc2Ugc29tZSBvZiB0aGUgdXRpbGl0aWVzIGluXG4gICAqIFJlYWN0TXVsdGlDaGlsZCB0byBtYWtlIHRoaXMgZWFzeSwgYnV0IGZvciBub3cgUmVhY3QgaXRzZWxmIGRvZXMgbm90XG4gICAqIGRpcmVjdGx5IGhhdmUgdGhpcyBjb25jZXB0IG9mIHRoZSB1bmlvbiBvZiBwcmV2Q2hpbGRyZW4gYW5kIG5leHRDaGlsZHJlblxuICAgKiBzbyB3ZSBpbXBsZW1lbnQgaXQgaGVyZS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHByZXYgcHJldiBjaGlsZHJlbiBhcyByZXR1cm5lZCBmcm9tXG4gICAqIGBSZWFjdFRyYW5zaXRpb25DaGlsZE1hcHBpbmcuZ2V0Q2hpbGRNYXBwaW5nKClgLlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dCBuZXh0IGNoaWxkcmVuIGFzIHJldHVybmVkIGZyb21cbiAgICogYFJlYWN0VHJhbnNpdGlvbkNoaWxkTWFwcGluZy5nZXRDaGlsZE1hcHBpbmcoKWAuXG4gICAqIEByZXR1cm4ge29iamVjdH0gYSBrZXkgc2V0IHRoYXQgY29udGFpbnMgYWxsIGtleXMgaW4gYHByZXZgIGFuZCBhbGwga2V5c1xuICAgKiBpbiBgbmV4dGAgaW4gYSByZWFzb25hYmxlIG9yZGVyLlxuICAgKi9cbiAgbWVyZ2VDaGlsZE1hcHBpbmdzOiBmdW5jdGlvbihwcmV2LCBuZXh0KSB7XG4gICAgcHJldiA9IHByZXYgfHwge307XG4gICAgbmV4dCA9IG5leHQgfHwge307XG5cbiAgICBmdW5jdGlvbiBnZXRWYWx1ZUZvcktleShrZXkpIHtcbiAgICAgIGlmIChuZXh0Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgcmV0dXJuIG5leHRba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwcmV2W2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRm9yIGVhY2gga2V5IG9mIGBuZXh0YCwgdGhlIGxpc3Qgb2Yga2V5cyB0byBpbnNlcnQgYmVmb3JlIHRoYXQga2V5IGluXG4gICAgLy8gdGhlIGNvbWJpbmVkIGxpc3RcbiAgICB2YXIgbmV4dEtleXNQZW5kaW5nID0ge307XG5cbiAgICB2YXIgcGVuZGluZ0tleXMgPSBbXTtcbiAgICBmb3IgKHZhciBwcmV2S2V5IGluIHByZXYpIHtcbiAgICAgIGlmIChuZXh0Lmhhc093blByb3BlcnR5KHByZXZLZXkpKSB7XG4gICAgICAgIGlmIChwZW5kaW5nS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICBuZXh0S2V5c1BlbmRpbmdbcHJldktleV0gPSBwZW5kaW5nS2V5cztcbiAgICAgICAgICBwZW5kaW5nS2V5cyA9IFtdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZW5kaW5nS2V5cy5wdXNoKHByZXZLZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpO1xuICAgIHZhciBjaGlsZE1hcHBpbmcgPSB7fTtcbiAgICBmb3IgKHZhciBuZXh0S2V5IGluIG5leHQpIHtcbiAgICAgIGlmIChuZXh0S2V5c1BlbmRpbmcuaGFzT3duUHJvcGVydHkobmV4dEtleSkpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG5leHRLZXlzUGVuZGluZ1tuZXh0S2V5XS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBwZW5kaW5nTmV4dEtleSA9IG5leHRLZXlzUGVuZGluZ1tuZXh0S2V5XVtpXTtcbiAgICAgICAgICBjaGlsZE1hcHBpbmdbbmV4dEtleXNQZW5kaW5nW25leHRLZXldW2ldXSA9IGdldFZhbHVlRm9yS2V5KFxuICAgICAgICAgICAgcGVuZGluZ05leHRLZXlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjaGlsZE1hcHBpbmdbbmV4dEtleV0gPSBnZXRWYWx1ZUZvcktleShuZXh0S2V5KTtcbiAgICB9XG5cbiAgICAvLyBGaW5hbGx5LCBhZGQgdGhlIGtleXMgd2hpY2ggZGlkbid0IGFwcGVhciBiZWZvcmUgYW55IGtleSBpbiBgbmV4dGBcbiAgICBmb3IgKGkgPSAwOyBpIDwgcGVuZGluZ0tleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkTWFwcGluZ1twZW5kaW5nS2V5c1tpXV0gPSBnZXRWYWx1ZUZvcktleShwZW5kaW5nS2V5c1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoaWxkTWFwcGluZztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFRyYW5zaXRpb25DaGlsZE1hcHBpbmc7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RUcmFuc2l0aW9uRXZlbnRzXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoXCIuL0V4ZWN1dGlvbkVudmlyb25tZW50XCIpO1xuXG4vKipcbiAqIEVWRU5UX05BTUVfTUFQIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIGV2ZW50IGZpcmVkIHdoZW4gYVxuICogdHJhbnNpdGlvbi9hbmltYXRpb24gZW5kcywgYmFzZWQgb24gdGhlIHN0eWxlIHByb3BlcnR5IHVzZWQgdG9cbiAqIGRlZmluZSB0aGF0IGV2ZW50LlxuICovXG52YXIgRVZFTlRfTkFNRV9NQVAgPSB7XG4gIHRyYW5zaXRpb25lbmQ6IHtcbiAgICAndHJhbnNpdGlvbic6ICd0cmFuc2l0aW9uZW5kJyxcbiAgICAnV2Via2l0VHJhbnNpdGlvbic6ICd3ZWJraXRUcmFuc2l0aW9uRW5kJyxcbiAgICAnTW96VHJhbnNpdGlvbic6ICdtb3pUcmFuc2l0aW9uRW5kJyxcbiAgICAnT1RyYW5zaXRpb24nOiAnb1RyYW5zaXRpb25FbmQnLFxuICAgICdtc1RyYW5zaXRpb24nOiAnTVNUcmFuc2l0aW9uRW5kJ1xuICB9LFxuXG4gIGFuaW1hdGlvbmVuZDoge1xuICAgICdhbmltYXRpb24nOiAnYW5pbWF0aW9uZW5kJyxcbiAgICAnV2Via2l0QW5pbWF0aW9uJzogJ3dlYmtpdEFuaW1hdGlvbkVuZCcsXG4gICAgJ01vekFuaW1hdGlvbic6ICdtb3pBbmltYXRpb25FbmQnLFxuICAgICdPQW5pbWF0aW9uJzogJ29BbmltYXRpb25FbmQnLFxuICAgICdtc0FuaW1hdGlvbic6ICdNU0FuaW1hdGlvbkVuZCdcbiAgfVxufTtcblxudmFyIGVuZEV2ZW50cyA9IFtdO1xuXG5mdW5jdGlvbiBkZXRlY3RFdmVudHMoKSB7XG4gIHZhciB0ZXN0RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdmFyIHN0eWxlID0gdGVzdEVsLnN0eWxlO1xuXG4gIC8vIE9uIHNvbWUgcGxhdGZvcm1zLCBpbiBwYXJ0aWN1bGFyIHNvbWUgcmVsZWFzZXMgb2YgQW5kcm9pZCA0LngsXG4gIC8vIHRoZSB1bi1wcmVmaXhlZCBcImFuaW1hdGlvblwiIGFuZCBcInRyYW5zaXRpb25cIiBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkIG9uIHRoZVxuICAvLyBzdHlsZSBvYmplY3QgYnV0IHRoZSBldmVudHMgdGhhdCBmaXJlIHdpbGwgc3RpbGwgYmUgcHJlZml4ZWQsIHNvIHdlIG5lZWRcbiAgLy8gdG8gY2hlY2sgaWYgdGhlIHVuLXByZWZpeGVkIGV2ZW50cyBhcmUgdXNlYWJsZSwgYW5kIGlmIG5vdCByZW1vdmUgdGhlbVxuICAvLyBmcm9tIHRoZSBtYXBcbiAgaWYgKCEoJ0FuaW1hdGlvbkV2ZW50JyBpbiB3aW5kb3cpKSB7XG4gICAgZGVsZXRlIEVWRU5UX05BTUVfTUFQLmFuaW1hdGlvbmVuZC5hbmltYXRpb247XG4gIH1cblxuICBpZiAoISgnVHJhbnNpdGlvbkV2ZW50JyBpbiB3aW5kb3cpKSB7XG4gICAgZGVsZXRlIEVWRU5UX05BTUVfTUFQLnRyYW5zaXRpb25lbmQudHJhbnNpdGlvbjtcbiAgfVxuXG4gIGZvciAodmFyIGJhc2VFdmVudE5hbWUgaW4gRVZFTlRfTkFNRV9NQVApIHtcbiAgICB2YXIgYmFzZUV2ZW50cyA9IEVWRU5UX05BTUVfTUFQW2Jhc2VFdmVudE5hbWVdO1xuICAgIGZvciAodmFyIHN0eWxlTmFtZSBpbiBiYXNlRXZlbnRzKSB7XG4gICAgICBpZiAoc3R5bGVOYW1lIGluIHN0eWxlKSB7XG4gICAgICAgIGVuZEV2ZW50cy5wdXNoKGJhc2VFdmVudHNbc3R5bGVOYW1lXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIGRldGVjdEV2ZW50cygpO1xufVxuXG4vLyBXZSB1c2UgdGhlIHJhdyB7YWRkfHJlbW92ZX1FdmVudExpc3RlbmVyKCkgY2FsbCBiZWNhdXNlIEV2ZW50TGlzdGVuZXJcbi8vIGRvZXMgbm90IGtub3cgaG93IHRvIHJlbW92ZSBldmVudCBsaXN0ZW5lcnMgYW5kIHdlIHJlYWxseSBzaG91bGRcbi8vIGNsZWFuIHVwLiBBbHNvLCB0aGVzZSBldmVudHMgYXJlIG5vdCB0cmlnZ2VyZWQgaW4gb2xkZXIgYnJvd3NlcnNcbi8vIHNvIHdlIHNob3VsZCBiZSBBLU9LIGhlcmUuXG5cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIobm9kZSwgZXZlbnROYW1lLCBldmVudExpc3RlbmVyKSB7XG4gIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGV2ZW50TGlzdGVuZXIsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihub2RlLCBldmVudE5hbWUsIGV2ZW50TGlzdGVuZXIpIHtcbiAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZXZlbnRMaXN0ZW5lciwgZmFsc2UpO1xufVxuXG52YXIgUmVhY3RUcmFuc2l0aW9uRXZlbnRzID0ge1xuICBhZGRFbmRFdmVudExpc3RlbmVyOiBmdW5jdGlvbihub2RlLCBldmVudExpc3RlbmVyKSB7XG4gICAgaWYgKGVuZEV2ZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIElmIENTUyB0cmFuc2l0aW9ucyBhcmUgbm90IHN1cHBvcnRlZCwgdHJpZ2dlciBhbiBcImVuZCBhbmltYXRpb25cIlxuICAgICAgLy8gZXZlbnQgaW1tZWRpYXRlbHkuXG4gICAgICB3aW5kb3cuc2V0VGltZW91dChldmVudExpc3RlbmVyLCAwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZW5kRXZlbnRzLmZvckVhY2goZnVuY3Rpb24oZW5kRXZlbnQpIHtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIobm9kZSwgZW5kRXZlbnQsIGV2ZW50TGlzdGVuZXIpO1xuICAgIH0pO1xuICB9LFxuXG4gIHJlbW92ZUVuZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKG5vZGUsIGV2ZW50TGlzdGVuZXIpIHtcbiAgICBpZiAoZW5kRXZlbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbmRFdmVudHMuZm9yRWFjaChmdW5jdGlvbihlbmRFdmVudCkge1xuICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihub2RlLCBlbmRFdmVudCwgZXZlbnRMaXN0ZW5lcik7XG4gICAgfSk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RUcmFuc2l0aW9uRXZlbnRzO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0VHJhbnNpdGlvbkdyb3VwXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoXCIuL1JlYWN0XCIpO1xudmFyIFJlYWN0VHJhbnNpdGlvbkNoaWxkTWFwcGluZyA9IHJlcXVpcmUoXCIuL1JlYWN0VHJhbnNpdGlvbkNoaWxkTWFwcGluZ1wiKTtcblxudmFyIGNsb25lV2l0aFByb3BzID0gcmVxdWlyZShcIi4vY2xvbmVXaXRoUHJvcHNcIik7XG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoXCIuL2VtcHR5RnVuY3Rpb25cIik7XG52YXIgbWVyZ2UgPSByZXF1aXJlKFwiLi9tZXJnZVwiKTtcblxudmFyIFJlYWN0VHJhbnNpdGlvbkdyb3VwID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ1JlYWN0VHJhbnNpdGlvbkdyb3VwJyxcblxuICBwcm9wVHlwZXM6IHtcbiAgICBjb21wb25lbnQ6IFJlYWN0LlByb3BUeXBlcy5mdW5jLFxuICAgIGNoaWxkRmFjdG9yeTogUmVhY3QuUHJvcFR5cGVzLmZ1bmNcbiAgfSxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21wb25lbnQ6IFJlYWN0LkRPTS5zcGFuLFxuICAgICAgY2hpbGRGYWN0b3J5OiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnRcbiAgICB9O1xuICB9LFxuXG4gIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNoaWxkcmVuOiBSZWFjdFRyYW5zaXRpb25DaGlsZE1hcHBpbmcuZ2V0Q2hpbGRNYXBwaW5nKHRoaXMucHJvcHMuY2hpbGRyZW4pXG4gICAgfTtcbiAgfSxcblxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbihuZXh0UHJvcHMpIHtcbiAgICB2YXIgbmV4dENoaWxkTWFwcGluZyA9IFJlYWN0VHJhbnNpdGlvbkNoaWxkTWFwcGluZy5nZXRDaGlsZE1hcHBpbmcoXG4gICAgICBuZXh0UHJvcHMuY2hpbGRyZW5cbiAgICApO1xuICAgIHZhciBwcmV2Q2hpbGRNYXBwaW5nID0gdGhpcy5zdGF0ZS5jaGlsZHJlbjtcblxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgY2hpbGRyZW46IFJlYWN0VHJhbnNpdGlvbkNoaWxkTWFwcGluZy5tZXJnZUNoaWxkTWFwcGluZ3MoXG4gICAgICAgIHByZXZDaGlsZE1hcHBpbmcsXG4gICAgICAgIG5leHRDaGlsZE1hcHBpbmdcbiAgICAgIClcbiAgICB9KTtcblxuICAgIHZhciBrZXk7XG5cbiAgICBmb3IgKGtleSBpbiBuZXh0Q2hpbGRNYXBwaW5nKSB7XG4gICAgICB2YXIgaGFzUHJldiA9IHByZXZDaGlsZE1hcHBpbmcgJiYgcHJldkNoaWxkTWFwcGluZy5oYXNPd25Qcm9wZXJ0eShrZXkpO1xuICAgICAgaWYgKG5leHRDaGlsZE1hcHBpbmdba2V5XSAmJiAhaGFzUHJldiAmJlxuICAgICAgICAgICF0aGlzLmN1cnJlbnRseVRyYW5zaXRpb25pbmdLZXlzW2tleV0pIHtcbiAgICAgICAgdGhpcy5rZXlzVG9FbnRlci5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChrZXkgaW4gcHJldkNoaWxkTWFwcGluZykge1xuICAgICAgdmFyIGhhc05leHQgPSBuZXh0Q2hpbGRNYXBwaW5nICYmIG5leHRDaGlsZE1hcHBpbmcuaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgICAgIGlmIChwcmV2Q2hpbGRNYXBwaW5nW2tleV0gJiYgIWhhc05leHQgJiZcbiAgICAgICAgICAhdGhpcy5jdXJyZW50bHlUcmFuc2l0aW9uaW5nS2V5c1trZXldKSB7XG4gICAgICAgIHRoaXMua2V5c1RvTGVhdmUucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHdlIHdhbnQgdG8gc29tZWRheSBjaGVjayBmb3IgcmVvcmRlcmluZywgd2UgY291bGQgZG8gaXQgaGVyZS5cbiAgfSxcblxuICBjb21wb25lbnRXaWxsTW91bnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY3VycmVudGx5VHJhbnNpdGlvbmluZ0tleXMgPSB7fTtcbiAgICB0aGlzLmtleXNUb0VudGVyID0gW107XG4gICAgdGhpcy5rZXlzVG9MZWF2ZSA9IFtdO1xuICB9LFxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGtleXNUb0VudGVyID0gdGhpcy5rZXlzVG9FbnRlcjtcbiAgICB0aGlzLmtleXNUb0VudGVyID0gW107XG4gICAga2V5c1RvRW50ZXIuZm9yRWFjaCh0aGlzLnBlcmZvcm1FbnRlcik7XG5cbiAgICB2YXIga2V5c1RvTGVhdmUgPSB0aGlzLmtleXNUb0xlYXZlO1xuICAgIHRoaXMua2V5c1RvTGVhdmUgPSBbXTtcbiAgICBrZXlzVG9MZWF2ZS5mb3JFYWNoKHRoaXMucGVyZm9ybUxlYXZlKTtcbiAgfSxcblxuICBwZXJmb3JtRW50ZXI6IGZ1bmN0aW9uKGtleSkge1xuICAgIHRoaXMuY3VycmVudGx5VHJhbnNpdGlvbmluZ0tleXNba2V5XSA9IHRydWU7XG5cbiAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5yZWZzW2tleV07XG5cbiAgICBpZiAoY29tcG9uZW50LmNvbXBvbmVudFdpbGxFbnRlcikge1xuICAgICAgY29tcG9uZW50LmNvbXBvbmVudFdpbGxFbnRlcihcbiAgICAgICAgdGhpcy5faGFuZGxlRG9uZUVudGVyaW5nLmJpbmQodGhpcywga2V5KVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faGFuZGxlRG9uZUVudGVyaW5nKGtleSk7XG4gICAgfVxuICB9LFxuXG4gIF9oYW5kbGVEb25lRW50ZXJpbmc6IGZ1bmN0aW9uKGtleSkge1xuICAgIHZhciBjb21wb25lbnQgPSB0aGlzLnJlZnNba2V5XTtcbiAgICBpZiAoY29tcG9uZW50LmNvbXBvbmVudERpZEVudGVyKSB7XG4gICAgICBjb21wb25lbnQuY29tcG9uZW50RGlkRW50ZXIoKTtcbiAgICB9XG5cbiAgICBkZWxldGUgdGhpcy5jdXJyZW50bHlUcmFuc2l0aW9uaW5nS2V5c1trZXldO1xuXG4gICAgdmFyIGN1cnJlbnRDaGlsZE1hcHBpbmcgPSBSZWFjdFRyYW5zaXRpb25DaGlsZE1hcHBpbmcuZ2V0Q2hpbGRNYXBwaW5nKFxuICAgICAgdGhpcy5wcm9wcy5jaGlsZHJlblxuICAgICk7XG5cbiAgICBpZiAoIWN1cnJlbnRDaGlsZE1hcHBpbmcgfHwgIWN1cnJlbnRDaGlsZE1hcHBpbmcuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgLy8gVGhpcyB3YXMgcmVtb3ZlZCBiZWZvcmUgaXQgaGFkIGZ1bGx5IGVudGVyZWQuIFJlbW92ZSBpdC5cbiAgICAgIHRoaXMucGVyZm9ybUxlYXZlKGtleSk7XG4gICAgfVxuICB9LFxuXG4gIHBlcmZvcm1MZWF2ZTogZnVuY3Rpb24oa2V5KSB7XG4gICAgdGhpcy5jdXJyZW50bHlUcmFuc2l0aW9uaW5nS2V5c1trZXldID0gdHJ1ZTtcblxuICAgIHZhciBjb21wb25lbnQgPSB0aGlzLnJlZnNba2V5XTtcbiAgICBpZiAoY29tcG9uZW50LmNvbXBvbmVudFdpbGxMZWF2ZSkge1xuICAgICAgY29tcG9uZW50LmNvbXBvbmVudFdpbGxMZWF2ZSh0aGlzLl9oYW5kbGVEb25lTGVhdmluZy5iaW5kKHRoaXMsIGtleSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBOb3RlIHRoYXQgdGhpcyBpcyBzb21ld2hhdCBkYW5nZXJvdXMgYi9jIGl0IGNhbGxzIHNldFN0YXRlKClcbiAgICAgIC8vIGFnYWluLCBlZmZlY3RpdmVseSBtdXRhdGluZyB0aGUgY29tcG9uZW50IGJlZm9yZSBhbGwgdGhlIHdvcmtcbiAgICAgIC8vIGlzIGRvbmUuXG4gICAgICB0aGlzLl9oYW5kbGVEb25lTGVhdmluZyhrZXkpO1xuICAgIH1cbiAgfSxcblxuICBfaGFuZGxlRG9uZUxlYXZpbmc6IGZ1bmN0aW9uKGtleSkge1xuICAgIHZhciBjb21wb25lbnQgPSB0aGlzLnJlZnNba2V5XTtcblxuICAgIGlmIChjb21wb25lbnQuY29tcG9uZW50RGlkTGVhdmUpIHtcbiAgICAgIGNvbXBvbmVudC5jb21wb25lbnREaWRMZWF2ZSgpO1xuICAgIH1cblxuICAgIGRlbGV0ZSB0aGlzLmN1cnJlbnRseVRyYW5zaXRpb25pbmdLZXlzW2tleV07XG5cbiAgICB2YXIgY3VycmVudENoaWxkTWFwcGluZyA9IFJlYWN0VHJhbnNpdGlvbkNoaWxkTWFwcGluZy5nZXRDaGlsZE1hcHBpbmcoXG4gICAgICB0aGlzLnByb3BzLmNoaWxkcmVuXG4gICAgKTtcblxuICAgIGlmIChjdXJyZW50Q2hpbGRNYXBwaW5nICYmIGN1cnJlbnRDaGlsZE1hcHBpbmcuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgLy8gVGhpcyBlbnRlcmVkIGFnYWluIGJlZm9yZSBpdCBmdWxseSBsZWZ0LiBBZGQgaXQgYWdhaW4uXG4gICAgICB0aGlzLnBlcmZvcm1FbnRlcihrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbmV3Q2hpbGRyZW4gPSBtZXJnZSh0aGlzLnN0YXRlLmNoaWxkcmVuKTtcbiAgICAgIGRlbGV0ZSBuZXdDaGlsZHJlbltrZXldO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7Y2hpbGRyZW46IG5ld0NoaWxkcmVufSk7XG4gICAgfVxuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgLy8gVE9ETzogd2UgY291bGQgZ2V0IHJpZCBvZiB0aGUgbmVlZCBmb3IgdGhlIHdyYXBwZXIgbm9kZVxuICAgIC8vIGJ5IGNsb25pbmcgYSBzaW5nbGUgY2hpbGRcbiAgICB2YXIgY2hpbGRyZW5Ub1JlbmRlciA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLnN0YXRlLmNoaWxkcmVuKSB7XG4gICAgICB2YXIgY2hpbGQgPSB0aGlzLnN0YXRlLmNoaWxkcmVuW2tleV07XG4gICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgLy8gWW91IG1heSBuZWVkIHRvIGFwcGx5IHJlYWN0aXZlIHVwZGF0ZXMgdG8gYSBjaGlsZCBhcyBpdCBpcyBsZWF2aW5nLlxuICAgICAgICAvLyBUaGUgbm9ybWFsIFJlYWN0IHdheSB0byBkbyBpdCB3b24ndCB3b3JrIHNpbmNlIHRoZSBjaGlsZCB3aWxsIGhhdmVcbiAgICAgICAgLy8gYWxyZWFkeSBiZWVuIHJlbW92ZWQuIEluIGNhc2UgeW91IG5lZWQgdGhpcyBiZWhhdmlvciB5b3UgY2FuIHByb3ZpZGVcbiAgICAgICAgLy8gYSBjaGlsZEZhY3RvcnkgZnVuY3Rpb24gdG8gd3JhcCBldmVyeSBjaGlsZCwgZXZlbiB0aGUgb25lcyB0aGF0IGFyZVxuICAgICAgICAvLyBsZWF2aW5nLlxuICAgICAgICBjaGlsZHJlblRvUmVuZGVyW2tleV0gPSBjbG9uZVdpdGhQcm9wcyhcbiAgICAgICAgICB0aGlzLnByb3BzLmNoaWxkRmFjdG9yeShjaGlsZCksXG4gICAgICAgICAge3JlZjoga2V5fVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy50cmFuc2ZlclByb3BzVG8odGhpcy5wcm9wcy5jb21wb25lbnQobnVsbCwgY2hpbGRyZW5Ub1JlbmRlcikpO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFRyYW5zaXRpb25Hcm91cDtcbiIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RVcGRhdGVzXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBDYWxsYmFja1F1ZXVlID0gcmVxdWlyZShcIi4vQ2FsbGJhY2tRdWV1ZVwiKTtcbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoXCIuL1Bvb2xlZENsYXNzXCIpO1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZShcIi4vUmVhY3RDdXJyZW50T3duZXJcIik7XG52YXIgUmVhY3RQZXJmID0gcmVxdWlyZShcIi4vUmVhY3RQZXJmXCIpO1xudmFyIFRyYW5zYWN0aW9uID0gcmVxdWlyZShcIi4vVHJhbnNhY3Rpb25cIik7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG52YXIgbWl4SW50byA9IHJlcXVpcmUoXCIuL21peEludG9cIik7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoXCIuL3dhcm5pbmdcIik7XG5cbnZhciBkaXJ0eUNvbXBvbmVudHMgPSBbXTtcblxudmFyIGJhdGNoaW5nU3RyYXRlZ3kgPSBudWxsO1xuXG5mdW5jdGlvbiBlbnN1cmVJbmplY3RlZCgpIHtcbiAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbiAmJiBiYXRjaGluZ1N0cmF0ZWd5LFxuICAgICdSZWFjdFVwZGF0ZXM6IG11c3QgaW5qZWN0IGEgcmVjb25jaWxlIHRyYW5zYWN0aW9uIGNsYXNzIGFuZCBiYXRjaGluZyAnICtcbiAgICAnc3RyYXRlZ3knXG4gICkgOiBpbnZhcmlhbnQoUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24gJiYgYmF0Y2hpbmdTdHJhdGVneSkpO1xufVxuXG52YXIgTkVTVEVEX1VQREFURVMgPSB7XG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZGlydHlDb21wb25lbnRzTGVuZ3RoID0gZGlydHlDb21wb25lbnRzLmxlbmd0aDtcbiAgfSxcbiAgY2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmRpcnR5Q29tcG9uZW50c0xlbmd0aCAhPT0gZGlydHlDb21wb25lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gQWRkaXRpb25hbCB1cGRhdGVzIHdlcmUgZW5xdWV1ZWQgYnkgY29tcG9uZW50RGlkVXBkYXRlIGhhbmRsZXJzIG9yXG4gICAgICAvLyBzaW1pbGFyOyBiZWZvcmUgb3VyIG93biBVUERBVEVfUVVFVUVJTkcgd3JhcHBlciBjbG9zZXMsIHdlIHdhbnQgdG8gcnVuXG4gICAgICAvLyB0aGVzZSBuZXcgdXBkYXRlcyBzbyB0aGF0IGlmIEEncyBjb21wb25lbnREaWRVcGRhdGUgY2FsbHMgc2V0U3RhdGUgb25cbiAgICAgIC8vIEIsIEIgd2lsbCB1cGRhdGUgYmVmb3JlIHRoZSBjYWxsYmFjayBBJ3MgdXBkYXRlciBwcm92aWRlZCB3aGVuIGNhbGxpbmdcbiAgICAgIC8vIHNldFN0YXRlLlxuICAgICAgZGlydHlDb21wb25lbnRzLnNwbGljZSgwLCB0aGlzLmRpcnR5Q29tcG9uZW50c0xlbmd0aCk7XG4gICAgICBmbHVzaEJhdGNoZWRVcGRhdGVzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpcnR5Q29tcG9uZW50cy5sZW5ndGggPSAwO1xuICAgIH1cbiAgfVxufTtcblxudmFyIFVQREFURV9RVUVVRUlORyA9IHtcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jYWxsYmFja1F1ZXVlLnJlc2V0KCk7XG4gIH0sXG4gIGNsb3NlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNhbGxiYWNrUXVldWUubm90aWZ5QWxsKCk7XG4gIH1cbn07XG5cbnZhciBUUkFOU0FDVElPTl9XUkFQUEVSUyA9IFtORVNURURfVVBEQVRFUywgVVBEQVRFX1FVRVVFSU5HXTtcblxuZnVuY3Rpb24gUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbigpIHtcbiAgdGhpcy5yZWluaXRpYWxpemVUcmFuc2FjdGlvbigpO1xuICB0aGlzLmRpcnR5Q29tcG9uZW50c0xlbmd0aCA9IG51bGw7XG4gIHRoaXMuY2FsbGJhY2tRdWV1ZSA9IENhbGxiYWNrUXVldWUuZ2V0UG9vbGVkKG51bGwpO1xuICB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uID1cbiAgICBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5nZXRQb29sZWQoKTtcbn1cblxubWl4SW50byhSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uLCBUcmFuc2FjdGlvbi5NaXhpbik7XG5taXhJbnRvKFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24sIHtcbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFRSQU5TQUNUSU9OX1dSQVBQRVJTO1xuICB9LFxuXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZGlydHlDb21wb25lbnRzTGVuZ3RoID0gbnVsbDtcbiAgICBDYWxsYmFja1F1ZXVlLnJlbGVhc2UodGhpcy5jYWxsYmFja1F1ZXVlKTtcbiAgICB0aGlzLmNhbGxiYWNrUXVldWUgPSBudWxsO1xuICAgIFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLnJlbGVhc2UodGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbik7XG4gICAgdGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbiA9IG51bGw7XG4gIH0sXG5cbiAgcGVyZm9ybTogZnVuY3Rpb24obWV0aG9kLCBzY29wZSwgYSkge1xuICAgIC8vIEVzc2VudGlhbGx5IGNhbGxzIGB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uLnBlcmZvcm0obWV0aG9kLCBzY29wZSwgYSlgXG4gICAgLy8gd2l0aCB0aGlzIHRyYW5zYWN0aW9uJ3Mgd3JhcHBlcnMgYXJvdW5kIGl0LlxuICAgIHJldHVybiBUcmFuc2FjdGlvbi5NaXhpbi5wZXJmb3JtLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgdGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbi5wZXJmb3JtLFxuICAgICAgdGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbixcbiAgICAgIG1ldGhvZCxcbiAgICAgIHNjb3BlLFxuICAgICAgYVxuICAgICk7XG4gIH1cbn0pO1xuXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbik7XG5cbmZ1bmN0aW9uIGJhdGNoZWRVcGRhdGVzKGNhbGxiYWNrLCBhLCBiKSB7XG4gIGVuc3VyZUluamVjdGVkKCk7XG4gIGJhdGNoaW5nU3RyYXRlZ3kuYmF0Y2hlZFVwZGF0ZXMoY2FsbGJhY2ssIGEsIGIpO1xufVxuXG4vKipcbiAqIEFycmF5IGNvbXBhcmF0b3IgZm9yIFJlYWN0Q29tcG9uZW50cyBieSBvd25lciBkZXB0aFxuICpcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGMxIGZpcnN0IGNvbXBvbmVudCB5b3UncmUgY29tcGFyaW5nXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjMiBzZWNvbmQgY29tcG9uZW50IHlvdSdyZSBjb21wYXJpbmdcbiAqIEByZXR1cm4ge251bWJlcn0gUmV0dXJuIHZhbHVlIHVzYWJsZSBieSBBcnJheS5wcm90b3R5cGUuc29ydCgpLlxuICovXG5mdW5jdGlvbiBtb3VudERlcHRoQ29tcGFyYXRvcihjMSwgYzIpIHtcbiAgcmV0dXJuIGMxLl9tb3VudERlcHRoIC0gYzIuX21vdW50RGVwdGg7XG59XG5cbmZ1bmN0aW9uIHJ1bkJhdGNoZWRVcGRhdGVzKHRyYW5zYWN0aW9uKSB7XG4gIHZhciBsZW4gPSB0cmFuc2FjdGlvbi5kaXJ0eUNvbXBvbmVudHNMZW5ndGg7XG4gIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgbGVuID09PSBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoLFxuICAgICdFeHBlY3RlZCBmbHVzaCB0cmFuc2FjdGlvblxcJ3Mgc3RvcmVkIGRpcnR5LWNvbXBvbmVudHMgbGVuZ3RoICglcykgdG8gJyArXG4gICAgJ21hdGNoIGRpcnR5LWNvbXBvbmVudHMgYXJyYXkgbGVuZ3RoICglcykuJyxcbiAgICBsZW4sXG4gICAgZGlydHlDb21wb25lbnRzLmxlbmd0aFxuICApIDogaW52YXJpYW50KGxlbiA9PT0gZGlydHlDb21wb25lbnRzLmxlbmd0aCkpO1xuXG4gIC8vIFNpbmNlIHJlY29uY2lsaW5nIGEgY29tcG9uZW50IGhpZ2hlciBpbiB0aGUgb3duZXIgaGllcmFyY2h5IHVzdWFsbHkgKG5vdFxuICAvLyBhbHdheXMgLS0gc2VlIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpKSB3aWxsIHJlY29uY2lsZSBjaGlsZHJlbiwgcmVjb25jaWxlXG4gIC8vIHRoZW0gYmVmb3JlIHRoZWlyIGNoaWxkcmVuIGJ5IHNvcnRpbmcgdGhlIGFycmF5LlxuICBkaXJ0eUNvbXBvbmVudHMuc29ydChtb3VudERlcHRoQ29tcGFyYXRvcik7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIC8vIElmIGEgY29tcG9uZW50IGlzIHVubW91bnRlZCBiZWZvcmUgcGVuZGluZyBjaGFuZ2VzIGFwcGx5LCBpZ25vcmUgdGhlbVxuICAgIC8vIFRPRE86IFF1ZXVlIHVubW91bnRzIGluIHRoZSBzYW1lIGxpc3QgdG8gYXZvaWQgdGhpcyBoYXBwZW5pbmcgYXQgYWxsXG4gICAgdmFyIGNvbXBvbmVudCA9IGRpcnR5Q29tcG9uZW50c1tpXTtcbiAgICBpZiAoY29tcG9uZW50LmlzTW91bnRlZCgpKSB7XG4gICAgICAvLyBJZiBwZXJmb3JtVXBkYXRlSWZOZWNlc3NhcnkgaGFwcGVucyB0byBlbnF1ZXVlIGFueSBuZXcgdXBkYXRlcywgd2VcbiAgICAgIC8vIHNob3VsZG4ndCBleGVjdXRlIHRoZSBjYWxsYmFja3MgdW50aWwgdGhlIG5leHQgcmVuZGVyIGhhcHBlbnMsIHNvXG4gICAgICAvLyBzdGFzaCB0aGUgY2FsbGJhY2tzIGZpcnN0XG4gICAgICB2YXIgY2FsbGJhY2tzID0gY29tcG9uZW50Ll9wZW5kaW5nQ2FsbGJhY2tzO1xuICAgICAgY29tcG9uZW50Ll9wZW5kaW5nQ2FsbGJhY2tzID0gbnVsbDtcbiAgICAgIGNvbXBvbmVudC5wZXJmb3JtVXBkYXRlSWZOZWNlc3NhcnkodHJhbnNhY3Rpb24ucmVjb25jaWxlVHJhbnNhY3Rpb24pO1xuXG4gICAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2FsbGJhY2tzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uY2FsbGJhY2tRdWV1ZS5lbnF1ZXVlKFxuICAgICAgICAgICAgY2FsbGJhY2tzW2pdLFxuICAgICAgICAgICAgY29tcG9uZW50XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgZmx1c2hCYXRjaGVkVXBkYXRlcyA9IFJlYWN0UGVyZi5tZWFzdXJlKFxuICAnUmVhY3RVcGRhdGVzJyxcbiAgJ2ZsdXNoQmF0Y2hlZFVwZGF0ZXMnLFxuICBmdW5jdGlvbigpIHtcbiAgICAvLyBSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uJ3Mgd3JhcHBlcnMgd2lsbCBjbGVhciB0aGUgZGlydHlDb21wb25lbnRzXG4gICAgLy8gYXJyYXkgYW5kIHBlcmZvcm0gYW55IHVwZGF0ZXMgZW5xdWV1ZWQgYnkgbW91bnQtcmVhZHkgaGFuZGxlcnMgKGkuZS4sXG4gICAgLy8gY29tcG9uZW50RGlkVXBkYXRlKSBidXQgd2UgbmVlZCB0byBjaGVjayBoZXJlIHRvbyBpbiBvcmRlciB0byBjYXRjaFxuICAgIC8vIHVwZGF0ZXMgZW5xdWV1ZWQgYnkgc2V0U3RhdGUgY2FsbGJhY2tzLlxuICAgIHdoaWxlIChkaXJ0eUNvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICB2YXIgdHJhbnNhY3Rpb24gPSBSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uLmdldFBvb2xlZCgpO1xuICAgICAgdHJhbnNhY3Rpb24ucGVyZm9ybShydW5CYXRjaGVkVXBkYXRlcywgbnVsbCwgdHJhbnNhY3Rpb24pO1xuICAgICAgUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbi5yZWxlYXNlKHRyYW5zYWN0aW9uKTtcbiAgICB9XG4gIH1cbik7XG5cbi8qKlxuICogTWFyayBhIGNvbXBvbmVudCBhcyBuZWVkaW5nIGEgcmVyZW5kZXIsIGFkZGluZyBhbiBvcHRpb25hbCBjYWxsYmFjayB0byBhXG4gKiBsaXN0IG9mIGZ1bmN0aW9ucyB3aGljaCB3aWxsIGJlIGV4ZWN1dGVkIG9uY2UgdGhlIHJlcmVuZGVyIG9jY3Vycy5cbiAqL1xuZnVuY3Rpb24gZW5xdWV1ZVVwZGF0ZShjb21wb25lbnQsIGNhbGxiYWNrKSB7XG4gIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgIWNhbGxiYWNrIHx8IHR5cGVvZiBjYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiLFxuICAgICdlbnF1ZXVlVXBkYXRlKC4uLik6IFlvdSBjYWxsZWQgYHNldFByb3BzYCwgYHJlcGxhY2VQcm9wc2AsICcgK1xuICAgICdgc2V0U3RhdGVgLCBgcmVwbGFjZVN0YXRlYCwgb3IgYGZvcmNlVXBkYXRlYCB3aXRoIGEgY2FsbGJhY2sgdGhhdCAnICtcbiAgICAnaXNuXFwndCBjYWxsYWJsZS4nXG4gICkgOiBpbnZhcmlhbnQoIWNhbGxiYWNrIHx8IHR5cGVvZiBjYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSk7XG4gIGVuc3VyZUluamVjdGVkKCk7XG5cbiAgLy8gVmFyaW91cyBwYXJ0cyBvZiBvdXIgY29kZSAoc3VjaCBhcyBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCdzXG4gIC8vIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQpIGFzc3VtZSB0aGF0IGNhbGxzIHRvIHJlbmRlciBhcmVuJ3QgbmVzdGVkO1xuICAvLyB2ZXJpZnkgdGhhdCB0aGF0J3MgdGhlIGNhc2UuIChUaGlzIGlzIGNhbGxlZCBieSBlYWNoIHRvcC1sZXZlbCB1cGRhdGVcbiAgLy8gZnVuY3Rpb24sIGxpa2Ugc2V0UHJvcHMsIHNldFN0YXRlLCBmb3JjZVVwZGF0ZSwgZXRjLjsgY3JlYXRpb24gYW5kXG4gIC8vIGRlc3RydWN0aW9uIG9mIHRvcC1sZXZlbCBjb21wb25lbnRzIGlzIGd1YXJkZWQgaW4gUmVhY3RNb3VudC4pXG4gIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKFxuICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPT0gbnVsbCxcbiAgICAnZW5xdWV1ZVVwZGF0ZSgpOiBSZW5kZXIgbWV0aG9kcyBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzICcgK1xuICAgICdhbmQgc3RhdGU7IHRyaWdnZXJpbmcgbmVzdGVkIGNvbXBvbmVudCB1cGRhdGVzIGZyb20gcmVuZGVyIGlzIG5vdCAnICtcbiAgICAnYWxsb3dlZC4gSWYgbmVjZXNzYXJ5LCB0cmlnZ2VyIG5lc3RlZCB1cGRhdGVzIGluICcgK1xuICAgICdjb21wb25lbnREaWRVcGRhdGUuJ1xuICApIDogbnVsbCk7XG5cbiAgaWYgKCFiYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzKSB7XG4gICAgYmF0Y2hpbmdTdHJhdGVneS5iYXRjaGVkVXBkYXRlcyhlbnF1ZXVlVXBkYXRlLCBjb21wb25lbnQsIGNhbGxiYWNrKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBkaXJ0eUNvbXBvbmVudHMucHVzaChjb21wb25lbnQpO1xuXG4gIGlmIChjYWxsYmFjaykge1xuICAgIGlmIChjb21wb25lbnQuX3BlbmRpbmdDYWxsYmFja3MpIHtcbiAgICAgIGNvbXBvbmVudC5fcGVuZGluZ0NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcG9uZW50Ll9wZW5kaW5nQ2FsbGJhY2tzID0gW2NhbGxiYWNrXTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0VXBkYXRlc0luamVjdGlvbiA9IHtcbiAgaW5qZWN0UmVjb25jaWxlVHJhbnNhY3Rpb246IGZ1bmN0aW9uKFJlY29uY2lsZVRyYW5zYWN0aW9uKSB7XG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgIFJlY29uY2lsZVRyYW5zYWN0aW9uLFxuICAgICAgJ1JlYWN0VXBkYXRlczogbXVzdCBwcm92aWRlIGEgcmVjb25jaWxlIHRyYW5zYWN0aW9uIGNsYXNzJ1xuICAgICkgOiBpbnZhcmlhbnQoUmVjb25jaWxlVHJhbnNhY3Rpb24pKTtcbiAgICBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbiA9IFJlY29uY2lsZVRyYW5zYWN0aW9uO1xuICB9LFxuXG4gIGluamVjdEJhdGNoaW5nU3RyYXRlZ3k6IGZ1bmN0aW9uKF9iYXRjaGluZ1N0cmF0ZWd5KSB7XG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgIF9iYXRjaGluZ1N0cmF0ZWd5LFxuICAgICAgJ1JlYWN0VXBkYXRlczogbXVzdCBwcm92aWRlIGEgYmF0Y2hpbmcgc3RyYXRlZ3knXG4gICAgKSA6IGludmFyaWFudChfYmF0Y2hpbmdTdHJhdGVneSkpO1xuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICB0eXBlb2YgX2JhdGNoaW5nU3RyYXRlZ3kuYmF0Y2hlZFVwZGF0ZXMgPT09ICdmdW5jdGlvbicsXG4gICAgICAnUmVhY3RVcGRhdGVzOiBtdXN0IHByb3ZpZGUgYSBiYXRjaGVkVXBkYXRlcygpIGZ1bmN0aW9uJ1xuICAgICkgOiBpbnZhcmlhbnQodHlwZW9mIF9iYXRjaGluZ1N0cmF0ZWd5LmJhdGNoZWRVcGRhdGVzID09PSAnZnVuY3Rpb24nKSk7XG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgIHR5cGVvZiBfYmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcyA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgJ1JlYWN0VXBkYXRlczogbXVzdCBwcm92aWRlIGFuIGlzQmF0Y2hpbmdVcGRhdGVzIGJvb2xlYW4gYXR0cmlidXRlJ1xuICAgICkgOiBpbnZhcmlhbnQodHlwZW9mIF9iYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzID09PSAnYm9vbGVhbicpKTtcbiAgICBiYXRjaGluZ1N0cmF0ZWd5ID0gX2JhdGNoaW5nU3RyYXRlZ3k7XG4gIH1cbn07XG5cbnZhciBSZWFjdFVwZGF0ZXMgPSB7XG4gIC8qKlxuICAgKiBSZWFjdCByZWZlcmVuY2VzIGBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uYCB1c2luZyB0aGlzIHByb3BlcnR5IGluIG9yZGVyXG4gICAqIHRvIGFsbG93IGRlcGVuZGVuY3kgaW5qZWN0aW9uLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb246IG51bGwsXG5cbiAgYmF0Y2hlZFVwZGF0ZXM6IGJhdGNoZWRVcGRhdGVzLFxuICBlbnF1ZXVlVXBkYXRlOiBlbnF1ZXVlVXBkYXRlLFxuICBmbHVzaEJhdGNoZWRVcGRhdGVzOiBmbHVzaEJhdGNoZWRVcGRhdGVzLFxuICBpbmplY3Rpb246IFJlYWN0VXBkYXRlc0luamVjdGlvblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFVwZGF0ZXM7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RXaXRoQWRkb25zXG4gKi9cblxuLyoqXG4gKiBUaGlzIG1vZHVsZSBleGlzdHMgcHVyZWx5IGluIHRoZSBvcGVuIHNvdXJjZSBwcm9qZWN0LCBhbmQgaXMgbWVhbnQgYXMgYSB3YXlcbiAqIHRvIGNyZWF0ZSBhIHNlcGFyYXRlIHN0YW5kYWxvbmUgYnVpbGQgb2YgUmVhY3QuIFRoaXMgYnVpbGQgaGFzIFwiYWRkb25zXCIsIG9yXG4gKiBmdW5jdGlvbmFsaXR5IHdlJ3ZlIGJ1aWx0IGFuZCB0aGluayBtaWdodCBiZSB1c2VmdWwgYnV0IGRvZXNuJ3QgaGF2ZSBhIGdvb2RcbiAqIHBsYWNlIHRvIGxpdmUgaW5zaWRlIFJlYWN0IGNvcmUuXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBMaW5rZWRTdGF0ZU1peGluID0gcmVxdWlyZShcIi4vTGlua2VkU3RhdGVNaXhpblwiKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoXCIuL1JlYWN0XCIpO1xudmFyIFJlYWN0Q29tcG9uZW50V2l0aFB1cmVSZW5kZXJNaXhpbiA9XG4gIHJlcXVpcmUoXCIuL1JlYWN0Q29tcG9uZW50V2l0aFB1cmVSZW5kZXJNaXhpblwiKTtcbnZhciBSZWFjdENTU1RyYW5zaXRpb25Hcm91cCA9IHJlcXVpcmUoXCIuL1JlYWN0Q1NTVHJhbnNpdGlvbkdyb3VwXCIpO1xudmFyIFJlYWN0VHJhbnNpdGlvbkdyb3VwID0gcmVxdWlyZShcIi4vUmVhY3RUcmFuc2l0aW9uR3JvdXBcIik7XG5cbnZhciBjeCA9IHJlcXVpcmUoXCIuL2N4XCIpO1xudmFyIGNsb25lV2l0aFByb3BzID0gcmVxdWlyZShcIi4vY2xvbmVXaXRoUHJvcHNcIik7XG52YXIgdXBkYXRlID0gcmVxdWlyZShcIi4vdXBkYXRlXCIpO1xuXG5SZWFjdC5hZGRvbnMgPSB7XG4gIENTU1RyYW5zaXRpb25Hcm91cDogUmVhY3RDU1NUcmFuc2l0aW9uR3JvdXAsXG4gIExpbmtlZFN0YXRlTWl4aW46IExpbmtlZFN0YXRlTWl4aW4sXG4gIFB1cmVSZW5kZXJNaXhpbjogUmVhY3RDb21wb25lbnRXaXRoUHVyZVJlbmRlck1peGluLFxuICBUcmFuc2l0aW9uR3JvdXA6IFJlYWN0VHJhbnNpdGlvbkdyb3VwLFxuXG4gIGNsYXNzU2V0OiBjeCxcbiAgY2xvbmVXaXRoUHJvcHM6IGNsb25lV2l0aFByb3BzLFxuICB1cGRhdGU6IHVwZGF0ZVxufTtcblxuaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICBSZWFjdC5hZGRvbnMuUGVyZiA9IHJlcXVpcmUoXCIuL1JlYWN0RGVmYXVsdFBlcmZcIik7XG4gIFJlYWN0LmFkZG9ucy5UZXN0VXRpbHMgPSByZXF1aXJlKFwiLi9SZWFjdFRlc3RVdGlsc1wiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdDtcblxuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU1ZHRE9NUHJvcGVydHlDb25maWdcbiAqL1xuXG4vKmpzbGludCBiaXR3aXNlOiB0cnVlKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoXCIuL0RPTVByb3BlcnR5XCIpO1xuXG52YXIgTVVTVF9VU0VfQVRUUklCVVRFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLk1VU1RfVVNFX0FUVFJJQlVURTtcblxudmFyIFNWR0RPTVByb3BlcnR5Q29uZmlnID0ge1xuICBQcm9wZXJ0aWVzOiB7XG4gICAgY3g6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBjeTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGQ6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBkeDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGR5OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZmlsbDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZpbGxPcGFjaXR5OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZm9udEZhbWlseTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZvbnRTaXplOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZng6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBmeTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGdyYWRpZW50VHJhbnNmb3JtOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZ3JhZGllbnRVbml0czogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIG1hcmtlckVuZDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIG1hcmtlck1pZDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIG1hcmtlclN0YXJ0OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgb2Zmc2V0OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgb3BhY2l0eTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHBhdHRlcm5Db250ZW50VW5pdHM6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBwYXR0ZXJuVW5pdHM6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBwb2ludHM6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgcjogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHJ4OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgcnk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBzcHJlYWRNZXRob2Q6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBzdG9wQ29sb3I6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBzdG9wT3BhY2l0eTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHN0cm9rZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHN0cm9rZURhc2hhcnJheTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHN0cm9rZUxpbmVjYXA6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBzdHJva2VPcGFjaXR5OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgc3Ryb2tlV2lkdGg6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB0ZXh0QW5jaG9yOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgdHJhbnNmb3JtOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgdmVyc2lvbjogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHZpZXdCb3g6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4MTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHgyOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHkxOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeTI6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB5OiBNVVNUX1VTRV9BVFRSSUJVVEVcbiAgfSxcbiAgRE9NQXR0cmlidXRlTmFtZXM6IHtcbiAgICBmaWxsT3BhY2l0eTogJ2ZpbGwtb3BhY2l0eScsXG4gICAgZm9udEZhbWlseTogJ2ZvbnQtZmFtaWx5JyxcbiAgICBmb250U2l6ZTogJ2ZvbnQtc2l6ZScsXG4gICAgZ3JhZGllbnRUcmFuc2Zvcm06ICdncmFkaWVudFRyYW5zZm9ybScsXG4gICAgZ3JhZGllbnRVbml0czogJ2dyYWRpZW50VW5pdHMnLFxuICAgIG1hcmtlckVuZDogJ21hcmtlci1lbmQnLFxuICAgIG1hcmtlck1pZDogJ21hcmtlci1taWQnLFxuICAgIG1hcmtlclN0YXJ0OiAnbWFya2VyLXN0YXJ0JyxcbiAgICBwYXR0ZXJuQ29udGVudFVuaXRzOiAncGF0dGVybkNvbnRlbnRVbml0cycsXG4gICAgcGF0dGVyblVuaXRzOiAncGF0dGVyblVuaXRzJyxcbiAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiAncHJlc2VydmVBc3BlY3RSYXRpbycsXG4gICAgc3ByZWFkTWV0aG9kOiAnc3ByZWFkTWV0aG9kJyxcbiAgICBzdG9wQ29sb3I6ICdzdG9wLWNvbG9yJyxcbiAgICBzdG9wT3BhY2l0eTogJ3N0b3Atb3BhY2l0eScsXG4gICAgc3Ryb2tlRGFzaGFycmF5OiAnc3Ryb2tlLWRhc2hhcnJheScsXG4gICAgc3Ryb2tlTGluZWNhcDogJ3N0cm9rZS1saW5lY2FwJyxcbiAgICBzdHJva2VPcGFjaXR5OiAnc3Ryb2tlLW9wYWNpdHknLFxuICAgIHN0cm9rZVdpZHRoOiAnc3Ryb2tlLXdpZHRoJyxcbiAgICB0ZXh0QW5jaG9yOiAndGV4dC1hbmNob3InLFxuICAgIHZpZXdCb3g6ICd2aWV3Qm94J1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNWR0RPTVByb3BlcnR5Q29uZmlnO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFNlbGVjdEV2ZW50UGx1Z2luXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoXCIuL0V2ZW50Q29uc3RhbnRzXCIpO1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKFwiLi9FdmVudFByb3BhZ2F0b3JzXCIpO1xudmFyIFJlYWN0SW5wdXRTZWxlY3Rpb24gPSByZXF1aXJlKFwiLi9SZWFjdElucHV0U2VsZWN0aW9uXCIpO1xudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZShcIi4vU3ludGhldGljRXZlbnRcIik7XG5cbnZhciBnZXRBY3RpdmVFbGVtZW50ID0gcmVxdWlyZShcIi4vZ2V0QWN0aXZlRWxlbWVudFwiKTtcbnZhciBpc1RleHRJbnB1dEVsZW1lbnQgPSByZXF1aXJlKFwiLi9pc1RleHRJbnB1dEVsZW1lbnRcIik7XG52YXIga2V5T2YgPSByZXF1aXJlKFwiLi9rZXlPZlwiKTtcbnZhciBzaGFsbG93RXF1YWwgPSByZXF1aXJlKFwiLi9zaGFsbG93RXF1YWxcIik7XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcblxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIHNlbGVjdDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7b25TZWxlY3Q6IG51bGx9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7b25TZWxlY3RDYXB0dXJlOiBudWxsfSlcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW1xuICAgICAgdG9wTGV2ZWxUeXBlcy50b3BCbHVyLFxuICAgICAgdG9wTGV2ZWxUeXBlcy50b3BDb250ZXh0TWVudSxcbiAgICAgIHRvcExldmVsVHlwZXMudG9wRm9jdXMsXG4gICAgICB0b3BMZXZlbFR5cGVzLnRvcEtleURvd24sXG4gICAgICB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93bixcbiAgICAgIHRvcExldmVsVHlwZXMudG9wTW91c2VVcCxcbiAgICAgIHRvcExldmVsVHlwZXMudG9wU2VsZWN0aW9uQ2hhbmdlXG4gICAgXVxuICB9XG59O1xuXG52YXIgYWN0aXZlRWxlbWVudCA9IG51bGw7XG52YXIgYWN0aXZlRWxlbWVudElEID0gbnVsbDtcbnZhciBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbnZhciBtb3VzZURvd24gPSBmYWxzZTtcblxuLyoqXG4gKiBHZXQgYW4gb2JqZWN0IHdoaWNoIGlzIGEgdW5pcXVlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgbm90IGJlIGNvbnNpc3RlbnQgYWNyb3NzIG5vZGVzIG9yIGJyb3dzZXJzLCBidXRcbiAqIHR3byBpZGVudGljYWwgc2VsZWN0aW9ucyBvbiB0aGUgc2FtZSBub2RlIHdpbGwgcmV0dXJuIGlkZW50aWNhbCBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldFNlbGVjdGlvbihub2RlKSB7XG4gIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIG5vZGUgJiZcbiAgICAgIFJlYWN0SW5wdXRTZWxlY3Rpb24uaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKG5vZGUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBub2RlLnNlbGVjdGlvblN0YXJ0LFxuICAgICAgZW5kOiBub2RlLnNlbGVjdGlvbkVuZFxuICAgIH07XG4gIH0gZWxzZSBpZiAoZG9jdW1lbnQuc2VsZWN0aW9uKSB7XG4gICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhcmVudEVsZW1lbnQ6IHJhbmdlLnBhcmVudEVsZW1lbnQoKSxcbiAgICAgIHRleHQ6IHJhbmdlLnRleHQsXG4gICAgICB0b3A6IHJhbmdlLmJvdW5kaW5nVG9wLFxuICAgICAgbGVmdDogcmFuZ2UuYm91bmRpbmdMZWZ0XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgIHJldHVybiB7XG4gICAgICBhbmNob3JOb2RlOiBzZWxlY3Rpb24uYW5jaG9yTm9kZSxcbiAgICAgIGFuY2hvck9mZnNldDogc2VsZWN0aW9uLmFuY2hvck9mZnNldCxcbiAgICAgIGZvY3VzTm9kZTogc2VsZWN0aW9uLmZvY3VzTm9kZSxcbiAgICAgIGZvY3VzT2Zmc2V0OiBzZWxlY3Rpb24uZm9jdXNPZmZzZXRcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogUG9sbCBzZWxlY3Rpb24gdG8gc2VlIHdoZXRoZXIgaXQncyBjaGFuZ2VkLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7P1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBjb25zdHJ1Y3RTZWxlY3RFdmVudChuYXRpdmVFdmVudCkge1xuICAvLyBFbnN1cmUgd2UgaGF2ZSB0aGUgcmlnaHQgZWxlbWVudCwgYW5kIHRoYXQgdGhlIHVzZXIgaXMgbm90IGRyYWdnaW5nIGFcbiAgLy8gc2VsZWN0aW9uICh0aGlzIG1hdGNoZXMgbmF0aXZlIGBzZWxlY3RgIGV2ZW50IGJlaGF2aW9yKS4gSW4gSFRNTDUsIHNlbGVjdFxuICAvLyBmaXJlcyBvbmx5IG9uIGlucHV0IGFuZCB0ZXh0YXJlYSB0aHVzIGlmIHRoZXJlJ3Mgbm8gZm9jdXNlZCBlbGVtZW50IHdlXG4gIC8vIHdvbid0IGRpc3BhdGNoLlxuICBpZiAobW91c2VEb3duIHx8XG4gICAgICBhY3RpdmVFbGVtZW50ID09IG51bGwgfHxcbiAgICAgIGFjdGl2ZUVsZW1lbnQgIT0gZ2V0QWN0aXZlRWxlbWVudCgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gT25seSBmaXJlIHdoZW4gc2VsZWN0aW9uIGhhcyBhY3R1YWxseSBjaGFuZ2VkLlxuICB2YXIgY3VycmVudFNlbGVjdGlvbiA9IGdldFNlbGVjdGlvbihhY3RpdmVFbGVtZW50KTtcbiAgaWYgKCFsYXN0U2VsZWN0aW9uIHx8ICFzaGFsbG93RXF1YWwobGFzdFNlbGVjdGlvbiwgY3VycmVudFNlbGVjdGlvbikpIHtcbiAgICBsYXN0U2VsZWN0aW9uID0gY3VycmVudFNlbGVjdGlvbjtcblxuICAgIHZhciBzeW50aGV0aWNFdmVudCA9IFN5bnRoZXRpY0V2ZW50LmdldFBvb2xlZChcbiAgICAgIGV2ZW50VHlwZXMuc2VsZWN0LFxuICAgICAgYWN0aXZlRWxlbWVudElELFxuICAgICAgbmF0aXZlRXZlbnRcbiAgICApO1xuXG4gICAgc3ludGhldGljRXZlbnQudHlwZSA9ICdzZWxlY3QnO1xuICAgIHN5bnRoZXRpY0V2ZW50LnRhcmdldCA9IGFjdGl2ZUVsZW1lbnQ7XG5cbiAgICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoc3ludGhldGljRXZlbnQpO1xuXG4gICAgcmV0dXJuIHN5bnRoZXRpY0V2ZW50O1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBwbHVnaW4gY3JlYXRlcyBhbiBgb25TZWxlY3RgIGV2ZW50IHRoYXQgbm9ybWFsaXplcyBzZWxlY3QgZXZlbnRzXG4gKiBhY3Jvc3MgZm9ybSBlbGVtZW50cy5cbiAqXG4gKiBTdXBwb3J0ZWQgZWxlbWVudHMgYXJlOlxuICogLSBpbnB1dCAoc2VlIGBpc1RleHRJbnB1dEVsZW1lbnRgKVxuICogLSB0ZXh0YXJlYVxuICogLSBjb250ZW50RWRpdGFibGVcbiAqXG4gKiBUaGlzIGRpZmZlcnMgZnJvbSBuYXRpdmUgYnJvd3NlciBpbXBsZW1lbnRhdGlvbnMgaW4gdGhlIGZvbGxvd2luZyB3YXlzOlxuICogLSBGaXJlcyBvbiBjb250ZW50RWRpdGFibGUgZmllbGRzIGFzIHdlbGwgYXMgaW5wdXRzLlxuICogLSBGaXJlcyBmb3IgY29sbGFwc2VkIHNlbGVjdGlvbi5cbiAqIC0gRmlyZXMgYWZ0ZXIgdXNlciBpbnB1dC5cbiAqL1xudmFyIFNlbGVjdEV2ZW50UGx1Z2luID0ge1xuXG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdG9wTGV2ZWxUYXJnZXQgVGhlIGxpc3RlbmluZyBjb21wb25lbnQgcm9vdCBub2RlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUYXJnZXRJRCBJRCBvZiBgdG9wTGV2ZWxUYXJnZXRgLlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gICAqIEByZXR1cm4geyp9IEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxuICAgKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5leHRyYWN0RXZlbnRzfVxuICAgKi9cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24oXG4gICAgICB0b3BMZXZlbFR5cGUsXG4gICAgICB0b3BMZXZlbFRhcmdldCxcbiAgICAgIHRvcExldmVsVGFyZ2V0SUQsXG4gICAgICBuYXRpdmVFdmVudCkge1xuXG4gICAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICAgIC8vIFRyYWNrIHRoZSBpbnB1dCBub2RlIHRoYXQgaGFzIGZvY3VzLlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzOlxuICAgICAgICBpZiAoaXNUZXh0SW5wdXRFbGVtZW50KHRvcExldmVsVGFyZ2V0KSB8fFxuICAgICAgICAgICAgdG9wTGV2ZWxUYXJnZXQuY29udGVudEVkaXRhYmxlID09PSAndHJ1ZScpIHtcbiAgICAgICAgICBhY3RpdmVFbGVtZW50ID0gdG9wTGV2ZWxUYXJnZXQ7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudElEID0gdG9wTGV2ZWxUYXJnZXRJRDtcbiAgICAgICAgICBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BCbHVyOlxuICAgICAgICBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgYWN0aXZlRWxlbWVudElEID0gbnVsbDtcbiAgICAgICAgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAvLyBEb24ndCBmaXJlIHRoZSBldmVudCB3aGlsZSB0aGUgdXNlciBpcyBkcmFnZ2luZy4gVGhpcyBtYXRjaGVzIHRoZVxuICAgICAgLy8gc2VtYW50aWNzIG9mIHRoZSBuYXRpdmUgc2VsZWN0IGV2ZW50LlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93bjpcbiAgICAgICAgbW91c2VEb3duID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29udGV4dE1lbnU6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VVcDpcbiAgICAgICAgbW91c2VEb3duID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3RTZWxlY3RFdmVudChuYXRpdmVFdmVudCk7XG5cbiAgICAgIC8vIENocm9tZSBhbmQgSUUgZmlyZSBub24tc3RhbmRhcmQgZXZlbnQgd2hlbiBzZWxlY3Rpb24gaXMgY2hhbmdlZCAoYW5kXG4gICAgICAvLyBzb21ldGltZXMgd2hlbiBpdCBoYXNuJ3QpLlxuICAgICAgLy8gRmlyZWZveCBkb2Vzbid0IHN1cHBvcnQgc2VsZWN0aW9uY2hhbmdlLCBzbyBjaGVjayBzZWxlY3Rpb24gc3RhdHVzXG4gICAgICAvLyBhZnRlciBlYWNoIGtleSBlbnRyeS4gVGhlIHNlbGVjdGlvbiBjaGFuZ2VzIGFmdGVyIGtleWRvd24gYW5kIGJlZm9yZVxuICAgICAgLy8ga2V5dXAsIGJ1dCB3ZSBjaGVjayBvbiBrZXlkb3duIGFzIHdlbGwgaW4gdGhlIGNhc2Ugb2YgaG9sZGluZyBkb3duIGFcbiAgICAgIC8vIGtleSwgd2hlbiBtdWx0aXBsZSBrZXlkb3duIGV2ZW50cyBhcmUgZmlyZWQgYnV0IG9ubHkgb25lIGtleXVwIGlzLlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFNlbGVjdGlvbkNoYW5nZTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleVVwOlxuICAgICAgICByZXR1cm4gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZWxlY3RFdmVudFBsdWdpbjtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTZXJ2ZXJSZWFjdFJvb3RJbmRleFxuICogQHR5cGVjaGVja3NcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBTaXplIG9mIHRoZSByZWFjdFJvb3QgSUQgc3BhY2UuIFdlIGdlbmVyYXRlIHJhbmRvbSBudW1iZXJzIGZvciBSZWFjdCByb290XG4gKiBJRHMgYW5kIGlmIHRoZXJlJ3MgYSBjb2xsaXNpb24gdGhlIGV2ZW50cyBhbmQgRE9NIHVwZGF0ZSBzeXN0ZW0gd2lsbFxuICogZ2V0IGNvbmZ1c2VkLiBJbiB0aGUgZnV0dXJlIHdlIG5lZWQgYSB3YXkgdG8gZ2VuZXJhdGUgR1VJRHMgYnV0IGZvclxuICogbm93IHRoaXMgd2lsbCB3b3JrIG9uIGEgc21hbGxlciBzY2FsZS5cbiAqL1xudmFyIEdMT0JBTF9NT1VOVF9QT0lOVF9NQVggPSBNYXRoLnBvdygyLCA1Myk7XG5cbnZhciBTZXJ2ZXJSZWFjdFJvb3RJbmRleCA9IHtcbiAgY3JlYXRlUmVhY3RSb290SW5kZXg6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBNYXRoLmNlaWwoTWF0aC5yYW5kb20oKSAqIEdMT0JBTF9NT1VOVF9QT0lOVF9NQVgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlcnZlclJlYWN0Um9vdEluZGV4O1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTaW1wbGVFdmVudFBsdWdpblxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKFwiLi9FdmVudENvbnN0YW50c1wiKTtcbnZhciBFdmVudFBsdWdpblV0aWxzID0gcmVxdWlyZShcIi4vRXZlbnRQbHVnaW5VdGlsc1wiKTtcbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZShcIi4vRXZlbnRQcm9wYWdhdG9yc1wiKTtcbnZhciBTeW50aGV0aWNDbGlwYm9hcmRFdmVudCA9IHJlcXVpcmUoXCIuL1N5bnRoZXRpY0NsaXBib2FyZEV2ZW50XCIpO1xudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZShcIi4vU3ludGhldGljRXZlbnRcIik7XG52YXIgU3ludGhldGljRm9jdXNFdmVudCA9IHJlcXVpcmUoXCIuL1N5bnRoZXRpY0ZvY3VzRXZlbnRcIik7XG52YXIgU3ludGhldGljS2V5Ym9hcmRFdmVudCA9IHJlcXVpcmUoXCIuL1N5bnRoZXRpY0tleWJvYXJkRXZlbnRcIik7XG52YXIgU3ludGhldGljTW91c2VFdmVudCA9IHJlcXVpcmUoXCIuL1N5bnRoZXRpY01vdXNlRXZlbnRcIik7XG52YXIgU3ludGhldGljRHJhZ0V2ZW50ID0gcmVxdWlyZShcIi4vU3ludGhldGljRHJhZ0V2ZW50XCIpO1xudmFyIFN5bnRoZXRpY1RvdWNoRXZlbnQgPSByZXF1aXJlKFwiLi9TeW50aGV0aWNUb3VjaEV2ZW50XCIpO1xudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSByZXF1aXJlKFwiLi9TeW50aGV0aWNVSUV2ZW50XCIpO1xudmFyIFN5bnRoZXRpY1doZWVsRXZlbnQgPSByZXF1aXJlKFwiLi9TeW50aGV0aWNXaGVlbEV2ZW50XCIpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xudmFyIGtleU9mID0gcmVxdWlyZShcIi4va2V5T2ZcIik7XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcblxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIGJsdXI6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2Yoe29uQmx1cjogdHJ1ZX0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHtvbkJsdXJDYXB0dXJlOiB0cnVlfSlcbiAgICB9XG4gIH0sXG4gIGNsaWNrOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHtvbkNsaWNrOiB0cnVlfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2Yoe29uQ2xpY2tDYXB0dXJlOiB0cnVlfSlcbiAgICB9XG4gIH0sXG4gIGNvbnRleHRNZW51OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHtvbkNvbnRleHRNZW51OiB0cnVlfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2Yoe29uQ29udGV4dE1lbnVDYXB0dXJlOiB0cnVlfSlcbiAgICB9XG4gIH0sXG4gIGNvcHk6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2Yoe29uQ29weTogdHJ1ZX0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHtvbkNvcHlDYXB0dXJlOiB0cnVlfSlcbiAgICB9XG4gIH0sXG4gIGN1dDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7b25DdXQ6IHRydWV9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7b25DdXRDYXB0dXJlOiB0cnVlfSlcbiAgICB9XG4gIH0sXG4gIGRvdWJsZUNsaWNrOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHtvbkRvdWJsZUNsaWNrOiB0cnVlfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2Yoe29uRG91YmxlQ2xpY2tDYXB0dXJlOiB0cnVlfSlcbiAgICB9XG4gIH0sXG4gIGRyYWc6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2Yoe29uRHJhZzogdHJ1ZX0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHtvbkRyYWdDYXB0dXJlOiB0cnVlfSlcbiAgICB9XG4gIH0sXG4gIGRyYWdFbmQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2Yoe29uRHJhZ0VuZDogdHJ1ZX0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHtvbkRyYWdFbmRDYXB0dXJlOiB0cnVlfSlcbiAgICB9XG4gIH0sXG4gIGRyYWdFbnRlcjoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7b25EcmFnRW50ZXI6IHRydWV9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7b25EcmFnRW50ZXJDYXB0dXJlOiB0cnVlfSlcbiAgICB9XG4gIH0sXG4gIGRyYWdFeGl0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHtvbkRyYWdFeGl0OiB0cnVlfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2Yoe29uRHJhZ0V4aXRDYXB0dXJlOiB0cnVlfSlcbiAgICB9XG4gIH0sXG4gIGRyYWdMZWF2ZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7b25EcmFnTGVhdmU6IHRydWV9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7b25EcmFnTGVhdmVDYXB0dXJlOiB0cnVlfSlcbiAgICB9XG4gIH0sXG4gIGRyYWdPdmVyOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHtvbkRyYWdPdmVyOiB0cnVlfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2Yoe29uRHJhZ092ZXJDYXB0dXJlOiB0cnVlfSlcbiAgICB9XG4gIH0sXG4gIGRyYWdTdGFydDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7b25EcmFnU3RhcnQ6IHRydWV9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7b25EcmFnU3RhcnRDYXB0dXJlOiB0cnVlfSlcbiAgICB9XG4gIH0sXG4gIGRyb3A6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2Yoe29uRHJvcDogdHJ1ZX0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHtvbkRyb3BDYXB0dXJlOiB0cnVlfSlcbiAgICB9XG4gIH0sXG4gIGZvY3VzOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHtvbkZvY3VzOiB0cnVlfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2Yoe29uRm9jdXNDYXB0dXJlOiB0cnVlfSlcbiAgICB9XG4gIH0sXG4gIGlucHV0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHtvbklucHV0OiB0cnVlfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2Yoe29uSW5wdXRDYXB0dXJlOiB0cnVlfSlcbiAgICB9XG4gIH0sXG4gIGtleURvd246IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2Yoe29uS2V5RG93bjogdHJ1ZX0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHtvbktleURvd25DYXB0dXJlOiB0cnVlfSlcbiAgICB9XG4gIH0sXG4gIGtleVByZXNzOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHtvbktleVByZXNzOiB0cnVlfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2Yoe29uS2V5UHJlc3NDYXB0dXJlOiB0cnVlfSlcbiAgICB9XG4gIH0sXG4gIGtleVVwOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHtvbktleVVwOiB0cnVlfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2Yoe29uS2V5VXBDYXB0dXJlOiB0cnVlfSlcbiAgICB9XG4gIH0sXG4gIGxvYWQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2Yoe29uTG9hZDogdHJ1ZX0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHtvbkxvYWRDYXB0dXJlOiB0cnVlfSlcbiAgICB9XG4gIH0sXG4gIGVycm9yOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHtvbkVycm9yOiB0cnVlfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2Yoe29uRXJyb3JDYXB0dXJlOiB0cnVlfSlcbiAgICB9XG4gIH0sXG4gIC8vIE5vdGU6IFdlIGRvIG5vdCBhbGxvdyBsaXN0ZW5pbmcgdG8gbW91c2VPdmVyIGV2ZW50cy4gSW5zdGVhZCwgdXNlIHRoZVxuICAvLyBvbk1vdXNlRW50ZXIvb25Nb3VzZUxlYXZlIGNyZWF0ZWQgYnkgYEVudGVyTGVhdmVFdmVudFBsdWdpbmAuXG4gIG1vdXNlRG93bjoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7b25Nb3VzZURvd246IHRydWV9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7b25Nb3VzZURvd25DYXB0dXJlOiB0cnVlfSlcbiAgICB9XG4gIH0sXG4gIG1vdXNlTW92ZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7b25Nb3VzZU1vdmU6IHRydWV9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7b25Nb3VzZU1vdmVDYXB0dXJlOiB0cnVlfSlcbiAgICB9XG4gIH0sXG4gIG1vdXNlT3V0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHtvbk1vdXNlT3V0OiB0cnVlfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2Yoe29uTW91c2VPdXRDYXB0dXJlOiB0cnVlfSlcbiAgICB9XG4gIH0sXG4gIG1vdXNlT3Zlcjoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7b25Nb3VzZU92ZXI6IHRydWV9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7b25Nb3VzZU92ZXJDYXB0dXJlOiB0cnVlfSlcbiAgICB9XG4gIH0sXG4gIG1vdXNlVXA6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2Yoe29uTW91c2VVcDogdHJ1ZX0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHtvbk1vdXNlVXBDYXB0dXJlOiB0cnVlfSlcbiAgICB9XG4gIH0sXG4gIHBhc3RlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHtvblBhc3RlOiB0cnVlfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2Yoe29uUGFzdGVDYXB0dXJlOiB0cnVlfSlcbiAgICB9XG4gIH0sXG4gIHJlc2V0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHtvblJlc2V0OiB0cnVlfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2Yoe29uUmVzZXRDYXB0dXJlOiB0cnVlfSlcbiAgICB9XG4gIH0sXG4gIHNjcm9sbDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7b25TY3JvbGw6IHRydWV9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7b25TY3JvbGxDYXB0dXJlOiB0cnVlfSlcbiAgICB9XG4gIH0sXG4gIHN1Ym1pdDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7b25TdWJtaXQ6IHRydWV9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7b25TdWJtaXRDYXB0dXJlOiB0cnVlfSlcbiAgICB9XG4gIH0sXG4gIHRvdWNoQ2FuY2VsOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHtvblRvdWNoQ2FuY2VsOiB0cnVlfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2Yoe29uVG91Y2hDYW5jZWxDYXB0dXJlOiB0cnVlfSlcbiAgICB9XG4gIH0sXG4gIHRvdWNoRW5kOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHtvblRvdWNoRW5kOiB0cnVlfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2Yoe29uVG91Y2hFbmRDYXB0dXJlOiB0cnVlfSlcbiAgICB9XG4gIH0sXG4gIHRvdWNoTW92ZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7b25Ub3VjaE1vdmU6IHRydWV9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7b25Ub3VjaE1vdmVDYXB0dXJlOiB0cnVlfSlcbiAgICB9XG4gIH0sXG4gIHRvdWNoU3RhcnQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2Yoe29uVG91Y2hTdGFydDogdHJ1ZX0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHtvblRvdWNoU3RhcnRDYXB0dXJlOiB0cnVlfSlcbiAgICB9XG4gIH0sXG4gIHdoZWVsOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHtvbldoZWVsOiB0cnVlfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2Yoe29uV2hlZWxDYXB0dXJlOiB0cnVlfSlcbiAgICB9XG4gIH1cbn07XG5cbnZhciB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWcgPSB7XG4gIHRvcEJsdXI6ICAgICAgICBldmVudFR5cGVzLmJsdXIsXG4gIHRvcENsaWNrOiAgICAgICBldmVudFR5cGVzLmNsaWNrLFxuICB0b3BDb250ZXh0TWVudTogZXZlbnRUeXBlcy5jb250ZXh0TWVudSxcbiAgdG9wQ29weTogICAgICAgIGV2ZW50VHlwZXMuY29weSxcbiAgdG9wQ3V0OiAgICAgICAgIGV2ZW50VHlwZXMuY3V0LFxuICB0b3BEb3VibGVDbGljazogZXZlbnRUeXBlcy5kb3VibGVDbGljayxcbiAgdG9wRHJhZzogICAgICAgIGV2ZW50VHlwZXMuZHJhZyxcbiAgdG9wRHJhZ0VuZDogICAgIGV2ZW50VHlwZXMuZHJhZ0VuZCxcbiAgdG9wRHJhZ0VudGVyOiAgIGV2ZW50VHlwZXMuZHJhZ0VudGVyLFxuICB0b3BEcmFnRXhpdDogICAgZXZlbnRUeXBlcy5kcmFnRXhpdCxcbiAgdG9wRHJhZ0xlYXZlOiAgIGV2ZW50VHlwZXMuZHJhZ0xlYXZlLFxuICB0b3BEcmFnT3ZlcjogICAgZXZlbnRUeXBlcy5kcmFnT3ZlcixcbiAgdG9wRHJhZ1N0YXJ0OiAgIGV2ZW50VHlwZXMuZHJhZ1N0YXJ0LFxuICB0b3BEcm9wOiAgICAgICAgZXZlbnRUeXBlcy5kcm9wLFxuICB0b3BFcnJvcjogICAgICAgZXZlbnRUeXBlcy5lcnJvcixcbiAgdG9wRm9jdXM6ICAgICAgIGV2ZW50VHlwZXMuZm9jdXMsXG4gIHRvcElucHV0OiAgICAgICBldmVudFR5cGVzLmlucHV0LFxuICB0b3BLZXlEb3duOiAgICAgZXZlbnRUeXBlcy5rZXlEb3duLFxuICB0b3BLZXlQcmVzczogICAgZXZlbnRUeXBlcy5rZXlQcmVzcyxcbiAgdG9wS2V5VXA6ICAgICAgIGV2ZW50VHlwZXMua2V5VXAsXG4gIHRvcExvYWQ6ICAgICAgICBldmVudFR5cGVzLmxvYWQsXG4gIHRvcE1vdXNlRG93bjogICBldmVudFR5cGVzLm1vdXNlRG93bixcbiAgdG9wTW91c2VNb3ZlOiAgIGV2ZW50VHlwZXMubW91c2VNb3ZlLFxuICB0b3BNb3VzZU91dDogICAgZXZlbnRUeXBlcy5tb3VzZU91dCxcbiAgdG9wTW91c2VPdmVyOiAgIGV2ZW50VHlwZXMubW91c2VPdmVyLFxuICB0b3BNb3VzZVVwOiAgICAgZXZlbnRUeXBlcy5tb3VzZVVwLFxuICB0b3BQYXN0ZTogICAgICAgZXZlbnRUeXBlcy5wYXN0ZSxcbiAgdG9wUmVzZXQ6ICAgICAgIGV2ZW50VHlwZXMucmVzZXQsXG4gIHRvcFNjcm9sbDogICAgICBldmVudFR5cGVzLnNjcm9sbCxcbiAgdG9wU3VibWl0OiAgICAgIGV2ZW50VHlwZXMuc3VibWl0LFxuICB0b3BUb3VjaENhbmNlbDogZXZlbnRUeXBlcy50b3VjaENhbmNlbCxcbiAgdG9wVG91Y2hFbmQ6ICAgIGV2ZW50VHlwZXMudG91Y2hFbmQsXG4gIHRvcFRvdWNoTW92ZTogICBldmVudFR5cGVzLnRvdWNoTW92ZSxcbiAgdG9wVG91Y2hTdGFydDogIGV2ZW50VHlwZXMudG91Y2hTdGFydCxcbiAgdG9wV2hlZWw6ICAgICAgIGV2ZW50VHlwZXMud2hlZWxcbn07XG5cbmZvciAodmFyIHRvcExldmVsVHlwZSBpbiB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWcpIHtcbiAgdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnW3RvcExldmVsVHlwZV0uZGVwZW5kZW5jaWVzID0gW3RvcExldmVsVHlwZV07XG59XG5cbnZhciBTaW1wbGVFdmVudFBsdWdpbiA9IHtcblxuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxuXG4gIC8qKlxuICAgKiBTYW1lIGFzIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uLCBleGNlcHQgY2FuY2VscyB0aGUgZXZlbnQgd2hlbiByZXR1cm5cbiAgICogdmFsdWUgaXMgZmFsc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBFdmVudCB0byBiZSBkaXNwYXRjaGVkLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBBcHBsaWNhdGlvbi1sZXZlbCBjYWxsYmFjay5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGRvbUlEIERPTSBJRCB0byBwYXNzIHRvIHRoZSBjYWxsYmFjay5cbiAgICovXG4gIGV4ZWN1dGVEaXNwYXRjaDogZnVuY3Rpb24oZXZlbnQsIGxpc3RlbmVyLCBkb21JRCkge1xuICAgIHZhciByZXR1cm5WYWx1ZSA9IEV2ZW50UGx1Z2luVXRpbHMuZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBsaXN0ZW5lciwgZG9tSUQpO1xuICAgIGlmIChyZXR1cm5WYWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdG9wTGV2ZWxUYXJnZXQgVGhlIGxpc3RlbmluZyBjb21wb25lbnQgcm9vdCBub2RlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUYXJnZXRJRCBJRCBvZiBgdG9wTGV2ZWxUYXJnZXRgLlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gICAqIEByZXR1cm4geyp9IEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxuICAgKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5leHRyYWN0RXZlbnRzfVxuICAgKi9cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24oXG4gICAgICB0b3BMZXZlbFR5cGUsXG4gICAgICB0b3BMZXZlbFRhcmdldCxcbiAgICAgIHRvcExldmVsVGFyZ2V0SUQsXG4gICAgICBuYXRpdmVFdmVudCkge1xuICAgIHZhciBkaXNwYXRjaENvbmZpZyA9IHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZ1t0b3BMZXZlbFR5cGVdO1xuICAgIGlmICghZGlzcGF0Y2hDb25maWcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgRXZlbnRDb25zdHJ1Y3RvcjtcbiAgICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcElucHV0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcExvYWQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRXJyb3I6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wUmVzZXQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wU3VibWl0OlxuICAgICAgICAvLyBIVE1MIEV2ZW50c1xuICAgICAgICAvLyBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2luZGV4Lmh0bWwjZXZlbnRzLTBcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0V2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzczpcbiAgICAgICAgLy8gRmlyZUZveCBjcmVhdGVzIGEga2V5cHJlc3MgZXZlbnQgZm9yIGZ1bmN0aW9uIGtleXMgdG9vLiBUaGlzIHJlbW92ZXNcbiAgICAgICAgLy8gdGhlIHVud2FudGVkIGtleXByZXNzIGV2ZW50cy5cbiAgICAgICAgaWYgKG5hdGl2ZUV2ZW50LmNoYXJDb2RlID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleURvd246XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5VXA6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNLZXlib2FyZEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BCbHVyOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljRm9jdXNFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ2xpY2s6XG4gICAgICAgIC8vIEZpcmVmb3ggY3JlYXRlcyBhIGNsaWNrIGV2ZW50IG9uIHJpZ2h0IG1vdXNlIGNsaWNrcy4gVGhpcyByZW1vdmVzIHRoZVxuICAgICAgICAvLyB1bndhbnRlZCBjbGljayBldmVudHMuXG4gICAgICAgIGlmIChuYXRpdmVFdmVudC5idXR0b24gPT09IDIpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29udGV4dE1lbnU6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRG91YmxlQ2xpY2s6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VEb3duOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlTW92ZTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU91dDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU92ZXI6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VVcDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY01vdXNlRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWc6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJhZ0VuZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcmFnRW50ZXI6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJhZ0V4aXQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJhZ0xlYXZlOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWdPdmVyOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWdTdGFydDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcm9wOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljRHJhZ0V2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BUb3VjaENhbmNlbDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BUb3VjaEVuZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BUb3VjaE1vdmU6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVG91Y2hTdGFydDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1RvdWNoRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFNjcm9sbDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1VJRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFdoZWVsOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljV2hlZWxFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29weTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDdXQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wUGFzdGU6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNDbGlwYm9hcmRFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICBFdmVudENvbnN0cnVjdG9yLFxuICAgICAgJ1NpbXBsZUV2ZW50UGx1Z2luOiBVbmhhbmRsZWQgZXZlbnQgdHlwZSwgYCVzYC4nLFxuICAgICAgdG9wTGV2ZWxUeXBlXG4gICAgKSA6IGludmFyaWFudChFdmVudENvbnN0cnVjdG9yKSk7XG4gICAgdmFyIGV2ZW50ID0gRXZlbnRDb25zdHJ1Y3Rvci5nZXRQb29sZWQoXG4gICAgICBkaXNwYXRjaENvbmZpZyxcbiAgICAgIHRvcExldmVsVGFyZ2V0SUQsXG4gICAgICBuYXRpdmVFdmVudFxuICAgICk7XG4gICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTaW1wbGVFdmVudFBsdWdpbjtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKFwiLi9TeW50aGV0aWNFdmVudFwiKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NsaXBib2FyZC1hcGlzL1xuICovXG52YXIgQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGNsaXBib2FyZERhdGE6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgcmV0dXJuIChcbiAgICAgICdjbGlwYm9hcmREYXRhJyBpbiBldmVudCA/XG4gICAgICAgIGV2ZW50LmNsaXBib2FyZERhdGEgOlxuICAgICAgICB3aW5kb3cuY2xpcGJvYXJkRGF0YVxuICAgICk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQpIHtcbiAgU3ludGhldGljRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50LCBDbGlwYm9hcmRFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljQ2xpcGJvYXJkRXZlbnQ7XG5cbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKFwiLi9TeW50aGV0aWNFdmVudFwiKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWNvbXBvc2l0aW9uZXZlbnRzXG4gKi9cbnZhciBDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlID0ge1xuICBkYXRhOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50KFxuICBkaXNwYXRjaENvbmZpZyxcbiAgZGlzcGF0Y2hNYXJrZXIsXG4gIG5hdGl2ZUV2ZW50KSB7XG4gIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCk7XG59XG5cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyhcbiAgU3ludGhldGljQ29tcG9zaXRpb25FdmVudCxcbiAgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZVxuKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50O1xuXG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljRHJhZ0V2ZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgU3ludGhldGljTW91c2VFdmVudCA9IHJlcXVpcmUoXCIuL1N5bnRoZXRpY01vdXNlRXZlbnRcIik7XG5cbi8qKlxuICogQGludGVyZmFjZSBEcmFnRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgRHJhZ0V2ZW50SW50ZXJmYWNlID0ge1xuICBkYXRhVHJhbnNmZXI6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0RyYWdFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50KSB7XG4gIFN5bnRoZXRpY01vdXNlRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50KTtcbn1cblxuU3ludGhldGljTW91c2VFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljRHJhZ0V2ZW50LCBEcmFnRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0RyYWdFdmVudDtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNFdmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZShcIi4vUG9vbGVkQ2xhc3NcIik7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZShcIi4vZW1wdHlGdW5jdGlvblwiKTtcbnZhciBnZXRFdmVudFRhcmdldCA9IHJlcXVpcmUoXCIuL2dldEV2ZW50VGFyZ2V0XCIpO1xudmFyIG1lcmdlID0gcmVxdWlyZShcIi4vbWVyZ2VcIik7XG52YXIgbWVyZ2VJbnRvID0gcmVxdWlyZShcIi4vbWVyZ2VJbnRvXCIpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHR5cGU6IG51bGwsXG4gIHRhcmdldDogZ2V0RXZlbnRUYXJnZXQsXG4gIC8vIGN1cnJlbnRUYXJnZXQgaXMgc2V0IHdoZW4gZGlzcGF0Y2hpbmc7IG5vIHVzZSBpbiBjb3B5aW5nIGl0IGhlcmVcbiAgY3VycmVudFRhcmdldDogZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwsXG4gIGV2ZW50UGhhc2U6IG51bGwsXG4gIGJ1YmJsZXM6IG51bGwsXG4gIGNhbmNlbGFibGU6IG51bGwsXG4gIHRpbWVTdGFtcDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG4gIH0sXG4gIGRlZmF1bHRQcmV2ZW50ZWQ6IG51bGwsXG4gIGlzVHJ1c3RlZDogbnVsbFxufTtcblxuLyoqXG4gKiBTeW50aGV0aWMgZXZlbnRzIGFyZSBkaXNwYXRjaGVkIGJ5IGV2ZW50IHBsdWdpbnMsIHR5cGljYWxseSBpbiByZXNwb25zZSB0byBhXG4gKiB0b3AtbGV2ZWwgZXZlbnQgZGVsZWdhdGlvbiBoYW5kbGVyLlxuICpcbiAqIFRoZXNlIHN5c3RlbXMgc2hvdWxkIGdlbmVyYWxseSB1c2UgcG9vbGluZyB0byByZWR1Y2UgdGhlIGZyZXF1ZW5jeSBvZiBnYXJiYWdlXG4gKiBjb2xsZWN0aW9uLiBUaGUgc3lzdGVtIHNob3VsZCBjaGVjayBgaXNQZXJzaXN0ZW50YCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGVcbiAqIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBpbnRvIHRoZSBwb29sIGFmdGVyIGJlaW5nIGRpc3BhdGNoZWQuIFVzZXJzIHRoYXRcbiAqIG5lZWQgYSBwZXJzaXN0ZWQgZXZlbnQgc2hvdWxkIGludm9rZSBgcGVyc2lzdGAuXG4gKlxuICogU3ludGhldGljIGV2ZW50cyAoYW5kIHN1YmNsYXNzZXMpIGltcGxlbWVudCB0aGUgRE9NIExldmVsIDMgRXZlbnRzIEFQSSBieVxuICogbm9ybWFsaXppbmcgYnJvd3NlciBxdWlya3MuIFN1YmNsYXNzZXMgZG8gbm90IG5lY2Vzc2FyaWx5IGhhdmUgdG8gaW1wbGVtZW50IGFcbiAqIERPTSBpbnRlcmZhY2U7IGN1c3RvbSBhcHBsaWNhdGlvbi1zcGVjaWZpYyBldmVudHMgY2FuIGFsc28gc3ViY2xhc3MgdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0V2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQpIHtcbiAgdGhpcy5kaXNwYXRjaENvbmZpZyA9IGRpc3BhdGNoQ29uZmlnO1xuICB0aGlzLmRpc3BhdGNoTWFya2VyID0gZGlzcGF0Y2hNYXJrZXI7XG4gIHRoaXMubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcblxuICB2YXIgSW50ZXJmYWNlID0gdGhpcy5jb25zdHJ1Y3Rvci5JbnRlcmZhY2U7XG4gIGZvciAodmFyIHByb3BOYW1lIGluIEludGVyZmFjZSkge1xuICAgIGlmICghSW50ZXJmYWNlLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBub3JtYWxpemUgPSBJbnRlcmZhY2VbcHJvcE5hbWVdO1xuICAgIGlmIChub3JtYWxpemUpIHtcbiAgICAgIHRoaXNbcHJvcE5hbWVdID0gbm9ybWFsaXplKG5hdGl2ZUV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1twcm9wTmFtZV0gPSBuYXRpdmVFdmVudFtwcm9wTmFtZV07XG4gICAgfVxuICB9XG5cbiAgdmFyIGRlZmF1bHRQcmV2ZW50ZWQgPSBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkICE9IG51bGwgP1xuICAgIG5hdGl2ZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgOlxuICAgIG5hdGl2ZUV2ZW50LnJldHVyblZhbHVlID09PSBmYWxzZTtcbiAgaWYgKGRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlO1xuICB9XG4gIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2U7XG59XG5cbm1lcmdlSW50byhTeW50aGV0aWNFdmVudC5wcm90b3R5cGUsIHtcblxuICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0ID8gZXZlbnQucHJldmVudERlZmF1bHQoKSA6IGV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuICAgIHZhciBldmVudCA9IHRoaXMubmF0aXZlRXZlbnQ7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uID8gZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCkgOiBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogV2UgcmVsZWFzZSBhbGwgZGlzcGF0Y2hlZCBgU3ludGhldGljRXZlbnRgcyBhZnRlciBlYWNoIGV2ZW50IGxvb3AsIGFkZGluZ1xuICAgKiB0aGVtIGJhY2sgaW50byB0aGUgcG9vbC4gVGhpcyBhbGxvd3MgYSB3YXkgdG8gaG9sZCBvbnRvIGEgcmVmZXJlbmNlIHRoYXRcbiAgICogd29uJ3QgYmUgYWRkZWQgYmFjayBpbnRvIHRoZSBwb29sLlxuICAgKi9cbiAgcGVyc2lzdDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pc1BlcnNpc3RlbnQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgZXZlbnQgc2hvdWxkIGJlIHJlbGVhc2VkIGJhY2sgaW50byB0aGUgcG9vbC5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGlzIHNob3VsZCBub3QgYmUgcmVsZWFzZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGlzUGVyc2lzdGVudDogZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlLFxuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciBgZGVzdHJ1Y3RvcmAgb24gZWFjaCBpbnN0YW5jZSBpdCByZWxlYXNlcy5cbiAgICovXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBJbnRlcmZhY2UgPSB0aGlzLmNvbnN0cnVjdG9yLkludGVyZmFjZTtcbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBJbnRlcmZhY2UpIHtcbiAgICAgIHRoaXNbcHJvcE5hbWVdID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5kaXNwYXRjaENvbmZpZyA9IG51bGw7XG4gICAgdGhpcy5kaXNwYXRjaE1hcmtlciA9IG51bGw7XG4gICAgdGhpcy5uYXRpdmVFdmVudCA9IG51bGw7XG4gIH1cblxufSk7XG5cblN5bnRoZXRpY0V2ZW50LkludGVyZmFjZSA9IEV2ZW50SW50ZXJmYWNlO1xuXG4vKipcbiAqIEhlbHBlciB0byByZWR1Y2UgYm9pbGVycGxhdGUgd2hlbiBjcmVhdGluZyBzdWJjbGFzc2VzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IENsYXNzXG4gKiBAcGFyYW0gez9vYmplY3R9IEludGVyZmFjZVxuICovXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MgPSBmdW5jdGlvbihDbGFzcywgSW50ZXJmYWNlKSB7XG4gIHZhciBTdXBlciA9IHRoaXM7XG5cbiAgdmFyIHByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3VwZXIucHJvdG90eXBlKTtcbiAgbWVyZ2VJbnRvKHByb3RvdHlwZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgQ2xhc3MucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICBDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDbGFzcztcblxuICBDbGFzcy5JbnRlcmZhY2UgPSBtZXJnZShTdXBlci5JbnRlcmZhY2UsIEludGVyZmFjZSk7XG4gIENsYXNzLmF1Z21lbnRDbGFzcyA9IFN1cGVyLmF1Z21lbnRDbGFzcztcblxuICBQb29sZWRDbGFzcy5hZGRQb29saW5nVG8oQ2xhc3MsIFBvb2xlZENsYXNzLnRocmVlQXJndW1lbnRQb29sZXIpO1xufTtcblxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKFN5bnRoZXRpY0V2ZW50LCBQb29sZWRDbGFzcy50aHJlZUFyZ3VtZW50UG9vbGVyKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNFdmVudDtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNGb2N1c0V2ZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoXCIuL1N5bnRoZXRpY1VJRXZlbnRcIik7XG5cbi8qKlxuICogQGludGVyZmFjZSBGb2N1c0V2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIEZvY3VzRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHJlbGF0ZWRUYXJnZXQ6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0ZvY3VzRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCkge1xuICBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0ZvY3VzRXZlbnQsIEZvY3VzRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0ZvY3VzRXZlbnQ7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzIEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY0lucHV0RXZlbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoXCIuL1N5bnRoZXRpY0V2ZW50XCIpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAxMzExMDVcbiAqICAgICAgLyNldmVudHMtaW5wdXRldmVudHNcbiAqL1xudmFyIElucHV0RXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRhdGE6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0lucHV0RXZlbnQoXG4gIGRpc3BhdGNoQ29uZmlnLFxuICBkaXNwYXRjaE1hcmtlcixcbiAgbmF0aXZlRXZlbnQpIHtcbiAgU3ludGhldGljRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFxuICBTeW50aGV0aWNJbnB1dEV2ZW50LFxuICBJbnB1dEV2ZW50SW50ZXJmYWNlXG4pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0lucHV0RXZlbnQ7XG5cbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNLZXlib2FyZEV2ZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoXCIuL1N5bnRoZXRpY1VJRXZlbnRcIik7XG5cbnZhciBnZXRFdmVudEtleSA9IHJlcXVpcmUoXCIuL2dldEV2ZW50S2V5XCIpO1xudmFyIGdldEV2ZW50TW9kaWZpZXJTdGF0ZSA9IHJlcXVpcmUoXCIuL2dldEV2ZW50TW9kaWZpZXJTdGF0ZVwiKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEtleWJvYXJkRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgS2V5Ym9hcmRFdmVudEludGVyZmFjZSA9IHtcbiAga2V5OiBnZXRFdmVudEtleSxcbiAgbG9jYXRpb246IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIHJlcGVhdDogbnVsbCxcbiAgbG9jYWxlOiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIC8vIExlZ2FjeSBJbnRlcmZhY2VcbiAgY2hhckNvZGU6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgLy8gYGNoYXJDb2RlYCBpcyB0aGUgcmVzdWx0IG9mIGEgS2V5UHJlc3MgZXZlbnQgYW5kIHJlcHJlc2VudHMgdGhlIHZhbHVlIG9mXG4gICAgLy8gdGhlIGFjdHVhbCBwcmludGFibGUgY2hhcmFjdGVyLlxuXG4gICAgLy8gS2V5UHJlc3MgaXMgZGVwcmVjYXRlZCBidXQgaXRzIHJlcGxhY2VtZW50IGlzIG5vdCB5ZXQgZmluYWwgYW5kIG5vdFxuICAgIC8vIGltcGxlbWVudGVkIGluIGFueSBtYWpvciBicm93c2VyLlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICAvLyBJRTggZG9lcyBub3QgaW1wbGVtZW50IFwiY2hhckNvZGVcIiwgYnV0IFwia2V5Q29kZVwiIGhhcyB0aGUgY29ycmVjdCB2YWx1ZS5cbiAgICAgIHJldHVybiAnY2hhckNvZGUnIGluIGV2ZW50ID8gZXZlbnQuY2hhckNvZGUgOiBldmVudC5rZXlDb2RlO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfSxcbiAga2V5Q29kZTogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAvLyBga2V5Q29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleURvd24vVXAgZXZlbnQgYW5kIHJlcHJlc2VudHMgdGhlIHZhbHVlIG9mXG4gICAgLy8gcGh5c2ljYWwga2V5Ym9hcmQga2V5LlxuXG4gICAgLy8gVGhlIGFjdHVhbCBtZWFuaW5nIG9mIHRoZSB2YWx1ZSBkZXBlbmRzIG9uIHRoZSB1c2Vycycga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gd2hpY2ggY2Fubm90IGJlIGRldGVjdGVkLiBBc3N1bWluZyB0aGF0IGl0IGlzIGEgVVMga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gcHJvdmlkZXMgYSBzdXJwcmlzaW5nbHkgYWNjdXJhdGUgbWFwcGluZyBmb3IgVVMgYW5kIEV1cm9wZWFuIHVzZXJzLlxuICAgIC8vIER1ZSB0byB0aGlzLCBpdCBpcyBsZWZ0IHRvIHRoZSB1c2VyIHRvIGltcGxlbWVudCBhdCB0aGlzIHRpbWUuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICByZXR1cm4gZXZlbnQua2V5Q29kZTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIHdoaWNoOiBmdW5jdGlvbihldmVudCkge1xuICAgIC8vIGB3aGljaGAgaXMgYW4gYWxpYXMgZm9yIGVpdGhlciBga2V5Q29kZWAgb3IgYGNoYXJDb2RlYCBkZXBlbmRpbmcgb24gdGhlXG4gICAgLy8gdHlwZSBvZiB0aGUgZXZlbnQuIFRoZXJlIGlzIG5vIG5lZWQgdG8gZGV0ZXJtaW5lIHRoZSB0eXBlIG9mIHRoZSBldmVudFxuICAgIC8vIGFzIGBrZXlDb2RlYCBhbmQgYGNoYXJDb2RlYCBhcmUgZWl0aGVyIGFsaWFzZWQgb3IgZGVmYXVsdCB0byB6ZXJvLlxuICAgIHJldHVybiBldmVudC5rZXlDb2RlIHx8IGV2ZW50LmNoYXJDb2RlO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNLZXlib2FyZEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQpIHtcbiAgU3ludGhldGljVUlFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNLZXlib2FyZEV2ZW50LCBLZXlib2FyZEV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNLZXlib2FyZEV2ZW50O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY01vdXNlRXZlbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gcmVxdWlyZShcIi4vU3ludGhldGljVUlFdmVudFwiKTtcbnZhciBWaWV3cG9ydE1ldHJpY3MgPSByZXF1aXJlKFwiLi9WaWV3cG9ydE1ldHJpY3NcIik7XG5cbnZhciBnZXRFdmVudE1vZGlmaWVyU3RhdGUgPSByZXF1aXJlKFwiLi9nZXRFdmVudE1vZGlmaWVyU3RhdGVcIik7XG5cbi8qKlxuICogQGludGVyZmFjZSBNb3VzZUV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIE1vdXNlRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHNjcmVlblg6IG51bGwsXG4gIHNjcmVlblk6IG51bGwsXG4gIGNsaWVudFg6IG51bGwsXG4gIGNsaWVudFk6IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZSxcbiAgYnV0dG9uOiBmdW5jdGlvbihldmVudCkge1xuICAgIC8vIFdlYmtpdCwgRmlyZWZveCwgSUU5K1xuICAgIC8vIHdoaWNoOiAgMSAyIDNcbiAgICAvLyBidXR0b246IDAgMSAyIChzdGFuZGFyZClcbiAgICB2YXIgYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xuICAgIGlmICgnd2hpY2gnIGluIGV2ZW50KSB7XG4gICAgICByZXR1cm4gYnV0dG9uO1xuICAgIH1cbiAgICAvLyBJRTw5XG4gICAgLy8gd2hpY2g6ICB1bmRlZmluZWRcbiAgICAvLyBidXR0b246IDAgMCAwXG4gICAgLy8gYnV0dG9uOiAxIDQgMiAob25tb3VzZXVwKVxuICAgIHJldHVybiBidXR0b24gPT09IDIgPyAyIDogYnV0dG9uID09PSA0ID8gMSA6IDA7XG4gIH0sXG4gIGJ1dHRvbnM6IG51bGwsXG4gIHJlbGF0ZWRUYXJnZXQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgKFxuICAgICAgZXZlbnQuZnJvbUVsZW1lbnQgPT09IGV2ZW50LnNyY0VsZW1lbnQgP1xuICAgICAgICBldmVudC50b0VsZW1lbnQgOlxuICAgICAgICBldmVudC5mcm9tRWxlbWVudFxuICAgICk7XG4gIH0sXG4gIC8vIFwiUHJvcHJpZXRhcnlcIiBJbnRlcmZhY2UuXG4gIHBhZ2VYOiBmdW5jdGlvbihldmVudCkge1xuICAgIHJldHVybiAncGFnZVgnIGluIGV2ZW50ID9cbiAgICAgIGV2ZW50LnBhZ2VYIDpcbiAgICAgIGV2ZW50LmNsaWVudFggKyBWaWV3cG9ydE1ldHJpY3MuY3VycmVudFNjcm9sbExlZnQ7XG4gIH0sXG4gIHBhZ2VZOiBmdW5jdGlvbihldmVudCkge1xuICAgIHJldHVybiAncGFnZVknIGluIGV2ZW50ID9cbiAgICAgIGV2ZW50LnBhZ2VZIDpcbiAgICAgIGV2ZW50LmNsaWVudFkgKyBWaWV3cG9ydE1ldHJpY3MuY3VycmVudFNjcm9sbFRvcDtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljTW91c2VFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50KSB7XG4gIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50KTtcbn1cblxuU3ludGhldGljVUlFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljTW91c2VFdmVudCwgTW91c2VFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljTW91c2VFdmVudDtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNUb3VjaEV2ZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoXCIuL1N5bnRoZXRpY1VJRXZlbnRcIik7XG5cbnZhciBnZXRFdmVudE1vZGlmaWVyU3RhdGUgPSByZXF1aXJlKFwiLi9nZXRFdmVudE1vZGlmaWVyU3RhdGVcIik7XG5cbi8qKlxuICogQGludGVyZmFjZSBUb3VjaEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL3RvdWNoLWV2ZW50cy9cbiAqL1xudmFyIFRvdWNoRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHRvdWNoZXM6IG51bGwsXG4gIHRhcmdldFRvdWNoZXM6IG51bGwsXG4gIGNoYW5nZWRUb3VjaGVzOiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGVcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1RvdWNoRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCkge1xuICBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1RvdWNoRXZlbnQsIFRvdWNoRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY1RvdWNoRXZlbnQ7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljVUlFdmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZShcIi4vU3ludGhldGljRXZlbnRcIik7XG5cbnZhciBnZXRFdmVudFRhcmdldCA9IHJlcXVpcmUoXCIuL2dldEV2ZW50VGFyZ2V0XCIpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgVUlFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBVSUV2ZW50SW50ZXJmYWNlID0ge1xuICB2aWV3OiBmdW5jdGlvbihldmVudCkge1xuICAgIGlmIChldmVudC52aWV3KSB7XG4gICAgICByZXR1cm4gZXZlbnQudmlldztcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQoZXZlbnQpO1xuICAgIGlmICh0YXJnZXQgIT0gbnVsbCAmJiB0YXJnZXQud2luZG93ID09PSB0YXJnZXQpIHtcbiAgICAgIC8vIHRhcmdldCBpcyBhIHdpbmRvdyBvYmplY3RcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgdmFyIGRvYyA9IHRhcmdldC5vd25lckRvY3VtZW50O1xuICAgIC8vIFRPRE86IEZpZ3VyZSBvdXQgd2h5IGBvd25lckRvY3VtZW50YCBpcyBzb21ldGltZXMgdW5kZWZpbmVkIGluIElFOC5cbiAgICBpZiAoZG9jKSB7XG4gICAgICByZXR1cm4gZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3c7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgfVxuICB9LFxuICBkZXRhaWw6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LmRldGFpbCB8fCAwO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljVUlFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50KSB7XG4gIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCk7XG59XG5cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNVSUV2ZW50LCBVSUV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNVSUV2ZW50O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY1doZWVsRXZlbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBTeW50aGV0aWNNb3VzZUV2ZW50ID0gcmVxdWlyZShcIi4vU3ludGhldGljTW91c2VFdmVudFwiKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIFdoZWVsRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgV2hlZWxFdmVudEludGVyZmFjZSA9IHtcbiAgZGVsdGFYOiBmdW5jdGlvbihldmVudCkge1xuICAgIHJldHVybiAoXG4gICAgICAnZGVsdGFYJyBpbiBldmVudCA/IGV2ZW50LmRlbHRhWCA6XG4gICAgICAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YVhgIGZvciBXZWJraXQgYW5kIG5vcm1hbGl6ZSAocmlnaHQgaXMgcG9zaXRpdmUpLlxuICAgICAgJ3doZWVsRGVsdGFYJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhWCA6IDBcbiAgICApO1xuICB9LFxuICBkZWx0YVk6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgcmV0dXJuIChcbiAgICAgICdkZWx0YVknIGluIGV2ZW50ID8gZXZlbnQuZGVsdGFZIDpcbiAgICAgIC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhWWAgZm9yIFdlYmtpdCBhbmQgbm9ybWFsaXplIChkb3duIGlzIHBvc2l0aXZlKS5cbiAgICAgICd3aGVlbERlbHRhWScgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YVkgOlxuICAgICAgLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFgIGZvciBJRTw5IGFuZCBub3JtYWxpemUgKGRvd24gaXMgcG9zaXRpdmUpLlxuICAgICAgJ3doZWVsRGVsdGEnIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGEgOiAwXG4gICAgKTtcbiAgfSxcbiAgZGVsdGFaOiBudWxsLFxuXG4gIC8vIEJyb3dzZXJzIHdpdGhvdXQgXCJkZWx0YU1vZGVcIiBpcyByZXBvcnRpbmcgaW4gcmF3IHdoZWVsIGRlbHRhIHdoZXJlIG9uZVxuICAvLyBub3RjaCBvbiB0aGUgc2Nyb2xsIGlzIGFsd2F5cyArLy0gMTIwLCByb3VnaGx5IGVxdWl2YWxlbnQgdG8gcGl4ZWxzLlxuICAvLyBBIGdvb2QgYXBwcm94aW1hdGlvbiBvZiBET01fREVMVEFfTElORSAoMSkgaXMgNSUgb2Ygdmlld3BvcnQgc2l6ZSBvclxuICAvLyB+NDAgcGl4ZWxzLCBmb3IgRE9NX0RFTFRBX1NDUkVFTiAoMikgaXQgaXMgODcuNSUgb2Ygdmlld3BvcnQgc2l6ZS5cbiAgZGVsdGFNb2RlOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNNb3VzZUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNXaGVlbEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQpIHtcbiAgU3ludGhldGljTW91c2VFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQpO1xufVxuXG5TeW50aGV0aWNNb3VzZUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNXaGVlbEV2ZW50LCBXaGVlbEV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNXaGVlbEV2ZW50O1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBUcmFuc2FjdGlvblxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xuXG4vKipcbiAqIGBUcmFuc2FjdGlvbmAgY3JlYXRlcyBhIGJsYWNrIGJveCB0aGF0IGlzIGFibGUgdG8gd3JhcCBhbnkgbWV0aG9kIHN1Y2ggdGhhdFxuICogY2VydGFpbiBpbnZhcmlhbnRzIGFyZSBtYWludGFpbmVkIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIG1ldGhvZCBpcyBpbnZva2VkXG4gKiAoRXZlbiBpZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIHdoaWxlIGludm9raW5nIHRoZSB3cmFwcGVkIG1ldGhvZCkuIFdob2V2ZXJcbiAqIGluc3RhbnRpYXRlcyBhIHRyYW5zYWN0aW9uIGNhbiBwcm92aWRlIGVuZm9yY2VycyBvZiB0aGUgaW52YXJpYW50cyBhdFxuICogY3JlYXRpb24gdGltZS4gVGhlIGBUcmFuc2FjdGlvbmAgY2xhc3MgaXRzZWxmIHdpbGwgc3VwcGx5IG9uZSBhZGRpdGlvbmFsXG4gKiBhdXRvbWF0aWMgaW52YXJpYW50IGZvciB5b3UgLSB0aGUgaW52YXJpYW50IHRoYXQgYW55IHRyYW5zYWN0aW9uIGluc3RhbmNlXG4gKiBzaG91bGQgbm90IGJlIHJ1biB3aGlsZSBpdCBpcyBhbHJlYWR5IGJlaW5nIHJ1bi4gWW91IHdvdWxkIHR5cGljYWxseSBjcmVhdGUgYVxuICogc2luZ2xlIGluc3RhbmNlIG9mIGEgYFRyYW5zYWN0aW9uYCBmb3IgcmV1c2UgbXVsdGlwbGUgdGltZXMsIHRoYXQgcG90ZW50aWFsbHlcbiAqIGlzIHVzZWQgdG8gd3JhcCBzZXZlcmFsIGRpZmZlcmVudCBtZXRob2RzLiBXcmFwcGVycyBhcmUgZXh0cmVtZWx5IHNpbXBsZSAtXG4gKiB0aGV5IG9ubHkgcmVxdWlyZSBpbXBsZW1lbnRpbmcgdHdvIG1ldGhvZHMuXG4gKlxuICogPHByZT5cbiAqICAgICAgICAgICAgICAgICAgICAgICB3cmFwcGVycyAoaW5qZWN0ZWQgYXQgY3JlYXRpb24gdGltZSlcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArICAgICAgICArXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLXwtLS0tLS0tLS0tLS0tLStcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICB2ICAgICAgICB8ICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgICAgICstLS0tLS0tLS0tLS0tLS0rICAgfCAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICArLS18ICAgIHdyYXBwZXIxICAgfC0tLXwtLS0tKyAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgKy0tLS0tLS0tLS0tLS0tLSsgICB2ICAgIHwgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHwgICAgICAgICAgKy0tLS0tLS0tLS0tLS0rICB8ICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB8ICAgICArLS0tLXwgICB3cmFwcGVyMiAgfC0tLS0tLS0tKyAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgICAgfCAgICArLS0tLS0tLS0tLS0tLSsgIHwgICAgIHwgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHwgICAgIHwgICAgICAgICAgICAgICAgICAgICB8ICAgICB8ICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB2ICAgICB2ICAgICAgICAgICAgICAgICAgICAgdiAgICAgdiAgIHwgd3JhcHBlclxuICogICAgICAgICAgICAgICAgICAgIHwgKy0tLSsgKy0tLSsgICArLS0tLS0tLS0tKyAgICstLS0rICstLS0rIHwgaW52YXJpYW50c1xuICogcGVyZm9ybShhbnlNZXRob2QpIHwgfCAgIHwgfCAgIHwgICB8ICAgICAgICAgfCAgIHwgICB8IHwgICB8IHwgbWFpbnRhaW5lZFxuICogKy0tLS0tLS0tLS0tLS0tLS0tPnwtfC0tLXwtfC0tLXwtLT58YW55TWV0aG9kfC0tLXwtLS18LXwtLS18LXwtLS0tLS0tLT5cbiAqICAgICAgICAgICAgICAgICAgICB8IHwgICB8IHwgICB8ICAgfCAgICAgICAgIHwgICB8ICAgfCB8ICAgfCB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCB8ICAgfCB8ICAgfCAgIHwgICAgICAgICB8ICAgfCAgIHwgfCAgIHwgfFxuICogICAgICAgICAgICAgICAgICAgIHwgfCAgIHwgfCAgIHwgICB8ICAgICAgICAgfCAgIHwgICB8IHwgICB8IHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICstLS0rICstLS0rICAgKy0tLS0tLS0tLSsgICArLS0tKyArLS0tKyB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgaW5pdGlhbGl6ZSAgICAgICAgICAgICAgICAgICAgY2xvc2UgICAgfFxuICogICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAqIDwvcHJlPlxuICpcbiAqIFVzZSBjYXNlczpcbiAqIC0gUHJlc2VydmluZyB0aGUgaW5wdXQgc2VsZWN0aW9uIHJhbmdlcyBiZWZvcmUvYWZ0ZXIgcmVjb25jaWxpYXRpb24uXG4gKiAgIFJlc3RvcmluZyBzZWxlY3Rpb24gZXZlbiBpbiB0aGUgZXZlbnQgb2YgYW4gdW5leHBlY3RlZCBlcnJvci5cbiAqIC0gRGVhY3RpdmF0aW5nIGV2ZW50cyB3aGlsZSByZWFycmFuZ2luZyB0aGUgRE9NLCBwcmV2ZW50aW5nIGJsdXJzL2ZvY3VzZXMsXG4gKiAgIHdoaWxlIGd1YXJhbnRlZWluZyB0aGF0IGFmdGVyd2FyZHMsIHRoZSBldmVudCBzeXN0ZW0gaXMgcmVhY3RpdmF0ZWQuXG4gKiAtIEZsdXNoaW5nIGEgcXVldWUgb2YgY29sbGVjdGVkIERPTSBtdXRhdGlvbnMgdG8gdGhlIG1haW4gVUkgdGhyZWFkIGFmdGVyIGFcbiAqICAgcmVjb25jaWxpYXRpb24gdGFrZXMgcGxhY2UgaW4gYSB3b3JrZXIgdGhyZWFkLlxuICogLSBJbnZva2luZyBhbnkgY29sbGVjdGVkIGBjb21wb25lbnREaWRVcGRhdGVgIGNhbGxiYWNrcyBhZnRlciByZW5kZXJpbmcgbmV3XG4gKiAgIGNvbnRlbnQuXG4gKiAtIChGdXR1cmUgdXNlIGNhc2UpOiBXcmFwcGluZyBwYXJ0aWN1bGFyIGZsdXNoZXMgb2YgdGhlIGBSZWFjdFdvcmtlcmAgcXVldWVcbiAqICAgdG8gcHJlc2VydmUgdGhlIGBzY3JvbGxUb3BgIChhbiBhdXRvbWF0aWMgc2Nyb2xsIGF3YXJlIERPTSkuXG4gKiAtIChGdXR1cmUgdXNlIGNhc2UpOiBMYXlvdXQgY2FsY3VsYXRpb25zIGJlZm9yZSBhbmQgYWZ0ZXIgRE9NIHVwYXRlcy5cbiAqXG4gKiBUcmFuc2FjdGlvbmFsIHBsdWdpbiBBUEk6XG4gKiAtIEEgbW9kdWxlIHRoYXQgaGFzIGFuIGBpbml0aWFsaXplYCBtZXRob2QgdGhhdCByZXR1cm5zIGFueSBwcmVjb21wdXRhdGlvbi5cbiAqIC0gYW5kIGEgYGNsb3NlYCBtZXRob2QgdGhhdCBhY2NlcHRzIHRoZSBwcmVjb21wdXRhdGlvbi4gYGNsb3NlYCBpcyBpbnZva2VkXG4gKiAgIHdoZW4gdGhlIHdyYXBwZWQgcHJvY2VzcyBpcyBjb21wbGV0ZWQsIG9yIGhhcyBmYWlsZWQuXG4gKlxuICogQHBhcmFtIHtBcnJheTxUcmFuc2FjdGlvbmFsV3JhcHBlcj59IHRyYW5zYWN0aW9uV3JhcHBlciBXcmFwcGVyIG1vZHVsZXNcbiAqIHRoYXQgaW1wbGVtZW50IGBpbml0aWFsaXplYCBhbmQgYGNsb3NlYC5cbiAqIEByZXR1cm4ge1RyYW5zYWN0aW9ufSBTaW5nbGUgdHJhbnNhY3Rpb24gZm9yIHJldXNlIGluIHRocmVhZC5cbiAqXG4gKiBAY2xhc3MgVHJhbnNhY3Rpb25cbiAqL1xudmFyIE1peGluID0ge1xuICAvKipcbiAgICogU2V0cyB1cCB0aGlzIGluc3RhbmNlIHNvIHRoYXQgaXQgaXMgcHJlcGFyZWQgZm9yIGNvbGxlY3RpbmcgbWV0cmljcy4gRG9lc1xuICAgKiBzbyBzdWNoIHRoYXQgdGhpcyBzZXR1cCBtZXRob2QgbWF5IGJlIHVzZWQgb24gYW4gaW5zdGFuY2UgdGhhdCBpcyBhbHJlYWR5XG4gICAqIGluaXRpYWxpemVkLCBpbiBhIHdheSB0aGF0IGRvZXMgbm90IGNvbnN1bWUgYWRkaXRpb25hbCBtZW1vcnkgdXBvbiByZXVzZS5cbiAgICogVGhhdCBjYW4gYmUgdXNlZnVsIGlmIHlvdSBkZWNpZGUgdG8gbWFrZSB5b3VyIHN1YmNsYXNzIG9mIHRoaXMgbWl4aW4gYVxuICAgKiBcIlBvb2xlZENsYXNzXCIuXG4gICAqL1xuICByZWluaXRpYWxpemVUcmFuc2FjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzID0gdGhpcy5nZXRUcmFuc2FjdGlvbldyYXBwZXJzKCk7XG4gICAgaWYgKCF0aGlzLndyYXBwZXJJbml0RGF0YSkge1xuICAgICAgdGhpcy53cmFwcGVySW5pdERhdGEgPSBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53cmFwcGVySW5pdERhdGEubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgdGhpcy5faXNJblRyYW5zYWN0aW9uID0gZmFsc2U7XG4gIH0sXG5cbiAgX2lzSW5UcmFuc2FjdGlvbjogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcmV0dXJuIHtBcnJheTxUcmFuc2FjdGlvbldyYXBwZXI+fSBBcnJheSBvZiB0cmFuc2FjdGlvbiB3cmFwcGVycy5cbiAgICovXG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IG51bGwsXG5cbiAgaXNJblRyYW5zYWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gISF0aGlzLl9pc0luVHJhbnNhY3Rpb247XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIHRoZSBmdW5jdGlvbiB3aXRoaW4gYSBzYWZldHkgd2luZG93LiBVc2UgdGhpcyBmb3IgdGhlIHRvcCBsZXZlbFxuICAgKiBtZXRob2RzIHRoYXQgcmVzdWx0IGluIGxhcmdlIGFtb3VudHMgb2YgY29tcHV0YXRpb24vbXV0YXRpb25zIHRoYXQgd291bGRcbiAgICogbmVlZCB0byBiZSBzYWZldHkgY2hlY2tlZC5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gbWV0aG9kIE1lbWJlciBvZiBzY29wZSB0byBjYWxsLlxuICAgKiBAcGFyYW0ge09iamVjdH0gc2NvcGUgU2NvcGUgdG8gaW52b2tlIGZyb20uXG4gICAqIEBwYXJhbSB7T2JqZWN0Pz19IGFyZ3MuLi4gQXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIG1ldGhvZCAob3B0aW9uYWwpLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIEhlbHBzIHByZXZlbnQgbmVlZCB0byBiaW5kIGluIG1hbnkgY2FzZXMuXG4gICAqIEByZXR1cm4gUmV0dXJuIHZhbHVlIGZyb20gYG1ldGhvZGAuXG4gICAqL1xuICBwZXJmb3JtOiBmdW5jdGlvbihtZXRob2QsIHNjb3BlLCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICF0aGlzLmlzSW5UcmFuc2FjdGlvbigpLFxuICAgICAgJ1RyYW5zYWN0aW9uLnBlcmZvcm0oLi4uKTogQ2Fubm90IGluaXRpYWxpemUgYSB0cmFuc2FjdGlvbiB3aGVuIHRoZXJlICcgK1xuICAgICAgJ2lzIGFscmVhZHkgYW4gb3V0c3RhbmRpbmcgdHJhbnNhY3Rpb24uJ1xuICAgICkgOiBpbnZhcmlhbnQoIXRoaXMuaXNJblRyYW5zYWN0aW9uKCkpKTtcbiAgICB2YXIgZXJyb3JUaHJvd247XG4gICAgdmFyIHJldDtcbiAgICB0cnkge1xuICAgICAgdGhpcy5faXNJblRyYW5zYWN0aW9uID0gdHJ1ZTtcbiAgICAgIC8vIENhdGNoaW5nIGVycm9ycyBtYWtlcyBkZWJ1Z2dpbmcgbW9yZSBkaWZmaWN1bHQsIHNvIHdlIHN0YXJ0IHdpdGhcbiAgICAgIC8vIGVycm9yVGhyb3duIHNldCB0byB0cnVlIGJlZm9yZSBzZXR0aW5nIGl0IHRvIGZhbHNlIGFmdGVyIGNhbGxpbmdcbiAgICAgIC8vIGNsb3NlIC0tIGlmIGl0J3Mgc3RpbGwgc2V0IHRvIHRydWUgaW4gdGhlIGZpbmFsbHkgYmxvY2ssIGl0IG1lYW5zXG4gICAgICAvLyBvbmUgb2YgdGhlc2UgY2FsbHMgdGhyZXcuXG4gICAgICBlcnJvclRocm93biA9IHRydWU7XG4gICAgICB0aGlzLmluaXRpYWxpemVBbGwoMCk7XG4gICAgICByZXQgPSBtZXRob2QuY2FsbChzY29wZSwgYSwgYiwgYywgZCwgZSwgZik7XG4gICAgICBlcnJvclRocm93biA9IGZhbHNlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoZXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAvLyBJZiBgbWV0aG9kYCB0aHJvd3MsIHByZWZlciB0byBzaG93IHRoYXQgc3RhY2sgdHJhY2Ugb3ZlciBhbnkgdGhyb3duXG4gICAgICAgICAgLy8gYnkgaW52b2tpbmcgYGNsb3NlQWxsYC5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZUFsbCgwKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gU2luY2UgYG1ldGhvZGAgZGlkbid0IHRocm93LCB3ZSBkb24ndCB3YW50IHRvIHNpbGVuY2UgdGhlIGV4Y2VwdGlvblxuICAgICAgICAgIC8vIGhlcmUuXG4gICAgICAgICAgdGhpcy5jbG9zZUFsbCgwKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5faXNJblRyYW5zYWN0aW9uID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZUFsbDogZnVuY3Rpb24oc3RhcnRJbmRleCkge1xuICAgIHZhciB0cmFuc2FjdGlvbldyYXBwZXJzID0gdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzO1xuICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDwgdHJhbnNhY3Rpb25XcmFwcGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHdyYXBwZXIgPSB0cmFuc2FjdGlvbldyYXBwZXJzW2ldO1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gQ2F0Y2hpbmcgZXJyb3JzIG1ha2VzIGRlYnVnZ2luZyBtb3JlIGRpZmZpY3VsdCwgc28gd2Ugc3RhcnQgd2l0aCB0aGVcbiAgICAgICAgLy8gT0JTRVJWRURfRVJST1Igc3RhdGUgYmVmb3JlIG92ZXJ3cml0aW5nIGl0IHdpdGggdGhlIHJlYWwgcmV0dXJuIHZhbHVlXG4gICAgICAgIC8vIG9mIGluaXRpYWxpemUgLS0gaWYgaXQncyBzdGlsbCBzZXQgdG8gT0JTRVJWRURfRVJST1IgaW4gdGhlIGZpbmFsbHlcbiAgICAgICAgLy8gYmxvY2ssIGl0IG1lYW5zIHdyYXBwZXIuaW5pdGlhbGl6ZSB0aHJldy5cbiAgICAgICAgdGhpcy53cmFwcGVySW5pdERhdGFbaV0gPSBUcmFuc2FjdGlvbi5PQlNFUlZFRF9FUlJPUjtcbiAgICAgICAgdGhpcy53cmFwcGVySW5pdERhdGFbaV0gPSB3cmFwcGVyLmluaXRpYWxpemUgP1xuICAgICAgICAgIHdyYXBwZXIuaW5pdGlhbGl6ZS5jYWxsKHRoaXMpIDpcbiAgICAgICAgICBudWxsO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHRoaXMud3JhcHBlckluaXREYXRhW2ldID09PSBUcmFuc2FjdGlvbi5PQlNFUlZFRF9FUlJPUikge1xuICAgICAgICAgIC8vIFRoZSBpbml0aWFsaXplciBmb3Igd3JhcHBlciBpIHRocmV3IGFuIGVycm9yOyBpbml0aWFsaXplIHRoZVxuICAgICAgICAgIC8vIHJlbWFpbmluZyB3cmFwcGVycyBidXQgc2lsZW5jZSBhbnkgZXhjZXB0aW9ucyBmcm9tIHRoZW0gdG8gZW5zdXJlXG4gICAgICAgICAgLy8gdGhhdCB0aGUgZmlyc3QgZXJyb3IgaXMgdGhlIG9uZSB0byBidWJibGUgdXAuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZUFsbChpICsgMSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJbnZva2VzIGVhY2ggb2YgYHRoaXMudHJhbnNhY3Rpb25XcmFwcGVycy5jbG9zZVtpXWAgZnVuY3Rpb25zLCBwYXNzaW5nIGludG9cbiAgICogdGhlbSB0aGUgcmVzcGVjdGl2ZSByZXR1cm4gdmFsdWVzIG9mIGB0aGlzLnRyYW5zYWN0aW9uV3JhcHBlcnMuaW5pdFtpXWBcbiAgICogKGBjbG9zZWBycyB0aGF0IGNvcnJlc3BvbmQgdG8gaW5pdGlhbGl6ZXJzIHRoYXQgZmFpbGVkIHdpbGwgbm90IGJlXG4gICAqIGludm9rZWQpLlxuICAgKi9cbiAgY2xvc2VBbGw6IGZ1bmN0aW9uKHN0YXJ0SW5kZXgpIHtcbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgdGhpcy5pc0luVHJhbnNhY3Rpb24oKSxcbiAgICAgICdUcmFuc2FjdGlvbi5jbG9zZUFsbCgpOiBDYW5ub3QgY2xvc2UgdHJhbnNhY3Rpb24gd2hlbiBub25lIGFyZSBvcGVuLidcbiAgICApIDogaW52YXJpYW50KHRoaXMuaXNJblRyYW5zYWN0aW9uKCkpKTtcbiAgICB2YXIgdHJhbnNhY3Rpb25XcmFwcGVycyA9IHRoaXMudHJhbnNhY3Rpb25XcmFwcGVycztcbiAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IHRyYW5zYWN0aW9uV3JhcHBlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3cmFwcGVyID0gdHJhbnNhY3Rpb25XcmFwcGVyc1tpXTtcbiAgICAgIHZhciBpbml0RGF0YSA9IHRoaXMud3JhcHBlckluaXREYXRhW2ldO1xuICAgICAgdmFyIGVycm9yVGhyb3duO1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gQ2F0Y2hpbmcgZXJyb3JzIG1ha2VzIGRlYnVnZ2luZyBtb3JlIGRpZmZpY3VsdCwgc28gd2Ugc3RhcnQgd2l0aFxuICAgICAgICAvLyBlcnJvclRocm93biBzZXQgdG8gdHJ1ZSBiZWZvcmUgc2V0dGluZyBpdCB0byBmYWxzZSBhZnRlciBjYWxsaW5nXG4gICAgICAgIC8vIGNsb3NlIC0tIGlmIGl0J3Mgc3RpbGwgc2V0IHRvIHRydWUgaW4gdGhlIGZpbmFsbHkgYmxvY2ssIGl0IG1lYW5zXG4gICAgICAgIC8vIHdyYXBwZXIuY2xvc2UgdGhyZXcuXG4gICAgICAgIGVycm9yVGhyb3duID0gdHJ1ZTtcbiAgICAgICAgaWYgKGluaXREYXRhICE9PSBUcmFuc2FjdGlvbi5PQlNFUlZFRF9FUlJPUikge1xuICAgICAgICAgIHdyYXBwZXIuY2xvc2UgJiYgd3JhcHBlci5jbG9zZS5jYWxsKHRoaXMsIGluaXREYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlcnJvclRocm93biA9IGZhbHNlO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGVycm9yVGhyb3duKSB7XG4gICAgICAgICAgLy8gVGhlIGNsb3NlciBmb3Igd3JhcHBlciBpIHRocmV3IGFuIGVycm9yOyBjbG9zZSB0aGUgcmVtYWluaW5nXG4gICAgICAgICAgLy8gd3JhcHBlcnMgYnV0IHNpbGVuY2UgYW55IGV4Y2VwdGlvbnMgZnJvbSB0aGVtIHRvIGVuc3VyZSB0aGF0IHRoZVxuICAgICAgICAgIC8vIGZpcnN0IGVycm9yIGlzIHRoZSBvbmUgdG8gYnViYmxlIHVwLlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlQWxsKGkgKyAxKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMud3JhcHBlckluaXREYXRhLmxlbmd0aCA9IDA7XG4gIH1cbn07XG5cbnZhciBUcmFuc2FjdGlvbiA9IHtcblxuICBNaXhpbjogTWl4aW4sXG5cbiAgLyoqXG4gICAqIFRva2VuIHRvIGxvb2sgZm9yIHRvIGRldGVybWluZSBpZiBhbiBlcnJvciBvY2N1cmVkLlxuICAgKi9cbiAgT0JTRVJWRURfRVJST1I6IHt9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNhY3Rpb247XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBWaWV3cG9ydE1ldHJpY3NcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGdldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uID0gcmVxdWlyZShcIi4vZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb25cIik7XG5cbnZhciBWaWV3cG9ydE1ldHJpY3MgPSB7XG5cbiAgY3VycmVudFNjcm9sbExlZnQ6IDAsXG5cbiAgY3VycmVudFNjcm9sbFRvcDogMCxcblxuICByZWZyZXNoU2Nyb2xsVmFsdWVzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2Nyb2xsUG9zaXRpb24gPSBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbih3aW5kb3cpO1xuICAgIFZpZXdwb3J0TWV0cmljcy5jdXJyZW50U2Nyb2xsTGVmdCA9IHNjcm9sbFBvc2l0aW9uLng7XG4gICAgVmlld3BvcnRNZXRyaWNzLmN1cnJlbnRTY3JvbGxUb3AgPSBzY3JvbGxQb3NpdGlvbi55O1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVmlld3BvcnRNZXRyaWNzO1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBhY2N1bXVsYXRlXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbi8qKlxuICogQWNjdW11bGF0ZXMgaXRlbXMgdGhhdCBtdXN0IG5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZC5cbiAqXG4gKiBUaGlzIGlzIHVzZWQgdG8gY29uc2VydmUgbWVtb3J5IGJ5IGF2b2lkaW5nIGFycmF5IGFsbG9jYXRpb25zLlxuICpcbiAqIEByZXR1cm4geyp8YXJyYXk8Kj59IEFuIGFjY3VtdWxhdGlvbiBvZiBpdGVtcy5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZShjdXJyZW50LCBuZXh0KSB7XG4gIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgbmV4dCAhPSBudWxsLFxuICAgICdhY2N1bXVsYXRlKC4uLik6IEFjY3VtdWxhdGVkIGl0ZW1zIG11c3QgYmUgbm90IGJlIG51bGwgb3IgdW5kZWZpbmVkLidcbiAgKSA6IGludmFyaWFudChuZXh0ICE9IG51bGwpKTtcbiAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBuZXh0O1xuICB9IGVsc2Uge1xuICAgIC8vIEJvdGggYXJlIG5vdCBlbXB0eS4gV2FybmluZzogTmV2ZXIgY2FsbCB4LmNvbmNhdCh5KSB3aGVuIHlvdSBhcmUgbm90XG4gICAgLy8gY2VydGFpbiB0aGF0IHggaXMgYW4gQXJyYXkgKHggY291bGQgYmUgYSBzdHJpbmcgd2l0aCBjb25jYXQgbWV0aG9kKS5cbiAgICB2YXIgY3VycmVudElzQXJyYXkgPSBBcnJheS5pc0FycmF5KGN1cnJlbnQpO1xuICAgIHZhciBuZXh0SXNBcnJheSA9IEFycmF5LmlzQXJyYXkobmV4dCk7XG4gICAgaWYgKGN1cnJlbnRJc0FycmF5KSB7XG4gICAgICByZXR1cm4gY3VycmVudC5jb25jYXQobmV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChuZXh0SXNBcnJheSkge1xuICAgICAgICByZXR1cm4gW2N1cnJlbnRdLmNvbmNhdChuZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbY3VycmVudCwgbmV4dF07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYWNjdW11bGF0ZTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGFkbGVyMzJcbiAqL1xuXG4vKiBqc2xpbnQgYml0d2lzZTp0cnVlICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgTU9EID0gNjU1MjE7XG5cbi8vIFRoaXMgaXMgYSBjbGVhbi1yb29tIGltcGxlbWVudGF0aW9uIG9mIGFkbGVyMzIgZGVzaWduZWQgZm9yIGRldGVjdGluZ1xuLy8gaWYgbWFya3VwIGlzIG5vdCB3aGF0IHdlIGV4cGVjdCBpdCB0byBiZS4gSXQgZG9lcyBub3QgbmVlZCB0byBiZVxuLy8gY3J5cHRvZ3JhcGhpY2FsbHkgc3Ryb25nLCBvbmx5IHJlYXNvbmFibGUgZ29vZCBhdCBkZXRlY3RpbmcgaWYgbWFya3VwXG4vLyBnZW5lcmF0ZWQgb24gdGhlIHNlcnZlciBpcyBkaWZmZXJlbnQgdGhhbiB0aGF0IG9uIHRoZSBjbGllbnQuXG5mdW5jdGlvbiBhZGxlcjMyKGRhdGEpIHtcbiAgdmFyIGEgPSAxO1xuICB2YXIgYiA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgIGEgPSAoYSArIGRhdGEuY2hhckNvZGVBdChpKSkgJSBNT0Q7XG4gICAgYiA9IChiICsgYSkgJSBNT0Q7XG4gIH1cbiAgcmV0dXJuIGEgfCAoYiA8PCAxNik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYWRsZXIzMjtcbiIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICogQHByb3ZpZGVzTW9kdWxlIGNsb25lV2l0aFByb3BzXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBSZWFjdFByb3BUcmFuc2ZlcmVyID0gcmVxdWlyZShcIi4vUmVhY3RQcm9wVHJhbnNmZXJlclwiKTtcblxudmFyIGtleU9mID0gcmVxdWlyZShcIi4va2V5T2ZcIik7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoXCIuL3dhcm5pbmdcIik7XG5cbnZhciBDSElMRFJFTl9QUk9QID0ga2V5T2Yoe2NoaWxkcmVuOiBudWxsfSk7XG5cbi8qKlxuICogU29tZXRpbWVzIHlvdSB3YW50IHRvIGNoYW5nZSB0aGUgcHJvcHMgb2YgYSBjaGlsZCBwYXNzZWQgdG8geW91LiBVc3VhbGx5XG4gKiB0aGlzIGlzIHRvIGFkZCBhIENTUyBjbGFzcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY2hpbGQgY2hpbGQgY29tcG9uZW50IHlvdSdkIGxpa2UgdG8gY2xvbmVcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wcyBwcm9wcyB5b3UnZCBsaWtlIHRvIG1vZGlmeS4gVGhleSB3aWxsIGJlIG1lcmdlZFxuICogYXMgaWYgeW91IHVzZWQgYHRyYW5zZmVyUHJvcHNUbygpYC5cbiAqIEByZXR1cm4ge29iamVjdH0gYSBjbG9uZSBvZiBjaGlsZCB3aXRoIHByb3BzIG1lcmdlZCBpbi5cbiAqL1xuZnVuY3Rpb24gY2xvbmVXaXRoUHJvcHMoY2hpbGQsIHByb3BzKSB7XG4gIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyhcbiAgICAgICFjaGlsZC5wcm9wcy5yZWYsXG4gICAgICAnWW91IGFyZSBjYWxsaW5nIGNsb25lV2l0aFByb3BzKCkgb24gYSBjaGlsZCB3aXRoIGEgcmVmLiBUaGlzIGlzICcgK1xuICAgICAgJ2Rhbmdlcm91cyBiZWNhdXNlIHlvdVxcJ3JlIGNyZWF0aW5nIGEgbmV3IGNoaWxkIHdoaWNoIHdpbGwgbm90IGJlICcgK1xuICAgICAgJ2FkZGVkIGFzIGEgcmVmIHRvIGl0cyBwYXJlbnQuJ1xuICAgICkgOiBudWxsKTtcbiAgfVxuXG4gIHZhciBuZXdQcm9wcyA9IFJlYWN0UHJvcFRyYW5zZmVyZXIubWVyZ2VQcm9wcyhwcm9wcywgY2hpbGQucHJvcHMpO1xuXG4gIC8vIFVzZSBgY2hpbGQucHJvcHMuY2hpbGRyZW5gIGlmIGl0IGlzIHByb3ZpZGVkLlxuICBpZiAoIW5ld1Byb3BzLmhhc093blByb3BlcnR5KENISUxEUkVOX1BST1ApICYmXG4gICAgICBjaGlsZC5wcm9wcy5oYXNPd25Qcm9wZXJ0eShDSElMRFJFTl9QUk9QKSkge1xuICAgIG5ld1Byb3BzLmNoaWxkcmVuID0gY2hpbGQucHJvcHMuY2hpbGRyZW47XG4gIH1cblxuICAvLyBUaGUgY3VycmVudCBBUEkgZG9lc24ndCByZXRhaW4gX293bmVyIGFuZCBfY29udGV4dCwgd2hpY2ggaXMgd2h5IHRoaXNcbiAgLy8gZG9lc24ndCB1c2UgUmVhY3REZXNjcmlwdG9yLmNsb25lQW5kUmVwbGFjZVByb3BzLlxuICByZXR1cm4gY2hpbGQuY29uc3RydWN0b3IobmV3UHJvcHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lV2l0aFByb3BzO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgY29udGFpbnNOb2RlXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBpc1RleHROb2RlID0gcmVxdWlyZShcIi4vaXNUZXh0Tm9kZVwiKTtcblxuLypqc2xpbnQgYml0d2lzZTp0cnVlICovXG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgZ2l2ZW4gRE9NIG5vZGUgY29udGFpbnMgb3IgaXMgYW5vdGhlciBET00gbm9kZS5cbiAqXG4gKiBAcGFyYW0gez9ET01Ob2RlfSBvdXRlck5vZGUgT3V0ZXIgRE9NIG5vZGUuXG4gKiBAcGFyYW0gez9ET01Ob2RlfSBpbm5lck5vZGUgSW5uZXIgRE9NIG5vZGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvdXRlck5vZGVgIGNvbnRhaW5zIG9yIGlzIGBpbm5lck5vZGVgLlxuICovXG5mdW5jdGlvbiBjb250YWluc05vZGUob3V0ZXJOb2RlLCBpbm5lck5vZGUpIHtcbiAgaWYgKCFvdXRlck5vZGUgfHwgIWlubmVyTm9kZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChvdXRlck5vZGUgPT09IGlubmVyTm9kZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGlzVGV4dE5vZGUob3V0ZXJOb2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChpc1RleHROb2RlKGlubmVyTm9kZSkpIHtcbiAgICByZXR1cm4gY29udGFpbnNOb2RlKG91dGVyTm9kZSwgaW5uZXJOb2RlLnBhcmVudE5vZGUpO1xuICB9IGVsc2UgaWYgKG91dGVyTm9kZS5jb250YWlucykge1xuICAgIHJldHVybiBvdXRlck5vZGUuY29udGFpbnMoaW5uZXJOb2RlKTtcbiAgfSBlbHNlIGlmIChvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24pIHtcbiAgICByZXR1cm4gISEob3V0ZXJOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGlubmVyTm9kZSkgJiAxNik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGFpbnNOb2RlO1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBjb3B5UHJvcGVydGllc1xuICovXG5cbi8qKlxuICogQ29weSBwcm9wZXJ0aWVzIGZyb20gb25lIG9yIG1vcmUgb2JqZWN0cyAodXAgdG8gNSkgaW50byB0aGUgZmlyc3Qgb2JqZWN0LlxuICogVGhpcyBpcyBhIHNoYWxsb3cgY29weS4gSXQgbXV0YXRlcyB0aGUgZmlyc3Qgb2JqZWN0IGFuZCBhbHNvIHJldHVybnMgaXQuXG4gKlxuICogTk9URTogYGFyZ3VtZW50c2AgaGFzIGEgdmVyeSBzaWduaWZpY2FudCBwZXJmb3JtYW5jZSBwZW5hbHR5LCB3aGljaCBpcyB3aHlcbiAqIHdlIGRvbid0IHN1cHBvcnQgdW5saW1pdGVkIGFyZ3VtZW50cy5cbiAqL1xuZnVuY3Rpb24gY29weVByb3BlcnRpZXMob2JqLCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIG9iaiA9IG9iaiB8fCB7fTtcblxuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgaWYgKGYpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVG9vIG1hbnkgYXJndW1lbnRzIHBhc3NlZCB0byBjb3B5UHJvcGVydGllcycpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGVdO1xuICB2YXIgaWkgPSAwLCB2O1xuICB3aGlsZSAoYXJnc1tpaV0pIHtcbiAgICB2ID0gYXJnc1tpaSsrXTtcbiAgICBmb3IgKHZhciBrIGluIHYpIHtcbiAgICAgIG9ialtrXSA9IHZba107XG4gICAgfVxuXG4gICAgLy8gSUUgaWdub3JlcyB0b1N0cmluZyBpbiBvYmplY3QgaXRlcmF0aW9uLi4gU2VlOlxuICAgIC8vIHdlYnJlZmxlY3Rpb24uYmxvZ3Nwb3QuY29tLzIwMDcvMDcvcXVpY2stZml4LWludGVybmV0LWV4cGxvcmVyLWFuZC5odG1sXG4gICAgaWYgKHYuaGFzT3duUHJvcGVydHkgJiYgdi5oYXNPd25Qcm9wZXJ0eSgndG9TdHJpbmcnKSAmJlxuICAgICAgICAodHlwZW9mIHYudG9TdHJpbmcgIT0gJ3VuZGVmaW5lZCcpICYmIChvYmoudG9TdHJpbmcgIT09IHYudG9TdHJpbmcpKSB7XG4gICAgICBvYmoudG9TdHJpbmcgPSB2LnRvU3RyaW5nO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weVByb3BlcnRpZXM7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBjcmVhdGVBcnJheUZyb21cbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIHRvQXJyYXkgPSByZXF1aXJlKFwiLi90b0FycmF5XCIpO1xuXG4vKipcbiAqIFBlcmZvcm0gYSBoZXVyaXN0aWMgdGVzdCB0byBkZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIFwiYXJyYXktbGlrZVwiLlxuICpcbiAqICAgQSBtb25rIGFza2VkIEpvc2h1LCBhIFplbiBtYXN0ZXIsIFwiSGFzIGEgZG9nIEJ1ZGRoYSBuYXR1cmU/XCJcbiAqICAgSm9zaHUgcmVwbGllZDogXCJNdS5cIlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gZGV0ZXJtaW5lcyBpZiBpdHMgYXJndW1lbnQgaGFzIFwiYXJyYXkgbmF0dXJlXCI6IGl0IHJldHVybnNcbiAqIHRydWUgaWYgdGhlIGFyZ3VtZW50IGlzIGFuIGFjdHVhbCBhcnJheSwgYW4gYGFyZ3VtZW50cycgb2JqZWN0LCBvciBhblxuICogSFRNTENvbGxlY3Rpb24gKGUuZy4gbm9kZS5jaGlsZE5vZGVzIG9yIG5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoKSkuXG4gKlxuICogSXQgd2lsbCByZXR1cm4gZmFsc2UgZm9yIG90aGVyIGFycmF5LWxpa2Ugb2JqZWN0cyBsaWtlIEZpbGVsaXN0LlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBoYXNBcnJheU5hdHVyZShvYmopIHtcbiAgcmV0dXJuIChcbiAgICAvLyBub3QgbnVsbC9mYWxzZVxuICAgICEhb2JqICYmXG4gICAgLy8gYXJyYXlzIGFyZSBvYmplY3RzLCBOb2RlTGlzdHMgYXJlIGZ1bmN0aW9ucyBpbiBTYWZhcmlcbiAgICAodHlwZW9mIG9iaiA9PSAnb2JqZWN0JyB8fCB0eXBlb2Ygb2JqID09ICdmdW5jdGlvbicpICYmXG4gICAgLy8gcXVhY2tzIGxpa2UgYW4gYXJyYXlcbiAgICAoJ2xlbmd0aCcgaW4gb2JqKSAmJlxuICAgIC8vIG5vdCB3aW5kb3dcbiAgICAhKCdzZXRJbnRlcnZhbCcgaW4gb2JqKSAmJlxuICAgIC8vIG5vIERPTSBub2RlIHNob3VsZCBiZSBjb25zaWRlcmVkIGFuIGFycmF5LWxpa2VcbiAgICAvLyBhICdzZWxlY3QnIGVsZW1lbnQgaGFzICdsZW5ndGgnIGFuZCAnaXRlbScgcHJvcGVydGllcyBvbiBJRThcbiAgICAodHlwZW9mIG9iai5ub2RlVHlwZSAhPSAnbnVtYmVyJykgJiZcbiAgICAoXG4gICAgICAvLyBhIHJlYWwgYXJyYXlcbiAgICAgICgvLyBIVE1MQ29sbGVjdGlvbi9Ob2RlTGlzdFxuICAgICAgKEFycmF5LmlzQXJyYXkob2JqKSB8fFxuICAgICAgLy8gYXJndW1lbnRzXG4gICAgICAoJ2NhbGxlZScgaW4gb2JqKSB8fCAnaXRlbScgaW4gb2JqKSlcbiAgICApXG4gICk7XG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgdGhlIGFyZ3VtZW50IGlzIGFuIGFycmF5IGJ5IHdyYXBwaW5nIGl0IGluIGFuIGFycmF5IGlmIGl0IGlzIG5vdC5cbiAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoZSBhcmd1bWVudCBpZiBpdCBpcyBhbHJlYWR5IGFuIGFycmF5LlxuICpcbiAqIFRoaXMgaXMgbW9zdGx5IHVzZWZ1bCBpZGlvbWF0aWNhbGx5OlxuICpcbiAqICAgdmFyIGNyZWF0ZUFycmF5RnJvbSA9IHJlcXVpcmUoJ2NyZWF0ZUFycmF5RnJvbScpO1xuICpcbiAqICAgZnVuY3Rpb24gdGFrZXNPbmVPck1vcmVUaGluZ3ModGhpbmdzKSB7XG4gKiAgICAgdGhpbmdzID0gY3JlYXRlQXJyYXlGcm9tKHRoaW5ncyk7XG4gKiAgICAgLi4uXG4gKiAgIH1cbiAqXG4gKiBUaGlzIGFsbG93cyB5b3UgdG8gdHJlYXQgYHRoaW5ncycgYXMgYW4gYXJyYXksIGJ1dCBhY2NlcHQgc2NhbGFycyBpbiB0aGUgQVBJLlxuICpcbiAqIElmIHlvdSBuZWVkIHRvIGNvbnZlcnQgYW4gYXJyYXktbGlrZSBvYmplY3QsIGxpa2UgYGFyZ3VtZW50c2AsIGludG8gYW4gYXJyYXlcbiAqIHVzZSB0b0FycmF5IGluc3RlYWQuXG4gKlxuICogQHBhcmFtIHsqfSBvYmpcbiAqIEByZXR1cm4ge2FycmF5fVxuICovXG5mdW5jdGlvbiBjcmVhdGVBcnJheUZyb20ob2JqKSB7XG4gIGlmICghaGFzQXJyYXlOYXR1cmUob2JqKSkge1xuICAgIHJldHVybiBbb2JqXTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICByZXR1cm4gb2JqLnNsaWNlKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRvQXJyYXkob2JqKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUFycmF5RnJvbTtcbiIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgY3JlYXRlRnVsbFBhZ2VDb21wb25lbnRcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIERlZmVhdCBjaXJjdWxhciByZWZlcmVuY2VzIGJ5IHJlcXVpcmluZyB0aGlzIGRpcmVjdGx5LlxudmFyIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50ID0gcmVxdWlyZShcIi4vUmVhY3RDb21wb3NpdGVDb21wb25lbnRcIik7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbi8qKlxuICogQ3JlYXRlIGEgY29tcG9uZW50IHRoYXQgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gd2hlbiB1bm1vdW50ZWQuXG4gKlxuICogQ29tcG9uZW50cyBsaWtlIDxodG1sPiA8aGVhZD4gYW5kIDxib2R5PiBjYW4ndCBiZSByZW1vdmVkIG9yIGFkZGVkXG4gKiBlYXNpbHkgaW4gYSBjcm9zcy1icm93c2VyIHdheSwgaG93ZXZlciBpdCdzIHZhbHVhYmxlIHRvIGJlIGFibGUgdG9cbiAqIHRha2UgYWR2YW50YWdlIG9mIFJlYWN0J3MgcmVjb25jaWxpYXRpb24gZm9yIHN0eWxpbmcgYW5kIDx0aXRsZT5cbiAqIG1hbmFnZW1lbnQuIFNvIHdlIGp1c3QgZG9jdW1lbnQgaXQgYW5kIHRocm93IGluIGRhbmdlcm91cyBjYXNlcy5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb21wb25lbnRDbGFzcyBjb252ZW5pZW5jZSBjb25zdHJ1Y3RvciB0byB3cmFwXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gY29udmVuaWVuY2UgY29uc3RydWN0b3Igb2YgbmV3IGNvbXBvbmVudFxuICovXG5mdW5jdGlvbiBjcmVhdGVGdWxsUGFnZUNvbXBvbmVudChjb21wb25lbnRDbGFzcykge1xuICB2YXIgRnVsbFBhZ2VDb21wb25lbnQgPSBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5jcmVhdGVDbGFzcyh7XG4gICAgZGlzcGxheU5hbWU6ICdSZWFjdEZ1bGxQYWdlQ29tcG9uZW50JyArIChcbiAgICAgIGNvbXBvbmVudENsYXNzLnR5cGUuZGlzcGxheU5hbWUgfHwgJydcbiAgICApLFxuXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICAgZmFsc2UsXG4gICAgICAgICclcyB0cmllZCB0byB1bm1vdW50LiBCZWNhdXNlIG9mIGNyb3NzLWJyb3dzZXIgcXVpcmtzIGl0IGlzICcgK1xuICAgICAgICAnaW1wb3NzaWJsZSB0byB1bm1vdW50IHNvbWUgdG9wLWxldmVsIGNvbXBvbmVudHMgKGVnIDxodG1sPiwgPGhlYWQ+LCAnICtcbiAgICAgICAgJ2FuZCA8Ym9keT4pIHJlbGlhYmx5IGFuZCBlZmZpY2llbnRseS4gVG8gZml4IHRoaXMsIGhhdmUgYSBzaW5nbGUgJyArXG4gICAgICAgICd0b3AtbGV2ZWwgY29tcG9uZW50IHRoYXQgbmV2ZXIgdW5tb3VudHMgcmVuZGVyIHRoZXNlIGVsZW1lbnRzLicsXG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IuZGlzcGxheU5hbWVcbiAgICAgICkgOiBpbnZhcmlhbnQoZmFsc2UpKTtcbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRyYW5zZmVyUHJvcHNUbyhjb21wb25lbnRDbGFzcyhudWxsLCB0aGlzLnByb3BzLmNoaWxkcmVuKSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gRnVsbFBhZ2VDb21wb25lbnQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlRnVsbFBhZ2VDb21wb25lbnQ7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgY3JlYXRlTm9kZXNGcm9tTWFya3VwXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qanNsaW50IGV2aWw6IHRydWUsIHN1YjogdHJ1ZSAqL1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKFwiLi9FeGVjdXRpb25FbnZpcm9ubWVudFwiKTtcblxudmFyIGNyZWF0ZUFycmF5RnJvbSA9IHJlcXVpcmUoXCIuL2NyZWF0ZUFycmF5RnJvbVwiKTtcbnZhciBnZXRNYXJrdXBXcmFwID0gcmVxdWlyZShcIi4vZ2V0TWFya3VwV3JhcFwiKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbi8qKlxuICogRHVtbXkgY29udGFpbmVyIHVzZWQgdG8gcmVuZGVyIGFsbCBtYXJrdXAuXG4gKi9cbnZhciBkdW1teU5vZGUgPVxuICBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSA6IG51bGw7XG5cbi8qKlxuICogUGF0dGVybiB1c2VkIGJ5IGBnZXROb2RlTmFtZWAuXG4gKi9cbnZhciBub2RlTmFtZVBhdHRlcm4gPSAvXlxccyo8KFxcdyspLztcblxuLyoqXG4gKiBFeHRyYWN0cyB0aGUgYG5vZGVOYW1lYCBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiBhIHN0cmluZyBvZiBtYXJrdXAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBTdHJpbmcgb2YgbWFya3VwLlxuICogQHJldHVybiB7P3N0cmluZ30gTm9kZSBuYW1lIG9mIHRoZSBzdXBwbGllZCBtYXJrdXAuXG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVOYW1lKG1hcmt1cCkge1xuICB2YXIgbm9kZU5hbWVNYXRjaCA9IG1hcmt1cC5tYXRjaChub2RlTmFtZVBhdHRlcm4pO1xuICByZXR1cm4gbm9kZU5hbWVNYXRjaCAmJiBub2RlTmFtZU1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBub2RlcyByZW5kZXJlZCBmcm9tIHRoZSBzdXBwbGllZCBtYXJrdXAuIFRoZVxuICogb3B0aW9uYWxseSBzdXBwbGllZCBgaGFuZGxlU2NyaXB0YCBmdW5jdGlvbiB3aWxsIGJlIGludm9rZWQgb25jZSBmb3IgZWFjaFxuICogPHNjcmlwdD4gZWxlbWVudCB0aGF0IGlzIHJlbmRlcmVkLiBJZiBubyBgaGFuZGxlU2NyaXB0YCBmdW5jdGlvbiBpcyBzdXBwbGllZCxcbiAqIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gaWYgYW55IDxzY3JpcHQ+IGVsZW1lbnRzIGFyZSByZW5kZXJlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIEEgc3RyaW5nIG9mIHZhbGlkIEhUTUwgbWFya3VwLlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGhhbmRsZVNjcmlwdCBJbnZva2VkIG9uY2UgZm9yIGVhY2ggcmVuZGVyZWQgPHNjcmlwdD4uXG4gKiBAcmV0dXJuIHthcnJheTxET01FbGVtZW50fERPTVRleHROb2RlPn0gQW4gYXJyYXkgb2YgcmVuZGVyZWQgbm9kZXMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU5vZGVzRnJvbU1hcmt1cChtYXJrdXAsIGhhbmRsZVNjcmlwdCkge1xuICB2YXIgbm9kZSA9IGR1bW15Tm9kZTtcbiAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudCghIWR1bW15Tm9kZSwgJ2NyZWF0ZU5vZGVzRnJvbU1hcmt1cCBkdW1teSBub3QgaW5pdGlhbGl6ZWQnKSA6IGludmFyaWFudCghIWR1bW15Tm9kZSkpO1xuICB2YXIgbm9kZU5hbWUgPSBnZXROb2RlTmFtZShtYXJrdXApO1xuXG4gIHZhciB3cmFwID0gbm9kZU5hbWUgJiYgZ2V0TWFya3VwV3JhcChub2RlTmFtZSk7XG4gIGlmICh3cmFwKSB7XG4gICAgbm9kZS5pbm5lckhUTUwgPSB3cmFwWzFdICsgbWFya3VwICsgd3JhcFsyXTtcblxuICAgIHZhciB3cmFwRGVwdGggPSB3cmFwWzBdO1xuICAgIHdoaWxlICh3cmFwRGVwdGgtLSkge1xuICAgICAgbm9kZSA9IG5vZGUubGFzdENoaWxkO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBub2RlLmlubmVySFRNTCA9IG1hcmt1cDtcbiAgfVxuXG4gIHZhciBzY3JpcHRzID0gbm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0Jyk7XG4gIGlmIChzY3JpcHRzLmxlbmd0aCkge1xuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICBoYW5kbGVTY3JpcHQsXG4gICAgICAnY3JlYXRlTm9kZXNGcm9tTWFya3VwKC4uLik6IFVuZXhwZWN0ZWQgPHNjcmlwdD4gZWxlbWVudCByZW5kZXJlZC4nXG4gICAgKSA6IGludmFyaWFudChoYW5kbGVTY3JpcHQpKTtcbiAgICBjcmVhdGVBcnJheUZyb20oc2NyaXB0cykuZm9yRWFjaChoYW5kbGVTY3JpcHQpO1xuICB9XG5cbiAgdmFyIG5vZGVzID0gY3JlYXRlQXJyYXlGcm9tKG5vZGUuY2hpbGROb2Rlcyk7XG4gIHdoaWxlIChub2RlLmxhc3RDaGlsZCkge1xuICAgIG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5sYXN0Q2hpbGQpO1xuICB9XG4gIHJldHVybiBub2Rlcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVOb2Rlc0Zyb21NYXJrdXA7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBjeFxuICovXG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIG1hcmsgc3RyaW5nIGxpdGVyYWxzIHJlcHJlc2VudGluZyBDU1MgY2xhc3MgbmFtZXNcbiAqIHNvIHRoYXQgdGhleSBjYW4gYmUgdHJhbnNmb3JtZWQgc3RhdGljYWxseS4gVGhpcyBhbGxvd3MgZm9yIG1vZHVsYXJpemF0aW9uXG4gKiBhbmQgbWluaWZpY2F0aW9uIG9mIENTUyBjbGFzcyBuYW1lcy5cbiAqXG4gKiBJbiBzdGF0aWNfdXBzdHJlYW0sIHRoaXMgZnVuY3Rpb24gaXMgYWN0dWFsbHkgaW1wbGVtZW50ZWQsIGJ1dCBpdCBzaG91bGRcbiAqIGV2ZW50dWFsbHkgYmUgcmVwbGFjZWQgd2l0aCBzb21ldGhpbmcgbW9yZSBkZXNjcmlwdGl2ZSwgYW5kIHRoZSB0cmFuc2Zvcm1cbiAqIHRoYXQgaXMgdXNlZCBpbiB0aGUgbWFpbiBzdGFjayBzaG91bGQgYmUgcG9ydGVkIGZvciB1c2UgZWxzZXdoZXJlLlxuICpcbiAqIEBwYXJhbSBzdHJpbmd8b2JqZWN0IGNsYXNzTmFtZSB0byBtb2R1bGFyaXplLCBvciBhbiBvYmplY3Qgb2Yga2V5L3ZhbHVlcy5cbiAqICAgICAgICAgICAgICAgICAgICAgIEluIHRoZSBvYmplY3QgY2FzZSwgdGhlIHZhbHVlcyBhcmUgY29uZGl0aW9ucyB0aGF0XG4gKiAgICAgICAgICAgICAgICAgICAgICBkZXRlcm1pbmUgaWYgdGhlIGNsYXNzTmFtZSBrZXlzIHNob3VsZCBiZSBpbmNsdWRlZC5cbiAqIEBwYXJhbSBbc3RyaW5nIC4uLl0gIFZhcmlhYmxlIGxpc3Qgb2YgY2xhc3NOYW1lcyBpbiB0aGUgc3RyaW5nIGNhc2UuXG4gKiBAcmV0dXJuIHN0cmluZyAgICAgICBSZW5kZXJhYmxlIHNwYWNlLXNlcGFyYXRlZCBDU1MgY2xhc3NOYW1lLlxuICovXG5mdW5jdGlvbiBjeChjbGFzc05hbWVzKSB7XG4gIGlmICh0eXBlb2YgY2xhc3NOYW1lcyA9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhjbGFzc05hbWVzKS5maWx0ZXIoZnVuY3Rpb24oY2xhc3NOYW1lKSB7XG4gICAgICByZXR1cm4gY2xhc3NOYW1lc1tjbGFzc05hbWVdO1xuICAgIH0pLmpvaW4oJyAnKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmpvaW4uY2FsbChhcmd1bWVudHMsICcgJyk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjeDtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBkYW5nZXJvdXNTdHlsZVZhbHVlXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgQ1NTUHJvcGVydHkgPSByZXF1aXJlKFwiLi9DU1NQcm9wZXJ0eVwiKTtcblxudmFyIGlzVW5pdGxlc3NOdW1iZXIgPSBDU1NQcm9wZXJ0eS5pc1VuaXRsZXNzTnVtYmVyO1xuXG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSBpbnRvIHRoZSBwcm9wZXIgY3NzIHdyaXRhYmxlIHZhbHVlLiBUaGUgc3R5bGUgbmFtZSBgbmFtZWBcbiAqIHNob3VsZCBiZSBsb2dpY2FsIChubyBoeXBoZW5zKSwgYXMgc3BlY2lmaWVkXG4gKiBpbiBgQ1NTUHJvcGVydHkuaXNVbml0bGVzc051bWJlcmAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQ1NTIHByb3BlcnR5IG5hbWUgc3VjaCBhcyBgdG9wTWFyZ2luYC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQ1NTIHByb3BlcnR5IHZhbHVlIHN1Y2ggYXMgYDEwcHhgLlxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIHN0eWxlIHZhbHVlIHdpdGggZGltZW5zaW9ucyBhcHBsaWVkLlxuICovXG5mdW5jdGlvbiBkYW5nZXJvdXNTdHlsZVZhbHVlKG5hbWUsIHZhbHVlKSB7XG4gIC8vIE5vdGUgdGhhdCB3ZSd2ZSByZW1vdmVkIGVzY2FwZVRleHRGb3JCcm93c2VyKCkgY2FsbHMgaGVyZSBzaW5jZSB0aGVcbiAgLy8gd2hvbGUgc3RyaW5nIHdpbGwgYmUgZXNjYXBlZCB3aGVuIHRoZSBhdHRyaWJ1dGUgaXMgaW5qZWN0ZWQgaW50b1xuICAvLyB0aGUgbWFya3VwLiBJZiB5b3UgcHJvdmlkZSB1bnNhZmUgdXNlciBkYXRhIGhlcmUgdGhleSBjYW4gaW5qZWN0XG4gIC8vIGFyYml0cmFyeSBDU1Mgd2hpY2ggbWF5IGJlIHByb2JsZW1hdGljIChJIGNvdWxkbid0IHJlcHJvIHRoaXMpOlxuICAvLyBodHRwczovL3d3dy5vd2FzcC5vcmcvaW5kZXgucGhwL1hTU19GaWx0ZXJfRXZhc2lvbl9DaGVhdF9TaGVldFxuICAvLyBodHRwOi8vd3d3LnRoZXNwYW5uZXIuY28udWsvMjAwNy8xMS8yNi91bHRpbWF0ZS14c3MtY3NzLWluamVjdGlvbi9cbiAgLy8gVGhpcyBpcyBub3QgYW4gWFNTIGhvbGUgYnV0IGluc3RlYWQgYSBwb3RlbnRpYWwgQ1NTIGluamVjdGlvbiBpc3N1ZVxuICAvLyB3aGljaCBoYXMgbGVhZCB0byBhIGdyZWF0ZXIgZGlzY3Vzc2lvbiBhYm91dCBob3cgd2UncmUgZ29pbmcgdG9cbiAgLy8gdHJ1c3QgVVJMcyBtb3ZpbmcgZm9yd2FyZC4gU2VlICMyMTE1OTAxXG5cbiAgdmFyIGlzRW1wdHkgPSB2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8IHZhbHVlID09PSAnJztcbiAgaWYgKGlzRW1wdHkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB2YXIgaXNOb25OdW1lcmljID0gaXNOYU4odmFsdWUpO1xuICBpZiAoaXNOb25OdW1lcmljIHx8IHZhbHVlID09PSAwIHx8XG4gICAgICBpc1VuaXRsZXNzTnVtYmVyLmhhc093blByb3BlcnR5KG5hbWUpICYmIGlzVW5pdGxlc3NOdW1iZXJbbmFtZV0pIHtcbiAgICByZXR1cm4gJycgKyB2YWx1ZTsgLy8gY2FzdCB0byBzdHJpbmdcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS50cmltKCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlICsgJ3B4Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkYW5nZXJvdXNTdHlsZVZhbHVlO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGVtcHR5RnVuY3Rpb25cbiAqL1xuXG52YXIgY29weVByb3BlcnRpZXMgPSByZXF1aXJlKFwiLi9jb3B5UHJvcGVydGllc1wiKTtcblxuZnVuY3Rpb24gbWFrZUVtcHR5RnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYXJnO1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhbmQgZGlzY2FyZHMgaW5wdXRzOyBpdCBoYXMgbm8gc2lkZSBlZmZlY3RzLiBUaGlzIGlzXG4gKiBwcmltYXJpbHkgdXNlZnVsIGlkaW9tYXRpY2FsbHkgZm9yIG92ZXJyaWRhYmxlIGZ1bmN0aW9uIGVuZHBvaW50cyB3aGljaFxuICogYWx3YXlzIG5lZWQgdG8gYmUgY2FsbGFibGUsIHNpbmNlIEpTIGxhY2tzIGEgbnVsbC1jYWxsIGlkaW9tIGFsYSBDb2NvYS5cbiAqL1xuZnVuY3Rpb24gZW1wdHlGdW5jdGlvbigpIHt9XG5cbmNvcHlQcm9wZXJ0aWVzKGVtcHR5RnVuY3Rpb24sIHtcbiAgdGhhdFJldHVybnM6IG1ha2VFbXB0eUZ1bmN0aW9uLFxuICB0aGF0UmV0dXJuc0ZhbHNlOiBtYWtlRW1wdHlGdW5jdGlvbihmYWxzZSksXG4gIHRoYXRSZXR1cm5zVHJ1ZTogbWFrZUVtcHR5RnVuY3Rpb24odHJ1ZSksXG4gIHRoYXRSZXR1cm5zTnVsbDogbWFrZUVtcHR5RnVuY3Rpb24obnVsbCksXG4gIHRoYXRSZXR1cm5zVGhpczogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9LFxuICB0aGF0UmV0dXJuc0FyZ3VtZW50OiBmdW5jdGlvbihhcmcpIHsgcmV0dXJuIGFyZzsgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZW1wdHlGdW5jdGlvbjtcbiIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZW1wdHlPYmplY3RcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGVtcHR5T2JqZWN0ID0ge307XG5cbmlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgT2JqZWN0LmZyZWV6ZShlbXB0eU9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZW1wdHlPYmplY3Q7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBlc2NhcGVUZXh0Rm9yQnJvd3NlclxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIEVTQ0FQRV9MT09LVVAgPSB7XG4gIFwiJlwiOiBcIiZhbXA7XCIsXG4gIFwiPlwiOiBcIiZndDtcIixcbiAgXCI8XCI6IFwiJmx0O1wiLFxuICBcIlxcXCJcIjogXCImcXVvdDtcIixcbiAgXCInXCI6IFwiJiN4Mjc7XCJcbn07XG5cbnZhciBFU0NBUEVfUkVHRVggPSAvWyY+PFwiJ10vZztcblxuZnVuY3Rpb24gZXNjYXBlcihtYXRjaCkge1xuICByZXR1cm4gRVNDQVBFX0xPT0tVUFttYXRjaF07XG59XG5cbi8qKlxuICogRXNjYXBlcyB0ZXh0IHRvIHByZXZlbnQgc2NyaXB0aW5nIGF0dGFja3MuXG4gKlxuICogQHBhcmFtIHsqfSB0ZXh0IFRleHQgdmFsdWUgdG8gZXNjYXBlLlxuICogQHJldHVybiB7c3RyaW5nfSBBbiBlc2NhcGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlVGV4dEZvckJyb3dzZXIodGV4dCkge1xuICByZXR1cm4gKCcnICsgdGV4dCkucmVwbGFjZShFU0NBUEVfUkVHRVgsIGVzY2FwZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVzY2FwZVRleHRGb3JCcm93c2VyO1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBmbGF0dGVuQ2hpbGRyZW5cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIHRyYXZlcnNlQWxsQ2hpbGRyZW4gPSByZXF1aXJlKFwiLi90cmF2ZXJzZUFsbENoaWxkcmVuXCIpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKFwiLi93YXJuaW5nXCIpO1xuXG4vKipcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHRyYXZlcnNlQ29udGV4dCBDb250ZXh0IHBhc3NlZCB0aHJvdWdoIHRyYXZlcnNhbC5cbiAqIEBwYXJhbSB7P1JlYWN0Q29tcG9uZW50fSBjaGlsZCBSZWFjdCBjaGlsZCBjb21wb25lbnQuXG4gKiBAcGFyYW0geyFzdHJpbmd9IG5hbWUgU3RyaW5nIG5hbWUgb2Yga2V5IHBhdGggdG8gY2hpbGQuXG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW5TaW5nbGVDaGlsZEludG9Db250ZXh0KHRyYXZlcnNlQ29udGV4dCwgY2hpbGQsIG5hbWUpIHtcbiAgLy8gV2UgZm91bmQgYSBjb21wb25lbnQgaW5zdGFuY2UuXG4gIHZhciByZXN1bHQgPSB0cmF2ZXJzZUNvbnRleHQ7XG4gIHZhciBrZXlVbmlxdWUgPSAhcmVzdWx0Lmhhc093blByb3BlcnR5KG5hbWUpO1xuICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyhcbiAgICBrZXlVbmlxdWUsXG4gICAgJ2ZsYXR0ZW5DaGlsZHJlbiguLi4pOiBFbmNvdW50ZXJlZCB0d28gY2hpbGRyZW4gd2l0aCB0aGUgc2FtZSBrZXksICcgK1xuICAgICdgJXNgLiBDaGlsZCBrZXlzIG11c3QgYmUgdW5pcXVlOyB3aGVuIHR3byBjaGlsZHJlbiBzaGFyZSBhIGtleSwgb25seSAnICtcbiAgICAndGhlIGZpcnN0IGNoaWxkIHdpbGwgYmUgdXNlZC4nLFxuICAgIG5hbWVcbiAgKSA6IG51bGwpO1xuICBpZiAoa2V5VW5pcXVlICYmIGNoaWxkICE9IG51bGwpIHtcbiAgICByZXN1bHRbbmFtZV0gPSBjaGlsZDtcbiAgfVxufVxuXG4vKipcbiAqIEZsYXR0ZW5zIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC4gQW55IG51bGxcbiAqIGNoaWxkcmVuIHdpbGwgbm90IGJlIGluY2x1ZGVkIGluIHRoZSByZXN1bHRpbmcgb2JqZWN0LlxuICogQHJldHVybiB7IW9iamVjdH0gZmxhdHRlbmVkIGNoaWxkcmVuIGtleWVkIGJ5IG5hbWUuXG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW5DaGlsZHJlbihjaGlsZHJlbikge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuICB2YXIgcmVzdWx0ID0ge307XG4gIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGZsYXR0ZW5TaW5nbGVDaGlsZEludG9Db250ZXh0LCByZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZsYXR0ZW5DaGlsZHJlbjtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBmb2N1c05vZGVcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBJRTggdGhyb3dzIGlmIGFuIGlucHV0L3RleHRhcmVhIGlzIGRpc2FibGVkIGFuZCB3ZSB0cnkgdG8gZm9jdXMgaXQuXG4gKiBGb2N1cyBvbmx5IHdoZW4gbmVjZXNzYXJ5LlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZSBpbnB1dC90ZXh0YXJlYSB0byBmb2N1c1xuICovXG5mdW5jdGlvbiBmb2N1c05vZGUobm9kZSkge1xuICBpZiAoIW5vZGUuZGlzYWJsZWQpIHtcbiAgICBub2RlLmZvY3VzKCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmb2N1c05vZGU7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZm9yRWFjaEFjY3VtdWxhdGVkXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQHBhcmFtIHthcnJheX0gYW4gXCJhY2N1bXVsYXRpb25cIiBvZiBpdGVtcyB3aGljaCBpcyBlaXRoZXIgYW4gQXJyYXkgb3JcbiAqIGEgc2luZ2xlIGl0ZW0uIFVzZWZ1bCB3aGVuIHBhaXJlZCB3aXRoIHRoZSBgYWNjdW11bGF0ZWAgbW9kdWxlLiBUaGlzIGlzIGFcbiAqIHNpbXBsZSB1dGlsaXR5IHRoYXQgYWxsb3dzIHVzIHRvIHJlYXNvbiBhYm91dCBhIGNvbGxlY3Rpb24gb2YgaXRlbXMsIGJ1dFxuICogaGFuZGxpbmcgdGhlIGNhc2Ugd2hlbiB0aGVyZSBpcyBleGFjdGx5IG9uZSBpdGVtIChhbmQgd2UgZG8gbm90IG5lZWQgdG9cbiAqIGFsbG9jYXRlIGFuIGFycmF5KS5cbiAqL1xudmFyIGZvckVhY2hBY2N1bXVsYXRlZCA9IGZ1bmN0aW9uKGFyciwgY2IsIHNjb3BlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICBhcnIuZm9yRWFjaChjYiwgc2NvcGUpO1xuICB9IGVsc2UgaWYgKGFycikge1xuICAgIGNiLmNhbGwoc2NvcGUsIGFycik7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZm9yRWFjaEFjY3VtdWxhdGVkO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldEFjdGl2ZUVsZW1lbnRcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuLyoqXG4gKiBTYW1lIGFzIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgYnV0IHdyYXBzIGluIGEgdHJ5LWNhdGNoIGJsb2NrLiBJbiBJRSBpdCBpc1xuICogbm90IHNhZmUgdG8gY2FsbCBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGlmIHRoZXJlIGlzIG5vdGhpbmcgZm9jdXNlZC5cbiAqXG4gKiBUaGUgYWN0aXZlRWxlbWVudCB3aWxsIGJlIG51bGwgb25seSBpZiB0aGUgZG9jdW1lbnQgYm9keSBpcyBub3QgeWV0IGRlZmluZWQuXG4gKi9cbmZ1bmN0aW9uIGdldEFjdGl2ZUVsZW1lbnQoKSAvKj9ET01FbGVtZW50Ki8ge1xuICB0cnkge1xuICAgIHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50IHx8IGRvY3VtZW50LmJvZHk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuYm9keTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFjdGl2ZUVsZW1lbnQ7XG4iLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldEV2ZW50S2V5XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xuXG4vKipcbiAqIE5vcm1hbGl6YXRpb24gb2YgZGVwcmVjYXRlZCBIVE1MNSBga2V5YCB2YWx1ZXNcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQjS2V5X25hbWVzXG4gKi9cbnZhciBub3JtYWxpemVLZXkgPSB7XG4gICdFc2MnOiAnRXNjYXBlJyxcbiAgJ1NwYWNlYmFyJzogJyAnLFxuICAnTGVmdCc6ICdBcnJvd0xlZnQnLFxuICAnVXAnOiAnQXJyb3dVcCcsXG4gICdSaWdodCc6ICdBcnJvd1JpZ2h0JyxcbiAgJ0Rvd24nOiAnQXJyb3dEb3duJyxcbiAgJ0RlbCc6ICdEZWxldGUnLFxuICAnV2luJzogJ09TJyxcbiAgJ01lbnUnOiAnQ29udGV4dE1lbnUnLFxuICAnQXBwcyc6ICdDb250ZXh0TWVudScsXG4gICdTY3JvbGwnOiAnU2Nyb2xsTG9jaycsXG4gICdNb3pQcmludGFibGVLZXknOiAnVW5pZGVudGlmaWVkJ1xufTtcblxuLyoqXG4gKiBUcmFuc2xhdGlvbiBmcm9tIGxlZ2FjeSBgd2hpY2hgL2BrZXlDb2RlYCB0byBIVE1MNSBga2V5YFxuICogT25seSBzcGVjaWFsIGtleXMgc3VwcG9ydGVkLCBhbGwgb3RoZXJzIGRlcGVuZCBvbiBrZXlib2FyZCBsYXlvdXQgb3IgYnJvd3NlclxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudCNLZXlfbmFtZXNcbiAqL1xudmFyIHRyYW5zbGF0ZVRvS2V5ID0ge1xuICA4OiAnQmFja3NwYWNlJyxcbiAgOTogJ1RhYicsXG4gIDEyOiAnQ2xlYXInLFxuICAxMzogJ0VudGVyJyxcbiAgMTY6ICdTaGlmdCcsXG4gIDE3OiAnQ29udHJvbCcsXG4gIDE4OiAnQWx0JyxcbiAgMTk6ICdQYXVzZScsXG4gIDIwOiAnQ2Fwc0xvY2snLFxuICAyNzogJ0VzY2FwZScsXG4gIDMyOiAnICcsXG4gIDMzOiAnUGFnZVVwJyxcbiAgMzQ6ICdQYWdlRG93bicsXG4gIDM1OiAnRW5kJyxcbiAgMzY6ICdIb21lJyxcbiAgMzc6ICdBcnJvd0xlZnQnLFxuICAzODogJ0Fycm93VXAnLFxuICAzOTogJ0Fycm93UmlnaHQnLFxuICA0MDogJ0Fycm93RG93bicsXG4gIDQ1OiAnSW5zZXJ0JyxcbiAgNDY6ICdEZWxldGUnLFxuICAxMTI6ICdGMScsIDExMzogJ0YyJywgMTE0OiAnRjMnLCAxMTU6ICdGNCcsIDExNjogJ0Y1JywgMTE3OiAnRjYnLFxuICAxMTg6ICdGNycsIDExOTogJ0Y4JywgMTIwOiAnRjknLCAxMjE6ICdGMTAnLCAxMjI6ICdGMTEnLCAxMjM6ICdGMTInLFxuICAxNDQ6ICdOdW1Mb2NrJyxcbiAgMTQ1OiAnU2Nyb2xsTG9jaycsXG4gIDIyNDogJ01ldGEnXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge3N0cmluZ30gTm9ybWFsaXplZCBga2V5YCBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRLZXkobmF0aXZlRXZlbnQpIHtcbiAgaWYgKG5hdGl2ZUV2ZW50LmtleSkge1xuICAgIC8vIE5vcm1hbGl6ZSBpbmNvbnNpc3RlbnQgdmFsdWVzIHJlcG9ydGVkIGJ5IGJyb3dzZXJzIGR1ZSB0b1xuICAgIC8vIGltcGxlbWVudGF0aW9ucyBvZiBhIHdvcmtpbmcgZHJhZnQgc3BlY2lmaWNhdGlvbi5cblxuICAgIC8vIEZpcmVGb3ggaW1wbGVtZW50cyBga2V5YCBidXQgcmV0dXJucyBgTW96UHJpbnRhYmxlS2V5YCBmb3IgYWxsXG4gICAgLy8gcHJpbnRhYmxlIGNoYXJhY3RlcnMgKG5vcm1hbGl6ZWQgdG8gYFVuaWRlbnRpZmllZGApLCBpZ25vcmUgaXQuXG4gICAgdmFyIGtleSA9IG5vcm1hbGl6ZUtleVtuYXRpdmVFdmVudC5rZXldIHx8IG5hdGl2ZUV2ZW50LmtleTtcbiAgICBpZiAoa2V5ICE9PSAnVW5pZGVudGlmaWVkJykge1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gIH1cblxuICAvLyBCcm93c2VyIGRvZXMgbm90IGltcGxlbWVudCBga2V5YCwgcG9seWZpbGwgYXMgbXVjaCBvZiBpdCBhcyB3ZSBjYW4uXG4gIGlmIChuYXRpdmVFdmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgLy8gQ3JlYXRlIHRoZSBjaGFyYWN0ZXIgZnJvbSB0aGUgYGNoYXJDb2RlYCBvdXJzZWx2ZXMgYW5kIHVzZSBhcyBhbiBhbG1vc3RcbiAgICAvLyBwZXJmZWN0IHJlcGxhY2VtZW50LlxuICAgIHZhciBjaGFyQ29kZSA9ICdjaGFyQ29kZScgaW4gbmF0aXZlRXZlbnQgP1xuICAgICAgbmF0aXZlRXZlbnQuY2hhckNvZGUgOlxuICAgICAgbmF0aXZlRXZlbnQua2V5Q29kZTtcblxuICAgIC8vIFRoZSBlbnRlci1rZXkgaXMgdGVjaG5pY2FsbHkgYm90aCBwcmludGFibGUgYW5kIG5vbi1wcmludGFibGUgYW5kIGNhblxuICAgIC8vIHRodXMgYmUgY2FwdHVyZWQgYnkgYGtleXByZXNzYCwgbm8gb3RoZXIgbm9uLXByaW50YWJsZSBrZXkgc2hvdWxkLlxuICAgIHJldHVybiBjaGFyQ29kZSA9PT0gMTMgPyAnRW50ZXInIDogU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG4gIH1cbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBuYXRpdmVFdmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgLy8gV2hpbGUgdXNlciBrZXlib2FyZCBsYXlvdXQgZGV0ZXJtaW5lcyB0aGUgYWN0dWFsIG1lYW5pbmcgb2YgZWFjaFxuICAgIC8vIGBrZXlDb2RlYCB2YWx1ZSwgYWxtb3N0IGFsbCBmdW5jdGlvbiBrZXlzIGhhdmUgYSB1bml2ZXJzYWwgdmFsdWUuXG4gICAgcmV0dXJuIHRyYW5zbGF0ZVRvS2V5W25hdGl2ZUV2ZW50LmtleUNvZGVdIHx8ICdVbmlkZW50aWZpZWQnO1xuICB9XG5cbiAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChmYWxzZSwgXCJVbmV4cGVjdGVkIGtleWJvYXJkIGV2ZW50IHR5cGU6ICVzXCIsIG5hdGl2ZUV2ZW50LnR5cGUpIDogaW52YXJpYW50KGZhbHNlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RXZlbnRLZXk7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0RXZlbnRNb2RpZmllclN0YXRlXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFRyYW5zbGF0aW9uIGZyb20gbW9kaWZpZXIga2V5IHRvIHRoZSBhc3NvY2lhdGVkIHByb3BlcnR5IGluIHRoZSBldmVudC5cbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNrZXlzLU1vZGlmaWVyc1xuICovXG5cbnZhciBtb2RpZmllcktleVRvUHJvcCA9IHtcbiAgJ0FsdCc6ICdhbHRLZXknLFxuICAnQ29udHJvbCc6ICdjdHJsS2V5JyxcbiAgJ01ldGEnOiAnbWV0YUtleScsXG4gICdTaGlmdCc6ICdzaGlmdEtleSdcbn07XG5cbi8vIElFOCBkb2VzIG5vdCBpbXBsZW1lbnQgZ2V0TW9kaWZpZXJTdGF0ZSBzbyB3ZSBzaW1wbHkgbWFwIGl0IHRvIHRoZSBvbmx5XG4vLyBtb2RpZmllciBrZXlzIGV4cG9zZWQgYnkgdGhlIGV2ZW50IGl0c2VsZiwgZG9lcyBub3Qgc3VwcG9ydCBMb2NrLWtleXMuXG4vLyBDdXJyZW50bHksIGFsbCBtYWpvciBicm93c2VycyBleGNlcHQgQ2hyb21lIHNlZW1zIHRvIHN1cHBvcnQgTG9jay1rZXlzLlxuZnVuY3Rpb24gbW9kaWZpZXJTdGF0ZUdldHRlcihrZXlBcmcpIHtcbiAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgdmFyIHN5bnRoZXRpY0V2ZW50ID0gdGhpcztcbiAgdmFyIG5hdGl2ZUV2ZW50ID0gc3ludGhldGljRXZlbnQubmF0aXZlRXZlbnQ7XG4gIGlmIChuYXRpdmVFdmVudC5nZXRNb2RpZmllclN0YXRlKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmdldE1vZGlmaWVyU3RhdGUoa2V5QXJnKTtcbiAgfVxuICB2YXIga2V5UHJvcCA9IG1vZGlmaWVyS2V5VG9Qcm9wW2tleUFyZ107XG4gIHJldHVybiBrZXlQcm9wID8gISFuYXRpdmVFdmVudFtrZXlQcm9wXSA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRFdmVudE1vZGlmaWVyU3RhdGUobmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIG1vZGlmaWVyU3RhdGVHZXR0ZXI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RXZlbnRNb2RpZmllclN0YXRlO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldEV2ZW50VGFyZ2V0XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIEdldHMgdGhlIHRhcmdldCBub2RlIGZyb20gYSBuYXRpdmUgYnJvd3NlciBldmVudCBieSBhY2NvdW50aW5nIGZvclxuICogaW5jb25zaXN0ZW5jaWVzIGluIGJyb3dzZXIgRE9NIEFQSXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7RE9NRXZlbnRUYXJnZXR9IFRhcmdldCBub2RlLlxuICovXG5mdW5jdGlvbiBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCkge1xuICB2YXIgdGFyZ2V0ID0gbmF0aXZlRXZlbnQudGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnNyY0VsZW1lbnQgfHwgd2luZG93O1xuICAvLyBTYWZhcmkgbWF5IGZpcmUgZXZlbnRzIG9uIHRleHQgbm9kZXMgKE5vZGUuVEVYVF9OT0RFIGlzIDMpLlxuICAvLyBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvanMvZXZlbnRzX3Byb3BlcnRpZXMuaHRtbFxuICByZXR1cm4gdGFyZ2V0Lm5vZGVUeXBlID09PSAzID8gdGFyZ2V0LnBhcmVudE5vZGUgOiB0YXJnZXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RXZlbnRUYXJnZXQ7XG4iLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldE1hcmt1cFdyYXBcbiAqL1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKFwiLi9FeGVjdXRpb25FbnZpcm9ubWVudFwiKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcblxuLyoqXG4gKiBEdW1teSBjb250YWluZXIgdXNlZCB0byBkZXRlY3Qgd2hpY2ggd3JhcHMgYXJlIG5lY2Vzc2FyeS5cbiAqL1xudmFyIGR1bW15Tm9kZSA9XG4gIEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpIDogbnVsbDtcblxuLyoqXG4gKiBTb21lIGJyb3dzZXJzIGNhbm5vdCB1c2UgYGlubmVySFRNTGAgdG8gcmVuZGVyIGNlcnRhaW4gZWxlbWVudHMgc3RhbmRhbG9uZSxcbiAqIHNvIHdlIHdyYXAgdGhlbSwgcmVuZGVyIHRoZSB3cmFwcGVkIG5vZGVzLCB0aGVuIGV4dHJhY3QgdGhlIGRlc2lyZWQgbm9kZS5cbiAqXG4gKiBJbiBJRTgsIGNlcnRhaW4gZWxlbWVudHMgY2Fubm90IHJlbmRlciBhbG9uZSwgc28gd3JhcCBhbGwgZWxlbWVudHMgKCcqJykuXG4gKi9cbnZhciBzaG91bGRXcmFwID0ge1xuICAvLyBGb3JjZSB3cmFwcGluZyBmb3IgU1ZHIGVsZW1lbnRzIGJlY2F1c2UgaWYgdGhleSBnZXQgY3JlYXRlZCBpbnNpZGUgYSA8ZGl2PixcbiAgLy8gdGhleSB3aWxsIGJlIGluaXRpYWxpemVkIGluIHRoZSB3cm9uZyBuYW1lc3BhY2UgKGFuZCB3aWxsIG5vdCBkaXNwbGF5KS5cbiAgJ2NpcmNsZSc6IHRydWUsXG4gICdkZWZzJzogdHJ1ZSxcbiAgJ2VsbGlwc2UnOiB0cnVlLFxuICAnZyc6IHRydWUsXG4gICdsaW5lJzogdHJ1ZSxcbiAgJ2xpbmVhckdyYWRpZW50JzogdHJ1ZSxcbiAgJ3BhdGgnOiB0cnVlLFxuICAncG9seWdvbic6IHRydWUsXG4gICdwb2x5bGluZSc6IHRydWUsXG4gICdyYWRpYWxHcmFkaWVudCc6IHRydWUsXG4gICdyZWN0JzogdHJ1ZSxcbiAgJ3N0b3AnOiB0cnVlLFxuICAndGV4dCc6IHRydWVcbn07XG5cbnZhciBzZWxlY3RXcmFwID0gWzEsICc8c2VsZWN0IG11bHRpcGxlPVwidHJ1ZVwiPicsICc8L3NlbGVjdD4nXTtcbnZhciB0YWJsZVdyYXAgPSBbMSwgJzx0YWJsZT4nLCAnPC90YWJsZT4nXTtcbnZhciB0cldyYXAgPSBbMywgJzx0YWJsZT48dGJvZHk+PHRyPicsICc8L3RyPjwvdGJvZHk+PC90YWJsZT4nXTtcblxudmFyIHN2Z1dyYXAgPSBbMSwgJzxzdmc+JywgJzwvc3ZnPiddO1xuXG52YXIgbWFya3VwV3JhcCA9IHtcbiAgJyonOiBbMSwgJz88ZGl2PicsICc8L2Rpdj4nXSxcblxuICAnYXJlYSc6IFsxLCAnPG1hcD4nLCAnPC9tYXA+J10sXG4gICdjb2wnOiBbMiwgJzx0YWJsZT48dGJvZHk+PC90Ym9keT48Y29sZ3JvdXA+JywgJzwvY29sZ3JvdXA+PC90YWJsZT4nXSxcbiAgJ2xlZ2VuZCc6IFsxLCAnPGZpZWxkc2V0PicsICc8L2ZpZWxkc2V0PiddLFxuICAncGFyYW0nOiBbMSwgJzxvYmplY3Q+JywgJzwvb2JqZWN0PiddLFxuICAndHInOiBbMiwgJzx0YWJsZT48dGJvZHk+JywgJzwvdGJvZHk+PC90YWJsZT4nXSxcblxuICAnb3B0Z3JvdXAnOiBzZWxlY3RXcmFwLFxuICAnb3B0aW9uJzogc2VsZWN0V3JhcCxcblxuICAnY2FwdGlvbic6IHRhYmxlV3JhcCxcbiAgJ2NvbGdyb3VwJzogdGFibGVXcmFwLFxuICAndGJvZHknOiB0YWJsZVdyYXAsXG4gICd0Zm9vdCc6IHRhYmxlV3JhcCxcbiAgJ3RoZWFkJzogdGFibGVXcmFwLFxuXG4gICd0ZCc6IHRyV3JhcCxcbiAgJ3RoJzogdHJXcmFwLFxuXG4gICdjaXJjbGUnOiBzdmdXcmFwLFxuICAnZGVmcyc6IHN2Z1dyYXAsXG4gICdlbGxpcHNlJzogc3ZnV3JhcCxcbiAgJ2cnOiBzdmdXcmFwLFxuICAnbGluZSc6IHN2Z1dyYXAsXG4gICdsaW5lYXJHcmFkaWVudCc6IHN2Z1dyYXAsXG4gICdwYXRoJzogc3ZnV3JhcCxcbiAgJ3BvbHlnb24nOiBzdmdXcmFwLFxuICAncG9seWxpbmUnOiBzdmdXcmFwLFxuICAncmFkaWFsR3JhZGllbnQnOiBzdmdXcmFwLFxuICAncmVjdCc6IHN2Z1dyYXAsXG4gICdzdG9wJzogc3ZnV3JhcCxcbiAgJ3RleHQnOiBzdmdXcmFwXG59O1xuXG4vKipcbiAqIEdldHMgdGhlIG1hcmt1cCB3cmFwIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBzdXBwbGllZCBgbm9kZU5hbWVgLlxuICpcbiAqIE5PVEU6IFRoaXMgbGF6aWx5IGRldGVjdHMgd2hpY2ggd3JhcHMgYXJlIG5lY2Vzc2FyeSBmb3IgdGhlIGN1cnJlbnQgYnJvd3Nlci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbm9kZU5hbWUgTG93ZXJjYXNlIGBub2RlTmFtZWAuXG4gKiBAcmV0dXJuIHs/YXJyYXl9IE1hcmt1cCB3cmFwIGNvbmZpZ3VyYXRpb24sIGlmIGFwcGxpY2FibGUuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcmt1cFdyYXAobm9kZU5hbWUpIHtcbiAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudCghIWR1bW15Tm9kZSwgJ01hcmt1cCB3cmFwcGluZyBub2RlIG5vdCBpbml0aWFsaXplZCcpIDogaW52YXJpYW50KCEhZHVtbXlOb2RlKSk7XG4gIGlmICghbWFya3VwV3JhcC5oYXNPd25Qcm9wZXJ0eShub2RlTmFtZSkpIHtcbiAgICBub2RlTmFtZSA9ICcqJztcbiAgfVxuICBpZiAoIXNob3VsZFdyYXAuaGFzT3duUHJvcGVydHkobm9kZU5hbWUpKSB7XG4gICAgaWYgKG5vZGVOYW1lID09PSAnKicpIHtcbiAgICAgIGR1bW15Tm9kZS5pbm5lckhUTUwgPSAnPGxpbmsgLz4nO1xuICAgIH0gZWxzZSB7XG4gICAgICBkdW1teU5vZGUuaW5uZXJIVE1MID0gJzwnICsgbm9kZU5hbWUgKyAnPjwvJyArIG5vZGVOYW1lICsgJz4nO1xuICAgIH1cbiAgICBzaG91bGRXcmFwW25vZGVOYW1lXSA9ICFkdW1teU5vZGUuZmlyc3RDaGlsZDtcbiAgfVxuICByZXR1cm4gc2hvdWxkV3JhcFtub2RlTmFtZV0gPyBtYXJrdXBXcmFwW25vZGVOYW1lXSA6IG51bGw7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRNYXJrdXBXcmFwO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldFxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIEdpdmVuIGFueSBub2RlIHJldHVybiB0aGUgZmlyc3QgbGVhZiBub2RlIHdpdGhvdXQgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtET01FbGVtZW50fERPTVRleHROb2RlfVxuICovXG5mdW5jdGlvbiBnZXRMZWFmTm9kZShub2RlKSB7XG4gIHdoaWxlIChub2RlICYmIG5vZGUuZmlyc3RDaGlsZCkge1xuICAgIG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8qKlxuICogR2V0IHRoZSBuZXh0IHNpYmxpbmcgd2l0aGluIGEgY29udGFpbmVyLiBUaGlzIHdpbGwgd2FsayB1cCB0aGVcbiAqIERPTSBpZiBhIG5vZGUncyBzaWJsaW5ncyBoYXZlIGJlZW4gZXhoYXVzdGVkLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7P0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9XG4gKi9cbmZ1bmN0aW9uIGdldFNpYmxpbmdOb2RlKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5uZXh0U2libGluZykge1xuICAgICAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmc7XG4gICAgfVxuICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgb2JqZWN0IGRlc2NyaWJpbmcgdGhlIG5vZGVzIHdoaWNoIGNvbnRhaW4gY2hhcmFjdGVycyBhdCBvZmZzZXQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSByb290XG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KHJvb3QsIG9mZnNldCkge1xuICB2YXIgbm9kZSA9IGdldExlYWZOb2RlKHJvb3QpO1xuICB2YXIgbm9kZVN0YXJ0ID0gMDtcbiAgdmFyIG5vZGVFbmQgPSAwO1xuXG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMykge1xuICAgICAgbm9kZUVuZCA9IG5vZGVTdGFydCArIG5vZGUudGV4dENvbnRlbnQubGVuZ3RoO1xuXG4gICAgICBpZiAobm9kZVN0YXJ0IDw9IG9mZnNldCAmJiBub2RlRW5kID49IG9mZnNldCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgICAgb2Zmc2V0OiBvZmZzZXQgLSBub2RlU3RhcnRcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgbm9kZVN0YXJ0ID0gbm9kZUVuZDtcbiAgICB9XG5cbiAgICBub2RlID0gZ2V0TGVhZk5vZGUoZ2V0U2libGluZ05vZGUobm9kZSkpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldDtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXJcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIERPQ19OT0RFX1RZUEUgPSA5O1xuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01Eb2N1bWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRoYXQgbWF5IGNvbnRhaW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgUmVhY3QgY29tcG9uZW50XG4gKiBAcmV0dXJuIHs/Kn0gRE9NIGVsZW1lbnQgdGhhdCBtYXkgaGF2ZSB0aGUgcmVhY3RSb290IElELCBvciBudWxsLlxuICovXG5mdW5jdGlvbiBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKSB7XG4gIGlmICghY29udGFpbmVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NfTk9ERV9UWVBFKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5kb2N1bWVudEVsZW1lbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5maXJzdENoaWxkO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldFRleHRDb250ZW50QWNjZXNzb3JcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZShcIi4vRXhlY3V0aW9uRW52aXJvbm1lbnRcIik7XG5cbnZhciBjb250ZW50S2V5ID0gbnVsbDtcblxuLyoqXG4gKiBHZXRzIHRoZSBrZXkgdXNlZCB0byBhY2Nlc3MgdGV4dCBjb250ZW50IG9uIGEgRE9NIG5vZGUuXG4gKlxuICogQHJldHVybiB7P3N0cmluZ30gS2V5IHVzZWQgdG8gYWNjZXNzIHRleHQgY29udGVudC5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBnZXRUZXh0Q29udGVudEFjY2Vzc29yKCkge1xuICBpZiAoIWNvbnRlbnRLZXkgJiYgRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gICAgLy8gUHJlZmVyIHRleHRDb250ZW50IHRvIGlubmVyVGV4dCBiZWNhdXNlIG1hbnkgYnJvd3NlcnMgc3VwcG9ydCBib3RoIGJ1dFxuICAgIC8vIFNWRyA8dGV4dD4gZWxlbWVudHMgZG9uJ3Qgc3VwcG9ydCBpbm5lclRleHQgZXZlbiB3aGVuIDxkaXY+IGRvZXMuXG4gICAgY29udGVudEtleSA9ICd0ZXh0Q29udGVudCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ID9cbiAgICAgICd0ZXh0Q29udGVudCcgOlxuICAgICAgJ2lubmVyVGV4dCc7XG4gIH1cbiAgcmV0dXJuIGNvbnRlbnRLZXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcjtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvblxuICogQHR5cGVjaGVja3NcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBHZXRzIHRoZSBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIHN1cHBsaWVkIGVsZW1lbnQgb3Igd2luZG93LlxuICpcbiAqIFRoZSByZXR1cm4gdmFsdWVzIGFyZSB1bmJvdW5kZWQsIHVubGlrZSBgZ2V0U2Nyb2xsUG9zaXRpb25gLiBUaGlzIG1lYW5zIHRoZXlcbiAqIG1heSBiZSBuZWdhdGl2ZSBvciBleGNlZWQgdGhlIGVsZW1lbnQgYm91bmRhcmllcyAod2hpY2ggaXMgcG9zc2libGUgdXNpbmdcbiAqIGluZXJ0aWFsIHNjcm9sbGluZykuXG4gKlxuICogQHBhcmFtIHtET01XaW5kb3d8RE9NRWxlbWVudH0gc2Nyb2xsYWJsZVxuICogQHJldHVybiB7b2JqZWN0fSBNYXAgd2l0aCBgeGAgYW5kIGB5YCBrZXlzLlxuICovXG5mdW5jdGlvbiBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbihzY3JvbGxhYmxlKSB7XG4gIGlmIChzY3JvbGxhYmxlID09PSB3aW5kb3cpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogd2luZG93LnBhZ2VYT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0LFxuICAgICAgeTogd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3BcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgeDogc2Nyb2xsYWJsZS5zY3JvbGxMZWZ0LFxuICAgIHk6IHNjcm9sbGFibGUuc2Nyb2xsVG9wXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb247XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaHlwaGVuYXRlXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBfdXBwZXJjYXNlUGF0dGVybiA9IC8oW0EtWl0pL2c7XG5cbi8qKlxuICogSHlwaGVuYXRlcyBhIGNhbWVsY2FzZWQgc3RyaW5nLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gaHlwaGVuYXRlKCdiYWNrZ3JvdW5kQ29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZC1jb2xvclwiXG4gKlxuICogRm9yIENTUyBzdHlsZSBuYW1lcywgdXNlIGBoeXBoZW5hdGVTdHlsZU5hbWVgIGluc3RlYWQgd2hpY2ggd29ya3MgcHJvcGVybHlcbiAqIHdpdGggYWxsIHZlbmRvciBwcmVmaXhlcywgaW5jbHVkaW5nIGBtc2AuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBoeXBoZW5hdGUoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShfdXBwZXJjYXNlUGF0dGVybiwgJy0kMScpLnRvTG93ZXJDYXNlKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaHlwaGVuYXRlO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGh5cGhlbmF0ZVN0eWxlTmFtZVxuICogQHR5cGVjaGVja3NcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGh5cGhlbmF0ZSA9IHJlcXVpcmUoXCIuL2h5cGhlbmF0ZVwiKTtcblxudmFyIG1zUGF0dGVybiA9IC9ebXMtLztcblxuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGh5cGhlbmF0ZSgnYmFja2dyb3VuZENvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmQtY29sb3JcIlxuICogICA+IGh5cGhlbmF0ZSgnTW96VHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbW96LXRyYW5zaXRpb25cIlxuICogICA+IGh5cGhlbmF0ZSgnbXNUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tcy10cmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBNb2Rlcm5penIgc3VnZ2VzdHMgKGh0dHA6Ly9tb2Rlcm5penIuY29tL2RvY3MvI3ByZWZpeGVkKSwgYW4gYG1zYCBwcmVmaXhcbiAqIGlzIGNvbnZlcnRlZCB0byBgLW1zLWAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBoeXBoZW5hdGVTdHlsZU5hbWUoc3RyaW5nKSB7XG4gIHJldHVybiBoeXBoZW5hdGUoc3RyaW5nKS5yZXBsYWNlKG1zUGF0dGVybiwgJy1tcy0nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoeXBoZW5hdGVTdHlsZU5hbWU7XG4iLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbi8qKlxuICogVmFsaWRhdGUgYSBgY29tcG9uZW50RGVzY3JpcHRvcmAuIFRoaXMgc2hvdWxkIGJlIGV4cG9zZWQgcHVibGljbHkgaW4gYSBmb2xsb3dcbiAqIHVwIGRpZmYuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGRlc2NyaXB0b3JcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGlzIGlzIGEgdmFsaWQgZGVzY3JpcHRvciBvZiBhIENvbXBvbmVudC5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZENvbXBvbmVudERlc2NyaXB0b3IoZGVzY3JpcHRvcikge1xuICByZXR1cm4gKFxuICAgIGRlc2NyaXB0b3IgJiZcbiAgICB0eXBlb2YgZGVzY3JpcHRvci50eXBlID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIGRlc2NyaXB0b3IudHlwZS5wcm90b3R5cGUubW91bnRDb21wb25lbnQgPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2YgZGVzY3JpcHRvci50eXBlLnByb3RvdHlwZS5yZWNlaXZlQ29tcG9uZW50ID09PSAnZnVuY3Rpb24nXG4gICk7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBgY29tcG9uZW50RGVzY3JpcHRvcmAgY3JlYXRlIGFuIGluc3RhbmNlIHRoYXQgd2lsbCBhY3R1YWxseSBiZVxuICogbW91bnRlZC4gQ3VycmVudGx5IGl0IGp1c3QgZXh0cmFjdHMgYW4gZXhpc3RpbmcgY2xvbmUgZnJvbSBjb21wb3NpdGVcbiAqIGNvbXBvbmVudHMgYnV0IHRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsIHdoaWNoIHdpbGwgY2hhbmdlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBkZXNjcmlwdG9yXG4gKiBAcmV0dXJuIHtvYmplY3R9IEEgbmV3IGluc3RhbmNlIG9mIGNvbXBvbmVudERlc2NyaXB0b3IncyBjb25zdHJ1Y3Rvci5cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuZnVuY3Rpb24gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChkZXNjcmlwdG9yKSB7XG5cbiAgLy8gVE9ETzogTWFrZSB3YXJuaW5nXG4gIC8vIGlmIChfX0RFVl9fKSB7XG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgIGlzVmFsaWRDb21wb25lbnREZXNjcmlwdG9yKGRlc2NyaXB0b3IpLFxuICAgICAgJ09ubHkgUmVhY3QgQ29tcG9uZW50cyBhcmUgdmFsaWQgZm9yIG1vdW50aW5nLidcbiAgICApIDogaW52YXJpYW50KGlzVmFsaWRDb21wb25lbnREZXNjcmlwdG9yKGRlc2NyaXB0b3IpKSk7XG4gIC8vIH1cblxuICByZXR1cm4gbmV3IGRlc2NyaXB0b3IudHlwZShkZXNjcmlwdG9yKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGludmFyaWFudFxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgaW52YXJpYW50ID0gZnVuY3Rpb24oY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdmFyIGVycm9yO1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICtcbiAgICAgICAgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJ1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFyZ3MgPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICdJbnZhcmlhbnQgVmlvbGF0aW9uOiAnICtcbiAgICAgICAgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJnc1thcmdJbmRleCsrXTsgfSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGlzRXZlbnRTdXBwb3J0ZWRcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZShcIi4vRXhlY3V0aW9uRW52aXJvbm1lbnRcIik7XG5cbnZhciB1c2VIYXNGZWF0dXJlO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICB1c2VIYXNGZWF0dXJlID1cbiAgICBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbiAmJlxuICAgIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUgJiZcbiAgICAvLyBhbHdheXMgcmV0dXJucyB0cnVlIGluIG5ld2VyIGJyb3dzZXJzIGFzIHBlciB0aGUgc3RhbmRhcmQuXG4gICAgLy8gQHNlZSBodHRwOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWRvbWltcGxlbWVudGF0aW9uLWhhc2ZlYXR1cmVcbiAgICBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCcnLCAnJykgIT09IHRydWU7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGFuIGV2ZW50IGlzIHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBleGVjdXRpb24gZW52aXJvbm1lbnQuXG4gKlxuICogTk9URTogVGhpcyB3aWxsIG5vdCB3b3JrIGNvcnJlY3RseSBmb3Igbm9uLWdlbmVyaWMgZXZlbnRzIHN1Y2ggYXMgYGNoYW5nZWAsXG4gKiBgcmVzZXRgLCBgbG9hZGAsIGBlcnJvcmAsIGFuZCBgc2VsZWN0YC5cbiAqXG4gKiBCb3Jyb3dzIGZyb20gTW9kZXJuaXpyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVTdWZmaXggRXZlbnQgbmFtZSwgZS5nLiBcImNsaWNrXCIuXG4gKiBAcGFyYW0gez9ib29sZWFufSBjYXB0dXJlIENoZWNrIGlmIHRoZSBjYXB0dXJlIHBoYXNlIGlzIHN1cHBvcnRlZC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IGlzIHN1cHBvcnRlZC5cbiAqIEBpbnRlcm5hbFxuICogQGxpY2Vuc2UgTW9kZXJuaXpyIDMuMC4wcHJlIChDdXN0b20gQnVpbGQpIHwgTUlUXG4gKi9cbmZ1bmN0aW9uIGlzRXZlbnRTdXBwb3J0ZWQoZXZlbnROYW1lU3VmZml4LCBjYXB0dXJlKSB7XG4gIGlmICghRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NIHx8XG4gICAgICBjYXB0dXJlICYmICEoJ2FkZEV2ZW50TGlzdGVuZXInIGluIGRvY3VtZW50KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBldmVudE5hbWUgPSAnb24nICsgZXZlbnROYW1lU3VmZml4O1xuICB2YXIgaXNTdXBwb3J0ZWQgPSBldmVudE5hbWUgaW4gZG9jdW1lbnQ7XG5cbiAgaWYgKCFpc1N1cHBvcnRlZCkge1xuICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoZXZlbnROYW1lLCAncmV0dXJuOycpO1xuICAgIGlzU3VwcG9ydGVkID0gdHlwZW9mIGVsZW1lbnRbZXZlbnROYW1lXSA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIGlmICghaXNTdXBwb3J0ZWQgJiYgdXNlSGFzRmVhdHVyZSAmJiBldmVudE5hbWVTdWZmaXggPT09ICd3aGVlbCcpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBvbmx5IHdheSB0byB0ZXN0IHN1cHBvcnQgZm9yIHRoZSBgd2hlZWxgIGV2ZW50IGluIElFOSsuXG4gICAgaXNTdXBwb3J0ZWQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCdFdmVudHMud2hlZWwnLCAnMy4wJyk7XG4gIH1cblxuICByZXR1cm4gaXNTdXBwb3J0ZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNFdmVudFN1cHBvcnRlZDtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBpc05vZGVcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIG9iamVjdCBpcyBhIERPTSBub2RlLlxuICovXG5mdW5jdGlvbiBpc05vZGUob2JqZWN0KSB7XG4gIHJldHVybiAhIShvYmplY3QgJiYgKFxuICAgIHR5cGVvZiBOb2RlID09PSAnZnVuY3Rpb24nID8gb2JqZWN0IGluc3RhbmNlb2YgTm9kZSA6XG4gICAgICB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgdHlwZW9mIG9iamVjdC5ub2RlVHlwZSA9PT0gJ251bWJlcicgJiZcbiAgICAgIHR5cGVvZiBvYmplY3Qubm9kZU5hbWUgPT09ICdzdHJpbmcnXG4gICkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTm9kZTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBpc1RleHRJbnB1dEVsZW1lbnRcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBAc2VlIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1pbnB1dC1lbGVtZW50Lmh0bWwjaW5wdXQtdHlwZS1hdHRyLXN1bW1hcnlcbiAqL1xudmFyIHN1cHBvcnRlZElucHV0VHlwZXMgPSB7XG4gICdjb2xvcic6IHRydWUsXG4gICdkYXRlJzogdHJ1ZSxcbiAgJ2RhdGV0aW1lJzogdHJ1ZSxcbiAgJ2RhdGV0aW1lLWxvY2FsJzogdHJ1ZSxcbiAgJ2VtYWlsJzogdHJ1ZSxcbiAgJ21vbnRoJzogdHJ1ZSxcbiAgJ251bWJlcic6IHRydWUsXG4gICdwYXNzd29yZCc6IHRydWUsXG4gICdyYW5nZSc6IHRydWUsXG4gICdzZWFyY2gnOiB0cnVlLFxuICAndGVsJzogdHJ1ZSxcbiAgJ3RleHQnOiB0cnVlLFxuICAndGltZSc6IHRydWUsXG4gICd1cmwnOiB0cnVlLFxuICAnd2Vlayc6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGlzVGV4dElucHV0RWxlbWVudChlbGVtKSB7XG4gIHJldHVybiBlbGVtICYmIChcbiAgICAoZWxlbS5ub2RlTmFtZSA9PT0gJ0lOUFVUJyAmJiBzdXBwb3J0ZWRJbnB1dFR5cGVzW2VsZW0udHlwZV0pIHx8XG4gICAgZWxlbS5ub2RlTmFtZSA9PT0gJ1RFWFRBUkVBJ1xuICApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVGV4dElucHV0RWxlbWVudDtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBpc1RleHROb2RlXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBpc05vZGUgPSByZXF1aXJlKFwiLi9pc05vZGVcIik7XG5cbi8qKlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBvYmplY3QgaXMgYSBET00gdGV4dCBub2RlLlxuICovXG5mdW5jdGlvbiBpc1RleHROb2RlKG9iamVjdCkge1xuICByZXR1cm4gaXNOb2RlKG9iamVjdCkgJiYgb2JqZWN0Lm5vZGVUeXBlID09IDM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUZXh0Tm9kZTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBqb2luQ2xhc3Nlc1xuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBDb21iaW5lcyBtdWx0aXBsZSBjbGFzc05hbWUgc3RyaW5ncyBpbnRvIG9uZS5cbiAqIGh0dHA6Ly9qc3BlcmYuY29tL2pvaW5jbGFzc2VzLWFyZ3MtdnMtYXJyYXlcbiAqXG4gKiBAcGFyYW0gey4uLj9zdHJpbmd9IGNsYXNzZXNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gam9pbkNsYXNzZXMoY2xhc3NOYW1lLyosIC4uLiAqLykge1xuICBpZiAoIWNsYXNzTmFtZSkge1xuICAgIGNsYXNzTmFtZSA9ICcnO1xuICB9XG4gIHZhciBuZXh0Q2xhc3M7XG4gIHZhciBhcmdMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICBpZiAoYXJnTGVuZ3RoID4gMSkge1xuICAgIGZvciAodmFyIGlpID0gMTsgaWkgPCBhcmdMZW5ndGg7IGlpKyspIHtcbiAgICAgIG5leHRDbGFzcyA9IGFyZ3VtZW50c1tpaV07XG4gICAgICBuZXh0Q2xhc3MgJiYgKGNsYXNzTmFtZSArPSAnICcgKyBuZXh0Q2xhc3MpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2xhc3NOYW1lO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGpvaW5DbGFzc2VzO1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBrZXlNaXJyb3JcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhbiBlbnVtZXJhdGlvbiB3aXRoIGtleXMgZXF1YWwgdG8gdGhlaXIgdmFsdWUuXG4gKlxuICogRm9yIGV4YW1wbGU6XG4gKlxuICogICB2YXIgQ09MT1JTID0ga2V5TWlycm9yKHtibHVlOiBudWxsLCByZWQ6IG51bGx9KTtcbiAqICAgdmFyIG15Q29sb3IgPSBDT0xPUlMuYmx1ZTtcbiAqICAgdmFyIGlzQ29sb3JWYWxpZCA9ICEhQ09MT1JTW215Q29sb3JdO1xuICpcbiAqIFRoZSBsYXN0IGxpbmUgY291bGQgbm90IGJlIHBlcmZvcm1lZCBpZiB0aGUgdmFsdWVzIG9mIHRoZSBnZW5lcmF0ZWQgZW51bSB3ZXJlXG4gKiBub3QgZXF1YWwgdG8gdGhlaXIga2V5cy5cbiAqXG4gKiAgIElucHV0OiAge2tleTE6IHZhbDEsIGtleTI6IHZhbDJ9XG4gKiAgIE91dHB1dDoge2tleTE6IGtleTEsIGtleTI6IGtleTJ9XG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9ialxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG52YXIga2V5TWlycm9yID0gZnVuY3Rpb24ob2JqKSB7XG4gIHZhciByZXQgPSB7fTtcbiAgdmFyIGtleTtcbiAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICBvYmogaW5zdGFuY2VvZiBPYmplY3QgJiYgIUFycmF5LmlzQXJyYXkob2JqKSxcbiAgICAna2V5TWlycm9yKC4uLik6IEFyZ3VtZW50IG11c3QgYmUgYW4gb2JqZWN0LidcbiAgKSA6IGludmFyaWFudChvYmogaW5zdGFuY2VvZiBPYmplY3QgJiYgIUFycmF5LmlzQXJyYXkob2JqKSkpO1xuICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICBpZiAoIW9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcmV0W2tleV0gPSBrZXk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5TWlycm9yO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUga2V5T2ZcbiAqL1xuXG4vKipcbiAqIEFsbG93cyBleHRyYWN0aW9uIG9mIGEgbWluaWZpZWQga2V5LiBMZXQncyB0aGUgYnVpbGQgc3lzdGVtIG1pbmlmeSBrZXlzXG4gKiB3aXRob3V0IGxvb3NpbmcgdGhlIGFiaWxpdHkgdG8gZHluYW1pY2FsbHkgdXNlIGtleSBzdHJpbmdzIGFzIHZhbHVlc1xuICogdGhlbXNlbHZlcy4gUGFzcyBpbiBhbiBvYmplY3Qgd2l0aCBhIHNpbmdsZSBrZXkvdmFsIHBhaXIgYW5kIGl0IHdpbGwgcmV0dXJuXG4gKiB5b3UgdGhlIHN0cmluZyBrZXkgb2YgdGhhdCBzaW5nbGUgcmVjb3JkLiBTdXBwb3NlIHlvdSB3YW50IHRvIGdyYWIgdGhlXG4gKiB2YWx1ZSBmb3IgYSBrZXkgJ2NsYXNzTmFtZScgaW5zaWRlIG9mIGFuIG9iamVjdC4gS2V5L3ZhbCBtaW5pZmljYXRpb24gbWF5XG4gKiBoYXZlIGFsaWFzZWQgdGhhdCBrZXkgdG8gYmUgJ3hhMTInLiBrZXlPZih7Y2xhc3NOYW1lOiBudWxsfSkgd2lsbCByZXR1cm5cbiAqICd4YTEyJyBpbiB0aGF0IGNhc2UuIFJlc29sdmUga2V5cyB5b3Ugd2FudCB0byB1c2Ugb25jZSBhdCBzdGFydHVwIHRpbWUsIHRoZW5cbiAqIHJldXNlIHRob3NlIHJlc29sdXRpb25zLlxuICovXG52YXIga2V5T2YgPSBmdW5jdGlvbihvbmVLZXlPYmopIHtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gb25lS2V5T2JqKSB7XG4gICAgaWYgKCFvbmVLZXlPYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0ga2V5T2Y7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgbWFwT2JqZWN0XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogRm9yIGVhY2gga2V5L3ZhbHVlIHBhaXIsIGludm9rZXMgY2FsbGJhY2sgZnVuYyBhbmQgY29uc3RydWN0cyBhIHJlc3VsdGluZ1xuICogb2JqZWN0IHdoaWNoIGNvbnRhaW5zLCBmb3IgZXZlcnkga2V5IGluIG9iaiwgdmFsdWVzIHRoYXQgYXJlIHRoZSByZXN1bHQgb2ZcbiAqIG9mIGludm9raW5nIHRoZSBmdW5jdGlvbjpcbiAqXG4gKiAgIGZ1bmModmFsdWUsIGtleSwgaXRlcmF0aW9uKVxuICpcbiAqIEdyZXBhYmxlIG5hbWVzOlxuICpcbiAqICAgZnVuY3Rpb24gb2JqZWN0TWFwKClcbiAqICAgZnVuY3Rpb24gb2JqTWFwKClcbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IG9iaiBPYmplY3QgdG8gbWFwIGtleXMgb3ZlclxuICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuYyBJbnZva2VkIGZvciBlYWNoIGtleS92YWwgcGFpci5cbiAqIEBwYXJhbSB7Pyp9IGNvbnRleHRcbiAqIEByZXR1cm4gez9vYmplY3R9IFJlc3VsdCBvZiBtYXBwaW5nIG9yIG51bGwgaWYgb2JqIGlzIGZhbHNleVxuICovXG5mdW5jdGlvbiBtYXBPYmplY3Qob2JqLCBmdW5jLCBjb250ZXh0KSB7XG4gIGlmICghb2JqKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIGkgPSAwO1xuICB2YXIgcmV0ID0ge307XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHJldFtrZXldID0gZnVuYy5jYWxsKGNvbnRleHQsIG9ialtrZXldLCBrZXksIGkrKyk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwT2JqZWN0O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIG1lbW9pemVTdHJpbmdPbmx5XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIE1lbW9pemVzIHRoZSByZXR1cm4gdmFsdWUgb2YgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgb25lIHN0cmluZyBhcmd1bWVudC5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybiB7ZnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIG1lbW9pemVTdHJpbmdPbmx5KGNhbGxiYWNrKSB7XG4gIHZhciBjYWNoZSA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgaWYgKGNhY2hlLmhhc093blByb3BlcnR5KHN0cmluZykpIHtcbiAgICAgIHJldHVybiBjYWNoZVtzdHJpbmddO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY2FjaGVbc3RyaW5nXSA9IGNhbGxiYWNrLmNhbGwodGhpcywgc3RyaW5nKTtcbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZVN0cmluZ09ubHk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgbWVyZ2VcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIG1lcmdlSW50byA9IHJlcXVpcmUoXCIuL21lcmdlSW50b1wiKTtcblxuLyoqXG4gKiBTaGFsbG93IG1lcmdlcyB0d28gc3RydWN0dXJlcyBpbnRvIGEgcmV0dXJuIHZhbHVlLCB3aXRob3V0IG11dGF0aW5nIGVpdGhlci5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IG9uZSBPcHRpb25hbCBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIHRvIG1lcmdlIGZyb20uXG4gKiBAcGFyYW0gez9vYmplY3R9IHR3byBPcHRpb25hbCBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIHRvIG1lcmdlIGZyb20uXG4gKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBzaGFsbG93IGV4dGVuc2lvbiBvZiBvbmUgYnkgdHdvLlxuICovXG52YXIgbWVyZ2UgPSBmdW5jdGlvbihvbmUsIHR3bykge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIG1lcmdlSW50byhyZXN1bHQsIG9uZSk7XG4gIG1lcmdlSW50byhyZXN1bHQsIHR3byk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1lcmdlO1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBtZXJnZUhlbHBlcnNcbiAqXG4gKiByZXF1aXJlc1BvbHlmaWxsczogQXJyYXkuaXNBcnJheVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xudmFyIGtleU1pcnJvciA9IHJlcXVpcmUoXCIuL2tleU1pcnJvclwiKTtcblxuLyoqXG4gKiBNYXhpbXVtIG51bWJlciBvZiBsZXZlbHMgdG8gdHJhdmVyc2UuIFdpbGwgY2F0Y2ggY2lyY3VsYXIgc3RydWN0dXJlcy5cbiAqIEBjb25zdFxuICovXG52YXIgTUFYX01FUkdFX0RFUFRIID0gMzY7XG5cbi8qKlxuICogV2Ugd29uJ3Qgd29ycnkgYWJvdXQgZWRnZSBjYXNlcyBsaWtlIG5ldyBTdHJpbmcoJ3gnKSBvciBuZXcgQm9vbGVhbih0cnVlKS5cbiAqIEZ1bmN0aW9ucyBhcmUgY29uc2lkZXJlZCB0ZXJtaW5hbHMsIGFuZCBhcnJheXMgYXJlIG5vdC5cbiAqIEBwYXJhbSB7Kn0gbyBUaGUgaXRlbS9vYmplY3QvdmFsdWUgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWZmIHRoZSBhcmd1bWVudCBpcyBhIHRlcm1pbmFsLlxuICovXG52YXIgaXNUZXJtaW5hbCA9IGZ1bmN0aW9uKG8pIHtcbiAgcmV0dXJuIHR5cGVvZiBvICE9PSAnb2JqZWN0JyB8fCBvID09PSBudWxsO1xufTtcblxudmFyIG1lcmdlSGVscGVycyA9IHtcblxuICBNQVhfTUVSR0VfREVQVEg6IE1BWF9NRVJHRV9ERVBUSCxcblxuICBpc1Rlcm1pbmFsOiBpc1Rlcm1pbmFsLFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBudWxsL3VuZGVmaW5lZCB2YWx1ZXMgaW50byBlbXB0eSBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7P09iamVjdD19IGFyZyBBcmd1bWVudCB0byBiZSBub3JtYWxpemVkIChudWxsYWJsZSBvcHRpb25hbClcbiAgICogQHJldHVybiB7IU9iamVjdH1cbiAgICovXG4gIG5vcm1hbGl6ZU1lcmdlQXJnOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09PSB1bmRlZmluZWQgfHwgYXJnID09PSBudWxsID8ge30gOiBhcmc7XG4gIH0sXG5cbiAgLyoqXG4gICAqIElmIG1lcmdpbmcgQXJyYXlzLCBhIG1lcmdlIHN0cmF0ZWd5ICptdXN0KiBiZSBzdXBwbGllZC4gSWYgbm90LCBpdCBpc1xuICAgKiBsaWtlbHkgdGhlIGNhbGxlcidzIGZhdWx0LiBJZiB0aGlzIGZ1bmN0aW9uIGlzIGV2ZXIgY2FsbGVkIHdpdGggYW55dGhpbmdcbiAgICogYnV0IGBvbmVgIGFuZCBgdHdvYCBiZWluZyBgQXJyYXlgcywgaXQgaXMgdGhlIGZhdWx0IG9mIHRoZSBtZXJnZSB1dGlsaXRpZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gb25lIEFycmF5IHRvIG1lcmdlIGludG8uXG4gICAqIEBwYXJhbSB7Kn0gdHdvIEFycmF5IHRvIG1lcmdlIGZyb20uXG4gICAqL1xuICBjaGVja01lcmdlQXJyYXlBcmdzOiBmdW5jdGlvbihvbmUsIHR3bykge1xuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICBBcnJheS5pc0FycmF5KG9uZSkgJiYgQXJyYXkuaXNBcnJheSh0d28pLFxuICAgICAgJ1RyaWVkIHRvIG1lcmdlIGFycmF5cywgaW5zdGVhZCBnb3QgJXMgYW5kICVzLicsXG4gICAgICBvbmUsXG4gICAgICB0d29cbiAgICApIDogaW52YXJpYW50KEFycmF5LmlzQXJyYXkob25lKSAmJiBBcnJheS5pc0FycmF5KHR3bykpKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHsqfSBvbmUgT2JqZWN0IHRvIG1lcmdlIGludG8uXG4gICAqIEBwYXJhbSB7Kn0gdHdvIE9iamVjdCB0byBtZXJnZSBmcm9tLlxuICAgKi9cbiAgY2hlY2tNZXJnZU9iamVjdEFyZ3M6IGZ1bmN0aW9uKG9uZSwgdHdvKSB7XG4gICAgbWVyZ2VIZWxwZXJzLmNoZWNrTWVyZ2VPYmplY3RBcmcob25lKTtcbiAgICBtZXJnZUhlbHBlcnMuY2hlY2tNZXJnZU9iamVjdEFyZyh0d28pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyp9IGFyZ1xuICAgKi9cbiAgY2hlY2tNZXJnZU9iamVjdEFyZzogZnVuY3Rpb24oYXJnKSB7XG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICFpc1Rlcm1pbmFsKGFyZykgJiYgIUFycmF5LmlzQXJyYXkoYXJnKSxcbiAgICAgICdUcmllZCB0byBtZXJnZSBhbiBvYmplY3QsIGluc3RlYWQgZ290ICVzLicsXG4gICAgICBhcmdcbiAgICApIDogaW52YXJpYW50KCFpc1Rlcm1pbmFsKGFyZykgJiYgIUFycmF5LmlzQXJyYXkoYXJnKSkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyp9IGFyZ1xuICAgKi9cbiAgY2hlY2tNZXJnZUludG9PYmplY3RBcmc6IGZ1bmN0aW9uKGFyZykge1xuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAoIWlzVGVybWluYWwoYXJnKSB8fCB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nKSAmJiAhQXJyYXkuaXNBcnJheShhcmcpLFxuICAgICAgJ1RyaWVkIHRvIG1lcmdlIGludG8gYW4gb2JqZWN0LCBpbnN0ZWFkIGdvdCAlcy4nLFxuICAgICAgYXJnXG4gICAgKSA6IGludmFyaWFudCgoIWlzVGVybWluYWwoYXJnKSB8fCB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nKSAmJiAhQXJyYXkuaXNBcnJheShhcmcpKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrcyB0aGF0IGEgbWVyZ2Ugd2FzIG5vdCBnaXZlbiBhIGNpcmN1bGFyIG9iamVjdCBvciBhbiBvYmplY3QgdGhhdCBoYWRcbiAgICogdG9vIGdyZWF0IG9mIGRlcHRoLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gTGV2ZWwgb2YgcmVjdXJzaW9uIHRvIHZhbGlkYXRlIGFnYWluc3QgbWF4aW11bS5cbiAgICovXG4gIGNoZWNrTWVyZ2VMZXZlbDogZnVuY3Rpb24obGV2ZWwpIHtcbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgbGV2ZWwgPCBNQVhfTUVSR0VfREVQVEgsXG4gICAgICAnTWF4aW11bSBkZWVwIG1lcmdlIGRlcHRoIGV4Y2VlZGVkLiBZb3UgbWF5IGJlIGF0dGVtcHRpbmcgdG8gbWVyZ2UgJyArXG4gICAgICAnY2lyY3VsYXIgc3RydWN0dXJlcyBpbiBhbiB1bnN1cHBvcnRlZCB3YXkuJ1xuICAgICkgOiBpbnZhcmlhbnQobGV2ZWwgPCBNQVhfTUVSR0VfREVQVEgpKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2tzIHRoYXQgdGhlIHN1cHBsaWVkIG1lcmdlIHN0cmF0ZWd5IGlzIHZhbGlkLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gQXJyYXkgbWVyZ2Ugc3RyYXRlZ3kuXG4gICAqL1xuICBjaGVja0FycmF5U3RyYXRlZ3k6IGZ1bmN0aW9uKHN0cmF0ZWd5KSB7XG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgIHN0cmF0ZWd5ID09PSB1bmRlZmluZWQgfHwgc3RyYXRlZ3kgaW4gbWVyZ2VIZWxwZXJzLkFycmF5U3RyYXRlZ2llcyxcbiAgICAgICdZb3UgbXVzdCBwcm92aWRlIGFuIGFycmF5IHN0cmF0ZWd5IHRvIGRlZXAgbWVyZ2UgZnVuY3Rpb25zIHRvICcgK1xuICAgICAgJ2luc3RydWN0IHRoZSBkZWVwIG1lcmdlIGhvdyB0byByZXNvbHZlIG1lcmdpbmcgdHdvIGFycmF5cy4nXG4gICAgKSA6IGludmFyaWFudChzdHJhdGVneSA9PT0gdW5kZWZpbmVkIHx8IHN0cmF0ZWd5IGluIG1lcmdlSGVscGVycy5BcnJheVN0cmF0ZWdpZXMpKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0IG9mIHBvc3NpYmxlIGJlaGF2aW9ycyBvZiBtZXJnZSBhbGdvcml0aG1zIHdoZW4gZW5jb3VudGVyaW5nIHR3byBBcnJheXNcbiAgICogdGhhdCBtdXN0IGJlIG1lcmdlZCB0b2dldGhlci5cbiAgICogLSBgY2xvYmJlcmA6IFRoZSBsZWZ0IGBBcnJheWAgaXMgaWdub3JlZC5cbiAgICogLSBgaW5kZXhCeUluZGV4YDogVGhlIHJlc3VsdCBpcyBhY2hpZXZlZCBieSByZWN1cnNpdmVseSBkZWVwIG1lcmdpbmcgYXRcbiAgICogICBlYWNoIGluZGV4LiAobm90IHlldCBzdXBwb3J0ZWQuKVxuICAgKi9cbiAgQXJyYXlTdHJhdGVnaWVzOiBrZXlNaXJyb3Ioe1xuICAgIENsb2JiZXI6IHRydWUsXG4gICAgSW5kZXhCeUluZGV4OiB0cnVlXG4gIH0pXG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbWVyZ2VIZWxwZXJzO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgbWVyZ2VJbnRvXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgbWVyZ2VIZWxwZXJzID0gcmVxdWlyZShcIi4vbWVyZ2VIZWxwZXJzXCIpO1xuXG52YXIgY2hlY2tNZXJnZU9iamVjdEFyZyA9IG1lcmdlSGVscGVycy5jaGVja01lcmdlT2JqZWN0QXJnO1xudmFyIGNoZWNrTWVyZ2VJbnRvT2JqZWN0QXJnID0gbWVyZ2VIZWxwZXJzLmNoZWNrTWVyZ2VJbnRvT2JqZWN0QXJnO1xuXG4vKipcbiAqIFNoYWxsb3cgbWVyZ2VzIHR3byBzdHJ1Y3R1cmVzIGJ5IG11dGF0aW5nIHRoZSBmaXJzdCBwYXJhbWV0ZXIuXG4gKlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IG9uZSBPYmplY3QgdG8gYmUgbWVyZ2VkIGludG8uXG4gKiBAcGFyYW0gez9vYmplY3R9IHR3byBPcHRpb25hbCBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIHRvIG1lcmdlIGZyb20uXG4gKi9cbmZ1bmN0aW9uIG1lcmdlSW50byhvbmUsIHR3bykge1xuICBjaGVja01lcmdlSW50b09iamVjdEFyZyhvbmUpO1xuICBpZiAodHdvICE9IG51bGwpIHtcbiAgICBjaGVja01lcmdlT2JqZWN0QXJnKHR3byk7XG4gICAgZm9yICh2YXIga2V5IGluIHR3bykge1xuICAgICAgaWYgKCF0d28uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIG9uZVtrZXldID0gdHdvW2tleV07XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWVyZ2VJbnRvO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIG1peEludG9cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBTaW1wbHkgY29waWVzIHByb3BlcnRpZXMgdG8gdGhlIHByb3RvdHlwZS5cbiAqL1xudmFyIG1peEludG8gPSBmdW5jdGlvbihjb25zdHJ1Y3RvciwgbWV0aG9kQmFnKSB7XG4gIHZhciBtZXRob2ROYW1lO1xuICBmb3IgKG1ldGhvZE5hbWUgaW4gbWV0aG9kQmFnKSB7XG4gICAgaWYgKCFtZXRob2RCYWcuaGFzT3duUHJvcGVydHkobWV0aG9kTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBtZXRob2RCYWdbbWV0aG9kTmFtZV07XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbWl4SW50bztcbiIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIG1vbml0b3JDb2RlVXNlXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbi8qKlxuICogUHJvdmlkZXMgb3Blbi1zb3VyY2UgY29tcGF0aWJsZSBpbnN0cnVtZW50YXRpb24gZm9yIG1vbml0b3JpbmcgY2VydGFpbiBBUElcbiAqIHVzZXMgYmVmb3JlIHdlJ3JlIHJlYWR5IHRvIGlzc3VlIGEgd2FybmluZyBvciByZWZhY3Rvci4gSXQgYWNjZXB0cyBhbiBldmVudFxuICogbmFtZSB3aGljaCBtYXkgb25seSBjb250YWluIHRoZSBjaGFyYWN0ZXJzIFthLXowLTlfXSBhbmQgYW4gb3B0aW9uYWwgZGF0YVxuICogb2JqZWN0IHdpdGggZnVydGhlciBpbmZvcm1hdGlvbi5cbiAqL1xuXG5mdW5jdGlvbiBtb25pdG9yQ29kZVVzZShldmVudE5hbWUsIGRhdGEpIHtcbiAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICBldmVudE5hbWUgJiYgIS9bXmEtejAtOV9dLy50ZXN0KGV2ZW50TmFtZSksXG4gICAgJ1lvdSBtdXN0IHByb3ZpZGUgYW4gZXZlbnROYW1lIHVzaW5nIG9ubHkgdGhlIGNoYXJhY3RlcnMgW2EtejAtOV9dJ1xuICApIDogaW52YXJpYW50KGV2ZW50TmFtZSAmJiAhL1teYS16MC05X10vLnRlc3QoZXZlbnROYW1lKSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1vbml0b3JDb2RlVXNlO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIG9ubHlDaGlsZFxuICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIFJlYWN0RGVzY3JpcHRvciA9IHJlcXVpcmUoXCIuL1JlYWN0RGVzY3JpcHRvclwiKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBjaGlsZCBpbiBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4gYW5kIHZlcmlmaWVzIHRoYXQgdGhlcmVcbiAqIGlzIG9ubHkgb25lIGNoaWxkIGluIHRoZSBjb2xsZWN0aW9uLiBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzXG4gKiBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgYSBzaW5nbGUgY2hpbGQgZ2V0cyBwYXNzZWQgd2l0aG91dCBhIHdyYXBwZXIsIGJ1dCB0aGVcbiAqIHB1cnBvc2Ugb2YgdGhpcyBoZWxwZXIgZnVuY3Rpb24gaXMgdG8gYWJzdHJhY3QgYXdheSB0aGUgcGFydGljdWxhciBzdHJ1Y3R1cmVcbiAqIG9mIGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gY2hpbGRyZW4gQ2hpbGQgY29sbGVjdGlvbiBzdHJ1Y3R1cmUuXG4gKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH0gVGhlIGZpcnN0IGFuZCBvbmx5IGBSZWFjdENvbXBvbmVudGAgY29udGFpbmVkIGluIHRoZVxuICogc3RydWN0dXJlLlxuICovXG5mdW5jdGlvbiBvbmx5Q2hpbGQoY2hpbGRyZW4pIHtcbiAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICBSZWFjdERlc2NyaXB0b3IuaXNWYWxpZERlc2NyaXB0b3IoY2hpbGRyZW4pLFxuICAgICdvbmx5Q2hpbGQgbXVzdCBiZSBwYXNzZWQgYSBjaGlsZHJlbiB3aXRoIGV4YWN0bHkgb25lIGNoaWxkLidcbiAgKSA6IGludmFyaWFudChSZWFjdERlc2NyaXB0b3IuaXNWYWxpZERlc2NyaXB0b3IoY2hpbGRyZW4pKSk7XG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvbmx5Q2hpbGQ7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBwZXJmb3JtYW5jZVxuICogQHR5cGVjaGVja3NcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZShcIi4vRXhlY3V0aW9uRW52aXJvbm1lbnRcIik7XG5cbnZhciBwZXJmb3JtYW5jZTtcblxuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICBwZXJmb3JtYW5jZSA9XG4gICAgd2luZG93LnBlcmZvcm1hbmNlIHx8XG4gICAgd2luZG93Lm1zUGVyZm9ybWFuY2UgfHxcbiAgICB3aW5kb3cud2Via2l0UGVyZm9ybWFuY2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGVyZm9ybWFuY2UgfHwge307XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgcGVyZm9ybWFuY2VOb3dcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIHBlcmZvcm1hbmNlID0gcmVxdWlyZShcIi4vcGVyZm9ybWFuY2VcIik7XG5cbi8qKlxuICogRGV0ZWN0IGlmIHdlIGNhbiB1c2UgYHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKWAgYW5kIGdyYWNlZnVsbHkgZmFsbGJhY2sgdG9cbiAqIGBEYXRlLm5vdygpYCBpZiBpdCBkb2Vzbid0IGV4aXN0LiBXZSBuZWVkIHRvIHN1cHBvcnQgRmlyZWZveCA8IDE1IGZvciBub3dcbiAqIGJlY2F1c2Ugb2YgRmFjZWJvb2sncyB0ZXN0aW5nIGluZnJhc3RydWN0dXJlLlxuICovXG5pZiAoIXBlcmZvcm1hbmNlIHx8ICFwZXJmb3JtYW5jZS5ub3cpIHtcbiAgcGVyZm9ybWFuY2UgPSBEYXRlO1xufVxuXG52YXIgcGVyZm9ybWFuY2VOb3cgPSBwZXJmb3JtYW5jZS5ub3cuYmluZChwZXJmb3JtYW5jZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGVyZm9ybWFuY2VOb3c7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgc2V0SW5uZXJIVE1MXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoXCIuL0V4ZWN1dGlvbkVudmlyb25tZW50XCIpO1xuXG4vKipcbiAqIFNldCB0aGUgaW5uZXJIVE1MIHByb3BlcnR5IG9mIGEgbm9kZSwgZW5zdXJpbmcgdGhhdCB3aGl0ZXNwYWNlIGlzIHByZXNlcnZlZFxuICogZXZlbiBpbiBJRTguXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICogQGludGVybmFsXG4gKi9cbnZhciBzZXRJbm5lckhUTUwgPSBmdW5jdGlvbihub2RlLCBodG1sKSB7XG4gIG5vZGUuaW5uZXJIVE1MID0gaHRtbDtcbn07XG5cbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgLy8gSUU4OiBXaGVuIHVwZGF0aW5nIGEganVzdCBjcmVhdGVkIG5vZGUgd2l0aCBpbm5lckhUTUwgb25seSBsZWFkaW5nXG4gIC8vIHdoaXRlc3BhY2UgaXMgcmVtb3ZlZC4gV2hlbiB1cGRhdGluZyBhbiBleGlzdGluZyBub2RlIHdpdGggaW5uZXJIVE1MXG4gIC8vIHdoaXRlc3BhY2UgaW4gcm9vdCBUZXh0Tm9kZXMgaXMgYWxzbyBjb2xsYXBzZWQuXG4gIC8vIEBzZWUgcXVpcmtzbW9kZS5vcmcvYnVncmVwb3J0cy9hcmNoaXZlcy8yMDA0LzExL2lubmVyaHRtbF9hbmRfdC5odG1sXG5cbiAgLy8gRmVhdHVyZSBkZXRlY3Rpb247IG9ubHkgSUU4IGlzIGtub3duIHRvIGJlaGF2ZSBpbXByb3Blcmx5IGxpa2UgdGhpcy5cbiAgdmFyIHRlc3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRlc3RFbGVtZW50LmlubmVySFRNTCA9ICcgJztcbiAgaWYgKHRlc3RFbGVtZW50LmlubmVySFRNTCA9PT0gJycpIHtcbiAgICBzZXRJbm5lckhUTUwgPSBmdW5jdGlvbihub2RlLCBodG1sKSB7XG4gICAgICAvLyBNYWdpYyB0aGVvcnk6IElFOCBzdXBwb3NlZGx5IGRpZmZlcmVudGlhdGVzIGJldHdlZW4gYWRkZWQgYW5kIHVwZGF0ZWRcbiAgICAgIC8vIG5vZGVzIHdoZW4gcHJvY2Vzc2luZyBpbm5lckhUTUwsIGlubmVySFRNTCBvbiB1cGRhdGVkIG5vZGVzIHN1ZmZlcnNcbiAgICAgIC8vIGZyb20gd29yc2Ugd2hpdGVzcGFjZSBiZWhhdmlvci4gUmUtYWRkaW5nIGEgbm9kZSBsaWtlIHRoaXMgdHJpZ2dlcnNcbiAgICAgIC8vIHRoZSBpbml0aWFsIGFuZCBtb3JlIGZhdm9yYWJsZSB3aGl0ZXNwYWNlIGJlaGF2aW9yLlxuICAgICAgLy8gVE9ETzogV2hhdCB0byBkbyBvbiBhIGRldGFjaGVkIG5vZGU/XG4gICAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobm9kZSwgbm9kZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFdlIGFsc28gaW1wbGVtZW50IGEgd29ya2Fyb3VuZCBmb3Igbm9uLXZpc2libGUgdGFncyBkaXNhcHBlYXJpbmcgaW50b1xuICAgICAgLy8gdGhpbiBhaXIgb24gSUU4LCB0aGlzIG9ubHkgaGFwcGVucyBpZiB0aGVyZSBpcyBubyB2aXNpYmxlIHRleHRcbiAgICAgIC8vIGluLWZyb250IG9mIHRoZSBub24tdmlzaWJsZSB0YWdzLiBQaWdneWJhY2sgb24gdGhlIHdoaXRlc3BhY2UgZml4XG4gICAgICAvLyBhbmQgc2ltcGx5IGNoZWNrIGlmIGFueSBub24tdmlzaWJsZSB0YWdzIGFwcGVhciBpbiB0aGUgc291cmNlLlxuICAgICAgaWYgKGh0bWwubWF0Y2goL15bIFxcclxcblxcdFxcZl0vKSB8fFxuICAgICAgICAgIGh0bWxbMF0gPT09ICc8JyAmJiAoXG4gICAgICAgICAgICBodG1sLmluZGV4T2YoJzxub3NjcmlwdCcpICE9PSAtMSB8fFxuICAgICAgICAgICAgaHRtbC5pbmRleE9mKCc8c2NyaXB0JykgIT09IC0xIHx8XG4gICAgICAgICAgICBodG1sLmluZGV4T2YoJzxzdHlsZScpICE9PSAtMSB8fFxuICAgICAgICAgICAgaHRtbC5pbmRleE9mKCc8bWV0YScpICE9PSAtMSB8fFxuICAgICAgICAgICAgaHRtbC5pbmRleE9mKCc8bGluaycpICE9PSAtMSkpIHtcbiAgICAgICAgLy8gUmVjb3ZlciBsZWFkaW5nIHdoaXRlc3BhY2UgYnkgdGVtcG9yYXJpbHkgcHJlcGVuZGluZyBhbnkgY2hhcmFjdGVyLlxuICAgICAgICAvLyBcXHVGRUZGIGhhcyB0aGUgcG90ZW50aWFsIGFkdmFudGFnZSBvZiBiZWluZyB6ZXJvLXdpZHRoL2ludmlzaWJsZS5cbiAgICAgICAgbm9kZS5pbm5lckhUTUwgPSAnXFx1RkVGRicgKyBodG1sO1xuXG4gICAgICAgIC8vIGRlbGV0ZURhdGEgbGVhdmVzIGFuIGVtcHR5IGBUZXh0Tm9kZWAgd2hpY2ggb2Zmc2V0cyB0aGUgaW5kZXggb2YgYWxsXG4gICAgICAgIC8vIGNoaWxkcmVuLiBEZWZpbml0ZWx5IHdhbnQgdG8gYXZvaWQgdGhpcy5cbiAgICAgICAgdmFyIHRleHROb2RlID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICBpZiAodGV4dE5vZGUuZGF0YS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBub2RlLnJlbW92ZUNoaWxkKHRleHROb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0Tm9kZS5kZWxldGVEYXRhKDAsIDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldElubmVySFRNTDtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBzaGFsbG93RXF1YWxcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBQZXJmb3JtcyBlcXVhbGl0eSBieSBpdGVyYXRpbmcgdGhyb3VnaCBrZXlzIG9uIGFuIG9iamVjdCBhbmQgcmV0dXJuaW5nXG4gKiBmYWxzZSB3aGVuIGFueSBrZXkgaGFzIHZhbHVlcyB3aGljaCBhcmUgbm90IHN0cmljdGx5IGVxdWFsIGJldHdlZW5cbiAqIG9iakEgYW5kIG9iakIuIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSB2YWx1ZXMgb2YgYWxsIGtleXMgYXJlIHN0cmljdGx5IGVxdWFsLlxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvYmpBLCBvYmpCKSB7XG4gIGlmIChvYmpBID09PSBvYmpCKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIGtleTtcbiAgLy8gVGVzdCBmb3IgQSdzIGtleXMgZGlmZmVyZW50IGZyb20gQi5cbiAgZm9yIChrZXkgaW4gb2JqQSkge1xuICAgIGlmIChvYmpBLmhhc093blByb3BlcnR5KGtleSkgJiZcbiAgICAgICAgKCFvYmpCLmhhc093blByb3BlcnR5KGtleSkgfHwgb2JqQVtrZXldICE9PSBvYmpCW2tleV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8vIFRlc3QgZm9yIEInYSBrZXlzIG1pc3NpbmcgZnJvbSBBLlxuICBmb3IgKGtleSBpbiBvYmpCKSB7XG4gICAgaWYgKG9iakIuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAhb2JqQS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNoYWxsb3dFcXVhbDtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBHaXZlbiBhIGBwcmV2RGVzY3JpcHRvcmAgYW5kIGBuZXh0RGVzY3JpcHRvcmAsIGRldGVybWluZXMgaWYgdGhlIGV4aXN0aW5nXG4gKiBpbnN0YW5jZSBzaG91bGQgYmUgdXBkYXRlZCBhcyBvcHBvc2VkIHRvIGJlaW5nIGRlc3Ryb3llZCBvciByZXBsYWNlZCBieSBhIG5ld1xuICogaW5zdGFuY2UuIEJvdGggYXJndW1lbnRzIGFyZSBkZXNjcmlwdG9ycy4gVGhpcyBlbnN1cmVzIHRoYXQgdGhpcyBsb2dpYyBjYW5cbiAqIG9wZXJhdGUgb24gc3RhdGVsZXNzIHRyZWVzIHdpdGhvdXQgYW55IGJhY2tpbmcgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBwcmV2RGVzY3JpcHRvclxuICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0RGVzY3JpcHRvclxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXhpc3RpbmcgaW5zdGFuY2Ugc2hvdWxkIGJlIHVwZGF0ZWQuXG4gKiBAcHJvdGVjdGVkXG4gKi9cbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50KHByZXZEZXNjcmlwdG9yLCBuZXh0RGVzY3JpcHRvcikge1xuICBpZiAocHJldkRlc2NyaXB0b3IgJiYgbmV4dERlc2NyaXB0b3IgJiZcbiAgICAgIHByZXZEZXNjcmlwdG9yLnR5cGUgPT09IG5leHREZXNjcmlwdG9yLnR5cGUgJiYgKFxuICAgICAgICAocHJldkRlc2NyaXB0b3IucHJvcHMgJiYgcHJldkRlc2NyaXB0b3IucHJvcHMua2V5KSA9PT1cbiAgICAgICAgKG5leHREZXNjcmlwdG9yLnByb3BzICYmIG5leHREZXNjcmlwdG9yLnByb3BzLmtleSlcbiAgICAgICkgJiYgcHJldkRlc2NyaXB0b3IuX293bmVyID09PSBuZXh0RGVzY3JpcHRvci5fb3duZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQ7XG4iLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSB0b0FycmF5XG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbi8qKlxuICogQ29udmVydCBhcnJheS1saWtlIG9iamVjdHMgdG8gYXJyYXlzLlxuICpcbiAqIFRoaXMgQVBJIGFzc3VtZXMgdGhlIGNhbGxlciBrbm93cyB0aGUgY29udGVudHMgb2YgdGhlIGRhdGEgdHlwZS4gRm9yIGxlc3NcbiAqIHdlbGwgZGVmaW5lZCBpbnB1dHMgdXNlIGNyZWF0ZUFycmF5RnJvbS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbnxmaWxlbGlzdH0gb2JqXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuZnVuY3Rpb24gdG9BcnJheShvYmopIHtcbiAgdmFyIGxlbmd0aCA9IG9iai5sZW5ndGg7XG5cbiAgLy8gU29tZSBicm93c2UgYnVpbHRpbiBvYmplY3RzIGNhbiByZXBvcnQgdHlwZW9mICdmdW5jdGlvbicgKGUuZy4gTm9kZUxpc3QgaW5cbiAgLy8gb2xkIHZlcnNpb25zIG9mIFNhZmFyaSkuXG4gIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgIUFycmF5LmlzQXJyYXkob2JqKSAmJlxuICAgICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyB8fCB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSxcbiAgICAndG9BcnJheTogQXJyYXktbGlrZSBvYmplY3QgZXhwZWN0ZWQnXG4gICkgOiBpbnZhcmlhbnQoIUFycmF5LmlzQXJyYXkob2JqKSAmJlxuICAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykpKTtcblxuICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgIHR5cGVvZiBsZW5ndGggPT09ICdudW1iZXInLFxuICAgICd0b0FycmF5OiBPYmplY3QgbmVlZHMgYSBsZW5ndGggcHJvcGVydHknXG4gICkgOiBpbnZhcmlhbnQodHlwZW9mIGxlbmd0aCA9PT0gJ251bWJlcicpKTtcblxuICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgIGxlbmd0aCA9PT0gMCB8fFxuICAgIChsZW5ndGggLSAxKSBpbiBvYmosXG4gICAgJ3RvQXJyYXk6IE9iamVjdCBzaG91bGQgaGF2ZSBrZXlzIGZvciBpbmRpY2VzJ1xuICApIDogaW52YXJpYW50KGxlbmd0aCA9PT0gMCB8fFxuICAobGVuZ3RoIC0gMSkgaW4gb2JqKSk7XG5cbiAgLy8gT2xkIElFIGRvZXNuJ3QgZ2l2ZSBjb2xsZWN0aW9ucyBhY2Nlc3MgdG8gaGFzT3duUHJvcGVydHkuIEFzc3VtZSBpbnB1dHNcbiAgLy8gd2l0aG91dCBtZXRob2Qgd2lsbCB0aHJvdyBkdXJpbmcgdGhlIHNsaWNlIGNhbGwgYW5kIHNraXAgc3RyYWlnaHQgdG8gdGhlXG4gIC8vIGZhbGxiYWNrLlxuICBpZiAob2JqLmhhc093blByb3BlcnR5KSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvYmopO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIElFIDwgOSBkb2VzIG5vdCBzdXBwb3J0IEFycmF5I3NsaWNlIG9uIGNvbGxlY3Rpb25zIG9iamVjdHNcbiAgICB9XG4gIH1cblxuICAvLyBGYWxsIGJhY2sgdG8gY29weWluZyBrZXkgYnkga2V5LiBUaGlzIGFzc3VtZXMgYWxsIGtleXMgaGF2ZSBhIHZhbHVlLFxuICAvLyBzbyB3aWxsIG5vdCBwcmVzZXJ2ZSBzcGFyc2VseSBwb3B1bGF0ZWQgaW5wdXRzLlxuICB2YXIgcmV0ID0gQXJyYXkobGVuZ3RoKTtcbiAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGxlbmd0aDsgaWkrKykge1xuICAgIHJldFtpaV0gPSBvYmpbaWldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9BcnJheTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSB0cmF2ZXJzZUFsbENoaWxkcmVuXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBSZWFjdEluc3RhbmNlSGFuZGxlcyA9IHJlcXVpcmUoXCIuL1JlYWN0SW5zdGFuY2VIYW5kbGVzXCIpO1xudmFyIFJlYWN0VGV4dENvbXBvbmVudCA9IHJlcXVpcmUoXCIuL1JlYWN0VGV4dENvbXBvbmVudFwiKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcblxudmFyIFNFUEFSQVRPUiA9IFJlYWN0SW5zdGFuY2VIYW5kbGVzLlNFUEFSQVRPUjtcbnZhciBTVUJTRVBBUkFUT1IgPSAnOic7XG5cbi8qKlxuICogVE9ETzogVGVzdCB0aGF0OlxuICogMS4gYG1hcENoaWxkcmVuYCB0cmFuc2Zvcm1zIHN0cmluZ3MgYW5kIG51bWJlcnMgaW50byBgUmVhY3RUZXh0Q29tcG9uZW50YC5cbiAqIDIuIGl0KCdzaG91bGQgZmFpbCB3aGVuIHN1cHBsaWVkIGR1cGxpY2F0ZSBrZXknLCBmdW5jdGlvbigpIHtcbiAqIDMuIFRoYXQgYSBzaW5nbGUgY2hpbGQgYW5kIGFuIGFycmF5IHdpdGggb25lIGl0ZW0gaGF2ZSB0aGUgc2FtZSBrZXkgcGF0dGVybi5cbiAqIH0pO1xuICovXG5cbnZhciB1c2VyUHJvdmlkZWRLZXlFc2NhcGVyTG9va3VwID0ge1xuICAnPSc6ICc9MCcsXG4gICcuJzogJz0xJyxcbiAgJzonOiAnPTInXG59O1xuXG52YXIgdXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXggPSAvWz0uOl0vZztcblxuZnVuY3Rpb24gdXNlclByb3ZpZGVkS2V5RXNjYXBlcihtYXRjaCkge1xuICByZXR1cm4gdXNlclByb3ZpZGVkS2V5RXNjYXBlckxvb2t1cFttYXRjaF07XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSBrZXkgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyBhIGNvbXBvbmVudCB3aXRoaW4gYSBzZXQuXG4gKlxuICogQHBhcmFtIHsqfSBjb21wb25lbnQgQSBjb21wb25lbnQgdGhhdCBjb3VsZCBjb250YWluIGEgbWFudWFsIGtleS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCB0aGF0IGlzIHVzZWQgaWYgYSBtYW51YWwga2V5IGlzIG5vdCBwcm92aWRlZC5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50S2V5KGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgaWYgKGNvbXBvbmVudCAmJiBjb21wb25lbnQucHJvcHMgJiYgY29tcG9uZW50LnByb3BzLmtleSAhPSBudWxsKSB7XG4gICAgLy8gRXhwbGljaXQga2V5XG4gICAgcmV0dXJuIHdyYXBVc2VyUHJvdmlkZWRLZXkoY29tcG9uZW50LnByb3BzLmtleSk7XG4gIH1cbiAgLy8gSW1wbGljaXQga2V5IGRldGVybWluZWQgYnkgdGhlIGluZGV4IGluIHRoZSBzZXRcbiAgcmV0dXJuIGluZGV4LnRvU3RyaW5nKDM2KTtcbn1cblxuLyoqXG4gKiBFc2NhcGUgYSBjb21wb25lbnQga2V5IHNvIHRoYXQgaXQgaXMgc2FmZSB0byB1c2UgaW4gYSByZWFjdGlkLlxuICpcbiAqIEBwYXJhbSB7Kn0ga2V5IENvbXBvbmVudCBrZXkgdG8gYmUgZXNjYXBlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gQW4gZXNjYXBlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZVVzZXJQcm92aWRlZEtleSh0ZXh0KSB7XG4gIHJldHVybiAoJycgKyB0ZXh0KS5yZXBsYWNlKFxuICAgIHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4LFxuICAgIHVzZXJQcm92aWRlZEtleUVzY2FwZXJcbiAgKTtcbn1cblxuLyoqXG4gKiBXcmFwIGEgYGtleWAgdmFsdWUgZXhwbGljaXRseSBwcm92aWRlZCBieSB0aGUgdXNlciB0byBkaXN0aW5ndWlzaCBpdCBmcm9tXG4gKiBpbXBsaWNpdGx5LWdlbmVyYXRlZCBrZXlzIGdlbmVyYXRlZCBieSBhIGNvbXBvbmVudCdzIGluZGV4IGluIGl0cyBwYXJlbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBWYWx1ZSBvZiBhIHVzZXItcHJvdmlkZWQgYGtleWAgYXR0cmlidXRlXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHdyYXBVc2VyUHJvdmlkZWRLZXkoa2V5KSB7XG4gIHJldHVybiAnJCcgKyBlc2NhcGVVc2VyUHJvdmlkZWRLZXkoa2V5KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7IXN0cmluZ30gbmFtZVNvRmFyIE5hbWUgb2YgdGhlIGtleSBwYXRoIHNvIGZhci5cbiAqIEBwYXJhbSB7IW51bWJlcn0gaW5kZXhTb0ZhciBOdW1iZXIgb2YgY2hpbGRyZW4gZW5jb3VudGVyZWQgdW50aWwgdGhpcyBwb2ludC5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2l0aCBlYWNoIGNoaWxkIGZvdW5kLlxuICogQHBhcmFtIHs/Kn0gdHJhdmVyc2VDb250ZXh0IFVzZWQgdG8gcGFzcyBpbmZvcm1hdGlvbiB0aHJvdWdob3V0IHRoZSB0cmF2ZXJzYWxcbiAqIHByb2Nlc3MuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xudmFyIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsID1cbiAgZnVuY3Rpb24oY2hpbGRyZW4sIG5hbWVTb0ZhciwgaW5kZXhTb0ZhciwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICAgIHZhciBzdWJ0cmVlQ291bnQgPSAwOyAgLy8gQ291bnQgb2YgY2hpbGRyZW4gZm91bmQgaW4gdGhlIGN1cnJlbnQgc3VidHJlZS5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgIHZhciBuZXh0TmFtZSA9IChcbiAgICAgICAgICBuYW1lU29GYXIgK1xuICAgICAgICAgIChuYW1lU29GYXIgPyBTVUJTRVBBUkFUT1IgOiBTRVBBUkFUT1IpICtcbiAgICAgICAgICBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGkpXG4gICAgICAgICk7XG4gICAgICAgIHZhciBuZXh0SW5kZXggPSBpbmRleFNvRmFyICsgc3VidHJlZUNvdW50O1xuICAgICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoXG4gICAgICAgICAgY2hpbGQsXG4gICAgICAgICAgbmV4dE5hbWUsXG4gICAgICAgICAgbmV4dEluZGV4LFxuICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgIHRyYXZlcnNlQ29udGV4dFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiBjaGlsZHJlbjtcbiAgICAgIHZhciBpc09ubHlDaGlsZCA9IG5hbWVTb0ZhciA9PT0gJyc7XG4gICAgICAvLyBJZiBpdCdzIHRoZSBvbmx5IGNoaWxkLCB0cmVhdCB0aGUgbmFtZSBhcyBpZiBpdCB3YXMgd3JhcHBlZCBpbiBhbiBhcnJheVxuICAgICAgLy8gc28gdGhhdCBpdCdzIGNvbnNpc3RlbnQgaWYgdGhlIG51bWJlciBvZiBjaGlsZHJlbiBncm93c1xuICAgICAgdmFyIHN0b3JhZ2VOYW1lID1cbiAgICAgICAgaXNPbmx5Q2hpbGQgPyBTRVBBUkFUT1IgKyBnZXRDb21wb25lbnRLZXkoY2hpbGRyZW4sIDApIDogbmFtZVNvRmFyO1xuICAgICAgaWYgKGNoaWxkcmVuID09IG51bGwgfHwgdHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIC8vIEFsbCBvZiB0aGUgYWJvdmUgYXJlIHBlcmNlaXZlZCBhcyBudWxsLlxuICAgICAgICBjYWxsYmFjayh0cmF2ZXJzZUNvbnRleHQsIG51bGwsIHN0b3JhZ2VOYW1lLCBpbmRleFNvRmFyKTtcbiAgICAgICAgc3VidHJlZUNvdW50ID0gMTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGRyZW4udHlwZSAmJiBjaGlsZHJlbi50eXBlLnByb3RvdHlwZSAmJlxuICAgICAgICAgICAgICAgICBjaGlsZHJlbi50eXBlLnByb3RvdHlwZS5tb3VudENvbXBvbmVudEludG9Ob2RlKSB7XG4gICAgICAgIGNhbGxiYWNrKHRyYXZlcnNlQ29udGV4dCwgY2hpbGRyZW4sIHN0b3JhZ2VOYW1lLCBpbmRleFNvRmFyKTtcbiAgICAgICAgc3VidHJlZUNvdW50ID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAgICAgICAhY2hpbGRyZW4gfHwgY2hpbGRyZW4ubm9kZVR5cGUgIT09IDEsXG4gICAgICAgICAgICAndHJhdmVyc2VBbGxDaGlsZHJlbiguLi4pOiBFbmNvdW50ZXJlZCBhbiBpbnZhbGlkIGNoaWxkOyBET00gJyArXG4gICAgICAgICAgICAnZWxlbWVudHMgYXJlIG5vdCB2YWxpZCBjaGlsZHJlbiBvZiBSZWFjdCBjb21wb25lbnRzLidcbiAgICAgICAgICApIDogaW52YXJpYW50KCFjaGlsZHJlbiB8fCBjaGlsZHJlbi5ub2RlVHlwZSAhPT0gMSkpO1xuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBjaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuW2tleV0sXG4gICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgbmFtZVNvRmFyICsgKG5hbWVTb0ZhciA/IFNVQlNFUEFSQVRPUiA6IFNFUEFSQVRPUikgK1xuICAgICAgICAgICAgICAgICAgd3JhcFVzZXJQcm92aWRlZEtleShrZXkpICsgU1VCU0VQQVJBVE9SICtcbiAgICAgICAgICAgICAgICAgIGdldENvbXBvbmVudEtleShjaGlsZHJlbltrZXldLCAwKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgaW5kZXhTb0ZhciArIHN1YnRyZWVDb3VudCxcbiAgICAgICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICB0cmF2ZXJzZUNvbnRleHRcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB2YXIgbm9ybWFsaXplZFRleHQgPSBSZWFjdFRleHRDb21wb25lbnQoY2hpbGRyZW4pO1xuICAgICAgICAgIGNhbGxiYWNrKHRyYXZlcnNlQ29udGV4dCwgbm9ybWFsaXplZFRleHQsIHN0b3JhZ2VOYW1lLCBpbmRleFNvRmFyKTtcbiAgICAgICAgICBzdWJ0cmVlQ291bnQgKz0gMTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHZhciBub3JtYWxpemVkTnVtYmVyID0gUmVhY3RUZXh0Q29tcG9uZW50KCcnICsgY2hpbGRyZW4pO1xuICAgICAgICAgIGNhbGxiYWNrKHRyYXZlcnNlQ29udGV4dCwgbm9ybWFsaXplZE51bWJlciwgc3RvcmFnZU5hbWUsIGluZGV4U29GYXIpO1xuICAgICAgICAgIHN1YnRyZWVDb3VudCArPSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdWJ0cmVlQ291bnQ7XG4gIH07XG5cbi8qKlxuICogVHJhdmVyc2VzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCwgYnV0XG4gKiBtaWdodCBhbHNvIGJlIHNwZWNpZmllZCB0aHJvdWdoIGF0dHJpYnV0ZXM6XG4gKlxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmNoaWxkcmVuLCAuLi4pYFxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmxlZnRQYW5lbENoaWxkcmVuLCAuLi4pYFxuICpcbiAqIFRoZSBgdHJhdmVyc2VDb250ZXh0YCBpcyBhbiBvcHRpb25hbCBhcmd1bWVudCB0aGF0IGlzIHBhc3NlZCB0aHJvdWdoIHRoZVxuICogZW50aXJlIHRyYXZlcnNhbC4gSXQgY2FuIGJlIHVzZWQgdG8gc3RvcmUgYWNjdW11bGF0aW9ucyBvciBhbnl0aGluZyBlbHNlIHRoYXRcbiAqIHRoZSBjYWxsYmFjayBtaWdodCBmaW5kIHJlbGV2YW50LlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgb2JqZWN0LlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIFRvIGludm9rZSB1cG9uIHRyYXZlcnNpbmcgZWFjaCBjaGlsZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBDb250ZXh0IGZvciB0cmF2ZXJzYWwuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCAnJywgMCwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdHJhdmVyc2VBbGxDaGlsZHJlbjtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSB1cGRhdGVcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGNvcHlQcm9wZXJ0aWVzID0gcmVxdWlyZShcIi4vY29weVByb3BlcnRpZXNcIik7XG52YXIga2V5T2YgPSByZXF1aXJlKFwiLi9rZXlPZlwiKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbmZ1bmN0aW9uIHNoYWxsb3dDb3B5KHgpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoeCkpIHtcbiAgICByZXR1cm4geC5jb25jYXQoKTtcbiAgfSBlbHNlIGlmICh4ICYmIHR5cGVvZiB4ID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBjb3B5UHJvcGVydGllcyhuZXcgeC5jb25zdHJ1Y3RvcigpLCB4KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geDtcbiAgfVxufVxuXG52YXIgQ09NTUFORF9QVVNIID0ga2V5T2YoeyRwdXNoOiBudWxsfSk7XG52YXIgQ09NTUFORF9VTlNISUZUID0ga2V5T2YoeyR1bnNoaWZ0OiBudWxsfSk7XG52YXIgQ09NTUFORF9TUExJQ0UgPSBrZXlPZih7JHNwbGljZTogbnVsbH0pO1xudmFyIENPTU1BTkRfU0VUID0ga2V5T2YoeyRzZXQ6IG51bGx9KTtcbnZhciBDT01NQU5EX01FUkdFID0ga2V5T2YoeyRtZXJnZTogbnVsbH0pO1xudmFyIENPTU1BTkRfQVBQTFkgPSBrZXlPZih7JGFwcGx5OiBudWxsfSk7XG5cbnZhciBBTExfQ09NTUFORFNfTElTVCA9IFtcbiAgQ09NTUFORF9QVVNILFxuICBDT01NQU5EX1VOU0hJRlQsXG4gIENPTU1BTkRfU1BMSUNFLFxuICBDT01NQU5EX1NFVCxcbiAgQ09NTUFORF9NRVJHRSxcbiAgQ09NTUFORF9BUFBMWVxuXTtcblxudmFyIEFMTF9DT01NQU5EU19TRVQgPSB7fTtcblxuQUxMX0NPTU1BTkRTX0xJU1QuZm9yRWFjaChmdW5jdGlvbihjb21tYW5kKSB7XG4gIEFMTF9DT01NQU5EU19TRVRbY29tbWFuZF0gPSB0cnVlO1xufSk7XG5cbmZ1bmN0aW9uIGludmFyaWFudEFycmF5Q2FzZSh2YWx1ZSwgc3BlYywgY29tbWFuZCkge1xuICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgIEFycmF5LmlzQXJyYXkodmFsdWUpLFxuICAgICd1cGRhdGUoKTogZXhwZWN0ZWQgdGFyZ2V0IG9mICVzIHRvIGJlIGFuIGFycmF5OyBnb3QgJXMuJyxcbiAgICBjb21tYW5kLFxuICAgIHZhbHVlXG4gICkgOiBpbnZhcmlhbnQoQXJyYXkuaXNBcnJheSh2YWx1ZSkpKTtcbiAgdmFyIHNwZWNWYWx1ZSA9IHNwZWNbY29tbWFuZF07XG4gIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgQXJyYXkuaXNBcnJheShzcGVjVmFsdWUpLFxuICAgICd1cGRhdGUoKTogZXhwZWN0ZWQgc3BlYyBvZiAlcyB0byBiZSBhbiBhcnJheTsgZ290ICVzLiAnICtcbiAgICAnRGlkIHlvdSBmb3JnZXQgdG8gd3JhcCB5b3VyIHBhcmFtZXRlciBpbiBhbiBhcnJheT8nLFxuICAgIGNvbW1hbmQsXG4gICAgc3BlY1ZhbHVlXG4gICkgOiBpbnZhcmlhbnQoQXJyYXkuaXNBcnJheShzcGVjVmFsdWUpKSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZSh2YWx1ZSwgc3BlYykge1xuICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgIHR5cGVvZiBzcGVjID09PSAnb2JqZWN0JyxcbiAgICAndXBkYXRlKCk6IFlvdSBwcm92aWRlZCBhIGtleSBwYXRoIHRvIHVwZGF0ZSgpIHRoYXQgZGlkIG5vdCBjb250YWluIG9uZSAnICtcbiAgICAnb2YgJXMuIERpZCB5b3UgZm9yZ2V0IHRvIGluY2x1ZGUgeyVzOiAuLi59PycsXG4gICAgQUxMX0NPTU1BTkRTX0xJU1Quam9pbignLCAnKSxcbiAgICBDT01NQU5EX1NFVFxuICApIDogaW52YXJpYW50KHR5cGVvZiBzcGVjID09PSAnb2JqZWN0JykpO1xuXG4gIGlmIChzcGVjLmhhc093blByb3BlcnR5KENPTU1BTkRfU0VUKSkge1xuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICBPYmplY3Qua2V5cyhzcGVjKS5sZW5ndGggPT09IDEsXG4gICAgICAnQ2Fubm90IGhhdmUgbW9yZSB0aGFuIG9uZSBrZXkgaW4gYW4gb2JqZWN0IHdpdGggJXMnLFxuICAgICAgQ09NTUFORF9TRVRcbiAgICApIDogaW52YXJpYW50KE9iamVjdC5rZXlzKHNwZWMpLmxlbmd0aCA9PT0gMSkpO1xuXG4gICAgcmV0dXJuIHNwZWNbQ09NTUFORF9TRVRdO1xuICB9XG5cbiAgdmFyIG5leHRWYWx1ZSA9IHNoYWxsb3dDb3B5KHZhbHVlKTtcblxuICBpZiAoc3BlYy5oYXNPd25Qcm9wZXJ0eShDT01NQU5EX01FUkdFKSkge1xuICAgIHZhciBtZXJnZU9iaiA9IHNwZWNbQ09NTUFORF9NRVJHRV07XG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgIG1lcmdlT2JqICYmIHR5cGVvZiBtZXJnZU9iaiA9PT0gJ29iamVjdCcsXG4gICAgICAndXBkYXRlKCk6ICVzIGV4cGVjdHMgYSBzcGVjIG9mIHR5cGUgXFwnb2JqZWN0XFwnOyBnb3QgJXMnLFxuICAgICAgQ09NTUFORF9NRVJHRSxcbiAgICAgIG1lcmdlT2JqXG4gICAgKSA6IGludmFyaWFudChtZXJnZU9iaiAmJiB0eXBlb2YgbWVyZ2VPYmogPT09ICdvYmplY3QnKSk7XG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgIG5leHRWYWx1ZSAmJiB0eXBlb2YgbmV4dFZhbHVlID09PSAnb2JqZWN0JyxcbiAgICAgICd1cGRhdGUoKTogJXMgZXhwZWN0cyBhIHRhcmdldCBvZiB0eXBlIFxcJ29iamVjdFxcJzsgZ290ICVzJyxcbiAgICAgIENPTU1BTkRfTUVSR0UsXG4gICAgICBuZXh0VmFsdWVcbiAgICApIDogaW52YXJpYW50KG5leHRWYWx1ZSAmJiB0eXBlb2YgbmV4dFZhbHVlID09PSAnb2JqZWN0JykpO1xuICAgIGNvcHlQcm9wZXJ0aWVzKG5leHRWYWx1ZSwgc3BlY1tDT01NQU5EX01FUkdFXSk7XG4gIH1cblxuICBpZiAoc3BlYy5oYXNPd25Qcm9wZXJ0eShDT01NQU5EX1BVU0gpKSB7XG4gICAgaW52YXJpYW50QXJyYXlDYXNlKHZhbHVlLCBzcGVjLCBDT01NQU5EX1BVU0gpO1xuICAgIHNwZWNbQ09NTUFORF9QVVNIXS5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIG5leHRWYWx1ZS5wdXNoKGl0ZW0pO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKHNwZWMuaGFzT3duUHJvcGVydHkoQ09NTUFORF9VTlNISUZUKSkge1xuICAgIGludmFyaWFudEFycmF5Q2FzZSh2YWx1ZSwgc3BlYywgQ09NTUFORF9VTlNISUZUKTtcbiAgICBzcGVjW0NPTU1BTkRfVU5TSElGVF0uZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICBuZXh0VmFsdWUudW5zaGlmdChpdGVtKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChzcGVjLmhhc093blByb3BlcnR5KENPTU1BTkRfU1BMSUNFKSkge1xuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICBBcnJheS5pc0FycmF5KHZhbHVlKSxcbiAgICAgICdFeHBlY3RlZCAlcyB0YXJnZXQgdG8gYmUgYW4gYXJyYXk7IGdvdCAlcycsXG4gICAgICBDT01NQU5EX1NQTElDRSxcbiAgICAgIHZhbHVlXG4gICAgKSA6IGludmFyaWFudChBcnJheS5pc0FycmF5KHZhbHVlKSkpO1xuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICBBcnJheS5pc0FycmF5KHNwZWNbQ09NTUFORF9TUExJQ0VdKSxcbiAgICAgICd1cGRhdGUoKTogZXhwZWN0ZWQgc3BlYyBvZiAlcyB0byBiZSBhbiBhcnJheSBvZiBhcnJheXM7IGdvdCAlcy4gJyArXG4gICAgICAnRGlkIHlvdSBmb3JnZXQgdG8gd3JhcCB5b3VyIHBhcmFtZXRlcnMgaW4gYW4gYXJyYXk/JyxcbiAgICAgIENPTU1BTkRfU1BMSUNFLFxuICAgICAgc3BlY1tDT01NQU5EX1NQTElDRV1cbiAgICApIDogaW52YXJpYW50KEFycmF5LmlzQXJyYXkoc3BlY1tDT01NQU5EX1NQTElDRV0pKSk7XG4gICAgc3BlY1tDT01NQU5EX1NQTElDRV0uZm9yRWFjaChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgICBBcnJheS5pc0FycmF5KGFyZ3MpLFxuICAgICAgICAndXBkYXRlKCk6IGV4cGVjdGVkIHNwZWMgb2YgJXMgdG8gYmUgYW4gYXJyYXkgb2YgYXJyYXlzOyBnb3QgJXMuICcgK1xuICAgICAgICAnRGlkIHlvdSBmb3JnZXQgdG8gd3JhcCB5b3VyIHBhcmFtZXRlcnMgaW4gYW4gYXJyYXk/JyxcbiAgICAgICAgQ09NTUFORF9TUExJQ0UsXG4gICAgICAgIHNwZWNbQ09NTUFORF9TUExJQ0VdXG4gICAgICApIDogaW52YXJpYW50KEFycmF5LmlzQXJyYXkoYXJncykpKTtcbiAgICAgIG5leHRWYWx1ZS5zcGxpY2UuYXBwbHkobmV4dFZhbHVlLCBhcmdzKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChzcGVjLmhhc093blByb3BlcnR5KENPTU1BTkRfQVBQTFkpKSB7XG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgIHR5cGVvZiBzcGVjW0NPTU1BTkRfQVBQTFldID09PSAnZnVuY3Rpb24nLFxuICAgICAgJ3VwZGF0ZSgpOiBleHBlY3RlZCBzcGVjIG9mICVzIHRvIGJlIGEgZnVuY3Rpb247IGdvdCAlcy4nLFxuICAgICAgQ09NTUFORF9BUFBMWSxcbiAgICAgIHNwZWNbQ09NTUFORF9BUFBMWV1cbiAgICApIDogaW52YXJpYW50KHR5cGVvZiBzcGVjW0NPTU1BTkRfQVBQTFldID09PSAnZnVuY3Rpb24nKSk7XG4gICAgbmV4dFZhbHVlID0gc3BlY1tDT01NQU5EX0FQUExZXShuZXh0VmFsdWUpO1xuICB9XG5cbiAgZm9yICh2YXIgayBpbiBzcGVjKSB7XG4gICAgaWYgKCEoQUxMX0NPTU1BTkRTX1NFVC5oYXNPd25Qcm9wZXJ0eShrKSAmJiBBTExfQ09NTUFORFNfU0VUW2tdKSkge1xuICAgICAgbmV4dFZhbHVlW2tdID0gdXBkYXRlKHZhbHVlW2tdLCBzcGVjW2tdKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV4dFZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHVwZGF0ZTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgd2FybmluZ1xuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoXCIuL2VtcHR5RnVuY3Rpb25cIik7XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciB3YXJuaW5nID0gZW1wdHlGdW5jdGlvbjtcblxuaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICB3YXJuaW5nID0gZnVuY3Rpb24oY29uZGl0aW9uLCBmb3JtYXQgKSB7dmFyIGFyZ3M9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDIpO1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArXG4gICAgICAgICdtZXNzYWdlIGFyZ3VtZW50J1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGNvbnNvbGUud2FybignV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbigpICB7cmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107fSkpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL1JlYWN0Jyk7XG4iXX0=
