(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"./app/scripts/index.coffee":[function(require,module,exports){
window.React = require('react');

window.Immutable = require('immutable');

window.App = require('./app');

window.TrackSelection = require('./ui/track_selection');

window.Meter = require('./ui/meter');

window.PianoRoll = require('./ui/piano_roll');

window.GridLines = require('./ui/piano_roll/grid_lines');

window.Keys = require('./ui/piano_roll/keys');

window.Notes = require('./ui/piano_roll/notes');

window.PlaybackMarker = require('./ui/piano_roll/playback_marker');

window.Selection = require('./ui/piano_roll/selection');

setTimeout(function() {
  return require('./default_song')(function(songData) {
    var render;
    render = function(data) {
      return React.renderComponent(App({
        song: data.cursor(render)
      }), document.body);
    };
    return render(Immutable.fromJS(songData));
  });
});



},{"./app":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/app.cjsx","./default_song":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/default_song.coffee","./ui/meter":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/meter.cjsx","./ui/piano_roll":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/piano_roll.cjsx","./ui/piano_roll/grid_lines":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/piano_roll/grid_lines.cjsx","./ui/piano_roll/keys":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/piano_roll/keys.cjsx","./ui/piano_roll/notes":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/piano_roll/notes.cjsx","./ui/piano_roll/playback_marker":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/piano_roll/playback_marker.cjsx","./ui/piano_roll/selection":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/piano_roll/selection.cjsx","./ui/track_selection":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/track_selection.cjsx","immutable":"/Users/charlieschwabacher/Code/sinesaw/node_modules/immutable/dist/Immutable.js","react":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/react.js"}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/app.cjsx":[function(require,module,exports){
var AnalogSynthesizer, AnalogSynthesizerControl, BasicSampler, BasicSamplerControl, DrumSampler, DrumSamplerControl, DrumkitSynthesizer, DrumkitSynthesizerControl, LoopSampler, LoopSamplerControl, Modal, Modelable, PianoRoll, PlaybackControl, React, ReactCSSTransitionGroup, Song, Track, TrackSelection, Updatable;

React = require('react/addons');

Updatable = require('./ui/mixins/updatable');

Modelable = require('./ui/mixins/modelable');

Song = require('./models/song');

Track = require('./models/track');

DrumkitSynthesizer = require('./models/drumkit_synthesizer');

AnalogSynthesizer = require('./models/analog_synthesizer');

BasicSampler = require('./models/basic_sampler');

LoopSampler = require('./models/loop_sampler');

DrumSampler = require('./models/drum_sampler');

PlaybackControl = require('./ui/playback_control');

TrackSelection = require('./ui/track_selection');

PianoRoll = require('./ui/piano_roll');

AnalogSynthesizerControl = require('./ui/analog_synthesizer_control');

DrumkitSynthesizerControl = require('./ui/drumkit_synthesizer_control');

BasicSamplerControl = require('./ui/basic_sampler_control');

DrumSamplerControl = require('./ui/drum_sampler_control');

LoopSamplerControl = require('./ui/loop_sampler_control');

Modal = require('./ui/modal');

ReactCSSTransitionGroup = React.addons.CSSTransitionGroup;

module.exports = React.createClass({
  mixins: [Modelable, Updatable],
  getInitialState: function() {
    return {
      selectedTrack: 0,
      modalContent: null
    };
  },
  launchModal: function(modalContent) {
    this.props.song.update(function(song) {
      return song.set('playing', false);
    });
    return this.setState({
      modalContent: modalContent
    });
  },
  dismissModal: function() {
    return this.setState({
      modalContent: null
    });
  },
  render: function() {
    var controlClass, instrument, instrumentControl, modal, sequence, track;
    track = this.props.song.cursor(['tracks', this.state.selectedTrack]);
    if (track) {
      sequence = track.cursor('sequence');
      instrument = track.cursor('instrument');
      controlClass = (function() {
        switch (instrument.get('_type')) {
          case 'BasicSampler':
            return BasicSamplerControl;
          case 'AnalogSynthesizer':
            return AnalogSynthesizerControl;
          case 'DrumkitSynthesizer':
            return DrumkitSynthesizerControl;
          case 'DrumSampler':
            return DrumSamplerControl;
          case 'LoopSampler':
            return LoopSamplerControl;
          default:
            return null;
        }
      })();
      if (controlClass != null) {
        instrumentControl = controlClass({
          "key": track.get('_id'),
          "instrument": instrument,
          "app": this
        });
      }
    }
    if (this.state.modalContent != null) {
      modal = Modal({
        "key": 'm'
      }, this.state.modalContent);
    }
    return React.DOM.div({
      "className": "app"
    }, React.DOM.div({
      "className": "row playback"
    }, PlaybackControl({
      "song": this.props.song
    })), React.DOM.div({
      "className": "row main"
    }, React.DOM.div({
      "className": "column sidebar"
    }, TrackSelection({
      "tracks": this.props.song.cursor('tracks'),
      "selectedTrack": this.state.selectedTrack,
      "selectTrack": this.update('selectedTrack')
    })), React.DOM.div({
      "className": "column main"
    }, React.DOM.div({
      "className": "row sequence"
    }, PianoRoll({
      "song": this.props.song,
      "sequence": sequence
    })), React.DOM.div({
      "className": "row instrument"
    }, instrumentControl))), ReactCSSTransitionGroup({
      "transitionName": "modal"
    }, modal));
  }
});



},{"./models/analog_synthesizer":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/models/analog_synthesizer.coffee","./models/basic_sampler":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/models/basic_sampler.coffee","./models/drum_sampler":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/models/drum_sampler.coffee","./models/drumkit_synthesizer":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/models/drumkit_synthesizer.coffee","./models/loop_sampler":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/models/loop_sampler.coffee","./models/song":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/models/song.coffee","./models/track":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/models/track.coffee","./ui/analog_synthesizer_control":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/analog_synthesizer_control.cjsx","./ui/basic_sampler_control":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/basic_sampler_control.cjsx","./ui/drum_sampler_control":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/drum_sampler_control.cjsx","./ui/drumkit_synthesizer_control":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/drumkit_synthesizer_control.cjsx","./ui/loop_sampler_control":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/loop_sampler_control.cjsx","./ui/mixins/modelable":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/mixins/modelable.coffee","./ui/mixins/updatable":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/mixins/updatable.coffee","./ui/modal":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/modal.cjsx","./ui/piano_roll":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/piano_roll.cjsx","./ui/playback_control":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/playback_control.cjsx","./ui/track_selection":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/track_selection.cjsx","react/addons":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/addons.js"}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/default_song.coffee":[function(require,module,exports){
var async, b2a, bass, callbacks, cuid, data, decoder, fs, hat, kick, loaded, snare;

async = require('async');



b2a = require('base64-arraybuffer');

cuid = require('cuid');

decoder = new webkitAudioContext;

bass = b2a.decode("UklGRixjAQBXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQhjAQD6/wUA+f8EAPv/AgD/////AQD9/wIA/f8DAP3/AgD+/wEA//8AAAEA/P8EAPv/BAD+/wAAAAD/////AgD//wEAAAD+/wMA/f8DAP7/AQD//wAAAgD//wIA/f8DAP7/AwD//wAAAQAAAAEAAQAAAAIA//8CAP//AQD/////AAAAAAAA/v8DAPz/BAD9/wIA/////wAAAAAAAP7/AgD8/wMA/f8BAP//AQD+/wEA/v///wEA/f8BAP3/AQD8/wIA+/8CAPz/AAD+///////9/wIA+f8FAPr/AgD8/wAA/v/+/wEA+/8BAPr/AwD5/wIA+/8AAP//+/8CAPr/AQD5/wIA+f8BAPr//v/7////+v8BAPr//v/8//z//v/5/wIA9v8DAPX/AQD4/wAA+P////r//P/9//n//v/7//v//P/8//z/+//+//r////5//7/+/////v//f/9//z//f////r/AgD5/wEA/P/9/wIA+f8EAPr/AQD9/wAA/P8DAPv/BAD8/wAAAQD8/wYA+f8IAPn/BwD7/wYA/f8EAAEAAQADAP//BgD9/wcA/v8EAAMAAAAHAP//BAACAAMABAADAAMAAgAEAAIABwD//wkA//8IAP//CQD//wgAAgAEAAYAAQAIAAAACAAAAAkAAAAHAAMABgAEAAMABgACAAgAAAAHAAEABgAEAAIACAD//wkAAAAFAAYAAAAGAAIABAACAAMABAABAAYAAAAEAAIABAAAAAYA//8GAP//BwD9/wgA/f8HAP3/BwD+/wYA/v8FAAAAAwABAAEABAABAAEAAgACAAEAAQACAP//BAD//wIAAQABAAAAAwD+/wMAAAABAAEAAAADAP3/BwD6/wUA/v8CAP//AQABAAAAAgD+/wMA/f8FAPz/BAD+/wIA//8CAP3/BAD+/wAAAgD+/wEAAgD9/wQA+/8GAPr/CAD4/wgA+v8FAP3/AwD//wAAAgABAAAAAgAAAAIAAAACAP//AwD//wIA//8DAP3/BQD8/wEAAQD//wIA//8BAAAAAQAAAAAAAQD//wIA/v8DAP7/AgD+/wMA/f8DAP//AQD9/wIAAAAAAAEA/v8AAAEAAAD+/wEAAAD//wIA+/8FAPn/BQD6/wQA/v///wIA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zBa4GJYaUxzzHWgftCDEIZsiMyOPI78j0iPWI9YjziPHI7sjsCOlI5cjiyN/I3MjZiNaI0wjQSM1IyYjHSMLIwgj8iLuItsi0iLGIrgiriKgIpUihiJ/Im0iaSJUIk8iPyI1IigiHSIRIgUi+iHvIeEh2CHIIcAhsSGmIZwhjSGGIXghbyFhIVkhSCFCITQhJiEeIRAhBiH7IO4g5CDZIM0gwCC4IKcgoiCSIIkgfyBuIGogVyBUIEAgPSAsICQgGSAJIAMg9h/oH+Qfzx/QH7kfuB+kH58fkx+GH38fcB9oH1sfUR9GHzofMB8mHxkfDx8GH/ce8h7iHtoezB7GHuke9B/WIIEgAyH5H6shhQqT4SHZIdda16vWU9cT2CfoCP5kDKwUhRiWGowbyRxgHewd/R0rHhUeKh4UHh4eCR4JHvYd9R3gHeEdyh3LHbgdsx2jHZ0dkB2HHXsdcR1nHVsdUR1HHTsdNB0kHSAdEB0KHfsc9hzmHOEc0hzKHL8cthyqHKIclByPHIAceRxuHGMcWRxPHEYcORw1HCIcIhwNHAsc/Rv0G+ob3xvWG8wbwxu2G68bpRuZG5IbhRt8G3MbaBtfG1YbShtBGzgbLBsmGxkbDxsHG/sa9BroGuAa1RrMGsEauBquGqQanBqQGokafhpyGm0aXRpbGkwaQxo8GjAaJhogGhIaCxoBGvcZ8BkcGjAb7BuOGxQcAxuxHEcDUd202fjXA9kM2LbY1Nbt1nPW4taZ1vDWu9b11tnWBdf91iPXGtdB1znXXtde13zXgNeh16PXxtfK1+fX89cM2BjYNdg92F3YZtiD2JTYqtjC2NPY79gD2R3ZONlP2W7Zhtmo2cbZ6NkN2jPaXtqN2sTa/tpK253bCNyG3B/d1d2n3pTflOCw4dXiE+RV5afm/edi6eDqo+x07vXvf/HP8oTzwu1m4ePbetsM2ynb/NrZ2nrak9p/2qTamNq42q/ay9rI2uPa4dr82vraE9sV2yrbNds/21HbV9tq23TbgNuR25fbq9uz28Tbzdvc2+fb99v/2xLcF9wq3DPcQtxN3FvcZ9x03IDcj9yZ3KjcstzC3Mzc2tzo3PLcAt0M3RrdKd0x3UPdSd1f3WTdeN1+3ZHdmt2q3bfdwt3S3dzd7t333QveE94m3jTeQd5W3mLeeN6I3pzert7F3tTe797+3hjf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");

kick = b2a.decode("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");

snare = b2a.decode("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9P9D+v9E+v9y+P+r9/8n9/8o9/+Z9f8W9f9a9f9v9//F+f+z9/+r9v9z9//v9v9++P8M+v8++P/a8/8V8/+89/9K+f8R+v8a+/+e+//Z+v+I+P9r9P+Z8f+w9P/q/P/5/v/d+v/K9/+D9v/T+P/t/P/t/P8L9/938//R9/9x/f9h+v8Q9//V9/9o+/8y/f+h+f8W9/+a9/+o+v/7/v+y/P/f9/8R9P8T9P/i9//q+f+n+P+o+P9r+f8x+//u+f8n9/8j9f8k9f/x+f+4/P/1+v9t9v8q9P+x9/84+/95+/84+v809v8z9P809P/39f9+/f+AAQC9+v/88/898v//9/9A/v+A/P8D9//F9P/G9f/F+P8D/P9C/f/F+v9N9f/R8//O9v+M+P9K+v+M+f/O+P/P+P+R+P9Q+f+Q+f8S+f+P+v/M+/8S+v+U+f9d9/8f9/9b+P9N/P/Q+/8r9f+38v8u9f9Z+v8J/v8N/f8q9/959P8y9v9T/P+C//+S/P9w9/849v/q+P9W/P9W/P+u+P/t+P8m+v9Y/P8o+v+69/+79/8x+f9T/f98AAAW/f9z+f9F9//p+v+U/f/i+/+t+v+/+P9E+P88+f/3+f9z+v/E+P+y+v+O/v/C//9j/P/8+f9O+P+D+f9l/P/1+v+G+f+5+v8C+v99+v8E+v+8+v+9+v+++v8S+f9Q+f+O+f/9+v8v/P+e/f8w/P+f+P/F9f+69v8c+f8z/P9W/v+g/f/W+f/P9f889/9R+v8p/f/f/f9m/f9j+f+89//69/+T+v+k/f9o/f//+/8e+v+X+v89/P9q/f9d+v8V9//a9v+b+v8k+v81+f+u+f/r+f84+f9K+P92+f9V+/+R+/+0+f8C+f+2+f9R+P/t9v939v9++f/7/P+E/P8z+v8L+f8M+f8g+P/49v+Y+P9M/P/q+v9g+P869/+e+P/t+v/H+f9S+f8D+v9T+f/f+P97+v8Y/P99+v+T+f9E+v+V+f/79/+H9//99//p+P+v+P+w+P8C+P8n+f8o+f++9f+/9f+q9v/b+f/z+P/R9/+Y9/9H+P8x+f+++P9L+P8c+v/B+P9/9v8M9v/++P+L+P8Z+P/o+f9c+v/q+f+x+f9Y+P8G+f+u9//O+P/v+f8p+v9k+v/y+f+19/8K9/8q+P9/9//z9/+j+v8T+f+g9v9K9f8U9//E+/9u+v9R9/+L9f+N9//H+/+P+/90+P899v/N9f+W9f/t9P9D9v/O+f8I+v9E+P+B9v8R9v/19v++9v+l9f829f/g9f9T9v/E9v9v9//H9v/J9v869/8c+P+V9v8O9f9n9P/58/9C9/9b+P++9f8Y9f8w9v8R9/8c9f939P9B9P+F9//29/9c9f/N9f/C9/9U9//09P/19P/H9/+m+P+S9/8C+P+V9/+l9f8B9f9O9v/R9//29v+t9f9T9v/p+P/X9/9Y9v/r9f+29f/c9P9M9f8X9f8Y9f/19f+a9v9A9/+d9v/q9P8i9f8k9f9M9P/x9P8i+P+B9/+/9P9k9f+c9f+e9f+u9v8c9/+x9v+z9v+09v+19v+P9/9a9//w9v9d9//K9/+I9v/19v+l+P/M+/9i+/89+P+d9/+B+f+4+f93+P9t9/8P+P9w9/8n+v8U/f+q/P+K+f8W+P9N+P/C+f8u+v9C/P8O/P95/P87+//9+f/J+f+e+v/d+/8S/P+F/f+6/f9+/P9C+/93+/88+v95+/8e/f+9/f+o+v+i+f9B+v8n/v8AAABQ/P/W+P90+f+6/P8j/f+M/f9e/v/s+/96+f9H+f+F+/8v//8AAACQ/f/w+/9Z/P9Z/P+O/P+O/P/D/P8r/f+T/f/1+//C+/9e/P9f/P/4+//J/f+V/f/5+v/G+v9h+/8w/f8x/v/9+/+X+v/++v/M/P9m/P9n+v81+v81/P81/f+d+/8F+/9s+//S+/+g+/8I+/88+/+k+v8L+/+k+/8M+/9A+/9z+/9x/P8G/v/X/P9E+/+t+v9F+/8P/P+j/f9t/v+o/P+y+v/l+v+q/P88/v/d/P+E+v/v+f/l+/8R/f+0+/+1+/9S+//v+v+M+v+4+/9V+//r+/+y/P/C+v/8+f9h+v9h+v+9+/8h/P+W+v9l+v/J+v/p/P8k/P/9+v/++v/1+/+d+v8K+v+f+v+V+/80+/8O+v82+/8r/P/7+/90+v9E+v8U+v+o+v+d+//O+//o+f+H+f8b+v/e+v8Q+/8D/P9P+v+/+f/w+f9E+/+0+v8B+f+i+P/T+P+4+v9Y+v+Y+f/6+f8b+//s+v9s+f/++f//+f9g+v9R+/+x+/9j+v/l+P+2+P+V+v/2+v+X+v/Z+f9q+v+s+f99+f/w+P+S+P+B+f+f+v//+v/H+P9p+P87+P9Y+f8q+f9b+f/q+f9x+P8p9/8W+P9G+P8E+f+s+v9k+f8d+P9N+P+s+P8L+f9q+f8O+f+b+f+G+v+H+v/N+f+g+f9E+f+i+f8v+v/q+v9H+/8D+v/u+P/B+P8f+f+r+f9++f8j+f/d+f/z+v+x+f+39/9C+P8q+f9t+v/4+v/m+f9d+f9e+f9Y+/89/P8r+//a+P9S+P84+f/U+v9C/P8f+v+Y+f8Q+f9c+P/J+f+t+v/L+f8X+f+g+f8p+v+F+v/v+P+z9/8P+P+Y+P9r+//G+//X+f/4+P/5+P+P+v/c+f/d+f+x+f9m+v/A+v9o+v+W+v8x+f8z+f+6+f+7+f8V+v8W+v9E+v/s+f/L+v/u+f90+v91+v8o+/9L+v/0+f+m+v+n+v/3+f99+v/6+f/7+f8o+v/9+f8y+/+v+v8s+v9S+f/8+P9V+f/Z+f/h+v8T/P8I+v+t+P8x+f+1+f+7+v/o+v+9+v8Q+v9o+v/r+v+a+//t+v9B+v/s+f8Y+v/x+v9L/P90+/9z+v8g+/8h+/9K+f/1+P/4+f/5+f/Q+v/R+v99+v/T+v//+v+A+f+s+P8C+v8C/P9X/f+v+/9c+v+z+f+K+f/i+P+L+v9d/P8z/P+L+/84+/+3+/9k+/9o+v/n+v+R+/9r+v/q+v+P/P+Q/P9B+/8Y+/8+/P+I/v9p/P8i+v/0+v8S/f82/v/q/P/4+v/P+v9N+//K+/+h+/9I/P85/v85/v9C/f/4+//Q+//6+//7+/8l/P8l/P+h/P+i/P+t+/+F+/80+/+6+v9p+v8s/P/4/P+n/P86+//A+v8T+/9l+/8V+/9a/P93/f9c/P+S+/9C+/+U+/+j+v+k+v/2+v+Y+/8D/f8s/f/D+/8j+//E+//e/P8W/P/H+/9Q+/95+/+i+/+M+v/z+/8L/f+8/P8e/P8e/P+W/P/4+/+8+v/6+/9K/P+F+/8Q+/+H+/9N/P//+/+K+/+L+/+z+/9R/P8Y+/+j+v99+v/N+v9V/P+6+/+T+/+7+/+8+/9v+//8+v+/+//3/P+D/P8n+/9O+/+d+/8S/P94+/+g+/+h+/+i+/+i+/8w+//k+v9Y+/+N/P8a/P8b/P9p/P9e+//G+v9U+v8U+/9G/P8h/P9/+v/o+f9m+/+N+/+q+v9f+v8e+//T+v/6+v+4+/9u+/+y+v9o+v/a+v9T/P96/P+Z+/+5+v9v+v+c+/8z/P95+/+/+v9V+/+B/P/M/P9Z+/9V+v+h+v+F/P/1/P9l/f9A/f9j/P8X+/+p+v8b/P+w/P+M/P9D/P/V+/9C+v/6+f+P+/9I/f+R/P8A/P9v+/9w+/+6+/+6+/8F+/90+/9z/P+Y/P+Z/P8t/P+b/P/m+/94/P8t/f96/P8y/P8P/P/o/P8x/f9a/P8T/P9//P8z/f+l/P/z+/+J+//1+/+E/P9+/f/x/P/O/P9k/P8e/P/Y+/9m/P+u/P88/f8a/f+w/P9r/P+y/P+z/P/6/P+q/f8e/f+d+/9Y+/9O/P/b/P+u/f9F/f91/P+l+/+m+/8P/P88/v/U/f9X/P+I+/9Z/P+R/f8c/v8r/f/1+/9K+/8p+/+z+//p/P9R/f+E/P/a+//9+/9C/P+q/P+q/P9n/P9G/P8D/P/Q/P9r/P+g+/+h+/9L/P9u/P/o+/9A+/+F+/8u/P/K+//L+/90/P8y/P8z/P9V/P+N+/+w+/9u+/84/P85/P/3+//4+//5+/8z+/+X+//b+/+7+/+b+/+c+/+++/9k/P8j/P8d+/8e+/9h+/9p/P+r/P8p/P8J/P+H+/+p+/8H+/9q+/+s+/9t+/9q+v9r+v8P+/80/P/W/P92/P/W+/92+/8W+/93+v+4+v9a+/9c+//d+v+++v8f+/8h+/+C+v+E+v+l+v9H+v8G/P+G/P/I+//J+/8s+/8O+/9u+/+P+/+T+v+R+/8v/P/y+/9W+/8Y+/9Y+/86+/+4+/+U/P/a+//C+v/E+v9h+/9D+//I+v8H+/9m+/+G+/+m+//u+v+x+v9W+v93+v87+v88+v/2+v/3+v9V+/90+/+++v/A+v/++v/z+/9Q/P8h+/+K+v/n+v9h+/9j+/9G+//s+v91+v+z+v8P+/8Q+//z+v/1+v9Q+//3+v81+/9U+//8+v8s+v/y+f9r+v/k+v+X+/8/+/+3+/+l/P/X+/8K+/9k+/+9+/+E+//6+/8Z/P/f+//h+/86/P+S/P+T/P8g/P+P+/8F/P8p/f+e/f+e/f+f/f+D/f8Q/f8R/f/1/P8S/f+g/P9q/f/B/f+I/f+J/f+L/v9v/v/+/f83/v/G/f/G/f8c/v9y/v/l/P88/P/n/P8d//8cAACR/v+w/f/p/f+u/v+T/v8j/v/P/f/Q/f/t/f9B/v8m/v/v/f9I/f/U/f+s///q/v9F/v+7/f9p/f+h/f8Q/v8I//8k//9k/v/3/f8u/v/4/f/C/f+M/f+C/v8m//+D/v8y/v8y/v/9/f+R/f93/f///f9D///K//8o//+i/v/n/f8C/v8D/v9v/v+K/v/A/v8Q///1/v88/v+4/f+D/f+E/f/v/f8K/v90/v/e/v/4/v/y/f+K/f/Z/f/g/v+R/v/1/f/c/f8r/v8R/v/E/f+r/f/F/f+V/v9i/v9J/v/8/f+V/f9j/f/K/f/+/f+Z/v+Z/v+A/v/n/f+c/f8E/f+3/f+c/v9q/v+g/f8i/f9V/f+7/f9T/v/W/f8n/f/D/P+//f+h/v9W/v92/f93/f+q/f8n/v9Z/v/e/f97/f+V/f/5/f/h/f/6/f/7/f9o/f+a/f+b/f/l/f/N/f8X/v/P/f8l/f8+/f9w/f+J/f+K/f+L/f9z/f9E/f+N/f++/f8v/f+g/P+5/P+R/f85/v/b/f/b/f99/f9O/f/Y/P/a/P/H/f8n/v9T/f/e/P+E/f/L/f9u/f9A/f8q/f9C/f+h/f+5/f///f8Y/f91/f92/f9g/f94/f+Q/f/Z/P/a/P98/f8h/f8L/f86/f9p/f88/f/5/P8+/f+a/f9t/f9B/f9Z/f+d/f9x/f9y/f/N/f/k/f9V/v/m/f+u/P8I/f8J/f83/f8i/f+H/P+J/P+K/P8m/f/Y/f8F/v+B/f9A/f9t/f9C/f+F/f9a/f/u/P8b/f8y/f8H/f+L/f/i/f/1/P+2/P/4/P9P/f9Q/f98/f89/f/9/P8U/f8q/f/s/P/C/P9t/f9u/f/w/P/y/P/z/P8e/f/1/P8L/f9h/f+L/f9O/f/h/f/N/f97/f+l/f+R/f8B/f/u/P8t/f9X/f+C/f+s/f9v/f+u/f+v/f8h/f8i/f90/f/H/f/c/f+M/f8o/f8V/f9S/f98/f+l/f9q/f8v/f/Q/f/R/f9u/f9v/f+s/f9x/f83/f+H/f+w/v+J/v/Z/f9Q/f9R/f+0/f/J/f+P/f8I/f9+/f+5/f/0/f/1/f+8/f+D/f+F/f+Z/f9z/f/U/f/7/f/D/f/X/f/Y/f+g/f8T/v9f/v9g/v+R/f9t/f+m/f8F/v8G/v+p/f/1/f/j/f/S/f8K/v/m/f/6/f8y/v8z/v/8/f/r/f/a/f+R/f+3/f/K/f+V/f/M/f8E/v9N/v8Y/v8Y/v/1/f/S/f9j/v+r/v8v/v9B/v/p/f+j/f9v/f8Q/v97/v+f/v/3/v9a/v+I/f9U/f/z/f/F/v8M///p/v9O/v9x/v8+/v+m/v9i/v/8/f+n/f+o/f8Q/v+Z/v+8/v9X/v9o/v96/v83/v8W/v8H/v8Y/v/F/f9M/v8m//8n///l/v+S/v8f/v9B/v8h/v+F/v+3/v9V/v8U/v82/v9H/v84/v85/v85/v/q/f/r/f8c/v+e/v9e/v8f/v8g/v/g/v/x/v9i/v9z/v90/v/T/v92/v9n/v+H/v/G/v+Y/v8l//8W//+q/v9O/v9t/v/L/v8Y///r/v/N/v++/v9y/v82/v90/v/u/v/v/v87///D/v9a/v9b/v9r/v/z/v8R//+p/v+M/v+r/v9i/v9j/v9j/v9k/v9l/v8s/v8t/v9L/v9M/v9q/v95/v/C/v/D/v+1/v+o/v/i/v8q///G/v9k/v+B/v9m/v+f/v+8/v+F/v+9/v+U/v/N/v+k/v9f/v9T/v9h/v9+/v+o/v+A/v+c/v/G/v/i/v/V/v+f/v+7/v9r/v8p/v8q/v97/v8C///b/v+M/v+0/v/P/v9a/v8z/v92/v+e/v+f/v+t/v/I/v+8/v9i/v+K/v+X/v+y/v/A/v+n/v91/v92/v93/v9F/v9s/v+s/v+6/v98/v8//v+j/v8g//++/v9Q/v+C/v/A/v/B/v/z/v/n/v+f/v+g/v99/v9+/v+j/v+M/v9p/v+O/v+z/v8S//83//8I///O/v+3/v+4/v+i/v/R/v/p/v/T/v+x/v++/v/4/v8b//8n///v/v/k/v/a/v/8/v9M//82//8V///0/v/q/v/2/v8j//8u///M/v/u/v8F//8b//8R//8H//8S//8e///+/v/U/v/r/v8r//8M///t/v8D//9D//9D//8a//8R//8m//8c//8y//8U///2/v/s/v8q//9T//8h///6/v8F///y/v/p/v/g/v8c//8J///2/v/t/v8C//8M///6/v/6/v8i//8G///9/v8R///s/v/2/v8B///4/v/T/v8D//8g//8O//8r//8Q///1/v/b/v8J///d/v/w/v8e//8W///z/v8G///+/v8i//8s//81//8l//8U//8M//8E///9/v8P///2/v/v/v/W/v/P/v+//v/z/v8N///s/v/2/v/F/v/w/v8S//8b//8L///0/v8d//8e//8v//8w//8R//8S///c/v/1/v8N//8t///w/v/i/v/j/v8D//8y///2/v/Z/v/a/v8I///7/v8D///9/v/+/v8r//8l//8X//8f//8S//8F///4/v/y/v8B//8Q//8D///+/v///v8q//8B///8/v8f//8S///y/v/6/v8q//8Q///3/v8M//8H///h/v/p/v8E//8l//8z//8I//8P///4/v8F///0/v8C//8o//82//8G//8B//8n//80//8d//8N///8/v8t//9L//8S///8/v8P//8h//8o//8p//8D//8Q//8i//85//9A//88//9z//8+//9V//9W//88//9I//9Z//9f//9b//9h//+B//98//9a//9W//9c//9i//9o//9W//9X//9i//9n//93//9X//9T//91//+E//+E//+B//99//+Z//+n//+N//+F//+G//+2//+u//+F//+G//+g//+l//+d//+e//+f//+X//+Y//+1//+9//+j//+Q//+k//+w//+m//+9///T///M//+0//+4//+x//+5//+l//+0///F///D///D///l///f///L///W///G///D///X///q///q///P///B///N///9///6///M//+8///N///0//8AAADv///d///T///R///U///X///c///k///u///x///q///j///d///d///p///0///w///o///c///S///S///d///m///m///6///4///i///X///j///i///k///o///q///x///x///o///f///o///l///p///w///w///q///o///m///n///l///u///2///z///s///q///r///s///p///n///q///w//8AAAD////x///u///v///0///z///x///2///6///5///2///3///5///5///6///6///6///6///8///9///9///+//////////8AAAAAAABTQVVSAAIAADEsIDAsIDYsIDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA");

hat = b2a.decode("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nwDtsAC/nwBriQCMggCFdgCmbwCFdgDOdAA3bACMggABkgC5kwC5kwDajADajABriQDajABDhABriQDUgABriQBKkABkfQCzhwDajACYmgBKkAB3oQCDuQBDhAAWcwDOdABkfQCzhwAiiwAcfwCMggA9eADBXAABkgCSjgAQZwCmbwAolwBctAAvowCepgCSjgAxYACgYwDUgACYmgA1rwDFqwCYmgCzhwC7UAAlSABkfQCYmgDajADUgACSjgBxlQCSjgDOdADUgABKkAD7hQA9eACFdgDUgABDhABQnAD5yAC/nwBYZQADTwArVACtewAolwBQnACzhwBkfQDtsAC/nwA9eAC7UADOdACYmgB3oQCzhwB/agBecQAiiwB3oQCepgDmpACSjgBDhAAolwCtewBecQCzhwBDhAD1eQAWcwABkgBDhABecQBSWQDOdABDhADOdADUgADgmADFqwCgYwBSWQA9eAD1eQAKWwAKWwAiiwABkgD7hQA3bAAWcwA9eAD7hQBkfQAWcwB5XgCmbwBDhABriQD7hQBYZQDpYQCmbwAKWwAKWwCFdgDpYQAWcwAolwDLtwAolwA9eABriQD7hQA9eABSWQBYZQCMggCYmgDmpAAiiwDOdAD1eQAiiwDajACtewDUgABDhABriQCtewCmbwCaVwDOdADOdABYZQCzhwCMggAWcwCmbwBriQCzhwAQZwBzUgDvbQAolwAvowC5kwDIaAAQZwCgYwAcfwABkgDgmABDhADIaAAQZwAQZwB/agB5XgCmbwAiiwAHngDgmAD7hQA9eAAWcwDOdABYZQCmbwBDhAC/nwCYmgDgmABKkACzhwCmbwBSWQCFdgC5kwBQnACSjgCSjgBKkACtewAQZwAWcwBriQBKkACzhwAWcwBYZQBYZQDIaAA9eACtewBkfQCFdgB/agDIaAA9eAC5kwC5kwBDhADBXACtewC5kwABkgBkfQA3bADvbQBecQBkfQA9eAAWcwDvbQA3bAAxYAA3bABkfQCSjgBecQB/agBriQCSjgAiiwDOdAA3bABSWQDiVQCFdgCtewCtewD7hQAiiwCzhwBkfQDvbQCmbwDOdABecQCzhwBKkAAiiwBkfQBkfQDUgADUgABkfQD1eQAiiwB/agCUSwB5XgD7hQCMggAKWwD1eQBDhAAQZwCaVwBYZQDOdACt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VQAKWwCaVwAKWwDiVQC7UABMTQBzUgBSWQDBXABSWQDiVQArVAAKWwBSWQDiVQCaVwDiVQArVABzUgCaVwArVADiVQAlSABzUgArVAAKWwB5XgAxYAArVAArVADBXADBXABSWQDiVQBMTQADTwCaVwBSWQAKWwBzUgC7UABzUgDiVQBSWQBSWQDiVQDBXACaVwC7UABSWQCaVwDBXAAKWwDiVQDcSQCUSwCUSwBMTQBzUgADTwDcSQC1RAADTwBMTQBzUgDiVQB5XgBSWQCaVwADTwBSWQBSWQBSWQCaVwADTwC7UAADTwBSWQCUSwArVADiVQB5XgAKWwC7UAC1RAD9QgCUSwBMTQAKWwBzUgDiVQADTwADTwBtRgADTwC7UAB5XgB5XgC7UABMTQAlSAC7UAArVAAKWwDiVQCaVwDcSQDcSQD9QgAKWwDiVQArVAADTwDcSQBzUgADTwArVABMTQAKWwDiVQDBXABzUgArVACaVwADTwBzUgADTwBzUgArVAArVAADTwCaVwBSWQAKWwArVADiVQBzUgCUSwAlSADcSQBzUgC7UAC7UABMTQBMTQBtRgDcSQDcSQDcSQC1RABMTQBzUgBzUgDiVQDcSQCUSwADTwADTwADTwADTwBMTQBMTQCUSwDiVQC7UABzUgBzUgADTwADTwBzUgArVABMTQADTwBzUgAKWwBzUgADTwBMTQC7UABMTQC7UAADTwADTwAlSABMTQBSWQBSWQAKWwDcSQC7UAC7UAAKWwArVAADTwBMTQBMTQDcSQBtRgCUSwCOPwBGQQC1RAAlSABtRgADTwC7UABzUgBMTQBMTQBtRgAlSADcSQAlSABzUgDiVQAlSABtRgBMTQCUSwBMTQADTwC7UAAlSAADTwCUSwCaVwDiVQArVAC7UAADTwDcSQAlSAC1RADcSQDcSQD9QgC1RAC1RABtRgCOPwC1RAAlSADcSQCUSwC7UAC7UADcSQC1RACOPwAlSAAlSAArVAC1RABtRgBGQQBGQQCOPwCOPwBtRgCUSwC7UABzUgAlSACOPwCOPwBMTQDiVQBzUgBzUgDcSQC1RABnOgBnOgCvOADWPQD9QgBGQQC1RABMTQC7UABMTQAlSAC1RAAlSACUSwC1RABnOgBnOgBnOgBGQQBGQQBtRgBGQQC1RACvOACvOAD9QgAlSACUSwC1RABtRgBGQQAlSAC1RADWPQAePAC1RAC1RAD9QgAePAC1RAC1RADcSQC7UAADTwC7UABzUgC7UADcSQCUSwBtRgCUSwBMTQCUSwC1RAAePAD9QgAlSABGQQCOPwBGQQBtRgArVABGQQDWPQCOPwBtRgBtRgC7UAArVADcSQDWPQD9QgBtRgBzUgDiVQBtRgDWPQA/NQDWPQCOPwBMTQBMTQBMTQCOPwD9QgDWPQC1RAC7UABMTQDcSQC1RADWPQDWPQCOPwBGQQAlSABMTQCUSwCOPwBGQQD9QgCOPwDWPQC1RABtRgC1RABtRgAlSACUSwDWPQBnOgDWPQAePADWPQAlSABtRgDWPQDWPQBtRgAlSAAlSACUSwDcSQC1RAD9QgAePABGQQBtRgDcSQBzUgDcSQDcSQD9QgC1RACOPwCUSwCUSwBMTQD9QgCOPwCOPwBGQQDcSQBtRgC1RAD9QgC1RAC1RADcSQBtRgBGQQBnOgAlSABtRgC1RABtRgCUSwCOPwC1RABtRgBGQQC1RABGQQBtRgCOPwD9QgCOPwBGQQDWPQBtRgD9QgAePABnOgBnOgDWPQDcSQBzUgAlSAD9QgCOPwC1RABGQQC1RAD9QgC1RACOPwBtRgBGQQDWPQBGQQBtRgCUSwAlSAC1RAAlSABGQQBGQQBtRgBGQQAePAAePAC1RACOPwC1RAD3NgBnOgAePACOPwC1RABGQQD9QgBGQQCOPwD9QgBtRgBtRgBtRgBGQQCUSwD9QgCOPwCOPwBGQQD9QgBnOgBnOgCOPwDWPQC1RAC1RAD9QgCOPwDWPQCOPwDWPQAePABnOgD9QgAePADWPQCOPwD9QgD9QgD9QgAePAAePADWPQDWPQDWPQD9QgC1RADWPQDWPQCOPwDWPQAePAAePABnOgDWPQBnOgDWPQBGQQD9QgDWPQCOPwD9QgCUSwBMTQBGQQBnOgD3NgCvOAA/NQD3NgCIMwDQMQD3NgAePAD3NgCvOABnOgBnOgA/NQBGQQAePADWPQCIMwAePAD3NgCIMwAePAAePAD9QgCOPwAePACIMwCvOADQMQA/NQCIMwAePABnOgDWPQD9QgD9QgD9QgD9QgCOPwDWPQCvOAAYMADQMQA/NQCIMwCpLADQMQAYMACvOAD3NgAePABnOgCvOABnOgD3NgD3NgAePAAePABGQQC1RABGQQBGQQCOPwAePADQMQCIMwBgLgD3NgCIMwBnOgDQMQCvOACvOACvOAD3NgBnOgCvOAAePACvOABnOgDWPQAePADQMQDQMQDWPQC1RADcSQD9QgDcSQBGQQBGQQBGQQBGQQCOPwBGQQDWPQBGQQCvOADWPQD3NgBnOgAePACvOAD3NgCvOAAYMACIMwCvOACIMwBnOgDQMQCvOACvOABGQQBnOgCvOABnOgD9QgBnOgCOPwBGQQAePACvOAA/NQAePAAePAD9QgCOPwD9QgAePACOPwBnOgCOPwCOPwCvOAA/NQDQMQBgLgCBJwDxKgDQMQA/NQAYMACpLADxKgDxKgAYMAA/NQBgLgAYMADxKgBgLgCpLADQMQDxKgAYMAAYMAAYMABgLgBgLgCpLAAYMADQMQDQMQCpLAA5KQDxKgBgLgBgLgCpLAA5KQDxKgCpLACpLADQMQAYMABgLgAYMAD3NgD3NgC1RAD3NgD3NgAYMAD3NgCIMwA/NQAYMADQMQAYMACvOAA/NQD3NgDQMQDQMQDQMQCIMwA/NQBgLgCpLABgLgBgLgDQMQCIMwBgLgCIMwD3NgCvOACpLAA5KQDxKgAYMAA5KQCpLAAYMACIMwAYMACIMwDQMQCIMwA/NQCvOAA/NQBgLgAYMACpLADxKgDQMQA/NQCpLACpLAA5KQAYMAAYMAD3NgAYMACvOAAYMACIMwDKJQBaIgA5KQAYMADxKgDxKgA5KQCBJwCpLACpLAAYMADQMQDQMQDxKgA5KQA5KQBgLgA5KQAYMACpLAA5KQA5KQAYMACpLAD3NgDQMQAYMADQMQD3NgBgLgDxKgBaIgDxKgCpLADxKgCpLAA/NQCIMwCBJwCBJwAzHQBaIgA5KQCpLADKJQCBJwDxKgCpLAAYMABgLgDrHgDKJQCpLACpLACpLAAYMADxKgCpLACBJwCpLABgLgAYMAAYMACIMwAYMAAYMACBJwBgLgCIMwCIMwBgLgCpLADxKgCpLACpLACBJwDxKgDKJQAYMACpLACIMwAYMAD3NgBgLgDxKgASJADxKgAYMACBJwCBJwCBJwBaIgBgLgDxKgCBJwAYMADQMQDxKgA5KQCpLADxKgA5KQDKJQA5KQB7GwASJACBJwBgLgA5KQA5KQCpLADxKgCBJwDQMQDxKgDxKgAYMAA/NQDQMQD3NgAY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AAAEAAAAAABTQVVSAAIAADEsIDAsIDYsIDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA");

loaded = false;

data = null;

callbacks = [];

module.exports = function(cb) {
  if (loaded) {
    return cb(data);
  } else {
    return callbacks.push(cb);
  }
};

async.parallel({
  bass: function(cb) {
    return decoder.decodeAudioData(bass, function(buffer) {
      return cb(null, buffer);
    });
  },
  kick: function(cb) {
    return decoder.decodeAudioData(kick, function(buffer) {
      return cb(null, buffer);
    });
  },
  snare: function(cb) {
    return decoder.decodeAudioData(snare, function(buffer) {
      return cb(null, buffer);
    });
  },
  hat: function(cb) {
    return decoder.decodeAudioData(hat, function(buffer) {
      return cb(null, buffer);
    });
  }
}, function(err, results) {
  var cb, _i, _len, _results;
  data = {
    _id: cuid(),
    bpm: 120,
    playing: false,
    recording: false,
    position: 0,
    tracks: [
      {
        _id: cuid(),
        name: 'Basic Sampler',
        meterLevel: 0,
        sequence: {
          _id: cuid(),
          loopSize: 4,
          notes: {}
        },
        instrument: {
          _id: cuid(),
          _type: 'BasicSampler',
          level: 0.5,
          pan: 0.5,
          polyphony: 1,
          rootKey: 60,
          sampleData: results.bass.getChannelData(0),
          sampleName: 'bass.wav',
          start: 0.3,
          loopActive: 'loop',
          loop: 0.7,
          tune: 0.5,
          volumeEnv: {
            a: 0,
            d: 0.25,
            s: 1,
            r: 0.5
          },
          filterEnv: {
            a: 0,
            d: 0.25,
            s: 1,
            r: 0.5
          },
          filter: {
            type: 'none',
            freq: 0.27,
            res: 0.05,
            env: 0.45
          }
        }
      }, {
        _id: cuid(),
        name: 'Drum Sampler',
        meterLevel: 0,
        sequence: {
          _id: cuid(),
          loopSize: 4,
          notes: {}
        },
        instrument: {
          _id: cuid(),
          _type: 'DrumSampler',
          level: 0.5,
          pan: 0.5,
          drums: [
            {
              name: 'Kick',
              sampleData: results.kick.getChannelData(0),
              sampleName: 'kick.wav',
              transpose: 0,
              level: 1,
              key: 0,
              start: 0,
              volumeEnv: {
                a: 0,
                d: 1,
                s: 1,
                r: 1
              }
            }, {
              name: 'Snare',
              sampleData: results.snare.getChannelData(0),
              sampleName: 'snare.wav',
              transpose: 0,
              level: 0.35,
              key: 1,
              start: 0,
              volumeEnv: {
                a: 0,
                d: 1,
                s: 1,
                r: 1
              }
            }, {
              name: 'High Hat',
              sampleData: results.hat.getChannelData(0),
              sampleName: 'hat.wav',
              transpose: 0,
              level: 0.2,
              key: 2,
              start: 0,
              volumeEnv: {
                a: 0,
                d: 1,
                s: 1,
                r: 1
              }
            }
          ]
        }
      }
    ]
  };
  _results = [];
  for (_i = 0, _len = callbacks.length; _i < _len; _i++) {
    cb = callbacks[_i];
    _results.push(cb(data));
  }
  return _results;
});



},{"async":"/Users/charlieschwabacher/Code/sinesaw/node_modules/async/lib/async.js","base64-arraybuffer":"/Users/charlieschwabacher/Code/sinesaw/node_modules/base64-arraybuffer/lib/base64-arraybuffer.js","cuid":"/Users/charlieschwabacher/Code/sinesaw/node_modules/cuid/dist/browser-cuid.js"}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/dsp/audio_recorder.coffee":[function(require,module,exports){
var AudioRecorder, context, workerScript;

context = require('./global_context');

workerScript = URL.createObjectURL(new Blob([
  '(', (function(window) {
    var buffers, clear, getSampleData, length, record;
    buffers = [];
    length = 0;
    record = function(inputBuffer) {
      buffers.push(inputBuffer);
      return length += inputBuffer.length;
    };
    clear = function() {
      buffers = [];
      return length = 0;
    };
    getSampleData = function() {
      var buffer, i, max, offset, sampleData, v, value, _i, _j, _k, _len, _len1, _len2;
      sampleData = new Float32Array(length);
      offset = 0;
      for (_i = 0, _len = buffers.length; _i < _len; _i++) {
        buffer = buffers[_i];
        sampleData.set(buffer, offset);
        offset += buffer.length;
      }
      max = -Infinity;
      for (i = _j = 0, _len1 = sampleData.length; _j < _len1; i = ++_j) {
        value = sampleData[i];
        v = Math.abs(value);
        if (v > max) {
          max = v;
        }
      }
      for (i = _k = 0, _len2 = sampleData.length; _k < _len2; i = ++_k) {
        value = sampleData[i];
        sampleData[i] = value / max;
      }
      return window.postMessage(sampleData);
    };
    return window.onmessage = function(e) {
      switch (e.data.command) {
        case 'record':
          return record(e.data.buffer);
        case 'clear':
          return clear();
        case 'getSampleData':
          return getSampleData();
      }
    };
  }).toString(), ')(this)'
], {
  type: 'application/javascript'
}));

module.exports = AudioRecorder = (function() {
  function AudioRecorder(input) {
    this.input = input;
    this.recorder = context.createScriptProcessor(4096, 1, 1);
    this.recording = false;
    this.worker = new Worker(workerScript);
    this.recorder.onaudioprocess = (function(_this) {
      return function(e) {
        if (!_this.recording) {
          return;
        }
        return _this.worker.postMessage({
          command: 'record',
          buffer: e.inputBuffer.getChannelData(0)
        });
      };
    })(this);
    this.worker.onmessage = (function(_this) {
      return function(e) {
        if (typeof _this.currentCallback === "function") {
          _this.currentCallback(e.data);
        }
        return _this.currentCallback = null;
      };
    })(this);
    this.input.connect(this.recorder);
    this.recorder.connect(context.destination);
  }

  AudioRecorder.prototype.record = function() {
    this.recording = true;
    return this;
  };

  AudioRecorder.prototype.stop = function() {
    this.recording = false;
    return this;
  };

  AudioRecorder.prototype.clear = function() {
    this.worker.postMessage({
      command: 'clear'
    });
    return this;
  };

  AudioRecorder.prototype.getSampleData = function(callback) {
    this.currentCallback = callback;
    this.worker.postMessage({
      command: 'getSampleData'
    });
    return this;
  };

  return AudioRecorder;

})();



},{"./global_context":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/dsp/global_context.coffee"}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/dsp/envelope.coffee":[function(require,module,exports){
var minEnvValue;

minEnvValue = 0.01;

module.exports = function(env, note, time) {
  var a, d, elapsed, l, r, s;
  elapsed = time - note.time;
  a = Math.max(minEnvValue, env.a);
  d = Math.max(minEnvValue, env.d);
  s = env.s;
  r = Math.max(minEnvValue, env.r);
  l = elapsed > a + d ? l = s : elapsed > a ? l = s + (1 - s) * (a + d - elapsed) / d : elapsed / a;
  if (elapsed > note.len) {
    l = l * (r + note.len - elapsed) / r;
  }
  return Math.max(0, l);
};



},{}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/dsp/global_context.coffee":[function(require,module,exports){
module.exports = new webkitAudioContext;



},{}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/dsp/highpass_filter.coffee":[function(require,module,exports){
var A, bandwidth, beta, dbGain, e, maxFreq, sampleRate, sinh, tau;

sampleRate = 48000;

maxFreq = 12000;

dbGain = 12;

bandwidth = 1;

A = Math.pow(10, dbGain / 40);

e = Math.log(2);

tau = 2 * Math.PI;

beta = Math.sqrt(2 * A);

sinh = function(x) {
  var y;
  y = Math.exp(x);
  return (y - 1 / y) / 2;
};

module.exports = function() {
  var a0, a1, a2, a3, a4, alpha, cs, freq, lastCutoff, omega, sn, x1, x2, y1, y2;
  a0 = a1 = a2 = a3 = a4 = x1 = x2 = y1 = y2 = 0;
  freq = omega = sn = alpha = 0;
  cs = 1;
  lastCutoff = 0;
  return function(sample, cutoff) {
    var aa0, aa1, aa2, b0, b1, b2, oldCutoff, result, s;
    if (cutoff !== lastCutoff) {
      oldCutoff = cutoff;
      freq = cutoff * maxFreq;
      omega = tau * freq / sampleRate;
      sn = Math.sin(omega);
      cs = Math.cos(omega);
      alpha = sn * sinh(e / 2 * bandwidth * omega / sn);
      b0 = (1 + cs) / 2;
      b1 = -(1 + cs);
      b2 = (1 + cs) / 2;
      aa0 = 1 + alpha;
      aa1 = -2 * cs;
      aa2 = 1 - alpha;
      a0 = b0 / aa0;
      a1 = b1 / aa0;
      a2 = b2 / aa0;
      a3 = aa1 / aa0;
      a4 = aa2 / aa0;
    }
    s = Math.max(-1, Math.min(1, sample));
    result = a0 * s + a1 * x1 + a2 * x2 - a3 * y1 - a4 * y2;
    x2 = x1;
    x1 = s;
    y2 = y1;
    y1 = result;
    return result;
  };
};



},{}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/dsp/linear_interpolator.coffee":[function(require,module,exports){
module.exports = function(sampleData, transpose, samplesElapsed, offset, loopActive, loopPoint) {
  var i, i1, i2, l;
  if (offset == null) {
    offset = 0;
  }
  if (loopActive == null) {
    loopActive = false;
  }
  i = samplesElapsed * Math.pow(2, transpose / 12);
  i1 = Math.floor(i);
  if (loopActive) {
    i1 = i1 % (loopPoint - offset);
  }
  i2 = i1 + 1;
  l = i % 1;
  return sampleData[offset + i1] * (1 - l) + sampleData[offset + i2] * l;
};



},{}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/dsp/lowpass_filter.coffee":[function(require,module,exports){
var sampleRate;

sampleRate = 48000;

module.exports = function() {
  var k, oldx, oldy1, oldy2, oldy3, p, r, t1, t2, x, y1, y2, y3, y4;
  y1 = y2 = y3 = y4 = oldx = oldy1 = oldy2 = oldy3 = 0;
  p = k = t1 = t2 = r = x = null;
  return function(sample, cutoff, res) {
    var freq;
    freq = 20 * Math.pow(10, 3 * cutoff);
    freq = freq / sampleRate;
    p = freq * (1.8 - (0.8 * freq));
    k = 2 * Math.sin(freq * Math.PI / 2) - 1;
    t1 = (1 - p) * 1.386249;
    t2 = 12 + t1 * t1;
    r = res * 0.57 * (t2 + 6 * t1) / (t2 - 6 * t1);
    x = sample - r * y4;
    y1 = x * p + oldx * p - k * y1;
    y2 = y1 * p + oldy1 * p - k * y2;
    y3 = y2 * p + oldy2 * p - k * y3;
    y4 = y3 * p + oldy3 * p - k * y4;
    y4 -= (y4 * y4 * y4) / 6;
    oldx = x;
    oldy1 = y1;
    oldy2 = y2;
    oldy3 = y3;
    return y4;
  };
};



},{}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/dsp/oscillators.coffee":[function(require,module,exports){
var tau;

tau = Math.PI * 2;

module.exports = {
  sine: function(time, frequency) {
    return Math.sin(time * tau * frequency);
  },
  square: function(time, frequency) {
    if (((time % (1 / frequency)) * frequency) % 1 > 0.5) {
      return 1;
    } else {
      return -1;
    }
  },
  saw: function(time, frequency) {
    return 1 - 2 * (((time % (1 / frequency)) * frequency) % 1);
  },
  noise: function() {
    return 2 * Math.random() - 1;
  }
};



},{}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/dsp/simple_envelope.coffee":[function(require,module,exports){
module.exports = function(decay, elapsed) {
  if (elapsed > decay) {
    return 0;
  } else {
    return 1 - elapsed / decay;
  }
};



},{}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/dsp/webaudio.coffee":[function(require,module,exports){
var bufferSize;

bufferSize = 4096;

module.exports = function(context, fn) {
  var Context, self;
  if (typeof context === 'function') {
    Context = window.AudioContext || window.webkitAudioContext;
    if (!Context) {
      throw new Error('AudioContext not supported');
    }
    fn = context;
    context = new Context();
  }
  self = context.createScriptProcessor(bufferSize, 1, 1);
  self.fn = fn;
  self.i = self.t = 0;
  window._SAMPLERATE = self.sampleRate = self.rate = context.sampleRate;
  self.duration = Infinity;
  self.onaudioprocess = function(e) {
    var output;
    output = e.outputBuffer.getChannelData(0);
    return self.tick(output);
  };
  self.tick = function(output) {
    var i, _i;
    for (i = _i = 0; 0 <= bufferSize ? _i < bufferSize : _i > bufferSize; i = 0 <= bufferSize ? ++_i : --_i) {
      self.t = self.i / self.rate;
      self.i += 1;
      output[i] = self.fn(self.t, self.i);
    }
    return output;
  };
  self.stop = function() {
    self.disconnect();
    return self.playing = false;
  };
  self.play = function(opts) {
    if (self.playing) {
      return;
    }
    self.connect(self.context.destination);
    self.playing = true;
    return setTimeout((function() {
      return this.node.disconnect();
    }), 100000000000);
  };
  self.reset = function() {
    return self.i = self.t = 0;
  };
  return self;
};



},{}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/models/analog_synthesizer.coffee":[function(require,module,exports){
var AnalogSynthesizer, Instrument, RingBuffer, envelope, highpassFilter, lowpassFilter, oscillators,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Instrument = require('./instrument');

RingBuffer = require('../util/ring_buffer');

lowpassFilter = require('../dsp/lowpass_filter');

highpassFilter = require('../dsp/highpass_filter');

envelope = require('../dsp/envelope');

oscillators = require('../dsp/oscillators');

module.exports = AnalogSynthesizer = (function(_super) {
  __extends(AnalogSynthesizer, _super);

  function AnalogSynthesizer() {
    return AnalogSynthesizer.__super__.constructor.apply(this, arguments);
  }

  AnalogSynthesizer.defaults = {
    _type: 'AnalogSynthesizer',
    level: 0.5,
    pan: 0.5,
    polyphony: 3,
    maxPolyphony: 6,
    volumeEnv: {
      a: 0,
      d: 0.25,
      s: 0,
      r: 0.5
    },
    filterEnv: {
      a: 0,
      d: 0.25,
      s: 0.2,
      r: 0.5
    },
    filter: {
      type: 'LP',
      freq: 0.27,
      res: 0.05,
      env: 0.45
    },
    osc1: {
      waveform: 'saw',
      level: 0.5,
      pitch: 0.5,
      tune: 0.5
    },
    osc2: {
      waveform: 'saw',
      level: 0.5,
      pitch: 0.5,
      tune: 0.5
    }
  };

  return AnalogSynthesizer;

})(Instrument);



},{"../dsp/envelope":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/dsp/envelope.coffee","../dsp/highpass_filter":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/dsp/highpass_filter.coffee","../dsp/lowpass_filter":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/dsp/lowpass_filter.coffee","../dsp/oscillators":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/dsp/oscillators.coffee","../util/ring_buffer":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/util/ring_buffer.coffee","./instrument":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/models/instrument.coffee"}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/models/basic_sampler.coffee":[function(require,module,exports){
var BasicSampler, Instrument, RingBuffer, envelope, highpassFilter, linearInterpolator, lowpassFilter,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Instrument = require('./instrument');

RingBuffer = require('../util/ring_buffer');

linearInterpolator = require('../dsp/linear_interpolator');

lowpassFilter = require('../dsp/lowpass_filter');

highpassFilter = require('../dsp/highpass_filter');

envelope = require('../dsp/envelope');

module.exports = BasicSampler = (function(_super) {
  __extends(BasicSampler, _super);

  function BasicSampler() {
    return BasicSampler.__super__.constructor.apply(this, arguments);
  }

  BasicSampler.defaults = {
    _type: 'BasicSampler',
    level: 0.5,
    pan: 0.5,
    polyphony: 1,
    rootKey: 60,
    sampleData: null,
    sampleName: '',
    start: 0.3,
    loopActive: 'loop',
    loop: 0.7,
    tune: 0.5,
    volumeEnv: {
      a: 0,
      d: 0.25,
      s: 1,
      r: 0.5
    },
    filterEnv: {
      a: 0,
      d: 0.25,
      s: 1,
      r: 0.5
    },
    filter: {
      type: 'none',
      freq: 0.27,
      res: 0.05,
      env: 0.45
    }
  };

  return BasicSampler;

})(Instrument);



},{"../dsp/envelope":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/dsp/envelope.coffee","../dsp/highpass_filter":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/dsp/highpass_filter.coffee","../dsp/linear_interpolator":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/dsp/linear_interpolator.coffee","../dsp/lowpass_filter":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/dsp/lowpass_filter.coffee","../util/ring_buffer":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/util/ring_buffer.coffee","./instrument":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/models/instrument.coffee"}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/models/drum_sampler.coffee":[function(require,module,exports){
var DrumSampler, Instrument, envelope, linearInterpolator,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Instrument = require('./instrument');

envelope = require('../dsp/envelope');

linearInterpolator = require('../dsp/linear_interpolator');

module.exports = DrumSampler = (function(_super) {
  __extends(DrumSampler, _super);

  DrumSampler.defaults = {
    _type: 'DrumSampler',
    level: 0.5,
    pan: 0.5,
    drums: [
      {
        name: 'Drum 1',
        sampleData: null,
        sampleName: '',
        transpose: 0,
        level: 1,
        start: 0,
        key: 0,
        volumeEnv: {
          a: 0,
          d: 1,
          s: 1,
          r: 1
        }
      }
    ]
  };

  DrumSampler.prototype.defaultDrum = function() {
    return {
      name: "Drum " + (this.state.drums.length + 1),
      sampleData: null,
      sampleName: '',
      transpose: 0,
      level: 1,
      start: 0,
      key: (function(_this) {
        return function() {
          var key;
          key = 0;
          while (_this.state.drums.some(function(drum) {
              return drum.key === key;
            })) {
            key += 1;
          }
          return key;
        };
      })(this)(),
      volumeEnv: {
        a: 0,
        d: 1,
        s: 1,
        r: 1
      }
    };
  };

  function DrumSampler() {
    this.tick = __bind(this.tick, this);
    this.out = __bind(this.out, this);
    this.removeDrum = __bind(this.removeDrum, this);
    this.addDrum = __bind(this.addDrum, this);
    DrumSampler.__super__.constructor.apply(this, arguments);
    this.notes = {};
  }

  DrumSampler.prototype.reset = function() {
    return this.notes = {};
  };

  DrumSampler.prototype.createSetterForDrum = function(index) {
    return (function(_this) {
      return function(value) {
        return _this.set({
          drums: _this.state.drums.map(function(drum, i) {
            if (i === index) {
              return value;
            } else {
              return drum;
            }
          })
        });
      };
    })(this);
  };

  DrumSampler.prototype.addDrum = function() {
    var drums;
    drums = this.state.drums.slice(0);
    drums.push(this.defaultDrum());
    return this.set({
      drums: drums
    });
  };

  DrumSampler.prototype.removeDrum = function(index) {
    var drums;
    drums = this.state.drums.slice(0);
    drums.splice(index, 1);
    return this.set({
      drums: drums
    });
  };

  DrumSampler.prototype.out = function(time, i) {
    if (this.state.level === 0) {
      return 0;
    }
    return this.state.level * this.state.drums.reduce((function(_this) {
      return function(memo, drum) {
        var note, offset, sample, samplesElapsed;
        if (drum.sampleData == null) {
          return memo;
        }
        note = _this.notes[drum.key];
        if (note == null) {
          return memo;
        }
        samplesElapsed = i - note.i;
        offset = Math.floor(drum.start * drum.sampleData.length);
        if (samplesElapsed + offset > drum.sampleData.length) {
          return memo;
        }
        sample = linearInterpolator(drum.sampleData, drum.transpose, samplesElapsed, offset);
        return memo + drum.level * envelope(drum.volumeEnv, note, time) * (sample || 0);
      };
    })(this), 0);
  };

  DrumSampler.prototype.tick = function(time, i, beat, bps, notesOn) {
    return notesOn.forEach((function(_this) {
      return function(note) {
        return _this.notes[note.key] = {
          time: time,
          i: i,
          len: note.length / bps
        };
      };
    })(this));
  };

  return DrumSampler;

})(Instrument);



},{"../dsp/envelope":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/dsp/envelope.coffee","../dsp/linear_interpolator":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/dsp/linear_interpolator.coffee","./instrument":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/models/instrument.coffee"}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/models/drumkit_synthesizer.coffee":[function(require,module,exports){
var DrumkitSynthesizer, Instrument, highpassFilter, logSample, oscillators, simpleEnvelope,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Instrument = require('./instrument');

highpassFilter = require('../dsp/highpass_filter');

simpleEnvelope = require('../dsp/simple_envelope');

oscillators = require('../dsp/oscillators');

logSample = require('../util/log_sample');

module.exports = DrumkitSynthesizer = (function(_super) {
  var drumId, freqScale, maxFreq, minFreq;

  __extends(DrumkitSynthesizer, _super);

  minFreq = 60;

  maxFreq = 3000;

  freqScale = maxFreq - minFreq;

  drumId = 0;

  DrumkitSynthesizer.prototype.defaults = {
    level: 0.5,
    pan: 0.5,
    drums: [
      {
        id: drumId += 1,
        key: 0,
        name: 'Kick',
        level: 1,
        hp: 0,
        decay: 0.35,
        noise: 0.001,
        pitch: 0,
        bend: 0.39,
        fm: 1,
        fmDecay: 0.05,
        fmFreq: 0.02
      }, {
        id: drumId += 1,
        key: 1,
        name: 'Snare',
        level: 0.5,
        hp: 0.22,
        decay: 0.1,
        noise: 0.8,
        pitch: 0.1,
        bend: 0,
        fm: 0,
        fmDecay: 0,
        fmFreq: 0
      }, {
        id: drumId += 1,
        key: 2,
        name: 'HH1',
        level: 0.05,
        hp: 1,
        decay: 0.07,
        noise: 0.8,
        pitch: 0.4,
        bend: 0,
        fm: 1,
        fmDecay: 0.4,
        fmFreq: 0
      }, {
        id: drumId += 1,
        key: 3,
        name: 'HH2',
        level: 0.2,
        hp: 0.6,
        decay: 0.22,
        noise: 1,
        pitch: 0.5,
        bend: 0,
        fm: 0,
        fmDecay: 0,
        fmFreq: 0
      }
    ]
  };

  DrumkitSynthesizer.prototype.defaultDrum = function() {
    return {
      id: drumId += 1,
      name: "Drum " + (this.state.drums.length + 1),
      level: 0.5,
      key: (function(_this) {
        return function() {
          var key;
          key = 0;
          while (_this.state.drums.some(function(drum) {
              return drum.key === key;
            })) {
            key += 1;
          }
          return key;
        };
      })(this)(),
      hp: 0,
      decay: 0.5,
      noise: 0.5,
      pitch: 0.5,
      bend: 0,
      fm: 0,
      fmDecay: 0,
      fmFreq: 0
    };
  };

  function DrumkitSynthesizer() {
    this.tick = __bind(this.tick, this);
    this.removeDrum = __bind(this.removeDrum, this);
    this.addDrum = __bind(this.addDrum, this);
    DrumkitSynthesizer.__super__.constructor.apply(this, arguments);
    this.notes = {};
    this.filters = {};
    this.updateFilters();
  }

  DrumkitSynthesizer.prototype.reset = function() {
    return this.notes = {};
  };

  DrumkitSynthesizer.prototype.updateFilters = function() {
    return this.filters = this.state.drums.reduce((function(_this) {
      return function(memo, drum) {
        memo[drum.id] = _this.filters[drum.id] || highpassFilter();
        return memo;
      };
    })(this), {});
  };

  DrumkitSynthesizer.prototype.createSetterForDrum = function(index) {
    return (function(_this) {
      return function(value) {
        return _this.set({
          drums: _this.state.drums.map(function(drum, i) {
            if (i === index) {
              return value;
            } else {
              return drum;
            }
          })
        });
      };
    })(this);
  };

  DrumkitSynthesizer.prototype.addDrum = function() {
    var drums;
    drums = this.state.drums.slice(0);
    drums.push(this.defaultDrum());
    return this.set({
      drums: drums
    });
  };

  DrumkitSynthesizer.prototype.removeDrum = function(index) {
    var drums;
    drums = this.state.drums.slice(0);
    drums.splice(index, 1);
    return this.set({
      drums: drums
    });
  };

  DrumkitSynthesizer.prototype.out = function(time) {
    if (this.state.level === 0) {
      return 0;
    }
    return this.state.level * this.state.drums.reduce((function(_this) {
      return function(memo, drum) {
        var elapsed, env, freq, note, sample, signal;
        note = _this.notes[drum.key];
        if (note == null) {
          return memo;
        }
        elapsed = time - note;
        if (elapsed > drum.decay) {
          return memo;
        }
        env = simpleEnvelope(drum.decay, elapsed);
        freq = minFreq + drum.pitch * freqScale;
        if (drum.bend) {
          freq = (2 - drum.bend + drum.bend * env) / 2 * freq;
        }
        if (drum.fm > 0) {
          signal = oscillators.sine(elapsed, minFreq + drum.fmFreq * freqScale);
          freq += drum.fm * signal * simpleEnvelope(drum.fmDecay + 0.01, elapsed);
        }
        sample = (1 - drum.noise) * oscillators.sine(elapsed, freq) + drum.noise * oscillators.noise();
        if (drum.hp > 0) {
          sample = _this.filters[drum.id](sample, drum.hp);
        }
        return memo + drum.level * env * sample;
      };
    })(this), 0);
  };

  DrumkitSynthesizer.prototype.tick = function(time, i, beat, bps, notesOn) {
    return notesOn.forEach((function(_this) {
      return function(note) {
        if (_this.state.drums[note.key] != null) {
          return _this.notes[note.key] = time;
        }
      };
    })(this));
  };

  return DrumkitSynthesizer;

})(Instrument);



},{"../dsp/highpass_filter":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/dsp/highpass_filter.coffee","../dsp/oscillators":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/dsp/oscillators.coffee","../dsp/simple_envelope":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/dsp/simple_envelope.coffee","../util/log_sample":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/util/log_sample.coffee","./instrument":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/models/instrument.coffee"}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/models/instrument.coffee":[function(require,module,exports){
var Instrument, Model,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Model = require('./model');

module.exports = Instrument = (function(_super) {
  __extends(Instrument, _super);

  function Instrument() {
    return Instrument.__super__.constructor.apply(this, arguments);
  }

  return Instrument;

})(Model);



},{"./model":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/models/model.coffee"}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/models/loop_sampler.coffee":[function(require,module,exports){
var Instrument, LoopSampler, RingBuffer,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Instrument = require('./instrument');

RingBuffer = require('../util/ring_buffer');

module.exports = LoopSampler = (function(_super) {
  __extends(LoopSampler, _super);

  LoopSampler.prototype.maxPolyphony = 6;

  LoopSampler.prototype.defaults = {
    level: 0.5,
    polyphony: 1,
    slices: []
  };

  function LoopSampler() {
    LoopSampler.__super__.constructor.apply(this, arguments);
    this.notes = new RingBuffer(this.maxPolyphony, Array, this.state.polyphony);
  }

  LoopSampler.prototype.setPolyphony = function(polyphony) {
    this.notes.resize(polyphony);
    return this.set({
      polyphony: polyphony
    });
  };

  LoopSampler.prototype.out = function() {
    return 0;
  };

  LoopSampler.prototype.tick = function() {};

  LoopSampler.prototype.reset = function() {};

  return LoopSampler;

})(Instrument);



},{"../util/ring_buffer":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/util/ring_buffer.coffee","./instrument":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/models/instrument.coffee"}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/models/model.coffee":[function(require,module,exports){
var Immutable, Model, cuid;

Immutable = require('immutable');

cuid = require('cuid');

module.exports = Model = (function() {
  function Model() {}

  Model.defaults = {};

  Model.build = function(data) {
    if (data == null) {
      data = {};
    }
    if (data._id == null) {
      data._id = cuid();
    }
    return Immutable.fromJS(data).mergeDeep(Immutable.fromJS(this.defaults));
  };

  return Model;

})();



},{"cuid":"/Users/charlieschwabacher/Code/sinesaw/node_modules/cuid/dist/browser-cuid.js","immutable":"/Users/charlieschwabacher/Code/sinesaw/node_modules/immutable/dist/Immutable.js"}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/models/recording.coffee":[function(require,module,exports){
var AudioRecorder, Model, Recording, Sequence, context,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Model = require('./model');

Sequence = require('./sequence');

AudioRecorder = require('../dsp/audio_recorder');

context = require('../dsp/global_context');

module.exports = Recording = (function(_super) {
  var meterDecay;

  __extends(Recording, _super);

  function Recording() {
    this.clear = __bind(this.clear, this);
    this.play = __bind(this.play, this);
    this.stop = __bind(this.stop, this);
    this.setCropEnd = __bind(this.setCropEnd, this);
    this.setCropStart = __bind(this.setCropStart, this);
    this.record = __bind(this.record, this);
    return Recording.__super__.constructor.apply(this, arguments);
  }

  meterDecay = 0.0005;

  Recording.prototype.defaults = {
    sampleData: null,
    error: null,
    active: false,
    playing: false,
    cropStart: 0,
    cropEnd: 1
  };

  Recording.prototype.record = function() {
    if (this.state.active) {
      return;
    }
    this.clear();
    return navigator.webkitGetUserMedia({
      audio: true
    }, (function(_this) {
      return function(localMediaStream) {
        var input;
        input = context.createMediaStreamSource(localMediaStream);
        _this.recorder = new AudioRecorder(input);
        _this.set({
          active: true
        });
        return _this.recorder.record();
      };
    })(this), (function(_this) {
      return function(errorCode) {
        return _this.set({
          error: 'Unable to access microphone'
        });
      };
    })(this));
  };

  Recording.prototype.setCropStart = function(value) {
    return this.set({
      cropStart: value,
      cropEnd: Math.max(value, this.state.cropStart)
    });
  };

  Recording.prototype.setCropEnd = function(value) {
    return this.set({
      cropEnd: value,
      cropStart: Math.min(value, this.state.cropEnd)
    });
  };

  Recording.prototype.croppedSampleData = function() {
    var length;
    length = this.state.sampleData.length;
    return this.state.sampleData.subarray(Math.floor(this.state.cropStart * length), Math.floor(this.state.cropEnd * length));
  };

  Recording.prototype.stop = function() {
    if (!this.state.active) {
      return;
    }
    if (this.player) {
      this.player.onended = false;
      this.player.stop();
    }
    return this.recorder.stop().getSampleData((function(_this) {
      return function(sampleData) {
        _this.recorder = null;
        return _this.set({
          sampleData: sampleData,
          error: null,
          active: false,
          playing: false
        });
      };
    })(this));
  };

  Recording.prototype.play = function() {
    var audioBuffer, data;
    if (this.player) {
      this.player.onended = null;
      this.player.stop();
      this.player.disconnect(context.destination);
    }
    data = this.croppedSampleData();
    this.player = context.createBufferSource();
    this.player.connect(context.destination);
    audioBuffer = context.createBuffer(1, data.length, context.sampleRate);
    audioBuffer.getChannelData(0).set(data);
    this.player.buffer = audioBuffer;
    this.player.onended = (function(_this) {
      return function() {
        return _this.set({
          playing: false
        });
      };
    })(this);
    this.player.start();
    return this.set({
      playing: true
    });
  };

  Recording.prototype.clear = function() {
    return this.set(this.defaults);
  };

  return Recording;

})(Model);



},{"../dsp/audio_recorder":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/dsp/audio_recorder.coffee","../dsp/global_context":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/dsp/global_context.coffee","./model":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/models/model.coffee","./sequence":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/models/sequence.coffee"}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/models/sequence.coffee":[function(require,module,exports){
var Model, Sequence,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Model = require('./model');

module.exports = Sequence = (function(_super) {
  var noteId;

  __extends(Sequence, _super);

  noteId = 0;

  Sequence.defaults = {
    loopSize: 4,
    notes: {}
  };

  function Sequence() {
    Sequence.__super__.constructor.apply(this, arguments);
    this.lastBeat = 0;
    this.bar = 0;
  }

  Sequence.prototype.clonedNotes = function() {
    var clone, k, v, _ref;
    clone = {};
    _ref = this.state.notes;
    for (k in _ref) {
      v = _ref[k];
      clone[k] = v;
    }
    return clone;
  };

  Sequence.prototype.clonedNote = function(id) {
    var clone, k, v, _ref;
    clone = {};
    _ref = this.state.notes[id];
    for (k in _ref) {
      v = _ref[k];
      clone[k] = v;
    }
    return clone;
  };

  Sequence.prototype.addNote = function(note) {
    var notes;
    noteId += 1;
    note.id = noteId;
    notes = this.clonedNotes();
    notes[noteId] = note;
    return this.set({
      notes: notes
    });
  };

  Sequence.prototype.addNotes = function(additions) {
    var id, note, notes;
    notes = this.clonedNotes();
    for (id in additions) {
      note = additions[id];
      noteId += 1;
      note.id = noteId;
      notes[noteId] = note;
    }
    return this.set({
      notes: notes
    });
  };

  Sequence.prototype.removeNote = function(id) {
    var notes;
    notes = this.clonedNotes();
    delete notes[id];
    return this.set({
      notes: notes
    });
  };

  Sequence.prototype.removeNotes = function(ids) {
    var id, notes, _i, _len;
    notes = this.clonedNotes();
    for (_i = 0, _len = ids.length; _i < _len; _i++) {
      id = ids[_i];
      delete notes[id];
    }
    return this.set({
      notes: notes
    });
  };

  Sequence.prototype.updateNote = function(id, attrs) {
    var k, note, notes, v;
    note = this.clonedNote(id);
    for (k in attrs) {
      v = attrs[k];
      note[k] = v;
    }
    notes = this.clonedNotes();
    notes[id] = note;
    return this.set({
      notes: notes
    });
  };

  Sequence.prototype.updateNotes = function(changes) {
    var attrs, id, k, note, notes, v;
    notes = this.clonedNotes();
    for (id in changes) {
      attrs = changes[id];
      note = this.clonedNote(id);
      for (k in attrs) {
        v = attrs[k];
        note[k] = v;
      }
      notes[id] = note;
    }
    return this.set({
      notes: notes
    });
  };

  Sequence.prototype.notesOn = function(beat) {
    var bar, id, note, notes, _ref;
    notes = [];
    bar = Math.floor(beat / this.state.loopSize);
    beat = beat % this.state.loopSize;
    _ref = this.state.notes;
    for (id in _ref) {
      note = _ref[id];
      if (note.start < beat && (note.start >= this.lastBeat || bar > this.bar)) {
        notes.push(note);
      }
    }
    this.lastBeat = beat;
    this.bar = bar;
    return notes;
  };

  Sequence.prototype.reset = function() {
    this.lastBeat = 0;
    return this.lastBar = 0;
  };

  return Sequence;

})(Model);



},{"./model":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/models/model.coffee"}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/models/song.coffee":[function(require,module,exports){
var Model, Song, context, webaudio,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Model = require('./model');

webaudio = require('../dsp/webaudio');

context = require('../dsp/global_context');

module.exports = Song = (function() {
  var clip, clockRatio;

  clockRatio = 230;

  clip = function(sample) {
    return Math.max(0, Math.min(2, sample + 1)) - 1;
  };

  function Song() {
    this.stop = __bind(this.stop, this);
    this.record = __bind(this.record, this);
    this.pause = __bind(this.pause, this);
    this.play = __bind(this.play, this);
    this.out = __bind(this.out, this);
    this.removeTrack = __bind(this.removeTrack, this);
    this.addTrack = __bind(this.addTrack, this);
    this.audio = webaudio(context, this.out);
  }

  Song.prototype.addTrack = function(track) {
    var tracks;
    tracks = this.state.tracks.slice(0);
    tracks.push(track);
    return this.set({
      tracks: tracks
    });
  };

  Song.prototype.removeTrack = function(index) {
    var tracks;
    tracks = this.state.tracks.slice(0);
    tracks.splice(index, 1);
    return this.set({
      tracks: tracks
    });
  };

  Song.prototype.out = function(time, i) {
    if (i % clockRatio === 0) {
      this.tick(time, i);
    }
    return clip(this.state.tracks.reduce(function(sample, t) {
      return sample + t.out(time, i);
    }, 0));
  };

  Song.prototype.tick = function(time, i) {
    var b, beat, bps, track, _i, _len, _ref, _results;
    bps = this.state.bpm / 60;
    beat = time * bps;
    b = Math.floor(beat * 4) / 4;
    if (b > this.state.position) {
      this.set({
        position: b
      });
    }
    _ref = this.state.tracks;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      track = _ref[_i];
      _results.push(track.tick(time, i, beat, bps));
    }
    return _results;
  };

  Song.prototype.play = function() {
    this.set({
      playing: true
    });
    return this.audio.play();
  };

  Song.prototype.pause = function() {
    this.set({
      playing: false
    });
    return this.audio.stop();
  };

  Song.prototype.record = function() {
    return this.set({
      recording: !this.state.recording
    });
  };

  Song.prototype.stop = function() {
    var track, _i, _len, _ref;
    this.audio.stop();
    this.audio.reset();
    _ref = this.state.tracks;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      track = _ref[_i];
      track.reset();
    }
    return this.set({
      playing: false,
      recording: false,
      position: 0
    });
  };

  Song.prototype.toJSON = function() {
    var result;
    result = {
      bpm: this.state.bpm
    };
    result.tracks = this.state.tracks.map(function(t) {
      return t.toJSON();
    });
    return result;
  };

  return Song;

})();



},{"../dsp/global_context":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/dsp/global_context.coffee","../dsp/webaudio":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/dsp/webaudio.coffee","./model":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/models/model.coffee"}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/models/track.coffee":[function(require,module,exports){
var Model, Sequence, Track, instrumentTypes,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Model = require('./model');

Sequence = require('./sequence');

instrumentTypes = {
  AnalogSynthesizer: require('./analog_synthesizer'),
  BasicSampler: require('./basic_sampler'),
  DrumSampler: require('./drum_sampler'),
  DrumkitSynthesizer: require('./drumkit_synthesizer'),
  LoopSampler: require('./loop_sampler')
};

module.exports = Track = (function(_super) {
  var meterDecay;

  __extends(Track, _super);

  function Track() {
    return Track.__super__.constructor.apply(this, arguments);
  }

  meterDecay = 0.0005;

  Track.defaults = {
    name: 'Track',
    meterLevel: 0,
    sequence: Sequence.build()
  };

  return Track;

})(Model);



},{"./analog_synthesizer":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/models/analog_synthesizer.coffee","./basic_sampler":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/models/basic_sampler.coffee","./drum_sampler":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/models/drum_sampler.coffee","./drumkit_synthesizer":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/models/drumkit_synthesizer.coffee","./loop_sampler":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/models/loop_sampler.coffee","./model":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/models/model.coffee","./sequence":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/models/sequence.coffee"}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/analog_synthesizer_control.cjsx":[function(require,module,exports){
var Envelope, Filter, Modelable, Oscillator, React, Slider;

React = require('react');

Modelable = require('./mixins/modelable');

Slider = require('./slider');

Envelope = require('./envelope');

Filter = require('./filter');

Oscillator = require('./oscillator');

module.exports = React.createClass({
  mixins: [Modelable('instrument')],
  setPolyphony: function(e) {
    return this.props.instrument.setPolyphony(parseInt(e.target.value));
  },
  render: function() {
    var i, options;
    options = (function() {
      var _i, _ref, _results;
      _results = [];
      for (i = _i = 1, _ref = this.props.instrument.maxPolyphony; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        _results.push(React.DOM.option({
          "key": i,
          "value": i
        }, i));
      }
      return _results;
    }).call(this);
    return React.DOM.div({
      "className": "ui analog"
    }, React.DOM.div({
      "className": "column channel"
    }, Slider({
      "label": "Level",
      "value": this.state.level,
      "onChange": this.props.instrument.createSetterFor('level')
    }), React.DOM.div({
      "className": "ui"
    }, React.DOM.select({
      "onChange": this.setPolyphony,
      "value": this.state.polyphony
    }, options), React.DOM.label(null, "Poly"))), React.DOM.div({
      "className": "column"
    }, Envelope({
      "label": "Volume Env",
      "env": this.props.instrument.state.volumeEnv,
      "onChange": this.props.instrument.createSetterFor('volumeEnv')
    })), React.DOM.div({
      "className": "column"
    }, Envelope({
      "label": "Filter Env",
      "env": this.props.instrument.state.filterEnv,
      "onChange": this.props.instrument.createSetterFor('filterEnv')
    })), React.DOM.div({
      "className": "column oscillators"
    }, Filter({
      "label": "Filter",
      "filter": this.props.instrument.state.filter,
      "onChange": this.props.instrument.createSetterFor('filter')
    }), Oscillator({
      "label": "Osc 1",
      "osc": this.props.instrument.state.osc1,
      "onChange": this.props.instrument.createSetterFor('osc1')
    }), Oscillator({
      "label": "Osc 2",
      "osc": this.props.instrument.state.osc2,
      "onChange": this.props.instrument.createSetterFor('osc2')
    })));
  }
});



},{"./envelope":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/envelope.cjsx","./filter":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/filter.cjsx","./mixins/modelable":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/mixins/modelable.coffee","./oscillator":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/oscillator.cjsx","./slider":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/slider.cjsx","react":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/react.js"}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/basic_sampler_control.cjsx":[function(require,module,exports){
var Chooser, Envelope, Filter, Knob, Modelable, React, SampleControl, Slider, keyOptions;

React = require('react/addons');

Modelable = require('./mixins/modelable');

Knob = require('./knob');

Chooser = require('./chooser');

Slider = require('./slider');

SampleControl = require('./sample_control');

Envelope = require('./envelope');

Filter = require('./filter');

keyOptions = require('../util/key_options');

module.exports = React.createClass({
  getInitialState: function() {
    return {
      buffer: null
    };
  },
  mixins: [Modelable('instrument')],
  render: function() {
    var i, instrument, options;
    instrument = this.props.instrument;
    options = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 1; _i <= 6; i = ++_i) {
        _results.push(React.DOM.option({
          "key": i,
          "value": i
        }, i));
      }
      return _results;
    })();
    return React.DOM.div({
      "className": "ui basic-sampler"
    }, React.DOM.div({
      "className": "column channel"
    }, Slider({
      "label": "Level",
      "value": instrument.get('level'),
      "onChange": (function() {})
    }), React.DOM.div({
      "className": "ui"
    }, React.DOM.select({
      "value": instrument.get('polyphony'),
      "onChange": (function() {})
    }, options), React.DOM.label(null, "Poly"))), React.DOM.div({
      "className": "column"
    }, SampleControl({
      "label": "Sample",
      "app": this.props.app,
      "onChange": this.setSample,
      "sampleData": instrument.get('sampleData'),
      "sampleName": instrument.get('sampleName'),
      "sampleStart": instrument.get('start'),
      "onChangeStart": (function() {}),
      "loopActive": instrument.get('loopActive') === 'loop',
      "sampleLoop": instrument.get('loop'),
      "onChangeLoop": (function() {})
    })), React.DOM.div({
      "className": "column envelope"
    }, Envelope({
      "label": "Volume Env",
      "env": instrument.get('volumeEnv').toJS(),
      "onChange": (function() {})
    })), React.DOM.div({
      "className": "column envelope"
    }, Envelope({
      "label": "Filter Env",
      "env": instrument.get('filterEnv').toJS(),
      "onChange": (function() {})
    })), React.DOM.div({
      "className": "column controls"
    }, Filter({
      "label": "Filter",
      "filter": instrument.get('filter').toJS(),
      "onChange": (function() {})
    }), React.DOM.div({
      "className": "row sample"
    }, React.DOM.div({
      "className": "ui"
    }, React.DOM.select({
      "value": instrument.get('rootKey'),
      "onChange": (function() {})
    }, keyOptions()), React.DOM.label(null, "Root")), Knob({
      "label": "Tune",
      "value": instrument.get('tune'),
      "onChange": (function() {})
    })), React.DOM.div({
      "className": "row sample"
    }, Chooser({
      "options": ['loop', 'off'],
      "value": instrument.get('loopActive'),
      "onChange": (function() {})
    }), Knob({
      "label": "Loop",
      "value": instrument.get('loop'),
      "disabled": instrument.get('loopActive') === 'off',
      "onChange": (function() {})
    }), Knob({
      "label": "Start",
      "value": instrument.get('start'),
      "onChange": (function() {})
    }))));
  }
});



},{"../util/key_options":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/util/key_options.coffee","./chooser":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/chooser.cjsx","./envelope":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/envelope.cjsx","./filter":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/filter.cjsx","./knob":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/knob.cjsx","./mixins/modelable":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/mixins/modelable.coffee","./sample_control":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/sample_control.cjsx","./slider":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/slider.cjsx","react/addons":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/addons.js"}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/chooser.cjsx":[function(require,module,exports){
var React;

React = require('react');

module.exports = React.createClass({
  onClickValue: function(e) {
    return this.props.onChange(e.target.dataset.value);
  },
  render: function() {
    var className, i, options, v;
    options = (function() {
      var _i, _len, _ref, _results;
      _ref = this.props.options;
      _results = [];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        v = _ref[i];
        className = 'option';
        if (v === this.props.value) {
          className += ' selected';
        }
        _results.push(React.DOM.div({
          "key": i,
          "className": className,
          "onClick": this.onClickValue,
          "data-value": v
        }, v));
      }
      return _results;
    }).call(this);
    return React.DOM.div({
      "className": "ui chooser"
    }, options);
  }
});



},{"react":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/react.js"}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/drum_sampler_control.cjsx":[function(require,module,exports){
var Drum, Envelope, Knob, ListControl, React, SampleControl, Slider, Sortable, Updatable, keyOptions, transposeOptions;

React = require('react');

Updatable = require('./mixins/updatable');

Sortable = require('./mixins/sortable');

Knob = require('./knob');

Slider = require('./slider');

ListControl = require('./list_control');

SampleControl = require('./sample_control');

Envelope = require('./envelope');

keyOptions = require('../util/key_options');

transposeOptions = require('../util/transpose_options');

Drum = React.createClass({
  mixins: [Sortable, React.addons.Pure],
  setSample: function(sampleName, sampleData) {},
  render: function() {
    var drum;
    drum = this.props.drum;
    if (!drum) {
      return React.DOM.div({
        "className": "drum"
      });
    }
    console.log("HERE");
    console.log(drum);
    console;
    return React.DOM.div({
      "className": "drum"
    }, React.DOM.div({
      "className": "column"
    }, SampleControl({
      "label": "Sample",
      "app": this.props.app,
      "onChange": this.setSample,
      "sampleData": drum.get('sampleData'),
      "sampleName": drum.get('sampleName'),
      "sampleStart": drum.get('start'),
      "onChangeStart": (function() {})
    })), React.DOM.div({
      "className": "column envelope"
    }, Envelope({
      "label": "Volume Env",
      "env": drum.get('volumeEnv').toJS(),
      "onChange": (function() {})
    })), React.DOM.div({
      "className": "column control"
    }, Knob({
      "label": "Level",
      "value": drum.get('level'),
      "onChange": (function() {})
    }), React.DOM.div({
      "className": "ui"
    }, React.DOM.select({
      "value": drum.get('transpose'),
      "onChange": (function() {})
    }, transposeOptions()), React.DOM.label(null, "Transpose")), React.DOM.div({
      "className": "ui"
    }, React.DOM.select({
      "value": drum.get('key'),
      "onChange": (function() {})
    }, keyOptions()), React.DOM.label(null, "Trigger"))));
  }
});

module.exports = React.createClass({
  mixins: [Updatable],
  getInitialState: function() {
    return {
      activeDrum: 0
    };
  },
  onAddDrum: function() {},
  onRemoveDrum: function() {},
  render: function() {
    var activeDrum, instrument;
    instrument = this.props.instrument;
    activeDrum = instrument.cursor(['drums', this.state.activeDrum]);
    return React.DOM.div({
      "className": "ui drum-sampler"
    }, React.DOM.div({
      "className": "column channel"
    }, Slider({
      "label": "Level",
      "value": instrument.get('level'),
      "onChange": (function() {})
    })), ListControl({
      "options": instrument.get('drums'),
      "selectedIndex": this.state.activeDrum,
      "onSelect": this.update('activeDrum'),
      "onAdd": this.onAddDrum,
      "onRemove": this.onRemoveDrum,
      "onSort": (function() {})
    }), Drum({
      "drum": activeDrum,
      "app": this.props.app
    }));
  }
});



},{"../util/key_options":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/util/key_options.coffee","../util/transpose_options":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/util/transpose_options.coffee","./envelope":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/envelope.cjsx","./knob":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/knob.cjsx","./list_control":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/list_control.cjsx","./mixins/sortable":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/mixins/sortable.coffee","./mixins/updatable":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/mixins/updatable.coffee","./sample_control":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/sample_control.cjsx","./slider":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/slider.cjsx","react":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/react.js"}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/drumkit_synthesizer_control.cjsx":[function(require,module,exports){
var Drum, Knob, ListControl, Modelable, React, Slider, Updatable, keyOptions;

React = require('react');

Modelable = require('./mixins/modelable');

Updatable = require('./mixins/updatable');

Knob = require('./knob');

Slider = require('./slider');

ListControl = require('./list_control');

keyOptions = require('../util/key_options');

Drum = React.createClass({
  update: function(key) {
    return (function(_this) {
      return function(value) {
        var k, o, v, _ref;
        o = {};
        _ref = _this.props.drum;
        for (k in _ref) {
          v = _ref[k];
          o[k] = k === key ? value : v;
        }
        return _this.props.onChange(o);
      };
    })(this);
  },
  bind: function(key) {
    var update;
    update = this.update(key);
    return function(e) {
      return update(e.target.value);
    };
  },
  render: function() {
    return React.DOM.div({
      "className": 'drum'
    }, React.DOM.div({
      "className": 'column attrs'
    }, Knob({
      "label": "Level",
      "value": this.props.drum.level,
      "onChange": this.update('level')
    }), Knob({
      "label": "Pitch",
      "value": this.props.drum.pitch,
      "onChange": this.update('pitch')
    }), Knob({
      "label": "FM",
      "value": this.props.drum.fm,
      "onChange": this.update('fm')
    }), Knob({
      "label": "Dcy",
      "value": this.props.drum.decay,
      "onChange": this.update('decay')
    }), Knob({
      "label": "Bend",
      "value": this.props.drum.bend,
      "onChange": this.update('bend')
    }), Knob({
      "label": "MDcy",
      "value": this.props.drum.fmDecay,
      "onChange": this.update('fmDecay')
    }), Knob({
      "label": "Noise",
      "value": this.props.drum.noise,
      "onChange": this.update('noise')
    }), Knob({
      "label": "HP",
      "value": this.props.drum.hp,
      "onChange": this.update('hp')
    }), Knob({
      "label": "MFrq",
      "value": this.props.drum.fmFreq,
      "onChange": this.update('fmFreq')
    })), React.DOM.div({
      "className": "column control"
    }, React.DOM.div({
      "className": "ui"
    }, React.DOM.select({
      "value": this.props.drum.key,
      "onChange": this.bind('key')
    }, keyOptions()), React.DOM.label(null, "Trigger"))));
  }
});

module.exports = React.createClass({
  mixins: [Modelable, Updatable],
  getInitialState: function() {
    return {
      activeDrum: 0
    };
  },
  onAddDrum: function() {
    this.props.instrument.addDrum();
    return this.setState({
      activeDrum: this.props.instrument.state.drums.length - 1
    });
  },
  onRemoveDrum: function() {
    this.props.instrument.removeDrum(this.state.activeDrum);
    return this.setState({
      activeDrum: Math.min(this.state.activeDrum, this.props.instrument.state.drums.length - 1)
    });
  },
  render: function() {
    var activeDrum, updateDrum;
    activeDrum = this.props.instrument.state.drums[this.state.activeDrum];
    updateDrum = this.props.instrument.createSetterForDrum(this.state.activeDrum);
    return React.DOM.div({
      "className": "ui drumkit"
    }, React.DOM.div({
      "className": "column channel"
    }, Slider({
      "label": "Level",
      "value": this.props.instrument.state.level,
      "onChange": this.props.instrument.createSetterFor('level')
    })), ListControl({
      "options": this.props.instrument.state.drums,
      "selectedIndex": this.state.activeDrum,
      "onSelect": this.update('activeDrum'),
      "onAdd": this.onAddDrum,
      "onRemove": this.onRemoveDrum,
      "onSort": this.props.instrument.createSetterFor('drums')
    }), Drum({
      "drum": activeDrum,
      "onChange": updateDrum
    }));
  }
});



},{"../util/key_options":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/util/key_options.coffee","./knob":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/knob.cjsx","./list_control":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/list_control.cjsx","./mixins/modelable":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/mixins/modelable.coffee","./mixins/updatable":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/mixins/updatable.coffee","./slider":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/slider.cjsx","react":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/react.js"}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/envelope.cjsx":[function(require,module,exports){
var Draggable, Knob, React, SizeMeasurable;

React = require('react');

SizeMeasurable = require('./mixins/size_measurable');

Draggable = require('./mixins/draggable');

Knob = require('./knob');

module.exports = React.createClass({
  mixins: [SizeMeasurable, Draggable],
  getInitialState: function() {
    return {
      dragTarget: null
    };
  },
  getDefaultProps: function() {
    return {
      dotRadius: 5,
      margin: 4
    };
  },
  buildLines: function() {
    var className, d, dots, env, h, lines, m, p, p1, p2, p3, p4, p5, w, _i, _len, _ref;
    lines = [];
    dots = [];
    m = this.props.margin + this.props.dotRadius;
    w = this.state.width - 2 * m;
    h = this.state.height - 2 * m;
    env = this.props.env;
    p1 = {
      x: 0,
      y: h
    };
    p2 = {
      x: w / 3 * env.a,
      y: 0
    };
    p3 = {
      x: p2.x + w / 3 * env.d,
      y: h * (1 - env.s)
    };
    p4 = {
      x: w * 2 / 3,
      y: h * (1 - env.s)
    };
    p5 = {
      x: w * (2 + env.r) / 3,
      y: h
    };
    _ref = [p1, p2, p3, p4, p5];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      p = _ref[_i];
      p.x += m;
      p.y += m;
    }
    d = 'M ' + [p1, p2, p3, p4, p5].map(function(p) {
      return "" + p.x + " " + p.y;
    }).join(' L ');
    lines.push(React.DOM.path({
      "key": "p",
      "d": d
    }));
    className = this.state.dragTarget === 'attack' ? 'active' : '';
    dots.push(React.DOM.circle({
      "key": "a",
      "className": className,
      "cx": p2.x,
      "cy": p2.y,
      "r": this.props.dotRadius,
      "onMouseDown": this.onMouseDownAttack
    }));
    className = this.state.dragTarget === 'decay' ? 'active' : '';
    dots.push(React.DOM.circle({
      "key": "d",
      "className": className,
      "cx": p3.x,
      "cy": p3.y,
      "r": this.props.dotRadius,
      "onMouseDown": this.onMouseDownDecay
    }));
    className = this.state.dragTarget === 'release' ? 'active' : '';
    dots.push(React.DOM.circle({
      "key": "r",
      "className": className,
      "cx": p5.x,
      "cy": p5.y,
      "r": this.props.dotRadius,
      "onMouseDown": this.onMouseDownRelease
    }));
    return lines.concat(dots);
  },
  onMouseDownAttack: function(e) {
    this.initialValue = this.props.env.a;
    this.setState({
      dragTarget: 'attack'
    });
    return this.draggableOnMouseDown(e);
  },
  onMouseDownDecay: function(e) {
    this.initialValue = {
      d: this.props.env.d,
      s: this.props.env.s
    };
    this.setState({
      dragTarget: 'decay'
    });
    return this.draggableOnMouseDown(e);
  },
  onMouseDownRelease: function(e) {
    this.initialValue = this.props.env.r;
    this.setState({
      dragTarget: 'release'
    });
    return this.draggableOnMouseDown(e);
  },
  onDrag: function(delta) {
    var a, changes, d, env, h, k, m, r, s, v, w, _ref;
    m = this.props.margin + this.props.dotRadius;
    w = (this.state.width - 2 * m) / 3;
    h = this.state.height - 2 * m;
    if (this.state.dragTarget === 'attack') {
      a = this.initialValue + delta.x / w;
      changes = {
        a: a
      };
    } else if (this.state.dragTarget === 'decay') {
      d = this.initialValue.d + delta.x / w;
      s = this.initialValue.s + delta.y / h;
      changes = {
        d: d,
        s: s
      };
    } else if (this.state.dragTarget === 'release') {
      r = this.initialValue + delta.x / w;
      changes = {
        r: r
      };
    }
    for (k in changes) {
      v = changes[k];
      changes[k] = Math.max(0, Math.min(1, v));
    }
    env = {};
    _ref = this.props.env;
    for (k in _ref) {
      v = _ref[k];
      env[k] = changes[k] != null ? changes[k] : v;
    }
    return this.props.onChange(env);
  },
  onDragEnd: function() {
    this.initialValue = null;
    return this.setState({
      dragTarget: null
    });
  },
  update: function(attr) {
    return (function(_this) {
      return function(value) {
        var env, k, v, _ref;
        env = {};
        _ref = _this.props.env;
        for (k in _ref) {
          v = _ref[k];
          env[k] = k === attr ? value : v;
        }
        return _this.props.onChange(env);
      };
    })(this);
  },
  render: function() {
    var lines;
    if (this.state.width > 0) {
      lines = this.buildLines();
    }
    return React.DOM.div({
      "className": 'ui envelope'
    }, React.DOM.div({
      "className": 'control',
      "ref": 'container'
    }, React.DOM.svg({
      "width": this.state.width,
      "height": this.state.height
    }, lines)), React.DOM.div({
      "className": 'knobs'
    }, React.DOM.div({
      "className": 'group'
    }, Knob({
      "label": 'A',
      "value": this.props.env.a,
      "onChange": this.update('a')
    }), Knob({
      "label": 'D',
      "value": this.props.env.d,
      "onChange": this.update('d')
    })), React.DOM.div({
      "className": 'group'
    }, Knob({
      "label": 'S',
      "value": this.props.env.s,
      "onChange": this.update('s')
    }), Knob({
      "label": 'R',
      "value": this.props.env.r,
      "onChange": this.update('r')
    }))), React.DOM.label(null, this.props.label));
  }
});



},{"./knob":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/knob.cjsx","./mixins/draggable":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/mixins/draggable.coffee","./mixins/size_measurable":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/mixins/size_measurable.coffee","react":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/react.js"}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/filter.cjsx":[function(require,module,exports){
var Chooser, Knob, React;

React = require('react');

Chooser = require('./chooser');

Knob = require('./knob');

module.exports = React.createClass({
  update: function(attr) {
    return (function(_this) {
      return function(value) {
        var filter, k, v, _ref;
        filter = {};
        _ref = _this.props.filter;
        for (k in _ref) {
          v = _ref[k];
          filter[k] = k === attr ? value : v;
        }
        return _this.props.onChange(filter);
      };
    })(this);
  },
  render: function() {
    return React.DOM.div({
      "className": "ui filter"
    }, Chooser({
      "options": ['LP', 'HP', 'none'],
      "value": this.props.filter.type,
      "onChange": this.update('type')
    }), Knob({
      "label": "Freq",
      "value": this.props.filter.freq,
      "onChange": this.update('freq')
    }), Knob({
      "label": "Res",
      "value": this.props.filter.res,
      "onChange": this.update('res')
    }), Knob({
      "label": "Env",
      "value": this.props.filter.env,
      "onChange": this.update('env')
    }), React.DOM.label(null, this.props.label));
  }
});



},{"./chooser":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/chooser.cjsx","./knob":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/knob.cjsx","react":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/react.js"}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/knob.cjsx":[function(require,module,exports){
var Draggable, React;

React = require('react');

Draggable = require('./mixins/draggable');

module.exports = React.createClass({
  range: 100,
  mixins: [Draggable],
  getInitialState: function() {
    return {
      active: false
    };
  },
  getDefaultProps: function() {
    return {
      value: 0.5
    };
  },
  onDragStart: function() {
    this.initalValue = this.props.value;
    return this.setState({
      active: true
    });
  },
  onDrag: function(delta) {
    var downRange, upRange, value;
    if (this.props.disabled) {
      return;
    }
    upRange = Math.min(this.range, this.dragStartPosition.y - window.scrollY);
    downRange = Math.min(this.range, window.innerHeight + window.scrollY - this.dragStartPosition.y);
    if (delta.y < 0) {
      value = Math.max(0, this.initalValue * (downRange + delta.y) / downRange);
    } else {
      value = Math.min(1, this.initalValue + (1 - this.initalValue) * delta.y / upRange);
    }
    return this.props.onChange(value);
  },
  onDragEnd: function() {
    this.initalValue = null;
    return this.setState({
      active: false
    });
  },
  preventDefault: function(e) {
    e.preventDefault();
    return e.stopPropagation();
  },
  render: function() {
    var className, style;
    style = {
      '-webkit-transform': "rotate(" + ((this.props.value - 0.5) * 300) + "deg)"
    };
    className = 'ui knob';
    if (this.state.active) {
      className += ' active';
    }
    if (this.props.disabled) {
      className += ' disabled';
    }
    return React.DOM.div({
      "className": className,
      "draggable": true,
      "onDragStart": this.preventDefault
    }, React.DOM.div({
      "className": "control"
    }, React.DOM.div({
      "className": "handle",
      "style": style,
      "onMouseDown": this.draggableOnMouseDown
    })), React.DOM.label(null, this.props.label));
  }
});



},{"./mixins/draggable":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/mixins/draggable.coffee","react":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/react.js"}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/list_control.cjsx":[function(require,module,exports){
var ListOption, React, Sortable;

React = require('react/addons');

Sortable = require('./mixins/sortable');

ListOption = React.createClass({
  mixins: [Sortable, React.addons.PureRenderMixin],
  render: function() {
    var className;
    className = 'option';
    if (this.props.selected) {
      className += ' selected';
    }
    if (this.isDragging()) {
      className += ' dragging';
    }
    return React.DOM.div({
      "className": className,
      "onClick": this.props.selectOption,
      "draggable": true,
      "onDragStart": this.dragStart,
      "onDragEnd": this.dragEnd,
      "onDragOver": this.dragOver,
      "data-id": this.props.key
    }, this.props.name);
  }
});

module.exports = React.createClass({
  mixins: [React.addons.PureRenderMixin],
  getInitialState: function() {
    return {
      dragging: null
    };
  },
  onRemove: function() {
    return this.props.onRemove(this.props.selectedIndex);
  },
  sort: function(items, dragging) {
    this.props.onSort(items);
    if (dragging != null) {
      this.props.onSelect(dragging);
    }
    return this.setState({
      dragging: dragging
    });
  },
  render: function() {
    var options;
    options = this.props.options.map((function(_this) {
      return function(option, i) {
        return ListOption({
          "key": i,
          "name": option.get('name'),
          "selected": i === _this.props.selectedIndex,
          "selectOption": (function() {
            return _this.props.onSelect(i);
          }),
          "sort": _this.sort,
          "items": _this.props.options,
          "dragging": _this.state.dragging
        });
      };
    })(this)).toArray();
    return React.DOM.div({
      "className": "ui list-control"
    }, React.DOM.div({
      "className": "list"
    }, options), React.DOM.div({
      "className": "controls"
    }, React.DOM.div({
      "className": "icon icon-plus pull-right",
      "onClick": this.props.onAdd
    }), React.DOM.div({
      "className": "icon icon-minus pull-left",
      "onClick": this.onRemove
    })));
  }
});



},{"./mixins/sortable":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/mixins/sortable.coffee","react/addons":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/addons.js"}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/loop_sampler_control.cjsx":[function(require,module,exports){
var Envelope, Knob, Modelable, React, SampleControl, Slider;

React = require('react');

Modelable = require('./mixins/modelable');

Knob = require('./knob');

Slider = require('./slider');

SampleControl = require('./sample_control');

Envelope = require('./envelope');

module.exports = React.createClass({
  mixins: [Modelable('instrument')],
  setPolyphony: function(e) {
    return this.props.instrument.setPolyphony(parseInt(e.target.value));
  },
  render: function() {
    var i, options;
    options = (function() {
      var _i, _ref, _results;
      _results = [];
      for (i = _i = 1, _ref = this.props.instrument.maxPolyphony; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        _results.push(React.DOM.option({
          "key": i,
          "value": i
        }, i));
      }
      return _results;
    }).call(this);
    return React.DOM.div({
      "className": "ui loop-sampler"
    }, React.DOM.div({
      "className": "column channel"
    }, Slider({
      "label": "Level",
      "value": this.state.level,
      "onChange": this.props.instrument.createSetterFor('level')
    }), React.DOM.div({
      "className": "ui"
    }, React.DOM.select({
      "onChange": this.setPolyphony,
      "value": this.state.polyphony
    }, options), React.DOM.label(null, "Poly"))));
  }
});



},{"./envelope":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/envelope.cjsx","./knob":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/knob.cjsx","./mixins/modelable":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/mixins/modelable.coffee","./sample_control":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/sample_control.cjsx","./slider":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/slider.cjsx","react":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/react.js"}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/menu.cjsx":[function(require,module,exports){
var React;

React = require('react');

module.exports = React.createClass({
  onClickOption: function(e) {
    e.stopPropagation();
    return this.props.onSelect(e.target.dataset.option);
  },
  render: function() {
    var i, option, options;
    options = (function() {
      var _i, _len, _ref, _results;
      _ref = this.props.options;
      _results = [];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        option = _ref[i];
        _results.push((function(_this) {
          return function(option) {
            return React.DOM.div({
              "key": i,
              "className": "option",
              "onClick": _this.onClickOption,
              "data-option": option
            }, option);
          };
        })(this)(option));
      }
      return _results;
    }).call(this);
    return React.DOM.div({
      "className": "ui menu",
      "style": {
        display: this.props.open ? 'block' : 'none'
      }
    }, options);
  }
});



},{"react":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/react.js"}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/meter.cjsx":[function(require,module,exports){
var React;

React = require('react');

module.exports = React.createClass({
  getDefaultProps: function() {
    return {
      steps: 6
    };
  },
  render: function() {
    var className, i, level, steps;
    level = Math.ceil(this.props.track.get('meterLevel') * this.props.steps);
    steps = (function() {
      var _i, _ref, _results;
      _results = [];
      for (i = _i = 1, _ref = this.props.steps; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        className = i <= level ? 'on' : '';
        _results.push(React.DOM.div({
          "key": i,
          "className": className
        }));
      }
      return _results;
    }).call(this);
    return React.DOM.div({
      "className": "ui meter"
    }, steps);
  },
  shouldComponentUpdate: function(nextProps) {
    return Math.ceil(this.props.track.get('meterLevel') * this.props.steps) !== Math.ceil(nextProps.track.get('meterLevel') * nextProps.steps);
  }
});



},{"react":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/react.js"}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/mixins/draggable.coffee":[function(require,module,exports){
module.exports = {
  draggableOnMouseDown: function(e) {
    window.addEventListener('mousemove', this.draggableOnMouseMove);
    window.addEventListener('mouseup', this.draggableOnMouseUp);
    this.dragStartPosition = {
      x: e.clientX,
      y: e.clientY
    };
    return typeof this.onDragStart === "function" ? this.onDragStart(this.dragStartPosition, e) : void 0;
  },
  draggableOnMouseMove: function(e) {
    var x, y;
    x = e.clientX - this.dragStartPosition.x;
    y = this.dragStartPosition.y - e.clientY;
    return typeof this.onDrag === "function" ? this.onDrag({
      x: x,
      y: y
    }, e) : void 0;
  },
  draggableOnMouseUp: function(e) {
    window.removeEventListener('mousemove', this.draggableOnMouseMove);
    window.removeEventListener('mouseup', this.draggableOnMouseUp);
    this.mouseDownPosition = null;
    this.initialValue = null;
    return typeof this.onDragEnd === "function" ? this.onDragEnd(e) : void 0;
  }
};



},{}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/mixins/modelable.coffee":[function(require,module,exports){
var capitalize, identity, immutableEqual;

identity = function(v) {
  return v;
};

capitalize = function(s) {
  return s.charAt(0).toUpperCase() + s.slice(1);
};

immutableEqual = function(objA, objB) {
  var key;
  if (objA === objB) {
    return true;
  }
  for (key in objA) {
    if (objA.hasOwnProperty(key)) {
      if (!objB.hasOwnProperty(key)) {
        return false;
      }
      if (objA[key].deref != null) {
        if (objA[key].deref() !== objB[key].deref()) {
          return false;
        }
      } else {
        if (objA[key] !== objB[key]) {
          return false;
        }
      }
    }
  }
  for (key in objB) {
    if (objB.hasOwnProperty(key)) {
      if (!objA.hasOwnProperty(key)) {
        return false;
      }
    }
  }
  return true;
};

module.exports = function() {
  var mixin, model, _fn, _i, _len;
  mixin = {
    shouldComponentUpdate: function(nextProps, nextState) {
      return !immutableEqual(this.props, nextProps) || !immutableEqual(this.state, nextState);
    }
  };
  _fn = function(model) {
    return mixin["update" + (capitalize(model))] = function(path, updator) {
      var c;
      if (updator == null) {
        updator = identity;
      }
      c = this.props[model].cursor(path);
      return function(value) {
        return c.update(function(oldValue) {
          return updator(value, oldValue);
        });
      };
    };
  };
  for (_i = 0, _len = arguments.length; _i < _len; _i++) {
    model = arguments[_i];
    _fn(model);
  }
  return mixin;
};



},{}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/mixins/size_measurable.coffee":[function(require,module,exports){
module.exports = {
  getInitialState: function() {
    return {
      height: 0,
      width: 0
    };
  },
  updateDimensions: function(e) {
    var el;
    el = this.refs.container.getDOMNode();
    return this.setState({
      width: el.clientWidth,
      height: el.clientHeight
    });
  },
  componentDidMount: function() {
    this.updateDimensions();
    return window.addEventListener('resize', this.updateDimensions);
  },
  componentWillUnmount: function() {
    return window.removeEventListener('resize', this.updateDimensions);
  }
};



},{}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/mixins/sortable.coffee":[function(require,module,exports){
module.exports = {
  dragStart: function(e) {
    this.props.updateDragging(parseInt(e.currentTarget.dataset.id));
    this.props.selectTrack(parseInt(e.currentTarget.dataset.id));
    e.dataTransfer.effectAllowed = 'move';
    return e.dataTransfer.setData('text/html', null);
  },
  dragEnd: function() {
    return this.props.updateDragging(null);
  },
  dragOver: function(e) {
    var append, from, height, items, over, relX, relY, to;
    e.preventDefault();
    over = e.currentTarget;
    relX = e.clientX - over.getBoundingClientRect().left;
    relY = e.clientY - over.getBoundingClientRect().top;
    height = over.offsetHeight / 2;
    append = relY > height;
    from = this.props.dragging;
    to = Number(over.dataset.id);
    if (append) {
      to += 1;
    }
    if (from < to) {
      to -= 1;
    }
    if (from === to) {
      return;
    }
    items = this.props.items.deref();
    this.props.items.update(function(items) {
      var item;
      item = items.get(from);
      items = items.splice(from, 1);
      items = items.splice(to, 0, item);
      return items.toVector();
    });
    this.props.updateDragging(to);
    return this.props.selectTrack(to);
  },
  isDragging: function() {
    return this.props.dragging === this.props.index;
  }
};



},{}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/mixins/updatable.coffee":[function(require,module,exports){
module.exports = {
  update: function(prop) {
    return (function(_this) {
      return function(value) {
        var obj;
        obj = {};
        obj[prop] = value;
        return _this.setState(obj);
      };
    })(this);
  },
  updateTo: function(values) {
    return (function(_this) {
      return function() {
        return _this.setState(values);
      };
    })(this);
  }
};



},{}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/modal.cjsx":[function(require,module,exports){
var React;

React = require('react');

module.exports = React.createClass({
  render: function() {
    return React.DOM.div(null, React.DOM.div({
      "className": "modal-backdrop"
    }), React.DOM.div({
      "className": "modal-body"
    }, this.props.children));
  }
});



},{"react":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/react.js"}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/oscillator.cjsx":[function(require,module,exports){
var Chooser, Knob, React;

React = require('react');

Chooser = require('./chooser');

Knob = require('./knob');

module.exports = React.createClass({
  update: function(attr) {
    return (function(_this) {
      return function(value) {
        var k, osc, v, _ref;
        osc = {};
        _ref = _this.props.osc;
        for (k in _ref) {
          v = _ref[k];
          osc[k] = k === attr ? value : v;
        }
        return _this.props.onChange(osc);
      };
    })(this);
  },
  render: function() {
    return React.DOM.div({
      "className": "ui oscillator"
    }, Chooser({
      "options": ['sine', 'square', 'saw'],
      "value": this.props.osc.waveform,
      "onChange": this.update('waveform')
    }), Knob({
      "label": "Level",
      "value": this.props.osc.level,
      "onChange": this.update('level')
    }), Knob({
      "label": "Pitch",
      "value": this.props.osc.pitch,
      "onChange": this.update('pitch')
    }), Knob({
      "label": "Tune",
      "value": this.props.osc.tune,
      "onChange": this.update('tune')
    }), React.DOM.label(null, this.props.label));
  }
});



},{"./chooser":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/chooser.cjsx","./knob":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/knob.cjsx","react":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/react.js"}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/piano_roll.cjsx":[function(require,module,exports){
var Cursor, Draggable, GridLines, Keyboard, Keys, Notes, PlaybackMarker, React, ScaleHandle, Selection, SizeMeasurable, Updatable,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

React = require('react/addons');

SizeMeasurable = require('./mixins/size_measurable');

Updatable = require('./mixins/updatable');

Draggable = require('./mixins/draggable');

ScaleHandle = require('./scale_handle');

Keyboard = require('../util/keyboard');

Cursor = require('../util/cursor');

Keys = require('./piano_roll/keys');

GridLines = require('./piano_roll/grid_lines');

Notes = require('./piano_roll/notes');

PlaybackMarker = require('./piano_roll/playback_marker');

Selection = require('./piano_roll/selection');

module.exports = React.createClass({
  mixins: [SizeMeasurable, Updatable, Draggable],
  getInitialState: function() {
    return {
      xScale: 1,
      yScale: 12,
      xScroll: 0,
      yScroll: 0,
      minXScale: 1,
      maxXScale: 64,
      minYScale: 12,
      maxYScale: 128,
      scrollPadding: 500,
      lineWidth: 1.5,
      keyWidth: 40,
      quantization: 4,
      resizeHandleWidth: 10,
      selectedNotes: [],
      selectionOrigin: null,
      selectionPosition: null,
      resizeTarget: null,
      resizeDirection: null,
      translateTarget: null
    };
  },
  componentDidMount: function() {
    var el;
    el = this.refs.container.getDOMNode();
    setTimeout((function(_this) {
      return function() {
        el.scrollTop = _this.state.scrollPadding;
        return el.scrollLeft = _this.state.scrollPadding;
      };
    })(this));
    Keyboard.on(8, this.deleteSelectedNotes);
    Keyboard.on(37, this.onArrowKey);
    Keyboard.on(38, this.onArrowKey);
    Keyboard.on(39, this.onArrowKey);
    Keyboard.on(40, this.onArrowKey);
    this.scrollDeltaY = 0;
    this.scrollDeltaX = 0;
    return this.autoScaleViewport(this.props.sequence);
  },
  componentWillUnmount: function() {
    Keyboard.off(8, this.deleteSelectedNotes);
    Keyboard.off(37, this.onArrowKey);
    Keyboard.off(38, this.onArrowKey);
    Keyboard.off(39, this.onArrowKey);
    return Keyboard.off(40, this.onArrowKey);
  },
  componentWillReceiveProps: function(nextProps) {
    if (nextProps.sequence.deref() !== this.props.sequence.deref()) {
      return this.autoScaleViewport(nextProps.sequence);
    }
  },
  snapScrolling: function(e) {
    var el, loopSize, quanta, xQuantum, xScroll, yQuantum, yScroll;
    e.preventDefault();
    e.stopPropagation();
    el = e.target;
    xQuantum = this.state.width / this.state.xScale / this.state.quantization;
    yQuantum = this.state.height / this.state.yScale;
    loopSize = this.props.sequence.get('loopSize');
    this.scrollDeltaX += el.scrollLeft - this.state.scrollPadding;
    this.scrollDeltaY += this.state.scrollPadding - el.scrollTop;
    el.scrollTop = el.scrollLeft = this.state.scrollPadding;
    if (Math.abs(this.scrollDeltaX) > xQuantum) {
      quanta = (this.scrollDeltaX > 0 ? Math.floor : Math.ceil)(this.scrollDeltaX / xQuantum);
      this.scrollDeltaX -= quanta * xQuantum;
      xScroll = Math.min(Math.max(0, this.state.xScroll + quanta / this.state.quantization), loopSize - this.state.xScale);
    }
    if (Math.abs(this.scrollDeltaY) > yQuantum) {
      quanta = (this.scrollDeltaX > 0 ? Math.floor : Math.ceil)(this.scrollDeltaY / yQuantum);
      this.scrollDeltaY -= quanta * yQuantum;
      yScroll = Math.min(Math.max(0, this.state.yScroll + quanta), 128 - this.state.yScale);
    }
    if ((xScroll != null) || (yScroll != null)) {
      return this.setState({
        xScroll: xScroll != null ? xScroll : this.state.xScroll,
        yScroll: yScroll != null ? yScroll : this.state.yScroll
      });
    }
  },
  autoScaleViewport: function(sequence) {
    var maxKey, minKey, size;
    if (sequence == null) {
      return;
    }
    minKey = 128;
    maxKey = 0;
    sequence.get('notes').forEach(function(id, _arg) {
      var key;
      key = _arg.key;
      if (key < minKey) {
        minKey = key;
      }
      if (key > maxKey) {
        return maxKey = key;
      }
    });
    size = Math.max(this.state.minYScale, maxKey - minKey) + 12;
    return this.setState({
      xScroll: 0,
      xScale: sequence.get('loopSize'),
      yScroll: Math.max(0, Math.ceil((minKey + maxKey - size) / 2)),
      yScale: size
    });
  },
  updateLoopSize: function(e) {},
  updateQuantization: function(e) {
    var value;
    value = parseFloat(e.target.value);
    return this.setState({
      quantization: value
    });
  },
  updateXScale: function(scale) {
    var loopSize, xScale, xScroll;
    loopSize = this.props.sequence.get('loopSize');
    xScale = Math.round(scale * this.state.quantization) / this.state.quantization;
    xScale = Math.min(loopSize, xScale);
    xScroll = Math.min(this.state.xScroll, loopSize - xScale);
    return this.setState({
      xScale: xScale,
      xScroll: xScroll
    });
  },
  updateYScale: function(scale) {
    var yScale, yScroll;
    yScale = Math.round(scale);
    yScroll = Math.min(this.state.yScroll, 128 - this.state.yScale);
    return this.setState({
      yScale: yScale,
      yScroll: yScroll
    });
  },
  updateNotes: function(changes) {},
  getRelativePosition: function(_arg) {
    var height, key, left, start, top, width, x, y, _ref;
    x = _arg.x, y = _arg.y;
    _ref = this.refs.grid.getDOMNode().getBoundingClientRect(), top = _ref.top, left = _ref.left;
    height = this.state.height;
    width = this.state.width - this.state.keyWidth;
    key = Math.floor((height - y + top) / height * this.state.yScale) + this.state.yScroll;
    start = Math.floor((x - left) / width * this.state.xScale * this.state.quantization) / this.state.quantization + this.state.xScroll;
    return {
      key: key,
      start: start
    };
  },
  deleteSelectedNotes: function() {
    return this.props.sequence.removeNotes(this.state.selectedNotes);
  },
  notesSelectedBy: function(from, to) {
    var maxKey, maxStart, minEnd, minKey, notes;
    minKey = Math.min(from.key, to.key);
    maxKey = Math.max(from.key, to.key);
    minEnd = Math.min(from.start, to.start);
    maxStart = Math.max(from.start, to.start);
    notes = [];
    this.props.sequence.get('notes').forEach(function(id, note) {
      if (note.key >= minKey && note.key <= maxKey && note.start + note.length > minEnd && note.start <= maxStart) {
        return notes.push(parseInt(id));
      }
    });
    return notes;
  },
  onClickKeys: function(e) {},
  onMouseDownGrid: function(e) {
    if (!Keyboard.pressed[16]) {
      this.setState({
        selectedNotes: []
      });
    }
    this.draggableOnMouseDown(e);
    return this.setState({
      selectionOrigin: this.getRelativePosition({
        x: e.clientX,
        y: e.clientY
      })
    });
  },
  onDoubleClickGrid: function(e) {
    var key, note, start, _ref;
    _ref = this.getRelativePosition({
      x: e.clientX,
      y: e.clientY
    }), key = _ref.key, start = _ref.start;
    return note = {
      key: key,
      start: start,
      length: 1 / this.state.quantization
    };
  },
  onMouseMoveNote: function(e) {
    var handleSize, position;
    position = e.target.getBoundingClientRect();
    handleSize = Math.max(0, Math.min(this.state.resizeHandleWidth, (position.width - this.state.resizeHandleWidth) / 2));
    if (position.left > e.clientX - handleSize) {
      return this.noteHoverCursor = Cursor.set('w-resize', 1, this.noteHoverCursor);
    } else if (position.right < e.clientX + handleSize) {
      return this.noteHoverCursor = Cursor.set('e-resize', 1, this.noteHoverCursor);
    } else {
      return Cursor.clear(this.noteHoverCursor);
    }
  },
  onMouseOutNote: function(e) {
    return Cursor.clear(this.noteHoverCursor);
  },
  onMouseDownNote: function(e) {
    var handleSize, id, position, selectedNotes, stateChanges;
    e.stopPropagation();
    id = parseInt(e.target.dataset.id);
    position = e.target.getBoundingClientRect();
    if (Keyboard.pressed[16]) {
      selectedNotes = this.state.selectedNotes.slice(0);
      if (__indexOf.call(this.state.selectedNotes, id) >= 0) {
        selectedNotes.splice(selectedNotes.indexOf(id), 1);
      } else {
        selectedNotes.push(id);
      }
    } else {
      if (__indexOf.call(this.state.selectedNotes, id) < 0) {
        selectedNotes = [id];
      } else {
        selectedNotes = this.state.selectedNotes;
      }
    }
    stateChanges = {
      selectedNotes: selectedNotes
    };
    this.draggableOnMouseDown(e);
    this.originalValue = this.props.sequence.get('notes').filter(function(note, id) {
      return selectedNotes.indexOf(id) >= 0;
    });
    this.dragOrigin = this.props.sequence.getIn(['notes', id]);
    handleSize = Math.max(0, Math.min(this.state.resizeHandleWidth, (position.width - this.state.resizeHandleWidth) / 2));
    if (position.left > e.clientX - handleSize) {
      stateChanges.resizeTarget = id;
      stateChanges.resizeDirection = 'left';
      this.dragActionCursor = Cursor.set('w-resize', 2, this.dragActionCursor);
    } else if (position.right < e.clientX + handleSize) {
      stateChanges.resizeTarget = id;
      stateChanges.resizeDirection = 'right';
      this.dragActionCursor = Cursor.set('e-resize', 2, this.dragActionCursor);
    } else {
      stateChanges.translateTarget = id;
      this.dragActionCursor = Cursor.set('move', 2, this.dragActionCursor);
    }
    return this.setState(stateChanges);
  },
  onDoubleClickNote: function(e) {
    e.stopPropagation();
    return this.props.sequence.removeNote(e.target.dataset.id);
  },
  onDrag: function(delta, e) {
    var i, keyDelta, minLength, note, notes, position, start, startDelta, _ref, _ref1, _ref2;
    position = this.getRelativePosition({
      x: e.clientX,
      y: e.clientY
    });
    if (this.state.selectionOrigin != null) {
      return this.setState({
        selectionPosition: position
      });
    } else {
      keyDelta = position.key - this.dragOrigin.key;
      startDelta = position.start - this.dragOrigin.start;
      notes = {};
      if (this.state.translateTarget != null) {
        _ref = this.originalValue;
        for (i in _ref) {
          note = _ref[i];
          notes[i] = {
            key: note.key + keyDelta,
            start: note.start + startDelta
          };
        }
      }
      if (this.state.resizeTarget != null) {
        minLength = 1 / this.state.quantization;
        if (this.state.resizeDirection === 'right') {
          _ref1 = this.originalValue;
          for (i in _ref1) {
            note = _ref1[i];
            notes[i] = {
              length: Math.max(minLength, note.length + startDelta - this.dragOrigin.length + minLength)
            };
          }
        }
        if (this.state.resizeDirection === 'left') {
          _ref2 = this.originalValue;
          for (i in _ref2) {
            note = _ref2[i];
            start = note.start + startDelta;
            start = Math.max(0, start);
            start = Math.min(start, note.start + note.length - minLength);
            notes[i] = {
              start: start,
              length: note.start + note.length - start
            };
          }
        }
      }
      return this.updateNotes(notes);
    }
  },
  onDragEnd: function(e) {
    var changes, position, selectedNotes;
    if ((this.originalValue != null) && Keyboard.pressed[18]) {
      this.props.sequence.addNotes(this.originalValue);
    }
    changes = {
      translateTarget: null,
      resizeTarget: null,
      resizeDirection: null,
      selectionOrigin: null,
      selectionPosition: null
    };
    if (this.state.selectionOrigin != null) {
      position = this.getRelativePosition({
        x: e.clientX,
        y: e.clientY
      });
      selectedNotes = this.notesSelectedBy(this.state.selectionOrigin, position);
      if (Keyboard.pressed[16]) {
        selectedNotes = this.state.selectedNotes.slice(0).concat(selectedNotes);
      }
      changes.selectedNotes = selectedNotes;
    }
    this.setState(changes);
    this.originalValue = null;
    this.dragOrigin = null;
    return Cursor.clear(this.dragActionCursor);
  },
  onArrowKey: function(e) {
    var changes, distance, id, note, _i, _len, _ref;
    changes = {};
    _ref = this.state.selectedNotes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      id = _ref[_i];
      note = this.state.notes[id];
      if (e.keyCode === 37) {
        changes[id] = {
          start: note.start - 1 / this.state.quantization
        };
      } else if (e.keyCode === 38) {
        distance = Keyboard.pressed[16] ? 12 : 1;
        changes[id] = {
          key: note.key + distance
        };
      } else if (e.keyCode === 39) {
        changes[id] = {
          start: note.start + 1 / this.state.quantization
        };
      } else if (e.keyCode === 40) {
        distance = Keyboard.pressed[16] ? 12 : 1;
        changes[id] = {
          key: note.key - distance
        };
      }
    }
    return this.updateNotes(changes);
  },
  render: function() {
    var gridWidth, innerStyle, outerStyle;
    outerStyle = {
      width: this.state.width + 2 * this.state.scrollPadding,
      height: this.state.height + 2 * this.state.scrollPadding
    };
    innerStyle = {
      top: this.state.scrollPadding,
      left: this.state.scrollPadding
    };
    gridWidth = Math.max(0, this.state.width - this.state.keyWidth);
    return React.DOM.div({
      "className": "ui piano-roll"
    }, React.DOM.div({
      "className": "body",
      "ref": 'container',
      "onScroll": this.snapScrolling
    }, React.DOM.div({
      "className": "outer",
      "style": outerStyle
    }, React.DOM.div({
      "className": "inner",
      "style": innerStyle
    }, Keys({
      "width": this.state.keyWidth - this.state.lineWidth,
      "height": this.state.height,
      "yScroll": this.state.yScroll,
      "yScale": this.state.yScale,
      "keyWidth": this.state.keyWidth,
      "onClick": this.onClickKeys
    }), React.DOM.div({
      "className": 'grid',
      "ref": 'grid'
    }, React.DOM.svg({
      "width": gridWidth,
      "height": this.state.height,
      "onMouseDown": this.onMouseDownGrid,
      "onMouseUp": this.onMouseUpGrid,
      "onDoubleClick": this.onDoubleClickGrid
    }, GridLines({
      "width": gridWidth,
      "height": this.state.height,
      "yScale": this.state.yScale,
      "xScale": this.state.xScale,
      "yScroll": this.state.yScroll,
      "xScroll": this.state.xScroll,
      "quantization": this.state.quantization
    }), PlaybackMarker({
      "position": this.props.song.get('position'),
      "loopSize": this.props.sequence.get('loopSize'),
      "width": gridWidth,
      "height": this.state.height,
      "xScroll": this.state.xScroll,
      "xScale": this.state.xScale,
      "quantization": this.state.quantization
    }), Selection({
      "selectionOrigin": this.state.selectionOrigin,
      "selectionPosition": this.state.selectionPosition,
      "width": gridWidth,
      "height": this.state.height,
      "yScale": this.state.yScale,
      "xScale": this.state.xScale,
      "yScroll": this.state.yScroll,
      "xScroll": this.state.xScroll,
      "quantization": this.state.quantization
    }), Notes({
      "notes": this.props.sequence.get('notes'),
      "selectedNotes": this.state.selectedNotes,
      "dragOriginalValue": this.originalValue,
      "translateTarget": this.state.translateTarget,
      "resizeTarget": this.state.resizeTarget,
      "width": gridWidth,
      "height": this.state.height,
      "yScale": this.state.yScale,
      "xScale": this.state.xScale,
      "yScroll": this.state.yScroll,
      "xScroll": this.state.xScroll,
      "lineWidth": this.state.lineWidth,
      "quantization": this.state.quantization,
      "onMouseDown": this.onMouseDownNote,
      "onMouseMove": this.onMouseMoveNote,
      "onMouseOut": this.onMouseOutNote,
      "onDoubleClick": this.onDoubleClickNote
    })))))), React.DOM.div({
      "className": "view-controls"
    }, React.DOM.div({
      "className": "setting"
    }, React.DOM.label(null, "Grid"), React.DOM.select({
      "value": this.state.quantization,
      "onChange": this.updateQuantization
    }, React.DOM.option({
      "value": "1"
    }, "1"), React.DOM.option({
      "value": "2"
    }, "1\x2F2"), React.DOM.option({
      "value": "3"
    }, "1\x2F3"), React.DOM.option({
      "value": "4"
    }, "1\x2F4"), React.DOM.option({
      "value": "6"
    }, "1\x2F6"), React.DOM.option({
      "value": "8"
    }, "1\x2F8"), React.DOM.option({
      "value": "12"
    }, "1\x2F12"), React.DOM.option({
      "value": "16"
    }, "1\x2F16"))), React.DOM.div({
      "className": "setting"
    }, React.DOM.label(null, "Length"), React.DOM.select({
      "value": this.props.sequence.get('loopSize'),
      "onChange": this.updateLoopSize
    }, React.DOM.option({
      "value": "1"
    }, "1"), React.DOM.option({
      "value": "2"
    }, "2"), React.DOM.option({
      "value": "4"
    }, "4"), React.DOM.option({
      "value": "8"
    }, "8"), React.DOM.option({
      "value": "16"
    }, "16"), React.DOM.option({
      "value": "32"
    }, "32"), React.DOM.option({
      "value": "64"
    }, "64"))), ScaleHandle({
      "min": this.state.minYScale,
      "max": this.state.maxYScale,
      "value": this.state.yScale,
      "onChange": this.updateYScale
    }, React.DOM.span({
      "className": "icon icon-arrow-up"
    }), React.DOM.span({
      "className": "icon icon-arrow-down"
    })), ScaleHandle({
      "min": this.state.minXScale,
      "max": this.state.maxXScale,
      "value": this.state.xScale,
      "onChange": this.updateXScale
    }, React.DOM.span({
      "className": "icon icon-arrow-left"
    }), React.DOM.span({
      "className": "icon icon-arrow-right"
    }))));
  }
});



},{"../util/cursor":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/util/cursor.coffee","../util/keyboard":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/util/keyboard.coffee","./mixins/draggable":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/mixins/draggable.coffee","./mixins/size_measurable":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/mixins/size_measurable.coffee","./mixins/updatable":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/mixins/updatable.coffee","./piano_roll/grid_lines":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/piano_roll/grid_lines.cjsx","./piano_roll/keys":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/piano_roll/keys.cjsx","./piano_roll/notes":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/piano_roll/notes.cjsx","./piano_roll/playback_marker":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/piano_roll/playback_marker.cjsx","./piano_roll/selection":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/piano_roll/selection.cjsx","./scale_handle":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/scale_handle.cjsx","react/addons":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/addons.js"}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/piano_roll/grid_lines.cjsx":[function(require,module,exports){
var React, keyPattern;

React = require('react/addons');

keyPattern = [true, false, true, false, true, true, false, true, false, true, false, true];

module.exports = React.createClass({
  mixins: [React.addons.PureRenderMixin],
  propTypes: {
    width: React.PropTypes.number.isRequired,
    height: React.PropTypes.number.isRequired,
    yScale: React.PropTypes.number.isRequired,
    xScale: React.PropTypes.number.isRequired,
    yScroll: React.PropTypes.number.isRequired,
    xScroll: React.PropTypes.number.isRequired,
    quantization: React.PropTypes.number.isRequired
  },
  render: function() {
    var col, cols, els, height, i, maxCol, maxRow, minCol, minRow, quantization, row, rows, squareHeight, squareWidth, width, x, y, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _n, _o, _results, _results1;
    width = this.props.width;
    height = this.props.height;
    squareHeight = height / this.props.yScale;
    quantization = this.props.quantization;
    cols = this.props.xScale * quantization;
    squareWidth = width / cols;
    els = [];
    minRow = this.props.yScroll;
    maxRow = minRow + this.props.yScale;
    rows = (function() {
      _results = [];
      for (var _i = minRow; minRow <= maxRow ? _i < maxRow : _i > maxRow; minRow <= maxRow ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this);
    minCol = this.props.xScroll * quantization;
    maxCol = minCol + this.props.xScale * quantization;
    cols = (function() {
      _results1 = [];
      for (var _j = minCol; minCol <= maxCol ? _j < maxCol : _j > maxCol; minCol <= maxCol ? _j++ : _j--){ _results1.push(_j); }
      return _results1;
    }).apply(this);
    for (i = _k = 0, _len = rows.length; _k < _len; i = ++_k) {
      row = rows[i];
      if (!keyPattern[row % 12]) {
        y = height - (i + 1) * squareHeight;
        els.push(React.DOM.rect({
          "key": 's' + i,
          "x": 0.,
          "y": y,
          "width": width,
          "height": squareHeight,
          "className": 'shade'
        }));
      }
    }
    for (i = _l = 0, _len1 = rows.length; _l < _len1; i = ++_l) {
      row = rows[i];
      if (row % 12 === 5) {
        y = (rows.length - i) * squareHeight;
        els.push(React.DOM.line({
          "key": 'h' + i,
          "x1": 0.,
          "y1": y,
          "x2": width,
          "y2": y
        }));
      }
    }
    for (i = _m = 0, _len2 = cols.length; _m < _len2; i = ++_m) {
      col = cols[i];
      if (col % quantization !== 0) {
        x = i * squareWidth;
        els.push(React.DOM.line({
          "key": 'v' + i,
          "x1": x,
          "y1": 0.,
          "x2": x,
          "y2": height
        }));
      }
    }
    for (i = _n = 0, _len3 = rows.length; _n < _len3; i = ++_n) {
      row = rows[i];
      if (row % 12 === 0) {
        y = (rows.length - i) * squareHeight;
        els.push(React.DOM.line({
          "key": 'hs' + i,
          "x1": 0.,
          "y1": y,
          "x2": width,
          "y2": y,
          "className": 'strong'
        }));
      }
    }
    for (i = _o = 0, _len4 = cols.length; _o < _len4; i = ++_o) {
      col = cols[i];
      if (i !== 0 && col % quantization === 0) {
        x = i * squareWidth;
        els.push(React.DOM.line({
          "key": 'vs' + i,
          "x1": x,
          "y1": 0.,
          "x2": x,
          "y2": height,
          "className": 'strong'
        }));
      }
    }
    return React.DOM.g(null, els);
  }
});



},{"react/addons":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/addons.js"}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/piano_roll/keys.cjsx":[function(require,module,exports){
var React, keyPattern;

React = require('react/addons');

keyPattern = [true, false, true, false, true, true, false, true, false, true, false, true];

module.exports = React.createClass({
  mixins: [React.addons.PureRenderMixin],
  propTypes: {
    height: React.PropTypes.number.isRequired,
    yScroll: React.PropTypes.number.isRequired,
    yScale: React.PropTypes.number.isRequired,
    keyWidth: React.PropTypes.number.isRequired
  },
  render: function() {
    var els, height, i, keyHeight, keyWidth, maxRow, minRow, row, rows, text, y, _i, _j, _k, _len, _len1, _results;
    height = this.props.height;
    keyHeight = height / this.props.yScale;
    keyWidth = this.props.keyWidth;
    els = [];
    minRow = this.props.yScroll;
    maxRow = minRow + this.props.yScale;
    rows = (function() {
      _results = [];
      for (var _i = minRow; minRow <= maxRow ? _i < maxRow : _i > maxRow; minRow <= maxRow ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this);
    for (i = _j = 0, _len = rows.length; _j < _len; i = ++_j) {
      row = rows[i];
      if (!keyPattern[row % 12]) {
        y = height - (i + 1) * keyHeight;
        text = null;
        els.push(React.DOM.rect({
          "key": 'k' + i,
          "x": 0.,
          "y": y,
          "width": keyWidth,
          "height": keyHeight
        }));
      }
    }
    for (i = _k = 0, _len1 = rows.length; _k < _len1; i = ++_k) {
      row = rows[i];
      if (row % 12 === 0) {
        y = height - (i + 0.5) * keyHeight;
        text = "C " + (Math.floor(row / 12) - 2);
        els.push(React.DOM.text({
          "key": 't' + i,
          "x": keyWidth - 4,
          "y": y
        }, text));
      }
    }
    return React.DOM.div({
      "className": 'keys'
    }, React.DOM.svg({
      "width": keyWidth,
      "height": height,
      "onClick": this.props.onClick
    }, els));
  }
});



},{"react/addons":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/addons.js"}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/piano_roll/notes.cjsx":[function(require,module,exports){
var Keyboard, React,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

React = require('react/addons');

Keyboard = require('../../util/keyboard');

module.exports = React.createClass({
  mixins: [React.addons.PureRenderMixin],
  getDefaultProps: function() {
    return {
      radius: 0
    };
  },
  propTypes: {
    notes: React.PropTypes.object.isRequired,
    selectedNotes: React.PropTypes.array.isRequired,
    dragOriginalValue: React.PropTypes.object,
    translateTarget: React.PropTypes.number,
    resizeTarget: React.PropTypes.number,
    width: React.PropTypes.number.isRequired,
    height: React.PropTypes.number.isRequired,
    lineWidth: React.PropTypes.number.isRequired,
    yScale: React.PropTypes.number.isRequired,
    xScale: React.PropTypes.number.isRequired,
    yScroll: React.PropTypes.number.isRequired,
    xScroll: React.PropTypes.number.isRequired,
    quantization: React.PropTypes.number.isRequired,
    onMouseDown: React.PropTypes.func,
    onMouseMove: React.PropTypes.func,
    onMouseOut: React.PropTypes.func,
    onClick: React.PropTypes.func,
    onDoubleClick: React.PropTypes.func
  },
  noteOnScreen: function(note) {
    return note.start <= this.props.xScroll + this.props.xScale && note.start + note.length >= this.props.xScroll && note.key >= this.props.yScroll && note.key <= this.props.yScroll + this.props.yScale;
  },
  render: function() {
    var cols, els, h, height, id, lineWidth, maxCol, maxRow, minCol, minRow, note, quantization, rows, squareHeight, squareWidth, w, width, x, y, _i, _j, _ref, _results, _results1;
    if (!(this.props.width > 0 && this.props.height > 0)) {
      return React.DOM.g(null);
    }
    width = this.props.width;
    height = this.props.height;
    lineWidth = this.props.lineWidth;
    squareHeight = height / this.props.yScale;
    quantization = this.props.quantization;
    cols = this.props.xScale * quantization;
    squareWidth = width / cols;
    els = [];
    minRow = this.props.yScroll;
    maxRow = minRow + this.props.yScale;
    rows = (function() {
      _results = [];
      for (var _i = minRow; minRow <= maxRow ? _i < maxRow : _i > maxRow; minRow <= maxRow ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this);
    minCol = this.props.xScroll * quantization;
    maxCol = minCol + this.props.xScale * quantization;
    cols = (function() {
      _results1 = [];
      for (var _j = minCol; minCol <= maxCol ? _j < maxCol : _j > maxCol; minCol <= maxCol ? _j++ : _j--){ _results1.push(_j); }
      return _results1;
    }).apply(this);
    if ((this.props.translateTarget != null) && Keyboard.pressed[18]) {
      _ref = this.props.dragOriginalValue;
      for (id in _ref) {
        note = _ref[id];
        if (!this.noteOnScreen(note)) {
          continue;
        }
        x = (note.start - this.props.xScroll) * squareWidth * quantization + lineWidth / 2;
        y = (this.props.yScale + this.props.yScroll - note.key - 1) * squareHeight + lineWidth / 2;
        w = squareWidth * note.length * this.props.quantization - this.props.lineWidth;
        h = squareHeight - this.props.lineWidth;
        els.push(React.DOM.rect({
          "className": "ghost note",
          "key": 'g' + id,
          "x": x,
          "y": y,
          "width": w,
          "height": h,
          "rx": this.props.radius,
          "ry": this.props.radius
        }));
      }
    }
    this.props.notes.forEach((function(_this) {
      return function(id, note) {
        var className, _ref1;
        if (!_this.noteOnScreen(note)) {
          return;
        }
        x = (note.start - _this.props.xScroll) * squareWidth * _this.props.quantization + lineWidth / 2;
        y = (_this.props.yScale + _this.props.yScroll - note.key - 1) * squareHeight + lineWidth / 2;
        w = squareWidth * note.length * _this.props.quantization - lineWidth;
        h = squareHeight - lineWidth;
        className = 'note';
        if (_ref1 = note.id, __indexOf.call(_this.props.selectedNotes, _ref1) >= 0) {
          className += ' selected';
        }
        if (_this.props.translateTarget === note.id || _this.props.resizeTarget === note.id) {
          className += ' active';
        }
        return els.push(React.DOM.rect({
          "className": className,
          "key": 'n' + id,
          "x": x,
          "y": y,
          "width": w,
          "height": h,
          "rx": _this.props.radius,
          "ry": _this.props.radius,
          "data-id": id,
          "onMouseDown": _this.props.onMouseDown,
          "onMouseMove": _this.props.onMouseMove,
          "onMouseOut": _this.props.onMouseOut,
          "onClick": _this.props.onClick,
          "onDoubleClick": _this.props.onDoubleClick
        }));
      };
    })(this));
    return React.DOM.g(null, els);
  }
});



},{"../../util/keyboard":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/util/keyboard.coffee","react/addons":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/addons.js"}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/piano_roll/playback_marker.cjsx":[function(require,module,exports){
var React;

React = require('react/addons');

module.exports = React.createClass({
  mixins: [React.addons.PureRenderMixin],
  propTypes: {
    position: React.PropTypes.number.isRequired,
    loopSize: React.PropTypes.number.isRequired,
    width: React.PropTypes.number.isRequired,
    height: React.PropTypes.number.isRequired,
    xScale: React.PropTypes.number.isRequired,
    xScroll: React.PropTypes.number.isRequired,
    quantization: React.PropTypes.number.isRequired
  },
  render: function() {
    var cols, el, height, position, squareWidth, width, x;
    width = this.props.width;
    height = this.props.height;
    position = this.props.position % this.props.loopSize;
    cols = this.props.xScale * this.props.quantization;
    squareWidth = width / cols;
    if (position >= this.props.xScroll && position <= this.props.xScroll + this.props.xScale) {
      x = Math.floor(position * this.props.quantization) * squareWidth;
      if (!(x <= 0)) {
        el = React.DOM.line({
          "key": 'pb',
          "x1": x,
          "y1": 0.,
          "x2": x,
          "y2": height
        });
      }
    }
    return React.DOM.g({
      "className": "playback"
    }, el);
  }
});



},{"react/addons":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/addons.js"}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/piano_roll/selection.cjsx":[function(require,module,exports){
var React;

React = require('react/addons');

module.exports = React.createClass({
  mixins: [React.addons.PureRenderMixin],
  propTypes: {
    selectionOrigin: React.PropTypes.object,
    selectionPosition: React.PropTypes.object,
    width: React.PropTypes.number.isRequired,
    height: React.PropTypes.number.isRequired,
    yScale: React.PropTypes.number.isRequired,
    xScale: React.PropTypes.number.isRequired,
    yScroll: React.PropTypes.number.isRequired,
    xScroll: React.PropTypes.number.isRequired,
    quantization: React.PropTypes.number.isRequired
  },
  render: function() {
    var beatWidth, cols, el, fromBeat, fromKey, h, height, keyWidth, quantization, selectionOrigin, selectionPosition, squareHeight, squareWidth, w, width, x, y;
    width = this.props.width;
    height = this.props.height;
    selectionOrigin = this.props.selectionOrigin;
    selectionPosition = this.props.selectionPosition;
    squareHeight = height / this.props.yScale;
    quantization = this.props.quantization;
    cols = this.props.xScale * quantization;
    squareWidth = width / cols;
    if ((selectionOrigin != null) && (selectionPosition != null)) {
      fromKey = Math.max(selectionOrigin.key, selectionPosition.key);
      keyWidth = Math.abs(selectionOrigin.key - selectionPosition.key);
      fromBeat = Math.min(selectionOrigin.start, selectionPosition.start);
      beatWidth = Math.abs(selectionOrigin.start - selectionPosition.start);
      x = (fromBeat - this.props.xScroll) * quantization * squareWidth;
      y = (this.props.yScale + this.props.yScroll - fromKey - 1) * squareHeight;
      w = (beatWidth * quantization + 1) * squareWidth;
      h = (keyWidth + 1) * squareHeight;
      el = React.DOM.rect({
        "className": 'selection',
        "key": 'sel',
        "x": x,
        "y": y,
        "width": w,
        "height": h
      });
    }
    return React.DOM.g(null, el);
  }
});



},{"react/addons":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/addons.js"}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/playback_control.cjsx":[function(require,module,exports){
var Keyboard, Modelable, React, ScaleHandle;

React = require('react');

Modelable = require('./mixins/modelable');

ScaleHandle = require('./scale_handle');

Keyboard = require('../util/keyboard');

module.exports = React.createClass({
  componentDidMount: function() {
    return Keyboard.on(32, this.play);
  },
  componentWillUnmount: function() {
    return Keyboard.off(32, this.play);
  },
  play: function() {},
  onChangeBpm: function(e) {},
  stopPropagation: function(e) {
    return e.stopPropagation();
  },
  render: function() {
    var bpmOptions, i, playClassName, song;
    song = this.props.song;
    playClassName = 'icon icon-play' + (song.get('playing') ? ' active' : '');
    bpmOptions = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 200; _i >= 20; i = --_i) {
        _results.push(React.DOM.option({
          "key": i,
          "value": i
        }, i, " bpm"));
      }
      return _results;
    })();
    return React.DOM.div({
      "className": "ui playback-control"
    }, React.DOM.div({
      "className": "group playback"
    }, React.DOM.div({
      "className": playClassName,
      "onClick": (function() {})
    }), React.DOM.div({
      "className": "icon icon-record"
    }), React.DOM.div({
      "className": "icon icon-stop",
      "onClick": (function() {})
    })), React.DOM.div({
      "className": "group tempo"
    }, React.DOM.select({
      "value": song.get('bpm'),
      "onChange": (function() {})
    }, bpmOptions)), React.DOM.div({
      "className": "logo"
    }, "sinesaw"), React.DOM.div({
      "className": "group menu"
    }, React.DOM.div({
      "className": "icon icon-air"
    })));
  }
});



},{"../util/keyboard":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/util/keyboard.coffee","./mixins/modelable":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/mixins/modelable.coffee","./scale_handle":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/scale_handle.cjsx","react":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/react.js"}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/record_control.cjsx":[function(require,module,exports){
var Meter, Modelable, React, Recording, Waveform;

React = require('react/addons');

Modelable = require('./mixins/modelable');

Recording = require('../models/recording');

Waveform = require('./waveform');

Meter = require('./meter');

module.exports = React.createClass({
  mixins: [Modelable('recording')],
  onClick: function() {
    if (this.state.active) {
      return this.props.recording.stop();
    } else if (this.state.sampleData == null) {
      return this.props.recording.record();
    }
  },
  confirm: function() {
    return this.props.onConfirm(this.props.recording.croppedSampleData());
  },
  render: function() {
    var instruction, leftButtons, message, rightButtons, waveform;
    leftButtons = [
      React.DOM.div({
        "className": "icon icon-record " + (this.state.active ? ' active' : ''),
        "key": "r",
        "onClick": (this.state.active ? this.props.recording.stop : this.props.recording.record)
      })
    ];
    rightButtons = [
      React.DOM.div({
        "className": "icon icon-cross",
        "key": "c",
        "onClick": this.props.onCancel
      })
    ];
    if (this.state.sampleData != null) {
      waveform = Waveform({
        "sampleData": this.state.sampleData,
        "selectionStart": this.state.cropStart,
        "selectionEnd": this.state.cropEnd,
        "markers": {
          start: {
            value: this.state.cropStart,
            onChange: this.props.recording.createSetterFor('cropStart')
          },
          end: {
            value: this.state.cropEnd,
            onChange: this.props.recording.createSetterFor('cropEnd')
          }
        }
      });
      leftButtons.push(React.DOM.div({
        "className": "icon icon-play " + (this.state.playing ? ' active' : ''),
        "key": "p",
        "onClick": (this.state.playing ? this.props.recording.stop : this.props.recording.play)
      }));
      rightButtons.push(React.DOM.div({
        "className": "icon icon-checkmark",
        "key": "s",
        "onClick": this.confirm
      }));
    } else {
      message = this.state.error != null ? this.props.recording.state.error : this.state.active ? 'Recording, click to stop' : 'Click to record';
      instruction = React.DOM.div({
        "className": "instruction"
      }, message);
    }
    return React.DOM.div({
      "className": "ui record-control"
    }, React.DOM.div({
      "className": "row sample"
    }, React.DOM.div({
      "className": "display",
      "onClick": this.onClick
    }, waveform, instruction)), React.DOM.div({
      "className": "row controls"
    }, React.DOM.div({
      "className": "left"
    }, leftButtons), React.DOM.div({
      "className": "right"
    }, rightButtons)));
  }
});



},{"../models/recording":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/models/recording.coffee","./meter":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/meter.cjsx","./mixins/modelable":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/mixins/modelable.coffee","./waveform":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/waveform.cjsx","react/addons":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/addons.js"}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/sample_control.cjsx":[function(require,module,exports){
var React, RecordControl, Recording, Waveform, decoder;

React = require('react/addons');

Recording = require('../models/recording');

Waveform = require('./waveform');

RecordControl = require('./record_control');

decoder = new webkitAudioContext;

module.exports = React.createClass({
  range: 300,
  dragTypeDistance: 10,
  mixins: [React.addons.pureRenderMixin],
  getDefaultProps: function() {
    return {
      sampleStart: 0
    };
  },
  triggerFileInput: function() {
    return this.refs.input.getDOMNode().click();
  },
  onFileSelect: function() {
    var file, reader;
    file = this.refs.input.getDOMNode().files[0];
    if (file != null) {
      reader = new FileReader;
      reader.onload = (function(_this) {
        return function(e) {
          return decoder.decodeAudioData(e.target.result, function(buffer) {
            var data;
            data = buffer.getChannelData(0);
            return _this.props.onChange(file.name, data);
          });
        };
      })(this);
      return reader.readAsArrayBuffer(file);
    }
  },
  clear: function() {
    return this.props.onChange(null, null);
  },
  recordSample: function() {
    return this.props.app.launchModal(RecordControl({
      "recording": new Recording,
      "onCancel": this.props.app.dismissModal,
      "onConfirm": ((function(_this) {
        return function(sampleData) {
          _this.props.onChange('recorded.wav', sampleData);
          return _this.props.app.dismissModal();
        };
      })(this))
    }));
  },
  render: function() {
    var markers;
    markers = {};
    if (this.props.sampleStart != null) {
      markers.start = {
        value: this.props.sampleStart,
        onChange: this.props.onChangeStart
      };
    }
    if (this.props.loopActive) {
      markers.loop = {
        value: this.props.sampleLoop,
        onChange: this.props.onChangeLoop
      };
    }
    return React.DOM.div({
      "className": "ui sample-control"
    }, React.DOM.input({
      "type": "file",
      "ref": "input",
      "onChange": this.onFileSelect
    }), React.DOM.div({
      "className": "display",
      "ref": "container",
      "onClick": (this.props.sampleData != null ? null : this.triggerFileInput)
    }, (this.props.sampleData != null ? null : React.DOM.div({
      "className": "instruction"
    }, "click to upload")), Waveform({
      "sampleData": this.props.sampleData,
      "selectionStart": this.props.sampleStart,
      "selectionEnd": (this.props.loopActive ? this.props.sampleLoop : 1),
      "markers": markers
    })), React.DOM.div({
      "className": "controls"
    }, React.DOM.div({
      "className": "control",
      "onClick": this.triggerFileInput
    }, React.DOM.div({
      "className": "icon icon-arrow-up"
    })), React.DOM.div({
      "className": "control",
      "onClick": this.recordSample
    }, React.DOM.div({
      "className": "icon icon-record"
    })), React.DOM.div({
      "className": "control",
      "onClick": this.clear
    }, React.DOM.div({
      "className": "icon icon-cross"
    })), React.DOM.div({
      "className": "file-name"
    }, this.props.sampleName)), React.DOM.label(null, this.props.label));
  }
});



},{"../models/recording":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/models/recording.coffee","./record_control":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/record_control.cjsx","./waveform":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/waveform.cjsx","react/addons":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/addons.js"}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/scale_handle.cjsx":[function(require,module,exports){
var Draggable, React;

React = require('react');

Draggable = require('./mixins/draggable');

module.exports = React.createClass({
  range: 300,
  mixins: [Draggable],
  getInitialState: function() {
    return {
      active: false
    };
  },
  onDragStart: function() {
    this.initialValue = (this.props.value - this.props.min) / (this.props.max - this.props.min);
    return this.setState({
      active: true
    });
  },
  onDrag: function(delta) {
    var downRange, upRange, value;
    upRange = Math.min(this.range, this.dragStartPosition.y - window.scrollY);
    downRange = Math.min(this.range, window.innerHeight + window.scrollY - this.dragStartPosition.y);
    if (delta.y < 0) {
      value = Math.max(0, this.initialValue * (downRange + delta.y) / downRange);
    } else {
      value = Math.min(1, this.initialValue + (1 - this.initialValue) * delta.y / upRange);
    }
    value = 1 * this.props.min + value * (this.props.max - this.props.min);
    return this.props.onChange(value);
  },
  onDragEnd: function() {
    this.initialValue = null;
    return this.setState({
      action: false
    });
  },
  render: function() {
    var className;
    className = 'ui scale-handle';
    if (this.state.active) {
      className += ' active';
    }
    return React.DOM.div({
      "className": className,
      "onMouseDown": this.draggableOnMouseDown
    }, this.props.children);
  }
});



},{"./mixins/draggable":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/mixins/draggable.coffee","react":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/react.js"}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/slider.cjsx":[function(require,module,exports){
var Draggable, React, SizeMeasurable;

React = require('react');

SizeMeasurable = require('./mixins/size_measurable');

Draggable = require('./mixins/draggable');

module.exports = React.createClass({
  mixins: [SizeMeasurable, Draggable],
  getInitialState: function() {
    return {
      active: false
    };
  },
  onDragStart: function() {
    this.initalValue = this.props.value;
    return this.setState({
      active: true
    });
  },
  onDrag: function(delta) {
    var value;
    value = this.initalValue + delta.y / this.state.height;
    value = Math.max(0, Math.min(value, 1));
    return this.props.onChange(value);
  },
  onDragEnd: function() {
    this.initalValue = null;
    return this.setState({
      active: false
    });
  },
  render: function() {
    var className, style;
    style = {
      top: "" + (100 * (1 - this.props.value)) + "%"
    };
    className = 'ui slider';
    if (this.state.active) {
      className += ' active';
    }
    return React.DOM.div({
      "className": className
    }, React.DOM.div({
      "className": "control",
      "ref": "container"
    }, React.DOM.div({
      "className": "track"
    }), React.DOM.div({
      "className": "handle",
      "style": style,
      "onMouseDown": this.draggableOnMouseDown
    })), React.DOM.label(null, this.props.label));
  }
});



},{"./mixins/draggable":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/mixins/draggable.coffee","./mixins/size_measurable":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/mixins/size_measurable.coffee","react":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/react.js"}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/track_selection.cjsx":[function(require,module,exports){
var AnalogSynthesizer, BasicSampler, Draggable, DrumSampler, DrumkitSynthesizer, Knob, LoopSampler, Menu, Meter, React, ReactCSSTransitionGroup, SizeMeasurable, Sortable, Track, TrackRow, Updatable;

React = require('react/addons');

Sortable = require('./mixins/sortable');

Updatable = require('./mixins/updatable');

Draggable = require('./mixins/draggable');

SizeMeasurable = require('./mixins/size_measurable');

Knob = require('./knob');

Meter = require('./meter');

Menu = require('./menu');

DrumSampler = require('../models/drum_sampler');

BasicSampler = require('../models/basic_sampler');

LoopSampler = require('../models/loop_sampler');

AnalogSynthesizer = require('../models/analog_synthesizer');

DrumkitSynthesizer = require('../models/drumkit_synthesizer');

Track = require('../models/track');

ReactCSSTransitionGroup = React.addons.CSSTransitionGroup;

TrackRow = React.createClass({
  mixins: [Sortable, React.addons.PureRenderMixin],
  render: function() {
    var className;
    className = 'track';
    if (this.props.selected) {
      className += ' selected';
    }
    if (this.isDragging()) {
      className += ' dragging';
    }
    return React.DOM.div({
      "className": className,
      "onClick": this.props.selectTrack,
      "draggable": true,
      "onDragStart": this.dragStart,
      "onDragEnd": this.dragEnd,
      "onDragOver": this.dragOver,
      "data-id": this.props.index
    }, React.DOM.div({
      "className": 'name'
    }, this.props.track.get('name')), Knob({
      "label": "Level",
      "value": this.props.track.getIn('instrument', 'level'),
      "onChange": (function() {})
    }), Meter({
      "track": this.props.track
    }));
  }
});

module.exports = React.createClass({
  mixins: [Updatable, React.addons.PureRenderMixin],
  trackTypes: {
    'Drum Sampler': DrumSampler,
    'Basic Sampler': BasicSampler,
    'Loop Sampler': LoopSampler,
    'Analog Synth': AnalogSynthesizer,
    'Drum Synth': DrumkitSynthesizer
  },
  getInitialState: function() {
    return {
      menuOpen: false,
      dragging: null
    };
  },
  componentDidMount: function() {
    return window.addEventListener('click', this.closeMenu);
  },
  componentWillUnmount: function() {
    return window.removeEventListener('click', this.closeMenu);
  },
  closeMenu: function() {
    if (this.state.menuOpen) {
      return this.setState({
        menuOpen: false
      });
    }
  },
  toggleMenu: function(e) {
    e.stopPropagation();
    return this.setState({
      menuOpen: !this.state.menuOpen
    });
  },
  addTrack: function(name) {
    var index, track;
    track = Track.build({
      name: name,
      instrument: this.trackTypes[name].build()
    });
    index = this.props.tracks.length;
    this.props.tracks.update(function(tracks) {
      return tracks.set(index, track);
    });
    this.props.selectTrack(index);
    return this.setState({
      menuOpen: false
    });
  },
  removeTrack: function() {
    this.props.tracks.update((function(_this) {
      return function(tracks) {
        return tracks.splice(_this.props.selectedTrack, 1).toVector();
      };
    })(this));
    return this.props.selectTrack(Math.max(0, Math.min(this.props.selectedTrack, this.props.tracks.length - 2)));
  },
  render: function() {
    var trackRows;
    trackRows = this.props.tracks.map((function(_this) {
      return function(track, i) {
        if (track) {
          return TrackRow({
            "key": track.get('_id'),
            "index": i,
            "track": track,
            "selected": _this.props.selectedTrack === i,
            "selectTrack": (function() {
              return _this.props.selectTrack(i);
            }),
            "dragging": _this.state.dragging,
            "updateDragging": _this.update('dragging'),
            "items": _this.props.tracks
          });
        }
      };
    })(this)).toArray();
    return React.DOM.div({
      "className": 'ui track-selection'
    }, React.DOM.div({
      "className": "tracks"
    }, ReactCSSTransitionGroup({
      "transitionName": "track"
    }, trackRows)), React.DOM.div({
      "className": "controls"
    }, Menu({
      "options": Object.keys(this.trackTypes),
      "onSelect": this.addTrack,
      "open": this.state.menuOpen
    }), React.DOM.div({
      "className": "icon icon-plus pull-right",
      "onClick": this.toggleMenu
    }), React.DOM.div({
      "className": "icon icon-minus pull-left",
      "onClick": this.removeTrack
    })));
  }
});



},{"../models/analog_synthesizer":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/models/analog_synthesizer.coffee","../models/basic_sampler":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/models/basic_sampler.coffee","../models/drum_sampler":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/models/drum_sampler.coffee","../models/drumkit_synthesizer":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/models/drumkit_synthesizer.coffee","../models/loop_sampler":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/models/loop_sampler.coffee","../models/track":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/models/track.coffee","./knob":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/knob.cjsx","./menu":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/menu.cjsx","./meter":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/meter.cjsx","./mixins/draggable":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/mixins/draggable.coffee","./mixins/size_measurable":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/mixins/size_measurable.coffee","./mixins/sortable":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/mixins/sortable.coffee","./mixins/updatable":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/mixins/updatable.coffee","react/addons":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/addons.js"}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/waveform.cjsx":[function(require,module,exports){
var Draggable, Marker, React, SizeMeasurable, Visualization;

React = require('react/addons');

SizeMeasurable = require('./mixins/size_measurable');

Draggable = require('./mixins/draggable');

Marker = require('./waveform/marker');

Visualization = require('./waveform/visualization');

module.exports = React.createClass({
  mixins: [React.addons.PureRenderMixin, SizeMeasurable, Draggable],
  propTypes: {
    sampleData: React.PropTypes.object,
    markers: React.PropTypes.object,
    selectionStart: React.PropTypes.number,
    selectionEnd: React.PropTypes.number,
    marginTop: React.PropTypes.number,
    marginBottom: React.PropTypes.number
  },
  range: 300,
  dragTypeDistance: 10,
  getInitialState: function() {
    return {
      windowCenter: 0.5,
      windowSize: 1
    };
  },
  getDefaultProps: function() {
    return {
      marginTop: 2,
      marginBottom: 2
    };
  },
  validateWindowCenter: function(center) {
    var halfSize;
    halfSize = this.state.windowSize / 2;
    if (center < halfSize) {
      return halfSize;
    } else if (center > 1 - halfSize) {
      return 1 - halfSize;
    } else {
      return center;
    }
  },
  onDragStart: function() {
    var relativePosition;
    this.initialWindowSize = this.state.windowSize;
    this.initialWindowCenter = this.state.windowCenter;
    relativePosition = (this.dragStartPosition.x - this.getDOMNode().getBoundingClientRect().left) / this.state.width;
    return this.initialPosition = this.state.windowCenter + this.state.windowSize * (relativePosition - 0.5);
  },
  onDragEnd: function() {
    this.dragType = null;
    this.initialWindowSize = null;
    this.initialWindowCenter = null;
    return this.initialPosition = null;
  },
  onDrag: function(delta) {
    var center, downRange, minValue, size, upRange;
    if (this.dragType === 'scale') {
      upRange = Math.min(this.range, this.dragStartPosition.y - window.scrollY);
      downRange = Math.min(this.range, window.innerHeight + window.scrollY - this.dragStartPosition.y);
      if (delta.y < 0) {
        minValue = Math.min(1, this.state.width / this.props.sampleData.length);
        size = Math.max(minValue, this.initialWindowSize * (downRange + delta.y) / downRange);
      } else {
        size = Math.min(1, this.initialWindowSize + (1 - this.initialWindowSize) * delta.y / upRange);
      }
      center = this.initialPosition - size / this.initialWindowSize * (this.initialPosition - this.initialWindowCenter);
      return this.setState({
        windowSize: size,
        windowCenter: this.validateWindowCenter(center)
      });
    } else if (this.dragType === 'pan') {
      center = this.initialWindowCenter - delta.x / this.state.width * this.initialWindowSize;
      return this.setState({
        windowCenter: this.validateWindowCenter(center)
      });
    } else {
      if (Math.abs(delta.x) > this.dragTypeDistance) {
        return this.dragType = 'pan';
      } else if (Math.abs(delta.y) > this.dragTypeDistance) {
        return this.dragType = 'scale';
      }
    }
  },
  render: function() {
    var data, markers, name, postSelection, preSelection, resolution, sampleData, selection, selectionEnd, selectionStart, sliceSize, windowSize, windowStart, _ref;
    if ((this.props.sampleData != null) && this.state.width > 0) {
      sampleData = this.props.sampleData;
      resolution = this.state.width / 2;
      windowSize = Math.max(1, Math.floor(this.state.windowSize * sampleData.length));
      sliceSize = windowSize / resolution;
      windowStart = Math.floor(this.state.windowCenter * sampleData.length - windowSize / 2);
      selectionStart = Math.floor((this.props.selectionStart * sampleData.length - windowStart) / sliceSize);
      selectionEnd = Math.ceil((this.props.selectionEnd * sampleData.length - windowStart) / sliceSize);
      if (selectionStart > 1) {
        preSelection = Visualization({
          "sampleData": sampleData,
          "resolution": resolution,
          "sliceSize": sliceSize,
          "windowStart": windowStart,
          "fromSlice": 0.,
          "toSlice": Math.min(resolution, selectionStart),
          "width": this.state.width,
          "height": this.state.height,
          "marginTop": this.props.marginTop,
          "marginBottom": this.props.marginBottom
        });
      }
      if (selectionStart !== selectionEnd) {
        selection = Visualization({
          "sampleData": sampleData,
          "resolution": resolution,
          "sliceSize": sliceSize,
          "windowStart": windowStart,
          "fromSlice": Math.max(0, selectionStart),
          "toSlice": Math.min(resolution, selectionEnd),
          "width": this.state.width,
          "height": this.state.height,
          "marginTop": this.props.marginTop,
          "marginBottom": this.props.marginBottom,
          "selection": true
        });
      }
      if (selectionEnd < resolution) {
        postSelection = Visualization({
          "sampleData": sampleData,
          "resolution": resolution,
          "sliceSize": sliceSize,
          "windowStart": windowStart,
          "fromSlice": Math.max(0, selectionEnd),
          "toSlice": resolution,
          "width": this.state.width,
          "height": this.state.height,
          "marginTop": this.props.marginTop,
          "marginBottom": this.props.marginBottom
        });
      }
      markers = [];
      if (this.props.markers != null) {
        _ref = this.props.markers;
        for (name in _ref) {
          data = _ref[name];
          markers.push(Marker({
            "key": name,
            "name": name,
            "value": data.value,
            "onChange": data.onChange,
            "parentWidth": this.state.width,
            "parentHeight": this.state.height,
            "windowSize": this.state.windowSize,
            "windowCenter": this.state.windowCenter
          }));
        }
      }
    }
    return React.DOM.div({
      "className": "ui waveform",
      "ref": "container"
    }, React.DOM.svg({
      "width": this.state.width,
      "height": this.state.height,
      "onMouseDown": (this.props.sampleData != null ? this.draggableOnMouseDown : null)
    }, preSelection, selection, postSelection, markers));
  }
});



},{"./mixins/draggable":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/mixins/draggable.coffee","./mixins/size_measurable":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/mixins/size_measurable.coffee","./waveform/marker":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/waveform/marker.cjsx","./waveform/visualization":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/waveform/visualization.cjsx","react/addons":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/addons.js"}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/waveform/marker.cjsx":[function(require,module,exports){
var Draggable, React;

React = require('react/addons');

Draggable = require('../mixins/draggable');

module.exports = React.createClass({
  mixins: [Draggable, React.addons.PureRenderMixin],
  propTypes: {
    name: React.PropTypes.string,
    value: React.PropTypes.number,
    parentWidth: React.PropTypes.number,
    parentHeight: React.PropTypes.number,
    windowSize: React.PropTypes.number,
    windowCenter: React.PropTypes.number,
    width: React.PropTypes.number,
    radius: React.PropTypes.number
  },
  getDefaultProps: function() {
    return {
      radius: 2,
      width: 4
    };
  },
  getInitialState: function() {
    return {
      dragActive: false
    };
  },
  onDragStart: function(dragStartPosition, e) {
    e.stopPropagation();
    return this.setState({
      dragInitialValue: this.props.value
    });
  },
  onDragEnd: function() {
    return this.setState({
      dragInitialValue: null
    });
  },
  onDrag: function(delta) {
    var value;
    value = Math.max(0, Math.min(1, this.state.dragInitialValue + delta.x / this.props.parentWidth * this.props.windowSize));
    return this.props.onChange(value);
  },
  render: function() {
    var className, windowEnd, windowStart, x;
    windowStart = this.props.windowCenter - this.props.windowSize / 2;
    windowEnd = this.props.windowCenter + this.props.windowSize / 2;
    if (!(this.props.value >= windowStart && this.props.value <= windowEnd)) {
      return React.DOM.g(null);
    }
    x = (this.props.value - windowStart) / this.props.windowSize * this.props.parentWidth - this.props.width / 2;
    x = Math.max(0, Math.min(this.props.parentWidth - this.props.width, x));
    className = "marker " + this.props.name;
    if (this.state.dragInitialValue != null) {
      className += ' active';
    }
    return React.DOM.g(null, React.DOM.rect({
      "className": className,
      "x": x,
      "y": 0.,
      "width": this.props.width,
      "height": this.props.parentHeight,
      "rx": this.props.radius,
      "ry": this.props.radius,
      "onMouseDown": this.draggableOnMouseDown
    }));
  }
});



},{"../mixins/draggable":"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/mixins/draggable.coffee","react/addons":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/addons.js"}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/ui/waveform/visualization.cjsx":[function(require,module,exports){
var React;

React = require('react/addons');

module.exports = React.createClass({
  mixins: [React.addons.PureRenderMixin],
  render: function() {
    var bottom, className, d, fromSlice, height, i, j, points, resolution, sampleData, sliceEnd, sliceSize, sliceStart, toSlice, top, v, width, windowStart, x, y, _i, _j, _ref, _ref1;
    sampleData = this.props.sampleData;
    resolution = this.props.resolution;
    sliceSize = this.props.sliceSize;
    windowStart = this.props.windowStart;
    fromSlice = this.props.fromSlice;
    toSlice = this.props.toSlice;
    width = this.props.width;
    height = this.props.height - this.props.marginTop - this.props.marginBottom;
    top = this.props.marginBottom;
    bottom = this.props.height - this.props.marginBottom;
    points = [];
    points.push("" + (fromSlice * width / resolution) + " " + bottom);
    for (i = _i = fromSlice; fromSlice <= toSlice ? _i <= toSlice : _i >= toSlice; i = fromSlice <= toSlice ? ++_i : --_i) {
      sliceStart = i * sliceSize + windowStart;
      sliceEnd = sliceStart + sliceSize;
      x = i * width / resolution;
      y = 0;
      for (j = _j = _ref = Math.floor(sliceStart), _ref1 = Math.floor(sliceEnd); _ref <= _ref1 ? _j < _ref1 : _j > _ref1; j = _ref <= _ref1 ? ++_j : --_j) {
        v = Math.abs(sampleData[j]);
        if (v > y) {
          y = v;
        }
      }
      y = (((1 - y) * height) || 0) + top;
      points.push("" + x + " " + y);
    }
    points.push("" + x + " " + bottom);
    d = "M " + (points.join(' L '));
    if (this.props.selection) {
      className = 'selection';
    }
    return React.DOM.path({
      "className": className,
      "d": d
    });
  }
});



},{"react/addons":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/addons.js"}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/util/cursor.coffee":[function(require,module,exports){
var actions, apply, nextId;

nextId = 0;

actions = {};

apply = function() {
  var action, id, max;
  max = null;
  for (id in actions) {
    action = actions[id];
    if ((max == null) || action.priority > actions[max].priority) {
      max = id;
    }
  }
  return document.body.style.cursor = max ? actions[max].value : 'default';
};

module.exports = {
  set: function(value, priority, id) {
    id || (id = nextId += 1);
    actions[id] = {
      value: value,
      priority: priority
    };
    apply();
    return id;
  },
  clear: function(id) {
    delete actions[id];
    return apply();
  }
};



},{}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/util/key_options.coffee":[function(require,module,exports){
var React, keys;

React = require('react');

keys = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

module.exports = function() {
  var i, note, octave, _i, _results;
  _results = [];
  for (i = _i = 127; _i >= 0; i = --_i) {
    octave = Math.floor(i / 12) - 2;
    note = keys[i % 12];
    _results.push(React.DOM.option({
      "key": i,
      "value": i
    }, "" + note + octave));
  }
  return _results;
};



},{"react":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/react.js"}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/util/keyboard.coffee":[function(require,module,exports){
var Keyboard,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

Keyboard = {
  callbacks: {},
  pressed: {},
  restricted: [8, 32, 37, 38, 39, 40],
  on: function(key, fn) {
    var _base;
    (_base = this.callbacks)[key] || (_base[key] = []);
    return this.callbacks[key].push(fn);
  },
  off: function(key, fn) {
    var i;
    i = this.callbacks[key].indexOf(fn);
    if (i >= 0) {
      return this.callbacks[key].splice(i, 1);
    }
  }
};

window.addEventListener('keydown', function(e) {
  var fn, _i, _len, _ref, _ref1, _results;
  Keyboard.pressed[e.keyCode] = true;
  if (_ref = e.keyCode, __indexOf.call(Keyboard.restricted, _ref) >= 0) {
    e.preventDefault();
  }
  if (Keyboard.callbacks[e.keyCode] != null) {
    _ref1 = Keyboard.callbacks[e.keyCode];
    _results = [];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      fn = _ref1[_i];
      _results.push(fn(e));
    }
    return _results;
  }
});

window.addEventListener('keyup', function(e) {
  return Keyboard.pressed[e.keyCode] = false;
});

module.exports = Keyboard;



},{}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/util/log_sample.coffee":[function(require,module,exports){
var i;

i = 0;

module.exports = function(v) {
  if (i === 0) {
    console.log(v);
  }
  return i = (i + 1) % 10000;
};



},{}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/util/ring_buffer.coffee":[function(require,module,exports){
var RingBuffer;

module.exports = RingBuffer = (function() {
  function RingBuffer(maxLength, Type, length) {
    this.maxLength = maxLength;
    this.Type = Type != null ? Type : Float32Array;
    this.length = length;
    this.length || (this.length = this.maxLength);
    this.array = new Type(this.maxLength);
    this.pos = 0;
  }

  RingBuffer.prototype.reset = function() {
    this.array = new this.Type(this.maxLength);
    return this;
  };

  RingBuffer.prototype.resize = function(length) {
    this.length = length;
    if (this.pos >= this.length) {
      return this.pos = 0;
    }
  };

  RingBuffer.prototype.push = function(el) {
    this.array[this.pos] = el;
    this.pos += 1;
    if (this.pos === this.length) {
      this.pos = 0;
    }
    return this;
  };

  RingBuffer.prototype.forEach = function(fn) {
    var i, len;
    for (i = this.pos, len = this.length; i < len; i++) {
      fn(this.array[i], i);
    }
    for (i = 0, len = this.pos; i < len; i++) {
      fn(this.array[i], i);
    };
    return this;
  };

  RingBuffer.prototype.reduce = function(fn, memo) {
    if (memo == null) {
      memo = 0;
    }
    this.forEach(function(el, i) {
      return memo = fn(memo, el, i);
    });
    return memo;
  };

  return RingBuffer;

})();



},{}],"/Users/charlieschwabacher/Code/sinesaw/app/scripts/util/transpose_options.coffee":[function(require,module,exports){
var React;

React = require('react');

module.exports = function() {
  var i, _i, _results;
  _results = [];
  for (i = _i = 24; _i >= -24; i = --_i) {
    _results.push(React.DOM.option({
      "key": i,
      "value": i
    }, i));
  }
  return _results;
};



},{"react":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/react.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/async/lib/async.js":[function(require,module,exports){
(function (process){
/*!
 * async
 * https://github.com/caolan/async
 *
 * Copyright 2010-2014 Caolan McMahon
 * Released under the MIT license
 */
/*jshint onevar: false, indent:4 */
/*global setImmediate: false, setTimeout: false, console: false */
(function () {

    var async = {};

    // global on the server, window in the browser
    var root, previous_async;

    root = this;
    if (root != null) {
      previous_async = root.async;
    }

    async.noConflict = function () {
        root.async = previous_async;
        return async;
    };

    function only_once(fn) {
        var called = false;
        return function() {
            if (called) throw new Error("Callback was already called.");
            called = true;
            fn.apply(root, arguments);
        }
    }

    //// cross-browser compatiblity functions ////

    var _toString = Object.prototype.toString;

    var _isArray = Array.isArray || function (obj) {
        return _toString.call(obj) === '[object Array]';
    };

    var _each = function (arr, iterator) {
        if (arr.forEach) {
            return arr.forEach(iterator);
        }
        for (var i = 0; i < arr.length; i += 1) {
            iterator(arr[i], i, arr);
        }
    };

    var _map = function (arr, iterator) {
        if (arr.map) {
            return arr.map(iterator);
        }
        var results = [];
        _each(arr, function (x, i, a) {
            results.push(iterator(x, i, a));
        });
        return results;
    };

    var _reduce = function (arr, iterator, memo) {
        if (arr.reduce) {
            return arr.reduce(iterator, memo);
        }
        _each(arr, function (x, i, a) {
            memo = iterator(memo, x, i, a);
        });
        return memo;
    };

    var _keys = function (obj) {
        if (Object.keys) {
            return Object.keys(obj);
        }
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    };

    //// exported async module functions ////

    //// nextTick implementation with browser-compatible fallback ////
    if (typeof process === 'undefined' || !(process.nextTick)) {
        if (typeof setImmediate === 'function') {
            async.nextTick = function (fn) {
                // not a direct alias for IE10 compatibility
                setImmediate(fn);
            };
            async.setImmediate = async.nextTick;
        }
        else {
            async.nextTick = function (fn) {
                setTimeout(fn, 0);
            };
            async.setImmediate = async.nextTick;
        }
    }
    else {
        async.nextTick = process.nextTick;
        if (typeof setImmediate !== 'undefined') {
            async.setImmediate = function (fn) {
              // not a direct alias for IE10 compatibility
              setImmediate(fn);
            };
        }
        else {
            async.setImmediate = async.nextTick;
        }
    }

    async.each = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        _each(arr, function (x) {
            iterator(x, only_once(done) );
        });
        function done(err) {
          if (err) {
              callback(err);
              callback = function () {};
          }
          else {
              completed += 1;
              if (completed >= arr.length) {
                  callback();
              }
          }
        }
    };
    async.forEach = async.each;

    async.eachSeries = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        var iterate = function () {
            iterator(arr[completed], function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback();
                    }
                    else {
                        iterate();
                    }
                }
            });
        };
        iterate();
    };
    async.forEachSeries = async.eachSeries;

    async.eachLimit = function (arr, limit, iterator, callback) {
        var fn = _eachLimit(limit);
        fn.apply(null, [arr, iterator, callback]);
    };
    async.forEachLimit = async.eachLimit;

    var _eachLimit = function (limit) {

        return function (arr, iterator, callback) {
            callback = callback || function () {};
            if (!arr.length || limit <= 0) {
                return callback();
            }
            var completed = 0;
            var started = 0;
            var running = 0;

            (function replenish () {
                if (completed >= arr.length) {
                    return callback();
                }

                while (running < limit && started < arr.length) {
                    started += 1;
                    running += 1;
                    iterator(arr[started - 1], function (err) {
                        if (err) {
                            callback(err);
                            callback = function () {};
                        }
                        else {
                            completed += 1;
                            running -= 1;
                            if (completed >= arr.length) {
                                callback();
                            }
                            else {
                                replenish();
                            }
                        }
                    });
                }
            })();
        };
    };


    var doParallel = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.each].concat(args));
        };
    };
    var doParallelLimit = function(limit, fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [_eachLimit(limit)].concat(args));
        };
    };
    var doSeries = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.eachSeries].concat(args));
        };
    };


    var _asyncMap = function (eachfn, arr, iterator, callback) {
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        if (!callback) {
            eachfn(arr, function (x, callback) {
                iterator(x.value, function (err) {
                    callback(err);
                });
            });
        } else {
            var results = [];
            eachfn(arr, function (x, callback) {
                iterator(x.value, function (err, v) {
                    results[x.index] = v;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };
    async.map = doParallel(_asyncMap);
    async.mapSeries = doSeries(_asyncMap);
    async.mapLimit = function (arr, limit, iterator, callback) {
        return _mapLimit(limit)(arr, iterator, callback);
    };

    var _mapLimit = function(limit) {
        return doParallelLimit(limit, _asyncMap);
    };

    // reduce only has a series version, as doing reduce in parallel won't
    // work in many situations.
    async.reduce = function (arr, memo, iterator, callback) {
        async.eachSeries(arr, function (x, callback) {
            iterator(memo, x, function (err, v) {
                memo = v;
                callback(err);
            });
        }, function (err) {
            callback(err, memo);
        });
    };
    // inject alias
    async.inject = async.reduce;
    // foldl alias
    async.foldl = async.reduce;

    async.reduceRight = function (arr, memo, iterator, callback) {
        var reversed = _map(arr, function (x) {
            return x;
        }).reverse();
        async.reduce(reversed, memo, iterator, callback);
    };
    // foldr alias
    async.foldr = async.reduceRight;

    var _filter = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.filter = doParallel(_filter);
    async.filterSeries = doSeries(_filter);
    // select alias
    async.select = async.filter;
    async.selectSeries = async.filterSeries;

    var _reject = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (!v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.reject = doParallel(_reject);
    async.rejectSeries = doSeries(_reject);

    var _detect = function (eachfn, arr, iterator, main_callback) {
        eachfn(arr, function (x, callback) {
            iterator(x, function (result) {
                if (result) {
                    main_callback(x);
                    main_callback = function () {};
                }
                else {
                    callback();
                }
            });
        }, function (err) {
            main_callback();
        });
    };
    async.detect = doParallel(_detect);
    async.detectSeries = doSeries(_detect);

    async.some = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (v) {
                    main_callback(true);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(false);
        });
    };
    // any alias
    async.any = async.some;

    async.every = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (!v) {
                    main_callback(false);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(true);
        });
    };
    // all alias
    async.all = async.every;

    async.sortBy = function (arr, iterator, callback) {
        async.map(arr, function (x, callback) {
            iterator(x, function (err, criteria) {
                if (err) {
                    callback(err);
                }
                else {
                    callback(null, {value: x, criteria: criteria});
                }
            });
        }, function (err, results) {
            if (err) {
                return callback(err);
            }
            else {
                var fn = function (left, right) {
                    var a = left.criteria, b = right.criteria;
                    return a < b ? -1 : a > b ? 1 : 0;
                };
                callback(null, _map(results.sort(fn), function (x) {
                    return x.value;
                }));
            }
        });
    };

    async.auto = function (tasks, callback) {
        callback = callback || function () {};
        var keys = _keys(tasks);
        var remainingTasks = keys.length
        if (!remainingTasks) {
            return callback();
        }

        var results = {};

        var listeners = [];
        var addListener = function (fn) {
            listeners.unshift(fn);
        };
        var removeListener = function (fn) {
            for (var i = 0; i < listeners.length; i += 1) {
                if (listeners[i] === fn) {
                    listeners.splice(i, 1);
                    return;
                }
            }
        };
        var taskComplete = function () {
            remainingTasks--
            _each(listeners.slice(0), function (fn) {
                fn();
            });
        };

        addListener(function () {
            if (!remainingTasks) {
                var theCallback = callback;
                // prevent final callback from calling itself if it errors
                callback = function () {};

                theCallback(null, results);
            }
        });

        _each(keys, function (k) {
            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];
            var taskCallback = function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                    args = args[0];
                }
                if (err) {
                    var safeResults = {};
                    _each(_keys(results), function(rkey) {
                        safeResults[rkey] = results[rkey];
                    });
                    safeResults[k] = args;
                    callback(err, safeResults);
                    // stop subsequent errors hitting callback multiple times
                    callback = function () {};
                }
                else {
                    results[k] = args;
                    async.setImmediate(taskComplete);
                }
            };
            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
            var ready = function () {
                return _reduce(requires, function (a, x) {
                    return (a && results.hasOwnProperty(x));
                }, true) && !results.hasOwnProperty(k);
            };
            if (ready()) {
                task[task.length - 1](taskCallback, results);
            }
            else {
                var listener = function () {
                    if (ready()) {
                        removeListener(listener);
                        task[task.length - 1](taskCallback, results);
                    }
                };
                addListener(listener);
            }
        });
    };

    async.retry = function(times, task, callback) {
        var DEFAULT_TIMES = 5;
        var attempts = [];
        // Use defaults if times not passed
        if (typeof times === 'function') {
            callback = task;
            task = times;
            times = DEFAULT_TIMES;
        }
        // Make sure times is a number
        times = parseInt(times, 10) || DEFAULT_TIMES;
        var wrappedTask = function(wrappedCallback, wrappedResults) {
            var retryAttempt = function(task, finalAttempt) {
                return function(seriesCallback) {
                    task(function(err, result){
                        seriesCallback(!err || finalAttempt, {err: err, result: result});
                    }, wrappedResults);
                };
            };
            while (times) {
                attempts.push(retryAttempt(task, !(times-=1)));
            }
            async.series(attempts, function(done, data){
                data = data[data.length - 1];
                (wrappedCallback || callback)(data.err, data.result);
            });
        }
        // If a callback is passed, run this as a controll flow
        return callback ? wrappedTask() : wrappedTask
    };

    async.waterfall = function (tasks, callback) {
        callback = callback || function () {};
        if (!_isArray(tasks)) {
          var err = new Error('First argument to waterfall must be an array of functions');
          return callback(err);
        }
        if (!tasks.length) {
            return callback();
        }
        var wrapIterator = function (iterator) {
            return function (err) {
                if (err) {
                    callback.apply(null, arguments);
                    callback = function () {};
                }
                else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    var next = iterator.next();
                    if (next) {
                        args.push(wrapIterator(next));
                    }
                    else {
                        args.push(callback);
                    }
                    async.setImmediate(function () {
                        iterator.apply(null, args);
                    });
                }
            };
        };
        wrapIterator(async.iterator(tasks))();
    };

    var _parallel = function(eachfn, tasks, callback) {
        callback = callback || function () {};
        if (_isArray(tasks)) {
            eachfn.map(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            eachfn.each(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.parallel = function (tasks, callback) {
        _parallel({ map: async.map, each: async.each }, tasks, callback);
    };

    async.parallelLimit = function(tasks, limit, callback) {
        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
    };

    async.series = function (tasks, callback) {
        callback = callback || function () {};
        if (_isArray(tasks)) {
            async.mapSeries(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            async.eachSeries(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.iterator = function (tasks) {
        var makeCallback = function (index) {
            var fn = function () {
                if (tasks.length) {
                    tasks[index].apply(null, arguments);
                }
                return fn.next();
            };
            fn.next = function () {
                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
            };
            return fn;
        };
        return makeCallback(0);
    };

    async.apply = function (fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
            return fn.apply(
                null, args.concat(Array.prototype.slice.call(arguments))
            );
        };
    };

    var _concat = function (eachfn, arr, fn, callback) {
        var r = [];
        eachfn(arr, function (x, cb) {
            fn(x, function (err, y) {
                r = r.concat(y || []);
                cb(err);
            });
        }, function (err) {
            callback(err, r);
        });
    };
    async.concat = doParallel(_concat);
    async.concatSeries = doSeries(_concat);

    async.whilst = function (test, iterator, callback) {
        if (test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.whilst(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doWhilst = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            var args = Array.prototype.slice.call(arguments, 1);
            if (test.apply(null, args)) {
                async.doWhilst(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.until = function (test, iterator, callback) {
        if (!test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.until(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doUntil = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            var args = Array.prototype.slice.call(arguments, 1);
            if (!test.apply(null, args)) {
                async.doUntil(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.queue = function (worker, concurrency) {
        if (concurrency === undefined) {
            concurrency = 1;
        }
        function _insert(q, data, pos, callback) {
          if (!q.started){
            q.started = true;
          }
          if (!_isArray(data)) {
              data = [data];
          }
          if(data.length == 0) {
             // call drain immediately if there are no tasks
             return async.setImmediate(function() {
                 if (q.drain) {
                     q.drain();
                 }
             });
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  callback: typeof callback === 'function' ? callback : null
              };

              if (pos) {
                q.tasks.unshift(item);
              } else {
                q.tasks.push(item);
              }

              if (q.saturated && q.tasks.length === q.concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }

        var workers = 0;
        var q = {
            tasks: [],
            concurrency: concurrency,
            saturated: null,
            empty: null,
            drain: null,
            started: false,
            paused: false,
            push: function (data, callback) {
              _insert(q, data, false, callback);
            },
            kill: function () {
              q.drain = null;
              q.tasks = [];
            },
            unshift: function (data, callback) {
              _insert(q, data, true, callback);
            },
            process: function () {
                if (!q.paused && workers < q.concurrency && q.tasks.length) {
                    var task = q.tasks.shift();
                    if (q.empty && q.tasks.length === 0) {
                        q.empty();
                    }
                    workers += 1;
                    var next = function () {
                        workers -= 1;
                        if (task.callback) {
                            task.callback.apply(task, arguments);
                        }
                        if (q.drain && q.tasks.length + workers === 0) {
                            q.drain();
                        }
                        q.process();
                    };
                    var cb = only_once(next);
                    worker(task.data, cb);
                }
            },
            length: function () {
                return q.tasks.length;
            },
            running: function () {
                return workers;
            },
            idle: function() {
                return q.tasks.length + workers === 0;
            },
            pause: function () {
                if (q.paused === true) { return; }
                q.paused = true;
                q.process();
            },
            resume: function () {
                if (q.paused === false) { return; }
                q.paused = false;
                q.process();
            }
        };
        return q;
    };
    
    async.priorityQueue = function (worker, concurrency) {
        
        function _compareTasks(a, b){
          return a.priority - b.priority;
        };
        
        function _binarySearch(sequence, item, compare) {
          var beg = -1,
              end = sequence.length - 1;
          while (beg < end) {
            var mid = beg + ((end - beg + 1) >>> 1);
            if (compare(item, sequence[mid]) >= 0) {
              beg = mid;
            } else {
              end = mid - 1;
            }
          }
          return beg;
        }
        
        function _insert(q, data, priority, callback) {
          if (!q.started){
            q.started = true;
          }
          if (!_isArray(data)) {
              data = [data];
          }
          if(data.length == 0) {
             // call drain immediately if there are no tasks
             return async.setImmediate(function() {
                 if (q.drain) {
                     q.drain();
                 }
             });
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  priority: priority,
                  callback: typeof callback === 'function' ? callback : null
              };
              
              q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);

              if (q.saturated && q.tasks.length === q.concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }
        
        // Start with a normal queue
        var q = async.queue(worker, concurrency);
        
        // Override push to accept second parameter representing priority
        q.push = function (data, priority, callback) {
          _insert(q, data, priority, callback);
        };
        
        // Remove unshift function
        delete q.unshift;

        return q;
    };

    async.cargo = function (worker, payload) {
        var working     = false,
            tasks       = [];

        var cargo = {
            tasks: tasks,
            payload: payload,
            saturated: null,
            empty: null,
            drain: null,
            drained: true,
            push: function (data, callback) {
                if (!_isArray(data)) {
                    data = [data];
                }
                _each(data, function(task) {
                    tasks.push({
                        data: task,
                        callback: typeof callback === 'function' ? callback : null
                    });
                    cargo.drained = false;
                    if (cargo.saturated && tasks.length === payload) {
                        cargo.saturated();
                    }
                });
                async.setImmediate(cargo.process);
            },
            process: function process() {
                if (working) return;
                if (tasks.length === 0) {
                    if(cargo.drain && !cargo.drained) cargo.drain();
                    cargo.drained = true;
                    return;
                }

                var ts = typeof payload === 'number'
                            ? tasks.splice(0, payload)
                            : tasks.splice(0, tasks.length);

                var ds = _map(ts, function (task) {
                    return task.data;
                });

                if(cargo.empty) cargo.empty();
                working = true;
                worker(ds, function () {
                    working = false;

                    var args = arguments;
                    _each(ts, function (data) {
                        if (data.callback) {
                            data.callback.apply(null, args);
                        }
                    });

                    process();
                });
            },
            length: function () {
                return tasks.length;
            },
            running: function () {
                return working;
            }
        };
        return cargo;
    };

    var _console_fn = function (name) {
        return function (fn) {
            var args = Array.prototype.slice.call(arguments, 1);
            fn.apply(null, args.concat([function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (typeof console !== 'undefined') {
                    if (err) {
                        if (console.error) {
                            console.error(err);
                        }
                    }
                    else if (console[name]) {
                        _each(args, function (x) {
                            console[name](x);
                        });
                    }
                }
            }]));
        };
    };
    async.log = _console_fn('log');
    async.dir = _console_fn('dir');
    /*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/

    async.memoize = function (fn, hasher) {
        var memo = {};
        var queues = {};
        hasher = hasher || function (x) {
            return x;
        };
        var memoized = function () {
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            var key = hasher.apply(null, args);
            if (key in memo) {
                async.nextTick(function () {
                    callback.apply(null, memo[key]);
                });
            }
            else if (key in queues) {
                queues[key].push(callback);
            }
            else {
                queues[key] = [callback];
                fn.apply(null, args.concat([function () {
                    memo[key] = arguments;
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                      q[i].apply(null, arguments);
                    }
                }]));
            }
        };
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
    };

    async.unmemoize = function (fn) {
      return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
      };
    };

    async.times = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.map(counter, iterator, callback);
    };

    async.timesSeries = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.mapSeries(counter, iterator, callback);
    };

    async.seq = function (/* functions... */) {
        var fns = arguments;
        return function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            async.reduce(fns, args, function (newargs, fn, cb) {
                fn.apply(that, newargs.concat([function () {
                    var err = arguments[0];
                    var nextargs = Array.prototype.slice.call(arguments, 1);
                    cb(err, nextargs);
                }]))
            },
            function (err, results) {
                callback.apply(that, [err].concat(results));
            });
        };
    };

    async.compose = function (/* functions... */) {
      return async.seq.apply(null, Array.prototype.reverse.call(arguments));
    };

    var _applyEach = function (eachfn, fns /*args...*/) {
        var go = function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            return eachfn(fns, function (fn, cb) {
                fn.apply(that, args.concat([cb]));
            },
            callback);
        };
        if (arguments.length > 2) {
            var args = Array.prototype.slice.call(arguments, 2);
            return go.apply(this, args);
        }
        else {
            return go;
        }
    };
    async.applyEach = doParallel(_applyEach);
    async.applyEachSeries = doSeries(_applyEach);

    async.forever = function (fn, callback) {
        function next(err) {
            if (err) {
                if (callback) {
                    return callback(err);
                }
                throw err;
            }
            fn(next);
        }
        next();
    };

    // Node.js
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = async;
    }
    // AMD / RequireJS
    else if (typeof define !== 'undefined' && define.amd) {
        define([], function () {
            return async;
        });
    }
    // included directly via <script> tag
    else {
        root.async = async;
    }

}());

}).call(this,require('_process'))
},{"_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/base64-arraybuffer/lib/base64-arraybuffer.js":[function(require,module,exports){
/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */
(function(chars){
  "use strict";

  exports.encode = function(arraybuffer) {
    var bytes = new Uint8Array(arraybuffer),
    i, len = bytes.length, base64 = "";

    for (i = 0; i < len; i+=3) {
      base64 += chars[bytes[i] >> 2];
      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
      base64 += chars[bytes[i + 2] & 63];
    }

    if ((len % 3) === 2) {
      base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + "==";
    }

    return base64;
  };

  exports.decode =  function(base64) {
    var bufferLength = base64.length * 0.75,
    len = base64.length, i, p = 0,
    encoded1, encoded2, encoded3, encoded4;

    if (base64[base64.length - 1] === "=") {
      bufferLength--;
      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }

    var arraybuffer = new ArrayBuffer(bufferLength),
    bytes = new Uint8Array(arraybuffer);

    for (i = 0; i < len; i+=4) {
      encoded1 = chars.indexOf(base64[i]);
      encoded2 = chars.indexOf(base64[i+1]);
      encoded3 = chars.indexOf(base64[i+2]);
      encoded4 = chars.indexOf(base64[i+3]);

      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }

    return arraybuffer;
  };
})("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");

},{}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js":[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/cuid/dist/browser-cuid.js":[function(require,module,exports){
/**
 * cuid.js
 * Collision-resistant UID generator for browsers and node.
 * Sequential for fast db lookups and recency sorting.
 * Safe for element IDs and server-side lookups.
 *
 * Extracted from CLCTR
 * 
 * Copyright (c) Eric Elliott 2012
 * MIT License
 */

/*global window, navigator, document, require, process, module */
(function (app) {
  'use strict';
  var namespace = 'cuid',
    c = 0,
    blockSize = 4,
    base = 36,
    discreteValues = Math.pow(base, blockSize),

    pad = function pad(num, size) {
      var s = "000000000" + num;
      return s.substr(s.length-size);
    },

    randomBlock = function randomBlock() {
      return pad((Math.random() *
            discreteValues << 0)
            .toString(base), blockSize);
    },

    safeCounter = function () {
      c = (c < discreteValues) ? c : 0;
      c++; // this is not subliminal
      return c - 1;
    },

    api = function cuid() {
      // Starting with a lowercase letter makes
      // it HTML element ID friendly.
      var letter = 'c', // hard-coded allows for sequential access

        // timestamp
        // warning: this exposes the exact date and time
        // that the uid was created.
        timestamp = (new Date().getTime()).toString(base),

        // Prevent same-machine collisions.
        counter,

        // A few chars to generate distinct ids for different
        // clients (so different computers are far less
        // likely to generate the same id)
        fingerprint = api.fingerprint(),

        // Grab some more chars from Math.random()
        random = randomBlock() + randomBlock();

        counter = pad(safeCounter().toString(base), blockSize);

      return  (letter + timestamp + counter + fingerprint + random);
    };

  api.slug = function slug() {
    var date = new Date().getTime().toString(36),
      counter,
      print = api.fingerprint().slice(0,1) +
        api.fingerprint().slice(-1),
      random = randomBlock().slice(-2);

      counter = safeCounter().toString(36).slice(-4);

    return date.slice(-2) + 
      counter + print + random;
  };

  api.globalCount = function globalCount() {
    // We want to cache the results of this
    var cache = (function calc() {
        var i,
          count = 0;

        for (i in window) {
          count++;
        }

        return count;
      }());

    api.globalCount = function () { return cache; };
    return cache;
  };

  api.fingerprint = function browserPrint() {
    return pad((navigator.mimeTypes.length +
      navigator.userAgent.length).toString(36) +
      api.globalCount().toString(36), 4);
  };

  // don't change anything from here down.
  if (app.register) {
    app.register(namespace, api);
  } else if (typeof module !== 'undefined') {
    module.exports = api;
  } else {
    app[namespace] = api;
  }

}(this.applitude || this));

},{}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/immutable/dist/Immutable.js":[function(require,module,exports){
/**
 *  Copyright (c) 2014, Facebook, Inc.
 *  All rights reserved.
 *
 *  This source code is licensed under the BSD-style license found in the
 *  LICENSE file in the root directory of this source tree. An additional grant
 *  of patent rights can be found in the PATENTS file in the same directory.
 */
function universalModule() {
  var $Object = Object;

function createClass(ctor, methods, staticMethods, superClass) {
  var proto;
  if (superClass) {
    var superProto = superClass.prototype;
    proto = $Object.create(superProto);
  } else {
    proto = ctor.prototype;
  }
  $Object.keys(methods).forEach(function (key) {
    proto[key] = methods[key];
  });
  $Object.keys(staticMethods).forEach(function (key) {
    ctor[key] = staticMethods[key];
  });
  proto.constructor = ctor;
  ctor.prototype = proto;
  return ctor;
}

function superCall(self, proto, name, args) {
  return $Object.getPrototypeOf(proto)[name].apply(self, args);
}

function defaultSuperCall(self, proto, args) {
  superCall(self, proto, 'constructor', args);
}

var $traceurRuntime = {};
$traceurRuntime.createClass = createClass;
$traceurRuntime.superCall = superCall;
$traceurRuntime.defaultSuperCall = defaultSuperCall;
"use strict";
var SHIFT = 5;
var SIZE = 1 << SHIFT;
var MASK = SIZE - 1;
var NOT_SET = {};
var CHANGE_LENGTH = {value: false};
var DID_ALTER = {value: false};
function MakeRef(ref) {
  ref.value = false;
  return ref;
}
function SetRef(ref) {
  ref && (ref.value = true);
}
function OwnerID() {}
function arrCopy(arr, offset) {
  offset = offset || 0;
  var len = Math.max(0, arr.length - offset);
  var newArr = new Array(len);
  for (var ii = 0; ii < len; ii++) {
    newArr[ii] = arr[ii + offset];
  }
  return newArr;
}
var ITER_RESULT = {
  value: undefined,
  done: false
};
function iteratorValue(value) {
  ITER_RESULT.value = value;
  ITER_RESULT.done = false;
  return ITER_RESULT;
}
function iteratorDone() {
  ITER_RESULT.value = undefined;
  ITER_RESULT.done = true;
  return ITER_RESULT;
}
function invariant(condition, error) {
  if (!condition)
    throw new Error(error);
}
var DELETE = 'delete';
var ITERATOR = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';
function hash(o) {
  if (!o) {
    return 0;
  }
  if (o === true) {
    return 1;
  }
  var type = typeof o;
  if (type === 'number') {
    if ((o | 0) === o) {
      return o & HASH_MAX_VAL;
    }
    o = '' + o;
    type = 'string';
  }
  if (type === 'string') {
    return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);
  }
  if (o.hashCode) {
    return hash(typeof o.hashCode === 'function' ? o.hashCode() : o.hashCode);
  }
  return hashJSObj(o);
}
function cachedHashString(string) {
  var hash = STRING_HASH_CACHE[string];
  if (hash == null) {
    hash = hashString(string);
    if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
      STRING_HASH_CACHE_SIZE = 0;
      STRING_HASH_CACHE = {};
    }
    STRING_HASH_CACHE_SIZE++;
    STRING_HASH_CACHE[string] = hash;
  }
  return hash;
}
function hashString(string) {
  var hash = 0;
  for (var ii = 0; ii < string.length; ii++) {
    hash = (31 * hash + string.charCodeAt(ii)) & HASH_MAX_VAL;
  }
  return hash;
}
function hashJSObj(obj) {
  if (obj[UID_HASH_KEY]) {
    return obj[UID_HASH_KEY];
  }
  var uid = ++UID_HASH_COUNT & HASH_MAX_VAL;
  if (!isIE8) {
    try {
      Object.defineProperty(obj, UID_HASH_KEY, {
        'enumerable': false,
        'configurable': false,
        'writable': false,
        'value': uid
      });
      return uid;
    } catch (e) {
      isIE8 = true;
    }
  }
  obj[UID_HASH_KEY] = uid;
  return uid;
}
var HASH_MAX_VAL = 0x7FFFFFFF;
var UID_HASH_COUNT = 0;
var UID_HASH_KEY = '__immutablehash__';
if (typeof Symbol !== 'undefined') {
  UID_HASH_KEY = Symbol(UID_HASH_KEY);
}
var isIE8 = false;
var STRING_HASH_CACHE_MIN_STRLEN = 16;
var STRING_HASH_CACHE_MAX_SIZE = 255;
var STRING_HASH_CACHE_SIZE = 0;
var STRING_HASH_CACHE = {};
var Sequence = function Sequence(value) {
  return $Sequence.from(arguments.length === 1 ? value : Array.prototype.slice.call(arguments));
};
var $Sequence = Sequence;
($traceurRuntime.createClass)(Sequence, {
  toString: function() {
    return this.__toString('Seq {', '}');
  },
  __toString: function(head, tail) {
    if (this.length === 0) {
      return head + tail;
    }
    return head + ' ' + this.map(this.__toStringMapper).join(', ') + ' ' + tail;
  },
  __toStringMapper: function(v, k) {
    return k + ': ' + quoteString(v);
  },
  toJS: function() {
    return this.map((function(value) {
      return value instanceof $Sequence ? value.toJS() : value;
    })).__toJS();
  },
  toArray: function() {
    assertNotInfinite(this.length);
    var array = new Array(this.length || 0);
    this.valueSeq().forEach((function(v, i) {
      array[i] = v;
    }));
    return array;
  },
  toObject: function() {
    assertNotInfinite(this.length);
    var object = {};
    this.forEach((function(v, k) {
      object[k] = v;
    }));
    return object;
  },
  toVector: function() {
    assertNotInfinite(this.length);
    return Vector.from(this);
  },
  toMap: function() {
    assertNotInfinite(this.length);
    return Map.from(this);
  },
  toOrderedMap: function() {
    assertNotInfinite(this.length);
    return OrderedMap.from(this);
  },
  toSet: function() {
    assertNotInfinite(this.length);
    return Set.from(this);
  },
  hashCode: function() {
    return this.__hash || (this.__hash = this.length === Infinity ? 0 : this.reduce((function(h, v, k) {
      return (h + (hash(v) ^ (v === k ? 0 : hash(k)))) & HASH_MAX_VAL;
    }), 0));
  },
  equals: function(other) {
    if (this === other) {
      return true;
    }
    if (!(other instanceof $Sequence)) {
      return false;
    }
    if (this.length != null && other.length != null) {
      if (this.length !== other.length) {
        return false;
      }
      if (this.length === 0 && other.length === 0) {
        return true;
      }
    }
    if (this.__hash != null && other.__hash != null && this.__hash !== other.__hash) {
      return false;
    }
    return this.__deepEquals(other);
  },
  __deepEquals: function(other) {
    var entries = this.cacheResult().entrySeq().toArray();
    var iterations = 0;
    return other.every((function(v, k) {
      var entry = entries[iterations++];
      return is(k, entry[0]) && is(v, entry[1]);
    }));
  },
  join: function(separator) {
    separator = separator || ',';
    var string = '';
    var isFirst = true;
    this.forEach((function(v, k) {
      if (isFirst) {
        isFirst = false;
        string += v;
      } else {
        string += separator + v;
      }
    }));
    return string;
  },
  count: function(predicate, thisArg) {
    if (!predicate) {
      if (this.length == null) {
        this.length = this.forEach(returnTrue);
      }
      return this.length;
    }
    return this.filter(predicate, thisArg).count();
  },
  countBy: function(mapper, context) {
    var seq = this;
    return OrderedMap.empty().withMutations((function(map) {
      seq.forEach((function(value, key, collection) {
        map.update(mapper(value, key, collection), increment);
      }));
    }));
  },
  concat: function() {
    for (var values = [],
        $__1 = 0; $__1 < arguments.length; $__1++)
      values[$__1] = arguments[$__1];
    var sequences = [this].concat(values.map((function(value) {
      return $Sequence(value);
    })));
    var concatSequence = this.__makeSequence();
    concatSequence.length = sequences.reduce((function(sum, seq) {
      return sum != null && seq.length != null ? sum + seq.length : undefined;
    }), 0);
    concatSequence.__iterateUncached = (function(fn, reverse) {
      var iterations = 0;
      var stoppedIteration;
      var lastIndex = sequences.length - 1;
      for (var ii = 0; ii <= lastIndex && !stoppedIteration; ii++) {
        var seq = sequences[reverse ? lastIndex - ii : ii];
        iterations += seq.__iterate((function(v, k, c) {
          if (fn(v, k, c) === false) {
            stoppedIteration = true;
            return false;
          }
        }), reverse);
      }
      return iterations;
    });
    return concatSequence;
  },
  reverse: function() {
    var sequence = this;
    var reversedSequence = sequence.__makeSequence();
    reversedSequence.length = sequence.length;
    reversedSequence.__iterateUncached = (function(fn, reverse) {
      return sequence.__iterate(fn, !reverse);
    });
    reversedSequence.reverse = (function() {
      return sequence;
    });
    return reversedSequence;
  },
  keySeq: function() {
    return this.flip().valueSeq();
  },
  valueSeq: function() {
    var sequence = this;
    var valuesSequence = makeIndexedSequence(sequence);
    valuesSequence.length = sequence.length;
    valuesSequence.valueSeq = returnThis;
    valuesSequence.__iterateUncached = function(fn, reverse, flipIndices) {
      if (flipIndices && this.length == null) {
        return this.cacheResult().__iterate(fn, reverse, flipIndices);
      }
      var iterations = 0;
      var predicate;
      if (flipIndices) {
        iterations = this.length - 1;
        predicate = (function(v, k, c) {
          return fn(v, iterations--, c) !== false;
        });
      } else {
        predicate = (function(v, k, c) {
          return fn(v, iterations++, c) !== false;
        });
      }
      sequence.__iterate(predicate, reverse);
      return flipIndices ? this.length : iterations;
    };
    return valuesSequence;
  },
  entrySeq: function() {
    var sequence = this;
    if (sequence._cache) {
      return $Sequence(sequence._cache);
    }
    var entriesSequence = sequence.map(entryMapper).valueSeq();
    entriesSequence.fromEntries = (function() {
      return sequence;
    });
    return entriesSequence;
  },
  forEach: function(sideEffect, thisArg) {
    return this.__iterate(thisArg ? sideEffect.bind(thisArg) : sideEffect);
  },
  reduce: function(reducer, initialReduction, thisArg) {
    var reduction = initialReduction;
    this.forEach((function(v, k, c) {
      reduction = reducer.call(thisArg, reduction, v, k, c);
    }));
    return reduction;
  },
  reduceRight: function(reducer, initialReduction, thisArg) {
    return this.reverse(true).reduce(reducer, initialReduction, thisArg);
  },
  every: function(predicate, thisArg) {
    var returnValue = true;
    this.forEach((function(v, k, c) {
      if (!predicate.call(thisArg, v, k, c)) {
        returnValue = false;
        return false;
      }
    }));
    return returnValue;
  },
  some: function(predicate, thisArg) {
    return !this.every(not(predicate), thisArg);
  },
  first: function() {
    return this.find(returnTrue);
  },
  last: function() {
    return this.findLast(returnTrue);
  },
  rest: function() {
    return this.slice(1);
  },
  butLast: function() {
    return this.slice(0, -1);
  },
  has: function(searchKey) {
    return this.get(searchKey, NOT_SET) !== NOT_SET;
  },
  get: function(searchKey, notSetValue) {
    return this.find((function(_, key) {
      return is(key, searchKey);
    }), null, notSetValue);
  },
  getIn: function(searchKeyPath, notSetValue) {
    if (!searchKeyPath || searchKeyPath.length === 0) {
      return this;
    }
    return getInDeepSequence(this, searchKeyPath, notSetValue, 0);
  },
  contains: function(searchValue) {
    return this.find((function(value) {
      return is(value, searchValue);
    }), null, NOT_SET) !== NOT_SET;
  },
  find: function(predicate, thisArg, notSetValue) {
    var foundValue = notSetValue;
    this.forEach((function(v, k, c) {
      if (predicate.call(thisArg, v, k, c)) {
        foundValue = v;
        return false;
      }
    }));
    return foundValue;
  },
  findKey: function(predicate, thisArg) {
    var foundKey;
    this.forEach((function(v, k, c) {
      if (predicate.call(thisArg, v, k, c)) {
        foundKey = k;
        return false;
      }
    }));
    return foundKey;
  },
  findLast: function(predicate, thisArg, notSetValue) {
    return this.reverse(true).find(predicate, thisArg, notSetValue);
  },
  findLastKey: function(predicate, thisArg) {
    return this.reverse(true).findKey(predicate, thisArg);
  },
  flip: function() {
    var sequence = this;
    var flipSequence = makeSequence();
    flipSequence.length = sequence.length;
    flipSequence.flip = (function() {
      return sequence;
    });
    flipSequence.__iterateUncached = (function(fn, reverse) {
      return sequence.__iterate((function(v, k, c) {
        return fn(k, v, c) !== false;
      }), reverse);
    });
    return flipSequence;
  },
  map: function(mapper, thisArg) {
    var sequence = this;
    var mappedSequence = sequence.__makeSequence();
    mappedSequence.length = sequence.length;
    mappedSequence.__iterateUncached = (function(fn, reverse) {
      return sequence.__iterate((function(v, k, c) {
        return fn(mapper.call(thisArg, v, k, c), k, c) !== false;
      }), reverse);
    });
    return mappedSequence;
  },
  mapKeys: function(mapper, thisArg) {
    var sequence = this;
    var mappedSequence = sequence.__makeSequence();
    mappedSequence.length = sequence.length;
    mappedSequence.__iterateUncached = (function(fn, reverse) {
      return sequence.__iterate((function(v, k, c) {
        return fn(v, mapper.call(thisArg, k, v, c), c) !== false;
      }), reverse);
    });
    return mappedSequence;
  },
  filter: function(predicate, thisArg) {
    return filterFactory(this, predicate, thisArg, true, false);
  },
  slice: function(begin, end) {
    if (wholeSlice(begin, end, this.length)) {
      return this;
    }
    var resolvedBegin = resolveBegin(begin, this.length);
    var resolvedEnd = resolveEnd(end, this.length);
    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
      return this.entrySeq().slice(begin, end).fromEntrySeq();
    }
    var skipped = resolvedBegin === 0 ? this : this.skip(resolvedBegin);
    return resolvedEnd == null || resolvedEnd === this.length ? skipped : skipped.take(resolvedEnd - resolvedBegin);
  },
  take: function(amount) {
    var sequence = this;
    if (amount > sequence.length) {
      return sequence;
    }
    var takeSequence = sequence.__makeSequence();
    takeSequence.__iterateUncached = function(fn, reverse, flipIndices) {
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse, flipIndices);
      }
      var iterations = 0;
      sequence.__iterate((function(v, k, c) {
        if (iterations < amount && fn(v, k, c) !== false) {
          iterations++;
        } else {
          return false;
        }
      }), reverse, flipIndices);
      return iterations;
    };
    takeSequence.length = this.length && Math.min(this.length, amount);
    return takeSequence;
  },
  takeLast: function(amount, maintainIndices) {
    return this.reverse(maintainIndices).take(amount).reverse(maintainIndices);
  },
  takeWhile: function(predicate, thisArg) {
    var sequence = this;
    var takeSequence = sequence.__makeSequence();
    takeSequence.__iterateUncached = function(fn, reverse, flipIndices) {
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse, flipIndices);
      }
      var iterations = 0;
      sequence.__iterate((function(v, k, c) {
        if (predicate.call(thisArg, v, k, c) && fn(v, k, c) !== false) {
          iterations++;
        } else {
          return false;
        }
      }), reverse, flipIndices);
      return iterations;
    };
    return takeSequence;
  },
  takeUntil: function(predicate, thisArg, maintainIndices) {
    return this.takeWhile(not(predicate), thisArg, maintainIndices);
  },
  skip: function(amount, maintainIndices) {
    var sequence = this;
    if (amount === 0) {
      return sequence;
    }
    var skipSequence = sequence.__makeSequence();
    skipSequence.__iterateUncached = function(fn, reverse, flipIndices) {
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse, flipIndices);
      }
      var isSkipping = true;
      var iterations = 0;
      var skipped = 0;
      sequence.__iterate((function(v, k, c) {
        if (!(isSkipping && (isSkipping = skipped++ < amount))) {
          if (fn(v, k, c) !== false) {
            iterations++;
          } else {
            return false;
          }
        }
      }), reverse, flipIndices);
      return iterations;
    };
    skipSequence.length = this.length && Math.max(0, this.length - amount);
    return skipSequence;
  },
  skipLast: function(amount, maintainIndices) {
    return this.reverse(maintainIndices).skip(amount).reverse(maintainIndices);
  },
  skipWhile: function(predicate, thisArg, maintainIndices) {
    var sequence = this;
    var skipSequence = sequence.__makeSequence();
    skipSequence.__iterateUncached = function(fn, reverse, flipIndices) {
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse, flipIndices);
      }
      var isSkipping = true;
      var iterations = 0;
      sequence.__iterate((function(v, k, c) {
        if (!(isSkipping && (isSkipping = predicate.call(thisArg, v, k, c)))) {
          if (fn(v, k, c) !== false) {
            iterations++;
          } else {
            return false;
          }
        }
      }), reverse, flipIndices);
      return iterations;
    };
    return skipSequence;
  },
  skipUntil: function(predicate, thisArg, maintainIndices) {
    return this.skipWhile(not(predicate), thisArg, maintainIndices);
  },
  groupBy: function(mapper, context) {
    var seq = this;
    var groups = OrderedMap.empty().withMutations((function(map) {
      seq.forEach((function(value, key, collection) {
        var groupKey = mapper(value, key, collection);
        var group = map.get(groupKey, NOT_SET);
        if (group === NOT_SET) {
          group = [];
          map.set(groupKey, group);
        }
        group.push([key, value]);
      }));
    }));
    return groups.map((function(group) {
      return $Sequence(group).fromEntrySeq();
    }));
  },
  sort: function(comparator, maintainIndices) {
    return this.sortBy(valueMapper, comparator, maintainIndices);
  },
  sortBy: function(mapper, comparator, maintainIndices) {
    comparator = comparator || defaultComparator;
    var seq = this;
    return $Sequence(this.entrySeq().entrySeq().toArray().sort((function(indexedEntryA, indexedEntryB) {
      return comparator(mapper(indexedEntryA[1][1], indexedEntryA[1][0], seq), mapper(indexedEntryB[1][1], indexedEntryB[1][0], seq)) || indexedEntryA[0] - indexedEntryB[0];
    }))).fromEntrySeq().valueSeq().fromEntrySeq();
  },
  cacheResult: function() {
    if (!this._cache && this.__iterateUncached) {
      assertNotInfinite(this.length);
      this._cache = this.entrySeq().toArray();
      if (this.length == null) {
        this.length = this._cache.length;
      }
    }
    return this;
  },
  __iterate: function(fn, reverse, flipIndices) {
    if (!this._cache) {
      return this.__iterateUncached(fn, reverse, flipIndices);
    }
    var maxIndex = this.length - 1;
    var cache = this._cache;
    var c = this;
    if (reverse) {
      for (var ii = cache.length - 1; ii >= 0; ii--) {
        var revEntry = cache[ii];
        if (fn(revEntry[1], flipIndices ? revEntry[0] : maxIndex - revEntry[0], c) === false) {
          break;
        }
      }
    } else {
      cache.every(flipIndices ? (function(entry) {
        return fn(entry[1], maxIndex - entry[0], c) !== false;
      }) : (function(entry) {
        return fn(entry[1], entry[0], c) !== false;
      }));
    }
    return this.length;
  },
  __makeSequence: function() {
    return makeSequence();
  }
}, {from: function(value) {
    if (value instanceof $Sequence) {
      return value;
    }
    if (!Array.isArray(value)) {
      if (value && value.constructor === Object) {
        return new ObjectSequence(value);
      }
      value = [value];
    }
    return new ArraySequence(value);
  }});
var SequencePrototype = Sequence.prototype;
SequencePrototype.toJSON = SequencePrototype.toJS;
SequencePrototype.__toJS = SequencePrototype.toObject;
SequencePrototype.inspect = SequencePrototype.toSource = function() {
  return this.toString();
};
var IndexedSequence = function IndexedSequence() {
  $traceurRuntime.defaultSuperCall(this, $IndexedSequence.prototype, arguments);
};
var $IndexedSequence = IndexedSequence;
($traceurRuntime.createClass)(IndexedSequence, {
  toString: function() {
    return this.__toString('Seq [', ']');
  },
  toArray: function() {
    assertNotInfinite(this.length);
    var array = new Array(this.length || 0);
    array.length = this.forEach((function(v, i) {
      array[i] = v;
    }));
    return array;
  },
  fromEntrySeq: function() {
    var sequence = this;
    var fromEntriesSequence = makeSequence();
    fromEntriesSequence.length = sequence.length;
    fromEntriesSequence.entrySeq = (function() {
      return sequence;
    });
    fromEntriesSequence.__iterateUncached = (function(fn, reverse, flipIndices) {
      return sequence.__iterate((function(entry, _, c) {
        return fn(entry[1], entry[0], c);
      }), reverse, flipIndices);
    });
    return fromEntriesSequence;
  },
  join: function(separator) {
    separator = separator || ',';
    var string = '';
    var prevIndex = 0;
    this.forEach((function(v, i) {
      var numSeparators = i - prevIndex;
      prevIndex = i;
      string += (numSeparators === 1 ? separator : repeatString(separator, numSeparators)) + v;
    }));
    if (this.length && prevIndex < this.length - 1) {
      string += repeatString(separator, this.length - 1 - prevIndex);
    }
    return string;
  },
  concat: function() {
    for (var values = [],
        $__2 = 0; $__2 < arguments.length; $__2++)
      values[$__2] = arguments[$__2];
    var sequences = [this].concat(values).map((function(value) {
      return Sequence(value);
    }));
    var concatSequence = this.__makeSequence();
    concatSequence.length = sequences.reduce((function(sum, seq) {
      return sum != null && seq.length != null ? sum + seq.length : undefined;
    }), 0);
    concatSequence.__iterateUncached = function(fn, reverse, flipIndices) {
      if (flipIndices && !this.length) {
        return this.cacheResult().__iterate(fn, reverse, flipIndices);
      }
      var iterations = 0;
      var stoppedIteration;
      var maxIndex = flipIndices && this.length - 1;
      var maxSequencesIndex = sequences.length - 1;
      for (var ii = 0; ii <= maxSequencesIndex && !stoppedIteration; ii++) {
        var sequence = sequences[reverse ? maxSequencesIndex - ii : ii];
        if (!(sequence instanceof $IndexedSequence)) {
          sequence = sequence.valueSeq();
        }
        iterations += sequence.__iterate((function(v, index, c) {
          index += iterations;
          if (fn(v, flipIndices ? maxIndex - index : index, c) === false) {
            stoppedIteration = true;
            return false;
          }
        }), reverse);
      }
      return iterations;
    };
    return concatSequence;
  },
  reverse: function(maintainIndices) {
    var sequence = this;
    var reversedSequence = sequence.__makeSequence();
    reversedSequence.length = sequence.length;
    reversedSequence.__reversedIndices = !!(maintainIndices ^ sequence.__reversedIndices);
    reversedSequence.__iterateUncached = (function(fn, reverse, flipIndices) {
      return sequence.__iterate(fn, !reverse, flipIndices ^ maintainIndices);
    });
    reversedSequence.reverse = function(_maintainIndices) {
      return maintainIndices === _maintainIndices ? sequence : IndexedSequencePrototype.reverse.call(this, _maintainIndices);
    };
    return reversedSequence;
  },
  valueSeq: function() {
    var valuesSequence = $traceurRuntime.superCall(this, $IndexedSequence.prototype, "valueSeq", []);
    valuesSequence.length = undefined;
    return valuesSequence;
  },
  filter: function(predicate, thisArg, maintainIndices) {
    var filterSequence = filterFactory(this, predicate, thisArg, maintainIndices, maintainIndices);
    if (maintainIndices) {
      filterSequence.length = this.length;
    }
    return filterSequence;
  },
  indexOf: function(searchValue) {
    return this.findIndex((function(value) {
      return is(value, searchValue);
    }));
  },
  lastIndexOf: function(searchValue) {
    return this.reverse(true).indexOf(searchValue);
  },
  findIndex: function(predicate, thisArg) {
    var key = this.findKey(predicate, thisArg);
    return key == null ? -1 : key;
  },
  findLastIndex: function(predicate, thisArg) {
    return this.reverse(true).findIndex(predicate, thisArg);
  },
  slice: function(begin, end, maintainIndices) {
    var sequence = this;
    if (wholeSlice(begin, end, sequence.length)) {
      return sequence;
    }
    var sliceSequence = sequence.__makeSequence();
    var resolvedBegin = resolveBegin(begin, sequence.length);
    var resolvedEnd = resolveEnd(end, sequence.length);
    sliceSequence.length = sequence.length && (maintainIndices ? sequence.length : resolvedEnd - resolvedBegin);
    sliceSequence.__reversedIndices = sequence.__reversedIndices;
    sliceSequence.__iterateUncached = function(fn, reverse, flipIndices) {
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse, flipIndices);
      }
      var reversedIndices = this.__reversedIndices ^ flipIndices;
      if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd || (reversedIndices && sequence.length == null)) {
        var exactLength = sequence.count();
        resolvedBegin = resolveBegin(begin, exactLength);
        resolvedEnd = resolveEnd(end, exactLength);
      }
      var iiBegin = reversedIndices ? sequence.length - resolvedEnd : resolvedBegin;
      var iiEnd = reversedIndices ? sequence.length - resolvedBegin : resolvedEnd;
      var lengthIterated = sequence.__iterate((function(v, ii, c) {
        return reversedIndices ? (iiEnd != null && ii >= iiEnd) || (ii >= iiBegin) && fn(v, maintainIndices ? ii : ii - iiBegin, c) !== false : (ii < iiBegin) || (iiEnd == null || ii < iiEnd) && fn(v, maintainIndices ? ii : ii - iiBegin, c) !== false;
      }), reverse, flipIndices);
      return this.length != null ? this.length : maintainIndices ? lengthIterated : Math.max(0, lengthIterated - iiBegin);
    };
    return sliceSequence;
  },
  splice: function(index, removeNum) {
    var numArgs = arguments.length;
    removeNum = Math.max(removeNum | 0, 0);
    if (numArgs === 0 || (numArgs === 2 && !removeNum)) {
      return this;
    }
    index = resolveBegin(index, this.length);
    var spliced = this.slice(0, index);
    return numArgs === 1 ? spliced : spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum));
  },
  take: function(amount) {
    var sequence = this;
    if (amount > sequence.length) {
      return sequence;
    }
    var takeSequence = sequence.__makeSequence();
    takeSequence.__iterateUncached = function(fn, reverse, flipIndices) {
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse, flipIndices);
      }
      var taken = 0;
      var iterations = 0;
      var didFinish = true;
      var length = sequence.__iterate((function(v, ii, c) {
        if (taken++ < amount && fn(v, ii, c) !== false) {
          iterations = ii;
        } else {
          didFinish = false;
          return false;
        }
      }), reverse, flipIndices);
      return didFinish ? length : iterations + 1;
    };
    takeSequence.length = this.length && Math.min(this.length, amount);
    return takeSequence;
  },
  takeWhile: function(predicate, thisArg, maintainIndices) {
    var sequence = this;
    var takeSequence = sequence.__makeSequence();
    takeSequence.__iterateUncached = function(fn, reverse, flipIndices) {
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse, flipIndices);
      }
      var iterations = 0;
      var didFinish = true;
      var length = sequence.__iterate((function(v, ii, c) {
        if (predicate.call(thisArg, v, ii, c) && fn(v, ii, c) !== false) {
          iterations = ii;
        } else {
          didFinish = false;
          return false;
        }
      }), reverse, flipIndices);
      return maintainIndices ? takeSequence.length : didFinish ? length : iterations + 1;
    };
    if (maintainIndices) {
      takeSequence.length = this.length;
    }
    return takeSequence;
  },
  skip: function(amount, maintainIndices) {
    var sequence = this;
    if (amount === 0) {
      return sequence;
    }
    var skipSequence = sequence.__makeSequence();
    if (maintainIndices) {
      skipSequence.length = this.length;
    }
    skipSequence.__iterateUncached = function(fn, reverse, flipIndices) {
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse, flipIndices);
      }
      var reversedIndices = sequence.__reversedIndices ^ flipIndices;
      var isSkipping = true;
      var indexOffset = 0;
      var skipped = 0;
      var length = sequence.__iterate((function(v, ii, c) {
        if (isSkipping) {
          isSkipping = skipped++ < amount;
          if (!isSkipping) {
            indexOffset = ii;
          }
        }
        return isSkipping || fn(v, flipIndices || maintainIndices ? ii : ii - indexOffset, c) !== false;
      }), reverse, flipIndices);
      return maintainIndices ? length : reversedIndices ? indexOffset + 1 : length - indexOffset;
    };
    skipSequence.length = this.length && Math.max(0, this.length - amount);
    return skipSequence;
  },
  skipWhile: function(predicate, thisArg, maintainIndices) {
    var sequence = this;
    var skipWhileSequence = sequence.__makeSequence();
    if (maintainIndices) {
      skipWhileSequence.length = this.length;
    }
    skipWhileSequence.__iterateUncached = function(fn, reverse, flipIndices) {
      if (reverse) {
        return this.cacheResult().__iterate(fn, reverse, flipIndices);
      }
      var reversedIndices = sequence.__reversedIndices ^ flipIndices;
      var isSkipping = true;
      var indexOffset = 0;
      var length = sequence.__iterate((function(v, ii, c) {
        if (isSkipping) {
          isSkipping = predicate.call(thisArg, v, ii, c);
          if (!isSkipping) {
            indexOffset = ii;
          }
        }
        return isSkipping || fn(v, flipIndices || maintainIndices ? ii : ii - indexOffset, c) !== false;
      }), reverse, flipIndices);
      return maintainIndices ? length : reversedIndices ? indexOffset + 1 : length - indexOffset;
    };
    return skipWhileSequence;
  },
  groupBy: function(mapper, context, maintainIndices) {
    var seq = this;
    var groups = OrderedMap.empty().withMutations((function(map) {
      seq.forEach((function(value, index, collection) {
        var groupKey = mapper(value, index, collection);
        var group = map.get(groupKey, NOT_SET);
        if (group === NOT_SET) {
          group = new Array(maintainIndices ? seq.length : 0);
          map.set(groupKey, group);
        }
        maintainIndices ? (group[index] = value) : group.push(value);
      }));
    }));
    return groups.map((function(group) {
      return Sequence(group);
    }));
  },
  sortBy: function(mapper, comparator, maintainIndices) {
    var sortedSeq = $traceurRuntime.superCall(this, $IndexedSequence.prototype, "sortBy", [mapper, comparator]);
    if (!maintainIndices) {
      sortedSeq = sortedSeq.valueSeq();
    }
    sortedSeq.length = this.length;
    return sortedSeq;
  },
  __makeSequence: function() {
    return makeIndexedSequence(this);
  }
}, {}, Sequence);
var IndexedSequencePrototype = IndexedSequence.prototype;
IndexedSequencePrototype.__toJS = IndexedSequencePrototype.toArray;
IndexedSequencePrototype.__toStringMapper = quoteString;
var ObjectSequence = function ObjectSequence(object) {
  var keys = Object.keys(object);
  this._object = object;
  this._keys = keys;
  this.length = keys.length;
};
($traceurRuntime.createClass)(ObjectSequence, {
  toObject: function() {
    return this._object;
  },
  get: function(key, notSetValue) {
    if (notSetValue !== undefined && !this.has(key)) {
      return notSetValue;
    }
    return this._object[key];
  },
  has: function(key) {
    return this._object.hasOwnProperty(key);
  },
  __iterate: function(fn, reverse) {
    var object = this._object;
    var keys = this._keys;
    var maxIndex = keys.length - 1;
    for (var ii = 0; ii <= maxIndex; ii++) {
      var iteration = reverse ? maxIndex - ii : ii;
      if (fn(object[keys[iteration]], keys[iteration], object) === false) {
        break;
      }
    }
    return ii;
  }
}, {}, Sequence);
var ArraySequence = function ArraySequence(array) {
  this._array = array;
  this.length = array.length;
};
($traceurRuntime.createClass)(ArraySequence, {
  toArray: function() {
    return this._array;
  },
  __iterate: function(fn, reverse, flipIndices) {
    var array = this._array;
    var maxIndex = array.length - 1;
    var lastIndex = -1;
    if (reverse) {
      for (var ii = maxIndex; ii >= 0; ii--) {
        if (array.hasOwnProperty(ii) && fn(array[ii], flipIndices ? ii : maxIndex - ii, array) === false) {
          return lastIndex + 1;
        }
        lastIndex = ii;
      }
      return array.length;
    } else {
      var didFinish = array.every((function(value, index) {
        if (fn(value, flipIndices ? maxIndex - index : index, array) === false) {
          return false;
        } else {
          lastIndex = index;
          return true;
        }
      }));
      return didFinish ? array.length : lastIndex + 1;
    }
  }
}, {}, IndexedSequence);
ArraySequence.prototype.get = ObjectSequence.prototype.get;
ArraySequence.prototype.has = ObjectSequence.prototype.has;
var SequenceIterator = function SequenceIterator() {};
($traceurRuntime.createClass)(SequenceIterator, {toString: function() {
    return '[Iterator]';
  }}, {});
var SequenceIteratorPrototype = SequenceIterator.prototype;
SequenceIteratorPrototype[ITERATOR] = returnThis;
SequenceIteratorPrototype.inspect = SequenceIteratorPrototype.toSource = function() {
  return this.toString();
};
function makeSequence() {
  return Object.create(SequencePrototype);
}
function makeIndexedSequence(parent) {
  var newSequence = Object.create(IndexedSequencePrototype);
  newSequence.__reversedIndices = parent ? parent.__reversedIndices : false;
  return newSequence;
}
function getInDeepSequence(seq, keyPath, notSetValue, pathOffset) {
  var nested = seq.get ? seq.get(keyPath[pathOffset], NOT_SET) : NOT_SET;
  if (nested === NOT_SET) {
    return notSetValue;
  }
  if (++pathOffset === keyPath.length) {
    return nested;
  }
  return getInDeepSequence(nested, keyPath, notSetValue, pathOffset);
}
function wholeSlice(begin, end, length) {
  return (begin === 0 || (length != null && begin <= -length)) && (end == null || (length != null && end >= length));
}
function resolveBegin(begin, length) {
  return resolveIndex(begin, length, 0);
}
function resolveEnd(end, length) {
  return resolveIndex(end, length, length);
}
function resolveIndex(index, length, defaultIndex) {
  return index == null ? defaultIndex : index < 0 ? Math.max(0, length + index) : length ? Math.min(length, index) : index;
}
function valueMapper(v) {
  return v;
}
function entryMapper(v, k) {
  return [k, v];
}
function returnTrue() {
  return true;
}
function returnThis() {
  return this;
}
function increment(value) {
  return (value || 0) + 1;
}
function filterFactory(sequence, predicate, thisArg, useKeys, maintainIndices) {
  var filterSequence = sequence.__makeSequence();
  filterSequence.__iterateUncached = (function(fn, reverse, flipIndices) {
    var iterations = 0;
    var length = sequence.__iterate((function(v, k, c) {
      if (predicate.call(thisArg, v, k, c)) {
        if (fn(v, useKeys ? k : iterations, c) !== false) {
          iterations++;
        } else {
          return false;
        }
      }
    }), reverse, flipIndices);
    return maintainIndices ? length : iterations;
  });
  return filterSequence;
}
function not(predicate) {
  return function() {
    return !predicate.apply(this, arguments);
  };
}
function quoteString(value) {
  return typeof value === 'string' ? JSON.stringify(value) : value;
}
function repeatString(string, times) {
  var repeated = '';
  while (times) {
    if (times & 1) {
      repeated += string;
    }
    if ((times >>= 1)) {
      string += string;
    }
  }
  return repeated;
}
function defaultComparator(a, b) {
  return a > b ? 1 : a < b ? -1 : 0;
}
function assertNotInfinite(length) {
  invariant(length !== Infinity, 'Cannot perform this action with an infinite sequence.');
}
function iteratorMapper(iter, fn) {
  var newIter = new SequenceIterator();
  newIter.next = (function() {
    var step = iter.next();
    if (step.done)
      return step;
    step.value = fn(step.value);
    return step;
  });
  return newIter;
}
var Cursor = function Cursor(rootData, keyPath, onChange, value) {
  value = value ? value : rootData.getIn(keyPath);
  this.length = value instanceof Sequence ? value.length : null;
  this._rootData = rootData;
  this._keyPath = keyPath;
  this._onChange = onChange;
};
($traceurRuntime.createClass)(Cursor, {
  deref: function(notSetValue) {
    return this._rootData.getIn(this._keyPath, notSetValue);
  },
  get: function(key, notSetValue) {
    if (Array.isArray(key) && key.length === 0) {
      return this;
    }
    var value = this._rootData.getIn(this._keyPath.concat(key), NOT_SET);
    return value === NOT_SET ? notSetValue : wrappedValue(this, key, value);
  },
  set: function(key, value) {
    return updateCursor(this, (function(m) {
      return m.set(key, value);
    }), key);
  },
  remove: function(key) {
    return updateCursor(this, (function(m) {
      return m.remove(key);
    }), key);
  },
  clear: function() {
    return updateCursor(this, (function(m) {
      return m.clear();
    }));
  },
  update: function(keyOrFn, notSetValue, updater) {
    return arguments.length === 1 ? updateCursor(this, keyOrFn) : updateCursor(this, (function(map) {
      return map.update(keyOrFn, notSetValue, updater);
    }), keyOrFn);
  },
  withMutations: function(fn) {
    return updateCursor(this, (function(m) {
      return (m || Map.empty()).withMutations(fn);
    }));
  },
  cursor: function(subKey) {
    return Array.isArray(subKey) && subKey.length === 0 ? this : subCursor(this, subKey);
  },
  __iterate: function(fn, reverse, flipIndices) {
    var cursor = this;
    var deref = cursor.deref();
    return deref && deref.__iterate ? deref.__iterate((function(value, key, collection) {
      return fn(wrappedValue(cursor, key, value), key, collection);
    }), reverse, flipIndices) : 0;
  }
}, {}, Sequence);
Cursor.prototype[DELETE] = Cursor.prototype.remove;
Cursor.prototype.getIn = Cursor.prototype.get;
function wrappedValue(cursor, key, value) {
  return value instanceof Sequence ? subCursor(cursor, key, value) : value;
}
function subCursor(cursor, key, value) {
  return new Cursor(cursor._rootData, cursor._keyPath.concat(key), cursor._onChange, value);
}
function updateCursor(cursor, changeFn, changeKey) {
  var newRootData = cursor._rootData.updateIn(cursor._keyPath, changeKey ? Map.empty() : undefined, changeFn);
  var keyPath = cursor._keyPath || [];
  cursor._onChange && cursor._onChange.call(undefined, newRootData, cursor._rootData, changeKey ? keyPath.concat(changeKey) : keyPath);
  return new Cursor(newRootData, cursor._keyPath, cursor._onChange);
}
function is(first, second) {
  if (first instanceof Cursor) {
    first = first.deref();
  }
  if (second instanceof Cursor) {
    second = second.deref();
  }
  if (first === second) {
    return first !== 0 || second !== 0 || 1 / first === 1 / second;
  }
  if (first !== first) {
    return second !== second;
  }
  if (first instanceof Sequence) {
    return first.equals(second);
  }
  return false;
}
var Map = function Map(sequence) {
  var map = $Map.empty();
  return sequence ? sequence.constructor === $Map ? sequence : map.merge(sequence) : map;
};
var $Map = Map;
($traceurRuntime.createClass)(Map, {
  toString: function() {
    return this.__toString('Map {', '}');
  },
  get: function(k, notSetValue) {
    return this._root ? this._root.get(0, hash(k), k, notSetValue) : notSetValue;
  },
  set: function(k, v) {
    return updateMap(this, k, v);
  },
  remove: function(k) {
    return updateMap(this, k, NOT_SET);
  },
  update: function(k, notSetValue, updater) {
    return arguments.length === 1 ? this.updateIn([], null, k) : this.updateIn([k], notSetValue, updater);
  },
  updateIn: function(keyPath, notSetValue, updater) {
    var $__12;
    if (!updater) {
      ($__12 = [notSetValue, updater], updater = $__12[0], notSetValue = $__12[1], $__12);
    }
    return updateInDeepMap(this, keyPath, notSetValue, updater, 0);
  },
  clear: function() {
    if (this.length === 0) {
      return this;
    }
    if (this.__ownerID) {
      this.length = 0;
      this._root = null;
      this.__hash = undefined;
      this.__altered = true;
      return this;
    }
    return $Map.empty();
  },
  merge: function() {
    return mergeIntoMapWith(this, null, arguments);
  },
  mergeWith: function(merger) {
    for (var seqs = [],
        $__3 = 1; $__3 < arguments.length; $__3++)
      seqs[$__3 - 1] = arguments[$__3];
    return mergeIntoMapWith(this, merger, seqs);
  },
  mergeDeep: function() {
    return mergeIntoMapWith(this, deepMerger(null), arguments);
  },
  mergeDeepWith: function(merger) {
    for (var seqs = [],
        $__4 = 1; $__4 < arguments.length; $__4++)
      seqs[$__4 - 1] = arguments[$__4];
    return mergeIntoMapWith(this, deepMerger(merger), seqs);
  },
  cursor: function(keyPath, onChange) {
    if (!onChange && typeof keyPath === 'function') {
      onChange = keyPath;
      keyPath = [];
    } else if (arguments.length === 0) {
      keyPath = [];
    } else if (!Array.isArray(keyPath)) {
      keyPath = [keyPath];
    }
    return new Cursor(this, keyPath, onChange);
  },
  withMutations: function(fn) {
    var mutable = this.asMutable();
    fn(mutable);
    return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
  },
  asMutable: function() {
    return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
  },
  asImmutable: function() {
    return this.__ensureOwner();
  },
  wasAltered: function() {
    return this.__altered;
  },
  keys: function() {
    return new MapIterator(this, 0);
  },
  values: function() {
    return new MapIterator(this, 1);
  },
  entries: function() {
    return new MapIterator(this, 2);
  },
  __iterator: function(reverse) {
    return new MapIterator(this, 2, reverse);
  },
  __iterate: function(fn, reverse) {
    var map = this;
    if (!map._root) {
      return 0;
    }
    var iterations = 0;
    this._root.iterate((function(entry) {
      if (fn(entry[1], entry[0], map) === false) {
        return false;
      }
      iterations++;
    }), reverse);
    return iterations;
  },
  __deepEqual: function(other) {
    var self = this;
    return other.every((function(v, k) {
      return is(self.get(k, NOT_SET), v);
    }));
  },
  __ensureOwner: function(ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    if (!ownerID) {
      this.__ownerID = ownerID;
      this.__altered = false;
      return this;
    }
    return makeMap(this.length, this._root, ownerID, this.__hash);
  }
}, {empty: function() {
    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
  }}, Sequence);
var MapPrototype = Map.prototype;
MapPrototype[DELETE] = MapPrototype.remove;
MapPrototype[ITERATOR] = function() {
  return this.entries();
};
Map.from = Map;
var BitmapIndexedNode = function BitmapIndexedNode(ownerID, bitmap, nodes) {
  this.ownerID = ownerID;
  this.bitmap = bitmap;
  this.nodes = nodes;
};
var $BitmapIndexedNode = BitmapIndexedNode;
($traceurRuntime.createClass)(BitmapIndexedNode, {
  get: function(shift, hash, key, notSetValue) {
    var bit = (1 << ((hash >>> shift) & MASK));
    var bitmap = this.bitmap;
    return (bitmap & bit) === 0 ? notSetValue : this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, hash, key, notSetValue);
  },
  update: function(ownerID, shift, hash, key, value, didChangeLength, didAlter) {
    var hashFrag = (hash >>> shift) & MASK;
    var bit = 1 << hashFrag;
    var bitmap = this.bitmap;
    var exists = (bitmap & bit) !== 0;
    if (!exists && value === NOT_SET) {
      return this;
    }
    var idx = popCount(bitmap & (bit - 1));
    var nodes = this.nodes;
    var node = exists ? nodes[idx] : null;
    var newNode = updateNode(node, ownerID, shift + SHIFT, hash, key, value, didChangeLength, didAlter);
    if (newNode === node) {
      return this;
    }
    if (!exists && newNode && nodes.length >= MAX_BITMAP_SIZE) {
      return expandNodes(ownerID, nodes, bitmap, hashFrag, newNode);
    }
    if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
      return nodes[idx ^ 1];
    }
    if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
      return newNode;
    }
    var isEditable = ownerID && ownerID === this.ownerID;
    var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
    var newNodes = exists ? newNode ? setIn(nodes, idx, newNode, isEditable) : spliceOut(nodes, idx, isEditable) : spliceIn(nodes, idx, newNode, isEditable);
    if (isEditable) {
      this.bitmap = newBitmap;
      this.nodes = newNodes;
      return this;
    }
    return new $BitmapIndexedNode(ownerID, newBitmap, newNodes);
  },
  iterate: function(fn, reverse) {
    var nodes = this.nodes;
    for (var ii = 0,
        maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
      if (nodes[reverse ? maxIndex - ii : ii].iterate(fn, reverse) === false) {
        return false;
      }
    }
  }
}, {});
var ArrayNode = function ArrayNode(ownerID, count, nodes) {
  this.ownerID = ownerID;
  this.count = count;
  this.nodes = nodes;
};
var $ArrayNode = ArrayNode;
($traceurRuntime.createClass)(ArrayNode, {
  get: function(shift, hash, key, notSetValue) {
    var idx = (hash >>> shift) & MASK;
    var node = this.nodes[idx];
    return node ? node.get(shift + SHIFT, hash, key, notSetValue) : notSetValue;
  },
  update: function(ownerID, shift, hash, key, value, didChangeLength, didAlter) {
    var idx = (hash >>> shift) & MASK;
    var removed = value === NOT_SET;
    var nodes = this.nodes;
    var node = nodes[idx];
    if (removed && !node) {
      return this;
    }
    var newNode = updateNode(node, ownerID, shift + SHIFT, hash, key, value, didChangeLength, didAlter);
    if (newNode === node) {
      return this;
    }
    var newCount = this.count;
    if (!node) {
      newCount++;
    } else if (!newNode) {
      newCount--;
      if (newCount < MIN_ARRAY_SIZE) {
        return packNodes(ownerID, nodes, newCount, idx);
      }
    }
    var isEditable = ownerID && ownerID === this.ownerID;
    var newNodes = setIn(nodes, idx, newNode, isEditable);
    if (isEditable) {
      this.count = newCount;
      this.nodes = newNodes;
      return this;
    }
    return new $ArrayNode(ownerID, newCount, newNodes);
  },
  iterate: function(fn, reverse) {
    var nodes = this.nodes;
    for (var ii = 0,
        maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
      var node = nodes[reverse ? maxIndex - ii : ii];
      if (node && node.iterate(fn, reverse) === false) {
        return false;
      }
    }
  }
}, {});
var HashCollisionNode = function HashCollisionNode(ownerID, hash, entries) {
  this.ownerID = ownerID;
  this.hash = hash;
  this.entries = entries;
};
var $HashCollisionNode = HashCollisionNode;
($traceurRuntime.createClass)(HashCollisionNode, {
  get: function(shift, hash, key, notSetValue) {
    var entries = this.entries;
    for (var ii = 0,
        len = entries.length; ii < len; ii++) {
      if (is(key, entries[ii][0])) {
        return entries[ii][1];
      }
    }
    return notSetValue;
  },
  update: function(ownerID, shift, hash, key, value, didChangeLength, didAlter) {
    var removed = value === NOT_SET;
    if (hash !== this.hash) {
      if (removed) {
        return this;
      }
      SetRef(didAlter);
      SetRef(didChangeLength);
      return mergeIntoNode(this, ownerID, shift, hash, [key, value]);
    }
    var entries = this.entries;
    var idx = 0;
    for (var len = entries.length; idx < len; idx++) {
      if (is(key, entries[idx][0])) {
        break;
      }
    }
    var exists = idx < len;
    if (removed && !exists) {
      return this;
    }
    SetRef(didAlter);
    (removed || !exists) && SetRef(didChangeLength);
    if (removed && len === 2) {
      return new ValueNode(ownerID, this.hash, entries[idx ^ 1]);
    }
    var isEditable = ownerID && ownerID === this.ownerID;
    var newEntries = isEditable ? entries : arrCopy(entries);
    if (exists) {
      if (removed) {
        idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
      } else {
        newEntries[idx] = [key, value];
      }
    } else {
      newEntries.push([key, value]);
    }
    if (isEditable) {
      this.entries = newEntries;
      return this;
    }
    return new $HashCollisionNode(ownerID, this.hash, newEntries);
  },
  iterate: function(fn, reverse) {
    var entries = this.entries;
    for (var ii = 0,
        maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
        return false;
      }
    }
  }
}, {});
var ValueNode = function ValueNode(ownerID, hash, entry) {
  this.ownerID = ownerID;
  this.hash = hash;
  this.entry = entry;
};
var $ValueNode = ValueNode;
($traceurRuntime.createClass)(ValueNode, {
  get: function(shift, hash, key, notSetValue) {
    return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
  },
  update: function(ownerID, shift, hash, key, value, didChangeLength, didAlter) {
    var removed = value === NOT_SET;
    var keyMatch = is(key, this.entry[0]);
    if (keyMatch ? value === this.entry[1] : removed) {
      return this;
    }
    SetRef(didAlter);
    if (removed) {
      SetRef(didChangeLength);
      return null;
    }
    if (keyMatch) {
      if (ownerID && ownerID === this.ownerID) {
        this.entry[1] = value;
        return this;
      }
      return new $ValueNode(ownerID, hash, [key, value]);
    }
    SetRef(didChangeLength);
    return mergeIntoNode(this, ownerID, shift, hash, [key, value]);
  },
  iterate: function(fn) {
    return fn(this.entry);
  }
}, {});
var MapIterator = function MapIterator(map, type, reverse) {
  this._type = type;
  this._reverse = reverse;
  this._stack = map._root && mapIteratorFrame(map._root);
};
($traceurRuntime.createClass)(MapIterator, {next: function() {
    var type = this._type;
    var stack = this._stack;
    while (stack) {
      var node = stack.node;
      var index = stack.index++;
      var maxIndex;
      if (node.entry) {
        if (index === 0) {
          return mapIteratorValue(type, node.entry);
        }
      } else if (node.entries) {
        maxIndex = node.entries.length - 1;
        if (index <= maxIndex) {
          return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);
        }
      } else {
        maxIndex = node.nodes.length - 1;
        if (index <= maxIndex) {
          var subNode = node.nodes[this._reverse ? maxIndex - index : index];
          if (subNode) {
            if (subNode.entry) {
              return mapIteratorValue(type, subNode.entry);
            }
            stack = this._stack = mapIteratorFrame(subNode, stack);
          }
          continue;
        }
      }
      stack = this._stack = this._stack.__prev;
    }
    return iteratorDone();
  }}, {}, SequenceIterator);
function mapIteratorValue(type, entry) {
  return iteratorValue(type === 0 || type === 1 ? entry[type] : [entry[0], entry[1]]);
}
function mapIteratorFrame(node, prev) {
  return {
    node: node,
    index: 0,
    __prev: prev
  };
}
function makeMap(length, root, ownerID, hash) {
  var map = Object.create(MapPrototype);
  map.length = length;
  map._root = root;
  map.__ownerID = ownerID;
  map.__hash = hash;
  map.__altered = false;
  return map;
}
function updateMap(map, k, v) {
  var didChangeLength = MakeRef(CHANGE_LENGTH);
  var didAlter = MakeRef(DID_ALTER);
  var newRoot = updateNode(map._root, map.__ownerID, 0, hash(k), k, v, didChangeLength, didAlter);
  if (!didAlter.value) {
    return map;
  }
  var newLength = map.length + (didChangeLength.value ? v === NOT_SET ? -1 : 1 : 0);
  if (map.__ownerID) {
    map.length = newLength;
    map._root = newRoot;
    map.__hash = undefined;
    map.__altered = true;
    return map;
  }
  return newRoot ? makeMap(newLength, newRoot) : Map.empty();
}
function updateNode(node, ownerID, shift, hash, key, value, didChangeLength, didAlter) {
  if (!node) {
    if (value === NOT_SET) {
      return node;
    }
    SetRef(didAlter);
    SetRef(didChangeLength);
    return new ValueNode(ownerID, hash, [key, value]);
  }
  return node.update(ownerID, shift, hash, key, value, didChangeLength, didAlter);
}
function isLeafNode(node) {
  return node.constructor === ValueNode || node.constructor === HashCollisionNode;
}
function mergeIntoNode(node, ownerID, shift, hash, entry) {
  if (node.hash === hash) {
    return new HashCollisionNode(ownerID, hash, [node.entry, entry]);
  }
  var idx1 = (node.hash >>> shift) & MASK;
  var idx2 = (hash >>> shift) & MASK;
  var newNode;
  var nodes = idx1 === idx2 ? [mergeIntoNode(node, ownerID, shift + SHIFT, hash, entry)] : ((newNode = new ValueNode(ownerID, hash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);
  return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);
}
function packNodes(ownerID, nodes, count, excluding) {
  var bitmap = 0;
  var packedII = 0;
  var packedNodes = new Array(count);
  for (var ii = 0,
      bit = 1,
      len = nodes.length; ii < len; ii++, bit <<= 1) {
    var node = nodes[ii];
    if (node != null && ii !== excluding) {
      bitmap |= bit;
      packedNodes[packedII++] = node;
    }
  }
  return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
}
function expandNodes(ownerID, nodes, bitmap, including, node) {
  var count = 0;
  var expandedNodes = new Array(SIZE);
  for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
    expandedNodes[ii] = bitmap & 1 ? nodes[count++] : null;
  }
  expandedNodes[including] = node;
  return new ArrayNode(ownerID, count + 1, expandedNodes);
}
function mergeIntoMapWith(map, merger, iterables) {
  var seqs = [];
  for (var ii = 0; ii < iterables.length; ii++) {
    var seq = iterables[ii];
    seq && seqs.push(Array.isArray(seq) ? Sequence(seq).fromEntrySeq() : Sequence(seq));
  }
  return mergeIntoCollectionWith(map, merger, seqs);
}
function deepMerger(merger) {
  return (function(existing, value) {
    return existing && existing.mergeDeepWith ? existing.mergeDeepWith(merger, value) : merger ? merger(existing, value) : value;
  });
}
function mergeIntoCollectionWith(collection, merger, seqs) {
  if (seqs.length === 0) {
    return collection;
  }
  return collection.withMutations((function(collection) {
    var mergeIntoMap = merger ? (function(value, key) {
      var existing = collection.get(key, NOT_SET);
      collection.set(key, existing === NOT_SET ? value : merger(existing, value));
    }) : (function(value, key) {
      collection.set(key, value);
    });
    for (var ii = 0; ii < seqs.length; ii++) {
      seqs[ii].forEach(mergeIntoMap);
    }
  }));
}
function updateInDeepMap(collection, keyPath, notSetValue, updater, pathOffset) {
  var pathLen = keyPath.length;
  if (pathOffset === pathLen) {
    return updater(collection);
  }
  invariant(collection.set, 'updateIn with invalid keyPath');
  var notSet = pathOffset === pathLen - 1 ? notSetValue : Map.empty();
  var key = keyPath[pathOffset];
  var existing = collection.get(key, notSet);
  var value = updateInDeepMap(existing, keyPath, notSetValue, updater, pathOffset + 1);
  return value === existing ? collection : collection.set(key, value);
}
function popCount(x) {
  x = x - ((x >> 1) & 0x55555555);
  x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
  x = (x + (x >> 4)) & 0x0f0f0f0f;
  x = x + (x >> 8);
  x = x + (x >> 16);
  return x & 0x7f;
}
function setIn(array, idx, val, canEdit) {
  var newArray = canEdit ? array : arrCopy(array);
  newArray[idx] = val;
  return newArray;
}
function spliceIn(array, idx, val, canEdit) {
  var newLen = array.length + 1;
  if (canEdit && idx + 1 === newLen) {
    array[idx] = val;
    return array;
  }
  var newArray = new Array(newLen);
  var after = 0;
  for (var ii = 0; ii < newLen; ii++) {
    if (ii === idx) {
      newArray[ii] = val;
      after = -1;
    } else {
      newArray[ii] = array[ii + after];
    }
  }
  return newArray;
}
function spliceOut(array, idx, canEdit) {
  var newLen = array.length - 1;
  if (canEdit && idx === newLen) {
    array.pop();
    return array;
  }
  var newArray = new Array(newLen);
  var after = 0;
  for (var ii = 0; ii < newLen; ii++) {
    if (ii === idx) {
      after = 1;
    }
    newArray[ii] = array[ii + after];
  }
  return newArray;
}
var MAX_BITMAP_SIZE = SIZE / 2;
var MIN_ARRAY_SIZE = SIZE / 4;
var EMPTY_MAP;
var Vector = function Vector() {
  for (var values = [],
      $__5 = 0; $__5 < arguments.length; $__5++)
    values[$__5] = arguments[$__5];
  return $Vector.from(values);
};
var $Vector = Vector;
($traceurRuntime.createClass)(Vector, {
  toString: function() {
    return this.__toString('Vector [', ']');
  },
  get: function(index, notSetValue) {
    index = rawIndex(index, this._origin);
    if (index >= this._size) {
      return notSetValue;
    }
    var node = vectorNodeFor(this, index);
    var maskedIndex = index & MASK;
    return node && (notSetValue === undefined || node.array.hasOwnProperty(maskedIndex)) ? node.array[maskedIndex] : notSetValue;
  },
  first: function() {
    return this.get(0);
  },
  last: function() {
    return this.get(this.length ? this.length - 1 : 0);
  },
  set: function(index, value) {
    return updateVector(this, index, value);
  },
  remove: function(index) {
    return updateVector(this, index, NOT_SET);
  },
  clear: function() {
    if (this.length === 0) {
      return this;
    }
    if (this.__ownerID) {
      this.length = this._origin = this._size = 0;
      this._level = SHIFT;
      this._root = this._tail = null;
      this.__hash = undefined;
      this.__altered = true;
      return this;
    }
    return $Vector.empty();
  },
  push: function() {
    var values = arguments;
    var oldLength = this.length;
    return this.withMutations((function(vect) {
      setVectorBounds(vect, 0, oldLength + values.length);
      for (var ii = 0; ii < values.length; ii++) {
        vect.set(oldLength + ii, values[ii]);
      }
    }));
  },
  pop: function() {
    return setVectorBounds(this, 0, -1);
  },
  unshift: function() {
    var values = arguments;
    return this.withMutations((function(vect) {
      setVectorBounds(vect, -values.length);
      for (var ii = 0; ii < values.length; ii++) {
        vect.set(ii, values[ii]);
      }
    }));
  },
  shift: function() {
    return setVectorBounds(this, 1);
  },
  merge: function() {
    return mergeIntoVectorWith(this, null, arguments);
  },
  mergeWith: function(merger) {
    for (var seqs = [],
        $__6 = 1; $__6 < arguments.length; $__6++)
      seqs[$__6 - 1] = arguments[$__6];
    return mergeIntoVectorWith(this, merger, seqs);
  },
  mergeDeep: function() {
    return mergeIntoVectorWith(this, deepMerger(null), arguments);
  },
  mergeDeepWith: function(merger) {
    for (var seqs = [],
        $__7 = 1; $__7 < arguments.length; $__7++)
      seqs[$__7 - 1] = arguments[$__7];
    return mergeIntoVectorWith(this, deepMerger(merger), seqs);
  },
  setLength: function(length) {
    return setVectorBounds(this, 0, length);
  },
  slice: function(begin, end, maintainIndices) {
    var sliceSequence = $traceurRuntime.superCall(this, $Vector.prototype, "slice", [begin, end, maintainIndices]);
    if (!maintainIndices && sliceSequence !== this) {
      var vector = this;
      var length = vector.length;
      sliceSequence.toVector = (function() {
        return setVectorBounds(vector, begin < 0 ? Math.max(0, length + begin) : length ? Math.min(length, begin) : begin, end == null ? length : end < 0 ? Math.max(0, length + end) : length ? Math.min(length, end) : end);
      });
    }
    return sliceSequence;
  },
  keys: function(sparse) {
    return new VectorIterator(this, 0, sparse);
  },
  values: function(sparse) {
    return new VectorIterator(this, 1, sparse);
  },
  entries: function(sparse) {
    return new VectorIterator(this, 2, sparse);
  },
  __iterator: function(reverse, flipIndices, sparse) {
    return new VectorIterator(this, 2, sparse, reverse, flipIndices);
  },
  __iterate: function(fn, reverse, flipIndices) {
    var vector = this;
    var lastIndex = 0;
    var maxIndex = vector.length - 1;
    flipIndices ^= reverse;
    var eachFn = (function(value, ii) {
      if (fn(value, flipIndices ? maxIndex - ii : ii, vector) === false) {
        return false;
      } else {
        lastIndex = ii;
        return true;
      }
    });
    var didComplete;
    var tailOffset = getTailOffset(this._size);
    if (reverse) {
      didComplete = iterateVNode(this._tail, 0, tailOffset - this._origin, this._size - this._origin, eachFn, reverse) && iterateVNode(this._root, this._level, -this._origin, tailOffset - this._origin, eachFn, reverse);
    } else {
      didComplete = iterateVNode(this._root, this._level, -this._origin, tailOffset - this._origin, eachFn, reverse) && iterateVNode(this._tail, 0, tailOffset - this._origin, this._size - this._origin, eachFn, reverse);
    }
    return (didComplete ? maxIndex : reverse ? maxIndex - lastIndex : lastIndex) + 1;
  },
  __deepEquals: function(other) {
    var iterator = this.entries(true);
    return other.every((function(v, i) {
      var entry = iterator.next().value;
      return entry && entry[0] === i && is(entry[1], v);
    }));
  },
  __ensureOwner: function(ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    if (!ownerID) {
      this.__ownerID = ownerID;
      return this;
    }
    return makeVector(this._origin, this._size, this._level, this._root, this._tail, ownerID, this.__hash);
  }
}, {
  empty: function() {
    return EMPTY_VECT || (EMPTY_VECT = makeVector(0, 0, SHIFT));
  },
  from: function(sequence) {
    if (!sequence || sequence.length === 0) {
      return $Vector.empty();
    }
    if (sequence.constructor === $Vector) {
      return sequence;
    }
    var isArray = Array.isArray(sequence);
    if (sequence.length > 0 && sequence.length < SIZE) {
      return makeVector(0, sequence.length, SHIFT, null, new VNode(isArray ? arrCopy(sequence) : Sequence(sequence).toArray()));
    }
    if (!isArray) {
      sequence = Sequence(sequence);
      if (!(sequence instanceof IndexedSequence)) {
        sequence = sequence.valueSeq();
      }
    }
    return $Vector.empty().merge(sequence);
  }
}, IndexedSequence);
var VectorPrototype = Vector.prototype;
VectorPrototype[DELETE] = VectorPrototype.remove;
VectorPrototype[ITERATOR] = VectorPrototype.values;
VectorPrototype.update = MapPrototype.update;
VectorPrototype.updateIn = MapPrototype.updateIn;
VectorPrototype.cursor = MapPrototype.cursor;
VectorPrototype.withMutations = MapPrototype.withMutations;
VectorPrototype.asMutable = MapPrototype.asMutable;
VectorPrototype.asImmutable = MapPrototype.asImmutable;
VectorPrototype.wasAltered = MapPrototype.wasAltered;
var VNode = function VNode(array, ownerID) {
  this.array = array;
  this.ownerID = ownerID;
};
var $VNode = VNode;
($traceurRuntime.createClass)(VNode, {
  removeBefore: function(ownerID, level, index) {
    if (index === level ? 1 << level : 0 || this.array.length === 0) {
      return this;
    }
    var originIndex = (index >>> level) & MASK;
    if (originIndex >= this.array.length) {
      return new $VNode([], ownerID);
    }
    var removingFirst = originIndex === 0;
    var newChild;
    if (level > 0) {
      var oldChild = this.array[originIndex];
      newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
      if (newChild === oldChild && removingFirst) {
        return this;
      }
    }
    if (removingFirst && !newChild) {
      return this;
    }
    var editable = editableVNode(this, ownerID);
    if (!removingFirst) {
      for (var ii = 0; ii < originIndex; ii++) {
        delete editable.array[ii];
      }
    }
    if (newChild) {
      editable.array[originIndex] = newChild;
    }
    return editable;
  },
  removeAfter: function(ownerID, level, index) {
    if (index === level ? 1 << level : 0 || this.array.length === 0) {
      return this;
    }
    var sizeIndex = ((index - 1) >>> level) & MASK;
    if (sizeIndex >= this.array.length) {
      return this;
    }
    var removingLast = sizeIndex === this.array.length - 1;
    var newChild;
    if (level > 0) {
      var oldChild = this.array[sizeIndex];
      newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
      if (newChild === oldChild && removingLast) {
        return this;
      }
    }
    if (removingLast && !newChild) {
      return this;
    }
    var editable = editableVNode(this, ownerID);
    if (!removingLast) {
      editable.array.length = sizeIndex + 1;
    }
    if (newChild) {
      editable.array[sizeIndex] = newChild;
    }
    return editable;
  }
}, {});
function iterateVNode(node, level, offset, max, fn, reverse) {
  if (node) {
    var ii;
    var array = node.array;
    var maxII = array.length - 1;
    if (level === 0) {
      for (ii = 0; ii <= maxII; ii++) {
        var rawIndex = reverse ? maxII - ii : ii;
        if (array.hasOwnProperty(rawIndex)) {
          var index = rawIndex + offset;
          if (index >= 0 && index < max && fn(array[rawIndex], index) === false) {
            return false;
          }
        }
      }
    } else {
      var step = 1 << level;
      var newLevel = level - SHIFT;
      for (ii = 0; ii <= maxII; ii++) {
        var levelIndex = reverse ? maxII - ii : ii;
        var newOffset = offset + levelIndex * step;
        if (newOffset < max && newOffset + step > 0) {
          var nextNode = array[levelIndex];
          if (nextNode && !iterateVNode(nextNode, newLevel, newOffset, max, fn, reverse)) {
            return false;
          }
        }
      }
    }
  }
  return true;
}
var VectorIterator = function VectorIterator(vector, type, sparse, reverse, flipIndices) {
  this._type = type;
  this._sparse = !!sparse;
  this._reverse = !!reverse;
  this._flipIndices = !!(flipIndices ^ reverse);
  this._maxIndex = vector.length - 1;
  var tailOffset = getTailOffset(vector._size);
  var rootStack = vectIteratorFrame(vector._root && vector._root.array, vector._level, -vector._origin, tailOffset - vector._origin - 1);
  var tailStack = vectIteratorFrame(vector._tail && vector._tail.array, 0, tailOffset - vector._origin, vector._size - vector._origin - 1);
  this._stack = reverse ? tailStack : rootStack;
  this._stack.__prev = reverse ? rootStack : tailStack;
};
($traceurRuntime.createClass)(VectorIterator, {next: function() {
    var sparse = this._sparse;
    var stack = this._stack;
    while (stack) {
      var array = stack.array;
      var rawIndex = stack.index++;
      if (this._reverse) {
        rawIndex = MASK - rawIndex;
        if (rawIndex > stack.rawMax) {
          rawIndex = stack.rawMax;
          stack.index = SIZE - rawIndex;
        }
      }
      if (rawIndex >= 0 && rawIndex < SIZE && rawIndex <= stack.rawMax) {
        var value = array && array[rawIndex];
        if (stack.level === 0) {
          if (!sparse || value != null || (array && rawIndex < array.length && array.hasOwnProperty(rawIndex))) {
            var type = this._type;
            var index;
            if (type !== 1) {
              index = stack.offset + (rawIndex << stack.level);
              if (this._flipIndices) {
                index = this._maxIndex - index;
              }
            }
            return iteratorValue(type === 0 ? index : type === 1 ? value : [index, value]);
          }
        } else if (!sparse || value != null) {
          this._stack = stack = vectIteratorFrame(value && value.array, stack.level - SHIFT, stack.offset + (rawIndex << stack.level), stack.max, stack);
        }
        continue;
      }
      stack = this._stack = this._stack.__prev;
    }
    return iteratorDone();
  }}, {}, SequenceIterator);
function vectIteratorFrame(array, level, offset, max, prevFrame) {
  return {
    array: array,
    level: level,
    offset: offset,
    max: max,
    rawMax: ((max - offset) >> level),
    index: 0,
    __prev: prevFrame
  };
}
function makeVector(origin, size, level, root, tail, ownerID, hash) {
  var vect = Object.create(VectorPrototype);
  vect.length = size - origin;
  vect._origin = origin;
  vect._size = size;
  vect._level = level;
  vect._root = root;
  vect._tail = tail;
  vect.__ownerID = ownerID;
  vect.__hash = hash;
  vect.__altered = false;
  return vect;
}
function updateVector(vector, index, value) {
  if (index >= vector.length) {
    return value === NOT_SET ? vector : vector.withMutations((function(vect) {
      setVectorBounds(vect, 0, index + 1).set(index, value);
    }));
  }
  index = rawIndex(index, vector._origin);
  var newTail = vector._tail;
  var newRoot = vector._root;
  var didAlter = MakeRef(DID_ALTER);
  if (index >= getTailOffset(vector._size)) {
    newTail = updateVNode(newTail, vector.__ownerID, 0, index, value, didAlter);
  } else {
    newRoot = updateVNode(newRoot, vector.__ownerID, vector._level, index, value, didAlter);
  }
  if (!didAlter.value) {
    return vector;
  }
  if (vector.__ownerID) {
    vector._root = newRoot;
    vector._tail = newTail;
    vector.__hash = undefined;
    vector.__altered = true;
    return vector;
  }
  return makeVector(vector._origin, vector._size, vector._level, newRoot, newTail);
}
function updateVNode(node, ownerID, level, index, value, didAlter) {
  var removed = value === NOT_SET;
  var newNode;
  var idx = (index >>> level) & MASK;
  var nodeHas = node && idx < node.array.length && node.array.hasOwnProperty(idx);
  if (removed && !nodeHas) {
    return node;
  }
  if (level > 0) {
    var lowerNode = node && node.array[idx];
    var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
    if (newLowerNode === lowerNode) {
      return node;
    }
    newNode = editableVNode(node, ownerID);
    newNode.array[idx] = newLowerNode;
    return newNode;
  }
  if (!removed && nodeHas && node.array[idx] === value) {
    return node;
  }
  SetRef(didAlter);
  newNode = editableVNode(node, ownerID);
  removed ? (delete newNode.array[idx]) : (newNode.array[idx] = value);
  return newNode;
}
function editableVNode(node, ownerID) {
  if (ownerID && node && ownerID === node.ownerID) {
    return node;
  }
  return new VNode(node ? node.array.slice() : [], ownerID);
}
function vectorNodeFor(vector, rawIndex) {
  if (rawIndex >= getTailOffset(vector._size)) {
    return vector._tail;
  }
  if (rawIndex < 1 << (vector._level + SHIFT)) {
    var node = vector._root;
    var level = vector._level;
    while (node && level > 0) {
      node = node.array[(rawIndex >>> level) & MASK];
      level -= SHIFT;
    }
    return node;
  }
}
function setVectorBounds(vector, begin, end) {
  var owner = vector.__ownerID || new OwnerID();
  var oldOrigin = vector._origin;
  var oldSize = vector._size;
  var newOrigin = oldOrigin + begin;
  var newSize = end == null ? oldSize : end < 0 ? oldSize + end : oldOrigin + end;
  if (newOrigin === oldOrigin && newSize === oldSize) {
    return vector;
  }
  if (newOrigin >= newSize) {
    return vector.clear();
  }
  var newLevel = vector._level;
  var newRoot = vector._root;
  var offsetShift = 0;
  while (newOrigin + offsetShift < 0) {
    newRoot = new VNode(newRoot && newRoot.array.length ? [null, newRoot] : [], owner);
    newLevel += SHIFT;
    offsetShift += 1 << newLevel;
  }
  if (offsetShift) {
    newOrigin += offsetShift;
    oldOrigin += offsetShift;
    newSize += offsetShift;
    oldSize += offsetShift;
  }
  var oldTailOffset = getTailOffset(oldSize);
  var newTailOffset = getTailOffset(newSize);
  while (newTailOffset >= 1 << (newLevel + SHIFT)) {
    newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
    newLevel += SHIFT;
  }
  var oldTail = vector._tail;
  var newTail = newTailOffset < oldTailOffset ? vectorNodeFor(vector, newSize - 1) : newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;
  if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldSize && oldTail.array.length) {
    newRoot = editableVNode(newRoot, owner);
    var node = newRoot;
    for (var level = newLevel; level > SHIFT; level -= SHIFT) {
      var idx = (oldTailOffset >>> level) & MASK;
      node = node.array[idx] = editableVNode(node.array[idx], owner);
    }
    node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;
  }
  if (newSize < oldSize) {
    newTail = newTail && newTail.removeAfter(owner, 0, newSize);
  }
  if (newOrigin >= newTailOffset) {
    newOrigin -= newTailOffset;
    newSize -= newTailOffset;
    newLevel = SHIFT;
    newRoot = null;
    newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);
  } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
    var beginIndex,
        endIndex;
    offsetShift = 0;
    do {
      beginIndex = ((newOrigin) >>> newLevel) & MASK;
      endIndex = ((newTailOffset - 1) >>> newLevel) & MASK;
      if (beginIndex === endIndex) {
        if (beginIndex) {
          offsetShift += (1 << newLevel) * beginIndex;
        }
        newLevel -= SHIFT;
        newRoot = newRoot && newRoot.array[beginIndex];
      }
    } while (newRoot && beginIndex === endIndex);
    if (newRoot && newOrigin > oldOrigin) {
      newRoot = newRoot && newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
    }
    if (newRoot && newTailOffset < oldTailOffset) {
      newRoot = newRoot && newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
    }
    if (offsetShift) {
      newOrigin -= offsetShift;
      newSize -= offsetShift;
    }
  }
  if (vector.__ownerID) {
    vector.length = newSize - newOrigin;
    vector._origin = newOrigin;
    vector._size = newSize;
    vector._level = newLevel;
    vector._root = newRoot;
    vector._tail = newTail;
    vector.__hash = undefined;
    vector.__altered = true;
    return vector;
  }
  return makeVector(newOrigin, newSize, newLevel, newRoot, newTail);
}
function mergeIntoVectorWith(vector, merger, iterables) {
  var seqs = [];
  for (var ii = 0; ii < iterables.length; ii++) {
    var seq = iterables[ii];
    seq && seqs.push(Sequence(seq));
  }
  var maxLength = Math.max.apply(null, seqs.map((function(s) {
    return s.length || 0;
  })));
  if (maxLength > vector.length) {
    vector = vector.setLength(maxLength);
  }
  return mergeIntoCollectionWith(vector, merger, seqs);
}
function rawIndex(index, origin) {
  invariant(index >= 0, 'Index out of bounds');
  return index + origin;
}
function getTailOffset(size) {
  return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);
}
var EMPTY_VECT;
var Set = function Set() {
  for (var values = [],
      $__8 = 0; $__8 < arguments.length; $__8++)
    values[$__8] = arguments[$__8];
  return $Set.from(values);
};
var $Set = Set;
($traceurRuntime.createClass)(Set, {
  toString: function() {
    return this.__toString('Set {', '}');
  },
  has: function(value) {
    return this._map.has(value);
  },
  get: function(value, notSetValue) {
    return this.has(value) ? value : notSetValue;
  },
  add: function(value) {
    var newMap = this._map.set(value, null);
    if (this.__ownerID) {
      this.length = newMap.length;
      this._map = newMap;
      return this;
    }
    return newMap === this._map ? this : makeSet(newMap);
  },
  remove: function(value) {
    var newMap = this._map.remove(value);
    if (this.__ownerID) {
      this.length = newMap.length;
      this._map = newMap;
      return this;
    }
    return newMap === this._map ? this : newMap.length === 0 ? $Set.empty() : makeSet(newMap);
  },
  clear: function() {
    if (this.length === 0) {
      return this;
    }
    if (this.__ownerID) {
      this.length = 0;
      this._map.clear();
      return this;
    }
    return $Set.empty();
  },
  union: function() {
    var seqs = arguments;
    if (seqs.length === 0) {
      return this;
    }
    return this.withMutations((function(set) {
      for (var ii = 0; ii < seqs.length; ii++) {
        Sequence(seqs[ii]).forEach((function(value) {
          return set.add(value);
        }));
      }
    }));
  },
  intersect: function() {
    for (var seqs = [],
        $__9 = 0; $__9 < arguments.length; $__9++)
      seqs[$__9] = arguments[$__9];
    if (seqs.length === 0) {
      return this;
    }
    seqs = seqs.map((function(seq) {
      return Sequence(seq);
    }));
    var originalSet = this;
    return this.withMutations((function(set) {
      originalSet.forEach((function(value) {
        if (!seqs.every((function(seq) {
          return seq.contains(value);
        }))) {
          set.remove(value);
        }
      }));
    }));
  },
  subtract: function() {
    for (var seqs = [],
        $__10 = 0; $__10 < arguments.length; $__10++)
      seqs[$__10] = arguments[$__10];
    if (seqs.length === 0) {
      return this;
    }
    seqs = seqs.map((function(seq) {
      return Sequence(seq);
    }));
    var originalSet = this;
    return this.withMutations((function(set) {
      originalSet.forEach((function(value) {
        if (seqs.some((function(seq) {
          return seq.contains(value);
        }))) {
          set.remove(value);
        }
      }));
    }));
  },
  isSubset: function(seq) {
    seq = Sequence(seq);
    return this.every((function(value) {
      return seq.contains(value);
    }));
  },
  isSuperset: function(seq) {
    var set = this;
    seq = Sequence(seq);
    return seq.every((function(value) {
      return set.contains(value);
    }));
  },
  wasAltered: function() {
    return this._map.wasAltered();
  },
  values: function() {
    return this._map.keys();
  },
  entries: function() {
    return iteratorMapper(this.values(), (function(key) {
      return [key, key];
    }));
  },
  hashCode: function() {
    return this._map.hashCode();
  },
  equals: function(other) {
    return this._map.equals(other._map);
  },
  __iterate: function(fn, reverse) {
    var collection = this;
    return this._map.__iterate((function(_, k) {
      return fn(k, k, collection);
    }), reverse);
  },
  __ensureOwner: function(ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    var newMap = this._map.__ensureOwner(ownerID);
    if (!ownerID) {
      this.__ownerID = ownerID;
      this._map = newMap;
      return this;
    }
    return makeSet(newMap, ownerID);
  }
}, {
  empty: function() {
    return EMPTY_SET || (EMPTY_SET = makeSet(Map.empty()));
  },
  from: function(sequence) {
    var set = $Set.empty();
    return sequence ? sequence.constructor === $Set ? sequence : set.union(sequence) : set;
  },
  fromKeys: function(sequence) {
    return $Set.from(Sequence(sequence).flip());
  }
}, Sequence);
var SetPrototype = Set.prototype;
SetPrototype[DELETE] = SetPrototype.remove;
SetPrototype[ITERATOR] = SetPrototype.keys = SetPrototype.values;
SetPrototype.contains = SetPrototype.has;
SetPrototype.mergeDeep = SetPrototype.merge = SetPrototype.union;
SetPrototype.mergeDeepWith = SetPrototype.mergeWith = function(merger) {
  for (var seqs = [],
      $__11 = 1; $__11 < arguments.length; $__11++)
    seqs[$__11 - 1] = arguments[$__11];
  return this.merge.apply(this, seqs);
};
SetPrototype.withMutations = MapPrototype.withMutations;
SetPrototype.asMutable = MapPrototype.asMutable;
SetPrototype.asImmutable = MapPrototype.asImmutable;
SetPrototype.__toJS = IndexedSequencePrototype.__toJS;
SetPrototype.__toStringMapper = IndexedSequencePrototype.__toStringMapper;
function makeSet(map, ownerID) {
  var set = Object.create(SetPrototype);
  set.length = map ? map.length : 0;
  set._map = map;
  set.__ownerID = ownerID;
  return set;
}
var EMPTY_SET;
var OrderedMap = function OrderedMap(sequence) {
  var map = $OrderedMap.empty();
  return sequence ? sequence.constructor === $OrderedMap ? sequence : map.merge(sequence) : map;
};
var $OrderedMap = OrderedMap;
($traceurRuntime.createClass)(OrderedMap, {
  toString: function() {
    return this.__toString('OrderedMap {', '}');
  },
  get: function(k, notSetValue) {
    var index = this._map.get(k);
    return index != null ? this._vector.get(index)[1] : notSetValue;
  },
  clear: function() {
    if (this.length === 0) {
      return this;
    }
    if (this.__ownerID) {
      this.length = 0;
      this._map.clear();
      this._vector.clear();
      return this;
    }
    return $OrderedMap.empty();
  },
  set: function(k, v) {
    return updateOrderedMap(this, k, v);
  },
  remove: function(k) {
    return updateOrderedMap(this, k, NOT_SET);
  },
  wasAltered: function() {
    return this._map.wasAltered() || this._vector.wasAltered();
  },
  keys: function() {
    return iteratorMapper(this.entries(), (function(entry) {
      return entry[0];
    }));
  },
  values: function() {
    return iteratorMapper(this.entries(), (function(entry) {
      return entry[1];
    }));
  },
  entries: function() {
    return this._vector.values(true);
  },
  __iterate: function(fn, reverse) {
    return this._vector.fromEntrySeq().__iterate(fn, reverse);
  },
  __deepEqual: function(other) {
    var iterator = this.entries();
    return other.every((function(v, k) {
      var entry = iterator.next().value;
      return entry && is(entry[0], k) && is(entry[1], v);
    }));
  },
  __ensureOwner: function(ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    var newMap = this._map.__ensureOwner(ownerID);
    var newVector = this._vector.__ensureOwner(ownerID);
    if (!ownerID) {
      this.__ownerID = ownerID;
      this._map = newMap;
      this._vector = newVector;
      return this;
    }
    return makeOrderedMap(newMap, newVector, ownerID, this.__hash);
  }
}, {empty: function() {
    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(Map.empty(), Vector.empty()));
  }}, Map);
OrderedMap.from = OrderedMap;
OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;
function makeOrderedMap(map, vector, ownerID, hash) {
  var omap = Object.create(OrderedMap.prototype);
  omap.length = map ? map.length : 0;
  omap._map = map;
  omap._vector = vector;
  omap.__ownerID = ownerID;
  omap.__hash = hash;
  return omap;
}
function updateOrderedMap(omap, k, v) {
  var map = omap._map;
  var vector = omap._vector;
  var i = map.get(k);
  var has = i !== undefined;
  var removed = v === NOT_SET;
  if ((!has && removed) || (has && v === vector.get(i)[1])) {
    return omap;
  }
  if (!has) {
    i = vector.length;
  }
  var newMap = removed ? map.remove(k) : has ? map : map.set(k, i);
  var newVector = removed ? vector.remove(i) : vector.set(i, [k, v]);
  if (omap.__ownerID) {
    omap.length = newMap.length;
    omap._map = newMap;
    omap._vector = newVector;
    omap.__hash = undefined;
    return omap;
  }
  return makeOrderedMap(newMap, newVector);
}
var EMPTY_ORDERED_MAP;
var Record = function Record(defaultValues, name) {
  var RecordType = function(values) {
    if (!(this instanceof RecordType)) {
      return new RecordType(values);
    }
    this._map = Map(values);
  };
  defaultValues = Sequence(defaultValues);
  var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
  RecordTypePrototype.constructor = RecordType;
  RecordTypePrototype._name = name;
  RecordTypePrototype._defaultValues = defaultValues;
  var keys = Object.keys(defaultValues);
  RecordType.prototype.length = keys.length;
  if (Object.defineProperty) {
    defaultValues.forEach((function(_, key) {
      Object.defineProperty(RecordType.prototype, key, {
        get: function() {
          return this.get(key);
        },
        set: function(value) {
          invariant(this.__ownerID, 'Cannot set on an immutable record.');
          this.set(key, value);
        }
      });
    }));
  }
  return RecordType;
};
var $Record = Record;
($traceurRuntime.createClass)(Record, {
  toString: function() {
    return this.__toString((this._name || 'Record') + ' {', '}');
  },
  has: function(k) {
    return this._defaultValues.has(k);
  },
  get: function(k, notSetValue) {
    if (notSetValue !== undefined && !this.has(k)) {
      return notSetValue;
    }
    return this._map.get(k, this._defaultValues.get(k));
  },
  clear: function() {
    if (this.__ownerID) {
      this._map.clear();
      return this;
    }
    var Record = Object.getPrototypeOf(this).constructor;
    return $Record._empty || ($Record._empty = makeRecord(this, Map.empty()));
  },
  set: function(k, v) {
    if (k == null || !this.has(k)) {
      return this;
    }
    var newMap = this._map.set(k, v);
    if (this.__ownerID || newMap === this._map) {
      return this;
    }
    return makeRecord(this, newMap);
  },
  remove: function(k) {
    if (k == null || !this.has(k)) {
      return this;
    }
    var newMap = this._map.remove(k);
    if (this.__ownerID || newMap === this._map) {
      return this;
    }
    return makeRecord(this, newMap);
  },
  keys: function() {
    return this._map.keys();
  },
  values: function() {
    return this._map.values();
  },
  entries: function() {
    return this._map.entries();
  },
  wasAltered: function() {
    return this._map.wasAltered();
  },
  __iterate: function(fn, reverse) {
    var record = this;
    return this._defaultValues.map((function(_, k) {
      return record.get(k);
    })).__iterate(fn, reverse);
  },
  __ensureOwner: function(ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    var newMap = this._map && this._map.__ensureOwner(ownerID);
    if (!ownerID) {
      this.__ownerID = ownerID;
      this._map = newMap;
      return this;
    }
    return makeRecord(this, newMap, ownerID);
  }
}, {}, Sequence);
var RecordPrototype = Record.prototype;
RecordPrototype[DELETE] = RecordPrototype.remove;
RecordPrototype[ITERATOR] = MapPrototype[ITERATOR];
RecordPrototype.merge = MapPrototype.merge;
RecordPrototype.mergeWith = MapPrototype.mergeWith;
RecordPrototype.mergeDeep = MapPrototype.mergeDeep;
RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;
RecordPrototype.update = MapPrototype.update;
RecordPrototype.updateIn = MapPrototype.updateIn;
RecordPrototype.cursor = MapPrototype.cursor;
RecordPrototype.withMutations = MapPrototype.withMutations;
RecordPrototype.asMutable = MapPrototype.asMutable;
RecordPrototype.asImmutable = MapPrototype.asImmutable;
RecordPrototype.__deepEqual = MapPrototype.__deepEqual;
function makeRecord(likeRecord, map, ownerID) {
  var record = Object.create(Object.getPrototypeOf(likeRecord));
  record._map = map;
  record.__ownerID = ownerID;
  return record;
}
var Range = function Range(start, end, step) {
  if (!(this instanceof $Range)) {
    return new $Range(start, end, step);
  }
  invariant(step !== 0, 'Cannot step a Range by 0');
  start = start || 0;
  if (end == null) {
    end = Infinity;
  }
  if (start === end && __EMPTY_RANGE) {
    return __EMPTY_RANGE;
  }
  step = step == null ? 1 : Math.abs(step);
  if (end < start) {
    step = -step;
  }
  this._start = start;
  this._end = end;
  this._step = step;
  this.length = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
};
var $Range = Range;
($traceurRuntime.createClass)(Range, {
  toString: function() {
    if (this.length === 0) {
      return 'Range []';
    }
    return 'Range [ ' + this._start + '...' + this._end + (this._step > 1 ? ' by ' + this._step : '') + ' ]';
  },
  has: function(index) {
    invariant(index >= 0, 'Index out of bounds');
    return index < this.length;
  },
  get: function(index, notSetValue) {
    invariant(index >= 0, 'Index out of bounds');
    return this.length === Infinity || index < this.length ? this._start + index * this._step : notSetValue;
  },
  contains: function(searchValue) {
    var possibleIndex = (searchValue - this._start) / this._step;
    return possibleIndex >= 0 && possibleIndex < this.length && possibleIndex === Math.floor(possibleIndex);
  },
  slice: function(begin, end, maintainIndices) {
    if (wholeSlice(begin, end, this.length)) {
      return this;
    }
    if (maintainIndices) {
      return $traceurRuntime.superCall(this, $Range.prototype, "slice", [begin, end, maintainIndices]);
    }
    begin = resolveBegin(begin, this.length);
    end = resolveEnd(end, this.length);
    if (end <= begin) {
      return __EMPTY_RANGE;
    }
    return new $Range(this.get(begin, this._end), this.get(end, this._end), this._step);
  },
  indexOf: function(searchValue) {
    var offsetValue = searchValue - this._start;
    if (offsetValue % this._step === 0) {
      var index = offsetValue / this._step;
      if (index >= 0 && index < this.length) {
        return index;
      }
    }
    return -1;
  },
  lastIndexOf: function(searchValue) {
    return this.indexOf(searchValue);
  },
  take: function(amount) {
    return this.slice(0, amount);
  },
  skip: function(amount, maintainIndices) {
    return maintainIndices ? $traceurRuntime.superCall(this, $Range.prototype, "skip", [amount]) : this.slice(amount);
  },
  __iterate: function(fn, reverse, flipIndices) {
    var reversedIndices = reverse ^ flipIndices;
    var maxIndex = this.length - 1;
    var step = this._step;
    var value = reverse ? this._start + maxIndex * step : this._start;
    for (var ii = 0; ii <= maxIndex; ii++) {
      if (fn(value, reversedIndices ? maxIndex - ii : ii, this) === false) {
        break;
      }
      value += reverse ? -step : step;
    }
    return reversedIndices ? this.length : ii;
  },
  __deepEquals: function(other) {
    return this._start === other._start && this._end === other._end && this._step === other._step;
  }
}, {}, IndexedSequence);
var RangePrototype = Range.prototype;
RangePrototype.__toJS = RangePrototype.toArray;
RangePrototype.first = VectorPrototype.first;
RangePrototype.last = VectorPrototype.last;
var __EMPTY_RANGE = Range(0, 0);
var Repeat = function Repeat(value, times) {
  if (times === 0 && EMPTY_REPEAT) {
    return EMPTY_REPEAT;
  }
  if (!(this instanceof $Repeat)) {
    return new $Repeat(value, times);
  }
  this._value = value;
  this.length = times == null ? Infinity : Math.max(0, times);
};
var $Repeat = Repeat;
($traceurRuntime.createClass)(Repeat, {
  toString: function() {
    if (this.length === 0) {
      return 'Repeat []';
    }
    return 'Repeat [ ' + this._value + ' ' + this.length + ' times ]';
  },
  get: function(index, notSetValue) {
    invariant(index >= 0, 'Index out of bounds');
    return this.length === Infinity || index < this.length ? this._value : notSetValue;
  },
  first: function() {
    return this._value;
  },
  contains: function(searchValue) {
    return is(this._value, searchValue);
  },
  slice: function(begin, end, maintainIndices) {
    if (maintainIndices) {
      return $traceurRuntime.superCall(this, $Repeat.prototype, "slice", [begin, end, maintainIndices]);
    }
    var length = this.length;
    begin = begin < 0 ? Math.max(0, length + begin) : Math.min(length, begin);
    end = end == null ? length : end > 0 ? Math.min(length, end) : Math.max(0, length + end);
    return end > begin ? new $Repeat(this._value, end - begin) : EMPTY_REPEAT;
  },
  reverse: function(maintainIndices) {
    return maintainIndices ? $traceurRuntime.superCall(this, $Repeat.prototype, "reverse", [maintainIndices]) : this;
  },
  indexOf: function(searchValue) {
    if (is(this._value, searchValue)) {
      return 0;
    }
    return -1;
  },
  lastIndexOf: function(searchValue) {
    if (is(this._value, searchValue)) {
      return this.length;
    }
    return -1;
  },
  __iterate: function(fn, reverse, flipIndices) {
    var reversedIndices = reverse ^ flipIndices;
    invariant(!reversedIndices || this.length < Infinity, 'Cannot access end of infinite range.');
    var maxIndex = this.length - 1;
    for (var ii = 0; ii <= maxIndex; ii++) {
      if (fn(this._value, reversedIndices ? maxIndex - ii : ii, this) === false) {
        break;
      }
    }
    return reversedIndices ? this.length : ii;
  },
  __deepEquals: function(other) {
    return is(this._value, other._value);
  }
}, {}, IndexedSequence);
var RepeatPrototype = Repeat.prototype;
RepeatPrototype.last = RepeatPrototype.first;
RepeatPrototype.has = RangePrototype.has;
RepeatPrototype.take = RangePrototype.take;
RepeatPrototype.skip = RangePrototype.skip;
RepeatPrototype.__toJS = RangePrototype.__toJS;
var EMPTY_REPEAT = new Repeat(undefined, 0);
function fromJS(json, converter) {
  if (converter) {
    return _fromJSWith(converter, json, '', {'': json});
  }
  return _fromJSDefault(json);
}
function _fromJSWith(converter, json, key, parentJSON) {
  if (json && (Array.isArray(json) || json.constructor === Object)) {
    return converter.call(parentJSON, key, Sequence(json).map((function(v, k) {
      return _fromJSWith(converter, v, k, json);
    })));
  }
  return json;
}
function _fromJSDefault(json) {
  if (json) {
    if (Array.isArray(json)) {
      return Sequence(json).map(_fromJSDefault).toVector();
    }
    if (json.constructor === Object) {
      return Sequence(json).map(_fromJSDefault).toMap();
    }
  }
  return json;
}
var Immutable = {
  Sequence: Sequence,
  Map: Map,
  Vector: Vector,
  Set: Set,
  OrderedMap: OrderedMap,
  Record: Record,
  Range: Range,
  Repeat: Repeat,
  is: is,
  fromJS: fromJS
};

  return Immutable;
}
typeof exports === 'object' ? module.exports = universalModule() :
  typeof define === 'function' && define.amd ? define(universalModule) :
    Immutable = universalModule();

},{}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/addons.js":[function(require,module,exports){
module.exports = require('./lib/ReactWithAddons');

},{"./lib/ReactWithAddons":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactWithAddons.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/AutoFocusMixin.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule AutoFocusMixin
 * @typechecks static-only
 */

"use strict";

var focusNode = require("./focusNode");

var AutoFocusMixin = {
  componentDidMount: function() {
    if (this.props.autoFocus) {
      focusNode(this.getDOMNode());
    }
  }
};

module.exports = AutoFocusMixin;

},{"./focusNode":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/focusNode.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/BeforeInputEventPlugin.js":[function(require,module,exports){
/**
 * Copyright 2013 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule BeforeInputEventPlugin
 * @typechecks static-only
 */

"use strict";

var EventConstants = require("./EventConstants");
var EventPropagators = require("./EventPropagators");
var ExecutionEnvironment = require("./ExecutionEnvironment");
var SyntheticInputEvent = require("./SyntheticInputEvent");

var keyOf = require("./keyOf");

var canUseTextInputEvent = (
  ExecutionEnvironment.canUseDOM &&
  'TextEvent' in window &&
  !('documentMode' in document || isPresto())
);

/**
 * Opera <= 12 includes TextEvent in window, but does not fire
 * text input events. Rely on keypress instead.
 */
function isPresto() {
  var opera = window.opera;
  return (
    typeof opera === 'object' &&
    typeof opera.version === 'function' &&
    parseInt(opera.version(), 10) <= 12
  );
}

var SPACEBAR_CODE = 32;
var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);

var topLevelTypes = EventConstants.topLevelTypes;

// Events and their corresponding property names.
var eventTypes = {
  beforeInput: {
    phasedRegistrationNames: {
      bubbled: keyOf({onBeforeInput: null}),
      captured: keyOf({onBeforeInputCapture: null})
    },
    dependencies: [
      topLevelTypes.topCompositionEnd,
      topLevelTypes.topKeyPress,
      topLevelTypes.topTextInput,
      topLevelTypes.topPaste
    ]
  }
};

// Track characters inserted via keypress and composition events.
var fallbackChars = null;

/**
 * Return whether a native keypress event is assumed to be a command.
 * This is required because Firefox fires `keypress` events for key commands
 * (cut, copy, select-all, etc.) even though no character is inserted.
 */
function isKeypressCommand(nativeEvent) {
  return (
    (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
    // ctrlKey && altKey is equivalent to AltGr, and is not a command.
    !(nativeEvent.ctrlKey && nativeEvent.altKey)
  );
}

/**
 * Create an `onBeforeInput` event to match
 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
 *
 * This event plugin is based on the native `textInput` event
 * available in Chrome, Safari, Opera, and IE. This event fires after
 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
 *
 * `beforeInput` is spec'd but not implemented in any browsers, and
 * the `input` event does not provide any useful information about what has
 * actually been added, contrary to the spec. Thus, `textInput` is the best
 * available event to identify the characters that have actually been inserted
 * into the target node.
 */
var BeforeInputEventPlugin = {

  eventTypes: eventTypes,

  /**
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function(
      topLevelType,
      topLevelTarget,
      topLevelTargetID,
      nativeEvent) {

    var chars;

    if (canUseTextInputEvent) {
      switch (topLevelType) {
        case topLevelTypes.topKeyPress:
          /**
           * If native `textInput` events are available, our goal is to make
           * use of them. However, there is a special case: the spacebar key.
           * In Webkit, preventing default on a spacebar `textInput` event
           * cancels character insertion, but it *also* causes the browser
           * to fall back to its default spacebar behavior of scrolling the
           * page.
           *
           * Tracking at:
           * https://code.google.com/p/chromium/issues/detail?id=355103
           *
           * To avoid this issue, use the keypress event as if no `textInput`
           * event is available.
           */
          var which = nativeEvent.which;
          if (which !== SPACEBAR_CODE) {
            return;
          }

          chars = String.fromCharCode(which);
          break;

        case topLevelTypes.topTextInput:
          // Record the characters to be added to the DOM.
          chars = nativeEvent.data;

          // If it's a spacebar character, assume that we have already handled
          // it at the keypress level and bail immediately.
          if (chars === SPACEBAR_CHAR) {
            return;
          }

          // Otherwise, carry on.
          break;

        default:
          // For other native event types, do nothing.
          return;
      }
    } else {
      switch (topLevelType) {
        case topLevelTypes.topPaste:
          // If a paste event occurs after a keypress, throw out the input
          // chars. Paste events should not lead to BeforeInput events.
          fallbackChars = null;
          break;
        case topLevelTypes.topKeyPress:
          /**
           * As of v27, Firefox may fire keypress events even when no character
           * will be inserted. A few possibilities:
           *
           * - `which` is `0`. Arrow keys, Esc key, etc.
           *
           * - `which` is the pressed key code, but no char is available.
           *   Ex: 'AltGr + d` in Polish. There is no modified character for
           *   this key combination and no character is inserted into the
           *   document, but FF fires the keypress for char code `100` anyway.
           *   No `input` event will occur.
           *
           * - `which` is the pressed key code, but a command combination is
           *   being used. Ex: `Cmd+C`. No character is inserted, and no
           *   `input` event will occur.
           */
          if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
            fallbackChars = String.fromCharCode(nativeEvent.which);
          }
          break;
        case topLevelTypes.topCompositionEnd:
          fallbackChars = nativeEvent.data;
          break;
      }

      // If no changes have occurred to the fallback string, no relevant
      // event has fired and we're done.
      if (fallbackChars === null) {
        return;
      }

      chars = fallbackChars;
    }

    // If no characters are being inserted, no BeforeInput event should
    // be fired.
    if (!chars) {
      return;
    }

    var event = SyntheticInputEvent.getPooled(
      eventTypes.beforeInput,
      topLevelTargetID,
      nativeEvent
    );

    event.data = chars;
    fallbackChars = null;
    EventPropagators.accumulateTwoPhaseDispatches(event);
    return event;
  }
};

module.exports = BeforeInputEventPlugin;

},{"./EventConstants":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/EventConstants.js","./EventPropagators":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/EventPropagators.js","./ExecutionEnvironment":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ExecutionEnvironment.js","./SyntheticInputEvent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/SyntheticInputEvent.js","./keyOf":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/keyOf.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/CSSCore.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule CSSCore
 * @typechecks
 */

var invariant = require("./invariant");

/**
 * The CSSCore module specifies the API (and implements most of the methods)
 * that should be used when dealing with the display of elements (via their
 * CSS classes and visibility on screen. It is an API focused on mutating the
 * display and not reading it as no logical state should be encoded in the
 * display of elements.
 */

var CSSCore = {

  /**
   * Adds the class passed in to the element if it doesn't already have it.
   *
   * @param {DOMElement} element the element to set the class on
   * @param {string} className the CSS className
   * @return {DOMElement} the element passed in
   */
  addClass: function(element, className) {
    ("production" !== process.env.NODE_ENV ? invariant(
      !/\s/.test(className),
      'CSSCore.addClass takes only a single class name. "%s" contains ' +
      'multiple classes.', className
    ) : invariant(!/\s/.test(className)));

    if (className) {
      if (element.classList) {
        element.classList.add(className);
      } else if (!CSSCore.hasClass(element, className)) {
        element.className = element.className + ' ' + className;
      }
    }
    return element;
  },

  /**
   * Removes the class passed in from the element
   *
   * @param {DOMElement} element the element to set the class on
   * @param {string} className the CSS className
   * @return {DOMElement} the element passed in
   */
  removeClass: function(element, className) {
    ("production" !== process.env.NODE_ENV ? invariant(
      !/\s/.test(className),
      'CSSCore.removeClass takes only a single class name. "%s" contains ' +
      'multiple classes.', className
    ) : invariant(!/\s/.test(className)));

    if (className) {
      if (element.classList) {
        element.classList.remove(className);
      } else if (CSSCore.hasClass(element, className)) {
        element.className = element.className
          .replace(new RegExp('(^|\\s)' + className + '(?:\\s|$)', 'g'), '$1')
          .replace(/\s+/g, ' ') // multiple spaces to one
          .replace(/^\s*|\s*$/g, ''); // trim the ends
      }
    }
    return element;
  },

  /**
   * Helper to add or remove a class from an element based on a condition.
   *
   * @param {DOMElement} element the element to set the class on
   * @param {string} className the CSS className
   * @param {*} bool condition to whether to add or remove the class
   * @return {DOMElement} the element passed in
   */
  conditionClass: function(element, className, bool) {
    return (bool ? CSSCore.addClass : CSSCore.removeClass)(element, className);
  },

  /**
   * Tests whether the element has the class specified.
   *
   * @param {DOMNode|DOMWindow} element the element to set the class on
   * @param {string} className the CSS className
   * @returns {boolean} true if the element has the class, false if not
   */
  hasClass: function(element, className) {
    ("production" !== process.env.NODE_ENV ? invariant(
      !/\s/.test(className),
      'CSS.hasClass takes only a single class name.'
    ) : invariant(!/\s/.test(className)));
    if (element.classList) {
      return !!className && element.classList.contains(className);
    }
    return (' ' + element.className + ' ').indexOf(' ' + className + ' ') > -1;
  }

};

module.exports = CSSCore;

}).call(this,require('_process'))
},{"./invariant":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/invariant.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/CSSProperty.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule CSSProperty
 */

"use strict";

/**
 * CSS properties which accept numbers but are not in units of "px".
 */
var isUnitlessNumber = {
  columnCount: true,
  fillOpacity: true,
  flex: true,
  flexGrow: true,
  flexShrink: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  widows: true,
  zIndex: true,
  zoom: true
};

/**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */
function prefixKey(prefix, key) {
  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
}

/**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */
var prefixes = ['Webkit', 'ms', 'Moz', 'O'];

// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
// infinite loop, because it iterates over the newly added props too.
Object.keys(isUnitlessNumber).forEach(function(prop) {
  prefixes.forEach(function(prefix) {
    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
  });
});

/**
 * Most style properties can be unset by doing .style[prop] = '' but IE8
 * doesn't like doing that with shorthand properties so for the properties that
 * IE8 breaks on, which are listed here, we instead unset each of the
 * individual properties. See http://bugs.jquery.com/ticket/12385.
 * The 4-value 'clock' properties like margin, padding, border-width seem to
 * behave without any problems. Curiously, list-style works too without any
 * special prodding.
 */
var shorthandPropertyExpansions = {
  background: {
    backgroundImage: true,
    backgroundPosition: true,
    backgroundRepeat: true,
    backgroundColor: true
  },
  border: {
    borderWidth: true,
    borderStyle: true,
    borderColor: true
  },
  borderBottom: {
    borderBottomWidth: true,
    borderBottomStyle: true,
    borderBottomColor: true
  },
  borderLeft: {
    borderLeftWidth: true,
    borderLeftStyle: true,
    borderLeftColor: true
  },
  borderRight: {
    borderRightWidth: true,
    borderRightStyle: true,
    borderRightColor: true
  },
  borderTop: {
    borderTopWidth: true,
    borderTopStyle: true,
    borderTopColor: true
  },
  font: {
    fontStyle: true,
    fontVariant: true,
    fontWeight: true,
    fontSize: true,
    lineHeight: true,
    fontFamily: true
  }
};

var CSSProperty = {
  isUnitlessNumber: isUnitlessNumber,
  shorthandPropertyExpansions: shorthandPropertyExpansions
};

module.exports = CSSProperty;

},{}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/CSSPropertyOperations.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule CSSPropertyOperations
 * @typechecks static-only
 */

"use strict";

var CSSProperty = require("./CSSProperty");

var dangerousStyleValue = require("./dangerousStyleValue");
var hyphenateStyleName = require("./hyphenateStyleName");
var memoizeStringOnly = require("./memoizeStringOnly");

var processStyleName = memoizeStringOnly(function(styleName) {
  return hyphenateStyleName(styleName);
});

/**
 * Operations for dealing with CSS properties.
 */
var CSSPropertyOperations = {

  /**
   * Serializes a mapping of style properties for use as inline styles:
   *
   *   > createMarkupForStyles({width: '200px', height: 0})
   *   "width:200px;height:0;"
   *
   * Undefined values are ignored so that declarative programming is easier.
   * The result should be HTML-escaped before insertion into the DOM.
   *
   * @param {object} styles
   * @return {?string}
   */
  createMarkupForStyles: function(styles) {
    var serialized = '';
    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }
      var styleValue = styles[styleName];
      if (styleValue != null) {
        serialized += processStyleName(styleName) + ':';
        serialized += dangerousStyleValue(styleName, styleValue) + ';';
      }
    }
    return serialized || null;
  },

  /**
   * Sets the value for multiple styles on a node.  If a value is specified as
   * '' (empty string), the corresponding style property will be unset.
   *
   * @param {DOMElement} node
   * @param {object} styles
   */
  setValueForStyles: function(node, styles) {
    var style = node.style;
    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }
      var styleValue = dangerousStyleValue(styleName, styles[styleName]);
      if (styleValue) {
        style[styleName] = styleValue;
      } else {
        var expansion = CSSProperty.shorthandPropertyExpansions[styleName];
        if (expansion) {
          // Shorthand property that IE8 won't like unsetting, so unset each
          // component to placate it
          for (var individualStyleName in expansion) {
            style[individualStyleName] = '';
          }
        } else {
          style[styleName] = '';
        }
      }
    }
  }

};

module.exports = CSSPropertyOperations;

},{"./CSSProperty":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/CSSProperty.js","./dangerousStyleValue":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/dangerousStyleValue.js","./hyphenateStyleName":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/hyphenateStyleName.js","./memoizeStringOnly":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/memoizeStringOnly.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/CallbackQueue.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule CallbackQueue
 */

"use strict";

var PooledClass = require("./PooledClass");

var invariant = require("./invariant");
var mixInto = require("./mixInto");

/**
 * A specialized pseudo-event module to help keep track of components waiting to
 * be notified when their DOM representations are available for use.
 *
 * This implements `PooledClass`, so you should never need to instantiate this.
 * Instead, use `CallbackQueue.getPooled()`.
 *
 * @class ReactMountReady
 * @implements PooledClass
 * @internal
 */
function CallbackQueue() {
  this._callbacks = null;
  this._contexts = null;
}

mixInto(CallbackQueue, {

  /**
   * Enqueues a callback to be invoked when `notifyAll` is invoked.
   *
   * @param {function} callback Invoked when `notifyAll` is invoked.
   * @param {?object} context Context to call `callback` with.
   * @internal
   */
  enqueue: function(callback, context) {
    this._callbacks = this._callbacks || [];
    this._contexts = this._contexts || [];
    this._callbacks.push(callback);
    this._contexts.push(context);
  },

  /**
   * Invokes all enqueued callbacks and clears the queue. This is invoked after
   * the DOM representation of a component has been created or updated.
   *
   * @internal
   */
  notifyAll: function() {
    var callbacks = this._callbacks;
    var contexts = this._contexts;
    if (callbacks) {
      ("production" !== process.env.NODE_ENV ? invariant(
        callbacks.length === contexts.length,
        "Mismatched list of contexts in callback queue"
      ) : invariant(callbacks.length === contexts.length));
      this._callbacks = null;
      this._contexts = null;
      for (var i = 0, l = callbacks.length; i < l; i++) {
        callbacks[i].call(contexts[i]);
      }
      callbacks.length = 0;
      contexts.length = 0;
    }
  },

  /**
   * Resets the internal queue.
   *
   * @internal
   */
  reset: function() {
    this._callbacks = null;
    this._contexts = null;
  },

  /**
   * `PooledClass` looks for this.
   */
  destructor: function() {
    this.reset();
  }

});

PooledClass.addPoolingTo(CallbackQueue);

module.exports = CallbackQueue;

}).call(this,require('_process'))
},{"./PooledClass":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/PooledClass.js","./invariant":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/invariant.js","./mixInto":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/mixInto.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ChangeEventPlugin.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ChangeEventPlugin
 */

"use strict";

var EventConstants = require("./EventConstants");
var EventPluginHub = require("./EventPluginHub");
var EventPropagators = require("./EventPropagators");
var ExecutionEnvironment = require("./ExecutionEnvironment");
var ReactUpdates = require("./ReactUpdates");
var SyntheticEvent = require("./SyntheticEvent");

var isEventSupported = require("./isEventSupported");
var isTextInputElement = require("./isTextInputElement");
var keyOf = require("./keyOf");

var topLevelTypes = EventConstants.topLevelTypes;

var eventTypes = {
  change: {
    phasedRegistrationNames: {
      bubbled: keyOf({onChange: null}),
      captured: keyOf({onChangeCapture: null})
    },
    dependencies: [
      topLevelTypes.topBlur,
      topLevelTypes.topChange,
      topLevelTypes.topClick,
      topLevelTypes.topFocus,
      topLevelTypes.topInput,
      topLevelTypes.topKeyDown,
      topLevelTypes.topKeyUp,
      topLevelTypes.topSelectionChange
    ]
  }
};

/**
 * For IE shims
 */
var activeElement = null;
var activeElementID = null;
var activeElementValue = null;
var activeElementValueProp = null;

/**
 * SECTION: handle `change` event
 */
function shouldUseChangeEvent(elem) {
  return (
    elem.nodeName === 'SELECT' ||
    (elem.nodeName === 'INPUT' && elem.type === 'file')
  );
}

var doesChangeEventBubble = false;
if (ExecutionEnvironment.canUseDOM) {
  // See `handleChange` comment below
  doesChangeEventBubble = isEventSupported('change') && (
    !('documentMode' in document) || document.documentMode > 8
  );
}

function manualDispatchChangeEvent(nativeEvent) {
  var event = SyntheticEvent.getPooled(
    eventTypes.change,
    activeElementID,
    nativeEvent
  );
  EventPropagators.accumulateTwoPhaseDispatches(event);

  // If change and propertychange bubbled, we'd just bind to it like all the
  // other events and have it go through ReactBrowserEventEmitter. Since it
  // doesn't, we manually listen for the events and so we have to enqueue and
  // process the abstract event manually.
  //
  // Batching is necessary here in order to ensure that all event handlers run
  // before the next rerender (including event handlers attached to ancestor
  // elements instead of directly on the input). Without this, controlled
  // components don't work properly in conjunction with event bubbling because
  // the component is rerendered and the value reverted before all the event
  // handlers can run. See https://github.com/facebook/react/issues/708.
  ReactUpdates.batchedUpdates(runEventInBatch, event);
}

function runEventInBatch(event) {
  EventPluginHub.enqueueEvents(event);
  EventPluginHub.processEventQueue();
}

function startWatchingForChangeEventIE8(target, targetID) {
  activeElement = target;
  activeElementID = targetID;
  activeElement.attachEvent('onchange', manualDispatchChangeEvent);
}

function stopWatchingForChangeEventIE8() {
  if (!activeElement) {
    return;
  }
  activeElement.detachEvent('onchange', manualDispatchChangeEvent);
  activeElement = null;
  activeElementID = null;
}

function getTargetIDForChangeEvent(
    topLevelType,
    topLevelTarget,
    topLevelTargetID) {
  if (topLevelType === topLevelTypes.topChange) {
    return topLevelTargetID;
  }
}
function handleEventsForChangeEventIE8(
    topLevelType,
    topLevelTarget,
    topLevelTargetID) {
  if (topLevelType === topLevelTypes.topFocus) {
    // stopWatching() should be a noop here but we call it just in case we
    // missed a blur event somehow.
    stopWatchingForChangeEventIE8();
    startWatchingForChangeEventIE8(topLevelTarget, topLevelTargetID);
  } else if (topLevelType === topLevelTypes.topBlur) {
    stopWatchingForChangeEventIE8();
  }
}


/**
 * SECTION: handle `input` event
 */
var isInputEventSupported = false;
if (ExecutionEnvironment.canUseDOM) {
  // IE9 claims to support the input event but fails to trigger it when
  // deleting text, so we ignore its input events
  isInputEventSupported = isEventSupported('input') && (
    !('documentMode' in document) || document.documentMode > 9
  );
}

/**
 * (For old IE.) Replacement getter/setter for the `value` property that gets
 * set on the active element.
 */
var newValueProp =  {
  get: function() {
    return activeElementValueProp.get.call(this);
  },
  set: function(val) {
    // Cast to a string so we can do equality checks.
    activeElementValue = '' + val;
    activeElementValueProp.set.call(this, val);
  }
};

/**
 * (For old IE.) Starts tracking propertychange events on the passed-in element
 * and override the value property so that we can distinguish user events from
 * value changes in JS.
 */
function startWatchingForValueChange(target, targetID) {
  activeElement = target;
  activeElementID = targetID;
  activeElementValue = target.value;
  activeElementValueProp = Object.getOwnPropertyDescriptor(
    target.constructor.prototype,
    'value'
  );

  Object.defineProperty(activeElement, 'value', newValueProp);
  activeElement.attachEvent('onpropertychange', handlePropertyChange);
}

/**
 * (For old IE.) Removes the event listeners from the currently-tracked element,
 * if any exists.
 */
function stopWatchingForValueChange() {
  if (!activeElement) {
    return;
  }

  // delete restores the original property definition
  delete activeElement.value;
  activeElement.detachEvent('onpropertychange', handlePropertyChange);

  activeElement = null;
  activeElementID = null;
  activeElementValue = null;
  activeElementValueProp = null;
}

/**
 * (For old IE.) Handles a propertychange event, sending a `change` event if
 * the value of the active element has changed.
 */
function handlePropertyChange(nativeEvent) {
  if (nativeEvent.propertyName !== 'value') {
    return;
  }
  var value = nativeEvent.srcElement.value;
  if (value === activeElementValue) {
    return;
  }
  activeElementValue = value;

  manualDispatchChangeEvent(nativeEvent);
}

/**
 * If a `change` event should be fired, returns the target's ID.
 */
function getTargetIDForInputEvent(
    topLevelType,
    topLevelTarget,
    topLevelTargetID) {
  if (topLevelType === topLevelTypes.topInput) {
    // In modern browsers (i.e., not IE8 or IE9), the input event is exactly
    // what we want so fall through here and trigger an abstract event
    return topLevelTargetID;
  }
}

// For IE8 and IE9.
function handleEventsForInputEventIE(
    topLevelType,
    topLevelTarget,
    topLevelTargetID) {
  if (topLevelType === topLevelTypes.topFocus) {
    // In IE8, we can capture almost all .value changes by adding a
    // propertychange handler and looking for events with propertyName
    // equal to 'value'
    // In IE9, propertychange fires for most input events but is buggy and
    // doesn't fire when text is deleted, but conveniently, selectionchange
    // appears to fire in all of the remaining cases so we catch those and
    // forward the event if the value has changed
    // In either case, we don't want to call the event handler if the value
    // is changed from JS so we redefine a setter for `.value` that updates
    // our activeElementValue variable, allowing us to ignore those changes
    //
    // stopWatching() should be a noop here but we call it just in case we
    // missed a blur event somehow.
    stopWatchingForValueChange();
    startWatchingForValueChange(topLevelTarget, topLevelTargetID);
  } else if (topLevelType === topLevelTypes.topBlur) {
    stopWatchingForValueChange();
  }
}

// For IE8 and IE9.
function getTargetIDForInputEventIE(
    topLevelType,
    topLevelTarget,
    topLevelTargetID) {
  if (topLevelType === topLevelTypes.topSelectionChange ||
      topLevelType === topLevelTypes.topKeyUp ||
      topLevelType === topLevelTypes.topKeyDown) {
    // On the selectionchange event, the target is just document which isn't
    // helpful for us so just check activeElement instead.
    //
    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
    // propertychange on the first input event after setting `value` from a
    // script and fires only keydown, keypress, keyup. Catching keyup usually
    // gets it and catching keydown lets us fire an event for the first
    // keystroke if user does a key repeat (it'll be a little delayed: right
    // before the second keystroke). Other input methods (e.g., paste) seem to
    // fire selectionchange normally.
    if (activeElement && activeElement.value !== activeElementValue) {
      activeElementValue = activeElement.value;
      return activeElementID;
    }
  }
}


/**
 * SECTION: handle `click` event
 */
function shouldUseClickEvent(elem) {
  // Use the `click` event to detect changes to checkbox and radio inputs.
  // This approach works across all browsers, whereas `change` does not fire
  // until `blur` in IE8.
  return (
    elem.nodeName === 'INPUT' &&
    (elem.type === 'checkbox' || elem.type === 'radio')
  );
}

function getTargetIDForClickEvent(
    topLevelType,
    topLevelTarget,
    topLevelTargetID) {
  if (topLevelType === topLevelTypes.topClick) {
    return topLevelTargetID;
  }
}

/**
 * This plugin creates an `onChange` event that normalizes change events
 * across form elements. This event fires at a time when it's possible to
 * change the element's value without seeing a flicker.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - select
 */
var ChangeEventPlugin = {

  eventTypes: eventTypes,

  /**
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function(
      topLevelType,
      topLevelTarget,
      topLevelTargetID,
      nativeEvent) {

    var getTargetIDFunc, handleEventFunc;
    if (shouldUseChangeEvent(topLevelTarget)) {
      if (doesChangeEventBubble) {
        getTargetIDFunc = getTargetIDForChangeEvent;
      } else {
        handleEventFunc = handleEventsForChangeEventIE8;
      }
    } else if (isTextInputElement(topLevelTarget)) {
      if (isInputEventSupported) {
        getTargetIDFunc = getTargetIDForInputEvent;
      } else {
        getTargetIDFunc = getTargetIDForInputEventIE;
        handleEventFunc = handleEventsForInputEventIE;
      }
    } else if (shouldUseClickEvent(topLevelTarget)) {
      getTargetIDFunc = getTargetIDForClickEvent;
    }

    if (getTargetIDFunc) {
      var targetID = getTargetIDFunc(
        topLevelType,
        topLevelTarget,
        topLevelTargetID
      );
      if (targetID) {
        var event = SyntheticEvent.getPooled(
          eventTypes.change,
          targetID,
          nativeEvent
        );
        EventPropagators.accumulateTwoPhaseDispatches(event);
        return event;
      }
    }

    if (handleEventFunc) {
      handleEventFunc(
        topLevelType,
        topLevelTarget,
        topLevelTargetID
      );
    }
  }

};

module.exports = ChangeEventPlugin;

},{"./EventConstants":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/EventConstants.js","./EventPluginHub":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/EventPluginHub.js","./EventPropagators":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/EventPropagators.js","./ExecutionEnvironment":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ExecutionEnvironment.js","./ReactUpdates":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactUpdates.js","./SyntheticEvent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/SyntheticEvent.js","./isEventSupported":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/isEventSupported.js","./isTextInputElement":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/isTextInputElement.js","./keyOf":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/keyOf.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ClientReactRootIndex.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ClientReactRootIndex
 * @typechecks
 */

"use strict";

var nextReactRootIndex = 0;

var ClientReactRootIndex = {
  createReactRootIndex: function() {
    return nextReactRootIndex++;
  }
};

module.exports = ClientReactRootIndex;

},{}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/CompositionEventPlugin.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule CompositionEventPlugin
 * @typechecks static-only
 */

"use strict";

var EventConstants = require("./EventConstants");
var EventPropagators = require("./EventPropagators");
var ExecutionEnvironment = require("./ExecutionEnvironment");
var ReactInputSelection = require("./ReactInputSelection");
var SyntheticCompositionEvent = require("./SyntheticCompositionEvent");

var getTextContentAccessor = require("./getTextContentAccessor");
var keyOf = require("./keyOf");

var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
var START_KEYCODE = 229;

var useCompositionEvent = (
  ExecutionEnvironment.canUseDOM &&
  'CompositionEvent' in window
);

// In IE9+, we have access to composition events, but the data supplied
// by the native compositionend event may be incorrect. In Korean, for example,
// the compositionend event contains only one character regardless of
// how many characters have been composed since compositionstart.
// We therefore use the fallback data while still using the native
// events as triggers.
var useFallbackData = (
  !useCompositionEvent ||
  (
    'documentMode' in document &&
    document.documentMode > 8 &&
    document.documentMode <= 11
  )
);

var topLevelTypes = EventConstants.topLevelTypes;
var currentComposition = null;

// Events and their corresponding property names.
var eventTypes = {
  compositionEnd: {
    phasedRegistrationNames: {
      bubbled: keyOf({onCompositionEnd: null}),
      captured: keyOf({onCompositionEndCapture: null})
    },
    dependencies: [
      topLevelTypes.topBlur,
      topLevelTypes.topCompositionEnd,
      topLevelTypes.topKeyDown,
      topLevelTypes.topKeyPress,
      topLevelTypes.topKeyUp,
      topLevelTypes.topMouseDown
    ]
  },
  compositionStart: {
    phasedRegistrationNames: {
      bubbled: keyOf({onCompositionStart: null}),
      captured: keyOf({onCompositionStartCapture: null})
    },
    dependencies: [
      topLevelTypes.topBlur,
      topLevelTypes.topCompositionStart,
      topLevelTypes.topKeyDown,
      topLevelTypes.topKeyPress,
      topLevelTypes.topKeyUp,
      topLevelTypes.topMouseDown
    ]
  },
  compositionUpdate: {
    phasedRegistrationNames: {
      bubbled: keyOf({onCompositionUpdate: null}),
      captured: keyOf({onCompositionUpdateCapture: null})
    },
    dependencies: [
      topLevelTypes.topBlur,
      topLevelTypes.topCompositionUpdate,
      topLevelTypes.topKeyDown,
      topLevelTypes.topKeyPress,
      topLevelTypes.topKeyUp,
      topLevelTypes.topMouseDown
    ]
  }
};

/**
 * Translate native top level events into event types.
 *
 * @param {string} topLevelType
 * @return {object}
 */
function getCompositionEventType(topLevelType) {
  switch (topLevelType) {
    case topLevelTypes.topCompositionStart:
      return eventTypes.compositionStart;
    case topLevelTypes.topCompositionEnd:
      return eventTypes.compositionEnd;
    case topLevelTypes.topCompositionUpdate:
      return eventTypes.compositionUpdate;
  }
}

/**
 * Does our fallback best-guess model think this event signifies that
 * composition has begun?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackStart(topLevelType, nativeEvent) {
  return (
    topLevelType === topLevelTypes.topKeyDown &&
    nativeEvent.keyCode === START_KEYCODE
  );
}

/**
 * Does our fallback mode think that this event is the end of composition?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackEnd(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case topLevelTypes.topKeyUp:
      // Command keys insert or clear IME input.
      return (END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1);
    case topLevelTypes.topKeyDown:
      // Expect IME keyCode on each keydown. If we get any other
      // code we must have exited earlier.
      return (nativeEvent.keyCode !== START_KEYCODE);
    case topLevelTypes.topKeyPress:
    case topLevelTypes.topMouseDown:
    case topLevelTypes.topBlur:
      // Events are not possible without cancelling IME.
      return true;
    default:
      return false;
  }
}

/**
 * Helper class stores information about selection and document state
 * so we can figure out what changed at a later date.
 *
 * @param {DOMEventTarget} root
 */
function FallbackCompositionState(root) {
  this.root = root;
  this.startSelection = ReactInputSelection.getSelection(root);
  this.startValue = this.getText();
}

/**
 * Get current text of input.
 *
 * @return {string}
 */
FallbackCompositionState.prototype.getText = function() {
  return this.root.value || this.root[getTextContentAccessor()];
};

/**
 * Text that has changed since the start of composition.
 *
 * @return {string}
 */
FallbackCompositionState.prototype.getData = function() {
  var endValue = this.getText();
  var prefixLength = this.startSelection.start;
  var suffixLength = this.startValue.length - this.startSelection.end;

  return endValue.substr(
    prefixLength,
    endValue.length - suffixLength - prefixLength
  );
};

/**
 * This plugin creates `onCompositionStart`, `onCompositionUpdate` and
 * `onCompositionEnd` events on inputs, textareas and contentEditable
 * nodes.
 */
var CompositionEventPlugin = {

  eventTypes: eventTypes,

  /**
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function(
      topLevelType,
      topLevelTarget,
      topLevelTargetID,
      nativeEvent) {

    var eventType;
    var data;

    if (useCompositionEvent) {
      eventType = getCompositionEventType(topLevelType);
    } else if (!currentComposition) {
      if (isFallbackStart(topLevelType, nativeEvent)) {
        eventType = eventTypes.compositionStart;
      }
    } else if (isFallbackEnd(topLevelType, nativeEvent)) {
      eventType = eventTypes.compositionEnd;
    }

    if (useFallbackData) {
      // The current composition is stored statically and must not be
      // overwritten while composition continues.
      if (!currentComposition && eventType === eventTypes.compositionStart) {
        currentComposition = new FallbackCompositionState(topLevelTarget);
      } else if (eventType === eventTypes.compositionEnd) {
        if (currentComposition) {
          data = currentComposition.getData();
          currentComposition = null;
        }
      }
    }

    if (eventType) {
      var event = SyntheticCompositionEvent.getPooled(
        eventType,
        topLevelTargetID,
        nativeEvent
      );
      if (data) {
        // Inject data generated from fallback path into the synthetic event.
        // This matches the property of native CompositionEventInterface.
        event.data = data;
      }
      EventPropagators.accumulateTwoPhaseDispatches(event);
      return event;
    }
  }
};

module.exports = CompositionEventPlugin;

},{"./EventConstants":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/EventConstants.js","./EventPropagators":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/EventPropagators.js","./ExecutionEnvironment":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ExecutionEnvironment.js","./ReactInputSelection":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactInputSelection.js","./SyntheticCompositionEvent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/SyntheticCompositionEvent.js","./getTextContentAccessor":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/getTextContentAccessor.js","./keyOf":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/keyOf.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/DOMChildrenOperations.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule DOMChildrenOperations
 * @typechecks static-only
 */

"use strict";

var Danger = require("./Danger");
var ReactMultiChildUpdateTypes = require("./ReactMultiChildUpdateTypes");

var getTextContentAccessor = require("./getTextContentAccessor");
var invariant = require("./invariant");

/**
 * The DOM property to use when setting text content.
 *
 * @type {string}
 * @private
 */
var textContentAccessor = getTextContentAccessor();

/**
 * Inserts `childNode` as a child of `parentNode` at the `index`.
 *
 * @param {DOMElement} parentNode Parent node in which to insert.
 * @param {DOMElement} childNode Child node to insert.
 * @param {number} index Index at which to insert the child.
 * @internal
 */
function insertChildAt(parentNode, childNode, index) {
  // By exploiting arrays returning `undefined` for an undefined index, we can
  // rely exclusively on `insertBefore(node, null)` instead of also using
  // `appendChild(node)`. However, using `undefined` is not allowed by all
  // browsers so we must replace it with `null`.
  parentNode.insertBefore(
    childNode,
    parentNode.childNodes[index] || null
  );
}

var updateTextContent;
if (textContentAccessor === 'textContent') {
  /**
   * Sets the text content of `node` to `text`.
   *
   * @param {DOMElement} node Node to change
   * @param {string} text New text content
   */
  updateTextContent = function(node, text) {
    node.textContent = text;
  };
} else {
  /**
   * Sets the text content of `node` to `text`.
   *
   * @param {DOMElement} node Node to change
   * @param {string} text New text content
   */
  updateTextContent = function(node, text) {
    // In order to preserve newlines correctly, we can't use .innerText to set
    // the contents (see #1080), so we empty the element then append a text node
    while (node.firstChild) {
      node.removeChild(node.firstChild);
    }
    if (text) {
      var doc = node.ownerDocument || document;
      node.appendChild(doc.createTextNode(text));
    }
  };
}

/**
 * Operations for updating with DOM children.
 */
var DOMChildrenOperations = {

  dangerouslyReplaceNodeWithMarkup: Danger.dangerouslyReplaceNodeWithMarkup,

  updateTextContent: updateTextContent,

  /**
   * Updates a component's children by processing a series of updates. The
   * update configurations are each expected to have a `parentNode` property.
   *
   * @param {array<object>} updates List of update configurations.
   * @param {array<string>} markupList List of markup strings.
   * @internal
   */
  processUpdates: function(updates, markupList) {
    var update;
    // Mapping from parent IDs to initial child orderings.
    var initialChildren = null;
    // List of children that will be moved or removed.
    var updatedChildren = null;

    for (var i = 0; update = updates[i]; i++) {
      if (update.type === ReactMultiChildUpdateTypes.MOVE_EXISTING ||
          update.type === ReactMultiChildUpdateTypes.REMOVE_NODE) {
        var updatedIndex = update.fromIndex;
        var updatedChild = update.parentNode.childNodes[updatedIndex];
        var parentID = update.parentID;

        ("production" !== process.env.NODE_ENV ? invariant(
          updatedChild,
          'processUpdates(): Unable to find child %s of element. This ' +
          'probably means the DOM was unexpectedly mutated (e.g., by the ' +
          'browser), usually due to forgetting a <tbody> when using tables, ' +
          'nesting <p> or <a> tags, or using non-SVG elements in an <svg> '+
          'parent. Try inspecting the child nodes of the element with React ' +
          'ID `%s`.',
          updatedIndex,
          parentID
        ) : invariant(updatedChild));

        initialChildren = initialChildren || {};
        initialChildren[parentID] = initialChildren[parentID] || [];
        initialChildren[parentID][updatedIndex] = updatedChild;

        updatedChildren = updatedChildren || [];
        updatedChildren.push(updatedChild);
      }
    }

    var renderedMarkup = Danger.dangerouslyRenderMarkup(markupList);

    // Remove updated children first so that `toIndex` is consistent.
    if (updatedChildren) {
      for (var j = 0; j < updatedChildren.length; j++) {
        updatedChildren[j].parentNode.removeChild(updatedChildren[j]);
      }
    }

    for (var k = 0; update = updates[k]; k++) {
      switch (update.type) {
        case ReactMultiChildUpdateTypes.INSERT_MARKUP:
          insertChildAt(
            update.parentNode,
            renderedMarkup[update.markupIndex],
            update.toIndex
          );
          break;
        case ReactMultiChildUpdateTypes.MOVE_EXISTING:
          insertChildAt(
            update.parentNode,
            initialChildren[update.parentID][update.fromIndex],
            update.toIndex
          );
          break;
        case ReactMultiChildUpdateTypes.TEXT_CONTENT:
          updateTextContent(
            update.parentNode,
            update.textContent
          );
          break;
        case ReactMultiChildUpdateTypes.REMOVE_NODE:
          // Already removed by the for-loop above.
          break;
      }
    }
  }

};

module.exports = DOMChildrenOperations;

}).call(this,require('_process'))
},{"./Danger":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/Danger.js","./ReactMultiChildUpdateTypes":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactMultiChildUpdateTypes.js","./getTextContentAccessor":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/getTextContentAccessor.js","./invariant":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/invariant.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/DOMProperty.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule DOMProperty
 * @typechecks static-only
 */

/*jslint bitwise: true */

"use strict";

var invariant = require("./invariant");

var DOMPropertyInjection = {
  /**
   * Mapping from normalized, camelcased property names to a configuration that
   * specifies how the associated DOM property should be accessed or rendered.
   */
  MUST_USE_ATTRIBUTE: 0x1,
  MUST_USE_PROPERTY: 0x2,
  HAS_SIDE_EFFECTS: 0x4,
  HAS_BOOLEAN_VALUE: 0x8,
  HAS_NUMERIC_VALUE: 0x10,
  HAS_POSITIVE_NUMERIC_VALUE: 0x20 | 0x10,
  HAS_OVERLOADED_BOOLEAN_VALUE: 0x40,

  /**
   * Inject some specialized knowledge about the DOM. This takes a config object
   * with the following properties:
   *
   * isCustomAttribute: function that given an attribute name will return true
   * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*
   * attributes where it's impossible to enumerate all of the possible
   * attribute names,
   *
   * Properties: object mapping DOM property name to one of the
   * DOMPropertyInjection constants or null. If your attribute isn't in here,
   * it won't get written to the DOM.
   *
   * DOMAttributeNames: object mapping React attribute name to the DOM
   * attribute name. Attribute names not specified use the **lowercase**
   * normalized name.
   *
   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
   * Property names not specified use the normalized name.
   *
   * DOMMutationMethods: Properties that require special mutation methods. If
   * `value` is undefined, the mutation method should unset the property.
   *
   * @param {object} domPropertyConfig the config as described above.
   */
  injectDOMPropertyConfig: function(domPropertyConfig) {
    var Properties = domPropertyConfig.Properties || {};
    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
    var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};

    if (domPropertyConfig.isCustomAttribute) {
      DOMProperty._isCustomAttributeFunctions.push(
        domPropertyConfig.isCustomAttribute
      );
    }

    for (var propName in Properties) {
      ("production" !== process.env.NODE_ENV ? invariant(
        !DOMProperty.isStandardName.hasOwnProperty(propName),
        'injectDOMPropertyConfig(...): You\'re trying to inject DOM property ' +
        '\'%s\' which has already been injected. You may be accidentally ' +
        'injecting the same DOM property config twice, or you may be ' +
        'injecting two configs that have conflicting property names.',
        propName
      ) : invariant(!DOMProperty.isStandardName.hasOwnProperty(propName)));

      DOMProperty.isStandardName[propName] = true;

      var lowerCased = propName.toLowerCase();
      DOMProperty.getPossibleStandardName[lowerCased] = propName;

      if (DOMAttributeNames.hasOwnProperty(propName)) {
        var attributeName = DOMAttributeNames[propName];
        DOMProperty.getPossibleStandardName[attributeName] = propName;
        DOMProperty.getAttributeName[propName] = attributeName;
      } else {
        DOMProperty.getAttributeName[propName] = lowerCased;
      }

      DOMProperty.getPropertyName[propName] =
        DOMPropertyNames.hasOwnProperty(propName) ?
          DOMPropertyNames[propName] :
          propName;

      if (DOMMutationMethods.hasOwnProperty(propName)) {
        DOMProperty.getMutationMethod[propName] = DOMMutationMethods[propName];
      } else {
        DOMProperty.getMutationMethod[propName] = null;
      }

      var propConfig = Properties[propName];
      DOMProperty.mustUseAttribute[propName] =
        propConfig & DOMPropertyInjection.MUST_USE_ATTRIBUTE;
      DOMProperty.mustUseProperty[propName] =
        propConfig & DOMPropertyInjection.MUST_USE_PROPERTY;
      DOMProperty.hasSideEffects[propName] =
        propConfig & DOMPropertyInjection.HAS_SIDE_EFFECTS;
      DOMProperty.hasBooleanValue[propName] =
        propConfig & DOMPropertyInjection.HAS_BOOLEAN_VALUE;
      DOMProperty.hasNumericValue[propName] =
        propConfig & DOMPropertyInjection.HAS_NUMERIC_VALUE;
      DOMProperty.hasPositiveNumericValue[propName] =
        propConfig & DOMPropertyInjection.HAS_POSITIVE_NUMERIC_VALUE;
      DOMProperty.hasOverloadedBooleanValue[propName] =
        propConfig & DOMPropertyInjection.HAS_OVERLOADED_BOOLEAN_VALUE;

      ("production" !== process.env.NODE_ENV ? invariant(
        !DOMProperty.mustUseAttribute[propName] ||
          !DOMProperty.mustUseProperty[propName],
        'DOMProperty: Cannot require using both attribute and property: %s',
        propName
      ) : invariant(!DOMProperty.mustUseAttribute[propName] ||
        !DOMProperty.mustUseProperty[propName]));
      ("production" !== process.env.NODE_ENV ? invariant(
        DOMProperty.mustUseProperty[propName] ||
          !DOMProperty.hasSideEffects[propName],
        'DOMProperty: Properties that have side effects must use property: %s',
        propName
      ) : invariant(DOMProperty.mustUseProperty[propName] ||
        !DOMProperty.hasSideEffects[propName]));
      ("production" !== process.env.NODE_ENV ? invariant(
        !!DOMProperty.hasBooleanValue[propName] +
          !!DOMProperty.hasNumericValue[propName] +
          !!DOMProperty.hasOverloadedBooleanValue[propName] <= 1,
        'DOMProperty: Value can be one of boolean, overloaded boolean, or ' +
        'numeric value, but not a combination: %s',
        propName
      ) : invariant(!!DOMProperty.hasBooleanValue[propName] +
        !!DOMProperty.hasNumericValue[propName] +
        !!DOMProperty.hasOverloadedBooleanValue[propName] <= 1));
    }
  }
};
var defaultValueCache = {};

/**
 * DOMProperty exports lookup objects that can be used like functions:
 *
 *   > DOMProperty.isValid['id']
 *   true
 *   > DOMProperty.isValid['foobar']
 *   undefined
 *
 * Although this may be confusing, it performs better in general.
 *
 * @see http://jsperf.com/key-exists
 * @see http://jsperf.com/key-missing
 */
var DOMProperty = {

  ID_ATTRIBUTE_NAME: 'data-reactid',

  /**
   * Checks whether a property name is a standard property.
   * @type {Object}
   */
  isStandardName: {},

  /**
   * Mapping from lowercase property names to the properly cased version, used
   * to warn in the case of missing properties.
   * @type {Object}
   */
  getPossibleStandardName: {},

  /**
   * Mapping from normalized names to attribute names that differ. Attribute
   * names are used when rendering markup or with `*Attribute()`.
   * @type {Object}
   */
  getAttributeName: {},

  /**
   * Mapping from normalized names to properties on DOM node instances.
   * (This includes properties that mutate due to external factors.)
   * @type {Object}
   */
  getPropertyName: {},

  /**
   * Mapping from normalized names to mutation methods. This will only exist if
   * mutation cannot be set simply by the property or `setAttribute()`.
   * @type {Object}
   */
  getMutationMethod: {},

  /**
   * Whether the property must be accessed and mutated as an object property.
   * @type {Object}
   */
  mustUseAttribute: {},

  /**
   * Whether the property must be accessed and mutated using `*Attribute()`.
   * (This includes anything that fails `<propName> in <element>`.)
   * @type {Object}
   */
  mustUseProperty: {},

  /**
   * Whether or not setting a value causes side effects such as triggering
   * resources to be loaded or text selection changes. We must ensure that
   * the value is only set if it has changed.
   * @type {Object}
   */
  hasSideEffects: {},

  /**
   * Whether the property should be removed when set to a falsey value.
   * @type {Object}
   */
  hasBooleanValue: {},

  /**
   * Whether the property must be numeric or parse as a
   * numeric and should be removed when set to a falsey value.
   * @type {Object}
   */
  hasNumericValue: {},

  /**
   * Whether the property must be positive numeric or parse as a positive
   * numeric and should be removed when set to a falsey value.
   * @type {Object}
   */
  hasPositiveNumericValue: {},

  /**
   * Whether the property can be used as a flag as well as with a value. Removed
   * when strictly equal to false; present without a value when strictly equal
   * to true; present with a value otherwise.
   * @type {Object}
   */
  hasOverloadedBooleanValue: {},

  /**
   * All of the isCustomAttribute() functions that have been injected.
   */
  _isCustomAttributeFunctions: [],

  /**
   * Checks whether a property name is a custom attribute.
   * @method
   */
  isCustomAttribute: function(attributeName) {
    for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
      var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
      if (isCustomAttributeFn(attributeName)) {
        return true;
      }
    }
    return false;
  },

  /**
   * Returns the default property value for a DOM property (i.e., not an
   * attribute). Most default values are '' or false, but not all. Worse yet,
   * some (in particular, `type`) vary depending on the type of element.
   *
   * TODO: Is it better to grab all the possible properties when creating an
   * element to avoid having to create the same element twice?
   */
  getDefaultValueForProperty: function(nodeName, prop) {
    var nodeDefaults = defaultValueCache[nodeName];
    var testElement;
    if (!nodeDefaults) {
      defaultValueCache[nodeName] = nodeDefaults = {};
    }
    if (!(prop in nodeDefaults)) {
      testElement = document.createElement(nodeName);
      nodeDefaults[prop] = testElement[prop];
    }
    return nodeDefaults[prop];
  },

  injection: DOMPropertyInjection
};

module.exports = DOMProperty;

}).call(this,require('_process'))
},{"./invariant":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/invariant.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/DOMPropertyOperations.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule DOMPropertyOperations
 * @typechecks static-only
 */

"use strict";

var DOMProperty = require("./DOMProperty");

var escapeTextForBrowser = require("./escapeTextForBrowser");
var memoizeStringOnly = require("./memoizeStringOnly");
var warning = require("./warning");

function shouldIgnoreValue(name, value) {
  return value == null ||
    (DOMProperty.hasBooleanValue[name] && !value) ||
    (DOMProperty.hasNumericValue[name] && isNaN(value)) ||
    (DOMProperty.hasPositiveNumericValue[name] && (value < 1)) ||
    (DOMProperty.hasOverloadedBooleanValue[name] && value === false);
}

var processAttributeNameAndPrefix = memoizeStringOnly(function(name) {
  return escapeTextForBrowser(name) + '="';
});

if ("production" !== process.env.NODE_ENV) {
  var reactProps = {
    children: true,
    dangerouslySetInnerHTML: true,
    key: true,
    ref: true
  };
  var warnedProperties = {};

  var warnUnknownProperty = function(name) {
    if (reactProps.hasOwnProperty(name) && reactProps[name] ||
        warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
      return;
    }

    warnedProperties[name] = true;
    var lowerCasedName = name.toLowerCase();

    // data-* attributes should be lowercase; suggest the lowercase version
    var standardName = (
      DOMProperty.isCustomAttribute(lowerCasedName) ?
        lowerCasedName :
      DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ?
        DOMProperty.getPossibleStandardName[lowerCasedName] :
        null
    );

    // For now, only warn when we have a suggested correction. This prevents
    // logging too much when using transferPropsTo.
    ("production" !== process.env.NODE_ENV ? warning(
      standardName == null,
      'Unknown DOM property ' + name + '. Did you mean ' + standardName + '?'
    ) : null);

  };
}

/**
 * Operations for dealing with DOM properties.
 */
var DOMPropertyOperations = {

  /**
   * Creates markup for the ID property.
   *
   * @param {string} id Unescaped ID.
   * @return {string} Markup string.
   */
  createMarkupForID: function(id) {
    return processAttributeNameAndPrefix(DOMProperty.ID_ATTRIBUTE_NAME) +
      escapeTextForBrowser(id) + '"';
  },

  /**
   * Creates markup for a property.
   *
   * @param {string} name
   * @param {*} value
   * @return {?string} Markup string, or null if the property was invalid.
   */
  createMarkupForProperty: function(name, value) {
    if (DOMProperty.isStandardName.hasOwnProperty(name) &&
        DOMProperty.isStandardName[name]) {
      if (shouldIgnoreValue(name, value)) {
        return '';
      }
      var attributeName = DOMProperty.getAttributeName[name];
      if (DOMProperty.hasBooleanValue[name] ||
          (DOMProperty.hasOverloadedBooleanValue[name] && value === true)) {
        return escapeTextForBrowser(attributeName);
      }
      return processAttributeNameAndPrefix(attributeName) +
        escapeTextForBrowser(value) + '"';
    } else if (DOMProperty.isCustomAttribute(name)) {
      if (value == null) {
        return '';
      }
      return processAttributeNameAndPrefix(name) +
        escapeTextForBrowser(value) + '"';
    } else if ("production" !== process.env.NODE_ENV) {
      warnUnknownProperty(name);
    }
    return null;
  },

  /**
   * Sets the value for a property on a node.
   *
   * @param {DOMElement} node
   * @param {string} name
   * @param {*} value
   */
  setValueForProperty: function(node, name, value) {
    if (DOMProperty.isStandardName.hasOwnProperty(name) &&
        DOMProperty.isStandardName[name]) {
      var mutationMethod = DOMProperty.getMutationMethod[name];
      if (mutationMethod) {
        mutationMethod(node, value);
      } else if (shouldIgnoreValue(name, value)) {
        this.deleteValueForProperty(node, name);
      } else if (DOMProperty.mustUseAttribute[name]) {
        node.setAttribute(DOMProperty.getAttributeName[name], '' + value);
      } else {
        var propName = DOMProperty.getPropertyName[name];
        if (!DOMProperty.hasSideEffects[name] || node[propName] !== value) {
          node[propName] = value;
        }
      }
    } else if (DOMProperty.isCustomAttribute(name)) {
      if (value == null) {
        node.removeAttribute(name);
      } else {
        node.setAttribute(name, '' + value);
      }
    } else if ("production" !== process.env.NODE_ENV) {
      warnUnknownProperty(name);
    }
  },

  /**
   * Deletes the value for a property on a node.
   *
   * @param {DOMElement} node
   * @param {string} name
   */
  deleteValueForProperty: function(node, name) {
    if (DOMProperty.isStandardName.hasOwnProperty(name) &&
        DOMProperty.isStandardName[name]) {
      var mutationMethod = DOMProperty.getMutationMethod[name];
      if (mutationMethod) {
        mutationMethod(node, undefined);
      } else if (DOMProperty.mustUseAttribute[name]) {
        node.removeAttribute(DOMProperty.getAttributeName[name]);
      } else {
        var propName = DOMProperty.getPropertyName[name];
        var defaultValue = DOMProperty.getDefaultValueForProperty(
          node.nodeName,
          propName
        );
        if (!DOMProperty.hasSideEffects[name] ||
            node[propName] !== defaultValue) {
          node[propName] = defaultValue;
        }
      }
    } else if (DOMProperty.isCustomAttribute(name)) {
      node.removeAttribute(name);
    } else if ("production" !== process.env.NODE_ENV) {
      warnUnknownProperty(name);
    }
  }

};

module.exports = DOMPropertyOperations;

}).call(this,require('_process'))
},{"./DOMProperty":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/DOMProperty.js","./escapeTextForBrowser":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/escapeTextForBrowser.js","./memoizeStringOnly":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/memoizeStringOnly.js","./warning":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/warning.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/Danger.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule Danger
 * @typechecks static-only
 */

/*jslint evil: true, sub: true */

"use strict";

var ExecutionEnvironment = require("./ExecutionEnvironment");

var createNodesFromMarkup = require("./createNodesFromMarkup");
var emptyFunction = require("./emptyFunction");
var getMarkupWrap = require("./getMarkupWrap");
var invariant = require("./invariant");

var OPEN_TAG_NAME_EXP = /^(<[^ \/>]+)/;
var RESULT_INDEX_ATTR = 'data-danger-index';

/**
 * Extracts the `nodeName` from a string of markup.
 *
 * NOTE: Extracting the `nodeName` does not require a regular expression match
 * because we make assumptions about React-generated markup (i.e. there are no
 * spaces surrounding the opening tag and there is at least one attribute).
 *
 * @param {string} markup String of markup.
 * @return {string} Node name of the supplied markup.
 * @see http://jsperf.com/extract-nodename
 */
function getNodeName(markup) {
  return markup.substring(1, markup.indexOf(' '));
}

var Danger = {

  /**
   * Renders markup into an array of nodes. The markup is expected to render
   * into a list of root nodes. Also, the length of `resultList` and
   * `markupList` should be the same.
   *
   * @param {array<string>} markupList List of markup strings to render.
   * @return {array<DOMElement>} List of rendered nodes.
   * @internal
   */
  dangerouslyRenderMarkup: function(markupList) {
    ("production" !== process.env.NODE_ENV ? invariant(
      ExecutionEnvironment.canUseDOM,
      'dangerouslyRenderMarkup(...): Cannot render markup in a Worker ' +
      'thread. This is likely a bug in the framework. Please report ' +
      'immediately.'
    ) : invariant(ExecutionEnvironment.canUseDOM));
    var nodeName;
    var markupByNodeName = {};
    // Group markup by `nodeName` if a wrap is necessary, else by '*'.
    for (var i = 0; i < markupList.length; i++) {
      ("production" !== process.env.NODE_ENV ? invariant(
        markupList[i],
        'dangerouslyRenderMarkup(...): Missing markup.'
      ) : invariant(markupList[i]));
      nodeName = getNodeName(markupList[i]);
      nodeName = getMarkupWrap(nodeName) ? nodeName : '*';
      markupByNodeName[nodeName] = markupByNodeName[nodeName] || [];
      markupByNodeName[nodeName][i] = markupList[i];
    }
    var resultList = [];
    var resultListAssignmentCount = 0;
    for (nodeName in markupByNodeName) {
      if (!markupByNodeName.hasOwnProperty(nodeName)) {
        continue;
      }
      var markupListByNodeName = markupByNodeName[nodeName];

      // This for-in loop skips the holes of the sparse array. The order of
      // iteration should follow the order of assignment, which happens to match
      // numerical index order, but we don't rely on that.
      for (var resultIndex in markupListByNodeName) {
        if (markupListByNodeName.hasOwnProperty(resultIndex)) {
          var markup = markupListByNodeName[resultIndex];

          // Push the requested markup with an additional RESULT_INDEX_ATTR
          // attribute.  If the markup does not start with a < character, it
          // will be discarded below (with an appropriate console.error).
          markupListByNodeName[resultIndex] = markup.replace(
            OPEN_TAG_NAME_EXP,
            // This index will be parsed back out below.
            '$1 ' + RESULT_INDEX_ATTR + '="' + resultIndex + '" '
          );
        }
      }

      // Render each group of markup with similar wrapping `nodeName`.
      var renderNodes = createNodesFromMarkup(
        markupListByNodeName.join(''),
        emptyFunction // Do nothing special with <script> tags.
      );

      for (i = 0; i < renderNodes.length; ++i) {
        var renderNode = renderNodes[i];
        if (renderNode.hasAttribute &&
            renderNode.hasAttribute(RESULT_INDEX_ATTR)) {

          resultIndex = +renderNode.getAttribute(RESULT_INDEX_ATTR);
          renderNode.removeAttribute(RESULT_INDEX_ATTR);

          ("production" !== process.env.NODE_ENV ? invariant(
            !resultList.hasOwnProperty(resultIndex),
            'Danger: Assigning to an already-occupied result index.'
          ) : invariant(!resultList.hasOwnProperty(resultIndex)));

          resultList[resultIndex] = renderNode;

          // This should match resultList.length and markupList.length when
          // we're done.
          resultListAssignmentCount += 1;

        } else if ("production" !== process.env.NODE_ENV) {
          console.error(
            "Danger: Discarding unexpected node:",
            renderNode
          );
        }
      }
    }

    // Although resultList was populated out of order, it should now be a dense
    // array.
    ("production" !== process.env.NODE_ENV ? invariant(
      resultListAssignmentCount === resultList.length,
      'Danger: Did not assign to every index of resultList.'
    ) : invariant(resultListAssignmentCount === resultList.length));

    ("production" !== process.env.NODE_ENV ? invariant(
      resultList.length === markupList.length,
      'Danger: Expected markup to render %s nodes, but rendered %s.',
      markupList.length,
      resultList.length
    ) : invariant(resultList.length === markupList.length));

    return resultList;
  },

  /**
   * Replaces a node with a string of markup at its current position within its
   * parent. The markup must render into a single root node.
   *
   * @param {DOMElement} oldChild Child node to replace.
   * @param {string} markup Markup to render in place of the child node.
   * @internal
   */
  dangerouslyReplaceNodeWithMarkup: function(oldChild, markup) {
    ("production" !== process.env.NODE_ENV ? invariant(
      ExecutionEnvironment.canUseDOM,
      'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a ' +
      'worker thread. This is likely a bug in the framework. Please report ' +
      'immediately.'
    ) : invariant(ExecutionEnvironment.canUseDOM));
    ("production" !== process.env.NODE_ENV ? invariant(markup, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : invariant(markup));
    ("production" !== process.env.NODE_ENV ? invariant(
      oldChild.tagName.toLowerCase() !== 'html',
      'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the ' +
      '<html> node. This is because browser quirks make this unreliable ' +
      'and/or slow. If you want to render to the root you must use ' +
      'server rendering. See renderComponentToString().'
    ) : invariant(oldChild.tagName.toLowerCase() !== 'html'));

    var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
    oldChild.parentNode.replaceChild(newChild, oldChild);
  }

};

module.exports = Danger;

}).call(this,require('_process'))
},{"./ExecutionEnvironment":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ExecutionEnvironment.js","./createNodesFromMarkup":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/createNodesFromMarkup.js","./emptyFunction":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/emptyFunction.js","./getMarkupWrap":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/getMarkupWrap.js","./invariant":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/invariant.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/DefaultEventPluginOrder.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule DefaultEventPluginOrder
 */

"use strict";

 var keyOf = require("./keyOf");

/**
 * Module that is injectable into `EventPluginHub`, that specifies a
 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
 * plugins, without having to package every one of them. This is better than
 * having plugins be ordered in the same order that they are injected because
 * that ordering would be influenced by the packaging order.
 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
 */
var DefaultEventPluginOrder = [
  keyOf({ResponderEventPlugin: null}),
  keyOf({SimpleEventPlugin: null}),
  keyOf({TapEventPlugin: null}),
  keyOf({EnterLeaveEventPlugin: null}),
  keyOf({ChangeEventPlugin: null}),
  keyOf({SelectEventPlugin: null}),
  keyOf({CompositionEventPlugin: null}),
  keyOf({BeforeInputEventPlugin: null}),
  keyOf({AnalyticsEventPlugin: null}),
  keyOf({MobileSafariClickEventPlugin: null})
];

module.exports = DefaultEventPluginOrder;

},{"./keyOf":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/keyOf.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/EnterLeaveEventPlugin.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule EnterLeaveEventPlugin
 * @typechecks static-only
 */

"use strict";

var EventConstants = require("./EventConstants");
var EventPropagators = require("./EventPropagators");
var SyntheticMouseEvent = require("./SyntheticMouseEvent");

var ReactMount = require("./ReactMount");
var keyOf = require("./keyOf");

var topLevelTypes = EventConstants.topLevelTypes;
var getFirstReactDOM = ReactMount.getFirstReactDOM;

var eventTypes = {
  mouseEnter: {
    registrationName: keyOf({onMouseEnter: null}),
    dependencies: [
      topLevelTypes.topMouseOut,
      topLevelTypes.topMouseOver
    ]
  },
  mouseLeave: {
    registrationName: keyOf({onMouseLeave: null}),
    dependencies: [
      topLevelTypes.topMouseOut,
      topLevelTypes.topMouseOver
    ]
  }
};

var extractedEvents = [null, null];

var EnterLeaveEventPlugin = {

  eventTypes: eventTypes,

  /**
   * For almost every interaction we care about, there will be both a top-level
   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
   * we do not extract duplicate events. However, moving the mouse into the
   * browser from outside will not fire a `mouseout` event. In this case, we use
   * the `mouseover` top-level event.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function(
      topLevelType,
      topLevelTarget,
      topLevelTargetID,
      nativeEvent) {
    if (topLevelType === topLevelTypes.topMouseOver &&
        (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
      return null;
    }
    if (topLevelType !== topLevelTypes.topMouseOut &&
        topLevelType !== topLevelTypes.topMouseOver) {
      // Must not be a mouse in or mouse out - ignoring.
      return null;
    }

    var win;
    if (topLevelTarget.window === topLevelTarget) {
      // `topLevelTarget` is probably a window object.
      win = topLevelTarget;
    } else {
      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
      var doc = topLevelTarget.ownerDocument;
      if (doc) {
        win = doc.defaultView || doc.parentWindow;
      } else {
        win = window;
      }
    }

    var from, to;
    if (topLevelType === topLevelTypes.topMouseOut) {
      from = topLevelTarget;
      to =
        getFirstReactDOM(nativeEvent.relatedTarget || nativeEvent.toElement) ||
        win;
    } else {
      from = win;
      to = topLevelTarget;
    }

    if (from === to) {
      // Nothing pertains to our managed components.
      return null;
    }

    var fromID = from ? ReactMount.getID(from) : '';
    var toID = to ? ReactMount.getID(to) : '';

    var leave = SyntheticMouseEvent.getPooled(
      eventTypes.mouseLeave,
      fromID,
      nativeEvent
    );
    leave.type = 'mouseleave';
    leave.target = from;
    leave.relatedTarget = to;

    var enter = SyntheticMouseEvent.getPooled(
      eventTypes.mouseEnter,
      toID,
      nativeEvent
    );
    enter.type = 'mouseenter';
    enter.target = to;
    enter.relatedTarget = from;

    EventPropagators.accumulateEnterLeaveDispatches(leave, enter, fromID, toID);

    extractedEvents[0] = leave;
    extractedEvents[1] = enter;

    return extractedEvents;
  }

};

module.exports = EnterLeaveEventPlugin;

},{"./EventConstants":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/EventConstants.js","./EventPropagators":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/EventPropagators.js","./ReactMount":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactMount.js","./SyntheticMouseEvent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/SyntheticMouseEvent.js","./keyOf":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/keyOf.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/EventConstants.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule EventConstants
 */

"use strict";

var keyMirror = require("./keyMirror");

var PropagationPhases = keyMirror({bubbled: null, captured: null});

/**
 * Types of raw signals from the browser caught at the top level.
 */
var topLevelTypes = keyMirror({
  topBlur: null,
  topChange: null,
  topClick: null,
  topCompositionEnd: null,
  topCompositionStart: null,
  topCompositionUpdate: null,
  topContextMenu: null,
  topCopy: null,
  topCut: null,
  topDoubleClick: null,
  topDrag: null,
  topDragEnd: null,
  topDragEnter: null,
  topDragExit: null,
  topDragLeave: null,
  topDragOver: null,
  topDragStart: null,
  topDrop: null,
  topError: null,
  topFocus: null,
  topInput: null,
  topKeyDown: null,
  topKeyPress: null,
  topKeyUp: null,
  topLoad: null,
  topMouseDown: null,
  topMouseMove: null,
  topMouseOut: null,
  topMouseOver: null,
  topMouseUp: null,
  topPaste: null,
  topReset: null,
  topScroll: null,
  topSelectionChange: null,
  topSubmit: null,
  topTextInput: null,
  topTouchCancel: null,
  topTouchEnd: null,
  topTouchMove: null,
  topTouchStart: null,
  topWheel: null
});

var EventConstants = {
  topLevelTypes: topLevelTypes,
  PropagationPhases: PropagationPhases
};

module.exports = EventConstants;

},{"./keyMirror":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/keyMirror.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/EventListener.js":[function(require,module,exports){
(function (process){
/**
 * @providesModule EventListener
 * @typechecks
 */

var emptyFunction = require("./emptyFunction");

/**
 * Upstream version of event listener. Does not take into account specific
 * nature of platform.
 */
var EventListener = {
  /**
   * Listen to DOM events during the bubble phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  listen: function(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, false);
      return {
        remove: function() {
          target.removeEventListener(eventType, callback, false);
        }
      };
    } else if (target.attachEvent) {
      target.attachEvent('on' + eventType, callback);
      return {
        remove: function() {
          target.detachEvent('on' + eventType, callback);
        }
      };
    }
  },

  /**
   * Listen to DOM events during the capture phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  capture: function(target, eventType, callback) {
    if (!target.addEventListener) {
      if ("production" !== process.env.NODE_ENV) {
        console.error(
          'Attempted to listen to events during the capture phase on a ' +
          'browser that does not support the capture phase. Your application ' +
          'will not receive some events.'
        );
      }
      return {
        remove: emptyFunction
      };
    } else {
      target.addEventListener(eventType, callback, true);
      return {
        remove: function() {
          target.removeEventListener(eventType, callback, true);
        }
      };
    }
  },

  registerDefault: function() {}
};

module.exports = EventListener;

}).call(this,require('_process'))
},{"./emptyFunction":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/emptyFunction.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/EventPluginHub.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule EventPluginHub
 */

"use strict";

var EventPluginRegistry = require("./EventPluginRegistry");
var EventPluginUtils = require("./EventPluginUtils");

var accumulate = require("./accumulate");
var forEachAccumulated = require("./forEachAccumulated");
var invariant = require("./invariant");
var isEventSupported = require("./isEventSupported");
var monitorCodeUse = require("./monitorCodeUse");

/**
 * Internal store for event listeners
 */
var listenerBank = {};

/**
 * Internal queue of events that have accumulated their dispatches and are
 * waiting to have their dispatches executed.
 */
var eventQueue = null;

/**
 * Dispatches an event and releases it back into the pool, unless persistent.
 *
 * @param {?object} event Synthetic event to be dispatched.
 * @private
 */
var executeDispatchesAndRelease = function(event) {
  if (event) {
    var executeDispatch = EventPluginUtils.executeDispatch;
    // Plugins can provide custom behavior when dispatching events.
    var PluginModule = EventPluginRegistry.getPluginModuleForEvent(event);
    if (PluginModule && PluginModule.executeDispatch) {
      executeDispatch = PluginModule.executeDispatch;
    }
    EventPluginUtils.executeDispatchesInOrder(event, executeDispatch);

    if (!event.isPersistent()) {
      event.constructor.release(event);
    }
  }
};

/**
 * - `InstanceHandle`: [required] Module that performs logical traversals of DOM
 *   hierarchy given ids of the logical DOM elements involved.
 */
var InstanceHandle = null;

function validateInstanceHandle() {
  var invalid = !InstanceHandle||
    !InstanceHandle.traverseTwoPhase ||
    !InstanceHandle.traverseEnterLeave;
  if (invalid) {
    throw new Error('InstanceHandle not injected before use!');
  }
}

/**
 * This is a unified interface for event plugins to be installed and configured.
 *
 * Event plugins can implement the following properties:
 *
 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
 *     Required. When a top-level event is fired, this method is expected to
 *     extract synthetic events that will in turn be queued and dispatched.
 *
 *   `eventTypes` {object}
 *     Optional, plugins that fire events must publish a mapping of registration
 *     names that are used to register listeners. Values of this mapping must
 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
 *
 *   `executeDispatch` {function(object, function, string)}
 *     Optional, allows plugins to override how an event gets dispatched. By
 *     default, the listener is simply invoked.
 *
 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
 *
 * @public
 */
var EventPluginHub = {

  /**
   * Methods for injecting dependencies.
   */
  injection: {

    /**
     * @param {object} InjectedMount
     * @public
     */
    injectMount: EventPluginUtils.injection.injectMount,

    /**
     * @param {object} InjectedInstanceHandle
     * @public
     */
    injectInstanceHandle: function(InjectedInstanceHandle) {
      InstanceHandle = InjectedInstanceHandle;
      if ("production" !== process.env.NODE_ENV) {
        validateInstanceHandle();
      }
    },

    getInstanceHandle: function() {
      if ("production" !== process.env.NODE_ENV) {
        validateInstanceHandle();
      }
      return InstanceHandle;
    },

    /**
     * @param {array} InjectedEventPluginOrder
     * @public
     */
    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,

    /**
     * @param {object} injectedNamesToPlugins Map from names to plugin modules.
     */
    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName

  },

  eventNameDispatchConfigs: EventPluginRegistry.eventNameDispatchConfigs,

  registrationNameModules: EventPluginRegistry.registrationNameModules,

  /**
   * Stores `listener` at `listenerBank[registrationName][id]`. Is idempotent.
   *
   * @param {string} id ID of the DOM element.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @param {?function} listener The callback to store.
   */
  putListener: function(id, registrationName, listener) {
    ("production" !== process.env.NODE_ENV ? invariant(
      !listener || typeof listener === 'function',
      'Expected %s listener to be a function, instead got type %s',
      registrationName, typeof listener
    ) : invariant(!listener || typeof listener === 'function'));

    if ("production" !== process.env.NODE_ENV) {
      // IE8 has no API for event capturing and the `onScroll` event doesn't
      // bubble.
      if (registrationName === 'onScroll' &&
          !isEventSupported('scroll', true)) {
        monitorCodeUse('react_no_scroll_event');
        console.warn('This browser doesn\'t support the `onScroll` event');
      }
    }
    var bankForRegistrationName =
      listenerBank[registrationName] || (listenerBank[registrationName] = {});
    bankForRegistrationName[id] = listener;
  },

  /**
   * @param {string} id ID of the DOM element.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @return {?function} The stored callback.
   */
  getListener: function(id, registrationName) {
    var bankForRegistrationName = listenerBank[registrationName];
    return bankForRegistrationName && bankForRegistrationName[id];
  },

  /**
   * Deletes a listener from the registration bank.
   *
   * @param {string} id ID of the DOM element.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   */
  deleteListener: function(id, registrationName) {
    var bankForRegistrationName = listenerBank[registrationName];
    if (bankForRegistrationName) {
      delete bankForRegistrationName[id];
    }
  },

  /**
   * Deletes all listeners for the DOM element with the supplied ID.
   *
   * @param {string} id ID of the DOM element.
   */
  deleteAllListeners: function(id) {
    for (var registrationName in listenerBank) {
      delete listenerBank[registrationName][id];
    }
  },

  /**
   * Allows registered plugins an opportunity to extract events from top-level
   * native browser events.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @internal
   */
  extractEvents: function(
      topLevelType,
      topLevelTarget,
      topLevelTargetID,
      nativeEvent) {
    var events;
    var plugins = EventPluginRegistry.plugins;
    for (var i = 0, l = plugins.length; i < l; i++) {
      // Not every plugin in the ordering may be loaded at runtime.
      var possiblePlugin = plugins[i];
      if (possiblePlugin) {
        var extractedEvents = possiblePlugin.extractEvents(
          topLevelType,
          topLevelTarget,
          topLevelTargetID,
          nativeEvent
        );
        if (extractedEvents) {
          events = accumulate(events, extractedEvents);
        }
      }
    }
    return events;
  },

  /**
   * Enqueues a synthetic event that should be dispatched when
   * `processEventQueue` is invoked.
   *
   * @param {*} events An accumulation of synthetic events.
   * @internal
   */
  enqueueEvents: function(events) {
    if (events) {
      eventQueue = accumulate(eventQueue, events);
    }
  },

  /**
   * Dispatches all synthetic events on the event queue.
   *
   * @internal
   */
  processEventQueue: function() {
    // Set `eventQueue` to null before processing it so that we can tell if more
    // events get enqueued while processing.
    var processingEventQueue = eventQueue;
    eventQueue = null;
    forEachAccumulated(processingEventQueue, executeDispatchesAndRelease);
    ("production" !== process.env.NODE_ENV ? invariant(
      !eventQueue,
      'processEventQueue(): Additional events were enqueued while processing ' +
      'an event queue. Support for this has not yet been implemented.'
    ) : invariant(!eventQueue));
  },

  /**
   * These are needed for tests only. Do not use!
   */
  __purge: function() {
    listenerBank = {};
  },

  __getListenerBank: function() {
    return listenerBank;
  }

};

module.exports = EventPluginHub;

}).call(this,require('_process'))
},{"./EventPluginRegistry":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/EventPluginRegistry.js","./EventPluginUtils":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/EventPluginUtils.js","./accumulate":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/accumulate.js","./forEachAccumulated":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/forEachAccumulated.js","./invariant":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/invariant.js","./isEventSupported":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/isEventSupported.js","./monitorCodeUse":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/monitorCodeUse.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/EventPluginRegistry.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule EventPluginRegistry
 * @typechecks static-only
 */

"use strict";

var invariant = require("./invariant");

/**
 * Injectable ordering of event plugins.
 */
var EventPluginOrder = null;

/**
 * Injectable mapping from names to event plugin modules.
 */
var namesToPlugins = {};

/**
 * Recomputes the plugin list using the injected plugins and plugin ordering.
 *
 * @private
 */
function recomputePluginOrdering() {
  if (!EventPluginOrder) {
    // Wait until an `EventPluginOrder` is injected.
    return;
  }
  for (var pluginName in namesToPlugins) {
    var PluginModule = namesToPlugins[pluginName];
    var pluginIndex = EventPluginOrder.indexOf(pluginName);
    ("production" !== process.env.NODE_ENV ? invariant(
      pluginIndex > -1,
      'EventPluginRegistry: Cannot inject event plugins that do not exist in ' +
      'the plugin ordering, `%s`.',
      pluginName
    ) : invariant(pluginIndex > -1));
    if (EventPluginRegistry.plugins[pluginIndex]) {
      continue;
    }
    ("production" !== process.env.NODE_ENV ? invariant(
      PluginModule.extractEvents,
      'EventPluginRegistry: Event plugins must implement an `extractEvents` ' +
      'method, but `%s` does not.',
      pluginName
    ) : invariant(PluginModule.extractEvents));
    EventPluginRegistry.plugins[pluginIndex] = PluginModule;
    var publishedEvents = PluginModule.eventTypes;
    for (var eventName in publishedEvents) {
      ("production" !== process.env.NODE_ENV ? invariant(
        publishEventForPlugin(
          publishedEvents[eventName],
          PluginModule,
          eventName
        ),
        'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.',
        eventName,
        pluginName
      ) : invariant(publishEventForPlugin(
        publishedEvents[eventName],
        PluginModule,
        eventName
      )));
    }
  }
}

/**
 * Publishes an event so that it can be dispatched by the supplied plugin.
 *
 * @param {object} dispatchConfig Dispatch configuration for the event.
 * @param {object} PluginModule Plugin publishing the event.
 * @return {boolean} True if the event was successfully published.
 * @private
 */
function publishEventForPlugin(dispatchConfig, PluginModule, eventName) {
  ("production" !== process.env.NODE_ENV ? invariant(
    !EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName),
    'EventPluginHub: More than one plugin attempted to publish the same ' +
    'event name, `%s`.',
    eventName
  ) : invariant(!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName)));
  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;

  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
  if (phasedRegistrationNames) {
    for (var phaseName in phasedRegistrationNames) {
      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
        var phasedRegistrationName = phasedRegistrationNames[phaseName];
        publishRegistrationName(
          phasedRegistrationName,
          PluginModule,
          eventName
        );
      }
    }
    return true;
  } else if (dispatchConfig.registrationName) {
    publishRegistrationName(
      dispatchConfig.registrationName,
      PluginModule,
      eventName
    );
    return true;
  }
  return false;
}

/**
 * Publishes a registration name that is used to identify dispatched events and
 * can be used with `EventPluginHub.putListener` to register listeners.
 *
 * @param {string} registrationName Registration name to add.
 * @param {object} PluginModule Plugin publishing the event.
 * @private
 */
function publishRegistrationName(registrationName, PluginModule, eventName) {
  ("production" !== process.env.NODE_ENV ? invariant(
    !EventPluginRegistry.registrationNameModules[registrationName],
    'EventPluginHub: More than one plugin attempted to publish the same ' +
    'registration name, `%s`.',
    registrationName
  ) : invariant(!EventPluginRegistry.registrationNameModules[registrationName]));
  EventPluginRegistry.registrationNameModules[registrationName] = PluginModule;
  EventPluginRegistry.registrationNameDependencies[registrationName] =
    PluginModule.eventTypes[eventName].dependencies;
}

/**
 * Registers plugins so that they can extract and dispatch events.
 *
 * @see {EventPluginHub}
 */
var EventPluginRegistry = {

  /**
   * Ordered list of injected plugins.
   */
  plugins: [],

  /**
   * Mapping from event name to dispatch config
   */
  eventNameDispatchConfigs: {},

  /**
   * Mapping from registration name to plugin module
   */
  registrationNameModules: {},

  /**
   * Mapping from registration name to event name
   */
  registrationNameDependencies: {},

  /**
   * Injects an ordering of plugins (by plugin name). This allows the ordering
   * to be decoupled from injection of the actual plugins so that ordering is
   * always deterministic regardless of packaging, on-the-fly injection, etc.
   *
   * @param {array} InjectedEventPluginOrder
   * @internal
   * @see {EventPluginHub.injection.injectEventPluginOrder}
   */
  injectEventPluginOrder: function(InjectedEventPluginOrder) {
    ("production" !== process.env.NODE_ENV ? invariant(
      !EventPluginOrder,
      'EventPluginRegistry: Cannot inject event plugin ordering more than ' +
      'once. You are likely trying to load more than one copy of React.'
    ) : invariant(!EventPluginOrder));
    // Clone the ordering so it cannot be dynamically mutated.
    EventPluginOrder = Array.prototype.slice.call(InjectedEventPluginOrder);
    recomputePluginOrdering();
  },

  /**
   * Injects plugins to be used by `EventPluginHub`. The plugin names must be
   * in the ordering injected by `injectEventPluginOrder`.
   *
   * Plugins can be injected as part of page initialization or on-the-fly.
   *
   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
   * @internal
   * @see {EventPluginHub.injection.injectEventPluginsByName}
   */
  injectEventPluginsByName: function(injectedNamesToPlugins) {
    var isOrderingDirty = false;
    for (var pluginName in injectedNamesToPlugins) {
      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
        continue;
      }
      var PluginModule = injectedNamesToPlugins[pluginName];
      if (!namesToPlugins.hasOwnProperty(pluginName) ||
          namesToPlugins[pluginName] !== PluginModule) {
        ("production" !== process.env.NODE_ENV ? invariant(
          !namesToPlugins[pluginName],
          'EventPluginRegistry: Cannot inject two different event plugins ' +
          'using the same name, `%s`.',
          pluginName
        ) : invariant(!namesToPlugins[pluginName]));
        namesToPlugins[pluginName] = PluginModule;
        isOrderingDirty = true;
      }
    }
    if (isOrderingDirty) {
      recomputePluginOrdering();
    }
  },

  /**
   * Looks up the plugin for the supplied event.
   *
   * @param {object} event A synthetic event.
   * @return {?object} The plugin that created the supplied event.
   * @internal
   */
  getPluginModuleForEvent: function(event) {
    var dispatchConfig = event.dispatchConfig;
    if (dispatchConfig.registrationName) {
      return EventPluginRegistry.registrationNameModules[
        dispatchConfig.registrationName
      ] || null;
    }
    for (var phase in dispatchConfig.phasedRegistrationNames) {
      if (!dispatchConfig.phasedRegistrationNames.hasOwnProperty(phase)) {
        continue;
      }
      var PluginModule = EventPluginRegistry.registrationNameModules[
        dispatchConfig.phasedRegistrationNames[phase]
      ];
      if (PluginModule) {
        return PluginModule;
      }
    }
    return null;
  },

  /**
   * Exposed for unit testing.
   * @private
   */
  _resetEventPlugins: function() {
    EventPluginOrder = null;
    for (var pluginName in namesToPlugins) {
      if (namesToPlugins.hasOwnProperty(pluginName)) {
        delete namesToPlugins[pluginName];
      }
    }
    EventPluginRegistry.plugins.length = 0;

    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
    for (var eventName in eventNameDispatchConfigs) {
      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
        delete eventNameDispatchConfigs[eventName];
      }
    }

    var registrationNameModules = EventPluginRegistry.registrationNameModules;
    for (var registrationName in registrationNameModules) {
      if (registrationNameModules.hasOwnProperty(registrationName)) {
        delete registrationNameModules[registrationName];
      }
    }
  }

};

module.exports = EventPluginRegistry;

}).call(this,require('_process'))
},{"./invariant":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/invariant.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/EventPluginUtils.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule EventPluginUtils
 */

"use strict";

var EventConstants = require("./EventConstants");

var invariant = require("./invariant");

/**
 * Injected dependencies:
 */

/**
 * - `Mount`: [required] Module that can convert between React dom IDs and
 *   actual node references.
 */
var injection = {
  Mount: null,
  injectMount: function(InjectedMount) {
    injection.Mount = InjectedMount;
    if ("production" !== process.env.NODE_ENV) {
      ("production" !== process.env.NODE_ENV ? invariant(
        InjectedMount && InjectedMount.getNode,
        'EventPluginUtils.injection.injectMount(...): Injected Mount module ' +
        'is missing getNode.'
      ) : invariant(InjectedMount && InjectedMount.getNode));
    }
  }
};

var topLevelTypes = EventConstants.topLevelTypes;

function isEndish(topLevelType) {
  return topLevelType === topLevelTypes.topMouseUp ||
         topLevelType === topLevelTypes.topTouchEnd ||
         topLevelType === topLevelTypes.topTouchCancel;
}

function isMoveish(topLevelType) {
  return topLevelType === topLevelTypes.topMouseMove ||
         topLevelType === topLevelTypes.topTouchMove;
}
function isStartish(topLevelType) {
  return topLevelType === topLevelTypes.topMouseDown ||
         topLevelType === topLevelTypes.topTouchStart;
}


var validateEventDispatches;
if ("production" !== process.env.NODE_ENV) {
  validateEventDispatches = function(event) {
    var dispatchListeners = event._dispatchListeners;
    var dispatchIDs = event._dispatchIDs;

    var listenersIsArr = Array.isArray(dispatchListeners);
    var idsIsArr = Array.isArray(dispatchIDs);
    var IDsLen = idsIsArr ? dispatchIDs.length : dispatchIDs ? 1 : 0;
    var listenersLen = listenersIsArr ?
      dispatchListeners.length :
      dispatchListeners ? 1 : 0;

    ("production" !== process.env.NODE_ENV ? invariant(
      idsIsArr === listenersIsArr && IDsLen === listenersLen,
      'EventPluginUtils: Invalid `event`.'
    ) : invariant(idsIsArr === listenersIsArr && IDsLen === listenersLen));
  };
}

/**
 * Invokes `cb(event, listener, id)`. Avoids using call if no scope is
 * provided. The `(listener,id)` pair effectively forms the "dispatch" but are
 * kept separate to conserve memory.
 */
function forEachEventDispatch(event, cb) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchIDs = event._dispatchIDs;
  if ("production" !== process.env.NODE_ENV) {
    validateEventDispatches(event);
  }
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i < dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and IDs are two parallel arrays that are always in sync.
      cb(event, dispatchListeners[i], dispatchIDs[i]);
    }
  } else if (dispatchListeners) {
    cb(event, dispatchListeners, dispatchIDs);
  }
}

/**
 * Default implementation of PluginModule.executeDispatch().
 * @param {SyntheticEvent} SyntheticEvent to handle
 * @param {function} Application-level callback
 * @param {string} domID DOM id to pass to the callback.
 */
function executeDispatch(event, listener, domID) {
  event.currentTarget = injection.Mount.getNode(domID);
  var returnValue = listener(event, domID);
  event.currentTarget = null;
  return returnValue;
}

/**
 * Standard/simple iteration through an event's collected dispatches.
 */
function executeDispatchesInOrder(event, executeDispatch) {
  forEachEventDispatch(event, executeDispatch);
  event._dispatchListeners = null;
  event._dispatchIDs = null;
}

/**
 * Standard/simple iteration through an event's collected dispatches, but stops
 * at the first dispatch execution returning true, and returns that id.
 *
 * @return id of the first dispatch execution who's listener returns true, or
 * null if no listener returned true.
 */
function executeDispatchesInOrderStopAtTrueImpl(event) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchIDs = event._dispatchIDs;
  if ("production" !== process.env.NODE_ENV) {
    validateEventDispatches(event);
  }
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i < dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and IDs are two parallel arrays that are always in sync.
      if (dispatchListeners[i](event, dispatchIDs[i])) {
        return dispatchIDs[i];
      }
    }
  } else if (dispatchListeners) {
    if (dispatchListeners(event, dispatchIDs)) {
      return dispatchIDs;
    }
  }
  return null;
}

/**
 * @see executeDispatchesInOrderStopAtTrueImpl
 */
function executeDispatchesInOrderStopAtTrue(event) {
  var ret = executeDispatchesInOrderStopAtTrueImpl(event);
  event._dispatchIDs = null;
  event._dispatchListeners = null;
  return ret;
}

/**
 * Execution of a "direct" dispatch - there must be at most one dispatch
 * accumulated on the event or it is considered an error. It doesn't really make
 * sense for an event with multiple dispatches (bubbled) to keep track of the
 * return values at each dispatch execution, but it does tend to make sense when
 * dealing with "direct" dispatches.
 *
 * @return The return value of executing the single dispatch.
 */
function executeDirectDispatch(event) {
  if ("production" !== process.env.NODE_ENV) {
    validateEventDispatches(event);
  }
  var dispatchListener = event._dispatchListeners;
  var dispatchID = event._dispatchIDs;
  ("production" !== process.env.NODE_ENV ? invariant(
    !Array.isArray(dispatchListener),
    'executeDirectDispatch(...): Invalid `event`.'
  ) : invariant(!Array.isArray(dispatchListener)));
  var res = dispatchListener ?
    dispatchListener(event, dispatchID) :
    null;
  event._dispatchListeners = null;
  event._dispatchIDs = null;
  return res;
}

/**
 * @param {SyntheticEvent} event
 * @return {bool} True iff number of dispatches accumulated is greater than 0.
 */
function hasDispatches(event) {
  return !!event._dispatchListeners;
}

/**
 * General utilities that are useful in creating custom Event Plugins.
 */
var EventPluginUtils = {
  isEndish: isEndish,
  isMoveish: isMoveish,
  isStartish: isStartish,

  executeDirectDispatch: executeDirectDispatch,
  executeDispatch: executeDispatch,
  executeDispatchesInOrder: executeDispatchesInOrder,
  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
  hasDispatches: hasDispatches,
  injection: injection,
  useTouchEvents: false
};

module.exports = EventPluginUtils;

}).call(this,require('_process'))
},{"./EventConstants":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/EventConstants.js","./invariant":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/invariant.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/EventPropagators.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule EventPropagators
 */

"use strict";

var EventConstants = require("./EventConstants");
var EventPluginHub = require("./EventPluginHub");

var accumulate = require("./accumulate");
var forEachAccumulated = require("./forEachAccumulated");

var PropagationPhases = EventConstants.PropagationPhases;
var getListener = EventPluginHub.getListener;

/**
 * Some event types have a notion of different registration names for different
 * "phases" of propagation. This finds listeners by a given phase.
 */
function listenerAtPhase(id, event, propagationPhase) {
  var registrationName =
    event.dispatchConfig.phasedRegistrationNames[propagationPhase];
  return getListener(id, registrationName);
}

/**
 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
 * here, allows us to not have to bind or create functions for each event.
 * Mutating the event's members allows us to not have to create a wrapping
 * "dispatch" object that pairs the event with the listener.
 */
function accumulateDirectionalDispatches(domID, upwards, event) {
  if ("production" !== process.env.NODE_ENV) {
    if (!domID) {
      throw new Error('Dispatching id must not be null');
    }
  }
  var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;
  var listener = listenerAtPhase(domID, event, phase);
  if (listener) {
    event._dispatchListeners = accumulate(event._dispatchListeners, listener);
    event._dispatchIDs = accumulate(event._dispatchIDs, domID);
  }
}

/**
 * Collect dispatches (must be entirely collected before dispatching - see unit
 * tests). Lazily allocate the array to conserve memory.  We must loop through
 * each event and perform the traversal for each one. We can not perform a
 * single traversal for the entire collection of events because each event may
 * have a different target.
 */
function accumulateTwoPhaseDispatchesSingle(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    EventPluginHub.injection.getInstanceHandle().traverseTwoPhase(
      event.dispatchMarker,
      accumulateDirectionalDispatches,
      event
    );
  }
}


/**
 * Accumulates without regard to direction, does not look for phased
 * registration names. Same as `accumulateDirectDispatchesSingle` but without
 * requiring that the `dispatchMarker` be the same as the dispatched ID.
 */
function accumulateDispatches(id, ignoredDirection, event) {
  if (event && event.dispatchConfig.registrationName) {
    var registrationName = event.dispatchConfig.registrationName;
    var listener = getListener(id, registrationName);
    if (listener) {
      event._dispatchListeners = accumulate(event._dispatchListeners, listener);
      event._dispatchIDs = accumulate(event._dispatchIDs, id);
    }
  }
}

/**
 * Accumulates dispatches on an `SyntheticEvent`, but only for the
 * `dispatchMarker`.
 * @param {SyntheticEvent} event
 */
function accumulateDirectDispatchesSingle(event) {
  if (event && event.dispatchConfig.registrationName) {
    accumulateDispatches(event.dispatchMarker, null, event);
  }
}

function accumulateTwoPhaseDispatches(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
}

function accumulateEnterLeaveDispatches(leave, enter, fromID, toID) {
  EventPluginHub.injection.getInstanceHandle().traverseEnterLeave(
    fromID,
    toID,
    accumulateDispatches,
    leave,
    enter
  );
}


function accumulateDirectDispatches(events) {
  forEachAccumulated(events, accumulateDirectDispatchesSingle);
}



/**
 * A small set of propagation patterns, each of which will accept a small amount
 * of information, and generate a set of "dispatch ready event objects" - which
 * are sets of events that have already been annotated with a set of dispatched
 * listener functions/ids. The API is designed this way to discourage these
 * propagation strategies from actually executing the dispatches, since we
 * always want to collect the entire set of dispatches before executing event a
 * single one.
 *
 * @constructor EventPropagators
 */
var EventPropagators = {
  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
  accumulateDirectDispatches: accumulateDirectDispatches,
  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
};

module.exports = EventPropagators;

}).call(this,require('_process'))
},{"./EventConstants":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/EventConstants.js","./EventPluginHub":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/EventPluginHub.js","./accumulate":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/accumulate.js","./forEachAccumulated":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/forEachAccumulated.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ExecutionEnvironment.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ExecutionEnvironment
 */

/*jslint evil: true */

"use strict";

var canUseDOM = !!(
  typeof window !== 'undefined' &&
  window.document &&
  window.document.createElement
);

/**
 * Simple, lightweight module assisting with the detection and context of
 * Worker. Helps avoid circular dependencies and allows code to reason about
 * whether or not they are in a Worker, even if they never include the main
 * `ReactWorker` dependency.
 */
var ExecutionEnvironment = {

  canUseDOM: canUseDOM,

  canUseWorkers: typeof Worker !== 'undefined',

  canUseEventListeners:
    canUseDOM && !!(window.addEventListener || window.attachEvent),

  canUseViewport: canUseDOM && !!window.screen,

  isInWorker: !canUseDOM // For now, this is true - might change in the future.

};

module.exports = ExecutionEnvironment;

},{}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/HTMLDOMPropertyConfig.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule HTMLDOMPropertyConfig
 */

/*jslint bitwise: true*/

"use strict";

var DOMProperty = require("./DOMProperty");
var ExecutionEnvironment = require("./ExecutionEnvironment");

var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;
var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
var HAS_SIDE_EFFECTS = DOMProperty.injection.HAS_SIDE_EFFECTS;
var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
var HAS_POSITIVE_NUMERIC_VALUE =
  DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
var HAS_OVERLOADED_BOOLEAN_VALUE =
  DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;

var hasSVG;
if (ExecutionEnvironment.canUseDOM) {
  var implementation = document.implementation;
  hasSVG = (
    implementation &&
    implementation.hasFeature &&
    implementation.hasFeature(
      'http://www.w3.org/TR/SVG11/feature#BasicStructure',
      '1.1'
    )
  );
}


var HTMLDOMPropertyConfig = {
  isCustomAttribute: RegExp.prototype.test.bind(
    /^(data|aria)-[a-z_][a-z\d_.\-]*$/
  ),
  Properties: {
    /**
     * Standard Properties
     */
    accept: null,
    accessKey: null,
    action: null,
    allowFullScreen: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
    allowTransparency: MUST_USE_ATTRIBUTE,
    alt: null,
    async: HAS_BOOLEAN_VALUE,
    autoComplete: null,
    // autoFocus is polyfilled/normalized by AutoFocusMixin
    // autoFocus: HAS_BOOLEAN_VALUE,
    autoPlay: HAS_BOOLEAN_VALUE,
    cellPadding: null,
    cellSpacing: null,
    charSet: MUST_USE_ATTRIBUTE,
    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    // To set className on SVG elements, it's necessary to use .setAttribute;
    // this works on HTML elements too in all browsers except IE8. Conveniently,
    // IE8 doesn't support SVG and so we can simply use the attribute in
    // browsers that support SVG and the property in browsers that don't,
    // regardless of whether the element is HTML or SVG.
    className: hasSVG ? MUST_USE_ATTRIBUTE : MUST_USE_PROPERTY,
    cols: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
    colSpan: null,
    content: null,
    contentEditable: null,
    contextMenu: MUST_USE_ATTRIBUTE,
    controls: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    coords: null,
    crossOrigin: null,
    data: null, // For `<object />` acts as `src`.
    dateTime: MUST_USE_ATTRIBUTE,
    defer: HAS_BOOLEAN_VALUE,
    dir: null,
    disabled: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
    download: HAS_OVERLOADED_BOOLEAN_VALUE,
    draggable: null,
    encType: null,
    form: MUST_USE_ATTRIBUTE,
    formNoValidate: HAS_BOOLEAN_VALUE,
    frameBorder: MUST_USE_ATTRIBUTE,
    height: MUST_USE_ATTRIBUTE,
    hidden: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
    href: null,
    hrefLang: null,
    htmlFor: null,
    httpEquiv: null,
    icon: null,
    id: MUST_USE_PROPERTY,
    label: null,
    lang: null,
    list: null,
    loop: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    max: null,
    maxLength: MUST_USE_ATTRIBUTE,
    mediaGroup: null,
    method: null,
    min: null,
    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    name: null,
    noValidate: HAS_BOOLEAN_VALUE,
    pattern: null,
    placeholder: null,
    poster: null,
    preload: null,
    radioGroup: null,
    readOnly: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    rel: null,
    required: HAS_BOOLEAN_VALUE,
    role: MUST_USE_ATTRIBUTE,
    rows: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
    rowSpan: null,
    sandbox: null,
    scope: null,
    scrollLeft: MUST_USE_PROPERTY,
    scrolling: null,
    scrollTop: MUST_USE_PROPERTY,
    seamless: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    shape: null,
    size: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
    span: HAS_POSITIVE_NUMERIC_VALUE,
    spellCheck: null,
    src: null,
    srcDoc: MUST_USE_PROPERTY,
    srcSet: null,
    start: HAS_NUMERIC_VALUE,
    step: null,
    style: null,
    tabIndex: null,
    target: null,
    title: null,
    type: null,
    useMap: null,
    value: MUST_USE_PROPERTY | HAS_SIDE_EFFECTS,
    width: MUST_USE_ATTRIBUTE,
    wmode: MUST_USE_ATTRIBUTE,

    /**
     * Non-standard Properties
     */
    autoCapitalize: null, // Supported in Mobile Safari for keyboard hints
    autoCorrect: null, // Supported in Mobile Safari for keyboard hints
    itemProp: MUST_USE_ATTRIBUTE, // Microdata: http://schema.org/docs/gs.html
    itemScope: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE, // Microdata: http://schema.org/docs/gs.html
    itemType: MUST_USE_ATTRIBUTE, // Microdata: http://schema.org/docs/gs.html
    property: null // Supports OG in meta tags
  },
  DOMAttributeNames: {
    className: 'class',
    htmlFor: 'for',
    httpEquiv: 'http-equiv'
  },
  DOMPropertyNames: {
    autoCapitalize: 'autocapitalize',
    autoComplete: 'autocomplete',
    autoCorrect: 'autocorrect',
    autoFocus: 'autofocus',
    autoPlay: 'autoplay',
    encType: 'enctype',
    hrefLang: 'hreflang',
    radioGroup: 'radiogroup',
    spellCheck: 'spellcheck',
    srcDoc: 'srcdoc',
    srcSet: 'srcset'
  }
};

module.exports = HTMLDOMPropertyConfig;

},{"./DOMProperty":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/DOMProperty.js","./ExecutionEnvironment":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ExecutionEnvironment.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/LinkedStateMixin.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule LinkedStateMixin
 * @typechecks static-only
 */

"use strict";

var ReactLink = require("./ReactLink");
var ReactStateSetters = require("./ReactStateSetters");

/**
 * A simple mixin around ReactLink.forState().
 */
var LinkedStateMixin = {
  /**
   * Create a ReactLink that's linked to part of this component's state. The
   * ReactLink will have the current value of this.state[key] and will call
   * setState() when a change is requested.
   *
   * @param {string} key state key to update. Note: you may want to use keyOf()
   * if you're using Google Closure Compiler advanced mode.
   * @return {ReactLink} ReactLink instance linking to the state.
   */
  linkState: function(key) {
    return new ReactLink(
      this.state[key],
      ReactStateSetters.createStateKeySetter(this, key)
    );
  }
};

module.exports = LinkedStateMixin;

},{"./ReactLink":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactLink.js","./ReactStateSetters":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactStateSetters.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/LinkedValueUtils.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule LinkedValueUtils
 * @typechecks static-only
 */

"use strict";

var ReactPropTypes = require("./ReactPropTypes");

var invariant = require("./invariant");

var hasReadOnlyValue = {
  'button': true,
  'checkbox': true,
  'image': true,
  'hidden': true,
  'radio': true,
  'reset': true,
  'submit': true
};

function _assertSingleLink(input) {
  ("production" !== process.env.NODE_ENV ? invariant(
    input.props.checkedLink == null || input.props.valueLink == null,
    'Cannot provide a checkedLink and a valueLink. If you want to use ' +
    'checkedLink, you probably don\'t want to use valueLink and vice versa.'
  ) : invariant(input.props.checkedLink == null || input.props.valueLink == null));
}
function _assertValueLink(input) {
  _assertSingleLink(input);
  ("production" !== process.env.NODE_ENV ? invariant(
    input.props.value == null && input.props.onChange == null,
    'Cannot provide a valueLink and a value or onChange event. If you want ' +
    'to use value or onChange, you probably don\'t want to use valueLink.'
  ) : invariant(input.props.value == null && input.props.onChange == null));
}

function _assertCheckedLink(input) {
  _assertSingleLink(input);
  ("production" !== process.env.NODE_ENV ? invariant(
    input.props.checked == null && input.props.onChange == null,
    'Cannot provide a checkedLink and a checked property or onChange event. ' +
    'If you want to use checked or onChange, you probably don\'t want to ' +
    'use checkedLink'
  ) : invariant(input.props.checked == null && input.props.onChange == null));
}

/**
 * @param {SyntheticEvent} e change event to handle
 */
function _handleLinkedValueChange(e) {
  /*jshint validthis:true */
  this.props.valueLink.requestChange(e.target.value);
}

/**
  * @param {SyntheticEvent} e change event to handle
  */
function _handleLinkedCheckChange(e) {
  /*jshint validthis:true */
  this.props.checkedLink.requestChange(e.target.checked);
}

/**
 * Provide a linked `value` attribute for controlled forms. You should not use
 * this outside of the ReactDOM controlled form components.
 */
var LinkedValueUtils = {
  Mixin: {
    propTypes: {
      value: function(props, propName, componentName) {
        if (!props[propName] ||
            hasReadOnlyValue[props.type] ||
            props.onChange ||
            props.readOnly ||
            props.disabled) {
          return;
        }
        return new Error(
          'You provided a `value` prop to a form field without an ' +
          '`onChange` handler. This will render a read-only field. If ' +
          'the field should be mutable use `defaultValue`. Otherwise, ' +
          'set either `onChange` or `readOnly`.'
        );
      },
      checked: function(props, propName, componentName) {
        if (!props[propName] ||
            props.onChange ||
            props.readOnly ||
            props.disabled) {
          return;
        }
        return new Error(
          'You provided a `checked` prop to a form field without an ' +
          '`onChange` handler. This will render a read-only field. If ' +
          'the field should be mutable use `defaultChecked`. Otherwise, ' +
          'set either `onChange` or `readOnly`.'
        );
      },
      onChange: ReactPropTypes.func
    }
  },

  /**
   * @param {ReactComponent} input Form component
   * @return {*} current value of the input either from value prop or link.
   */
  getValue: function(input) {
    if (input.props.valueLink) {
      _assertValueLink(input);
      return input.props.valueLink.value;
    }
    return input.props.value;
  },

  /**
   * @param {ReactComponent} input Form component
   * @return {*} current checked status of the input either from checked prop
   *             or link.
   */
  getChecked: function(input) {
    if (input.props.checkedLink) {
      _assertCheckedLink(input);
      return input.props.checkedLink.value;
    }
    return input.props.checked;
  },

  /**
   * @param {ReactComponent} input Form component
   * @return {function} change callback either from onChange prop or link.
   */
  getOnChange: function(input) {
    if (input.props.valueLink) {
      _assertValueLink(input);
      return _handleLinkedValueChange;
    } else if (input.props.checkedLink) {
      _assertCheckedLink(input);
      return _handleLinkedCheckChange;
    }
    return input.props.onChange;
  }
};

module.exports = LinkedValueUtils;

}).call(this,require('_process'))
},{"./ReactPropTypes":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactPropTypes.js","./invariant":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/invariant.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/LocalEventTrapMixin.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule LocalEventTrapMixin
 */

"use strict";

var ReactBrowserEventEmitter = require("./ReactBrowserEventEmitter");

var accumulate = require("./accumulate");
var forEachAccumulated = require("./forEachAccumulated");
var invariant = require("./invariant");

function remove(event) {
  event.remove();
}

var LocalEventTrapMixin = {
  trapBubbledEvent:function(topLevelType, handlerBaseName) {
    ("production" !== process.env.NODE_ENV ? invariant(this.isMounted(), 'Must be mounted to trap events') : invariant(this.isMounted()));
    var listener = ReactBrowserEventEmitter.trapBubbledEvent(
      topLevelType,
      handlerBaseName,
      this.getDOMNode()
    );
    this._localEventListeners = accumulate(this._localEventListeners, listener);
  },

  // trapCapturedEvent would look nearly identical. We don't implement that
  // method because it isn't currently needed.

  componentWillUnmount:function() {
    if (this._localEventListeners) {
      forEachAccumulated(this._localEventListeners, remove);
    }
  }
};

module.exports = LocalEventTrapMixin;

}).call(this,require('_process'))
},{"./ReactBrowserEventEmitter":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactBrowserEventEmitter.js","./accumulate":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/accumulate.js","./forEachAccumulated":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/forEachAccumulated.js","./invariant":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/invariant.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/MobileSafariClickEventPlugin.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule MobileSafariClickEventPlugin
 * @typechecks static-only
 */

"use strict";

var EventConstants = require("./EventConstants");

var emptyFunction = require("./emptyFunction");

var topLevelTypes = EventConstants.topLevelTypes;

/**
 * Mobile Safari does not fire properly bubble click events on non-interactive
 * elements, which means delegated click listeners do not fire. The workaround
 * for this bug involves attaching an empty click listener on the target node.
 *
 * This particular plugin works around the bug by attaching an empty click
 * listener on `touchstart` (which does fire on every element).
 */
var MobileSafariClickEventPlugin = {

  eventTypes: null,

  /**
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function(
      topLevelType,
      topLevelTarget,
      topLevelTargetID,
      nativeEvent) {
    if (topLevelType === topLevelTypes.topTouchStart) {
      var target = nativeEvent.target;
      if (target && !target.onclick) {
        target.onclick = emptyFunction;
      }
    }
  }

};

module.exports = MobileSafariClickEventPlugin;

},{"./EventConstants":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/EventConstants.js","./emptyFunction":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/emptyFunction.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/PooledClass.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule PooledClass
 */

"use strict";

var invariant = require("./invariant");

/**
 * Static poolers. Several custom versions for each potential number of
 * arguments. A completely generic pooler is easy to implement, but would
 * require accessing the `arguments` object. In each of these, `this` refers to
 * the Class itself, not an instance. If any others are needed, simply add them
 * here, or in their own files.
 */
var oneArgumentPooler = function(copyFieldsFrom) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, copyFieldsFrom);
    return instance;
  } else {
    return new Klass(copyFieldsFrom);
  }
};

var twoArgumentPooler = function(a1, a2) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2);
    return instance;
  } else {
    return new Klass(a1, a2);
  }
};

var threeArgumentPooler = function(a1, a2, a3) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3);
    return instance;
  } else {
    return new Klass(a1, a2, a3);
  }
};

var fiveArgumentPooler = function(a1, a2, a3, a4, a5) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4, a5);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4, a5);
  }
};

var standardReleaser = function(instance) {
  var Klass = this;
  ("production" !== process.env.NODE_ENV ? invariant(
    instance instanceof Klass,
    'Trying to release an instance into a pool of a different type.'
  ) : invariant(instance instanceof Klass));
  if (instance.destructor) {
    instance.destructor();
  }
  if (Klass.instancePool.length < Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
};

var DEFAULT_POOL_SIZE = 10;
var DEFAULT_POOLER = oneArgumentPooler;

/**
 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
 * itself (statically) not adding any prototypical fields. Any CopyConstructor
 * you give this may have a `poolSize` property, and will look for a
 * prototypical `destructor` on instances (optional).
 *
 * @param {Function} CopyConstructor Constructor that can be used to reset.
 * @param {Function} pooler Customizable pooler.
 */
var addPoolingTo = function(CopyConstructor, pooler) {
  var NewKlass = CopyConstructor;
  NewKlass.instancePool = [];
  NewKlass.getPooled = pooler || DEFAULT_POOLER;
  if (!NewKlass.poolSize) {
    NewKlass.poolSize = DEFAULT_POOL_SIZE;
  }
  NewKlass.release = standardReleaser;
  return NewKlass;
};

var PooledClass = {
  addPoolingTo: addPoolingTo,
  oneArgumentPooler: oneArgumentPooler,
  twoArgumentPooler: twoArgumentPooler,
  threeArgumentPooler: threeArgumentPooler,
  fiveArgumentPooler: fiveArgumentPooler
};

module.exports = PooledClass;

}).call(this,require('_process'))
},{"./invariant":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/invariant.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/React.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule React
 */

"use strict";

var DOMPropertyOperations = require("./DOMPropertyOperations");
var EventPluginUtils = require("./EventPluginUtils");
var ReactChildren = require("./ReactChildren");
var ReactComponent = require("./ReactComponent");
var ReactCompositeComponent = require("./ReactCompositeComponent");
var ReactContext = require("./ReactContext");
var ReactCurrentOwner = require("./ReactCurrentOwner");
var ReactDescriptor = require("./ReactDescriptor");
var ReactDOM = require("./ReactDOM");
var ReactDOMComponent = require("./ReactDOMComponent");
var ReactDefaultInjection = require("./ReactDefaultInjection");
var ReactInstanceHandles = require("./ReactInstanceHandles");
var ReactMount = require("./ReactMount");
var ReactMultiChild = require("./ReactMultiChild");
var ReactPerf = require("./ReactPerf");
var ReactPropTypes = require("./ReactPropTypes");
var ReactServerRendering = require("./ReactServerRendering");
var ReactTextComponent = require("./ReactTextComponent");

var onlyChild = require("./onlyChild");

ReactDefaultInjection.inject();

var React = {
  Children: {
    map: ReactChildren.map,
    forEach: ReactChildren.forEach,
    count: ReactChildren.count,
    only: onlyChild
  },
  DOM: ReactDOM,
  PropTypes: ReactPropTypes,
  initializeTouchEvents: function(shouldUseTouch) {
    EventPluginUtils.useTouchEvents = shouldUseTouch;
  },
  createClass: ReactCompositeComponent.createClass,
  createDescriptor: function(type, props, children) {
    var args = Array.prototype.slice.call(arguments, 1);
    return type.apply(null, args);
  },
  constructAndRenderComponent: ReactMount.constructAndRenderComponent,
  constructAndRenderComponentByID: ReactMount.constructAndRenderComponentByID,
  renderComponent: ReactPerf.measure(
    'React',
    'renderComponent',
    ReactMount.renderComponent
  ),
  renderComponentToString: ReactServerRendering.renderComponentToString,
  renderComponentToStaticMarkup:
    ReactServerRendering.renderComponentToStaticMarkup,
  unmountComponentAtNode: ReactMount.unmountComponentAtNode,
  isValidClass: ReactDescriptor.isValidFactory,
  isValidComponent: ReactDescriptor.isValidDescriptor,
  withContext: ReactContext.withContext,
  __internals: {
    Component: ReactComponent,
    CurrentOwner: ReactCurrentOwner,
    DOMComponent: ReactDOMComponent,
    DOMPropertyOperations: DOMPropertyOperations,
    InstanceHandles: ReactInstanceHandles,
    Mount: ReactMount,
    MultiChild: ReactMultiChild,
    TextComponent: ReactTextComponent
  }
};

if ("production" !== process.env.NODE_ENV) {
  var ExecutionEnvironment = require("./ExecutionEnvironment");
  if (ExecutionEnvironment.canUseDOM &&
      window.top === window.self &&
      navigator.userAgent.indexOf('Chrome') > -1) {
    console.debug(
      'Download the React DevTools for a better development experience: ' +
      'http://fb.me/react-devtools'
    );

    var expectedFeatures = [
      // shims
      Array.isArray,
      Array.prototype.every,
      Array.prototype.forEach,
      Array.prototype.indexOf,
      Array.prototype.map,
      Date.now,
      Function.prototype.bind,
      Object.keys,
      String.prototype.split,
      String.prototype.trim,

      // shams
      Object.create,
      Object.freeze
    ];

    for (var i in expectedFeatures) {
      if (!expectedFeatures[i]) {
        console.error(
          'One or more ES5 shim/shams expected by React are not available: ' +
          'http://fb.me/react-warning-polyfills'
        );
        break;
      }
    }
  }
}

// Version exists only in the open-source version of React, not in Facebook's
// internal version.
React.version = '0.11.1';

module.exports = React;

}).call(this,require('_process'))
},{"./DOMPropertyOperations":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/DOMPropertyOperations.js","./EventPluginUtils":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/EventPluginUtils.js","./ExecutionEnvironment":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ExecutionEnvironment.js","./ReactChildren":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactChildren.js","./ReactComponent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactComponent.js","./ReactCompositeComponent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactCompositeComponent.js","./ReactContext":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactContext.js","./ReactCurrentOwner":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactCurrentOwner.js","./ReactDOM":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDOM.js","./ReactDOMComponent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDOMComponent.js","./ReactDefaultInjection":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDefaultInjection.js","./ReactDescriptor":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDescriptor.js","./ReactInstanceHandles":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactInstanceHandles.js","./ReactMount":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactMount.js","./ReactMultiChild":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactMultiChild.js","./ReactPerf":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactPerf.js","./ReactPropTypes":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactPropTypes.js","./ReactServerRendering":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactServerRendering.js","./ReactTextComponent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactTextComponent.js","./onlyChild":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/onlyChild.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactBrowserComponentMixin.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactBrowserComponentMixin
 */

"use strict";

var ReactEmptyComponent = require("./ReactEmptyComponent");
var ReactMount = require("./ReactMount");

var invariant = require("./invariant");

var ReactBrowserComponentMixin = {
  /**
   * Returns the DOM node rendered by this component.
   *
   * @return {DOMElement} The root node of this component.
   * @final
   * @protected
   */
  getDOMNode: function() {
    ("production" !== process.env.NODE_ENV ? invariant(
      this.isMounted(),
      'getDOMNode(): A component must be mounted to have a DOM node.'
    ) : invariant(this.isMounted()));
    if (ReactEmptyComponent.isNullComponentID(this._rootNodeID)) {
      return null;
    }
    return ReactMount.getNode(this._rootNodeID);
  }
};

module.exports = ReactBrowserComponentMixin;

}).call(this,require('_process'))
},{"./ReactEmptyComponent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactEmptyComponent.js","./ReactMount":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactMount.js","./invariant":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/invariant.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactBrowserEventEmitter.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactBrowserEventEmitter
 * @typechecks static-only
 */

"use strict";

var EventConstants = require("./EventConstants");
var EventPluginHub = require("./EventPluginHub");
var EventPluginRegistry = require("./EventPluginRegistry");
var ReactEventEmitterMixin = require("./ReactEventEmitterMixin");
var ViewportMetrics = require("./ViewportMetrics");

var isEventSupported = require("./isEventSupported");
var merge = require("./merge");

/**
 * Summary of `ReactBrowserEventEmitter` event handling:
 *
 *  - Top-level delegation is used to trap most native browser events. This
 *    may only occur in the main thread and is the responsibility of
 *    ReactEventListener, which is injected and can therefore support pluggable
 *    event sources. This is the only work that occurs in the main thread.
 *
 *  - We normalize and de-duplicate events to account for browser quirks. This
 *    may be done in the worker thread.
 *
 *  - Forward these native events (with the associated top-level type used to
 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
 *    to extract any synthetic events.
 *
 *  - The `EventPluginHub` will then process each event by annotating them with
 *    "dispatches", a sequence of listeners and IDs that care about that event.
 *
 *  - The `EventPluginHub` then dispatches the events.
 *
 * Overview of React and the event system:
 *
 * +------------+    .
 * |    DOM     |    .
 * +------------+    .
 *       |           .
 *       v           .
 * +------------+    .
 * | ReactEvent |    .
 * |  Listener  |    .
 * +------------+    .                         +-----------+
 *       |           .               +--------+|SimpleEvent|
 *       |           .               |         |Plugin     |
 * +-----|------+    .               v         +-----------+
 * |     |      |    .    +--------------+                    +------------+
 * |     +-----------.--->|EventPluginHub|                    |    Event   |
 * |            |    .    |              |     +-----------+  | Propagators|
 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
 * |            |    .    |              |     +-----------+  |  utilities |
 * |     +-----------.--->|              |                    +------------+
 * |     |      |    .    +--------------+
 * +-----|------+    .                ^        +-----------+
 *       |           .                |        |Enter/Leave|
 *       +           .                +-------+|Plugin     |
 * +-------------+   .                         +-----------+
 * | application |   .
 * |-------------|   .
 * |             |   .
 * |             |   .
 * +-------------+   .
 *                   .
 *    React Core     .  General Purpose Event Plugin System
 */

var alreadyListeningTo = {};
var isMonitoringScrollValue = false;
var reactTopListenersCounter = 0;

// For events like 'submit' which don't consistently bubble (which we trap at a
// lower node than `document`), binding at `document` would cause duplicate
// events so we don't include them here
var topEventMapping = {
  topBlur: 'blur',
  topChange: 'change',
  topClick: 'click',
  topCompositionEnd: 'compositionend',
  topCompositionStart: 'compositionstart',
  topCompositionUpdate: 'compositionupdate',
  topContextMenu: 'contextmenu',
  topCopy: 'copy',
  topCut: 'cut',
  topDoubleClick: 'dblclick',
  topDrag: 'drag',
  topDragEnd: 'dragend',
  topDragEnter: 'dragenter',
  topDragExit: 'dragexit',
  topDragLeave: 'dragleave',
  topDragOver: 'dragover',
  topDragStart: 'dragstart',
  topDrop: 'drop',
  topFocus: 'focus',
  topInput: 'input',
  topKeyDown: 'keydown',
  topKeyPress: 'keypress',
  topKeyUp: 'keyup',
  topMouseDown: 'mousedown',
  topMouseMove: 'mousemove',
  topMouseOut: 'mouseout',
  topMouseOver: 'mouseover',
  topMouseUp: 'mouseup',
  topPaste: 'paste',
  topScroll: 'scroll',
  topSelectionChange: 'selectionchange',
  topTextInput: 'textInput',
  topTouchCancel: 'touchcancel',
  topTouchEnd: 'touchend',
  topTouchMove: 'touchmove',
  topTouchStart: 'touchstart',
  topWheel: 'wheel'
};

/**
 * To ensure no conflicts with other potential React instances on the page
 */
var topListenersIDKey = "_reactListenersID" + String(Math.random()).slice(2);

function getListeningForDocument(mountAt) {
  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
  // directly.
  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
    mountAt[topListenersIDKey] = reactTopListenersCounter++;
    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
  }
  return alreadyListeningTo[mountAt[topListenersIDKey]];
}

/**
 * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For
 * example:
 *
 *   ReactBrowserEventEmitter.putListener('myID', 'onClick', myFunction);
 *
 * This would allocate a "registration" of `('onClick', myFunction)` on 'myID'.
 *
 * @internal
 */
var ReactBrowserEventEmitter = merge(ReactEventEmitterMixin, {

  /**
   * Injectable event backend
   */
  ReactEventListener: null,

  injection: {
    /**
     * @param {object} ReactEventListener
     */
    injectReactEventListener: function(ReactEventListener) {
      ReactEventListener.setHandleTopLevel(
        ReactBrowserEventEmitter.handleTopLevel
      );
      ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
    }
  },

  /**
   * Sets whether or not any created callbacks should be enabled.
   *
   * @param {boolean} enabled True if callbacks should be enabled.
   */
  setEnabled: function(enabled) {
    if (ReactBrowserEventEmitter.ReactEventListener) {
      ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
    }
  },

  /**
   * @return {boolean} True if callbacks are enabled.
   */
  isEnabled: function() {
    return !!(
      ReactBrowserEventEmitter.ReactEventListener &&
      ReactBrowserEventEmitter.ReactEventListener.isEnabled()
    );
  },

  /**
   * We listen for bubbled touch events on the document object.
   *
   * Firefox v8.01 (and possibly others) exhibited strange behavior when
   * mounting `onmousemove` events at some node that was not the document
   * element. The symptoms were that if your mouse is not moving over something
   * contained within that mount point (for example on the background) the
   * top-level listeners for `onmousemove` won't be called. However, if you
   * register the `mousemove` on the document object, then it will of course
   * catch all `mousemove`s. This along with iOS quirks, justifies restricting
   * top-level listeners to the document object only, at least for these
   * movement types of events and possibly all events.
   *
   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
   *
   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
   * they bubble to document.
   *
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @param {object} contentDocumentHandle Document which owns the container
   */
  listenTo: function(registrationName, contentDocumentHandle) {
    var mountAt = contentDocumentHandle;
    var isListening = getListeningForDocument(mountAt);
    var dependencies = EventPluginRegistry.
      registrationNameDependencies[registrationName];

    var topLevelTypes = EventConstants.topLevelTypes;
    for (var i = 0, l = dependencies.length; i < l; i++) {
      var dependency = dependencies[i];
      if (!(
            isListening.hasOwnProperty(dependency) &&
            isListening[dependency]
          )) {
        if (dependency === topLevelTypes.topWheel) {
          if (isEventSupported('wheel')) {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(
              topLevelTypes.topWheel,
              'wheel',
              mountAt
            );
          } else if (isEventSupported('mousewheel')) {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(
              topLevelTypes.topWheel,
              'mousewheel',
              mountAt
            );
          } else {
            // Firefox needs to capture a different mouse scroll event.
            // @see http://www.quirksmode.org/dom/events/tests/scroll.html
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(
              topLevelTypes.topWheel,
              'DOMMouseScroll',
              mountAt
            );
          }
        } else if (dependency === topLevelTypes.topScroll) {

          if (isEventSupported('scroll', true)) {
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(
              topLevelTypes.topScroll,
              'scroll',
              mountAt
            );
          } else {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(
              topLevelTypes.topScroll,
              'scroll',
              ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE
            );
          }
        } else if (dependency === topLevelTypes.topFocus ||
            dependency === topLevelTypes.topBlur) {

          if (isEventSupported('focus', true)) {
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(
              topLevelTypes.topFocus,
              'focus',
              mountAt
            );
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(
              topLevelTypes.topBlur,
              'blur',
              mountAt
            );
          } else if (isEventSupported('focusin')) {
            // IE has `focusin` and `focusout` events which bubble.
            // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(
              topLevelTypes.topFocus,
              'focusin',
              mountAt
            );
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(
              topLevelTypes.topBlur,
              'focusout',
              mountAt
            );
          }

          // to make sure blur and focus event listeners are only attached once
          isListening[topLevelTypes.topBlur] = true;
          isListening[topLevelTypes.topFocus] = true;
        } else if (topEventMapping.hasOwnProperty(dependency)) {
          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(
            dependency,
            topEventMapping[dependency],
            mountAt
          );
        }

        isListening[dependency] = true;
      }
    }
  },

  trapBubbledEvent: function(topLevelType, handlerBaseName, handle) {
    return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(
      topLevelType,
      handlerBaseName,
      handle
    );
  },

  trapCapturedEvent: function(topLevelType, handlerBaseName, handle) {
    return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(
      topLevelType,
      handlerBaseName,
      handle
    );
  },

  /**
   * Listens to window scroll and resize events. We cache scroll values so that
   * application code can access them without triggering reflows.
   *
   * NOTE: Scroll events do not bubble.
   *
   * @see http://www.quirksmode.org/dom/events/scroll.html
   */
  ensureScrollValueMonitoring: function(){
    if (!isMonitoringScrollValue) {
      var refresh = ViewportMetrics.refreshScrollValues;
      ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
      isMonitoringScrollValue = true;
    }
  },

  eventNameDispatchConfigs: EventPluginHub.eventNameDispatchConfigs,

  registrationNameModules: EventPluginHub.registrationNameModules,

  putListener: EventPluginHub.putListener,

  getListener: EventPluginHub.getListener,

  deleteListener: EventPluginHub.deleteListener,

  deleteAllListeners: EventPluginHub.deleteAllListeners

});

module.exports = ReactBrowserEventEmitter;

},{"./EventConstants":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/EventConstants.js","./EventPluginHub":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/EventPluginHub.js","./EventPluginRegistry":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/EventPluginRegistry.js","./ReactEventEmitterMixin":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactEventEmitterMixin.js","./ViewportMetrics":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ViewportMetrics.js","./isEventSupported":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/isEventSupported.js","./merge":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/merge.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactCSSTransitionGroup.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @typechecks
 * @providesModule ReactCSSTransitionGroup
 */

"use strict";

var React = require("./React");

var ReactTransitionGroup = require("./ReactTransitionGroup");
var ReactCSSTransitionGroupChild = require("./ReactCSSTransitionGroupChild");

var ReactCSSTransitionGroup = React.createClass({
  displayName: 'ReactCSSTransitionGroup',

  propTypes: {
    transitionName: React.PropTypes.string.isRequired,
    transitionEnter: React.PropTypes.bool,
    transitionLeave: React.PropTypes.bool
  },

  getDefaultProps: function() {
    return {
      transitionEnter: true,
      transitionLeave: true
    };
  },

  _wrapChild: function(child) {
    // We need to provide this childFactory so that
    // ReactCSSTransitionGroupChild can receive updates to name, enter, and
    // leave while it is leaving.
    return ReactCSSTransitionGroupChild(
      {
        name: this.props.transitionName,
        enter: this.props.transitionEnter,
        leave: this.props.transitionLeave
      },
      child
    );
  },

  render: function() {
    return this.transferPropsTo(
      ReactTransitionGroup(
        {childFactory: this._wrapChild},
        this.props.children
      )
    );
  }
});

module.exports = ReactCSSTransitionGroup;

},{"./React":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/React.js","./ReactCSSTransitionGroupChild":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactCSSTransitionGroupChild.js","./ReactTransitionGroup":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactTransitionGroup.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactCSSTransitionGroupChild.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @typechecks
 * @providesModule ReactCSSTransitionGroupChild
 */

"use strict";

var React = require("./React");

var CSSCore = require("./CSSCore");
var ReactTransitionEvents = require("./ReactTransitionEvents");

var onlyChild = require("./onlyChild");

// We don't remove the element from the DOM until we receive an animationend or
// transitionend event. If the user screws up and forgets to add an animation
// their node will be stuck in the DOM forever, so we detect if an animation
// does not start and if it doesn't, we just call the end listener immediately.
var TICK = 17;
var NO_EVENT_TIMEOUT = 5000;

var noEventListener = null;


if ("production" !== process.env.NODE_ENV) {
  noEventListener = function() {
    console.warn(
      'transition(): tried to perform an animation without ' +
      'an animationend or transitionend event after timeout (' +
      NO_EVENT_TIMEOUT + 'ms). You should either disable this ' +
      'transition in JS or add a CSS animation/transition.'
    );
  };
}

var ReactCSSTransitionGroupChild = React.createClass({
  displayName: 'ReactCSSTransitionGroupChild',

  transition: function(animationType, finishCallback) {
    var node = this.getDOMNode();
    var className = this.props.name + '-' + animationType;
    var activeClassName = className + '-active';
    var noEventTimeout = null;

    var endListener = function() {
      if ("production" !== process.env.NODE_ENV) {
        clearTimeout(noEventTimeout);
      }

      CSSCore.removeClass(node, className);
      CSSCore.removeClass(node, activeClassName);

      ReactTransitionEvents.removeEndEventListener(node, endListener);

      // Usually this optional callback is used for informing an owner of
      // a leave animation and telling it to remove the child.
      finishCallback && finishCallback();
    };

    ReactTransitionEvents.addEndEventListener(node, endListener);

    CSSCore.addClass(node, className);

    // Need to do this to actually trigger a transition.
    this.queueClass(activeClassName);

    if ("production" !== process.env.NODE_ENV) {
      noEventTimeout = setTimeout(noEventListener, NO_EVENT_TIMEOUT);
    }
  },

  queueClass: function(className) {
    this.classNameQueue.push(className);

    if (!this.timeout) {
      this.timeout = setTimeout(this.flushClassNameQueue, TICK);
    }
  },

  flushClassNameQueue: function() {
    if (this.isMounted()) {
      this.classNameQueue.forEach(
        CSSCore.addClass.bind(CSSCore, this.getDOMNode())
      );
    }
    this.classNameQueue.length = 0;
    this.timeout = null;
  },

  componentWillMount: function() {
    this.classNameQueue = [];
  },

  componentWillUnmount: function() {
    if (this.timeout) {
      clearTimeout(this.timeout);
    }
  },

  componentWillEnter: function(done) {
    if (this.props.enter) {
      this.transition('enter', done);
    } else {
      done();
    }
  },

  componentWillLeave: function(done) {
    if (this.props.leave) {
      this.transition('leave', done);
    } else {
      done();
    }
  },

  render: function() {
    return onlyChild(this.props.children);
  }
});

module.exports = ReactCSSTransitionGroupChild;

}).call(this,require('_process'))
},{"./CSSCore":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/CSSCore.js","./React":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/React.js","./ReactTransitionEvents":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactTransitionEvents.js","./onlyChild":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/onlyChild.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactChildren.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactChildren
 */

"use strict";

var PooledClass = require("./PooledClass");

var traverseAllChildren = require("./traverseAllChildren");
var warning = require("./warning");

var twoArgumentPooler = PooledClass.twoArgumentPooler;
var threeArgumentPooler = PooledClass.threeArgumentPooler;

/**
 * PooledClass representing the bookkeeping associated with performing a child
 * traversal. Allows avoiding binding callbacks.
 *
 * @constructor ForEachBookKeeping
 * @param {!function} forEachFunction Function to perform traversal with.
 * @param {?*} forEachContext Context to perform context with.
 */
function ForEachBookKeeping(forEachFunction, forEachContext) {
  this.forEachFunction = forEachFunction;
  this.forEachContext = forEachContext;
}
PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);

function forEachSingleChild(traverseContext, child, name, i) {
  var forEachBookKeeping = traverseContext;
  forEachBookKeeping.forEachFunction.call(
    forEachBookKeeping.forEachContext, child, i);
}

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc.
 * @param {*} forEachContext Context for forEachContext.
 */
function forEachChildren(children, forEachFunc, forEachContext) {
  if (children == null) {
    return children;
  }

  var traverseContext =
    ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
  traverseAllChildren(children, forEachSingleChild, traverseContext);
  ForEachBookKeeping.release(traverseContext);
}

/**
 * PooledClass representing the bookkeeping associated with performing a child
 * mapping. Allows avoiding binding callbacks.
 *
 * @constructor MapBookKeeping
 * @param {!*} mapResult Object containing the ordered map of results.
 * @param {!function} mapFunction Function to perform mapping with.
 * @param {?*} mapContext Context to perform mapping with.
 */
function MapBookKeeping(mapResult, mapFunction, mapContext) {
  this.mapResult = mapResult;
  this.mapFunction = mapFunction;
  this.mapContext = mapContext;
}
PooledClass.addPoolingTo(MapBookKeeping, threeArgumentPooler);

function mapSingleChildIntoContext(traverseContext, child, name, i) {
  var mapBookKeeping = traverseContext;
  var mapResult = mapBookKeeping.mapResult;

  var keyUnique = !mapResult.hasOwnProperty(name);
  ("production" !== process.env.NODE_ENV ? warning(
    keyUnique,
    'ReactChildren.map(...): Encountered two children with the same key, ' +
    '`%s`. Child keys must be unique; when two children share a key, only ' +
    'the first child will be used.',
    name
  ) : null);

  if (keyUnique) {
    var mappedChild =
      mapBookKeeping.mapFunction.call(mapBookKeeping.mapContext, child, i);
    mapResult[name] = mappedChild;
  }
}

/**
 * Maps children that are typically specified as `props.children`.
 *
 * The provided mapFunction(child, key, index) will be called for each
 * leaf child.
 *
 * TODO: This may likely break any calls to `ReactChildren.map` that were
 * previously relying on the fact that we guarded against null children.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} mapFunction.
 * @param {*} mapContext Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }

  var mapResult = {};
  var traverseContext = MapBookKeeping.getPooled(mapResult, func, context);
  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
  MapBookKeeping.release(traverseContext);
  return mapResult;
}

function forEachSingleChildDummy(traverseContext, child, name, i) {
  return null;
}

/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */
function countChildren(children, context) {
  return traverseAllChildren(children, forEachSingleChildDummy, null);
}

var ReactChildren = {
  forEach: forEachChildren,
  map: mapChildren,
  count: countChildren
};

module.exports = ReactChildren;

}).call(this,require('_process'))
},{"./PooledClass":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/PooledClass.js","./traverseAllChildren":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/traverseAllChildren.js","./warning":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/warning.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactComponent.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactComponent
 */

"use strict";

var ReactDescriptor = require("./ReactDescriptor");
var ReactOwner = require("./ReactOwner");
var ReactUpdates = require("./ReactUpdates");

var invariant = require("./invariant");
var keyMirror = require("./keyMirror");
var merge = require("./merge");

/**
 * Every React component is in one of these life cycles.
 */
var ComponentLifeCycle = keyMirror({
  /**
   * Mounted components have a DOM node representation and are capable of
   * receiving new props.
   */
  MOUNTED: null,
  /**
   * Unmounted components are inactive and cannot receive new props.
   */
  UNMOUNTED: null
});

var injected = false;

/**
 * Optionally injectable environment dependent cleanup hook. (server vs.
 * browser etc). Example: A browser system caches DOM nodes based on component
 * ID and must remove that cache entry when this instance is unmounted.
 *
 * @private
 */
var unmountIDFromEnvironment = null;

/**
 * The "image" of a component tree, is the platform specific (typically
 * serialized) data that represents a tree of lower level UI building blocks.
 * On the web, this "image" is HTML markup which describes a construction of
 * low level `div` and `span` nodes. Other platforms may have different
 * encoding of this "image". This must be injected.
 *
 * @private
 */
var mountImageIntoNode = null;

/**
 * Components are the basic units of composition in React.
 *
 * Every component accepts a set of keyed input parameters known as "props" that
 * are initialized by the constructor. Once a component is mounted, the props
 * can be mutated using `setProps` or `replaceProps`.
 *
 * Every component is capable of the following operations:
 *
 *   `mountComponent`
 *     Initializes the component, renders markup, and registers event listeners.
 *
 *   `receiveComponent`
 *     Updates the rendered DOM nodes to match the given component.
 *
 *   `unmountComponent`
 *     Releases any resources allocated by this component.
 *
 * Components can also be "owned" by other components. Being owned by another
 * component means being constructed by that component. This is different from
 * being the child of a component, which means having a DOM representation that
 * is a child of the DOM representation of that component.
 *
 * @class ReactComponent
 */
var ReactComponent = {

  injection: {
    injectEnvironment: function(ReactComponentEnvironment) {
      ("production" !== process.env.NODE_ENV ? invariant(
        !injected,
        'ReactComponent: injectEnvironment() can only be called once.'
      ) : invariant(!injected));
      mountImageIntoNode = ReactComponentEnvironment.mountImageIntoNode;
      unmountIDFromEnvironment =
        ReactComponentEnvironment.unmountIDFromEnvironment;
      ReactComponent.BackendIDOperations =
        ReactComponentEnvironment.BackendIDOperations;
      injected = true;
    }
  },

  /**
   * @internal
   */
  LifeCycle: ComponentLifeCycle,

  /**
   * Injected module that provides ability to mutate individual properties.
   * Injected into the base class because many different subclasses need access
   * to this.
   *
   * @internal
   */
  BackendIDOperations: null,

  /**
   * Base functionality for every ReactComponent constructor. Mixed into the
   * `ReactComponent` prototype, but exposed statically for easy access.
   *
   * @lends {ReactComponent.prototype}
   */
  Mixin: {

    /**
     * Checks whether or not this component is mounted.
     *
     * @return {boolean} True if mounted, false otherwise.
     * @final
     * @protected
     */
    isMounted: function() {
      return this._lifeCycleState === ComponentLifeCycle.MOUNTED;
    },

    /**
     * Sets a subset of the props.
     *
     * @param {object} partialProps Subset of the next props.
     * @param {?function} callback Called after props are updated.
     * @final
     * @public
     */
    setProps: function(partialProps, callback) {
      // Merge with the pending descriptor if it exists, otherwise with existing
      // descriptor props.
      var descriptor = this._pendingDescriptor || this._descriptor;
      this.replaceProps(
        merge(descriptor.props, partialProps),
        callback
      );
    },

    /**
     * Replaces all of the props.
     *
     * @param {object} props New props.
     * @param {?function} callback Called after props are updated.
     * @final
     * @public
     */
    replaceProps: function(props, callback) {
      ("production" !== process.env.NODE_ENV ? invariant(
        this.isMounted(),
        'replaceProps(...): Can only update a mounted component.'
      ) : invariant(this.isMounted()));
      ("production" !== process.env.NODE_ENV ? invariant(
        this._mountDepth === 0,
        'replaceProps(...): You called `setProps` or `replaceProps` on a ' +
        'component with a parent. This is an anti-pattern since props will ' +
        'get reactively updated when rendered. Instead, change the owner\'s ' +
        '`render` method to pass the correct value as props to the component ' +
        'where it is created.'
      ) : invariant(this._mountDepth === 0));
      // This is a deoptimized path. We optimize for always having a descriptor.
      // This creates an extra internal descriptor.
      this._pendingDescriptor = ReactDescriptor.cloneAndReplaceProps(
        this._pendingDescriptor || this._descriptor,
        props
      );
      ReactUpdates.enqueueUpdate(this, callback);
    },

    /**
     * Schedule a partial update to the props. Only used for internal testing.
     *
     * @param {object} partialProps Subset of the next props.
     * @param {?function} callback Called after props are updated.
     * @final
     * @internal
     */
    _setPropsInternal: function(partialProps, callback) {
      // This is a deoptimized path. We optimize for always having a descriptor.
      // This creates an extra internal descriptor.
      var descriptor = this._pendingDescriptor || this._descriptor;
      this._pendingDescriptor = ReactDescriptor.cloneAndReplaceProps(
        descriptor,
        merge(descriptor.props, partialProps)
      );
      ReactUpdates.enqueueUpdate(this, callback);
    },

    /**
     * Base constructor for all React components.
     *
     * Subclasses that override this method should make sure to invoke
     * `ReactComponent.Mixin.construct.call(this, ...)`.
     *
     * @param {ReactDescriptor} descriptor
     * @internal
     */
    construct: function(descriptor) {
      // This is the public exposed props object after it has been processed
      // with default props. The descriptor's props represents the true internal
      // state of the props.
      this.props = descriptor.props;
      // Record the component responsible for creating this component.
      // This is accessible through the descriptor but we maintain an extra
      // field for compatibility with devtools and as a way to make an
      // incremental update. TODO: Consider deprecating this field.
      this._owner = descriptor._owner;

      // All components start unmounted.
      this._lifeCycleState = ComponentLifeCycle.UNMOUNTED;

      // See ReactUpdates.
      this._pendingCallbacks = null;

      // We keep the old descriptor and a reference to the pending descriptor
      // to track updates.
      this._descriptor = descriptor;
      this._pendingDescriptor = null;
    },

    /**
     * Initializes the component, renders markup, and registers event listeners.
     *
     * NOTE: This does not insert any nodes into the DOM.
     *
     * Subclasses that override this method should make sure to invoke
     * `ReactComponent.Mixin.mountComponent.call(this, ...)`.
     *
     * @param {string} rootID DOM ID of the root node.
     * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
     * @param {number} mountDepth number of components in the owner hierarchy.
     * @return {?string} Rendered markup to be inserted into the DOM.
     * @internal
     */
    mountComponent: function(rootID, transaction, mountDepth) {
      ("production" !== process.env.NODE_ENV ? invariant(
        !this.isMounted(),
        'mountComponent(%s, ...): Can only mount an unmounted component. ' +
        'Make sure to avoid storing components between renders or reusing a ' +
        'single component instance in multiple places.',
        rootID
      ) : invariant(!this.isMounted()));
      var props = this._descriptor.props;
      if (props.ref != null) {
        var owner = this._descriptor._owner;
        ReactOwner.addComponentAsRefTo(this, props.ref, owner);
      }
      this._rootNodeID = rootID;
      this._lifeCycleState = ComponentLifeCycle.MOUNTED;
      this._mountDepth = mountDepth;
      // Effectively: return '';
    },

    /**
     * Releases any resources allocated by `mountComponent`.
     *
     * NOTE: This does not remove any nodes from the DOM.
     *
     * Subclasses that override this method should make sure to invoke
     * `ReactComponent.Mixin.unmountComponent.call(this)`.
     *
     * @internal
     */
    unmountComponent: function() {
      ("production" !== process.env.NODE_ENV ? invariant(
        this.isMounted(),
        'unmountComponent(): Can only unmount a mounted component.'
      ) : invariant(this.isMounted()));
      var props = this.props;
      if (props.ref != null) {
        ReactOwner.removeComponentAsRefFrom(this, props.ref, this._owner);
      }
      unmountIDFromEnvironment(this._rootNodeID);
      this._rootNodeID = null;
      this._lifeCycleState = ComponentLifeCycle.UNMOUNTED;
    },

    /**
     * Given a new instance of this component, updates the rendered DOM nodes
     * as if that instance was rendered instead.
     *
     * Subclasses that override this method should make sure to invoke
     * `ReactComponent.Mixin.receiveComponent.call(this, ...)`.
     *
     * @param {object} nextComponent Next set of properties.
     * @param {ReactReconcileTransaction} transaction
     * @internal
     */
    receiveComponent: function(nextDescriptor, transaction) {
      ("production" !== process.env.NODE_ENV ? invariant(
        this.isMounted(),
        'receiveComponent(...): Can only update a mounted component.'
      ) : invariant(this.isMounted()));
      this._pendingDescriptor = nextDescriptor;
      this.performUpdateIfNecessary(transaction);
    },

    /**
     * If `_pendingDescriptor` is set, update the component.
     *
     * @param {ReactReconcileTransaction} transaction
     * @internal
     */
    performUpdateIfNecessary: function(transaction) {
      if (this._pendingDescriptor == null) {
        return;
      }
      var prevDescriptor = this._descriptor;
      var nextDescriptor = this._pendingDescriptor;
      this._descriptor = nextDescriptor;
      this.props = nextDescriptor.props;
      this._owner = nextDescriptor._owner;
      this._pendingDescriptor = null;
      this.updateComponent(transaction, prevDescriptor);
    },

    /**
     * Updates the component's currently mounted representation.
     *
     * @param {ReactReconcileTransaction} transaction
     * @param {object} prevDescriptor
     * @internal
     */
    updateComponent: function(transaction, prevDescriptor) {
      var nextDescriptor = this._descriptor;

      // If either the owner or a `ref` has changed, make sure the newest owner
      // has stored a reference to `this`, and the previous owner (if different)
      // has forgotten the reference to `this`. We use the descriptor instead
      // of the public this.props because the post processing cannot determine
      // a ref. The ref conceptually lives on the descriptor.

      // TODO: Should this even be possible? The owner cannot change because
      // it's forbidden by shouldUpdateReactComponent. The ref can change
      // if you swap the keys of but not the refs. Reconsider where this check
      // is made. It probably belongs where the key checking and
      // instantiateReactComponent is done.

      if (nextDescriptor._owner !== prevDescriptor._owner ||
          nextDescriptor.props.ref !== prevDescriptor.props.ref) {
        if (prevDescriptor.props.ref != null) {
          ReactOwner.removeComponentAsRefFrom(
            this, prevDescriptor.props.ref, prevDescriptor._owner
          );
        }
        // Correct, even if the owner is the same, and only the ref has changed.
        if (nextDescriptor.props.ref != null) {
          ReactOwner.addComponentAsRefTo(
            this,
            nextDescriptor.props.ref,
            nextDescriptor._owner
          );
        }
      }
    },

    /**
     * Mounts this component and inserts it into the DOM.
     *
     * @param {string} rootID DOM ID of the root node.
     * @param {DOMElement} container DOM element to mount into.
     * @param {boolean} shouldReuseMarkup If true, do not insert markup
     * @final
     * @internal
     * @see {ReactMount.renderComponent}
     */
    mountComponentIntoNode: function(rootID, container, shouldReuseMarkup) {
      var transaction = ReactUpdates.ReactReconcileTransaction.getPooled();
      transaction.perform(
        this._mountComponentIntoNode,
        this,
        rootID,
        container,
        transaction,
        shouldReuseMarkup
      );
      ReactUpdates.ReactReconcileTransaction.release(transaction);
    },

    /**
     * @param {string} rootID DOM ID of the root node.
     * @param {DOMElement} container DOM element to mount into.
     * @param {ReactReconcileTransaction} transaction
     * @param {boolean} shouldReuseMarkup If true, do not insert markup
     * @final
     * @private
     */
    _mountComponentIntoNode: function(
        rootID,
        container,
        transaction,
        shouldReuseMarkup) {
      var markup = this.mountComponent(rootID, transaction, 0);
      mountImageIntoNode(markup, container, shouldReuseMarkup);
    },

    /**
     * Checks if this component is owned by the supplied `owner` component.
     *
     * @param {ReactComponent} owner Component to check.
     * @return {boolean} True if `owners` owns this component.
     * @final
     * @internal
     */
    isOwnedBy: function(owner) {
      return this._owner === owner;
    },

    /**
     * Gets another component, that shares the same owner as this one, by ref.
     *
     * @param {string} ref of a sibling Component.
     * @return {?ReactComponent} the actual sibling Component.
     * @final
     * @internal
     */
    getSiblingByRef: function(ref) {
      var owner = this._owner;
      if (!owner || !owner.refs) {
        return null;
      }
      return owner.refs[ref];
    }
  }
};

module.exports = ReactComponent;

}).call(this,require('_process'))
},{"./ReactDescriptor":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDescriptor.js","./ReactOwner":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactOwner.js","./ReactUpdates":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactUpdates.js","./invariant":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/invariant.js","./keyMirror":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/keyMirror.js","./merge":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/merge.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactComponentBrowserEnvironment.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactComponentBrowserEnvironment
 */

/*jslint evil: true */

"use strict";

var ReactDOMIDOperations = require("./ReactDOMIDOperations");
var ReactMarkupChecksum = require("./ReactMarkupChecksum");
var ReactMount = require("./ReactMount");
var ReactPerf = require("./ReactPerf");
var ReactReconcileTransaction = require("./ReactReconcileTransaction");

var getReactRootElementInContainer = require("./getReactRootElementInContainer");
var invariant = require("./invariant");
var setInnerHTML = require("./setInnerHTML");


var ELEMENT_NODE_TYPE = 1;
var DOC_NODE_TYPE = 9;


/**
 * Abstracts away all functionality of `ReactComponent` requires knowledge of
 * the browser context.
 */
var ReactComponentBrowserEnvironment = {
  ReactReconcileTransaction: ReactReconcileTransaction,

  BackendIDOperations: ReactDOMIDOperations,

  /**
   * If a particular environment requires that some resources be cleaned up,
   * specify this in the injected Mixin. In the DOM, we would likely want to
   * purge any cached node ID lookups.
   *
   * @private
   */
  unmountIDFromEnvironment: function(rootNodeID) {
    ReactMount.purgeID(rootNodeID);
  },

  /**
   * @param {string} markup Markup string to place into the DOM Element.
   * @param {DOMElement} container DOM Element to insert markup into.
   * @param {boolean} shouldReuseMarkup Should reuse the existing markup in the
   * container if possible.
   */
  mountImageIntoNode: ReactPerf.measure(
    'ReactComponentBrowserEnvironment',
    'mountImageIntoNode',
    function(markup, container, shouldReuseMarkup) {
      ("production" !== process.env.NODE_ENV ? invariant(
        container && (
          container.nodeType === ELEMENT_NODE_TYPE ||
            container.nodeType === DOC_NODE_TYPE
        ),
        'mountComponentIntoNode(...): Target container is not valid.'
      ) : invariant(container && (
        container.nodeType === ELEMENT_NODE_TYPE ||
          container.nodeType === DOC_NODE_TYPE
      )));

      if (shouldReuseMarkup) {
        if (ReactMarkupChecksum.canReuseMarkup(
          markup,
          getReactRootElementInContainer(container))) {
          return;
        } else {
          ("production" !== process.env.NODE_ENV ? invariant(
            container.nodeType !== DOC_NODE_TYPE,
            'You\'re trying to render a component to the document using ' +
            'server rendering but the checksum was invalid. This usually ' +
            'means you rendered a different component type or props on ' +
            'the client from the one on the server, or your render() ' +
            'methods are impure. React cannot handle this case due to ' +
            'cross-browser quirks by rendering at the document root. You ' +
            'should look for environment dependent code in your components ' +
            'and ensure the props are the same client and server side.'
          ) : invariant(container.nodeType !== DOC_NODE_TYPE));

          if ("production" !== process.env.NODE_ENV) {
            console.warn(
              'React attempted to use reuse markup in a container but the ' +
              'checksum was invalid. This generally means that you are ' +
              'using server rendering and the markup generated on the ' +
              'server was not what the client was expecting. React injected ' +
              'new markup to compensate which works but you have lost many ' +
              'of the benefits of server rendering. Instead, figure out ' +
              'why the markup being generated is different on the client ' +
              'or server.'
            );
          }
        }
      }

      ("production" !== process.env.NODE_ENV ? invariant(
        container.nodeType !== DOC_NODE_TYPE,
        'You\'re trying to render a component to the document but ' +
          'you didn\'t use server rendering. We can\'t do this ' +
          'without using server rendering due to cross-browser quirks. ' +
          'See renderComponentToString() for server rendering.'
      ) : invariant(container.nodeType !== DOC_NODE_TYPE));

      setInnerHTML(container, markup);
    }
  )
};

module.exports = ReactComponentBrowserEnvironment;

}).call(this,require('_process'))
},{"./ReactDOMIDOperations":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDOMIDOperations.js","./ReactMarkupChecksum":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactMarkupChecksum.js","./ReactMount":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactMount.js","./ReactPerf":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactPerf.js","./ReactReconcileTransaction":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactReconcileTransaction.js","./getReactRootElementInContainer":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/getReactRootElementInContainer.js","./invariant":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/invariant.js","./setInnerHTML":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/setInnerHTML.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactComponentWithPureRenderMixin.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
* @providesModule ReactComponentWithPureRenderMixin
*/

"use strict";

var shallowEqual = require("./shallowEqual");

/**
 * If your React component's render function is "pure", e.g. it will render the
 * same result given the same props and state, provide this Mixin for a
 * considerable performance boost.
 *
 * Most React components have pure render functions.
 *
 * Example:
 *
 *   var ReactComponentWithPureRenderMixin =
 *     require('ReactComponentWithPureRenderMixin');
 *   React.createClass({
 *     mixins: [ReactComponentWithPureRenderMixin],
 *
 *     render: function() {
 *       return <div className={this.props.className}>foo</div>;
 *     }
 *   });
 *
 * Note: This only checks shallow equality for props and state. If these contain
 * complex data structures this mixin may have false-negatives for deeper
 * differences. Only mixin to components which have simple props and state, or
 * use `forceUpdate()` when you know deep data structures have changed.
 */
var ReactComponentWithPureRenderMixin = {
  shouldComponentUpdate: function(nextProps, nextState) {
    return !shallowEqual(this.props, nextProps) ||
           !shallowEqual(this.state, nextState);
  }
};

module.exports = ReactComponentWithPureRenderMixin;

},{"./shallowEqual":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/shallowEqual.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactCompositeComponent.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactCompositeComponent
 */

"use strict";

var ReactComponent = require("./ReactComponent");
var ReactContext = require("./ReactContext");
var ReactCurrentOwner = require("./ReactCurrentOwner");
var ReactDescriptor = require("./ReactDescriptor");
var ReactDescriptorValidator = require("./ReactDescriptorValidator");
var ReactEmptyComponent = require("./ReactEmptyComponent");
var ReactErrorUtils = require("./ReactErrorUtils");
var ReactOwner = require("./ReactOwner");
var ReactPerf = require("./ReactPerf");
var ReactPropTransferer = require("./ReactPropTransferer");
var ReactPropTypeLocations = require("./ReactPropTypeLocations");
var ReactPropTypeLocationNames = require("./ReactPropTypeLocationNames");
var ReactUpdates = require("./ReactUpdates");

var instantiateReactComponent = require("./instantiateReactComponent");
var invariant = require("./invariant");
var keyMirror = require("./keyMirror");
var merge = require("./merge");
var mixInto = require("./mixInto");
var monitorCodeUse = require("./monitorCodeUse");
var mapObject = require("./mapObject");
var shouldUpdateReactComponent = require("./shouldUpdateReactComponent");
var warning = require("./warning");

/**
 * Policies that describe methods in `ReactCompositeComponentInterface`.
 */
var SpecPolicy = keyMirror({
  /**
   * These methods may be defined only once by the class specification or mixin.
   */
  DEFINE_ONCE: null,
  /**
   * These methods may be defined by both the class specification and mixins.
   * Subsequent definitions will be chained. These methods must return void.
   */
  DEFINE_MANY: null,
  /**
   * These methods are overriding the base ReactCompositeComponent class.
   */
  OVERRIDE_BASE: null,
  /**
   * These methods are similar to DEFINE_MANY, except we assume they return
   * objects. We try to merge the keys of the return values of all the mixed in
   * functions. If there is a key conflict we throw.
   */
  DEFINE_MANY_MERGED: null
});


var injectedMixins = [];

/**
 * Composite components are higher-level components that compose other composite
 * or native components.
 *
 * To create a new type of `ReactCompositeComponent`, pass a specification of
 * your new class to `React.createClass`. The only requirement of your class
 * specification is that you implement a `render` method.
 *
 *   var MyComponent = React.createClass({
 *     render: function() {
 *       return <div>Hello World</div>;
 *     }
 *   });
 *
 * The class specification supports a specific protocol of methods that have
 * special meaning (e.g. `render`). See `ReactCompositeComponentInterface` for
 * more the comprehensive protocol. Any other properties and methods in the
 * class specification will available on the prototype.
 *
 * @interface ReactCompositeComponentInterface
 * @internal
 */
var ReactCompositeComponentInterface = {

  /**
   * An array of Mixin objects to include when defining your component.
   *
   * @type {array}
   * @optional
   */
  mixins: SpecPolicy.DEFINE_MANY,

  /**
   * An object containing properties and methods that should be defined on
   * the component's constructor instead of its prototype (static methods).
   *
   * @type {object}
   * @optional
   */
  statics: SpecPolicy.DEFINE_MANY,

  /**
   * Definition of prop types for this component.
   *
   * @type {object}
   * @optional
   */
  propTypes: SpecPolicy.DEFINE_MANY,

  /**
   * Definition of context types for this component.
   *
   * @type {object}
   * @optional
   */
  contextTypes: SpecPolicy.DEFINE_MANY,

  /**
   * Definition of context types this component sets for its children.
   *
   * @type {object}
   * @optional
   */
  childContextTypes: SpecPolicy.DEFINE_MANY,

  // ==== Definition methods ====

  /**
   * Invoked when the component is mounted. Values in the mapping will be set on
   * `this.props` if that prop is not specified (i.e. using an `in` check).
   *
   * This method is invoked before `getInitialState` and therefore cannot rely
   * on `this.state` or use `this.setState`.
   *
   * @return {object}
   * @optional
   */
  getDefaultProps: SpecPolicy.DEFINE_MANY_MERGED,

  /**
   * Invoked once before the component is mounted. The return value will be used
   * as the initial value of `this.state`.
   *
   *   getInitialState: function() {
   *     return {
   *       isOn: false,
   *       fooBaz: new BazFoo()
   *     }
   *   }
   *
   * @return {object}
   * @optional
   */
  getInitialState: SpecPolicy.DEFINE_MANY_MERGED,

  /**
   * @return {object}
   * @optional
   */
  getChildContext: SpecPolicy.DEFINE_MANY_MERGED,

  /**
   * Uses props from `this.props` and state from `this.state` to render the
   * structure of the component.
   *
   * No guarantees are made about when or how often this method is invoked, so
   * it must not have side effects.
   *
   *   render: function() {
   *     var name = this.props.name;
   *     return <div>Hello, {name}!</div>;
   *   }
   *
   * @return {ReactComponent}
   * @nosideeffects
   * @required
   */
  render: SpecPolicy.DEFINE_ONCE,



  // ==== Delegate methods ====

  /**
   * Invoked when the component is initially created and about to be mounted.
   * This may have side effects, but any external subscriptions or data created
   * by this method must be cleaned up in `componentWillUnmount`.
   *
   * @optional
   */
  componentWillMount: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked when the component has been mounted and has a DOM representation.
   * However, there is no guarantee that the DOM node is in the document.
   *
   * Use this as an opportunity to operate on the DOM when the component has
   * been mounted (initialized and rendered) for the first time.
   *
   * @param {DOMElement} rootNode DOM element representing the component.
   * @optional
   */
  componentDidMount: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked before the component receives new props.
   *
   * Use this as an opportunity to react to a prop transition by updating the
   * state using `this.setState`. Current props are accessed via `this.props`.
   *
   *   componentWillReceiveProps: function(nextProps, nextContext) {
   *     this.setState({
   *       likesIncreasing: nextProps.likeCount > this.props.likeCount
   *     });
   *   }
   *
   * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
   * transition may cause a state change, but the opposite is not true. If you
   * need it, you are probably looking for `componentWillUpdate`.
   *
   * @param {object} nextProps
   * @optional
   */
  componentWillReceiveProps: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked while deciding if the component should be updated as a result of
   * receiving new props, state and/or context.
   *
   * Use this as an opportunity to `return false` when you're certain that the
   * transition to the new props/state/context will not require a component
   * update.
   *
   *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
   *     return !equal(nextProps, this.props) ||
   *       !equal(nextState, this.state) ||
   *       !equal(nextContext, this.context);
   *   }
   *
   * @param {object} nextProps
   * @param {?object} nextState
   * @param {?object} nextContext
   * @return {boolean} True if the component should update.
   * @optional
   */
  shouldComponentUpdate: SpecPolicy.DEFINE_ONCE,

  /**
   * Invoked when the component is about to update due to a transition from
   * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
   * and `nextContext`.
   *
   * Use this as an opportunity to perform preparation before an update occurs.
   *
   * NOTE: You **cannot** use `this.setState()` in this method.
   *
   * @param {object} nextProps
   * @param {?object} nextState
   * @param {?object} nextContext
   * @param {ReactReconcileTransaction} transaction
   * @optional
   */
  componentWillUpdate: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked when the component's DOM representation has been updated.
   *
   * Use this as an opportunity to operate on the DOM when the component has
   * been updated.
   *
   * @param {object} prevProps
   * @param {?object} prevState
   * @param {?object} prevContext
   * @param {DOMElement} rootNode DOM element representing the component.
   * @optional
   */
  componentDidUpdate: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked when the component is about to be removed from its parent and have
   * its DOM representation destroyed.
   *
   * Use this as an opportunity to deallocate any external resources.
   *
   * NOTE: There is no `componentDidUnmount` since your component will have been
   * destroyed by that point.
   *
   * @optional
   */
  componentWillUnmount: SpecPolicy.DEFINE_MANY,



  // ==== Advanced methods ====

  /**
   * Updates the component's currently mounted DOM representation.
   *
   * By default, this implements React's rendering and reconciliation algorithm.
   * Sophisticated clients may wish to override this.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   * @overridable
   */
  updateComponent: SpecPolicy.OVERRIDE_BASE

};

/**
 * Mapping from class specification keys to special processing functions.
 *
 * Although these are declared like instance properties in the specification
 * when defining classes using `React.createClass`, they are actually static
 * and are accessible on the constructor instead of the prototype. Despite
 * being static, they must be defined outside of the "statics" key under
 * which all other static methods are defined.
 */
var RESERVED_SPEC_KEYS = {
  displayName: function(Constructor, displayName) {
    Constructor.displayName = displayName;
  },
  mixins: function(Constructor, mixins) {
    if (mixins) {
      for (var i = 0; i < mixins.length; i++) {
        mixSpecIntoComponent(Constructor, mixins[i]);
      }
    }
  },
  childContextTypes: function(Constructor, childContextTypes) {
    validateTypeDef(
      Constructor,
      childContextTypes,
      ReactPropTypeLocations.childContext
    );
    Constructor.childContextTypes = merge(
      Constructor.childContextTypes,
      childContextTypes
    );
  },
  contextTypes: function(Constructor, contextTypes) {
    validateTypeDef(
      Constructor,
      contextTypes,
      ReactPropTypeLocations.context
    );
    Constructor.contextTypes = merge(Constructor.contextTypes, contextTypes);
  },
  /**
   * Special case getDefaultProps which should move into statics but requires
   * automatic merging.
   */
  getDefaultProps: function(Constructor, getDefaultProps) {
    if (Constructor.getDefaultProps) {
      Constructor.getDefaultProps = createMergedResultFunction(
        Constructor.getDefaultProps,
        getDefaultProps
      );
    } else {
      Constructor.getDefaultProps = getDefaultProps;
    }
  },
  propTypes: function(Constructor, propTypes) {
    validateTypeDef(
      Constructor,
      propTypes,
      ReactPropTypeLocations.prop
    );
    Constructor.propTypes = merge(Constructor.propTypes, propTypes);
  },
  statics: function(Constructor, statics) {
    mixStaticSpecIntoComponent(Constructor, statics);
  }
};

function getDeclarationErrorAddendum(component) {
  var owner = component._owner || null;
  if (owner && owner.constructor && owner.constructor.displayName) {
    return ' Check the render method of `' + owner.constructor.displayName +
      '`.';
  }
  return '';
}

function validateTypeDef(Constructor, typeDef, location) {
  for (var propName in typeDef) {
    if (typeDef.hasOwnProperty(propName)) {
      ("production" !== process.env.NODE_ENV ? invariant(
        typeof typeDef[propName] == 'function',
        '%s: %s type `%s` is invalid; it must be a function, usually from ' +
        'React.PropTypes.',
        Constructor.displayName || 'ReactCompositeComponent',
        ReactPropTypeLocationNames[location],
        propName
      ) : invariant(typeof typeDef[propName] == 'function'));
    }
  }
}

function validateMethodOverride(proto, name) {
  var specPolicy = ReactCompositeComponentInterface.hasOwnProperty(name) ?
    ReactCompositeComponentInterface[name] :
    null;

  // Disallow overriding of base class methods unless explicitly allowed.
  if (ReactCompositeComponentMixin.hasOwnProperty(name)) {
    ("production" !== process.env.NODE_ENV ? invariant(
      specPolicy === SpecPolicy.OVERRIDE_BASE,
      'ReactCompositeComponentInterface: You are attempting to override ' +
      '`%s` from your class specification. Ensure that your method names ' +
      'do not overlap with React methods.',
      name
    ) : invariant(specPolicy === SpecPolicy.OVERRIDE_BASE));
  }

  // Disallow defining methods more than once unless explicitly allowed.
  if (proto.hasOwnProperty(name)) {
    ("production" !== process.env.NODE_ENV ? invariant(
      specPolicy === SpecPolicy.DEFINE_MANY ||
      specPolicy === SpecPolicy.DEFINE_MANY_MERGED,
      'ReactCompositeComponentInterface: You are attempting to define ' +
      '`%s` on your component more than once. This conflict may be due ' +
      'to a mixin.',
      name
    ) : invariant(specPolicy === SpecPolicy.DEFINE_MANY ||
    specPolicy === SpecPolicy.DEFINE_MANY_MERGED));
  }
}

function validateLifeCycleOnReplaceState(instance) {
  var compositeLifeCycleState = instance._compositeLifeCycleState;
  ("production" !== process.env.NODE_ENV ? invariant(
    instance.isMounted() ||
      compositeLifeCycleState === CompositeLifeCycle.MOUNTING,
    'replaceState(...): Can only update a mounted or mounting component.'
  ) : invariant(instance.isMounted() ||
    compositeLifeCycleState === CompositeLifeCycle.MOUNTING));
  ("production" !== process.env.NODE_ENV ? invariant(compositeLifeCycleState !== CompositeLifeCycle.RECEIVING_STATE,
    'replaceState(...): Cannot update during an existing state transition ' +
    '(such as within `render`). This could potentially cause an infinite ' +
    'loop so it is forbidden.'
  ) : invariant(compositeLifeCycleState !== CompositeLifeCycle.RECEIVING_STATE));
  ("production" !== process.env.NODE_ENV ? invariant(compositeLifeCycleState !== CompositeLifeCycle.UNMOUNTING,
    'replaceState(...): Cannot update while unmounting component. This ' +
    'usually means you called setState() on an unmounted component.'
  ) : invariant(compositeLifeCycleState !== CompositeLifeCycle.UNMOUNTING));
}

/**
 * Custom version of `mixInto` which handles policy validation and reserved
 * specification keys when building `ReactCompositeComponent` classses.
 */
function mixSpecIntoComponent(Constructor, spec) {
  ("production" !== process.env.NODE_ENV ? invariant(
    !ReactDescriptor.isValidFactory(spec),
    'ReactCompositeComponent: You\'re attempting to ' +
    'use a component class as a mixin. Instead, just use a regular object.'
  ) : invariant(!ReactDescriptor.isValidFactory(spec)));
  ("production" !== process.env.NODE_ENV ? invariant(
    !ReactDescriptor.isValidDescriptor(spec),
    'ReactCompositeComponent: You\'re attempting to ' +
    'use a component as a mixin. Instead, just use a regular object.'
  ) : invariant(!ReactDescriptor.isValidDescriptor(spec)));

  var proto = Constructor.prototype;
  for (var name in spec) {
    var property = spec[name];
    if (!spec.hasOwnProperty(name)) {
      continue;
    }

    validateMethodOverride(proto, name);

    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
      RESERVED_SPEC_KEYS[name](Constructor, property);
    } else {
      // Setup methods on prototype:
      // The following member methods should not be automatically bound:
      // 1. Expected ReactCompositeComponent methods (in the "interface").
      // 2. Overridden methods (that were mixed in).
      var isCompositeComponentMethod =
        ReactCompositeComponentInterface.hasOwnProperty(name);
      var isAlreadyDefined = proto.hasOwnProperty(name);
      var markedDontBind = property && property.__reactDontBind;
      var isFunction = typeof property === 'function';
      var shouldAutoBind =
        isFunction &&
        !isCompositeComponentMethod &&
        !isAlreadyDefined &&
        !markedDontBind;

      if (shouldAutoBind) {
        if (!proto.__reactAutoBindMap) {
          proto.__reactAutoBindMap = {};
        }
        proto.__reactAutoBindMap[name] = property;
        proto[name] = property;
      } else {
        if (isAlreadyDefined) {
          var specPolicy = ReactCompositeComponentInterface[name];

          // These cases should already be caught by validateMethodOverride
          ("production" !== process.env.NODE_ENV ? invariant(
            isCompositeComponentMethod && (
              specPolicy === SpecPolicy.DEFINE_MANY_MERGED ||
              specPolicy === SpecPolicy.DEFINE_MANY
            ),
            'ReactCompositeComponent: Unexpected spec policy %s for key %s ' +
            'when mixing in component specs.',
            specPolicy,
            name
          ) : invariant(isCompositeComponentMethod && (
            specPolicy === SpecPolicy.DEFINE_MANY_MERGED ||
            specPolicy === SpecPolicy.DEFINE_MANY
          )));

          // For methods which are defined more than once, call the existing
          // methods before calling the new property, merging if appropriate.
          if (specPolicy === SpecPolicy.DEFINE_MANY_MERGED) {
            proto[name] = createMergedResultFunction(proto[name], property);
          } else if (specPolicy === SpecPolicy.DEFINE_MANY) {
            proto[name] = createChainedFunction(proto[name], property);
          }
        } else {
          proto[name] = property;
          if ("production" !== process.env.NODE_ENV) {
            // Add verbose displayName to the function, which helps when looking
            // at profiling tools.
            if (typeof property === 'function' && spec.displayName) {
              proto[name].displayName = spec.displayName + '_' + name;
            }
          }
        }
      }
    }
  }
}

function mixStaticSpecIntoComponent(Constructor, statics) {
  if (!statics) {
    return;
  }
  for (var name in statics) {
    var property = statics[name];
    if (!statics.hasOwnProperty(name)) {
      continue;
    }

    var isInherited = name in Constructor;
    var result = property;
    if (isInherited) {
      var existingProperty = Constructor[name];
      var existingType = typeof existingProperty;
      var propertyType = typeof property;
      ("production" !== process.env.NODE_ENV ? invariant(
        existingType === 'function' && propertyType === 'function',
        'ReactCompositeComponent: You are attempting to define ' +
        '`%s` on your component more than once, but that is only supported ' +
        'for functions, which are chained together. This conflict may be ' +
        'due to a mixin.',
        name
      ) : invariant(existingType === 'function' && propertyType === 'function'));
      result = createChainedFunction(existingProperty, property);
    }
    Constructor[name] = result;
  }
}

/**
 * Merge two objects, but throw if both contain the same key.
 *
 * @param {object} one The first object, which is mutated.
 * @param {object} two The second object
 * @return {object} one after it has been mutated to contain everything in two.
 */
function mergeObjectsWithNoDuplicateKeys(one, two) {
  ("production" !== process.env.NODE_ENV ? invariant(
    one && two && typeof one === 'object' && typeof two === 'object',
    'mergeObjectsWithNoDuplicateKeys(): Cannot merge non-objects'
  ) : invariant(one && two && typeof one === 'object' && typeof two === 'object'));

  mapObject(two, function(value, key) {
    ("production" !== process.env.NODE_ENV ? invariant(
      one[key] === undefined,
      'mergeObjectsWithNoDuplicateKeys(): ' +
      'Tried to merge two objects with the same key: %s',
      key
    ) : invariant(one[key] === undefined));
    one[key] = value;
  });
  return one;
}

/**
 * Creates a function that invokes two functions and merges their return values.
 *
 * @param {function} one Function to invoke first.
 * @param {function} two Function to invoke second.
 * @return {function} Function that invokes the two argument functions.
 * @private
 */
function createMergedResultFunction(one, two) {
  return function mergedResult() {
    var a = one.apply(this, arguments);
    var b = two.apply(this, arguments);
    if (a == null) {
      return b;
    } else if (b == null) {
      return a;
    }
    return mergeObjectsWithNoDuplicateKeys(a, b);
  };
}

/**
 * Creates a function that invokes two functions and ignores their return vales.
 *
 * @param {function} one Function to invoke first.
 * @param {function} two Function to invoke second.
 * @return {function} Function that invokes the two argument functions.
 * @private
 */
function createChainedFunction(one, two) {
  return function chainedFunction() {
    one.apply(this, arguments);
    two.apply(this, arguments);
  };
}

/**
 * `ReactCompositeComponent` maintains an auxiliary life cycle state in
 * `this._compositeLifeCycleState` (which can be null).
 *
 * This is different from the life cycle state maintained by `ReactComponent` in
 * `this._lifeCycleState`. The following diagram shows how the states overlap in
 * time. There are times when the CompositeLifeCycle is null - at those times it
 * is only meaningful to look at ComponentLifeCycle alone.
 *
 * Top Row: ReactComponent.ComponentLifeCycle
 * Low Row: ReactComponent.CompositeLifeCycle
 *
 * +-------+------------------------------------------------------+--------+
 * |  UN   |                    MOUNTED                           |   UN   |
 * |MOUNTED|                                                      | MOUNTED|
 * +-------+------------------------------------------------------+--------+
 * |       ^--------+   +------+   +------+   +------+   +--------^        |
 * |       |        |   |      |   |      |   |      |   |        |        |
 * |    0--|MOUNTING|-0-|RECEIV|-0-|RECEIV|-0-|RECEIV|-0-|   UN   |--->0   |
 * |       |        |   |PROPS |   | PROPS|   | STATE|   |MOUNTING|        |
 * |       |        |   |      |   |      |   |      |   |        |        |
 * |       |        |   |      |   |      |   |      |   |        |        |
 * |       +--------+   +------+   +------+   +------+   +--------+        |
 * |       |                                                      |        |
 * +-------+------------------------------------------------------+--------+
 */
var CompositeLifeCycle = keyMirror({
  /**
   * Components in the process of being mounted respond to state changes
   * differently.
   */
  MOUNTING: null,
  /**
   * Components in the process of being unmounted are guarded against state
   * changes.
   */
  UNMOUNTING: null,
  /**
   * Components that are mounted and receiving new props respond to state
   * changes differently.
   */
  RECEIVING_PROPS: null,
  /**
   * Components that are mounted and receiving new state are guarded against
   * additional state changes.
   */
  RECEIVING_STATE: null
});

/**
 * @lends {ReactCompositeComponent.prototype}
 */
var ReactCompositeComponentMixin = {

  /**
   * Base constructor for all composite component.
   *
   * @param {ReactDescriptor} descriptor
   * @final
   * @internal
   */
  construct: function(descriptor) {
    // Children can be either an array or more than one argument
    ReactComponent.Mixin.construct.apply(this, arguments);
    ReactOwner.Mixin.construct.apply(this, arguments);

    this.state = null;
    this._pendingState = null;

    // This is the public post-processed context. The real context and pending
    // context lives on the descriptor.
    this.context = null;

    this._compositeLifeCycleState = null;
  },

  /**
   * Checks whether or not this composite component is mounted.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function() {
    return ReactComponent.Mixin.isMounted.call(this) &&
      this._compositeLifeCycleState !== CompositeLifeCycle.MOUNTING;
  },

  /**
   * Initializes the component, renders markup, and registers event listeners.
   *
   * @param {string} rootID DOM ID of the root node.
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {number} mountDepth number of components in the owner hierarchy
   * @return {?string} Rendered markup to be inserted into the DOM.
   * @final
   * @internal
   */
  mountComponent: ReactPerf.measure(
    'ReactCompositeComponent',
    'mountComponent',
    function(rootID, transaction, mountDepth) {
      ReactComponent.Mixin.mountComponent.call(
        this,
        rootID,
        transaction,
        mountDepth
      );
      this._compositeLifeCycleState = CompositeLifeCycle.MOUNTING;

      if (this.__reactAutoBindMap) {
        this._bindAutoBindMethods();
      }

      this.context = this._processContext(this._descriptor._context);
      this.props = this._processProps(this.props);

      this.state = this.getInitialState ? this.getInitialState() : null;
      ("production" !== process.env.NODE_ENV ? invariant(
        typeof this.state === 'object' && !Array.isArray(this.state),
        '%s.getInitialState(): must return an object or null',
        this.constructor.displayName || 'ReactCompositeComponent'
      ) : invariant(typeof this.state === 'object' && !Array.isArray(this.state)));

      this._pendingState = null;
      this._pendingForceUpdate = false;

      if (this.componentWillMount) {
        this.componentWillMount();
        // When mounting, calls to `setState` by `componentWillMount` will set
        // `this._pendingState` without triggering a re-render.
        if (this._pendingState) {
          this.state = this._pendingState;
          this._pendingState = null;
        }
      }

      this._renderedComponent = instantiateReactComponent(
        this._renderValidatedComponent()
      );

      // Done with mounting, `setState` will now trigger UI changes.
      this._compositeLifeCycleState = null;
      var markup = this._renderedComponent.mountComponent(
        rootID,
        transaction,
        mountDepth + 1
      );
      if (this.componentDidMount) {
        transaction.getReactMountReady().enqueue(this.componentDidMount, this);
      }
      return markup;
    }
  ),

  /**
   * Releases any resources allocated by `mountComponent`.
   *
   * @final
   * @internal
   */
  unmountComponent: function() {
    this._compositeLifeCycleState = CompositeLifeCycle.UNMOUNTING;
    if (this.componentWillUnmount) {
      this.componentWillUnmount();
    }
    this._compositeLifeCycleState = null;

    this._renderedComponent.unmountComponent();
    this._renderedComponent = null;

    ReactComponent.Mixin.unmountComponent.call(this);

    // Some existing components rely on this.props even after they've been
    // destroyed (in event handlers).
    // TODO: this.props = null;
    // TODO: this.state = null;
  },

  /**
   * Sets a subset of the state. Always use this or `replaceState` to mutate
   * state. You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * There is no guarantee that calls to `setState` will run synchronously,
   * as they may eventually be batched together.  You can provide an optional
   * callback that will be executed when the call to setState is actually
   * completed.
   *
   * @param {object} partialState Next partial state to be merged with state.
   * @param {?function} callback Called after state is updated.
   * @final
   * @protected
   */
  setState: function(partialState, callback) {
    ("production" !== process.env.NODE_ENV ? invariant(
      typeof partialState === 'object' || partialState == null,
      'setState(...): takes an object of state variables to update.'
    ) : invariant(typeof partialState === 'object' || partialState == null));
    if ("production" !== process.env.NODE_ENV){
      ("production" !== process.env.NODE_ENV ? warning(
        partialState != null,
        'setState(...): You passed an undefined or null state object; ' +
        'instead, use forceUpdate().'
      ) : null);
    }
    // Merge with `_pendingState` if it exists, otherwise with existing state.
    this.replaceState(
      merge(this._pendingState || this.state, partialState),
      callback
    );
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {object} completeState Next state.
   * @param {?function} callback Called after state is updated.
   * @final
   * @protected
   */
  replaceState: function(completeState, callback) {
    validateLifeCycleOnReplaceState(this);
    this._pendingState = completeState;
    if (this._compositeLifeCycleState !== CompositeLifeCycle.MOUNTING) {
      // If we're in a componentWillMount handler, don't enqueue a rerender
      // because ReactUpdates assumes we're in a browser context (which is wrong
      // for server rendering) and we're about to do a render anyway.
      // TODO: The callback here is ignored when setState is called from
      // componentWillMount. Either fix it or disallow doing so completely in
      // favor of getInitialState.
      ReactUpdates.enqueueUpdate(this, callback);
    }
  },

  /**
   * Filters the context object to only contain keys specified in
   * `contextTypes`, and asserts that they are valid.
   *
   * @param {object} context
   * @return {?object}
   * @private
   */
  _processContext: function(context) {
    var maskedContext = null;
    var contextTypes = this.constructor.contextTypes;
    if (contextTypes) {
      maskedContext = {};
      for (var contextName in contextTypes) {
        maskedContext[contextName] = context[contextName];
      }
      if ("production" !== process.env.NODE_ENV) {
        this._checkPropTypes(
          contextTypes,
          maskedContext,
          ReactPropTypeLocations.context
        );
      }
    }
    return maskedContext;
  },

  /**
   * @param {object} currentContext
   * @return {object}
   * @private
   */
  _processChildContext: function(currentContext) {
    var childContext = this.getChildContext && this.getChildContext();
    var displayName = this.constructor.displayName || 'ReactCompositeComponent';
    if (childContext) {
      ("production" !== process.env.NODE_ENV ? invariant(
        typeof this.constructor.childContextTypes === 'object',
        '%s.getChildContext(): childContextTypes must be defined in order to ' +
        'use getChildContext().',
        displayName
      ) : invariant(typeof this.constructor.childContextTypes === 'object'));
      if ("production" !== process.env.NODE_ENV) {
        this._checkPropTypes(
          this.constructor.childContextTypes,
          childContext,
          ReactPropTypeLocations.childContext
        );
      }
      for (var name in childContext) {
        ("production" !== process.env.NODE_ENV ? invariant(
          name in this.constructor.childContextTypes,
          '%s.getChildContext(): key "%s" is not defined in childContextTypes.',
          displayName,
          name
        ) : invariant(name in this.constructor.childContextTypes));
      }
      return merge(currentContext, childContext);
    }
    return currentContext;
  },

  /**
   * Processes props by setting default values for unspecified props and
   * asserting that the props are valid. Does not mutate its argument; returns
   * a new props object with defaults merged in.
   *
   * @param {object} newProps
   * @return {object}
   * @private
   */
  _processProps: function(newProps) {
    var defaultProps = this.constructor.defaultProps;
    var props;
    if (defaultProps) {
      props = merge(newProps);
      for (var propName in defaultProps) {
        if (typeof props[propName] === 'undefined') {
          props[propName] = defaultProps[propName];
        }
      }
    } else {
      props = newProps;
    }
    if ("production" !== process.env.NODE_ENV) {
      var propTypes = this.constructor.propTypes;
      if (propTypes) {
        this._checkPropTypes(propTypes, props, ReactPropTypeLocations.prop);
      }
    }
    return props;
  },

  /**
   * Assert that the props are valid
   *
   * @param {object} propTypes Map of prop name to a ReactPropType
   * @param {object} props
   * @param {string} location e.g. "prop", "context", "child context"
   * @private
   */
  _checkPropTypes: function(propTypes, props, location) {
    // TODO: Stop validating prop types here and only use the descriptor
    // validation.
    var componentName = this.constructor.displayName;
    for (var propName in propTypes) {
      if (propTypes.hasOwnProperty(propName)) {
        var error =
          propTypes[propName](props, propName, componentName, location);
        if (error instanceof Error) {
          // We may want to extend this logic for similar errors in
          // renderComponent calls, so I'm abstracting it away into
          // a function to minimize refactoring in the future
          var addendum = getDeclarationErrorAddendum(this);
          ("production" !== process.env.NODE_ENV ? warning(false, error.message + addendum) : null);
        }
      }
    }
  },

  /**
   * If any of `_pendingDescriptor`, `_pendingState`, or `_pendingForceUpdate`
   * is set, update the component.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  performUpdateIfNecessary: function(transaction) {
    var compositeLifeCycleState = this._compositeLifeCycleState;
    // Do not trigger a state transition if we are in the middle of mounting or
    // receiving props because both of those will already be doing this.
    if (compositeLifeCycleState === CompositeLifeCycle.MOUNTING ||
        compositeLifeCycleState === CompositeLifeCycle.RECEIVING_PROPS) {
      return;
    }

    if (this._pendingDescriptor == null &&
        this._pendingState == null &&
        !this._pendingForceUpdate) {
      return;
    }

    var nextContext = this.context;
    var nextProps = this.props;
    var nextDescriptor = this._descriptor;
    if (this._pendingDescriptor != null) {
      nextDescriptor = this._pendingDescriptor;
      nextContext = this._processContext(nextDescriptor._context);
      nextProps = this._processProps(nextDescriptor.props);
      this._pendingDescriptor = null;

      this._compositeLifeCycleState = CompositeLifeCycle.RECEIVING_PROPS;
      if (this.componentWillReceiveProps) {
        this.componentWillReceiveProps(nextProps, nextContext);
      }
    }

    this._compositeLifeCycleState = CompositeLifeCycle.RECEIVING_STATE;

    var nextState = this._pendingState || this.state;
    this._pendingState = null;

    try {
      var shouldUpdate =
        this._pendingForceUpdate ||
        !this.shouldComponentUpdate ||
        this.shouldComponentUpdate(nextProps, nextState, nextContext);

      if ("production" !== process.env.NODE_ENV) {
        if (typeof shouldUpdate === "undefined") {
          console.warn(
            (this.constructor.displayName || 'ReactCompositeComponent') +
            '.shouldComponentUpdate(): Returned undefined instead of a ' +
            'boolean value. Make sure to return true or false.'
          );
        }
      }

      if (shouldUpdate) {
        this._pendingForceUpdate = false;
        // Will set `this.props`, `this.state` and `this.context`.
        this._performComponentUpdate(
          nextDescriptor,
          nextProps,
          nextState,
          nextContext,
          transaction
        );
      } else {
        // If it's determined that a component should not update, we still want
        // to set props and state.
        this._descriptor = nextDescriptor;
        this.props = nextProps;
        this.state = nextState;
        this.context = nextContext;

        // Owner cannot change because shouldUpdateReactComponent doesn't allow
        // it. TODO: Remove this._owner completely.
        this._owner = nextDescriptor._owner;
      }
    } finally {
      this._compositeLifeCycleState = null;
    }
  },

  /**
   * Merges new props and state, notifies delegate methods of update and
   * performs update.
   *
   * @param {ReactDescriptor} nextDescriptor Next descriptor
   * @param {object} nextProps Next public object to set as properties.
   * @param {?object} nextState Next object to set as state.
   * @param {?object} nextContext Next public object to set as context.
   * @param {ReactReconcileTransaction} transaction
   * @private
   */
  _performComponentUpdate: function(
    nextDescriptor,
    nextProps,
    nextState,
    nextContext,
    transaction
  ) {
    var prevDescriptor = this._descriptor;
    var prevProps = this.props;
    var prevState = this.state;
    var prevContext = this.context;

    if (this.componentWillUpdate) {
      this.componentWillUpdate(nextProps, nextState, nextContext);
    }

    this._descriptor = nextDescriptor;
    this.props = nextProps;
    this.state = nextState;
    this.context = nextContext;

    // Owner cannot change because shouldUpdateReactComponent doesn't allow
    // it. TODO: Remove this._owner completely.
    this._owner = nextDescriptor._owner;

    this.updateComponent(
      transaction,
      prevDescriptor
    );

    if (this.componentDidUpdate) {
      transaction.getReactMountReady().enqueue(
        this.componentDidUpdate.bind(this, prevProps, prevState, prevContext),
        this
      );
    }
  },

  receiveComponent: function(nextDescriptor, transaction) {
    if (nextDescriptor === this._descriptor &&
        nextDescriptor._owner != null) {
      // Since descriptors are immutable after the owner is rendered,
      // we can do a cheap identity compare here to determine if this is a
      // superfluous reconcile. It's possible for state to be mutable but such
      // change should trigger an update of the owner which would recreate
      // the descriptor. We explicitly check for the existence of an owner since
      // it's possible for a descriptor created outside a composite to be
      // deeply mutated and reused.
      return;
    }

    ReactComponent.Mixin.receiveComponent.call(
      this,
      nextDescriptor,
      transaction
    );
  },

  /**
   * Updates the component's currently mounted DOM representation.
   *
   * By default, this implements React's rendering and reconciliation algorithm.
   * Sophisticated clients may wish to override this.
   *
   * @param {ReactReconcileTransaction} transaction
   * @param {ReactDescriptor} prevDescriptor
   * @internal
   * @overridable
   */
  updateComponent: ReactPerf.measure(
    'ReactCompositeComponent',
    'updateComponent',
    function(transaction, prevParentDescriptor) {
      ReactComponent.Mixin.updateComponent.call(
        this,
        transaction,
        prevParentDescriptor
      );

      var prevComponentInstance = this._renderedComponent;
      var prevDescriptor = prevComponentInstance._descriptor;
      var nextDescriptor = this._renderValidatedComponent();
      if (shouldUpdateReactComponent(prevDescriptor, nextDescriptor)) {
        prevComponentInstance.receiveComponent(nextDescriptor, transaction);
      } else {
        // These two IDs are actually the same! But nothing should rely on that.
        var thisID = this._rootNodeID;
        var prevComponentID = prevComponentInstance._rootNodeID;
        prevComponentInstance.unmountComponent();
        this._renderedComponent = instantiateReactComponent(nextDescriptor);
        var nextMarkup = this._renderedComponent.mountComponent(
          thisID,
          transaction,
          this._mountDepth + 1
        );
        ReactComponent.BackendIDOperations.dangerouslyReplaceNodeWithMarkupByID(
          prevComponentID,
          nextMarkup
        );
      }
    }
  ),

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldUpdateComponent`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {?function} callback Called after update is complete.
   * @final
   * @protected
   */
  forceUpdate: function(callback) {
    var compositeLifeCycleState = this._compositeLifeCycleState;
    ("production" !== process.env.NODE_ENV ? invariant(
      this.isMounted() ||
        compositeLifeCycleState === CompositeLifeCycle.MOUNTING,
      'forceUpdate(...): Can only force an update on mounted or mounting ' +
        'components.'
    ) : invariant(this.isMounted() ||
      compositeLifeCycleState === CompositeLifeCycle.MOUNTING));
    ("production" !== process.env.NODE_ENV ? invariant(
      compositeLifeCycleState !== CompositeLifeCycle.RECEIVING_STATE &&
      compositeLifeCycleState !== CompositeLifeCycle.UNMOUNTING,
      'forceUpdate(...): Cannot force an update while unmounting component ' +
      'or during an existing state transition (such as within `render`).'
    ) : invariant(compositeLifeCycleState !== CompositeLifeCycle.RECEIVING_STATE &&
    compositeLifeCycleState !== CompositeLifeCycle.UNMOUNTING));
    this._pendingForceUpdate = true;
    ReactUpdates.enqueueUpdate(this, callback);
  },

  /**
   * @private
   */
  _renderValidatedComponent: ReactPerf.measure(
    'ReactCompositeComponent',
    '_renderValidatedComponent',
    function() {
      var renderedComponent;
      var previousContext = ReactContext.current;
      ReactContext.current = this._processChildContext(
        this._descriptor._context
      );
      ReactCurrentOwner.current = this;
      try {
        renderedComponent = this.render();
        if (renderedComponent === null || renderedComponent === false) {
          renderedComponent = ReactEmptyComponent.getEmptyComponent();
          ReactEmptyComponent.registerNullComponentID(this._rootNodeID);
        } else {
          ReactEmptyComponent.deregisterNullComponentID(this._rootNodeID);
        }
      } finally {
        ReactContext.current = previousContext;
        ReactCurrentOwner.current = null;
      }
      ("production" !== process.env.NODE_ENV ? invariant(
        ReactDescriptor.isValidDescriptor(renderedComponent),
        '%s.render(): A valid ReactComponent must be returned. You may have ' +
          'returned undefined, an array or some other invalid object.',
        this.constructor.displayName || 'ReactCompositeComponent'
      ) : invariant(ReactDescriptor.isValidDescriptor(renderedComponent)));
      return renderedComponent;
    }
  ),

  /**
   * @private
   */
  _bindAutoBindMethods: function() {
    for (var autoBindKey in this.__reactAutoBindMap) {
      if (!this.__reactAutoBindMap.hasOwnProperty(autoBindKey)) {
        continue;
      }
      var method = this.__reactAutoBindMap[autoBindKey];
      this[autoBindKey] = this._bindAutoBindMethod(ReactErrorUtils.guard(
        method,
        this.constructor.displayName + '.' + autoBindKey
      ));
    }
  },

  /**
   * Binds a method to the component.
   *
   * @param {function} method Method to be bound.
   * @private
   */
  _bindAutoBindMethod: function(method) {
    var component = this;
    var boundMethod = function() {
      return method.apply(component, arguments);
    };
    if ("production" !== process.env.NODE_ENV) {
      boundMethod.__reactBoundContext = component;
      boundMethod.__reactBoundMethod = method;
      boundMethod.__reactBoundArguments = null;
      var componentName = component.constructor.displayName;
      var _bind = boundMethod.bind;
      boundMethod.bind = function(newThis ) {var args=Array.prototype.slice.call(arguments,1);
        // User is trying to bind() an autobound method; we effectively will
        // ignore the value of "this" that the user is trying to use, so
        // let's warn.
        if (newThis !== component && newThis !== null) {
          monitorCodeUse('react_bind_warning', { component: componentName });
          console.warn(
            'bind(): React component methods may only be bound to the ' +
            'component instance. See ' + componentName
          );
        } else if (!args.length) {
          monitorCodeUse('react_bind_warning', { component: componentName });
          console.warn(
            'bind(): You are binding a component method to the component. ' +
            'React does this for you automatically in a high-performance ' +
            'way, so you can safely remove this call. See ' + componentName
          );
          return boundMethod;
        }
        var reboundMethod = _bind.apply(boundMethod, arguments);
        reboundMethod.__reactBoundContext = component;
        reboundMethod.__reactBoundMethod = method;
        reboundMethod.__reactBoundArguments = args;
        return reboundMethod;
      };
    }
    return boundMethod;
  }
};

var ReactCompositeComponentBase = function() {};
mixInto(ReactCompositeComponentBase, ReactComponent.Mixin);
mixInto(ReactCompositeComponentBase, ReactOwner.Mixin);
mixInto(ReactCompositeComponentBase, ReactPropTransferer.Mixin);
mixInto(ReactCompositeComponentBase, ReactCompositeComponentMixin);

/**
 * Module for creating composite components.
 *
 * @class ReactCompositeComponent
 * @extends ReactComponent
 * @extends ReactOwner
 * @extends ReactPropTransferer
 */
var ReactCompositeComponent = {

  LifeCycle: CompositeLifeCycle,

  Base: ReactCompositeComponentBase,

  /**
   * Creates a composite component class given a class specification.
   *
   * @param {object} spec Class specification (which must define `render`).
   * @return {function} Component constructor function.
   * @public
   */
  createClass: function(spec) {
    var Constructor = function(props, owner) {
      this.construct(props, owner);
    };
    Constructor.prototype = new ReactCompositeComponentBase();
    Constructor.prototype.constructor = Constructor;

    injectedMixins.forEach(
      mixSpecIntoComponent.bind(null, Constructor)
    );

    mixSpecIntoComponent(Constructor, spec);

    // Initialize the defaultProps property after all mixins have been merged
    if (Constructor.getDefaultProps) {
      Constructor.defaultProps = Constructor.getDefaultProps();
    }

    ("production" !== process.env.NODE_ENV ? invariant(
      Constructor.prototype.render,
      'createClass(...): Class specification must implement a `render` method.'
    ) : invariant(Constructor.prototype.render));

    if ("production" !== process.env.NODE_ENV) {
      if (Constructor.prototype.componentShouldUpdate) {
        monitorCodeUse(
          'react_component_should_update_warning',
          { component: spec.displayName }
        );
        console.warn(
          (spec.displayName || 'A component') + ' has a method called ' +
          'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' +
          'The name is phrased as a question because the function is ' +
          'expected to return a value.'
         );
      }
    }

    // Reduce time spent doing lookups by setting these on the prototype.
    for (var methodName in ReactCompositeComponentInterface) {
      if (!Constructor.prototype[methodName]) {
        Constructor.prototype[methodName] = null;
      }
    }

    var descriptorFactory = ReactDescriptor.createFactory(Constructor);

    if ("production" !== process.env.NODE_ENV) {
      return ReactDescriptorValidator.createFactory(
        descriptorFactory,
        Constructor.propTypes,
        Constructor.contextTypes
      );
    }

    return descriptorFactory;
  },

  injection: {
    injectMixin: function(mixin) {
      injectedMixins.push(mixin);
    }
  }
};

module.exports = ReactCompositeComponent;

}).call(this,require('_process'))
},{"./ReactComponent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactComponent.js","./ReactContext":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactContext.js","./ReactCurrentOwner":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactCurrentOwner.js","./ReactDescriptor":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDescriptor.js","./ReactDescriptorValidator":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDescriptorValidator.js","./ReactEmptyComponent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactEmptyComponent.js","./ReactErrorUtils":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactErrorUtils.js","./ReactOwner":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactOwner.js","./ReactPerf":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactPerf.js","./ReactPropTransferer":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactPropTransferer.js","./ReactPropTypeLocationNames":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactPropTypeLocationNames.js","./ReactPropTypeLocations":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactPropTypeLocations.js","./ReactUpdates":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactUpdates.js","./instantiateReactComponent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/instantiateReactComponent.js","./invariant":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/invariant.js","./keyMirror":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/keyMirror.js","./mapObject":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/mapObject.js","./merge":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/merge.js","./mixInto":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/mixInto.js","./monitorCodeUse":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/monitorCodeUse.js","./shouldUpdateReactComponent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/shouldUpdateReactComponent.js","./warning":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/warning.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactContext.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactContext
 */

"use strict";

var merge = require("./merge");

/**
 * Keeps track of the current context.
 *
 * The context is automatically passed down the component ownership hierarchy
 * and is accessible via `this.context` on ReactCompositeComponents.
 */
var ReactContext = {

  /**
   * @internal
   * @type {object}
   */
  current: {},

  /**
   * Temporarily extends the current context while executing scopedCallback.
   *
   * A typical use case might look like
   *
   *  render: function() {
   *    var children = ReactContext.withContext({foo: 'foo'} () => (
   *
   *    ));
   *    return <div>{children}</div>;
   *  }
   *
   * @param {object} newContext New context to merge into the existing context
   * @param {function} scopedCallback Callback to run with the new context
   * @return {ReactComponent|array<ReactComponent>}
   */
  withContext: function(newContext, scopedCallback) {
    var result;
    var previousContext = ReactContext.current;
    ReactContext.current = merge(previousContext, newContext);
    try {
      result = scopedCallback();
    } finally {
      ReactContext.current = previousContext;
    }
    return result;
  }

};

module.exports = ReactContext;

},{"./merge":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/merge.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactCurrentOwner.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactCurrentOwner
 */

"use strict";

/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 *
 * The depth indicate how many composite components are above this render level.
 */
var ReactCurrentOwner = {

  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null

};

module.exports = ReactCurrentOwner;

},{}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDOM.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactDOM
 * @typechecks static-only
 */

"use strict";

var ReactDescriptor = require("./ReactDescriptor");
var ReactDescriptorValidator = require("./ReactDescriptorValidator");
var ReactDOMComponent = require("./ReactDOMComponent");

var mergeInto = require("./mergeInto");
var mapObject = require("./mapObject");

/**
 * Creates a new React class that is idempotent and capable of containing other
 * React components. It accepts event listeners and DOM properties that are
 * valid according to `DOMProperty`.
 *
 *  - Event listeners: `onClick`, `onMouseDown`, etc.
 *  - DOM properties: `className`, `name`, `title`, etc.
 *
 * The `style` property functions differently from the DOM API. It accepts an
 * object mapping of style properties to values.
 *
 * @param {boolean} omitClose True if the close tag should be omitted.
 * @param {string} tag Tag name (e.g. `div`).
 * @private
 */
function createDOMComponentClass(omitClose, tag) {
  var Constructor = function(descriptor) {
    this.construct(descriptor);
  };
  Constructor.prototype = new ReactDOMComponent(tag, omitClose);
  Constructor.prototype.constructor = Constructor;
  Constructor.displayName = tag;

  var ConvenienceConstructor = ReactDescriptor.createFactory(Constructor);

  if ("production" !== process.env.NODE_ENV) {
    return ReactDescriptorValidator.createFactory(
      ConvenienceConstructor
    );
  }

  return ConvenienceConstructor;
}

/**
 * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
 * This is also accessible via `React.DOM`.
 *
 * @public
 */
var ReactDOM = mapObject({
  a: false,
  abbr: false,
  address: false,
  area: true,
  article: false,
  aside: false,
  audio: false,
  b: false,
  base: true,
  bdi: false,
  bdo: false,
  big: false,
  blockquote: false,
  body: false,
  br: true,
  button: false,
  canvas: false,
  caption: false,
  cite: false,
  code: false,
  col: true,
  colgroup: false,
  data: false,
  datalist: false,
  dd: false,
  del: false,
  details: false,
  dfn: false,
  div: false,
  dl: false,
  dt: false,
  em: false,
  embed: true,
  fieldset: false,
  figcaption: false,
  figure: false,
  footer: false,
  form: false, // NOTE: Injected, see `ReactDOMForm`.
  h1: false,
  h2: false,
  h3: false,
  h4: false,
  h5: false,
  h6: false,
  head: false,
  header: false,
  hr: true,
  html: false,
  i: false,
  iframe: false,
  img: true,
  input: true,
  ins: false,
  kbd: false,
  keygen: true,
  label: false,
  legend: false,
  li: false,
  link: true,
  main: false,
  map: false,
  mark: false,
  menu: false,
  menuitem: false, // NOTE: Close tag should be omitted, but causes problems.
  meta: true,
  meter: false,
  nav: false,
  noscript: false,
  object: false,
  ol: false,
  optgroup: false,
  option: false,
  output: false,
  p: false,
  param: true,
  pre: false,
  progress: false,
  q: false,
  rp: false,
  rt: false,
  ruby: false,
  s: false,
  samp: false,
  script: false,
  section: false,
  select: false,
  small: false,
  source: true,
  span: false,
  strong: false,
  style: false,
  sub: false,
  summary: false,
  sup: false,
  table: false,
  tbody: false,
  td: false,
  textarea: false, // NOTE: Injected, see `ReactDOMTextarea`.
  tfoot: false,
  th: false,
  thead: false,
  time: false,
  title: false,
  tr: false,
  track: true,
  u: false,
  ul: false,
  'var': false,
  video: false,
  wbr: true,

  // SVG
  circle: false,
  defs: false,
  ellipse: false,
  g: false,
  line: false,
  linearGradient: false,
  mask: false,
  path: false,
  pattern: false,
  polygon: false,
  polyline: false,
  radialGradient: false,
  rect: false,
  stop: false,
  svg: false,
  text: false,
  tspan: false
}, createDOMComponentClass);

var injection = {
  injectComponentClasses: function(componentClasses) {
    mergeInto(ReactDOM, componentClasses);
  }
};

ReactDOM.injection = injection;

module.exports = ReactDOM;

}).call(this,require('_process'))
},{"./ReactDOMComponent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDOMComponent.js","./ReactDescriptor":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDescriptor.js","./ReactDescriptorValidator":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDescriptorValidator.js","./mapObject":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/mapObject.js","./mergeInto":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/mergeInto.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDOMButton.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactDOMButton
 */

"use strict";

var AutoFocusMixin = require("./AutoFocusMixin");
var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
var ReactCompositeComponent = require("./ReactCompositeComponent");
var ReactDOM = require("./ReactDOM");

var keyMirror = require("./keyMirror");

// Store a reference to the <button> `ReactDOMComponent`.
var button = ReactDOM.button;

var mouseListenerNames = keyMirror({
  onClick: true,
  onDoubleClick: true,
  onMouseDown: true,
  onMouseMove: true,
  onMouseUp: true,
  onClickCapture: true,
  onDoubleClickCapture: true,
  onMouseDownCapture: true,
  onMouseMoveCapture: true,
  onMouseUpCapture: true
});

/**
 * Implements a <button> native component that does not receive mouse events
 * when `disabled` is set.
 */
var ReactDOMButton = ReactCompositeComponent.createClass({
  displayName: 'ReactDOMButton',

  mixins: [AutoFocusMixin, ReactBrowserComponentMixin],

  render: function() {
    var props = {};

    // Copy the props; except the mouse listeners if we're disabled
    for (var key in this.props) {
      if (this.props.hasOwnProperty(key) &&
          (!this.props.disabled || !mouseListenerNames[key])) {
        props[key] = this.props[key];
      }
    }

    return button(props, this.props.children);
  }

});

module.exports = ReactDOMButton;

},{"./AutoFocusMixin":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/AutoFocusMixin.js","./ReactBrowserComponentMixin":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactBrowserComponentMixin.js","./ReactCompositeComponent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactCompositeComponent.js","./ReactDOM":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDOM.js","./keyMirror":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/keyMirror.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDOMComponent.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactDOMComponent
 * @typechecks static-only
 */

"use strict";

var CSSPropertyOperations = require("./CSSPropertyOperations");
var DOMProperty = require("./DOMProperty");
var DOMPropertyOperations = require("./DOMPropertyOperations");
var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
var ReactComponent = require("./ReactComponent");
var ReactBrowserEventEmitter = require("./ReactBrowserEventEmitter");
var ReactMount = require("./ReactMount");
var ReactMultiChild = require("./ReactMultiChild");
var ReactPerf = require("./ReactPerf");

var escapeTextForBrowser = require("./escapeTextForBrowser");
var invariant = require("./invariant");
var keyOf = require("./keyOf");
var merge = require("./merge");
var mixInto = require("./mixInto");

var deleteListener = ReactBrowserEventEmitter.deleteListener;
var listenTo = ReactBrowserEventEmitter.listenTo;
var registrationNameModules = ReactBrowserEventEmitter.registrationNameModules;

// For quickly matching children type, to test if can be treated as content.
var CONTENT_TYPES = {'string': true, 'number': true};

var STYLE = keyOf({style: null});

var ELEMENT_NODE_TYPE = 1;

/**
 * @param {?object} props
 */
function assertValidProps(props) {
  if (!props) {
    return;
  }
  // Note the use of `==` which checks for null or undefined.
  ("production" !== process.env.NODE_ENV ? invariant(
    props.children == null || props.dangerouslySetInnerHTML == null,
    'Can only set one of `children` or `props.dangerouslySetInnerHTML`.'
  ) : invariant(props.children == null || props.dangerouslySetInnerHTML == null));
  ("production" !== process.env.NODE_ENV ? invariant(
    props.style == null || typeof props.style === 'object',
    'The `style` prop expects a mapping from style properties to values, ' +
    'not a string.'
  ) : invariant(props.style == null || typeof props.style === 'object'));
}

function putListener(id, registrationName, listener, transaction) {
  var container = ReactMount.findReactContainerForID(id);
  if (container) {
    var doc = container.nodeType === ELEMENT_NODE_TYPE ?
      container.ownerDocument :
      container;
    listenTo(registrationName, doc);
  }
  transaction.getPutListenerQueue().enqueuePutListener(
    id,
    registrationName,
    listener
  );
}


/**
 * @constructor ReactDOMComponent
 * @extends ReactComponent
 * @extends ReactMultiChild
 */
function ReactDOMComponent(tag, omitClose) {
  this._tagOpen = '<' + tag;
  this._tagClose = omitClose ? '' : '</' + tag + '>';
  this.tagName = tag.toUpperCase();
}

ReactDOMComponent.Mixin = {

  /**
   * Generates root tag markup then recurses. This method has side effects and
   * is not idempotent.
   *
   * @internal
   * @param {string} rootID The root DOM ID for this node.
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {number} mountDepth number of components in the owner hierarchy
   * @return {string} The computed markup.
   */
  mountComponent: ReactPerf.measure(
    'ReactDOMComponent',
    'mountComponent',
    function(rootID, transaction, mountDepth) {
      ReactComponent.Mixin.mountComponent.call(
        this,
        rootID,
        transaction,
        mountDepth
      );
      assertValidProps(this.props);
      return (
        this._createOpenTagMarkupAndPutListeners(transaction) +
        this._createContentMarkup(transaction) +
        this._tagClose
      );
    }
  ),

  /**
   * Creates markup for the open tag and all attributes.
   *
   * This method has side effects because events get registered.
   *
   * Iterating over object properties is faster than iterating over arrays.
   * @see http://jsperf.com/obj-vs-arr-iteration
   *
   * @private
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @return {string} Markup of opening tag.
   */
  _createOpenTagMarkupAndPutListeners: function(transaction) {
    var props = this.props;
    var ret = this._tagOpen;

    for (var propKey in props) {
      if (!props.hasOwnProperty(propKey)) {
        continue;
      }
      var propValue = props[propKey];
      if (propValue == null) {
        continue;
      }
      if (registrationNameModules.hasOwnProperty(propKey)) {
        putListener(this._rootNodeID, propKey, propValue, transaction);
      } else {
        if (propKey === STYLE) {
          if (propValue) {
            propValue = props.style = merge(props.style);
          }
          propValue = CSSPropertyOperations.createMarkupForStyles(propValue);
        }
        var markup =
          DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
        if (markup) {
          ret += ' ' + markup;
        }
      }
    }

    // For static pages, no need to put React ID and checksum. Saves lots of
    // bytes.
    if (transaction.renderToStaticMarkup) {
      return ret + '>';
    }

    var markupForID = DOMPropertyOperations.createMarkupForID(this._rootNodeID);
    return ret + ' ' + markupForID + '>';
  },

  /**
   * Creates markup for the content between the tags.
   *
   * @private
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @return {string} Content markup.
   */
  _createContentMarkup: function(transaction) {
    // Intentional use of != to avoid catching zero/false.
    var innerHTML = this.props.dangerouslySetInnerHTML;
    if (innerHTML != null) {
      if (innerHTML.__html != null) {
        return innerHTML.__html;
      }
    } else {
      var contentToUse =
        CONTENT_TYPES[typeof this.props.children] ? this.props.children : null;
      var childrenToUse = contentToUse != null ? null : this.props.children;
      if (contentToUse != null) {
        return escapeTextForBrowser(contentToUse);
      } else if (childrenToUse != null) {
        var mountImages = this.mountChildren(
          childrenToUse,
          transaction
        );
        return mountImages.join('');
      }
    }
    return '';
  },

  receiveComponent: function(nextDescriptor, transaction) {
    if (nextDescriptor === this._descriptor &&
        nextDescriptor._owner != null) {
      // Since descriptors are immutable after the owner is rendered,
      // we can do a cheap identity compare here to determine if this is a
      // superfluous reconcile. It's possible for state to be mutable but such
      // change should trigger an update of the owner which would recreate
      // the descriptor. We explicitly check for the existence of an owner since
      // it's possible for a descriptor created outside a composite to be
      // deeply mutated and reused.
      return;
    }

    ReactComponent.Mixin.receiveComponent.call(
      this,
      nextDescriptor,
      transaction
    );
  },

  /**
   * Updates a native DOM component after it has already been allocated and
   * attached to the DOM. Reconciles the root DOM node, then recurses.
   *
   * @param {ReactReconcileTransaction} transaction
   * @param {ReactDescriptor} prevDescriptor
   * @internal
   * @overridable
   */
  updateComponent: ReactPerf.measure(
    'ReactDOMComponent',
    'updateComponent',
    function(transaction, prevDescriptor) {
      assertValidProps(this._descriptor.props);
      ReactComponent.Mixin.updateComponent.call(
        this,
        transaction,
        prevDescriptor
      );
      this._updateDOMProperties(prevDescriptor.props, transaction);
      this._updateDOMChildren(prevDescriptor.props, transaction);
    }
  ),

  /**
   * Reconciles the properties by detecting differences in property values and
   * updating the DOM as necessary. This function is probably the single most
   * critical path for performance optimization.
   *
   * TODO: Benchmark whether checking for changed values in memory actually
   *       improves performance (especially statically positioned elements).
   * TODO: Benchmark the effects of putting this at the top since 99% of props
   *       do not change for a given reconciliation.
   * TODO: Benchmark areas that can be improved with caching.
   *
   * @private
   * @param {object} lastProps
   * @param {ReactReconcileTransaction} transaction
   */
  _updateDOMProperties: function(lastProps, transaction) {
    var nextProps = this.props;
    var propKey;
    var styleName;
    var styleUpdates;
    for (propKey in lastProps) {
      if (nextProps.hasOwnProperty(propKey) ||
         !lastProps.hasOwnProperty(propKey)) {
        continue;
      }
      if (propKey === STYLE) {
        var lastStyle = lastProps[propKey];
        for (styleName in lastStyle) {
          if (lastStyle.hasOwnProperty(styleName)) {
            styleUpdates = styleUpdates || {};
            styleUpdates[styleName] = '';
          }
        }
      } else if (registrationNameModules.hasOwnProperty(propKey)) {
        deleteListener(this._rootNodeID, propKey);
      } else if (
          DOMProperty.isStandardName[propKey] ||
          DOMProperty.isCustomAttribute(propKey)) {
        ReactComponent.BackendIDOperations.deletePropertyByID(
          this._rootNodeID,
          propKey
        );
      }
    }
    for (propKey in nextProps) {
      var nextProp = nextProps[propKey];
      var lastProp = lastProps[propKey];
      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp) {
        continue;
      }
      if (propKey === STYLE) {
        if (nextProp) {
          nextProp = nextProps.style = merge(nextProp);
        }
        if (lastProp) {
          // Unset styles on `lastProp` but not on `nextProp`.
          for (styleName in lastProp) {
            if (lastProp.hasOwnProperty(styleName) &&
                (!nextProp || !nextProp.hasOwnProperty(styleName))) {
              styleUpdates = styleUpdates || {};
              styleUpdates[styleName] = '';
            }
          }
          // Update styles that changed since `lastProp`.
          for (styleName in nextProp) {
            if (nextProp.hasOwnProperty(styleName) &&
                lastProp[styleName] !== nextProp[styleName]) {
              styleUpdates = styleUpdates || {};
              styleUpdates[styleName] = nextProp[styleName];
            }
          }
        } else {
          // Relies on `updateStylesByID` not mutating `styleUpdates`.
          styleUpdates = nextProp;
        }
      } else if (registrationNameModules.hasOwnProperty(propKey)) {
        putListener(this._rootNodeID, propKey, nextProp, transaction);
      } else if (
          DOMProperty.isStandardName[propKey] ||
          DOMProperty.isCustomAttribute(propKey)) {
        ReactComponent.BackendIDOperations.updatePropertyByID(
          this._rootNodeID,
          propKey,
          nextProp
        );
      }
    }
    if (styleUpdates) {
      ReactComponent.BackendIDOperations.updateStylesByID(
        this._rootNodeID,
        styleUpdates
      );
    }
  },

  /**
   * Reconciles the children with the various properties that affect the
   * children content.
   *
   * @param {object} lastProps
   * @param {ReactReconcileTransaction} transaction
   */
  _updateDOMChildren: function(lastProps, transaction) {
    var nextProps = this.props;

    var lastContent =
      CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
    var nextContent =
      CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;

    var lastHtml =
      lastProps.dangerouslySetInnerHTML &&
      lastProps.dangerouslySetInnerHTML.__html;
    var nextHtml =
      nextProps.dangerouslySetInnerHTML &&
      nextProps.dangerouslySetInnerHTML.__html;

    // Note the use of `!=` which checks for null or undefined.
    var lastChildren = lastContent != null ? null : lastProps.children;
    var nextChildren = nextContent != null ? null : nextProps.children;

    // If we're switching from children to content/html or vice versa, remove
    // the old content
    var lastHasContentOrHtml = lastContent != null || lastHtml != null;
    var nextHasContentOrHtml = nextContent != null || nextHtml != null;
    if (lastChildren != null && nextChildren == null) {
      this.updateChildren(null, transaction);
    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
      this.updateTextContent('');
    }

    if (nextContent != null) {
      if (lastContent !== nextContent) {
        this.updateTextContent('' + nextContent);
      }
    } else if (nextHtml != null) {
      if (lastHtml !== nextHtml) {
        ReactComponent.BackendIDOperations.updateInnerHTMLByID(
          this._rootNodeID,
          nextHtml
        );
      }
    } else if (nextChildren != null) {
      this.updateChildren(nextChildren, transaction);
    }
  },

  /**
   * Destroys all event registrations for this instance. Does not remove from
   * the DOM. That must be done by the parent.
   *
   * @internal
   */
  unmountComponent: function() {
    this.unmountChildren();
    ReactBrowserEventEmitter.deleteAllListeners(this._rootNodeID);
    ReactComponent.Mixin.unmountComponent.call(this);
  }

};

mixInto(ReactDOMComponent, ReactComponent.Mixin);
mixInto(ReactDOMComponent, ReactDOMComponent.Mixin);
mixInto(ReactDOMComponent, ReactMultiChild.Mixin);
mixInto(ReactDOMComponent, ReactBrowserComponentMixin);

module.exports = ReactDOMComponent;

}).call(this,require('_process'))
},{"./CSSPropertyOperations":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/CSSPropertyOperations.js","./DOMProperty":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/DOMProperty.js","./DOMPropertyOperations":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/DOMPropertyOperations.js","./ReactBrowserComponentMixin":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactBrowserComponentMixin.js","./ReactBrowserEventEmitter":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactBrowserEventEmitter.js","./ReactComponent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactComponent.js","./ReactMount":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactMount.js","./ReactMultiChild":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactMultiChild.js","./ReactPerf":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactPerf.js","./escapeTextForBrowser":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/escapeTextForBrowser.js","./invariant":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/invariant.js","./keyOf":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/keyOf.js","./merge":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/merge.js","./mixInto":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/mixInto.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDOMForm.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactDOMForm
 */

"use strict";

var EventConstants = require("./EventConstants");
var LocalEventTrapMixin = require("./LocalEventTrapMixin");
var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
var ReactCompositeComponent = require("./ReactCompositeComponent");
var ReactDOM = require("./ReactDOM");

// Store a reference to the <form> `ReactDOMComponent`.
var form = ReactDOM.form;

/**
 * Since onSubmit doesn't bubble OR capture on the top level in IE8, we need
 * to capture it on the <form> element itself. There are lots of hacks we could
 * do to accomplish this, but the most reliable is to make <form> a
 * composite component and use `componentDidMount` to attach the event handlers.
 */
var ReactDOMForm = ReactCompositeComponent.createClass({
  displayName: 'ReactDOMForm',

  mixins: [ReactBrowserComponentMixin, LocalEventTrapMixin],

  render: function() {
    // TODO: Instead of using `ReactDOM` directly, we should use JSX. However,
    // `jshint` fails to parse JSX so in order for linting to work in the open
    // source repo, we need to just use `ReactDOM.form`.
    return this.transferPropsTo(form(null, this.props.children));
  },

  componentDidMount: function() {
    this.trapBubbledEvent(EventConstants.topLevelTypes.topReset, 'reset');
    this.trapBubbledEvent(EventConstants.topLevelTypes.topSubmit, 'submit');
  }
});

module.exports = ReactDOMForm;

},{"./EventConstants":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/EventConstants.js","./LocalEventTrapMixin":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/LocalEventTrapMixin.js","./ReactBrowserComponentMixin":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactBrowserComponentMixin.js","./ReactCompositeComponent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactCompositeComponent.js","./ReactDOM":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDOM.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDOMIDOperations.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactDOMIDOperations
 * @typechecks static-only
 */

/*jslint evil: true */

"use strict";

var CSSPropertyOperations = require("./CSSPropertyOperations");
var DOMChildrenOperations = require("./DOMChildrenOperations");
var DOMPropertyOperations = require("./DOMPropertyOperations");
var ReactMount = require("./ReactMount");
var ReactPerf = require("./ReactPerf");

var invariant = require("./invariant");
var setInnerHTML = require("./setInnerHTML");

/**
 * Errors for properties that should not be updated with `updatePropertyById()`.
 *
 * @type {object}
 * @private
 */
var INVALID_PROPERTY_ERRORS = {
  dangerouslySetInnerHTML:
    '`dangerouslySetInnerHTML` must be set using `updateInnerHTMLByID()`.',
  style: '`style` must be set using `updateStylesByID()`.'
};

/**
 * Operations used to process updates to DOM nodes. This is made injectable via
 * `ReactComponent.BackendIDOperations`.
 */
var ReactDOMIDOperations = {

  /**
   * Updates a DOM node with new property values. This should only be used to
   * update DOM properties in `DOMProperty`.
   *
   * @param {string} id ID of the node to update.
   * @param {string} name A valid property name, see `DOMProperty`.
   * @param {*} value New value of the property.
   * @internal
   */
  updatePropertyByID: ReactPerf.measure(
    'ReactDOMIDOperations',
    'updatePropertyByID',
    function(id, name, value) {
      var node = ReactMount.getNode(id);
      ("production" !== process.env.NODE_ENV ? invariant(
        !INVALID_PROPERTY_ERRORS.hasOwnProperty(name),
        'updatePropertyByID(...): %s',
        INVALID_PROPERTY_ERRORS[name]
      ) : invariant(!INVALID_PROPERTY_ERRORS.hasOwnProperty(name)));

      // If we're updating to null or undefined, we should remove the property
      // from the DOM node instead of inadvertantly setting to a string. This
      // brings us in line with the same behavior we have on initial render.
      if (value != null) {
        DOMPropertyOperations.setValueForProperty(node, name, value);
      } else {
        DOMPropertyOperations.deleteValueForProperty(node, name);
      }
    }
  ),

  /**
   * Updates a DOM node to remove a property. This should only be used to remove
   * DOM properties in `DOMProperty`.
   *
   * @param {string} id ID of the node to update.
   * @param {string} name A property name to remove, see `DOMProperty`.
   * @internal
   */
  deletePropertyByID: ReactPerf.measure(
    'ReactDOMIDOperations',
    'deletePropertyByID',
    function(id, name, value) {
      var node = ReactMount.getNode(id);
      ("production" !== process.env.NODE_ENV ? invariant(
        !INVALID_PROPERTY_ERRORS.hasOwnProperty(name),
        'updatePropertyByID(...): %s',
        INVALID_PROPERTY_ERRORS[name]
      ) : invariant(!INVALID_PROPERTY_ERRORS.hasOwnProperty(name)));
      DOMPropertyOperations.deleteValueForProperty(node, name, value);
    }
  ),

  /**
   * Updates a DOM node with new style values. If a value is specified as '',
   * the corresponding style property will be unset.
   *
   * @param {string} id ID of the node to update.
   * @param {object} styles Mapping from styles to values.
   * @internal
   */
  updateStylesByID: ReactPerf.measure(
    'ReactDOMIDOperations',
    'updateStylesByID',
    function(id, styles) {
      var node = ReactMount.getNode(id);
      CSSPropertyOperations.setValueForStyles(node, styles);
    }
  ),

  /**
   * Updates a DOM node's innerHTML.
   *
   * @param {string} id ID of the node to update.
   * @param {string} html An HTML string.
   * @internal
   */
  updateInnerHTMLByID: ReactPerf.measure(
    'ReactDOMIDOperations',
    'updateInnerHTMLByID',
    function(id, html) {
      var node = ReactMount.getNode(id);
      setInnerHTML(node, html);
    }
  ),

  /**
   * Updates a DOM node's text content set by `props.content`.
   *
   * @param {string} id ID of the node to update.
   * @param {string} content Text content.
   * @internal
   */
  updateTextContentByID: ReactPerf.measure(
    'ReactDOMIDOperations',
    'updateTextContentByID',
    function(id, content) {
      var node = ReactMount.getNode(id);
      DOMChildrenOperations.updateTextContent(node, content);
    }
  ),

  /**
   * Replaces a DOM node that exists in the document with markup.
   *
   * @param {string} id ID of child to be replaced.
   * @param {string} markup Dangerous markup to inject in place of child.
   * @internal
   * @see {Danger.dangerouslyReplaceNodeWithMarkup}
   */
  dangerouslyReplaceNodeWithMarkupByID: ReactPerf.measure(
    'ReactDOMIDOperations',
    'dangerouslyReplaceNodeWithMarkupByID',
    function(id, markup) {
      var node = ReactMount.getNode(id);
      DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup(node, markup);
    }
  ),

  /**
   * Updates a component's children by processing a series of updates.
   *
   * @param {array<object>} updates List of update configurations.
   * @param {array<string>} markup List of markup strings.
   * @internal
   */
  dangerouslyProcessChildrenUpdates: ReactPerf.measure(
    'ReactDOMIDOperations',
    'dangerouslyProcessChildrenUpdates',
    function(updates, markup) {
      for (var i = 0; i < updates.length; i++) {
        updates[i].parentNode = ReactMount.getNode(updates[i].parentID);
      }
      DOMChildrenOperations.processUpdates(updates, markup);
    }
  )
};

module.exports = ReactDOMIDOperations;

}).call(this,require('_process'))
},{"./CSSPropertyOperations":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/CSSPropertyOperations.js","./DOMChildrenOperations":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/DOMChildrenOperations.js","./DOMPropertyOperations":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/DOMPropertyOperations.js","./ReactMount":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactMount.js","./ReactPerf":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactPerf.js","./invariant":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/invariant.js","./setInnerHTML":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/setInnerHTML.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDOMImg.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactDOMImg
 */

"use strict";

var EventConstants = require("./EventConstants");
var LocalEventTrapMixin = require("./LocalEventTrapMixin");
var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
var ReactCompositeComponent = require("./ReactCompositeComponent");
var ReactDOM = require("./ReactDOM");

// Store a reference to the <img> `ReactDOMComponent`.
var img = ReactDOM.img;

/**
 * Since onLoad doesn't bubble OR capture on the top level in IE8, we need to
 * capture it on the <img> element itself. There are lots of hacks we could do
 * to accomplish this, but the most reliable is to make <img> a composite
 * component and use `componentDidMount` to attach the event handlers.
 */
var ReactDOMImg = ReactCompositeComponent.createClass({
  displayName: 'ReactDOMImg',
  tagName: 'IMG',

  mixins: [ReactBrowserComponentMixin, LocalEventTrapMixin],

  render: function() {
    return img(this.props);
  },

  componentDidMount: function() {
    this.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load');
    this.trapBubbledEvent(EventConstants.topLevelTypes.topError, 'error');
  }
});

module.exports = ReactDOMImg;

},{"./EventConstants":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/EventConstants.js","./LocalEventTrapMixin":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/LocalEventTrapMixin.js","./ReactBrowserComponentMixin":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactBrowserComponentMixin.js","./ReactCompositeComponent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactCompositeComponent.js","./ReactDOM":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDOM.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDOMInput.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactDOMInput
 */

"use strict";

var AutoFocusMixin = require("./AutoFocusMixin");
var DOMPropertyOperations = require("./DOMPropertyOperations");
var LinkedValueUtils = require("./LinkedValueUtils");
var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
var ReactCompositeComponent = require("./ReactCompositeComponent");
var ReactDOM = require("./ReactDOM");
var ReactMount = require("./ReactMount");

var invariant = require("./invariant");
var merge = require("./merge");

// Store a reference to the <input> `ReactDOMComponent`.
var input = ReactDOM.input;

var instancesByReactID = {};

/**
 * Implements an <input> native component that allows setting these optional
 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
 *
 * If `checked` or `value` are not supplied (or null/undefined), user actions
 * that affect the checked state or value will trigger updates to the element.
 *
 * If they are supplied (and not null/undefined), the rendered element will not
 * trigger updates to the element. Instead, the props must change in order for
 * the rendered element to be updated.
 *
 * The rendered element will be initialized as unchecked (or `defaultChecked`)
 * with an empty value (or `defaultValue`).
 *
 * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */
var ReactDOMInput = ReactCompositeComponent.createClass({
  displayName: 'ReactDOMInput',

  mixins: [AutoFocusMixin, LinkedValueUtils.Mixin, ReactBrowserComponentMixin],

  getInitialState: function() {
    var defaultValue = this.props.defaultValue;
    return {
      checked: this.props.defaultChecked || false,
      value: defaultValue != null ? defaultValue : null
    };
  },

  shouldComponentUpdate: function() {
    // Defer any updates to this component during the `onChange` handler.
    return !this._isChanging;
  },

  render: function() {
    // Clone `this.props` so we don't mutate the input.
    var props = merge(this.props);

    props.defaultChecked = null;
    props.defaultValue = null;

    var value = LinkedValueUtils.getValue(this);
    props.value = value != null ? value : this.state.value;

    var checked = LinkedValueUtils.getChecked(this);
    props.checked = checked != null ? checked : this.state.checked;

    props.onChange = this._handleChange;

    return input(props, this.props.children);
  },

  componentDidMount: function() {
    var id = ReactMount.getID(this.getDOMNode());
    instancesByReactID[id] = this;
  },

  componentWillUnmount: function() {
    var rootNode = this.getDOMNode();
    var id = ReactMount.getID(rootNode);
    delete instancesByReactID[id];
  },

  componentDidUpdate: function(prevProps, prevState, prevContext) {
    var rootNode = this.getDOMNode();
    if (this.props.checked != null) {
      DOMPropertyOperations.setValueForProperty(
        rootNode,
        'checked',
        this.props.checked || false
      );
    }

    var value = LinkedValueUtils.getValue(this);
    if (value != null) {
      // Cast `value` to a string to ensure the value is set correctly. While
      // browsers typically do this as necessary, jsdom doesn't.
      DOMPropertyOperations.setValueForProperty(rootNode, 'value', '' + value);
    }
  },

  _handleChange: function(event) {
    var returnValue;
    var onChange = LinkedValueUtils.getOnChange(this);
    if (onChange) {
      this._isChanging = true;
      returnValue = onChange.call(this, event);
      this._isChanging = false;
    }
    this.setState({
      checked: event.target.checked,
      value: event.target.value
    });

    var name = this.props.name;
    if (this.props.type === 'radio' && name != null) {
      var rootNode = this.getDOMNode();
      var queryRoot = rootNode;

      while (queryRoot.parentNode) {
        queryRoot = queryRoot.parentNode;
      }

      // If `rootNode.form` was non-null, then we could try `form.elements`,
      // but that sometimes behaves strangely in IE8. We could also try using
      // `form.getElementsByName`, but that will only return direct children
      // and won't include inputs that use the HTML5 `form=` attribute. Since
      // the input might not even be in a form, let's just use the global
      // `querySelectorAll` to ensure we don't miss anything.
      var group = queryRoot.querySelectorAll(
        'input[name=' + JSON.stringify('' + name) + '][type="radio"]');

      for (var i = 0, groupLen = group.length; i < groupLen; i++) {
        var otherNode = group[i];
        if (otherNode === rootNode ||
            otherNode.form !== rootNode.form) {
          continue;
        }
        var otherID = ReactMount.getID(otherNode);
        ("production" !== process.env.NODE_ENV ? invariant(
          otherID,
          'ReactDOMInput: Mixing React and non-React radio inputs with the ' +
          'same `name` is not supported.'
        ) : invariant(otherID));
        var otherInstance = instancesByReactID[otherID];
        ("production" !== process.env.NODE_ENV ? invariant(
          otherInstance,
          'ReactDOMInput: Unknown radio button ID %s.',
          otherID
        ) : invariant(otherInstance));
        // In some cases, this will actually change the `checked` state value.
        // In other cases, there's no change but this forces a reconcile upon
        // which componentDidUpdate will reset the DOM property to whatever it
        // should be.
        otherInstance.setState({
          checked: false
        });
      }
    }

    return returnValue;
  }

});

module.exports = ReactDOMInput;

}).call(this,require('_process'))
},{"./AutoFocusMixin":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/AutoFocusMixin.js","./DOMPropertyOperations":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/DOMPropertyOperations.js","./LinkedValueUtils":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/LinkedValueUtils.js","./ReactBrowserComponentMixin":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactBrowserComponentMixin.js","./ReactCompositeComponent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactCompositeComponent.js","./ReactDOM":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDOM.js","./ReactMount":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactMount.js","./invariant":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/invariant.js","./merge":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/merge.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDOMOption.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactDOMOption
 */

"use strict";

var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
var ReactCompositeComponent = require("./ReactCompositeComponent");
var ReactDOM = require("./ReactDOM");

var warning = require("./warning");

// Store a reference to the <option> `ReactDOMComponent`.
var option = ReactDOM.option;

/**
 * Implements an <option> native component that warns when `selected` is set.
 */
var ReactDOMOption = ReactCompositeComponent.createClass({
  displayName: 'ReactDOMOption',

  mixins: [ReactBrowserComponentMixin],

  componentWillMount: function() {
    // TODO (yungsters): Remove support for `selected` in <option>.
    if ("production" !== process.env.NODE_ENV) {
      ("production" !== process.env.NODE_ENV ? warning(
        this.props.selected == null,
        'Use the `defaultValue` or `value` props on <select> instead of ' +
        'setting `selected` on <option>.'
      ) : null);
    }
  },

  render: function() {
    return option(this.props, this.props.children);
  }

});

module.exports = ReactDOMOption;

}).call(this,require('_process'))
},{"./ReactBrowserComponentMixin":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactBrowserComponentMixin.js","./ReactCompositeComponent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactCompositeComponent.js","./ReactDOM":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDOM.js","./warning":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/warning.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDOMSelect.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactDOMSelect
 */

"use strict";

var AutoFocusMixin = require("./AutoFocusMixin");
var LinkedValueUtils = require("./LinkedValueUtils");
var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
var ReactCompositeComponent = require("./ReactCompositeComponent");
var ReactDOM = require("./ReactDOM");

var merge = require("./merge");

// Store a reference to the <select> `ReactDOMComponent`.
var select = ReactDOM.select;

/**
 * Validation function for `value` and `defaultValue`.
 * @private
 */
function selectValueType(props, propName, componentName) {
  if (props[propName] == null) {
    return;
  }
  if (props.multiple) {
    if (!Array.isArray(props[propName])) {
      return new Error(
        ("The `" + propName + "` prop supplied to <select> must be an array if ") +
        ("`multiple` is true.")
      );
    }
  } else {
    if (Array.isArray(props[propName])) {
      return new Error(
        ("The `" + propName + "` prop supplied to <select> must be a scalar ") +
        ("value if `multiple` is false.")
      );
    }
  }
}

/**
 * If `value` is supplied, updates <option> elements on mount and update.
 * @param {ReactComponent} component Instance of ReactDOMSelect
 * @param {?*} propValue For uncontrolled components, null/undefined. For
 * controlled components, a string (or with `multiple`, a list of strings).
 * @private
 */
function updateOptions(component, propValue) {
  var multiple = component.props.multiple;
  var value = propValue != null ? propValue : component.state.value;
  var options = component.getDOMNode().options;
  var selectedValue, i, l;
  if (multiple) {
    selectedValue = {};
    for (i = 0, l = value.length; i < l; ++i) {
      selectedValue['' + value[i]] = true;
    }
  } else {
    selectedValue = '' + value;
  }
  for (i = 0, l = options.length; i < l; i++) {
    var selected = multiple ?
      selectedValue.hasOwnProperty(options[i].value) :
      options[i].value === selectedValue;

    if (selected !== options[i].selected) {
      options[i].selected = selected;
    }
  }
}

/**
 * Implements a <select> native component that allows optionally setting the
 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
 * string. If `multiple` is true, the prop must be an array of strings.
 *
 * If `value` is not supplied (or null/undefined), user actions that change the
 * selected option will trigger updates to the rendered options.
 *
 * If it is supplied (and not null/undefined), the rendered options will not
 * update in response to user actions. Instead, the `value` prop must change in
 * order for the rendered options to update.
 *
 * If `defaultValue` is provided, any options with the supplied values will be
 * selected.
 */
var ReactDOMSelect = ReactCompositeComponent.createClass({
  displayName: 'ReactDOMSelect',

  mixins: [AutoFocusMixin, LinkedValueUtils.Mixin, ReactBrowserComponentMixin],

  propTypes: {
    defaultValue: selectValueType,
    value: selectValueType
  },

  getInitialState: function() {
    return {value: this.props.defaultValue || (this.props.multiple ? [] : '')};
  },

  componentWillReceiveProps: function(nextProps) {
    if (!this.props.multiple && nextProps.multiple) {
      this.setState({value: [this.state.value]});
    } else if (this.props.multiple && !nextProps.multiple) {
      this.setState({value: this.state.value[0]});
    }
  },

  shouldComponentUpdate: function() {
    // Defer any updates to this component during the `onChange` handler.
    return !this._isChanging;
  },

  render: function() {
    // Clone `this.props` so we don't mutate the input.
    var props = merge(this.props);

    props.onChange = this._handleChange;
    props.value = null;

    return select(props, this.props.children);
  },

  componentDidMount: function() {
    updateOptions(this, LinkedValueUtils.getValue(this));
  },

  componentDidUpdate: function(prevProps) {
    var value = LinkedValueUtils.getValue(this);
    var prevMultiple = !!prevProps.multiple;
    var multiple = !!this.props.multiple;
    if (value != null || prevMultiple !== multiple) {
      updateOptions(this, value);
    }
  },

  _handleChange: function(event) {
    var returnValue;
    var onChange = LinkedValueUtils.getOnChange(this);
    if (onChange) {
      this._isChanging = true;
      returnValue = onChange.call(this, event);
      this._isChanging = false;
    }

    var selectedValue;
    if (this.props.multiple) {
      selectedValue = [];
      var options = event.target.options;
      for (var i = 0, l = options.length; i < l; i++) {
        if (options[i].selected) {
          selectedValue.push(options[i].value);
        }
      }
    } else {
      selectedValue = event.target.value;
    }

    this.setState({value: selectedValue});
    return returnValue;
  }

});

module.exports = ReactDOMSelect;

},{"./AutoFocusMixin":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/AutoFocusMixin.js","./LinkedValueUtils":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/LinkedValueUtils.js","./ReactBrowserComponentMixin":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactBrowserComponentMixin.js","./ReactCompositeComponent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactCompositeComponent.js","./ReactDOM":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDOM.js","./merge":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/merge.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDOMSelection.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactDOMSelection
 */

"use strict";

var ExecutionEnvironment = require("./ExecutionEnvironment");

var getNodeForCharacterOffset = require("./getNodeForCharacterOffset");
var getTextContentAccessor = require("./getTextContentAccessor");

/**
 * While `isCollapsed` is available on the Selection object and `collapsed`
 * is available on the Range object, IE11 sometimes gets them wrong.
 * If the anchor/focus nodes and offsets are the same, the range is collapsed.
 */
function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
  return anchorNode === focusNode && anchorOffset === focusOffset;
}

/**
 * Get the appropriate anchor and focus node/offset pairs for IE.
 *
 * The catch here is that IE's selection API doesn't provide information
 * about whether the selection is forward or backward, so we have to
 * behave as though it's always forward.
 *
 * IE text differs from modern selection in that it behaves as though
 * block elements end with a new line. This means character offsets will
 * differ between the two APIs.
 *
 * @param {DOMElement} node
 * @return {object}
 */
function getIEOffsets(node) {
  var selection = document.selection;
  var selectedRange = selection.createRange();
  var selectedLength = selectedRange.text.length;

  // Duplicate selection so we can move range without breaking user selection.
  var fromStart = selectedRange.duplicate();
  fromStart.moveToElementText(node);
  fromStart.setEndPoint('EndToStart', selectedRange);

  var startOffset = fromStart.text.length;
  var endOffset = startOffset + selectedLength;

  return {
    start: startOffset,
    end: endOffset
  };
}

/**
 * @param {DOMElement} node
 * @return {?object}
 */
function getModernOffsets(node) {
  var selection = window.getSelection();

  if (selection.rangeCount === 0) {
    return null;
  }

  var anchorNode = selection.anchorNode;
  var anchorOffset = selection.anchorOffset;
  var focusNode = selection.focusNode;
  var focusOffset = selection.focusOffset;

  var currentRange = selection.getRangeAt(0);

  // If the node and offset values are the same, the selection is collapsed.
  // `Selection.isCollapsed` is available natively, but IE sometimes gets
  // this value wrong.
  var isSelectionCollapsed = isCollapsed(
    selection.anchorNode,
    selection.anchorOffset,
    selection.focusNode,
    selection.focusOffset
  );

  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;

  var tempRange = currentRange.cloneRange();
  tempRange.selectNodeContents(node);
  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);

  var isTempRangeCollapsed = isCollapsed(
    tempRange.startContainer,
    tempRange.startOffset,
    tempRange.endContainer,
    tempRange.endOffset
  );

  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
  var end = start + rangeLength;

  // Detect whether the selection is backward.
  var detectionRange = document.createRange();
  detectionRange.setStart(anchorNode, anchorOffset);
  detectionRange.setEnd(focusNode, focusOffset);
  var isBackward = detectionRange.collapsed;
  detectionRange.detach();

  return {
    start: isBackward ? end : start,
    end: isBackward ? start : end
  };
}

/**
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */
function setIEOffsets(node, offsets) {
  var range = document.selection.createRange().duplicate();
  var start, end;

  if (typeof offsets.end === 'undefined') {
    start = offsets.start;
    end = start;
  } else if (offsets.start > offsets.end) {
    start = offsets.end;
    end = offsets.start;
  } else {
    start = offsets.start;
    end = offsets.end;
  }

  range.moveToElementText(node);
  range.moveStart('character', start);
  range.setEndPoint('EndToStart', range);
  range.moveEnd('character', end - start);
  range.select();
}

/**
 * In modern non-IE browsers, we can support both forward and backward
 * selections.
 *
 * Note: IE10+ supports the Selection object, but it does not support
 * the `extend` method, which means that even in modern IE, it's not possible
 * to programatically create a backward selection. Thus, for all IE
 * versions, we use the old IE API to create our selections.
 *
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */
function setModernOffsets(node, offsets) {
  var selection = window.getSelection();

  var length = node[getTextContentAccessor()].length;
  var start = Math.min(offsets.start, length);
  var end = typeof offsets.end === 'undefined' ?
            start : Math.min(offsets.end, length);

  // IE 11 uses modern selection, but doesn't support the extend method.
  // Flip backward selections, so we can set with a single range.
  if (!selection.extend && start > end) {
    var temp = end;
    end = start;
    start = temp;
  }

  var startMarker = getNodeForCharacterOffset(node, start);
  var endMarker = getNodeForCharacterOffset(node, end);

  if (startMarker && endMarker) {
    var range = document.createRange();
    range.setStart(startMarker.node, startMarker.offset);
    selection.removeAllRanges();

    if (start > end) {
      selection.addRange(range);
      selection.extend(endMarker.node, endMarker.offset);
    } else {
      range.setEnd(endMarker.node, endMarker.offset);
      selection.addRange(range);
    }

    range.detach();
  }
}

var useIEOffsets = ExecutionEnvironment.canUseDOM && document.selection;

var ReactDOMSelection = {
  /**
   * @param {DOMElement} node
   */
  getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,

  /**
   * @param {DOMElement|DOMTextNode} node
   * @param {object} offsets
   */
  setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
};

module.exports = ReactDOMSelection;

},{"./ExecutionEnvironment":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ExecutionEnvironment.js","./getNodeForCharacterOffset":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/getNodeForCharacterOffset.js","./getTextContentAccessor":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/getTextContentAccessor.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDOMTextarea.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactDOMTextarea
 */

"use strict";

var AutoFocusMixin = require("./AutoFocusMixin");
var DOMPropertyOperations = require("./DOMPropertyOperations");
var LinkedValueUtils = require("./LinkedValueUtils");
var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
var ReactCompositeComponent = require("./ReactCompositeComponent");
var ReactDOM = require("./ReactDOM");

var invariant = require("./invariant");
var merge = require("./merge");

var warning = require("./warning");

// Store a reference to the <textarea> `ReactDOMComponent`.
var textarea = ReactDOM.textarea;

/**
 * Implements a <textarea> native component that allows setting `value`, and
 * `defaultValue`. This differs from the traditional DOM API because value is
 * usually set as PCDATA children.
 *
 * If `value` is not supplied (or null/undefined), user actions that affect the
 * value will trigger updates to the element.
 *
 * If `value` is supplied (and not null/undefined), the rendered element will
 * not trigger updates to the element. Instead, the `value` prop must change in
 * order for the rendered element to be updated.
 *
 * The rendered element will be initialized with an empty value, the prop
 * `defaultValue` if specified, or the children content (deprecated).
 */
var ReactDOMTextarea = ReactCompositeComponent.createClass({
  displayName: 'ReactDOMTextarea',

  mixins: [AutoFocusMixin, LinkedValueUtils.Mixin, ReactBrowserComponentMixin],

  getInitialState: function() {
    var defaultValue = this.props.defaultValue;
    // TODO (yungsters): Remove support for children content in <textarea>.
    var children = this.props.children;
    if (children != null) {
      if ("production" !== process.env.NODE_ENV) {
        ("production" !== process.env.NODE_ENV ? warning(
          false,
          'Use the `defaultValue` or `value` props instead of setting ' +
          'children on <textarea>.'
        ) : null);
      }
      ("production" !== process.env.NODE_ENV ? invariant(
        defaultValue == null,
        'If you supply `defaultValue` on a <textarea>, do not pass children.'
      ) : invariant(defaultValue == null));
      if (Array.isArray(children)) {
        ("production" !== process.env.NODE_ENV ? invariant(
          children.length <= 1,
          '<textarea> can only have at most one child.'
        ) : invariant(children.length <= 1));
        children = children[0];
      }

      defaultValue = '' + children;
    }
    if (defaultValue == null) {
      defaultValue = '';
    }
    var value = LinkedValueUtils.getValue(this);
    return {
      // We save the initial value so that `ReactDOMComponent` doesn't update
      // `textContent` (unnecessary since we update value).
      // The initial value can be a boolean or object so that's why it's
      // forced to be a string.
      initialValue: '' + (value != null ? value : defaultValue)
    };
  },

  shouldComponentUpdate: function() {
    // Defer any updates to this component during the `onChange` handler.
    return !this._isChanging;
  },

  render: function() {
    // Clone `this.props` so we don't mutate the input.
    var props = merge(this.props);

    ("production" !== process.env.NODE_ENV ? invariant(
      props.dangerouslySetInnerHTML == null,
      '`dangerouslySetInnerHTML` does not make sense on <textarea>.'
    ) : invariant(props.dangerouslySetInnerHTML == null));

    props.defaultValue = null;
    props.value = null;
    props.onChange = this._handleChange;

    // Always set children to the same thing. In IE9, the selection range will
    // get reset if `textContent` is mutated.
    return textarea(props, this.state.initialValue);
  },

  componentDidUpdate: function(prevProps, prevState, prevContext) {
    var value = LinkedValueUtils.getValue(this);
    if (value != null) {
      var rootNode = this.getDOMNode();
      // Cast `value` to a string to ensure the value is set correctly. While
      // browsers typically do this as necessary, jsdom doesn't.
      DOMPropertyOperations.setValueForProperty(rootNode, 'value', '' + value);
    }
  },

  _handleChange: function(event) {
    var returnValue;
    var onChange = LinkedValueUtils.getOnChange(this);
    if (onChange) {
      this._isChanging = true;
      returnValue = onChange.call(this, event);
      this._isChanging = false;
    }
    this.setState({value: event.target.value});
    return returnValue;
  }

});

module.exports = ReactDOMTextarea;

}).call(this,require('_process'))
},{"./AutoFocusMixin":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/AutoFocusMixin.js","./DOMPropertyOperations":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/DOMPropertyOperations.js","./LinkedValueUtils":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/LinkedValueUtils.js","./ReactBrowserComponentMixin":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactBrowserComponentMixin.js","./ReactCompositeComponent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactCompositeComponent.js","./ReactDOM":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDOM.js","./invariant":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/invariant.js","./merge":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/merge.js","./warning":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/warning.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDefaultBatchingStrategy.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactDefaultBatchingStrategy
 */

"use strict";

var ReactUpdates = require("./ReactUpdates");
var Transaction = require("./Transaction");

var emptyFunction = require("./emptyFunction");
var mixInto = require("./mixInto");

var RESET_BATCHED_UPDATES = {
  initialize: emptyFunction,
  close: function() {
    ReactDefaultBatchingStrategy.isBatchingUpdates = false;
  }
};

var FLUSH_BATCHED_UPDATES = {
  initialize: emptyFunction,
  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
};

var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];

function ReactDefaultBatchingStrategyTransaction() {
  this.reinitializeTransaction();
}

mixInto(ReactDefaultBatchingStrategyTransaction, Transaction.Mixin);
mixInto(ReactDefaultBatchingStrategyTransaction, {
  getTransactionWrappers: function() {
    return TRANSACTION_WRAPPERS;
  }
});

var transaction = new ReactDefaultBatchingStrategyTransaction();

var ReactDefaultBatchingStrategy = {
  isBatchingUpdates: false,

  /**
   * Call the provided function in a context within which calls to `setState`
   * and friends are batched such that components aren't updated unnecessarily.
   */
  batchedUpdates: function(callback, a, b) {
    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;

    ReactDefaultBatchingStrategy.isBatchingUpdates = true;

    // The code is written this way to avoid extra allocations
    if (alreadyBatchingUpdates) {
      callback(a, b);
    } else {
      transaction.perform(callback, null, a, b);
    }
  }
};

module.exports = ReactDefaultBatchingStrategy;

},{"./ReactUpdates":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactUpdates.js","./Transaction":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/Transaction.js","./emptyFunction":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/emptyFunction.js","./mixInto":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/mixInto.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDefaultInjection.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactDefaultInjection
 */

"use strict";

var BeforeInputEventPlugin = require("./BeforeInputEventPlugin");
var ChangeEventPlugin = require("./ChangeEventPlugin");
var ClientReactRootIndex = require("./ClientReactRootIndex");
var CompositionEventPlugin = require("./CompositionEventPlugin");
var DefaultEventPluginOrder = require("./DefaultEventPluginOrder");
var EnterLeaveEventPlugin = require("./EnterLeaveEventPlugin");
var ExecutionEnvironment = require("./ExecutionEnvironment");
var HTMLDOMPropertyConfig = require("./HTMLDOMPropertyConfig");
var MobileSafariClickEventPlugin = require("./MobileSafariClickEventPlugin");
var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
var ReactComponentBrowserEnvironment =
  require("./ReactComponentBrowserEnvironment");
var ReactDefaultBatchingStrategy = require("./ReactDefaultBatchingStrategy");
var ReactDOM = require("./ReactDOM");
var ReactDOMButton = require("./ReactDOMButton");
var ReactDOMForm = require("./ReactDOMForm");
var ReactDOMImg = require("./ReactDOMImg");
var ReactDOMInput = require("./ReactDOMInput");
var ReactDOMOption = require("./ReactDOMOption");
var ReactDOMSelect = require("./ReactDOMSelect");
var ReactDOMTextarea = require("./ReactDOMTextarea");
var ReactEventListener = require("./ReactEventListener");
var ReactInjection = require("./ReactInjection");
var ReactInstanceHandles = require("./ReactInstanceHandles");
var ReactMount = require("./ReactMount");
var SelectEventPlugin = require("./SelectEventPlugin");
var ServerReactRootIndex = require("./ServerReactRootIndex");
var SimpleEventPlugin = require("./SimpleEventPlugin");
var SVGDOMPropertyConfig = require("./SVGDOMPropertyConfig");

var createFullPageComponent = require("./createFullPageComponent");

function inject() {
  ReactInjection.EventEmitter.injectReactEventListener(
    ReactEventListener
  );

  /**
   * Inject modules for resolving DOM hierarchy and plugin ordering.
   */
  ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
  ReactInjection.EventPluginHub.injectInstanceHandle(ReactInstanceHandles);
  ReactInjection.EventPluginHub.injectMount(ReactMount);

  /**
   * Some important event plugins included by default (without having to require
   * them).
   */
  ReactInjection.EventPluginHub.injectEventPluginsByName({
    SimpleEventPlugin: SimpleEventPlugin,
    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
    ChangeEventPlugin: ChangeEventPlugin,
    CompositionEventPlugin: CompositionEventPlugin,
    MobileSafariClickEventPlugin: MobileSafariClickEventPlugin,
    SelectEventPlugin: SelectEventPlugin,
    BeforeInputEventPlugin: BeforeInputEventPlugin
  });

  ReactInjection.DOM.injectComponentClasses({
    button: ReactDOMButton,
    form: ReactDOMForm,
    img: ReactDOMImg,
    input: ReactDOMInput,
    option: ReactDOMOption,
    select: ReactDOMSelect,
    textarea: ReactDOMTextarea,

    html: createFullPageComponent(ReactDOM.html),
    head: createFullPageComponent(ReactDOM.head),
    body: createFullPageComponent(ReactDOM.body)
  });

  // This needs to happen after createFullPageComponent() otherwise the mixin
  // gets double injected.
  ReactInjection.CompositeComponent.injectMixin(ReactBrowserComponentMixin);

  ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
  ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);

  ReactInjection.EmptyComponent.injectEmptyComponent(ReactDOM.noscript);

  ReactInjection.Updates.injectReconcileTransaction(
    ReactComponentBrowserEnvironment.ReactReconcileTransaction
  );
  ReactInjection.Updates.injectBatchingStrategy(
    ReactDefaultBatchingStrategy
  );

  ReactInjection.RootIndex.injectCreateReactRootIndex(
    ExecutionEnvironment.canUseDOM ?
      ClientReactRootIndex.createReactRootIndex :
      ServerReactRootIndex.createReactRootIndex
  );

  ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);

  if ("production" !== process.env.NODE_ENV) {
    var url = (ExecutionEnvironment.canUseDOM && window.location.href) || '';
    if ((/[?&]react_perf\b/).test(url)) {
      var ReactDefaultPerf = require("./ReactDefaultPerf");
      ReactDefaultPerf.start();
    }
  }
}

module.exports = {
  inject: inject
};

}).call(this,require('_process'))
},{"./BeforeInputEventPlugin":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/BeforeInputEventPlugin.js","./ChangeEventPlugin":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ChangeEventPlugin.js","./ClientReactRootIndex":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ClientReactRootIndex.js","./CompositionEventPlugin":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/CompositionEventPlugin.js","./DefaultEventPluginOrder":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/DefaultEventPluginOrder.js","./EnterLeaveEventPlugin":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/EnterLeaveEventPlugin.js","./ExecutionEnvironment":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ExecutionEnvironment.js","./HTMLDOMPropertyConfig":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/HTMLDOMPropertyConfig.js","./MobileSafariClickEventPlugin":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/MobileSafariClickEventPlugin.js","./ReactBrowserComponentMixin":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactBrowserComponentMixin.js","./ReactComponentBrowserEnvironment":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactComponentBrowserEnvironment.js","./ReactDOM":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDOM.js","./ReactDOMButton":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDOMButton.js","./ReactDOMForm":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDOMForm.js","./ReactDOMImg":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDOMImg.js","./ReactDOMInput":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDOMInput.js","./ReactDOMOption":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDOMOption.js","./ReactDOMSelect":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDOMSelect.js","./ReactDOMTextarea":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDOMTextarea.js","./ReactDefaultBatchingStrategy":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDefaultBatchingStrategy.js","./ReactDefaultPerf":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDefaultPerf.js","./ReactEventListener":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactEventListener.js","./ReactInjection":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactInjection.js","./ReactInstanceHandles":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactInstanceHandles.js","./ReactMount":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactMount.js","./SVGDOMPropertyConfig":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/SVGDOMPropertyConfig.js","./SelectEventPlugin":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/SelectEventPlugin.js","./ServerReactRootIndex":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ServerReactRootIndex.js","./SimpleEventPlugin":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/SimpleEventPlugin.js","./createFullPageComponent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/createFullPageComponent.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDefaultPerf.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactDefaultPerf
 * @typechecks static-only
 */

"use strict";

var DOMProperty = require("./DOMProperty");
var ReactDefaultPerfAnalysis = require("./ReactDefaultPerfAnalysis");
var ReactMount = require("./ReactMount");
var ReactPerf = require("./ReactPerf");

var performanceNow = require("./performanceNow");

function roundFloat(val) {
  return Math.floor(val * 100) / 100;
}

function addValue(obj, key, val) {
  obj[key] = (obj[key] || 0) + val;
}

var ReactDefaultPerf = {
  _allMeasurements: [], // last item in the list is the current one
  _mountStack: [0],
  _injected: false,

  start: function() {
    if (!ReactDefaultPerf._injected) {
      ReactPerf.injection.injectMeasure(ReactDefaultPerf.measure);
    }

    ReactDefaultPerf._allMeasurements.length = 0;
    ReactPerf.enableMeasure = true;
  },

  stop: function() {
    ReactPerf.enableMeasure = false;
  },

  getLastMeasurements: function() {
    return ReactDefaultPerf._allMeasurements;
  },

  printExclusive: function(measurements) {
    measurements = measurements || ReactDefaultPerf._allMeasurements;
    var summary = ReactDefaultPerfAnalysis.getExclusiveSummary(measurements);
    console.table(summary.map(function(item) {
      return {
        'Component class name': item.componentName,
        'Total inclusive time (ms)': roundFloat(item.inclusive),
        'Exclusive mount time (ms)': roundFloat(item.exclusive),
        'Exclusive render time (ms)': roundFloat(item.render),
        'Mount time per instance (ms)': roundFloat(item.exclusive / item.count),
        'Render time per instance (ms)': roundFloat(item.render / item.count),
        'Instances': item.count
      };
    }));
    // TODO: ReactDefaultPerfAnalysis.getTotalTime() does not return the correct
    // number.
  },

  printInclusive: function(measurements) {
    measurements = measurements || ReactDefaultPerf._allMeasurements;
    var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements);
    console.table(summary.map(function(item) {
      return {
        'Owner > component': item.componentName,
        'Inclusive time (ms)': roundFloat(item.time),
        'Instances': item.count
      };
    }));
    console.log(
      'Total time:',
      ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms'
    );
  },

  printWasted: function(measurements) {
    measurements = measurements || ReactDefaultPerf._allMeasurements;
    var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(
      measurements,
      true
    );
    console.table(summary.map(function(item) {
      return {
        'Owner > component': item.componentName,
        'Wasted time (ms)': item.time,
        'Instances': item.count
      };
    }));
    console.log(
      'Total time:',
      ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms'
    );
  },

  printDOM: function(measurements) {
    measurements = measurements || ReactDefaultPerf._allMeasurements;
    var summary = ReactDefaultPerfAnalysis.getDOMSummary(measurements);
    console.table(summary.map(function(item) {
      var result = {};
      result[DOMProperty.ID_ATTRIBUTE_NAME] = item.id;
      result['type'] = item.type;
      result['args'] = JSON.stringify(item.args);
      return result;
    }));
    console.log(
      'Total time:',
      ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms'
    );
  },

  _recordWrite: function(id, fnName, totalTime, args) {
    // TODO: totalTime isn't that useful since it doesn't count paints/reflows
    var writes =
      ReactDefaultPerf
        ._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1]
        .writes;
    writes[id] = writes[id] || [];
    writes[id].push({
      type: fnName,
      time: totalTime,
      args: args
    });
  },

  measure: function(moduleName, fnName, func) {
    return function() {var args=Array.prototype.slice.call(arguments,0);
      var totalTime;
      var rv;
      var start;

      if (fnName === '_renderNewRootComponent' ||
          fnName === 'flushBatchedUpdates') {
        // A "measurement" is a set of metrics recorded for each flush. We want
        // to group the metrics for a given flush together so we can look at the
        // components that rendered and the DOM operations that actually
        // happened to determine the amount of "wasted work" performed.
        ReactDefaultPerf._allMeasurements.push({
          exclusive: {},
          inclusive: {},
          render: {},
          counts: {},
          writes: {},
          displayNames: {},
          totalTime: 0
        });
        start = performanceNow();
        rv = func.apply(this, args);
        ReactDefaultPerf._allMeasurements[
          ReactDefaultPerf._allMeasurements.length - 1
        ].totalTime = performanceNow() - start;
        return rv;
      } else if (moduleName === 'ReactDOMIDOperations' ||
        moduleName === 'ReactComponentBrowserEnvironment') {
        start = performanceNow();
        rv = func.apply(this, args);
        totalTime = performanceNow() - start;

        if (fnName === 'mountImageIntoNode') {
          var mountID = ReactMount.getID(args[1]);
          ReactDefaultPerf._recordWrite(mountID, fnName, totalTime, args[0]);
        } else if (fnName === 'dangerouslyProcessChildrenUpdates') {
          // special format
          args[0].forEach(function(update) {
            var writeArgs = {};
            if (update.fromIndex !== null) {
              writeArgs.fromIndex = update.fromIndex;
            }
            if (update.toIndex !== null) {
              writeArgs.toIndex = update.toIndex;
            }
            if (update.textContent !== null) {
              writeArgs.textContent = update.textContent;
            }
            if (update.markupIndex !== null) {
              writeArgs.markup = args[1][update.markupIndex];
            }
            ReactDefaultPerf._recordWrite(
              update.parentID,
              update.type,
              totalTime,
              writeArgs
            );
          });
        } else {
          // basic format
          ReactDefaultPerf._recordWrite(
            args[0],
            fnName,
            totalTime,
            Array.prototype.slice.call(args, 1)
          );
        }
        return rv;
      } else if (moduleName === 'ReactCompositeComponent' && (
        fnName === 'mountComponent' ||
        fnName === 'updateComponent' || // TODO: receiveComponent()?
        fnName === '_renderValidatedComponent')) {

        var rootNodeID = fnName === 'mountComponent' ?
          args[0] :
          this._rootNodeID;
        var isRender = fnName === '_renderValidatedComponent';
        var isMount = fnName === 'mountComponent';

        var mountStack = ReactDefaultPerf._mountStack;
        var entry = ReactDefaultPerf._allMeasurements[
          ReactDefaultPerf._allMeasurements.length - 1
        ];

        if (isRender) {
          addValue(entry.counts, rootNodeID, 1);
        } else if (isMount) {
          mountStack.push(0);
        }

        start = performanceNow();
        rv = func.apply(this, args);
        totalTime = performanceNow() - start;

        if (isRender) {
          addValue(entry.render, rootNodeID, totalTime);
        } else if (isMount) {
          var subMountTime = mountStack.pop();
          mountStack[mountStack.length - 1] += totalTime;
          addValue(entry.exclusive, rootNodeID, totalTime - subMountTime);
          addValue(entry.inclusive, rootNodeID, totalTime);
        } else {
          addValue(entry.inclusive, rootNodeID, totalTime);
        }

        entry.displayNames[rootNodeID] = {
          current: this.constructor.displayName,
          owner: this._owner ? this._owner.constructor.displayName : '<root>'
        };

        return rv;
      } else {
        return func.apply(this, args);
      }
    };
  }
};

module.exports = ReactDefaultPerf;

},{"./DOMProperty":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/DOMProperty.js","./ReactDefaultPerfAnalysis":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDefaultPerfAnalysis.js","./ReactMount":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactMount.js","./ReactPerf":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactPerf.js","./performanceNow":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/performanceNow.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDefaultPerfAnalysis.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactDefaultPerfAnalysis
 */

var merge = require("./merge");

// Don't try to save users less than 1.2ms (a number I made up)
var DONT_CARE_THRESHOLD = 1.2;
var DOM_OPERATION_TYPES = {
  'mountImageIntoNode': 'set innerHTML',
  INSERT_MARKUP: 'set innerHTML',
  MOVE_EXISTING: 'move',
  REMOVE_NODE: 'remove',
  TEXT_CONTENT: 'set textContent',
  'updatePropertyByID': 'update attribute',
  'deletePropertyByID': 'delete attribute',
  'updateStylesByID': 'update styles',
  'updateInnerHTMLByID': 'set innerHTML',
  'dangerouslyReplaceNodeWithMarkupByID': 'replace'
};

function getTotalTime(measurements) {
  // TODO: return number of DOM ops? could be misleading.
  // TODO: measure dropped frames after reconcile?
  // TODO: log total time of each reconcile and the top-level component
  // class that triggered it.
  var totalTime = 0;
  for (var i = 0; i < measurements.length; i++) {
    var measurement = measurements[i];
    totalTime += measurement.totalTime;
  }
  return totalTime;
}

function getDOMSummary(measurements) {
  var items = [];
  for (var i = 0; i < measurements.length; i++) {
    var measurement = measurements[i];
    var id;

    for (id in measurement.writes) {
      measurement.writes[id].forEach(function(write) {
        items.push({
          id: id,
          type: DOM_OPERATION_TYPES[write.type] || write.type,
          args: write.args
        });
      });
    }
  }
  return items;
}

function getExclusiveSummary(measurements) {
  var candidates = {};
  var displayName;

  for (var i = 0; i < measurements.length; i++) {
    var measurement = measurements[i];
    var allIDs = merge(measurement.exclusive, measurement.inclusive);

    for (var id in allIDs) {
      displayName = measurement.displayNames[id].current;

      candidates[displayName] = candidates[displayName] || {
        componentName: displayName,
        inclusive: 0,
        exclusive: 0,
        render: 0,
        count: 0
      };
      if (measurement.render[id]) {
        candidates[displayName].render += measurement.render[id];
      }
      if (measurement.exclusive[id]) {
        candidates[displayName].exclusive += measurement.exclusive[id];
      }
      if (measurement.inclusive[id]) {
        candidates[displayName].inclusive += measurement.inclusive[id];
      }
      if (measurement.counts[id]) {
        candidates[displayName].count += measurement.counts[id];
      }
    }
  }

  // Now make a sorted array with the results.
  var arr = [];
  for (displayName in candidates) {
    if (candidates[displayName].exclusive >= DONT_CARE_THRESHOLD) {
      arr.push(candidates[displayName]);
    }
  }

  arr.sort(function(a, b) {
    return b.exclusive - a.exclusive;
  });

  return arr;
}

function getInclusiveSummary(measurements, onlyClean) {
  var candidates = {};
  var inclusiveKey;

  for (var i = 0; i < measurements.length; i++) {
    var measurement = measurements[i];
    var allIDs = merge(measurement.exclusive, measurement.inclusive);
    var cleanComponents;

    if (onlyClean) {
      cleanComponents = getUnchangedComponents(measurement);
    }

    for (var id in allIDs) {
      if (onlyClean && !cleanComponents[id]) {
        continue;
      }

      var displayName = measurement.displayNames[id];

      // Inclusive time is not useful for many components without knowing where
      // they are instantiated. So we aggregate inclusive time with both the
      // owner and current displayName as the key.
      inclusiveKey = displayName.owner + ' > ' + displayName.current;

      candidates[inclusiveKey] = candidates[inclusiveKey] || {
        componentName: inclusiveKey,
        time: 0,
        count: 0
      };

      if (measurement.inclusive[id]) {
        candidates[inclusiveKey].time += measurement.inclusive[id];
      }
      if (measurement.counts[id]) {
        candidates[inclusiveKey].count += measurement.counts[id];
      }
    }
  }

  // Now make a sorted array with the results.
  var arr = [];
  for (inclusiveKey in candidates) {
    if (candidates[inclusiveKey].time >= DONT_CARE_THRESHOLD) {
      arr.push(candidates[inclusiveKey]);
    }
  }

  arr.sort(function(a, b) {
    return b.time - a.time;
  });

  return arr;
}

function getUnchangedComponents(measurement) {
  // For a given reconcile, look at which components did not actually
  // render anything to the DOM and return a mapping of their ID to
  // the amount of time it took to render the entire subtree.
  var cleanComponents = {};
  var dirtyLeafIDs = Object.keys(measurement.writes);
  var allIDs = merge(measurement.exclusive, measurement.inclusive);

  for (var id in allIDs) {
    var isDirty = false;
    // For each component that rendered, see if a component that triggerd
    // a DOM op is in its subtree.
    for (var i = 0; i < dirtyLeafIDs.length; i++) {
      if (dirtyLeafIDs[i].indexOf(id) === 0) {
        isDirty = true;
        break;
      }
    }
    if (!isDirty && measurement.counts[id] > 0) {
      cleanComponents[id] = true;
    }
  }
  return cleanComponents;
}

var ReactDefaultPerfAnalysis = {
  getExclusiveSummary: getExclusiveSummary,
  getInclusiveSummary: getInclusiveSummary,
  getDOMSummary: getDOMSummary,
  getTotalTime: getTotalTime
};

module.exports = ReactDefaultPerfAnalysis;

},{"./merge":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/merge.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDescriptor.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactDescriptor
 */

"use strict";

var ReactContext = require("./ReactContext");
var ReactCurrentOwner = require("./ReactCurrentOwner");

var merge = require("./merge");
var warning = require("./warning");

/**
 * Warn for mutations.
 *
 * @internal
 * @param {object} object
 * @param {string} key
 */
function defineWarningProperty(object, key) {
  Object.defineProperty(object, key, {

    configurable: false,
    enumerable: true,

    get: function() {
      if (!this._store) {
        return null;
      }
      return this._store[key];
    },

    set: function(value) {
      ("production" !== process.env.NODE_ENV ? warning(
        false,
        'Don\'t set the ' + key + ' property of the component. ' +
        'Mutate the existing props object instead.'
      ) : null);
      this._store[key] = value;
    }

  });
}

/**
 * This is updated to true if the membrane is successfully created.
 */
var useMutationMembrane = false;

/**
 * Warn for mutations.
 *
 * @internal
 * @param {object} descriptor
 */
function defineMutationMembrane(prototype) {
  try {
    var pseudoFrozenProperties = {
      props: true
    };
    for (var key in pseudoFrozenProperties) {
      defineWarningProperty(prototype, key);
    }
    useMutationMembrane = true;
  } catch (x) {
    // IE will fail on defineProperty
  }
}

/**
 * Transfer static properties from the source to the target. Functions are
 * rebound to have this reflect the original source.
 */
function proxyStaticMethods(target, source) {
  if (typeof source !== 'function') {
    return;
  }
  for (var key in source) {
    if (source.hasOwnProperty(key)) {
      var value = source[key];
      if (typeof value === 'function') {
        var bound = value.bind(source);
        // Copy any properties defined on the function, such as `isRequired` on
        // a PropTypes validator. (mergeInto refuses to work on functions.)
        for (var k in value) {
          if (value.hasOwnProperty(k)) {
            bound[k] = value[k];
          }
        }
        target[key] = bound;
      } else {
        target[key] = value;
      }
    }
  }
}

/**
 * Base constructor for all React descriptors. This is only used to make this
 * work with a dynamic instanceof check. Nothing should live on this prototype.
 *
 * @param {*} type
 * @internal
 */
var ReactDescriptor = function() {};

if ("production" !== process.env.NODE_ENV) {
  defineMutationMembrane(ReactDescriptor.prototype);
}

ReactDescriptor.createFactory = function(type) {

  var descriptorPrototype = Object.create(ReactDescriptor.prototype);

  var factory = function(props, children) {
    // For consistency we currently allocate a new object for every descriptor.
    // This protects the descriptor from being mutated by the original props
    // object being mutated. It also protects the original props object from
    // being mutated by children arguments and default props. This behavior
    // comes with a performance cost and could be deprecated in the future.
    // It could also be optimized with a smarter JSX transform.
    if (props == null) {
      props = {};
    } else if (typeof props === 'object') {
      props = merge(props);
    }

    // Children can be more than one argument, and those are transferred onto
    // the newly allocated props object.
    var childrenLength = arguments.length - 1;
    if (childrenLength === 1) {
      props.children = children;
    } else if (childrenLength > 1) {
      var childArray = Array(childrenLength);
      for (var i = 0; i < childrenLength; i++) {
        childArray[i] = arguments[i + 1];
      }
      props.children = childArray;
    }

    // Initialize the descriptor object
    var descriptor = Object.create(descriptorPrototype);

    // Record the component responsible for creating this descriptor.
    descriptor._owner = ReactCurrentOwner.current;

    // TODO: Deprecate withContext, and then the context becomes accessible
    // through the owner.
    descriptor._context = ReactContext.current;

    if ("production" !== process.env.NODE_ENV) {
      // The validation flag and props are currently mutative. We put them on
      // an external backing store so that we can freeze the whole object.
      // This can be replaced with a WeakMap once they are implemented in
      // commonly used development environments.
      descriptor._store = { validated: false, props: props };

      // We're not allowed to set props directly on the object so we early
      // return and rely on the prototype membrane to forward to the backing
      // store.
      if (useMutationMembrane) {
        Object.freeze(descriptor);
        return descriptor;
      }
    }

    descriptor.props = props;
    return descriptor;
  };

  // Currently we expose the prototype of the descriptor so that
  // <Foo /> instanceof Foo works. This is controversial pattern.
  factory.prototype = descriptorPrototype;

  // Expose the type on the factory and the prototype so that it can be
  // easily accessed on descriptors. E.g. <Foo />.type === Foo.type and for
  // static methods like <Foo />.type.staticMethod();
  // This should not be named constructor since this may not be the function
  // that created the descriptor, and it may not even be a constructor.
  factory.type = type;
  descriptorPrototype.type = type;

  proxyStaticMethods(factory, type);

  // Expose a unique constructor on the prototype is that this works with type
  // systems that compare constructor properties: <Foo />.constructor === Foo
  // This may be controversial since it requires a known factory function.
  descriptorPrototype.constructor = factory;

  return factory;

};

ReactDescriptor.cloneAndReplaceProps = function(oldDescriptor, newProps) {
  var newDescriptor = Object.create(oldDescriptor.constructor.prototype);
  // It's important that this property order matches the hidden class of the
  // original descriptor to maintain perf.
  newDescriptor._owner = oldDescriptor._owner;
  newDescriptor._context = oldDescriptor._context;

  if ("production" !== process.env.NODE_ENV) {
    newDescriptor._store = {
      validated: oldDescriptor._store.validated,
      props: newProps
    };
    if (useMutationMembrane) {
      Object.freeze(newDescriptor);
      return newDescriptor;
    }
  }

  newDescriptor.props = newProps;
  return newDescriptor;
};

/**
 * Checks if a value is a valid descriptor constructor.
 *
 * @param {*}
 * @return {boolean}
 * @public
 */
ReactDescriptor.isValidFactory = function(factory) {
  return typeof factory === 'function' &&
         factory.prototype instanceof ReactDescriptor;
};

/**
 * @param {?object} object
 * @return {boolean} True if `object` is a valid component.
 * @final
 */
ReactDescriptor.isValidDescriptor = function(object) {
  return object instanceof ReactDescriptor;
};

module.exports = ReactDescriptor;

}).call(this,require('_process'))
},{"./ReactContext":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactContext.js","./ReactCurrentOwner":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactCurrentOwner.js","./merge":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/merge.js","./warning":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/warning.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDescriptorValidator.js":[function(require,module,exports){
/**
 * Copyright 2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactDescriptorValidator
 */

/**
 * ReactDescriptorValidator provides a wrapper around a descriptor factory
 * which validates the props passed to the descriptor. This is intended to be
 * used only in DEV and could be replaced by a static type checker for languages
 * that support it.
 */

"use strict";

var ReactDescriptor = require("./ReactDescriptor");
var ReactPropTypeLocations = require("./ReactPropTypeLocations");
var ReactCurrentOwner = require("./ReactCurrentOwner");

var monitorCodeUse = require("./monitorCodeUse");

/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */
var ownerHasKeyUseWarning = {
  'react_key_warning': {},
  'react_numeric_key_warning': {}
};
var ownerHasMonitoredObjectMap = {};

var loggedTypeFailures = {};

var NUMERIC_PROPERTY_REGEX = /^\d+$/;

/**
 * Gets the current owner's displayName for use in warnings.
 *
 * @internal
 * @return {?string} Display name or undefined
 */
function getCurrentOwnerDisplayName() {
  var current = ReactCurrentOwner.current;
  return current && current.constructor.displayName || undefined;
}

/**
 * Warn if the component doesn't have an explicit key assigned to it.
 * This component is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it.
 *
 * @internal
 * @param {ReactComponent} component Component that requires a key.
 * @param {*} parentType component's parent's type.
 */
function validateExplicitKey(component, parentType) {
  if (component._store.validated || component.props.key != null) {
    return;
  }
  component._store.validated = true;

  warnAndMonitorForKeyUse(
    'react_key_warning',
    'Each child in an array should have a unique "key" prop.',
    component,
    parentType
  );
}

/**
 * Warn if the key is being defined as an object property but has an incorrect
 * value.
 *
 * @internal
 * @param {string} name Property name of the key.
 * @param {ReactComponent} component Component that requires a key.
 * @param {*} parentType component's parent's type.
 */
function validatePropertyKey(name, component, parentType) {
  if (!NUMERIC_PROPERTY_REGEX.test(name)) {
    return;
  }
  warnAndMonitorForKeyUse(
    'react_numeric_key_warning',
    'Child objects should have non-numeric keys so ordering is preserved.',
    component,
    parentType
  );
}

/**
 * Shared warning and monitoring code for the key warnings.
 *
 * @internal
 * @param {string} warningID The id used when logging.
 * @param {string} message The base warning that gets output.
 * @param {ReactComponent} component Component that requires a key.
 * @param {*} parentType component's parent's type.
 */
function warnAndMonitorForKeyUse(warningID, message, component, parentType) {
  var ownerName = getCurrentOwnerDisplayName();
  var parentName = parentType.displayName;

  var useName = ownerName || parentName;
  var memoizer = ownerHasKeyUseWarning[warningID];
  if (memoizer.hasOwnProperty(useName)) {
    return;
  }
  memoizer[useName] = true;

  message += ownerName ?
    (" Check the render method of " + ownerName + ".") :
    (" Check the renderComponent call using <" + parentName + ">.");

  // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.
  var childOwnerName = null;
  if (component._owner && component._owner !== ReactCurrentOwner.current) {
    // Name of the component that originally created this child.
    childOwnerName = component._owner.constructor.displayName;

    message += (" It was passed a child from " + childOwnerName + ".");
  }

  message += ' See http://fb.me/react-warning-keys for more information.';
  monitorCodeUse(warningID, {
    component: useName,
    componentOwner: childOwnerName
  });
  console.warn(message);
}

/**
 * Log that we're using an object map. We're considering deprecating this
 * feature and replace it with proper Map and ImmutableMap data structures.
 *
 * @internal
 */
function monitorUseOfObjectMap() {
  var currentName = getCurrentOwnerDisplayName() || '';
  if (ownerHasMonitoredObjectMap.hasOwnProperty(currentName)) {
    return;
  }
  ownerHasMonitoredObjectMap[currentName] = true;
  monitorCodeUse('react_object_map_children');
}

/**
 * Ensure that every component either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {*} component Statically passed child of any type.
 * @param {*} parentType component's parent's type.
 * @return {boolean}
 */
function validateChildKeys(component, parentType) {
  if (Array.isArray(component)) {
    for (var i = 0; i < component.length; i++) {
      var child = component[i];
      if (ReactDescriptor.isValidDescriptor(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (ReactDescriptor.isValidDescriptor(component)) {
    // This component was passed in a valid location.
    component._store.validated = true;
  } else if (component && typeof component === 'object') {
    monitorUseOfObjectMap();
    for (var name in component) {
      validatePropertyKey(name, component[name], parentType);
    }
  }
}

/**
 * Assert that the props are valid
 *
 * @param {string} componentName Name of the component for error messages.
 * @param {object} propTypes Map of prop name to a ReactPropType
 * @param {object} props
 * @param {string} location e.g. "prop", "context", "child context"
 * @private
 */
function checkPropTypes(componentName, propTypes, props, location) {
  for (var propName in propTypes) {
    if (propTypes.hasOwnProperty(propName)) {
      var error;
      // Prop type validation may throw. In case they do, we don't want to
      // fail the render phase where it didn't fail before. So we log it.
      // After these have been cleaned up, we'll let them throw.
      try {
        error = propTypes[propName](props, propName, componentName, location);
      } catch (ex) {
        error = ex;
      }
      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
        // Only monitor this failure once because there tends to be a lot of the
        // same error.
        loggedTypeFailures[error.message] = true;
        // This will soon use the warning module
        monitorCodeUse(
          'react_failed_descriptor_type_check',
          { message: error.message }
        );
      }
    }
  }
}

var ReactDescriptorValidator = {

  /**
   * Wraps a descriptor factory function in another function which validates
   * the props and context of the descriptor and warns about any failed type
   * checks.
   *
   * @param {function} factory The original descriptor factory
   * @param {object?} propTypes A prop type definition set
   * @param {object?} contextTypes A context type definition set
   * @return {object} The component descriptor, which may be invalid.
   * @private
   */
  createFactory: function(factory, propTypes, contextTypes) {
    var validatedFactory = function(props, children) {
      var descriptor = factory.apply(this, arguments);

      for (var i = 1; i < arguments.length; i++) {
        validateChildKeys(arguments[i], descriptor.type);
      }

      var name = descriptor.type.displayName;
      if (propTypes) {
        checkPropTypes(
          name,
          propTypes,
          descriptor.props,
          ReactPropTypeLocations.prop
        );
      }
      if (contextTypes) {
        checkPropTypes(
          name,
          contextTypes,
          descriptor._context,
          ReactPropTypeLocations.context
        );
      }
      return descriptor;
    };

    validatedFactory.prototype = factory.prototype;
    validatedFactory.type = factory.type;

    // Copy static properties
    for (var key in factory) {
      if (factory.hasOwnProperty(key)) {
        validatedFactory[key] = factory[key];
      }
    }

    return validatedFactory;
  }

};

module.exports = ReactDescriptorValidator;

},{"./ReactCurrentOwner":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactCurrentOwner.js","./ReactDescriptor":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDescriptor.js","./ReactPropTypeLocations":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactPropTypeLocations.js","./monitorCodeUse":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/monitorCodeUse.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactEmptyComponent.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactEmptyComponent
 */

"use strict";

var invariant = require("./invariant");

var component;
// This registry keeps track of the React IDs of the components that rendered to
// `null` (in reality a placeholder such as `noscript`)
var nullComponentIdsRegistry = {};

var ReactEmptyComponentInjection = {
  injectEmptyComponent: function(emptyComponent) {
    component = emptyComponent;
  }
};

/**
 * @return {ReactComponent} component The injected empty component.
 */
function getEmptyComponent() {
  ("production" !== process.env.NODE_ENV ? invariant(
    component,
    'Trying to return null from a render, but no null placeholder component ' +
    'was injected.'
  ) : invariant(component));
  return component();
}

/**
 * Mark the component as having rendered to null.
 * @param {string} id Component's `_rootNodeID`.
 */
function registerNullComponentID(id) {
  nullComponentIdsRegistry[id] = true;
}

/**
 * Unmark the component as having rendered to null: it renders to something now.
 * @param {string} id Component's `_rootNodeID`.
 */
function deregisterNullComponentID(id) {
  delete nullComponentIdsRegistry[id];
}

/**
 * @param {string} id Component's `_rootNodeID`.
 * @return {boolean} True if the component is rendered to null.
 */
function isNullComponentID(id) {
  return nullComponentIdsRegistry[id];
}

var ReactEmptyComponent = {
  deregisterNullComponentID: deregisterNullComponentID,
  getEmptyComponent: getEmptyComponent,
  injection: ReactEmptyComponentInjection,
  isNullComponentID: isNullComponentID,
  registerNullComponentID: registerNullComponentID
};

module.exports = ReactEmptyComponent;

}).call(this,require('_process'))
},{"./invariant":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/invariant.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactErrorUtils.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactErrorUtils
 * @typechecks
 */

"use strict";

var ReactErrorUtils = {
  /**
   * Creates a guarded version of a function. This is supposed to make debugging
   * of event handlers easier. To aid debugging with the browser's debugger,
   * this currently simply returns the original function.
   *
   * @param {function} func Function to be executed
   * @param {string} name The name of the guard
   * @return {function}
   */
  guard: function(func, name) {
    return func;
  }
};

module.exports = ReactErrorUtils;

},{}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactEventEmitterMixin.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactEventEmitterMixin
 */

"use strict";

var EventPluginHub = require("./EventPluginHub");

function runEventQueueInBatch(events) {
  EventPluginHub.enqueueEvents(events);
  EventPluginHub.processEventQueue();
}

var ReactEventEmitterMixin = {

  /**
   * Streams a fired top-level event to `EventPluginHub` where plugins have the
   * opportunity to create `ReactEvent`s to be dispatched.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {object} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native environment event.
   */
  handleTopLevel: function(
      topLevelType,
      topLevelTarget,
      topLevelTargetID,
      nativeEvent) {
    var events = EventPluginHub.extractEvents(
      topLevelType,
      topLevelTarget,
      topLevelTargetID,
      nativeEvent
    );

    runEventQueueInBatch(events);
  }
};

module.exports = ReactEventEmitterMixin;

},{"./EventPluginHub":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/EventPluginHub.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactEventListener.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactEventListener
 * @typechecks static-only
 */

"use strict";

var EventListener = require("./EventListener");
var ExecutionEnvironment = require("./ExecutionEnvironment");
var PooledClass = require("./PooledClass");
var ReactInstanceHandles = require("./ReactInstanceHandles");
var ReactMount = require("./ReactMount");
var ReactUpdates = require("./ReactUpdates");

var getEventTarget = require("./getEventTarget");
var getUnboundedScrollPosition = require("./getUnboundedScrollPosition");
var mixInto = require("./mixInto");

/**
 * Finds the parent React component of `node`.
 *
 * @param {*} node
 * @return {?DOMEventTarget} Parent container, or `null` if the specified node
 *                           is not nested.
 */
function findParent(node) {
  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
  // traversal, but caching is difficult to do correctly without using a
  // mutation observer to listen for all DOM changes.
  var nodeID = ReactMount.getID(node);
  var rootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);
  var container = ReactMount.findReactContainerForID(rootID);
  var parent = ReactMount.getFirstReactDOM(container);
  return parent;
}

// Used to store ancestor hierarchy in top level callback
function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
  this.topLevelType = topLevelType;
  this.nativeEvent = nativeEvent;
  this.ancestors = [];
}
mixInto(TopLevelCallbackBookKeeping, {
  destructor: function() {
    this.topLevelType = null;
    this.nativeEvent = null;
    this.ancestors.length = 0;
  }
});
PooledClass.addPoolingTo(
  TopLevelCallbackBookKeeping,
  PooledClass.twoArgumentPooler
);

function handleTopLevelImpl(bookKeeping) {
  var topLevelTarget = ReactMount.getFirstReactDOM(
    getEventTarget(bookKeeping.nativeEvent)
  ) || window;

  // Loop through the hierarchy, in case there's any nested components.
  // It's important that we build the array of ancestors before calling any
  // event handlers, because event handlers can modify the DOM, leading to
  // inconsistencies with ReactMount's node cache. See #1105.
  var ancestor = topLevelTarget;
  while (ancestor) {
    bookKeeping.ancestors.push(ancestor);
    ancestor = findParent(ancestor);
  }

  for (var i = 0, l = bookKeeping.ancestors.length; i < l; i++) {
    topLevelTarget = bookKeeping.ancestors[i];
    var topLevelTargetID = ReactMount.getID(topLevelTarget) || '';
    ReactEventListener._handleTopLevel(
      bookKeeping.topLevelType,
      topLevelTarget,
      topLevelTargetID,
      bookKeeping.nativeEvent
    );
  }
}

function scrollValueMonitor(cb) {
  var scrollPosition = getUnboundedScrollPosition(window);
  cb(scrollPosition);
}

var ReactEventListener = {
  _enabled: true,
  _handleTopLevel: null,

  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,

  setHandleTopLevel: function(handleTopLevel) {
    ReactEventListener._handleTopLevel = handleTopLevel;
  },

  setEnabled: function(enabled) {
    ReactEventListener._enabled = !!enabled;
  },

  isEnabled: function() {
    return ReactEventListener._enabled;
  },


  /**
   * Traps top-level events by using event bubbling.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {string} handlerBaseName Event name (e.g. "click").
   * @param {object} handle Element on which to attach listener.
   * @return {object} An object with a remove function which will forcefully
   *                  remove the listener.
   * @internal
   */
  trapBubbledEvent: function(topLevelType, handlerBaseName, handle) {
    var element = handle;
    if (!element) {
      return;
    }
    return EventListener.listen(
      element,
      handlerBaseName,
      ReactEventListener.dispatchEvent.bind(null, topLevelType)
    );
  },

  /**
   * Traps a top-level event by using event capturing.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {string} handlerBaseName Event name (e.g. "click").
   * @param {object} handle Element on which to attach listener.
   * @return {object} An object with a remove function which will forcefully
   *                  remove the listener.
   * @internal
   */
  trapCapturedEvent: function(topLevelType, handlerBaseName, handle) {
    var element = handle;
    if (!element) {
      return;
    }
    return EventListener.capture(
      element,
      handlerBaseName,
      ReactEventListener.dispatchEvent.bind(null, topLevelType)
    );
  },

  monitorScrollValue: function(refresh) {
    var callback = scrollValueMonitor.bind(null, refresh);
    EventListener.listen(window, 'scroll', callback);
    EventListener.listen(window, 'resize', callback);
  },

  dispatchEvent: function(topLevelType, nativeEvent) {
    if (!ReactEventListener._enabled) {
      return;
    }

    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(
      topLevelType,
      nativeEvent
    );
    try {
      // Event queue being processed in the same cycle allows
      // `preventDefault`.
      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
    } finally {
      TopLevelCallbackBookKeeping.release(bookKeeping);
    }
  }
};

module.exports = ReactEventListener;

},{"./EventListener":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/EventListener.js","./ExecutionEnvironment":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ExecutionEnvironment.js","./PooledClass":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/PooledClass.js","./ReactInstanceHandles":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactInstanceHandles.js","./ReactMount":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactMount.js","./ReactUpdates":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactUpdates.js","./getEventTarget":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/getEventTarget.js","./getUnboundedScrollPosition":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/getUnboundedScrollPosition.js","./mixInto":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/mixInto.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactInjection.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactInjection
 */

"use strict";

var DOMProperty = require("./DOMProperty");
var EventPluginHub = require("./EventPluginHub");
var ReactComponent = require("./ReactComponent");
var ReactCompositeComponent = require("./ReactCompositeComponent");
var ReactDOM = require("./ReactDOM");
var ReactEmptyComponent = require("./ReactEmptyComponent");
var ReactBrowserEventEmitter = require("./ReactBrowserEventEmitter");
var ReactPerf = require("./ReactPerf");
var ReactRootIndex = require("./ReactRootIndex");
var ReactUpdates = require("./ReactUpdates");

var ReactInjection = {
  Component: ReactComponent.injection,
  CompositeComponent: ReactCompositeComponent.injection,
  DOMProperty: DOMProperty.injection,
  EmptyComponent: ReactEmptyComponent.injection,
  EventPluginHub: EventPluginHub.injection,
  DOM: ReactDOM.injection,
  EventEmitter: ReactBrowserEventEmitter.injection,
  Perf: ReactPerf.injection,
  RootIndex: ReactRootIndex.injection,
  Updates: ReactUpdates.injection
};

module.exports = ReactInjection;

},{"./DOMProperty":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/DOMProperty.js","./EventPluginHub":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/EventPluginHub.js","./ReactBrowserEventEmitter":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactBrowserEventEmitter.js","./ReactComponent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactComponent.js","./ReactCompositeComponent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactCompositeComponent.js","./ReactDOM":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDOM.js","./ReactEmptyComponent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactEmptyComponent.js","./ReactPerf":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactPerf.js","./ReactRootIndex":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactRootIndex.js","./ReactUpdates":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactUpdates.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactInputSelection.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactInputSelection
 */

"use strict";

var ReactDOMSelection = require("./ReactDOMSelection");

var containsNode = require("./containsNode");
var focusNode = require("./focusNode");
var getActiveElement = require("./getActiveElement");

function isInDocument(node) {
  return containsNode(document.documentElement, node);
}

/**
 * @ReactInputSelection: React input selection module. Based on Selection.js,
 * but modified to be suitable for react and has a couple of bug fixes (doesn't
 * assume buttons have range selections allowed).
 * Input selection module for React.
 */
var ReactInputSelection = {

  hasSelectionCapabilities: function(elem) {
    return elem && (
      (elem.nodeName === 'INPUT' && elem.type === 'text') ||
      elem.nodeName === 'TEXTAREA' ||
      elem.contentEditable === 'true'
    );
  },

  getSelectionInformation: function() {
    var focusedElem = getActiveElement();
    return {
      focusedElem: focusedElem,
      selectionRange:
          ReactInputSelection.hasSelectionCapabilities(focusedElem) ?
          ReactInputSelection.getSelection(focusedElem) :
          null
    };
  },

  /**
   * @restoreSelection: If any selection information was potentially lost,
   * restore it. This is useful when performing operations that could remove dom
   * nodes and place them back in, resulting in focus being lost.
   */
  restoreSelection: function(priorSelectionInformation) {
    var curFocusedElem = getActiveElement();
    var priorFocusedElem = priorSelectionInformation.focusedElem;
    var priorSelectionRange = priorSelectionInformation.selectionRange;
    if (curFocusedElem !== priorFocusedElem &&
        isInDocument(priorFocusedElem)) {
      if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
        ReactInputSelection.setSelection(
          priorFocusedElem,
          priorSelectionRange
        );
      }
      focusNode(priorFocusedElem);
    }
  },

  /**
   * @getSelection: Gets the selection bounds of a focused textarea, input or
   * contentEditable node.
   * -@input: Look up selection bounds of this input
   * -@return {start: selectionStart, end: selectionEnd}
   */
  getSelection: function(input) {
    var selection;

    if ('selectionStart' in input) {
      // Modern browser with input or textarea.
      selection = {
        start: input.selectionStart,
        end: input.selectionEnd
      };
    } else if (document.selection && input.nodeName === 'INPUT') {
      // IE8 input.
      var range = document.selection.createRange();
      // There can only be one selection per document in IE, so it must
      // be in our element.
      if (range.parentElement() === input) {
        selection = {
          start: -range.moveStart('character', -input.value.length),
          end: -range.moveEnd('character', -input.value.length)
        };
      }
    } else {
      // Content editable or old IE textarea.
      selection = ReactDOMSelection.getOffsets(input);
    }

    return selection || {start: 0, end: 0};
  },

  /**
   * @setSelection: Sets the selection bounds of a textarea or input and focuses
   * the input.
   * -@input     Set selection bounds of this input or textarea
   * -@offsets   Object of same form that is returned from get*
   */
  setSelection: function(input, offsets) {
    var start = offsets.start;
    var end = offsets.end;
    if (typeof end === 'undefined') {
      end = start;
    }

    if ('selectionStart' in input) {
      input.selectionStart = start;
      input.selectionEnd = Math.min(end, input.value.length);
    } else if (document.selection && input.nodeName === 'INPUT') {
      var range = input.createTextRange();
      range.collapse(true);
      range.moveStart('character', start);
      range.moveEnd('character', end - start);
      range.select();
    } else {
      ReactDOMSelection.setOffsets(input, offsets);
    }
  }
};

module.exports = ReactInputSelection;

},{"./ReactDOMSelection":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDOMSelection.js","./containsNode":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/containsNode.js","./focusNode":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/focusNode.js","./getActiveElement":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/getActiveElement.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactInstanceHandles.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactInstanceHandles
 * @typechecks static-only
 */

"use strict";

var ReactRootIndex = require("./ReactRootIndex");

var invariant = require("./invariant");

var SEPARATOR = '.';
var SEPARATOR_LENGTH = SEPARATOR.length;

/**
 * Maximum depth of traversals before we consider the possibility of a bad ID.
 */
var MAX_TREE_DEPTH = 100;

/**
 * Creates a DOM ID prefix to use when mounting React components.
 *
 * @param {number} index A unique integer
 * @return {string} React root ID.
 * @internal
 */
function getReactRootIDString(index) {
  return SEPARATOR + index.toString(36);
}

/**
 * Checks if a character in the supplied ID is a separator or the end.
 *
 * @param {string} id A React DOM ID.
 * @param {number} index Index of the character to check.
 * @return {boolean} True if the character is a separator or end of the ID.
 * @private
 */
function isBoundary(id, index) {
  return id.charAt(index) === SEPARATOR || index === id.length;
}

/**
 * Checks if the supplied string is a valid React DOM ID.
 *
 * @param {string} id A React DOM ID, maybe.
 * @return {boolean} True if the string is a valid React DOM ID.
 * @private
 */
function isValidID(id) {
  return id === '' || (
    id.charAt(0) === SEPARATOR && id.charAt(id.length - 1) !== SEPARATOR
  );
}

/**
 * Checks if the first ID is an ancestor of or equal to the second ID.
 *
 * @param {string} ancestorID
 * @param {string} descendantID
 * @return {boolean} True if `ancestorID` is an ancestor of `descendantID`.
 * @internal
 */
function isAncestorIDOf(ancestorID, descendantID) {
  return (
    descendantID.indexOf(ancestorID) === 0 &&
    isBoundary(descendantID, ancestorID.length)
  );
}

/**
 * Gets the parent ID of the supplied React DOM ID, `id`.
 *
 * @param {string} id ID of a component.
 * @return {string} ID of the parent, or an empty string.
 * @private
 */
function getParentID(id) {
  return id ? id.substr(0, id.lastIndexOf(SEPARATOR)) : '';
}

/**
 * Gets the next DOM ID on the tree path from the supplied `ancestorID` to the
 * supplied `destinationID`. If they are equal, the ID is returned.
 *
 * @param {string} ancestorID ID of an ancestor node of `destinationID`.
 * @param {string} destinationID ID of the destination node.
 * @return {string} Next ID on the path from `ancestorID` to `destinationID`.
 * @private
 */
function getNextDescendantID(ancestorID, destinationID) {
  ("production" !== process.env.NODE_ENV ? invariant(
    isValidID(ancestorID) && isValidID(destinationID),
    'getNextDescendantID(%s, %s): Received an invalid React DOM ID.',
    ancestorID,
    destinationID
  ) : invariant(isValidID(ancestorID) && isValidID(destinationID)));
  ("production" !== process.env.NODE_ENV ? invariant(
    isAncestorIDOf(ancestorID, destinationID),
    'getNextDescendantID(...): React has made an invalid assumption about ' +
    'the DOM hierarchy. Expected `%s` to be an ancestor of `%s`.',
    ancestorID,
    destinationID
  ) : invariant(isAncestorIDOf(ancestorID, destinationID)));
  if (ancestorID === destinationID) {
    return ancestorID;
  }
  // Skip over the ancestor and the immediate separator. Traverse until we hit
  // another separator or we reach the end of `destinationID`.
  var start = ancestorID.length + SEPARATOR_LENGTH;
  for (var i = start; i < destinationID.length; i++) {
    if (isBoundary(destinationID, i)) {
      break;
    }
  }
  return destinationID.substr(0, i);
}

/**
 * Gets the nearest common ancestor ID of two IDs.
 *
 * Using this ID scheme, the nearest common ancestor ID is the longest common
 * prefix of the two IDs that immediately preceded a "marker" in both strings.
 *
 * @param {string} oneID
 * @param {string} twoID
 * @return {string} Nearest common ancestor ID, or the empty string if none.
 * @private
 */
function getFirstCommonAncestorID(oneID, twoID) {
  var minLength = Math.min(oneID.length, twoID.length);
  if (minLength === 0) {
    return '';
  }
  var lastCommonMarkerIndex = 0;
  // Use `<=` to traverse until the "EOL" of the shorter string.
  for (var i = 0; i <= minLength; i++) {
    if (isBoundary(oneID, i) && isBoundary(twoID, i)) {
      lastCommonMarkerIndex = i;
    } else if (oneID.charAt(i) !== twoID.charAt(i)) {
      break;
    }
  }
  var longestCommonID = oneID.substr(0, lastCommonMarkerIndex);
  ("production" !== process.env.NODE_ENV ? invariant(
    isValidID(longestCommonID),
    'getFirstCommonAncestorID(%s, %s): Expected a valid React DOM ID: %s',
    oneID,
    twoID,
    longestCommonID
  ) : invariant(isValidID(longestCommonID)));
  return longestCommonID;
}

/**
 * Traverses the parent path between two IDs (either up or down). The IDs must
 * not be the same, and there must exist a parent path between them. If the
 * callback returns `false`, traversal is stopped.
 *
 * @param {?string} start ID at which to start traversal.
 * @param {?string} stop ID at which to end traversal.
 * @param {function} cb Callback to invoke each ID with.
 * @param {?boolean} skipFirst Whether or not to skip the first node.
 * @param {?boolean} skipLast Whether or not to skip the last node.
 * @private
 */
function traverseParentPath(start, stop, cb, arg, skipFirst, skipLast) {
  start = start || '';
  stop = stop || '';
  ("production" !== process.env.NODE_ENV ? invariant(
    start !== stop,
    'traverseParentPath(...): Cannot traverse from and to the same ID, `%s`.',
    start
  ) : invariant(start !== stop));
  var traverseUp = isAncestorIDOf(stop, start);
  ("production" !== process.env.NODE_ENV ? invariant(
    traverseUp || isAncestorIDOf(start, stop),
    'traverseParentPath(%s, %s, ...): Cannot traverse from two IDs that do ' +
    'not have a parent path.',
    start,
    stop
  ) : invariant(traverseUp || isAncestorIDOf(start, stop)));
  // Traverse from `start` to `stop` one depth at a time.
  var depth = 0;
  var traverse = traverseUp ? getParentID : getNextDescendantID;
  for (var id = start; /* until break */; id = traverse(id, stop)) {
    var ret;
    if ((!skipFirst || id !== start) && (!skipLast || id !== stop)) {
      ret = cb(id, traverseUp, arg);
    }
    if (ret === false || id === stop) {
      // Only break //after// visiting `stop`.
      break;
    }
    ("production" !== process.env.NODE_ENV ? invariant(
      depth++ < MAX_TREE_DEPTH,
      'traverseParentPath(%s, %s, ...): Detected an infinite loop while ' +
      'traversing the React DOM ID tree. This may be due to malformed IDs: %s',
      start, stop
    ) : invariant(depth++ < MAX_TREE_DEPTH));
  }
}

/**
 * Manages the IDs assigned to DOM representations of React components. This
 * uses a specific scheme in order to traverse the DOM efficiently (e.g. in
 * order to simulate events).
 *
 * @internal
 */
var ReactInstanceHandles = {

  /**
   * Constructs a React root ID
   * @return {string} A React root ID.
   */
  createReactRootID: function() {
    return getReactRootIDString(ReactRootIndex.createReactRootIndex());
  },

  /**
   * Constructs a React ID by joining a root ID with a name.
   *
   * @param {string} rootID Root ID of a parent component.
   * @param {string} name A component's name (as flattened children).
   * @return {string} A React ID.
   * @internal
   */
  createReactID: function(rootID, name) {
    return rootID + name;
  },

  /**
   * Gets the DOM ID of the React component that is the root of the tree that
   * contains the React component with the supplied DOM ID.
   *
   * @param {string} id DOM ID of a React component.
   * @return {?string} DOM ID of the React component that is the root.
   * @internal
   */
  getReactRootIDFromNodeID: function(id) {
    if (id && id.charAt(0) === SEPARATOR && id.length > 1) {
      var index = id.indexOf(SEPARATOR, 1);
      return index > -1 ? id.substr(0, index) : id;
    }
    return null;
  },

  /**
   * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
   * should would receive a `mouseEnter` or `mouseLeave` event.
   *
   * NOTE: Does not invoke the callback on the nearest common ancestor because
   * nothing "entered" or "left" that element.
   *
   * @param {string} leaveID ID being left.
   * @param {string} enterID ID being entered.
   * @param {function} cb Callback to invoke on each entered/left ID.
   * @param {*} upArg Argument to invoke the callback with on left IDs.
   * @param {*} downArg Argument to invoke the callback with on entered IDs.
   * @internal
   */
  traverseEnterLeave: function(leaveID, enterID, cb, upArg, downArg) {
    var ancestorID = getFirstCommonAncestorID(leaveID, enterID);
    if (ancestorID !== leaveID) {
      traverseParentPath(leaveID, ancestorID, cb, upArg, false, true);
    }
    if (ancestorID !== enterID) {
      traverseParentPath(ancestorID, enterID, cb, downArg, true, false);
    }
  },

  /**
   * Simulates the traversal of a two-phase, capture/bubble event dispatch.
   *
   * NOTE: This traversal happens on IDs without touching the DOM.
   *
   * @param {string} targetID ID of the target node.
   * @param {function} cb Callback to invoke.
   * @param {*} arg Argument to invoke the callback with.
   * @internal
   */
  traverseTwoPhase: function(targetID, cb, arg) {
    if (targetID) {
      traverseParentPath('', targetID, cb, arg, true, false);
      traverseParentPath(targetID, '', cb, arg, false, true);
    }
  },

  /**
   * Traverse a node ID, calling the supplied `cb` for each ancestor ID. For
   * example, passing `.0.$row-0.1` would result in `cb` getting called
   * with `.0`, `.0.$row-0`, and `.0.$row-0.1`.
   *
   * NOTE: This traversal happens on IDs without touching the DOM.
   *
   * @param {string} targetID ID of the target node.
   * @param {function} cb Callback to invoke.
   * @param {*} arg Argument to invoke the callback with.
   * @internal
   */
  traverseAncestors: function(targetID, cb, arg) {
    traverseParentPath('', targetID, cb, arg, true, false);
  },

  /**
   * Exposed for unit testing.
   * @private
   */
  _getFirstCommonAncestorID: getFirstCommonAncestorID,

  /**
   * Exposed for unit testing.
   * @private
   */
  _getNextDescendantID: getNextDescendantID,

  isAncestorIDOf: isAncestorIDOf,

  SEPARATOR: SEPARATOR

};

module.exports = ReactInstanceHandles;

}).call(this,require('_process'))
},{"./ReactRootIndex":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactRootIndex.js","./invariant":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/invariant.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactLink.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactLink
 * @typechecks static-only
 */

"use strict";

/**
 * ReactLink encapsulates a common pattern in which a component wants to modify
 * a prop received from its parent. ReactLink allows the parent to pass down a
 * value coupled with a callback that, when invoked, expresses an intent to
 * modify that value. For example:
 *
 * React.createClass({
 *   getInitialState: function() {
 *     return {value: ''};
 *   },
 *   render: function() {
 *     var valueLink = new ReactLink(this.state.value, this._handleValueChange);
 *     return <input valueLink={valueLink} />;
 *   },
 *   this._handleValueChange: function(newValue) {
 *     this.setState({value: newValue});
 *   }
 * });
 *
 * We have provided some sugary mixins to make the creation and
 * consumption of ReactLink easier; see LinkedValueUtils and LinkedStateMixin.
 */

var React = require("./React");

/**
 * @param {*} value current value of the link
 * @param {function} requestChange callback to request a change
 */
function ReactLink(value, requestChange) {
  this.value = value;
  this.requestChange = requestChange;
}

/**
 * Creates a PropType that enforces the ReactLink API and optionally checks the
 * type of the value being passed inside the link. Example:
 *
 * MyComponent.propTypes = {
 *   tabIndexLink: ReactLink.PropTypes.link(React.PropTypes.number)
 * }
 */
function createLinkTypeChecker(linkType) {
  var shapes = {
    value: typeof linkType === 'undefined' ?
      React.PropTypes.any.isRequired :
      linkType.isRequired,
    requestChange: React.PropTypes.func.isRequired
  };
  return React.PropTypes.shape(shapes);
}

ReactLink.PropTypes = {
  link: createLinkTypeChecker
};

module.exports = ReactLink;

},{"./React":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/React.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactMarkupChecksum.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactMarkupChecksum
 */

"use strict";

var adler32 = require("./adler32");

var ReactMarkupChecksum = {
  CHECKSUM_ATTR_NAME: 'data-react-checksum',

  /**
   * @param {string} markup Markup string
   * @return {string} Markup string with checksum attribute attached
   */
  addChecksumToMarkup: function(markup) {
    var checksum = adler32(markup);
    return markup.replace(
      '>',
      ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '">'
    );
  },

  /**
   * @param {string} markup to use
   * @param {DOMElement} element root React element
   * @returns {boolean} whether or not the markup is the same
   */
  canReuseMarkup: function(markup, element) {
    var existingChecksum = element.getAttribute(
      ReactMarkupChecksum.CHECKSUM_ATTR_NAME
    );
    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
    var markupChecksum = adler32(markup);
    return markupChecksum === existingChecksum;
  }
};

module.exports = ReactMarkupChecksum;

},{"./adler32":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/adler32.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactMount.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactMount
 */

"use strict";

var DOMProperty = require("./DOMProperty");
var ReactBrowserEventEmitter = require("./ReactBrowserEventEmitter");
var ReactCurrentOwner = require("./ReactCurrentOwner");
var ReactDescriptor = require("./ReactDescriptor");
var ReactInstanceHandles = require("./ReactInstanceHandles");
var ReactPerf = require("./ReactPerf");

var containsNode = require("./containsNode");
var getReactRootElementInContainer = require("./getReactRootElementInContainer");
var instantiateReactComponent = require("./instantiateReactComponent");
var invariant = require("./invariant");
var shouldUpdateReactComponent = require("./shouldUpdateReactComponent");
var warning = require("./warning");

var SEPARATOR = ReactInstanceHandles.SEPARATOR;

var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
var nodeCache = {};

var ELEMENT_NODE_TYPE = 1;
var DOC_NODE_TYPE = 9;

/** Mapping from reactRootID to React component instance. */
var instancesByReactRootID = {};

/** Mapping from reactRootID to `container` nodes. */
var containersByReactRootID = {};

if ("production" !== process.env.NODE_ENV) {
  /** __DEV__-only mapping from reactRootID to root elements. */
  var rootElementsByReactRootID = {};
}

// Used to store breadth-first search state in findComponentRoot.
var findComponentRootReusableArray = [];

/**
 * @param {DOMElement} container DOM element that may contain a React component.
 * @return {?string} A "reactRoot" ID, if a React component is rendered.
 */
function getReactRootID(container) {
  var rootElement = getReactRootElementInContainer(container);
  return rootElement && ReactMount.getID(rootElement);
}

/**
 * Accessing node[ATTR_NAME] or calling getAttribute(ATTR_NAME) on a form
 * element can return its control whose name or ID equals ATTR_NAME. All
 * DOM nodes support `getAttributeNode` but this can also get called on
 * other objects so just return '' if we're given something other than a
 * DOM node (such as window).
 *
 * @param {?DOMElement|DOMWindow|DOMDocument|DOMTextNode} node DOM node.
 * @return {string} ID of the supplied `domNode`.
 */
function getID(node) {
  var id = internalGetID(node);
  if (id) {
    if (nodeCache.hasOwnProperty(id)) {
      var cached = nodeCache[id];
      if (cached !== node) {
        ("production" !== process.env.NODE_ENV ? invariant(
          !isValid(cached, id),
          'ReactMount: Two valid but unequal nodes with the same `%s`: %s',
          ATTR_NAME, id
        ) : invariant(!isValid(cached, id)));

        nodeCache[id] = node;
      }
    } else {
      nodeCache[id] = node;
    }
  }

  return id;
}

function internalGetID(node) {
  // If node is something like a window, document, or text node, none of
  // which support attributes or a .getAttribute method, gracefully return
  // the empty string, as if the attribute were missing.
  return node && node.getAttribute && node.getAttribute(ATTR_NAME) || '';
}

/**
 * Sets the React-specific ID of the given node.
 *
 * @param {DOMElement} node The DOM node whose ID will be set.
 * @param {string} id The value of the ID attribute.
 */
function setID(node, id) {
  var oldID = internalGetID(node);
  if (oldID !== id) {
    delete nodeCache[oldID];
  }
  node.setAttribute(ATTR_NAME, id);
  nodeCache[id] = node;
}

/**
 * Finds the node with the supplied React-generated DOM ID.
 *
 * @param {string} id A React-generated DOM ID.
 * @return {DOMElement} DOM node with the suppled `id`.
 * @internal
 */
function getNode(id) {
  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
    nodeCache[id] = ReactMount.findReactNodeByID(id);
  }
  return nodeCache[id];
}

/**
 * A node is "valid" if it is contained by a currently mounted container.
 *
 * This means that the node does not have to be contained by a document in
 * order to be considered valid.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @param {string} id The expected ID of the node.
 * @return {boolean} Whether the node is contained by a mounted container.
 */
function isValid(node, id) {
  if (node) {
    ("production" !== process.env.NODE_ENV ? invariant(
      internalGetID(node) === id,
      'ReactMount: Unexpected modification of `%s`',
      ATTR_NAME
    ) : invariant(internalGetID(node) === id));

    var container = ReactMount.findReactContainerForID(id);
    if (container && containsNode(container, node)) {
      return true;
    }
  }

  return false;
}

/**
 * Causes the cache to forget about one React-specific ID.
 *
 * @param {string} id The ID to forget.
 */
function purgeID(id) {
  delete nodeCache[id];
}

var deepestNodeSoFar = null;
function findDeepestCachedAncestorImpl(ancestorID) {
  var ancestor = nodeCache[ancestorID];
  if (ancestor && isValid(ancestor, ancestorID)) {
    deepestNodeSoFar = ancestor;
  } else {
    // This node isn't populated in the cache, so presumably none of its
    // descendants are. Break out of the loop.
    return false;
  }
}

/**
 * Return the deepest cached node whose ID is a prefix of `targetID`.
 */
function findDeepestCachedAncestor(targetID) {
  deepestNodeSoFar = null;
  ReactInstanceHandles.traverseAncestors(
    targetID,
    findDeepestCachedAncestorImpl
  );

  var foundNode = deepestNodeSoFar;
  deepestNodeSoFar = null;
  return foundNode;
}

/**
 * Mounting is the process of initializing a React component by creatings its
 * representative DOM elements and inserting them into a supplied `container`.
 * Any prior content inside `container` is destroyed in the process.
 *
 *   ReactMount.renderComponent(
 *     component,
 *     document.getElementById('container')
 *   );
 *
 *   <div id="container">                   <-- Supplied `container`.
 *     <div data-reactid=".3">              <-- Rendered reactRoot of React
 *       // ...                                 component.
 *     </div>
 *   </div>
 *
 * Inside of `container`, the first element rendered is the "reactRoot".
 */
var ReactMount = {
  /** Exposed for debugging purposes **/
  _instancesByReactRootID: instancesByReactRootID,

  /**
   * This is a hook provided to support rendering React components while
   * ensuring that the apparent scroll position of its `container` does not
   * change.
   *
   * @param {DOMElement} container The `container` being rendered into.
   * @param {function} renderCallback This must be called once to do the render.
   */
  scrollMonitor: function(container, renderCallback) {
    renderCallback();
  },

  /**
   * Take a component that's already mounted into the DOM and replace its props
   * @param {ReactComponent} prevComponent component instance already in the DOM
   * @param {ReactComponent} nextComponent component instance to render
   * @param {DOMElement} container container to render into
   * @param {?function} callback function triggered on completion
   */
  _updateRootComponent: function(
      prevComponent,
      nextComponent,
      container,
      callback) {
    var nextProps = nextComponent.props;
    ReactMount.scrollMonitor(container, function() {
      prevComponent.replaceProps(nextProps, callback);
    });

    if ("production" !== process.env.NODE_ENV) {
      // Record the root element in case it later gets transplanted.
      rootElementsByReactRootID[getReactRootID(container)] =
        getReactRootElementInContainer(container);
    }

    return prevComponent;
  },

  /**
   * Register a component into the instance map and starts scroll value
   * monitoring
   * @param {ReactComponent} nextComponent component instance to render
   * @param {DOMElement} container container to render into
   * @return {string} reactRoot ID prefix
   */
  _registerComponent: function(nextComponent, container) {
    ("production" !== process.env.NODE_ENV ? invariant(
      container && (
        container.nodeType === ELEMENT_NODE_TYPE ||
        container.nodeType === DOC_NODE_TYPE
      ),
      '_registerComponent(...): Target container is not a DOM element.'
    ) : invariant(container && (
      container.nodeType === ELEMENT_NODE_TYPE ||
      container.nodeType === DOC_NODE_TYPE
    )));

    ReactBrowserEventEmitter.ensureScrollValueMonitoring();

    var reactRootID = ReactMount.registerContainer(container);
    instancesByReactRootID[reactRootID] = nextComponent;
    return reactRootID;
  },

  /**
   * Render a new component into the DOM.
   * @param {ReactComponent} nextComponent component instance to render
   * @param {DOMElement} container container to render into
   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion
   * @return {ReactComponent} nextComponent
   */
  _renderNewRootComponent: ReactPerf.measure(
    'ReactMount',
    '_renderNewRootComponent',
    function(
        nextComponent,
        container,
        shouldReuseMarkup) {
      // Various parts of our code (such as ReactCompositeComponent's
      // _renderValidatedComponent) assume that calls to render aren't nested;
      // verify that that's the case.
      ("production" !== process.env.NODE_ENV ? warning(
        ReactCurrentOwner.current == null,
        '_renderNewRootComponent(): Render methods should be a pure function ' +
        'of props and state; triggering nested component updates from ' +
        'render is not allowed. If necessary, trigger nested updates in ' +
        'componentDidUpdate.'
      ) : null);

      var componentInstance = instantiateReactComponent(nextComponent);
      var reactRootID = ReactMount._registerComponent(
        componentInstance,
        container
      );
      componentInstance.mountComponentIntoNode(
        reactRootID,
        container,
        shouldReuseMarkup
      );

      if ("production" !== process.env.NODE_ENV) {
        // Record the root element in case it later gets transplanted.
        rootElementsByReactRootID[reactRootID] =
          getReactRootElementInContainer(container);
      }

      return componentInstance;
    }
  ),

  /**
   * Renders a React component into the DOM in the supplied `container`.
   *
   * If the React component was previously rendered into `container`, this will
   * perform an update on it and only mutate the DOM as necessary to reflect the
   * latest React component.
   *
   * @param {ReactDescriptor} nextDescriptor Component descriptor to render.
   * @param {DOMElement} container DOM element to render into.
   * @param {?function} callback function triggered on completion
   * @return {ReactComponent} Component instance rendered in `container`.
   */
  renderComponent: function(nextDescriptor, container, callback) {
    ("production" !== process.env.NODE_ENV ? invariant(
      ReactDescriptor.isValidDescriptor(nextDescriptor),
      'renderComponent(): Invalid component descriptor.%s',
      (
        ReactDescriptor.isValidFactory(nextDescriptor) ?
          ' Instead of passing a component class, make sure to instantiate ' +
          'it first by calling it with props.' :
        // Check if it quacks like a descriptor
        typeof nextDescriptor.props !== "undefined" ?
          ' This may be caused by unintentionally loading two independent ' +
          'copies of React.' :
          ''
      )
    ) : invariant(ReactDescriptor.isValidDescriptor(nextDescriptor)));

    var prevComponent = instancesByReactRootID[getReactRootID(container)];

    if (prevComponent) {
      var prevDescriptor = prevComponent._descriptor;
      if (shouldUpdateReactComponent(prevDescriptor, nextDescriptor)) {
        return ReactMount._updateRootComponent(
          prevComponent,
          nextDescriptor,
          container,
          callback
        );
      } else {
        ReactMount.unmountComponentAtNode(container);
      }
    }

    var reactRootElement = getReactRootElementInContainer(container);
    var containerHasReactMarkup =
      reactRootElement && ReactMount.isRenderedByReact(reactRootElement);

    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent;

    var component = ReactMount._renderNewRootComponent(
      nextDescriptor,
      container,
      shouldReuseMarkup
    );
    callback && callback.call(component);
    return component;
  },

  /**
   * Constructs a component instance of `constructor` with `initialProps` and
   * renders it into the supplied `container`.
   *
   * @param {function} constructor React component constructor.
   * @param {?object} props Initial props of the component instance.
   * @param {DOMElement} container DOM element to render into.
   * @return {ReactComponent} Component instance rendered in `container`.
   */
  constructAndRenderComponent: function(constructor, props, container) {
    return ReactMount.renderComponent(constructor(props), container);
  },

  /**
   * Constructs a component instance of `constructor` with `initialProps` and
   * renders it into a container node identified by supplied `id`.
   *
   * @param {function} componentConstructor React component constructor
   * @param {?object} props Initial props of the component instance.
   * @param {string} id ID of the DOM element to render into.
   * @return {ReactComponent} Component instance rendered in the container node.
   */
  constructAndRenderComponentByID: function(constructor, props, id) {
    var domNode = document.getElementById(id);
    ("production" !== process.env.NODE_ENV ? invariant(
      domNode,
      'Tried to get element with id of "%s" but it is not present on the page.',
      id
    ) : invariant(domNode));
    return ReactMount.constructAndRenderComponent(constructor, props, domNode);
  },

  /**
   * Registers a container node into which React components will be rendered.
   * This also creates the "reactRoot" ID that will be assigned to the element
   * rendered within.
   *
   * @param {DOMElement} container DOM element to register as a container.
   * @return {string} The "reactRoot" ID of elements rendered within.
   */
  registerContainer: function(container) {
    var reactRootID = getReactRootID(container);
    if (reactRootID) {
      // If one exists, make sure it is a valid "reactRoot" ID.
      reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID);
    }
    if (!reactRootID) {
      // No valid "reactRoot" ID found, create one.
      reactRootID = ReactInstanceHandles.createReactRootID();
    }
    containersByReactRootID[reactRootID] = container;
    return reactRootID;
  },

  /**
   * Unmounts and destroys the React component rendered in the `container`.
   *
   * @param {DOMElement} container DOM element containing a React component.
   * @return {boolean} True if a component was found in and unmounted from
   *                   `container`
   */
  unmountComponentAtNode: function(container) {
    // Various parts of our code (such as ReactCompositeComponent's
    // _renderValidatedComponent) assume that calls to render aren't nested;
    // verify that that's the case. (Strictly speaking, unmounting won't cause a
    // render but we still don't expect to be in a render call here.)
    ("production" !== process.env.NODE_ENV ? warning(
      ReactCurrentOwner.current == null,
      'unmountComponentAtNode(): Render methods should be a pure function of ' +
      'props and state; triggering nested component updates from render is ' +
      'not allowed. If necessary, trigger nested updates in ' +
      'componentDidUpdate.'
    ) : null);

    var reactRootID = getReactRootID(container);
    var component = instancesByReactRootID[reactRootID];
    if (!component) {
      return false;
    }
    ReactMount.unmountComponentFromNode(component, container);
    delete instancesByReactRootID[reactRootID];
    delete containersByReactRootID[reactRootID];
    if ("production" !== process.env.NODE_ENV) {
      delete rootElementsByReactRootID[reactRootID];
    }
    return true;
  },

  /**
   * Unmounts a component and removes it from the DOM.
   *
   * @param {ReactComponent} instance React component instance.
   * @param {DOMElement} container DOM element to unmount from.
   * @final
   * @internal
   * @see {ReactMount.unmountComponentAtNode}
   */
  unmountComponentFromNode: function(instance, container) {
    instance.unmountComponent();

    if (container.nodeType === DOC_NODE_TYPE) {
      container = container.documentElement;
    }

    // http://jsperf.com/emptying-a-node
    while (container.lastChild) {
      container.removeChild(container.lastChild);
    }
  },

  /**
   * Finds the container DOM element that contains React component to which the
   * supplied DOM `id` belongs.
   *
   * @param {string} id The ID of an element rendered by a React component.
   * @return {?DOMElement} DOM element that contains the `id`.
   */
  findReactContainerForID: function(id) {
    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(id);
    var container = containersByReactRootID[reactRootID];

    if ("production" !== process.env.NODE_ENV) {
      var rootElement = rootElementsByReactRootID[reactRootID];
      if (rootElement && rootElement.parentNode !== container) {
        ("production" !== process.env.NODE_ENV ? invariant(
          // Call internalGetID here because getID calls isValid which calls
          // findReactContainerForID (this function).
          internalGetID(rootElement) === reactRootID,
          'ReactMount: Root element ID differed from reactRootID.'
        ) : invariant(// Call internalGetID here because getID calls isValid which calls
        // findReactContainerForID (this function).
        internalGetID(rootElement) === reactRootID));

        var containerChild = container.firstChild;
        if (containerChild &&
            reactRootID === internalGetID(containerChild)) {
          // If the container has a new child with the same ID as the old
          // root element, then rootElementsByReactRootID[reactRootID] is
          // just stale and needs to be updated. The case that deserves a
          // warning is when the container is empty.
          rootElementsByReactRootID[reactRootID] = containerChild;
        } else {
          console.warn(
            'ReactMount: Root element has been removed from its original ' +
            'container. New container:', rootElement.parentNode
          );
        }
      }
    }

    return container;
  },

  /**
   * Finds an element rendered by React with the supplied ID.
   *
   * @param {string} id ID of a DOM node in the React component.
   * @return {DOMElement} Root DOM node of the React component.
   */
  findReactNodeByID: function(id) {
    var reactRoot = ReactMount.findReactContainerForID(id);
    return ReactMount.findComponentRoot(reactRoot, id);
  },

  /**
   * True if the supplied `node` is rendered by React.
   *
   * @param {*} node DOM Element to check.
   * @return {boolean} True if the DOM Element appears to be rendered by React.
   * @internal
   */
  isRenderedByReact: function(node) {
    if (node.nodeType !== 1) {
      // Not a DOMElement, therefore not a React component
      return false;
    }
    var id = ReactMount.getID(node);
    return id ? id.charAt(0) === SEPARATOR : false;
  },

  /**
   * Traverses up the ancestors of the supplied node to find a node that is a
   * DOM representation of a React component.
   *
   * @param {*} node
   * @return {?DOMEventTarget}
   * @internal
   */
  getFirstReactDOM: function(node) {
    var current = node;
    while (current && current.parentNode !== current) {
      if (ReactMount.isRenderedByReact(current)) {
        return current;
      }
      current = current.parentNode;
    }
    return null;
  },

  /**
   * Finds a node with the supplied `targetID` inside of the supplied
   * `ancestorNode`.  Exploits the ID naming scheme to perform the search
   * quickly.
   *
   * @param {DOMEventTarget} ancestorNode Search from this root.
   * @pararm {string} targetID ID of the DOM representation of the component.
   * @return {DOMEventTarget} DOM node with the supplied `targetID`.
   * @internal
   */
  findComponentRoot: function(ancestorNode, targetID) {
    var firstChildren = findComponentRootReusableArray;
    var childIndex = 0;

    var deepestAncestor = findDeepestCachedAncestor(targetID) || ancestorNode;

    firstChildren[0] = deepestAncestor.firstChild;
    firstChildren.length = 1;

    while (childIndex < firstChildren.length) {
      var child = firstChildren[childIndex++];
      var targetChild;

      while (child) {
        var childID = ReactMount.getID(child);
        if (childID) {
          // Even if we find the node we're looking for, we finish looping
          // through its siblings to ensure they're cached so that we don't have
          // to revisit this node again. Otherwise, we make n^2 calls to getID
          // when visiting the many children of a single node in order.

          if (targetID === childID) {
            targetChild = child;
          } else if (ReactInstanceHandles.isAncestorIDOf(childID, targetID)) {
            // If we find a child whose ID is an ancestor of the given ID,
            // then we can be sure that we only want to search the subtree
            // rooted at this child, so we can throw out the rest of the
            // search state.
            firstChildren.length = childIndex = 0;
            firstChildren.push(child.firstChild);
          }

        } else {
          // If this child had no ID, then there's a chance that it was
          // injected automatically by the browser, as when a `<table>`
          // element sprouts an extra `<tbody>` child as a side effect of
          // `.innerHTML` parsing. Optimistically continue down this
          // branch, but not before examining the other siblings.
          firstChildren.push(child.firstChild);
        }

        child = child.nextSibling;
      }

      if (targetChild) {
        // Emptying firstChildren/findComponentRootReusableArray is
        // not necessary for correctness, but it helps the GC reclaim
        // any nodes that were left at the end of the search.
        firstChildren.length = 0;

        return targetChild;
      }
    }

    firstChildren.length = 0;

    ("production" !== process.env.NODE_ENV ? invariant(
      false,
      'findComponentRoot(..., %s): Unable to find element. This probably ' +
      'means the DOM was unexpectedly mutated (e.g., by the browser), ' +
      'usually due to forgetting a <tbody> when using tables, nesting <p> ' +
      'or <a> tags, or using non-SVG elements in an <svg> parent. Try ' +
      'inspecting the child nodes of the element with React ID `%s`.',
      targetID,
      ReactMount.getID(ancestorNode)
    ) : invariant(false));
  },


  /**
   * React ID utilities.
   */

  getReactRootID: getReactRootID,

  getID: getID,

  setID: setID,

  getNode: getNode,

  purgeID: purgeID
};

module.exports = ReactMount;

}).call(this,require('_process'))
},{"./DOMProperty":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/DOMProperty.js","./ReactBrowserEventEmitter":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactBrowserEventEmitter.js","./ReactCurrentOwner":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactCurrentOwner.js","./ReactDescriptor":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDescriptor.js","./ReactInstanceHandles":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactInstanceHandles.js","./ReactPerf":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactPerf.js","./containsNode":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/containsNode.js","./getReactRootElementInContainer":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/getReactRootElementInContainer.js","./instantiateReactComponent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/instantiateReactComponent.js","./invariant":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/invariant.js","./shouldUpdateReactComponent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/shouldUpdateReactComponent.js","./warning":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/warning.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactMultiChild.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactMultiChild
 * @typechecks static-only
 */

"use strict";

var ReactComponent = require("./ReactComponent");
var ReactMultiChildUpdateTypes = require("./ReactMultiChildUpdateTypes");

var flattenChildren = require("./flattenChildren");
var instantiateReactComponent = require("./instantiateReactComponent");
var shouldUpdateReactComponent = require("./shouldUpdateReactComponent");

/**
 * Updating children of a component may trigger recursive updates. The depth is
 * used to batch recursive updates to render markup more efficiently.
 *
 * @type {number}
 * @private
 */
var updateDepth = 0;

/**
 * Queue of update configuration objects.
 *
 * Each object has a `type` property that is in `ReactMultiChildUpdateTypes`.
 *
 * @type {array<object>}
 * @private
 */
var updateQueue = [];

/**
 * Queue of markup to be rendered.
 *
 * @type {array<string>}
 * @private
 */
var markupQueue = [];

/**
 * Enqueues markup to be rendered and inserted at a supplied index.
 *
 * @param {string} parentID ID of the parent component.
 * @param {string} markup Markup that renders into an element.
 * @param {number} toIndex Destination index.
 * @private
 */
function enqueueMarkup(parentID, markup, toIndex) {
  // NOTE: Null values reduce hidden classes.
  updateQueue.push({
    parentID: parentID,
    parentNode: null,
    type: ReactMultiChildUpdateTypes.INSERT_MARKUP,
    markupIndex: markupQueue.push(markup) - 1,
    textContent: null,
    fromIndex: null,
    toIndex: toIndex
  });
}

/**
 * Enqueues moving an existing element to another index.
 *
 * @param {string} parentID ID of the parent component.
 * @param {number} fromIndex Source index of the existing element.
 * @param {number} toIndex Destination index of the element.
 * @private
 */
function enqueueMove(parentID, fromIndex, toIndex) {
  // NOTE: Null values reduce hidden classes.
  updateQueue.push({
    parentID: parentID,
    parentNode: null,
    type: ReactMultiChildUpdateTypes.MOVE_EXISTING,
    markupIndex: null,
    textContent: null,
    fromIndex: fromIndex,
    toIndex: toIndex
  });
}

/**
 * Enqueues removing an element at an index.
 *
 * @param {string} parentID ID of the parent component.
 * @param {number} fromIndex Index of the element to remove.
 * @private
 */
function enqueueRemove(parentID, fromIndex) {
  // NOTE: Null values reduce hidden classes.
  updateQueue.push({
    parentID: parentID,
    parentNode: null,
    type: ReactMultiChildUpdateTypes.REMOVE_NODE,
    markupIndex: null,
    textContent: null,
    fromIndex: fromIndex,
    toIndex: null
  });
}

/**
 * Enqueues setting the text content.
 *
 * @param {string} parentID ID of the parent component.
 * @param {string} textContent Text content to set.
 * @private
 */
function enqueueTextContent(parentID, textContent) {
  // NOTE: Null values reduce hidden classes.
  updateQueue.push({
    parentID: parentID,
    parentNode: null,
    type: ReactMultiChildUpdateTypes.TEXT_CONTENT,
    markupIndex: null,
    textContent: textContent,
    fromIndex: null,
    toIndex: null
  });
}

/**
 * Processes any enqueued updates.
 *
 * @private
 */
function processQueue() {
  if (updateQueue.length) {
    ReactComponent.BackendIDOperations.dangerouslyProcessChildrenUpdates(
      updateQueue,
      markupQueue
    );
    clearQueue();
  }
}

/**
 * Clears any enqueued updates.
 *
 * @private
 */
function clearQueue() {
  updateQueue.length = 0;
  markupQueue.length = 0;
}

/**
 * ReactMultiChild are capable of reconciling multiple children.
 *
 * @class ReactMultiChild
 * @internal
 */
var ReactMultiChild = {

  /**
   * Provides common functionality for components that must reconcile multiple
   * children. This is used by `ReactDOMComponent` to mount, update, and
   * unmount child components.
   *
   * @lends {ReactMultiChild.prototype}
   */
  Mixin: {

    /**
     * Generates a "mount image" for each of the supplied children. In the case
     * of `ReactDOMComponent`, a mount image is a string of markup.
     *
     * @param {?object} nestedChildren Nested child maps.
     * @return {array} An array of mounted representations.
     * @internal
     */
    mountChildren: function(nestedChildren, transaction) {
      var children = flattenChildren(nestedChildren);
      var mountImages = [];
      var index = 0;
      this._renderedChildren = children;
      for (var name in children) {
        var child = children[name];
        if (children.hasOwnProperty(name)) {
          // The rendered children must be turned into instances as they're
          // mounted.
          var childInstance = instantiateReactComponent(child);
          children[name] = childInstance;
          // Inlined for performance, see `ReactInstanceHandles.createReactID`.
          var rootID = this._rootNodeID + name;
          var mountImage = childInstance.mountComponent(
            rootID,
            transaction,
            this._mountDepth + 1
          );
          childInstance._mountIndex = index;
          mountImages.push(mountImage);
          index++;
        }
      }
      return mountImages;
    },

    /**
     * Replaces any rendered children with a text content string.
     *
     * @param {string} nextContent String of content.
     * @internal
     */
    updateTextContent: function(nextContent) {
      updateDepth++;
      var errorThrown = true;
      try {
        var prevChildren = this._renderedChildren;
        // Remove any rendered children.
        for (var name in prevChildren) {
          if (prevChildren.hasOwnProperty(name)) {
            this._unmountChildByName(prevChildren[name], name);
          }
        }
        // Set new text content.
        this.setTextContent(nextContent);
        errorThrown = false;
      } finally {
        updateDepth--;
        if (!updateDepth) {
          errorThrown ? clearQueue() : processQueue();
        }
      }
    },

    /**
     * Updates the rendered children with new children.
     *
     * @param {?object} nextNestedChildren Nested child maps.
     * @param {ReactReconcileTransaction} transaction
     * @internal
     */
    updateChildren: function(nextNestedChildren, transaction) {
      updateDepth++;
      var errorThrown = true;
      try {
        this._updateChildren(nextNestedChildren, transaction);
        errorThrown = false;
      } finally {
        updateDepth--;
        if (!updateDepth) {
          errorThrown ? clearQueue() : processQueue();
        }
      }
    },

    /**
     * Improve performance by isolating this hot code path from the try/catch
     * block in `updateChildren`.
     *
     * @param {?object} nextNestedChildren Nested child maps.
     * @param {ReactReconcileTransaction} transaction
     * @final
     * @protected
     */
    _updateChildren: function(nextNestedChildren, transaction) {
      var nextChildren = flattenChildren(nextNestedChildren);
      var prevChildren = this._renderedChildren;
      if (!nextChildren && !prevChildren) {
        return;
      }
      var name;
      // `nextIndex` will increment for each child in `nextChildren`, but
      // `lastIndex` will be the last index visited in `prevChildren`.
      var lastIndex = 0;
      var nextIndex = 0;
      for (name in nextChildren) {
        if (!nextChildren.hasOwnProperty(name)) {
          continue;
        }
        var prevChild = prevChildren && prevChildren[name];
        var prevDescriptor = prevChild && prevChild._descriptor;
        var nextDescriptor = nextChildren[name];
        if (shouldUpdateReactComponent(prevDescriptor, nextDescriptor)) {
          this.moveChild(prevChild, nextIndex, lastIndex);
          lastIndex = Math.max(prevChild._mountIndex, lastIndex);
          prevChild.receiveComponent(nextDescriptor, transaction);
          prevChild._mountIndex = nextIndex;
        } else {
          if (prevChild) {
            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
            this._unmountChildByName(prevChild, name);
          }
          // The child must be instantiated before it's mounted.
          var nextChildInstance = instantiateReactComponent(nextDescriptor);
          this._mountChildByNameAtIndex(
            nextChildInstance, name, nextIndex, transaction
          );
        }
        nextIndex++;
      }
      // Remove children that are no longer present.
      for (name in prevChildren) {
        if (prevChildren.hasOwnProperty(name) &&
            !(nextChildren && nextChildren[name])) {
          this._unmountChildByName(prevChildren[name], name);
        }
      }
    },

    /**
     * Unmounts all rendered children. This should be used to clean up children
     * when this component is unmounted.
     *
     * @internal
     */
    unmountChildren: function() {
      var renderedChildren = this._renderedChildren;
      for (var name in renderedChildren) {
        var renderedChild = renderedChildren[name];
        // TODO: When is this not true?
        if (renderedChild.unmountComponent) {
          renderedChild.unmountComponent();
        }
      }
      this._renderedChildren = null;
    },

    /**
     * Moves a child component to the supplied index.
     *
     * @param {ReactComponent} child Component to move.
     * @param {number} toIndex Destination index of the element.
     * @param {number} lastIndex Last index visited of the siblings of `child`.
     * @protected
     */
    moveChild: function(child, toIndex, lastIndex) {
      // If the index of `child` is less than `lastIndex`, then it needs to
      // be moved. Otherwise, we do not need to move it because a child will be
      // inserted or moved before `child`.
      if (child._mountIndex < lastIndex) {
        enqueueMove(this._rootNodeID, child._mountIndex, toIndex);
      }
    },

    /**
     * Creates a child component.
     *
     * @param {ReactComponent} child Component to create.
     * @param {string} mountImage Markup to insert.
     * @protected
     */
    createChild: function(child, mountImage) {
      enqueueMarkup(this._rootNodeID, mountImage, child._mountIndex);
    },

    /**
     * Removes a child component.
     *
     * @param {ReactComponent} child Child to remove.
     * @protected
     */
    removeChild: function(child) {
      enqueueRemove(this._rootNodeID, child._mountIndex);
    },

    /**
     * Sets this text content string.
     *
     * @param {string} textContent Text content to set.
     * @protected
     */
    setTextContent: function(textContent) {
      enqueueTextContent(this._rootNodeID, textContent);
    },

    /**
     * Mounts a child with the supplied name.
     *
     * NOTE: This is part of `updateChildren` and is here for readability.
     *
     * @param {ReactComponent} child Component to mount.
     * @param {string} name Name of the child.
     * @param {number} index Index at which to insert the child.
     * @param {ReactReconcileTransaction} transaction
     * @private
     */
    _mountChildByNameAtIndex: function(child, name, index, transaction) {
      // Inlined for performance, see `ReactInstanceHandles.createReactID`.
      var rootID = this._rootNodeID + name;
      var mountImage = child.mountComponent(
        rootID,
        transaction,
        this._mountDepth + 1
      );
      child._mountIndex = index;
      this.createChild(child, mountImage);
      this._renderedChildren = this._renderedChildren || {};
      this._renderedChildren[name] = child;
    },

    /**
     * Unmounts a rendered child by name.
     *
     * NOTE: This is part of `updateChildren` and is here for readability.
     *
     * @param {ReactComponent} child Component to unmount.
     * @param {string} name Name of the child in `this._renderedChildren`.
     * @private
     */
    _unmountChildByName: function(child, name) {
      this.removeChild(child);
      child._mountIndex = null;
      child.unmountComponent();
      delete this._renderedChildren[name];
    }

  }

};

module.exports = ReactMultiChild;

},{"./ReactComponent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactComponent.js","./ReactMultiChildUpdateTypes":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactMultiChildUpdateTypes.js","./flattenChildren":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/flattenChildren.js","./instantiateReactComponent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/instantiateReactComponent.js","./shouldUpdateReactComponent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/shouldUpdateReactComponent.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactMultiChildUpdateTypes.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactMultiChildUpdateTypes
 */

"use strict";

var keyMirror = require("./keyMirror");

/**
 * When a component's children are updated, a series of update configuration
 * objects are created in order to batch and serialize the required changes.
 *
 * Enumerates all the possible types of update configurations.
 *
 * @internal
 */
var ReactMultiChildUpdateTypes = keyMirror({
  INSERT_MARKUP: null,
  MOVE_EXISTING: null,
  REMOVE_NODE: null,
  TEXT_CONTENT: null
});

module.exports = ReactMultiChildUpdateTypes;

},{"./keyMirror":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/keyMirror.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactOwner.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactOwner
 */

"use strict";

var emptyObject = require("./emptyObject");
var invariant = require("./invariant");

/**
 * ReactOwners are capable of storing references to owned components.
 *
 * All components are capable of //being// referenced by owner components, but
 * only ReactOwner components are capable of //referencing// owned components.
 * The named reference is known as a "ref".
 *
 * Refs are available when mounted and updated during reconciliation.
 *
 *   var MyComponent = React.createClass({
 *     render: function() {
 *       return (
 *         <div onClick={this.handleClick}>
 *           <CustomComponent ref="custom" />
 *         </div>
 *       );
 *     },
 *     handleClick: function() {
 *       this.refs.custom.handleClick();
 *     },
 *     componentDidMount: function() {
 *       this.refs.custom.initialize();
 *     }
 *   });
 *
 * Refs should rarely be used. When refs are used, they should only be done to
 * control data that is not handled by React's data flow.
 *
 * @class ReactOwner
 */
var ReactOwner = {

  /**
   * @param {?object} object
   * @return {boolean} True if `object` is a valid owner.
   * @final
   */
  isValidOwner: function(object) {
    return !!(
      object &&
      typeof object.attachRef === 'function' &&
      typeof object.detachRef === 'function'
    );
  },

  /**
   * Adds a component by ref to an owner component.
   *
   * @param {ReactComponent} component Component to reference.
   * @param {string} ref Name by which to refer to the component.
   * @param {ReactOwner} owner Component on which to record the ref.
   * @final
   * @internal
   */
  addComponentAsRefTo: function(component, ref, owner) {
    ("production" !== process.env.NODE_ENV ? invariant(
      ReactOwner.isValidOwner(owner),
      'addComponentAsRefTo(...): Only a ReactOwner can have refs. This ' +
      'usually means that you\'re trying to add a ref to a component that ' +
      'doesn\'t have an owner (that is, was not created inside of another ' +
      'component\'s `render` method). Try rendering this component inside of ' +
      'a new top-level component which will hold the ref.'
    ) : invariant(ReactOwner.isValidOwner(owner)));
    owner.attachRef(ref, component);
  },

  /**
   * Removes a component by ref from an owner component.
   *
   * @param {ReactComponent} component Component to dereference.
   * @param {string} ref Name of the ref to remove.
   * @param {ReactOwner} owner Component on which the ref is recorded.
   * @final
   * @internal
   */
  removeComponentAsRefFrom: function(component, ref, owner) {
    ("production" !== process.env.NODE_ENV ? invariant(
      ReactOwner.isValidOwner(owner),
      'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. This ' +
      'usually means that you\'re trying to remove a ref to a component that ' +
      'doesn\'t have an owner (that is, was not created inside of another ' +
      'component\'s `render` method). Try rendering this component inside of ' +
      'a new top-level component which will hold the ref.'
    ) : invariant(ReactOwner.isValidOwner(owner)));
    // Check that `component` is still the current ref because we do not want to
    // detach the ref if another component stole it.
    if (owner.refs[ref] === component) {
      owner.detachRef(ref);
    }
  },

  /**
   * A ReactComponent must mix this in to have refs.
   *
   * @lends {ReactOwner.prototype}
   */
  Mixin: {

    construct: function() {
      this.refs = emptyObject;
    },

    /**
     * Lazily allocates the refs object and stores `component` as `ref`.
     *
     * @param {string} ref Reference name.
     * @param {component} component Component to store as `ref`.
     * @final
     * @private
     */
    attachRef: function(ref, component) {
      ("production" !== process.env.NODE_ENV ? invariant(
        component.isOwnedBy(this),
        'attachRef(%s, ...): Only a component\'s owner can store a ref to it.',
        ref
      ) : invariant(component.isOwnedBy(this)));
      var refs = this.refs === emptyObject ? (this.refs = {}) : this.refs;
      refs[ref] = component;
    },

    /**
     * Detaches a reference name.
     *
     * @param {string} ref Name to dereference.
     * @final
     * @private
     */
    detachRef: function(ref) {
      delete this.refs[ref];
    }

  }

};

module.exports = ReactOwner;

}).call(this,require('_process'))
},{"./emptyObject":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/emptyObject.js","./invariant":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/invariant.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactPerf.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactPerf
 * @typechecks static-only
 */

"use strict";

/**
 * ReactPerf is a general AOP system designed to measure performance. This
 * module only has the hooks: see ReactDefaultPerf for the analysis tool.
 */
var ReactPerf = {
  /**
   * Boolean to enable/disable measurement. Set to false by default to prevent
   * accidental logging and perf loss.
   */
  enableMeasure: false,

  /**
   * Holds onto the measure function in use. By default, don't measure
   * anything, but we'll override this if we inject a measure function.
   */
  storedMeasure: _noMeasure,

  /**
   * Use this to wrap methods you want to measure. Zero overhead in production.
   *
   * @param {string} objName
   * @param {string} fnName
   * @param {function} func
   * @return {function}
   */
  measure: function(objName, fnName, func) {
    if ("production" !== process.env.NODE_ENV) {
      var measuredFunc = null;
      return function() {
        if (ReactPerf.enableMeasure) {
          if (!measuredFunc) {
            measuredFunc = ReactPerf.storedMeasure(objName, fnName, func);
          }
          return measuredFunc.apply(this, arguments);
        }
        return func.apply(this, arguments);
      };
    }
    return func;
  },

  injection: {
    /**
     * @param {function} measure
     */
    injectMeasure: function(measure) {
      ReactPerf.storedMeasure = measure;
    }
  }
};

/**
 * Simply passes through the measured function, without measuring it.
 *
 * @param {string} objName
 * @param {string} fnName
 * @param {function} func
 * @return {function}
 */
function _noMeasure(objName, fnName, func) {
  return func;
}

module.exports = ReactPerf;

}).call(this,require('_process'))
},{"_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactPropTransferer.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactPropTransferer
 */

"use strict";

var emptyFunction = require("./emptyFunction");
var invariant = require("./invariant");
var joinClasses = require("./joinClasses");
var merge = require("./merge");

/**
 * Creates a transfer strategy that will merge prop values using the supplied
 * `mergeStrategy`. If a prop was previously unset, this just sets it.
 *
 * @param {function} mergeStrategy
 * @return {function}
 */
function createTransferStrategy(mergeStrategy) {
  return function(props, key, value) {
    if (!props.hasOwnProperty(key)) {
      props[key] = value;
    } else {
      props[key] = mergeStrategy(props[key], value);
    }
  };
}

var transferStrategyMerge = createTransferStrategy(function(a, b) {
  // `merge` overrides the first object's (`props[key]` above) keys using the
  // second object's (`value`) keys. An object's style's existing `propA` would
  // get overridden. Flip the order here.
  return merge(b, a);
});

/**
 * Transfer strategies dictate how props are transferred by `transferPropsTo`.
 * NOTE: if you add any more exceptions to this list you should be sure to
 * update `cloneWithProps()` accordingly.
 */
var TransferStrategies = {
  /**
   * Never transfer `children`.
   */
  children: emptyFunction,
  /**
   * Transfer the `className` prop by merging them.
   */
  className: createTransferStrategy(joinClasses),
  /**
   * Never transfer the `key` prop.
   */
  key: emptyFunction,
  /**
   * Never transfer the `ref` prop.
   */
  ref: emptyFunction,
  /**
   * Transfer the `style` prop (which is an object) by merging them.
   */
  style: transferStrategyMerge
};

/**
 * Mutates the first argument by transferring the properties from the second
 * argument.
 *
 * @param {object} props
 * @param {object} newProps
 * @return {object}
 */
function transferInto(props, newProps) {
  for (var thisKey in newProps) {
    if (!newProps.hasOwnProperty(thisKey)) {
      continue;
    }

    var transferStrategy = TransferStrategies[thisKey];

    if (transferStrategy && TransferStrategies.hasOwnProperty(thisKey)) {
      transferStrategy(props, thisKey, newProps[thisKey]);
    } else if (!props.hasOwnProperty(thisKey)) {
      props[thisKey] = newProps[thisKey];
    }
  }
  return props;
}

/**
 * ReactPropTransferer are capable of transferring props to another component
 * using a `transferPropsTo` method.
 *
 * @class ReactPropTransferer
 */
var ReactPropTransferer = {

  TransferStrategies: TransferStrategies,

  /**
   * Merge two props objects using TransferStrategies.
   *
   * @param {object} oldProps original props (they take precedence)
   * @param {object} newProps new props to merge in
   * @return {object} a new object containing both sets of props merged.
   */
  mergeProps: function(oldProps, newProps) {
    return transferInto(merge(oldProps), newProps);
  },

  /**
   * @lends {ReactPropTransferer.prototype}
   */
  Mixin: {

    /**
     * Transfer props from this component to a target component.
     *
     * Props that do not have an explicit transfer strategy will be transferred
     * only if the target component does not already have the prop set.
     *
     * This is usually used to pass down props to a returned root component.
     *
     * @param {ReactDescriptor} descriptor Component receiving the properties.
     * @return {ReactDescriptor} The supplied `component`.
     * @final
     * @protected
     */
    transferPropsTo: function(descriptor) {
      ("production" !== process.env.NODE_ENV ? invariant(
        descriptor._owner === this,
        '%s: You can\'t call transferPropsTo() on a component that you ' +
        'don\'t own, %s. This usually means you are calling ' +
        'transferPropsTo() on a component passed in as props or children.',
        this.constructor.displayName,
        descriptor.type.displayName
      ) : invariant(descriptor._owner === this));

      // Because descriptors are immutable we have to merge into the existing
      // props object rather than clone it.
      transferInto(descriptor.props, this.props);

      return descriptor;
    }

  }
};

module.exports = ReactPropTransferer;

}).call(this,require('_process'))
},{"./emptyFunction":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/emptyFunction.js","./invariant":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/invariant.js","./joinClasses":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/joinClasses.js","./merge":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/merge.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactPropTypeLocationNames.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactPropTypeLocationNames
 */

"use strict";

var ReactPropTypeLocationNames = {};

if ("production" !== process.env.NODE_ENV) {
  ReactPropTypeLocationNames = {
    prop: 'prop',
    context: 'context',
    childContext: 'child context'
  };
}

module.exports = ReactPropTypeLocationNames;

}).call(this,require('_process'))
},{"_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactPropTypeLocations.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactPropTypeLocations
 */

"use strict";

var keyMirror = require("./keyMirror");

var ReactPropTypeLocations = keyMirror({
  prop: null,
  context: null,
  childContext: null
});

module.exports = ReactPropTypeLocations;

},{"./keyMirror":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/keyMirror.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactPropTypes.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactPropTypes
 */

"use strict";

var ReactDescriptor = require("./ReactDescriptor");
var ReactPropTypeLocationNames = require("./ReactPropTypeLocationNames");

var emptyFunction = require("./emptyFunction");

/**
 * Collection of methods that allow declaration and validation of props that are
 * supplied to React components. Example usage:
 *
 *   var Props = require('ReactPropTypes');
 *   var MyArticle = React.createClass({
 *     propTypes: {
 *       // An optional string prop named "description".
 *       description: Props.string,
 *
 *       // A required enum prop named "category".
 *       category: Props.oneOf(['News','Photos']).isRequired,
 *
 *       // A prop named "dialog" that requires an instance of Dialog.
 *       dialog: Props.instanceOf(Dialog).isRequired
 *     },
 *     render: function() { ... }
 *   });
 *
 * A more formal specification of how these methods are used:
 *
 *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
 *   decl := ReactPropTypes.{type}(.isRequired)?
 *
 * Each and every declaration produces a function with the same signature. This
 * allows the creation of custom validation functions. For example:
 *
 *  var MyLink = React.createClass({
 *    propTypes: {
 *      // An optional string or URI prop named "href".
 *      href: function(props, propName, componentName) {
 *        var propValue = props[propName];
 *        if (propValue != null && typeof propValue !== 'string' &&
 *            !(propValue instanceof URI)) {
 *          return new Error(
 *            'Expected a string or an URI for ' + propName + ' in ' +
 *            componentName
 *          );
 *        }
 *      }
 *    },
 *    render: function() {...}
 *  });
 *
 * @internal
 */

var ANONYMOUS = '<<anonymous>>';

var ReactPropTypes = {
  array: createPrimitiveTypeChecker('array'),
  bool: createPrimitiveTypeChecker('boolean'),
  func: createPrimitiveTypeChecker('function'),
  number: createPrimitiveTypeChecker('number'),
  object: createPrimitiveTypeChecker('object'),
  string: createPrimitiveTypeChecker('string'),

  any: createAnyTypeChecker(),
  arrayOf: createArrayOfTypeChecker,
  component: createComponentTypeChecker(),
  instanceOf: createInstanceTypeChecker,
  objectOf: createObjectOfTypeChecker,
  oneOf: createEnumTypeChecker,
  oneOfType: createUnionTypeChecker,
  renderable: createRenderableTypeChecker(),
  shape: createShapeTypeChecker
};

function createChainableTypeChecker(validate) {
  function checkType(isRequired, props, propName, componentName, location) {
    componentName = componentName || ANONYMOUS;
    if (props[propName] == null) {
      var locationName = ReactPropTypeLocationNames[location];
      if (isRequired) {
        return new Error(
          ("Required " + locationName + " `" + propName + "` was not specified in ")+
          ("`" + componentName + "`.")
        );
      }
    } else {
      return validate(props, propName, componentName, location);
    }
  }

  var chainedCheckType = checkType.bind(null, false);
  chainedCheckType.isRequired = checkType.bind(null, true);

  return chainedCheckType;
}

function createPrimitiveTypeChecker(expectedType) {
  function validate(props, propName, componentName, location) {
    var propValue = props[propName];
    var propType = getPropType(propValue);
    if (propType !== expectedType) {
      var locationName = ReactPropTypeLocationNames[location];
      // `propValue` being instance of, say, date/regexp, pass the 'object'
      // check, but we can offer a more precise error message here rather than
      // 'of type `object`'.
      var preciseType = getPreciseType(propValue);

      return new Error(
        ("Invalid " + locationName + " `" + propName + "` of type `" + preciseType + "` ") +
        ("supplied to `" + componentName + "`, expected `" + expectedType + "`.")
      );
    }
  }
  return createChainableTypeChecker(validate);
}

function createAnyTypeChecker() {
  return createChainableTypeChecker(emptyFunction.thatReturns());
}

function createArrayOfTypeChecker(typeChecker) {
  function validate(props, propName, componentName, location) {
    var propValue = props[propName];
    if (!Array.isArray(propValue)) {
      var locationName = ReactPropTypeLocationNames[location];
      var propType = getPropType(propValue);
      return new Error(
        ("Invalid " + locationName + " `" + propName + "` of type ") +
        ("`" + propType + "` supplied to `" + componentName + "`, expected an array.")
      );
    }
    for (var i = 0; i < propValue.length; i++) {
      var error = typeChecker(propValue, i, componentName, location);
      if (error instanceof Error) {
        return error;
      }
    }
  }
  return createChainableTypeChecker(validate);
}

function createComponentTypeChecker() {
  function validate(props, propName, componentName, location) {
    if (!ReactDescriptor.isValidDescriptor(props[propName])) {
      var locationName = ReactPropTypeLocationNames[location];
      return new Error(
        ("Invalid " + locationName + " `" + propName + "` supplied to ") +
        ("`" + componentName + "`, expected a React component.")
      );
    }
  }
  return createChainableTypeChecker(validate);
}

function createInstanceTypeChecker(expectedClass) {
  function validate(props, propName, componentName, location) {
    if (!(props[propName] instanceof expectedClass)) {
      var locationName = ReactPropTypeLocationNames[location];
      var expectedClassName = expectedClass.name || ANONYMOUS;
      return new Error(
        ("Invalid " + locationName + " `" + propName + "` supplied to ") +
        ("`" + componentName + "`, expected instance of `" + expectedClassName + "`.")
      );
    }
  }
  return createChainableTypeChecker(validate);
}

function createEnumTypeChecker(expectedValues) {
  function validate(props, propName, componentName, location) {
    var propValue = props[propName];
    for (var i = 0; i < expectedValues.length; i++) {
      if (propValue === expectedValues[i]) {
        return;
      }
    }

    var locationName = ReactPropTypeLocationNames[location];
    var valuesString = JSON.stringify(expectedValues);
    return new Error(
      ("Invalid " + locationName + " `" + propName + "` of value `" + propValue + "` ") +
      ("supplied to `" + componentName + "`, expected one of " + valuesString + ".")
    );
  }
  return createChainableTypeChecker(validate);
}

function createObjectOfTypeChecker(typeChecker) {
  function validate(props, propName, componentName, location) {
    var propValue = props[propName];
    var propType = getPropType(propValue);
    if (propType !== 'object') {
      var locationName = ReactPropTypeLocationNames[location];
      return new Error(
        ("Invalid " + locationName + " `" + propName + "` of type ") +
        ("`" + propType + "` supplied to `" + componentName + "`, expected an object.")
      );
    }
    for (var key in propValue) {
      if (propValue.hasOwnProperty(key)) {
        var error = typeChecker(propValue, key, componentName, location);
        if (error instanceof Error) {
          return error;
        }
      }
    }
  }
  return createChainableTypeChecker(validate);
}

function createUnionTypeChecker(arrayOfTypeCheckers) {
  function validate(props, propName, componentName, location) {
    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (checker(props, propName, componentName, location) == null) {
        return;
      }
    }

    var locationName = ReactPropTypeLocationNames[location];
    return new Error(
      ("Invalid " + locationName + " `" + propName + "` supplied to ") +
      ("`" + componentName + "`.")
    );
  }
  return createChainableTypeChecker(validate);
}

function createRenderableTypeChecker() {
  function validate(props, propName, componentName, location) {
    if (!isRenderable(props[propName])) {
      var locationName = ReactPropTypeLocationNames[location];
      return new Error(
        ("Invalid " + locationName + " `" + propName + "` supplied to ") +
        ("`" + componentName + "`, expected a renderable prop.")
      );
    }
  }
  return createChainableTypeChecker(validate);
}

function createShapeTypeChecker(shapeTypes) {
  function validate(props, propName, componentName, location) {
    var propValue = props[propName];
    var propType = getPropType(propValue);
    if (propType !== 'object') {
      var locationName = ReactPropTypeLocationNames[location];
      return new Error(
        ("Invalid " + locationName + " `" + propName + "` of type `" + propType + "` ") +
        ("supplied to `" + componentName + "`, expected `object`.")
      );
    }
    for (var key in shapeTypes) {
      var checker = shapeTypes[key];
      if (!checker) {
        continue;
      }
      var error = checker(propValue, key, componentName, location);
      if (error) {
        return error;
      }
    }
  }
  return createChainableTypeChecker(validate, 'expected `object`');
}

function isRenderable(propValue) {
  switch(typeof propValue) {
    // TODO: this was probably written with the assumption that we're not
    // returning `this.props.component` directly from `render`. This is
    // currently not supported but we should, to make it consistent.
    case 'number':
    case 'string':
      return true;
    case 'boolean':
      return !propValue;
    case 'object':
      if (Array.isArray(propValue)) {
        return propValue.every(isRenderable);
      }
      if (ReactDescriptor.isValidDescriptor(propValue)) {
        return true;
      }
      for (var k in propValue) {
        if (!isRenderable(propValue[k])) {
          return false;
        }
      }
      return true;
    default:
      return false;
  }
}

// Equivalent of `typeof` but with special handling for array and regexp.
function getPropType(propValue) {
  var propType = typeof propValue;
  if (Array.isArray(propValue)) {
    return 'array';
  }
  if (propValue instanceof RegExp) {
    // Old webkits (at least until Android 4.0) return 'function' rather than
    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
    // passes PropTypes.object.
    return 'object';
  }
  return propType;
}

// This handles more types than `getPropType`. Only used for error messages.
// See `createPrimitiveTypeChecker`.
function getPreciseType(propValue) {
  var propType = getPropType(propValue);
  if (propType === 'object') {
    if (propValue instanceof Date) {
      return 'date';
    } else if (propValue instanceof RegExp) {
      return 'regexp';
    }
  }
  return propType;
}

module.exports = ReactPropTypes;

},{"./ReactDescriptor":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDescriptor.js","./ReactPropTypeLocationNames":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactPropTypeLocationNames.js","./emptyFunction":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/emptyFunction.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactPutListenerQueue.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactPutListenerQueue
 */

"use strict";

var PooledClass = require("./PooledClass");
var ReactBrowserEventEmitter = require("./ReactBrowserEventEmitter");

var mixInto = require("./mixInto");

function ReactPutListenerQueue() {
  this.listenersToPut = [];
}

mixInto(ReactPutListenerQueue, {
  enqueuePutListener: function(rootNodeID, propKey, propValue) {
    this.listenersToPut.push({
      rootNodeID: rootNodeID,
      propKey: propKey,
      propValue: propValue
    });
  },

  putListeners: function() {
    for (var i = 0; i < this.listenersToPut.length; i++) {
      var listenerToPut = this.listenersToPut[i];
      ReactBrowserEventEmitter.putListener(
        listenerToPut.rootNodeID,
        listenerToPut.propKey,
        listenerToPut.propValue
      );
    }
  },

  reset: function() {
    this.listenersToPut.length = 0;
  },

  destructor: function() {
    this.reset();
  }
});

PooledClass.addPoolingTo(ReactPutListenerQueue);

module.exports = ReactPutListenerQueue;

},{"./PooledClass":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/PooledClass.js","./ReactBrowserEventEmitter":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactBrowserEventEmitter.js","./mixInto":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/mixInto.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactReconcileTransaction.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactReconcileTransaction
 * @typechecks static-only
 */

"use strict";

var CallbackQueue = require("./CallbackQueue");
var PooledClass = require("./PooledClass");
var ReactBrowserEventEmitter = require("./ReactBrowserEventEmitter");
var ReactInputSelection = require("./ReactInputSelection");
var ReactPutListenerQueue = require("./ReactPutListenerQueue");
var Transaction = require("./Transaction");

var mixInto = require("./mixInto");

/**
 * Ensures that, when possible, the selection range (currently selected text
 * input) is not disturbed by performing the transaction.
 */
var SELECTION_RESTORATION = {
  /**
   * @return {Selection} Selection information.
   */
  initialize: ReactInputSelection.getSelectionInformation,
  /**
   * @param {Selection} sel Selection information returned from `initialize`.
   */
  close: ReactInputSelection.restoreSelection
};

/**
 * Suppresses events (blur/focus) that could be inadvertently dispatched due to
 * high level DOM manipulations (like temporarily removing a text input from the
 * DOM).
 */
var EVENT_SUPPRESSION = {
  /**
   * @return {boolean} The enabled status of `ReactBrowserEventEmitter` before
   * the reconciliation.
   */
  initialize: function() {
    var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
    ReactBrowserEventEmitter.setEnabled(false);
    return currentlyEnabled;
  },

  /**
   * @param {boolean} previouslyEnabled Enabled status of
   *   `ReactBrowserEventEmitter` before the reconciliation occured. `close`
   *   restores the previous value.
   */
  close: function(previouslyEnabled) {
    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
  }
};

/**
 * Provides a queue for collecting `componentDidMount` and
 * `componentDidUpdate` callbacks during the the transaction.
 */
var ON_DOM_READY_QUEUEING = {
  /**
   * Initializes the internal `onDOMReady` queue.
   */
  initialize: function() {
    this.reactMountReady.reset();
  },

  /**
   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
   */
  close: function() {
    this.reactMountReady.notifyAll();
  }
};

var PUT_LISTENER_QUEUEING = {
  initialize: function() {
    this.putListenerQueue.reset();
  },

  close: function() {
    this.putListenerQueue.putListeners();
  }
};

/**
 * Executed within the scope of the `Transaction` instance. Consider these as
 * being member methods, but with an implied ordering while being isolated from
 * each other.
 */
var TRANSACTION_WRAPPERS = [
  PUT_LISTENER_QUEUEING,
  SELECTION_RESTORATION,
  EVENT_SUPPRESSION,
  ON_DOM_READY_QUEUEING
];

/**
 * Currently:
 * - The order that these are listed in the transaction is critical:
 * - Suppresses events.
 * - Restores selection range.
 *
 * Future:
 * - Restore document/overflow scroll positions that were unintentionally
 *   modified via DOM insertions above the top viewport boundary.
 * - Implement/integrate with customized constraint based layout system and keep
 *   track of which dimensions must be remeasured.
 *
 * @class ReactReconcileTransaction
 */
function ReactReconcileTransaction() {
  this.reinitializeTransaction();
  // Only server-side rendering really needs this option (see
  // `ReactServerRendering`), but server-side uses
  // `ReactServerRenderingTransaction` instead. This option is here so that it's
  // accessible and defaults to false when `ReactDOMComponent` and
  // `ReactTextComponent` checks it in `mountComponent`.`
  this.renderToStaticMarkup = false;
  this.reactMountReady = CallbackQueue.getPooled(null);
  this.putListenerQueue = ReactPutListenerQueue.getPooled();
}

var Mixin = {
  /**
   * @see Transaction
   * @abstract
   * @final
   * @return {array<object>} List of operation wrap proceedures.
   *   TODO: convert to array<TransactionWrapper>
   */
  getTransactionWrappers: function() {
    return TRANSACTION_WRAPPERS;
  },

  /**
   * @return {object} The queue to collect `onDOMReady` callbacks with.
   */
  getReactMountReady: function() {
    return this.reactMountReady;
  },

  getPutListenerQueue: function() {
    return this.putListenerQueue;
  },

  /**
   * `PooledClass` looks for this, and will invoke this before allowing this
   * instance to be resused.
   */
  destructor: function() {
    CallbackQueue.release(this.reactMountReady);
    this.reactMountReady = null;

    ReactPutListenerQueue.release(this.putListenerQueue);
    this.putListenerQueue = null;
  }
};


mixInto(ReactReconcileTransaction, Transaction.Mixin);
mixInto(ReactReconcileTransaction, Mixin);

PooledClass.addPoolingTo(ReactReconcileTransaction);

module.exports = ReactReconcileTransaction;

},{"./CallbackQueue":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/CallbackQueue.js","./PooledClass":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/PooledClass.js","./ReactBrowserEventEmitter":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactBrowserEventEmitter.js","./ReactInputSelection":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactInputSelection.js","./ReactPutListenerQueue":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactPutListenerQueue.js","./Transaction":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/Transaction.js","./mixInto":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/mixInto.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactRootIndex.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactRootIndex
 * @typechecks
 */

"use strict";

var ReactRootIndexInjection = {
  /**
   * @param {function} _createReactRootIndex
   */
  injectCreateReactRootIndex: function(_createReactRootIndex) {
    ReactRootIndex.createReactRootIndex = _createReactRootIndex;
  }
};

var ReactRootIndex = {
  createReactRootIndex: null,
  injection: ReactRootIndexInjection
};

module.exports = ReactRootIndex;

},{}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactServerRendering.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @typechecks static-only
 * @providesModule ReactServerRendering
 */
"use strict";

var ReactDescriptor = require("./ReactDescriptor");
var ReactInstanceHandles = require("./ReactInstanceHandles");
var ReactMarkupChecksum = require("./ReactMarkupChecksum");
var ReactServerRenderingTransaction =
  require("./ReactServerRenderingTransaction");

var instantiateReactComponent = require("./instantiateReactComponent");
var invariant = require("./invariant");

/**
 * @param {ReactComponent} component
 * @return {string} the HTML markup
 */
function renderComponentToString(component) {
  ("production" !== process.env.NODE_ENV ? invariant(
    ReactDescriptor.isValidDescriptor(component),
    'renderComponentToString(): You must pass a valid ReactComponent.'
  ) : invariant(ReactDescriptor.isValidDescriptor(component)));

  ("production" !== process.env.NODE_ENV ? invariant(
    !(arguments.length === 2 && typeof arguments[1] === 'function'),
    'renderComponentToString(): This function became synchronous and now ' +
    'returns the generated markup. Please remove the second parameter.'
  ) : invariant(!(arguments.length === 2 && typeof arguments[1] === 'function')));

  var transaction;
  try {
    var id = ReactInstanceHandles.createReactRootID();
    transaction = ReactServerRenderingTransaction.getPooled(false);

    return transaction.perform(function() {
      var componentInstance = instantiateReactComponent(component);
      var markup = componentInstance.mountComponent(id, transaction, 0);
      return ReactMarkupChecksum.addChecksumToMarkup(markup);
    }, null);
  } finally {
    ReactServerRenderingTransaction.release(transaction);
  }
}

/**
 * @param {ReactComponent} component
 * @return {string} the HTML markup, without the extra React ID and checksum
* (for generating static pages)
 */
function renderComponentToStaticMarkup(component) {
  ("production" !== process.env.NODE_ENV ? invariant(
    ReactDescriptor.isValidDescriptor(component),
    'renderComponentToStaticMarkup(): You must pass a valid ReactComponent.'
  ) : invariant(ReactDescriptor.isValidDescriptor(component)));

  var transaction;
  try {
    var id = ReactInstanceHandles.createReactRootID();
    transaction = ReactServerRenderingTransaction.getPooled(true);

    return transaction.perform(function() {
      var componentInstance = instantiateReactComponent(component);
      return componentInstance.mountComponent(id, transaction, 0);
    }, null);
  } finally {
    ReactServerRenderingTransaction.release(transaction);
  }
}

module.exports = {
  renderComponentToString: renderComponentToString,
  renderComponentToStaticMarkup: renderComponentToStaticMarkup
};

}).call(this,require('_process'))
},{"./ReactDescriptor":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDescriptor.js","./ReactInstanceHandles":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactInstanceHandles.js","./ReactMarkupChecksum":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactMarkupChecksum.js","./ReactServerRenderingTransaction":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactServerRenderingTransaction.js","./instantiateReactComponent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/instantiateReactComponent.js","./invariant":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/invariant.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactServerRenderingTransaction.js":[function(require,module,exports){
/**
 * Copyright 2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactServerRenderingTransaction
 * @typechecks
 */

"use strict";

var PooledClass = require("./PooledClass");
var CallbackQueue = require("./CallbackQueue");
var ReactPutListenerQueue = require("./ReactPutListenerQueue");
var Transaction = require("./Transaction");

var emptyFunction = require("./emptyFunction");
var mixInto = require("./mixInto");

/**
 * Provides a `CallbackQueue` queue for collecting `onDOMReady` callbacks
 * during the performing of the transaction.
 */
var ON_DOM_READY_QUEUEING = {
  /**
   * Initializes the internal `onDOMReady` queue.
   */
  initialize: function() {
    this.reactMountReady.reset();
  },

  close: emptyFunction
};

var PUT_LISTENER_QUEUEING = {
  initialize: function() {
    this.putListenerQueue.reset();
  },

  close: emptyFunction
};

/**
 * Executed within the scope of the `Transaction` instance. Consider these as
 * being member methods, but with an implied ordering while being isolated from
 * each other.
 */
var TRANSACTION_WRAPPERS = [
  PUT_LISTENER_QUEUEING,
  ON_DOM_READY_QUEUEING
];

/**
 * @class ReactServerRenderingTransaction
 * @param {boolean} renderToStaticMarkup
 */
function ReactServerRenderingTransaction(renderToStaticMarkup) {
  this.reinitializeTransaction();
  this.renderToStaticMarkup = renderToStaticMarkup;
  this.reactMountReady = CallbackQueue.getPooled(null);
  this.putListenerQueue = ReactPutListenerQueue.getPooled();
}

var Mixin = {
  /**
   * @see Transaction
   * @abstract
   * @final
   * @return {array} Empty list of operation wrap proceedures.
   */
  getTransactionWrappers: function() {
    return TRANSACTION_WRAPPERS;
  },

  /**
   * @return {object} The queue to collect `onDOMReady` callbacks with.
   */
  getReactMountReady: function() {
    return this.reactMountReady;
  },

  getPutListenerQueue: function() {
    return this.putListenerQueue;
  },

  /**
   * `PooledClass` looks for this, and will invoke this before allowing this
   * instance to be resused.
   */
  destructor: function() {
    CallbackQueue.release(this.reactMountReady);
    this.reactMountReady = null;

    ReactPutListenerQueue.release(this.putListenerQueue);
    this.putListenerQueue = null;
  }
};


mixInto(ReactServerRenderingTransaction, Transaction.Mixin);
mixInto(ReactServerRenderingTransaction, Mixin);

PooledClass.addPoolingTo(ReactServerRenderingTransaction);

module.exports = ReactServerRenderingTransaction;

},{"./CallbackQueue":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/CallbackQueue.js","./PooledClass":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/PooledClass.js","./ReactPutListenerQueue":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactPutListenerQueue.js","./Transaction":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/Transaction.js","./emptyFunction":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/emptyFunction.js","./mixInto":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/mixInto.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactStateSetters.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactStateSetters
 */

"use strict";

var ReactStateSetters = {
  /**
   * Returns a function that calls the provided function, and uses the result
   * of that to set the component's state.
   *
   * @param {ReactCompositeComponent} component
   * @param {function} funcReturningState Returned callback uses this to
   *                                      determine how to update state.
   * @return {function} callback that when invoked uses funcReturningState to
   *                    determined the object literal to setState.
   */
  createStateSetter: function(component, funcReturningState) {
    return function(a, b, c, d, e, f) {
      var partialState = funcReturningState.call(component, a, b, c, d, e, f);
      if (partialState) {
        component.setState(partialState);
      }
    };
  },

  /**
   * Returns a single-argument callback that can be used to update a single
   * key in the component's state.
   *
   * Note: this is memoized function, which makes it inexpensive to call.
   *
   * @param {ReactCompositeComponent} component
   * @param {string} key The key in the state that you should update.
   * @return {function} callback of 1 argument which calls setState() with
   *                    the provided keyName and callback argument.
   */
  createStateKeySetter: function(component, key) {
    // Memoize the setters.
    var cache = component.__keySetters || (component.__keySetters = {});
    return cache[key] || (cache[key] = createStateKeySetter(component, key));
  }
};

function createStateKeySetter(component, key) {
  // Partial state is allocated outside of the function closure so it can be
  // reused with every call, avoiding memory allocation when this function
  // is called.
  var partialState = {};
  return function stateKeySetter(value) {
    partialState[key] = value;
    component.setState(partialState);
  };
}

ReactStateSetters.Mixin = {
  /**
   * Returns a function that calls the provided function, and uses the result
   * of that to set the component's state.
   *
   * For example, these statements are equivalent:
   *
   *   this.setState({x: 1});
   *   this.createStateSetter(function(xValue) {
   *     return {x: xValue};
   *   })(1);
   *
   * @param {function} funcReturningState Returned callback uses this to
   *                                      determine how to update state.
   * @return {function} callback that when invoked uses funcReturningState to
   *                    determined the object literal to setState.
   */
  createStateSetter: function(funcReturningState) {
    return ReactStateSetters.createStateSetter(this, funcReturningState);
  },

  /**
   * Returns a single-argument callback that can be used to update a single
   * key in the component's state.
   *
   * For example, these statements are equivalent:
   *
   *   this.setState({x: 1});
   *   this.createStateKeySetter('x')(1);
   *
   * Note: this is memoized function, which makes it inexpensive to call.
   *
   * @param {string} key The key in the state that you should update.
   * @return {function} callback of 1 argument which calls setState() with
   *                    the provided keyName and callback argument.
   */
  createStateKeySetter: function(key) {
    return ReactStateSetters.createStateKeySetter(this, key);
  }
};

module.exports = ReactStateSetters;

},{}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactTestUtils.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactTestUtils
 */

"use strict";

var EventConstants = require("./EventConstants");
var EventPluginHub = require("./EventPluginHub");
var EventPropagators = require("./EventPropagators");
var React = require("./React");
var ReactDescriptor = require("./ReactDescriptor");
var ReactDOM = require("./ReactDOM");
var ReactBrowserEventEmitter = require("./ReactBrowserEventEmitter");
var ReactMount = require("./ReactMount");
var ReactTextComponent = require("./ReactTextComponent");
var ReactUpdates = require("./ReactUpdates");
var SyntheticEvent = require("./SyntheticEvent");

var mergeInto = require("./mergeInto");
var copyProperties = require("./copyProperties");

var topLevelTypes = EventConstants.topLevelTypes;

function Event(suffix) {}

/**
 * @class ReactTestUtils
 */

/**
 * Todo: Support the entire DOM.scry query syntax. For now, these simple
 * utilities will suffice for testing purposes.
 * @lends ReactTestUtils
 */
var ReactTestUtils = {
  renderIntoDocument: function(instance) {
    var div = document.createElement('div');
    // None of our tests actually require attaching the container to the
    // DOM, and doing so creates a mess that we rely on test isolation to
    // clean up, so we're going to stop honoring the name of this method
    // (and probably rename it eventually) if no problems arise.
    // document.documentElement.appendChild(div);
    return React.renderComponent(instance, div);
  },

  isDescriptor: function(descriptor) {
    return ReactDescriptor.isValidDescriptor(descriptor);
  },

  isDescriptorOfType: function(inst, convenienceConstructor) {
    return (
      ReactDescriptor.isValidDescriptor(inst) &&
      inst.type === convenienceConstructor.type
    );
  },

  isDOMComponent: function(inst) {
    return !!(inst && inst.mountComponent && inst.tagName);
  },

  isDOMComponentDescriptor: function(inst) {
    return !!(inst &&
              ReactDescriptor.isValidDescriptor(inst) &&
              !!inst.tagName);
  },

  isCompositeComponent: function(inst) {
    return typeof inst.render === 'function' &&
           typeof inst.setState === 'function';
  },

  isCompositeComponentWithType: function(inst, type) {
    return !!(ReactTestUtils.isCompositeComponent(inst) &&
             (inst.constructor === type.type));
  },

  isCompositeComponentDescriptor: function(inst) {
    if (!ReactDescriptor.isValidDescriptor(inst)) {
      return false;
    }
    // We check the prototype of the type that will get mounted, not the
    // instance itself. This is a future proof way of duck typing.
    var prototype = inst.type.prototype;
    return (
      typeof prototype.render === 'function' &&
      typeof prototype.setState === 'function'
    );
  },

  isCompositeComponentDescriptorWithType: function(inst, type) {
    return !!(ReactTestUtils.isCompositeComponentDescriptor(inst) &&
             (inst.constructor === type));
  },

  isTextComponent: function(inst) {
    return inst instanceof ReactTextComponent.type;
  },

  findAllInRenderedTree: function(inst, test) {
    if (!inst) {
      return [];
    }
    var ret = test(inst) ? [inst] : [];
    if (ReactTestUtils.isDOMComponent(inst)) {
      var renderedChildren = inst._renderedChildren;
      var key;
      for (key in renderedChildren) {
        if (!renderedChildren.hasOwnProperty(key)) {
          continue;
        }
        ret = ret.concat(
          ReactTestUtils.findAllInRenderedTree(renderedChildren[key], test)
        );
      }
    } else if (ReactTestUtils.isCompositeComponent(inst)) {
      ret = ret.concat(
        ReactTestUtils.findAllInRenderedTree(inst._renderedComponent, test)
      );
    }
    return ret;
  },

  /**
   * Finds all instance of components in the rendered tree that are DOM
   * components with the class name matching `className`.
   * @return an array of all the matches.
   */
  scryRenderedDOMComponentsWithClass: function(root, className) {
    return ReactTestUtils.findAllInRenderedTree(root, function(inst) {
      var instClassName = inst.props.className;
      return ReactTestUtils.isDOMComponent(inst) && (
        instClassName &&
        (' ' + instClassName + ' ').indexOf(' ' + className + ' ') !== -1
      );
    });
  },

  /**
   * Like scryRenderedDOMComponentsWithClass but expects there to be one result,
   * and returns that one result, or throws exception if there is any other
   * number of matches besides one.
   * @return {!ReactDOMComponent} The one match.
   */
  findRenderedDOMComponentWithClass: function(root, className) {
    var all =
      ReactTestUtils.scryRenderedDOMComponentsWithClass(root, className);
    if (all.length !== 1) {
      throw new Error('Did not find exactly one match for class:' + className);
    }
    return all[0];
  },


  /**
   * Finds all instance of components in the rendered tree that are DOM
   * components with the tag name matching `tagName`.
   * @return an array of all the matches.
   */
  scryRenderedDOMComponentsWithTag: function(root, tagName) {
    return ReactTestUtils.findAllInRenderedTree(root, function(inst) {
      return ReactTestUtils.isDOMComponent(inst) &&
            inst.tagName === tagName.toUpperCase();
    });
  },

  /**
   * Like scryRenderedDOMComponentsWithTag but expects there to be one result,
   * and returns that one result, or throws exception if there is any other
   * number of matches besides one.
   * @return {!ReactDOMComponent} The one match.
   */
  findRenderedDOMComponentWithTag: function(root, tagName) {
    var all = ReactTestUtils.scryRenderedDOMComponentsWithTag(root, tagName);
    if (all.length !== 1) {
      throw new Error('Did not find exactly one match for tag:' + tagName);
    }
    return all[0];
  },


  /**
   * Finds all instances of components with type equal to `componentType`.
   * @return an array of all the matches.
   */
  scryRenderedComponentsWithType: function(root, componentType) {
    return ReactTestUtils.findAllInRenderedTree(root, function(inst) {
      return ReactTestUtils.isCompositeComponentWithType(
        inst,
        componentType
      );
    });
  },

  /**
   * Same as `scryRenderedComponentsWithType` but expects there to be one result
   * and returns that one result, or throws exception if there is any other
   * number of matches besides one.
   * @return {!ReactComponent} The one match.
   */
  findRenderedComponentWithType: function(root, componentType) {
    var all = ReactTestUtils.scryRenderedComponentsWithType(
      root,
      componentType
    );
    if (all.length !== 1) {
      throw new Error(
        'Did not find exactly one match for componentType:' + componentType
      );
    }
    return all[0];
  },

  /**
   * Pass a mocked component module to this method to augment it with
   * useful methods that allow it to be used as a dummy React component.
   * Instead of rendering as usual, the component will become a simple
   * <div> containing any provided children.
   *
   * @param {object} module the mock function object exported from a
   *                        module that defines the component to be mocked
   * @param {?string} mockTagName optional dummy root tag name to return
   *                              from render method (overrides
   *                              module.mockTagName if provided)
   * @return {object} the ReactTestUtils object (for chaining)
   */
  mockComponent: function(module, mockTagName) {
    var ConvenienceConstructor = React.createClass({
      render: function() {
        var mockTagName = mockTagName || module.mockTagName || "div";
        return ReactDOM[mockTagName](null, this.props.children);
      }
    });

    copyProperties(module, ConvenienceConstructor);
    module.mockImplementation(ConvenienceConstructor);

    return this;
  },

  /**
   * Simulates a top level event being dispatched from a raw event that occured
   * on an `Element` node.
   * @param topLevelType {Object} A type from `EventConstants.topLevelTypes`
   * @param {!Element} node The dom to simulate an event occurring on.
   * @param {?Event} fakeNativeEvent Fake native event to use in SyntheticEvent.
   */
  simulateNativeEventOnNode: function(topLevelType, node, fakeNativeEvent) {
    fakeNativeEvent.target = node;
    ReactBrowserEventEmitter.ReactEventListener.dispatchEvent(
      topLevelType,
      fakeNativeEvent
    );
  },

  /**
   * Simulates a top level event being dispatched from a raw event that occured
   * on the `ReactDOMComponent` `comp`.
   * @param topLevelType {Object} A type from `EventConstants.topLevelTypes`.
   * @param comp {!ReactDOMComponent}
   * @param {?Event} fakeNativeEvent Fake native event to use in SyntheticEvent.
   */
  simulateNativeEventOnDOMComponent: function(
      topLevelType,
      comp,
      fakeNativeEvent) {
    ReactTestUtils.simulateNativeEventOnNode(
      topLevelType,
      comp.getDOMNode(),
      fakeNativeEvent
    );
  },

  nativeTouchData: function(x, y) {
    return {
      touches: [
        {pageX: x, pageY: y}
      ]
    };
  },

  Simulate: null,
  SimulateNative: {}
};

/**
 * Exports:
 *
 * - `ReactTestUtils.Simulate.click(Element/ReactDOMComponent)`
 * - `ReactTestUtils.Simulate.mouseMove(Element/ReactDOMComponent)`
 * - `ReactTestUtils.Simulate.change(Element/ReactDOMComponent)`
 * - ... (All keys from event plugin `eventTypes` objects)
 */
function makeSimulator(eventType) {
  return function(domComponentOrNode, eventData) {
    var node;
    if (ReactTestUtils.isDOMComponent(domComponentOrNode)) {
      node = domComponentOrNode.getDOMNode();
    } else if (domComponentOrNode.tagName) {
      node = domComponentOrNode;
    }

    var fakeNativeEvent = new Event();
    fakeNativeEvent.target = node;
    // We don't use SyntheticEvent.getPooled in order to not have to worry about
    // properly destroying any properties assigned from `eventData` upon release
    var event = new SyntheticEvent(
      ReactBrowserEventEmitter.eventNameDispatchConfigs[eventType],
      ReactMount.getID(node),
      fakeNativeEvent
    );
    mergeInto(event, eventData);
    EventPropagators.accumulateTwoPhaseDispatches(event);

    ReactUpdates.batchedUpdates(function() {
      EventPluginHub.enqueueEvents(event);
      EventPluginHub.processEventQueue();
    });
  };
}

function buildSimulators() {
  ReactTestUtils.Simulate = {};

  var eventType;
  for (eventType in ReactBrowserEventEmitter.eventNameDispatchConfigs) {
    /**
     * @param {!Element || ReactDOMComponent} domComponentOrNode
     * @param {?object} eventData Fake event data to use in SyntheticEvent.
     */
    ReactTestUtils.Simulate[eventType] = makeSimulator(eventType);
  }
}

// Rebuild ReactTestUtils.Simulate whenever event plugins are injected
var oldInjectEventPluginOrder = EventPluginHub.injection.injectEventPluginOrder;
EventPluginHub.injection.injectEventPluginOrder = function() {
  oldInjectEventPluginOrder.apply(this, arguments);
  buildSimulators();
};
var oldInjectEventPlugins = EventPluginHub.injection.injectEventPluginsByName;
EventPluginHub.injection.injectEventPluginsByName = function() {
  oldInjectEventPlugins.apply(this, arguments);
  buildSimulators();
};

buildSimulators();

/**
 * Exports:
 *
 * - `ReactTestUtils.SimulateNative.click(Element/ReactDOMComponent)`
 * - `ReactTestUtils.SimulateNative.mouseMove(Element/ReactDOMComponent)`
 * - `ReactTestUtils.SimulateNative.mouseIn/ReactDOMComponent)`
 * - `ReactTestUtils.SimulateNative.mouseOut(Element/ReactDOMComponent)`
 * - ... (All keys from `EventConstants.topLevelTypes`)
 *
 * Note: Top level event types are a subset of the entire set of handler types
 * (which include a broader set of "synthetic" events). For example, onDragDone
 * is a synthetic event. Except when testing an event plugin or React's event
 * handling code specifically, you probably want to use ReactTestUtils.Simulate
 * to dispatch synthetic events.
 */

function makeNativeSimulator(eventType) {
  return function(domComponentOrNode, nativeEventData) {
    var fakeNativeEvent = new Event(eventType);
    mergeInto(fakeNativeEvent, nativeEventData);
    if (ReactTestUtils.isDOMComponent(domComponentOrNode)) {
      ReactTestUtils.simulateNativeEventOnDOMComponent(
        eventType,
        domComponentOrNode,
        fakeNativeEvent
      );
    } else if (!!domComponentOrNode.tagName) {
      // Will allow on actual dom nodes.
      ReactTestUtils.simulateNativeEventOnNode(
        eventType,
        domComponentOrNode,
        fakeNativeEvent
      );
    }
  };
}

var eventType;
for (eventType in topLevelTypes) {
  // Event type is stored as 'topClick' - we transform that to 'click'
  var convenienceName = eventType.indexOf('top') === 0 ?
    eventType.charAt(3).toLowerCase() + eventType.substr(4) : eventType;
  /**
   * @param {!Element || ReactDOMComponent} domComponentOrNode
   * @param {?Event} nativeEventData Fake native event to use in SyntheticEvent.
   */
  ReactTestUtils.SimulateNative[convenienceName] =
    makeNativeSimulator(eventType);
}

module.exports = ReactTestUtils;

},{"./EventConstants":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/EventConstants.js","./EventPluginHub":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/EventPluginHub.js","./EventPropagators":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/EventPropagators.js","./React":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/React.js","./ReactBrowserEventEmitter":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactBrowserEventEmitter.js","./ReactDOM":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDOM.js","./ReactDescriptor":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDescriptor.js","./ReactMount":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactMount.js","./ReactTextComponent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactTextComponent.js","./ReactUpdates":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactUpdates.js","./SyntheticEvent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/SyntheticEvent.js","./copyProperties":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/copyProperties.js","./mergeInto":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/mergeInto.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactTextComponent.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactTextComponent
 * @typechecks static-only
 */

"use strict";

var DOMPropertyOperations = require("./DOMPropertyOperations");
var ReactBrowserComponentMixin = require("./ReactBrowserComponentMixin");
var ReactComponent = require("./ReactComponent");
var ReactDescriptor = require("./ReactDescriptor");

var escapeTextForBrowser = require("./escapeTextForBrowser");
var mixInto = require("./mixInto");

/**
 * Text nodes violate a couple assumptions that React makes about components:
 *
 *  - When mounting text into the DOM, adjacent text nodes are merged.
 *  - Text nodes cannot be assigned a React root ID.
 *
 * This component is used to wrap strings in elements so that they can undergo
 * the same reconciliation that is applied to elements.
 *
 * TODO: Investigate representing React components in the DOM with text nodes.
 *
 * @class ReactTextComponent
 * @extends ReactComponent
 * @internal
 */
var ReactTextComponent = function(descriptor) {
  this.construct(descriptor);
};

mixInto(ReactTextComponent, ReactComponent.Mixin);
mixInto(ReactTextComponent, ReactBrowserComponentMixin);
mixInto(ReactTextComponent, {

  /**
   * Creates the markup for this text node. This node is not intended to have
   * any features besides containing text content.
   *
   * @param {string} rootID DOM ID of the root node.
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {number} mountDepth number of components in the owner hierarchy
   * @return {string} Markup for this text node.
   * @internal
   */
  mountComponent: function(rootID, transaction, mountDepth) {
    ReactComponent.Mixin.mountComponent.call(
      this,
      rootID,
      transaction,
      mountDepth
    );

    var escapedText = escapeTextForBrowser(this.props);

    if (transaction.renderToStaticMarkup) {
      // Normally we'd wrap this in a `span` for the reasons stated above, but
      // since this is a situation where React won't take over (static pages),
      // we can simply return the text as it is.
      return escapedText;
    }

    return (
      '<span ' + DOMPropertyOperations.createMarkupForID(rootID) + '>' +
        escapedText +
      '</span>'
    );
  },

  /**
   * Updates this component by updating the text content.
   *
   * @param {object} nextComponent Contains the next text content.
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  receiveComponent: function(nextComponent, transaction) {
    var nextProps = nextComponent.props;
    if (nextProps !== this.props) {
      this.props = nextProps;
      ReactComponent.BackendIDOperations.updateTextContentByID(
        this._rootNodeID,
        nextProps
      );
    }
  }

});

module.exports = ReactDescriptor.createFactory(ReactTextComponent);

},{"./DOMPropertyOperations":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/DOMPropertyOperations.js","./ReactBrowserComponentMixin":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactBrowserComponentMixin.js","./ReactComponent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactComponent.js","./ReactDescriptor":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDescriptor.js","./escapeTextForBrowser":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/escapeTextForBrowser.js","./mixInto":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/mixInto.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactTransitionChildMapping.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @typechecks static-only
 * @providesModule ReactTransitionChildMapping
 */

"use strict";

var ReactChildren = require("./ReactChildren");

var ReactTransitionChildMapping = {
  /**
   * Given `this.props.children`, return an object mapping key to child. Just
   * simple syntactic sugar around ReactChildren.map().
   *
   * @param {*} children `this.props.children`
   * @return {object} Mapping of key to child
   */
  getChildMapping: function(children) {
    return ReactChildren.map(children, function(child) {
      return child;
    });
  },

  /**
   * When you're adding or removing children some may be added or removed in the
   * same render pass. We want ot show *both* since we want to simultaneously
   * animate elements in and out. This function takes a previous set of keys
   * and a new set of keys and merges them with its best guess of the correct
   * ordering. In the future we may expose some of the utilities in
   * ReactMultiChild to make this easy, but for now React itself does not
   * directly have this concept of the union of prevChildren and nextChildren
   * so we implement it here.
   *
   * @param {object} prev prev children as returned from
   * `ReactTransitionChildMapping.getChildMapping()`.
   * @param {object} next next children as returned from
   * `ReactTransitionChildMapping.getChildMapping()`.
   * @return {object} a key set that contains all keys in `prev` and all keys
   * in `next` in a reasonable order.
   */
  mergeChildMappings: function(prev, next) {
    prev = prev || {};
    next = next || {};

    function getValueForKey(key) {
      if (next.hasOwnProperty(key)) {
        return next[key];
      } else {
        return prev[key];
      }
    }

    // For each key of `next`, the list of keys to insert before that key in
    // the combined list
    var nextKeysPending = {};

    var pendingKeys = [];
    for (var prevKey in prev) {
      if (next.hasOwnProperty(prevKey)) {
        if (pendingKeys.length) {
          nextKeysPending[prevKey] = pendingKeys;
          pendingKeys = [];
        }
      } else {
        pendingKeys.push(prevKey);
      }
    }

    var i;
    var childMapping = {};
    for (var nextKey in next) {
      if (nextKeysPending.hasOwnProperty(nextKey)) {
        for (i = 0; i < nextKeysPending[nextKey].length; i++) {
          var pendingNextKey = nextKeysPending[nextKey][i];
          childMapping[nextKeysPending[nextKey][i]] = getValueForKey(
            pendingNextKey
          );
        }
      }
      childMapping[nextKey] = getValueForKey(nextKey);
    }

    // Finally, add the keys which didn't appear before any key in `next`
    for (i = 0; i < pendingKeys.length; i++) {
      childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
    }

    return childMapping;
  }
};

module.exports = ReactTransitionChildMapping;

},{"./ReactChildren":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactChildren.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactTransitionEvents.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactTransitionEvents
 */

"use strict";

var ExecutionEnvironment = require("./ExecutionEnvironment");

/**
 * EVENT_NAME_MAP is used to determine which event fired when a
 * transition/animation ends, based on the style property used to
 * define that event.
 */
var EVENT_NAME_MAP = {
  transitionend: {
    'transition': 'transitionend',
    'WebkitTransition': 'webkitTransitionEnd',
    'MozTransition': 'mozTransitionEnd',
    'OTransition': 'oTransitionEnd',
    'msTransition': 'MSTransitionEnd'
  },

  animationend: {
    'animation': 'animationend',
    'WebkitAnimation': 'webkitAnimationEnd',
    'MozAnimation': 'mozAnimationEnd',
    'OAnimation': 'oAnimationEnd',
    'msAnimation': 'MSAnimationEnd'
  }
};

var endEvents = [];

function detectEvents() {
  var testEl = document.createElement('div');
  var style = testEl.style;

  // On some platforms, in particular some releases of Android 4.x,
  // the un-prefixed "animation" and "transition" properties are defined on the
  // style object but the events that fire will still be prefixed, so we need
  // to check if the un-prefixed events are useable, and if not remove them
  // from the map
  if (!('AnimationEvent' in window)) {
    delete EVENT_NAME_MAP.animationend.animation;
  }

  if (!('TransitionEvent' in window)) {
    delete EVENT_NAME_MAP.transitionend.transition;
  }

  for (var baseEventName in EVENT_NAME_MAP) {
    var baseEvents = EVENT_NAME_MAP[baseEventName];
    for (var styleName in baseEvents) {
      if (styleName in style) {
        endEvents.push(baseEvents[styleName]);
        break;
      }
    }
  }
}

if (ExecutionEnvironment.canUseDOM) {
  detectEvents();
}

// We use the raw {add|remove}EventListener() call because EventListener
// does not know how to remove event listeners and we really should
// clean up. Also, these events are not triggered in older browsers
// so we should be A-OK here.

function addEventListener(node, eventName, eventListener) {
  node.addEventListener(eventName, eventListener, false);
}

function removeEventListener(node, eventName, eventListener) {
  node.removeEventListener(eventName, eventListener, false);
}

var ReactTransitionEvents = {
  addEndEventListener: function(node, eventListener) {
    if (endEvents.length === 0) {
      // If CSS transitions are not supported, trigger an "end animation"
      // event immediately.
      window.setTimeout(eventListener, 0);
      return;
    }
    endEvents.forEach(function(endEvent) {
      addEventListener(node, endEvent, eventListener);
    });
  },

  removeEndEventListener: function(node, eventListener) {
    if (endEvents.length === 0) {
      return;
    }
    endEvents.forEach(function(endEvent) {
      removeEventListener(node, endEvent, eventListener);
    });
  }
};

module.exports = ReactTransitionEvents;

},{"./ExecutionEnvironment":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ExecutionEnvironment.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactTransitionGroup.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactTransitionGroup
 */

"use strict";

var React = require("./React");
var ReactTransitionChildMapping = require("./ReactTransitionChildMapping");

var cloneWithProps = require("./cloneWithProps");
var emptyFunction = require("./emptyFunction");
var merge = require("./merge");

var ReactTransitionGroup = React.createClass({
  displayName: 'ReactTransitionGroup',

  propTypes: {
    component: React.PropTypes.func,
    childFactory: React.PropTypes.func
  },

  getDefaultProps: function() {
    return {
      component: React.DOM.span,
      childFactory: emptyFunction.thatReturnsArgument
    };
  },

  getInitialState: function() {
    return {
      children: ReactTransitionChildMapping.getChildMapping(this.props.children)
    };
  },

  componentWillReceiveProps: function(nextProps) {
    var nextChildMapping = ReactTransitionChildMapping.getChildMapping(
      nextProps.children
    );
    var prevChildMapping = this.state.children;

    this.setState({
      children: ReactTransitionChildMapping.mergeChildMappings(
        prevChildMapping,
        nextChildMapping
      )
    });

    var key;

    for (key in nextChildMapping) {
      var hasPrev = prevChildMapping && prevChildMapping.hasOwnProperty(key);
      if (nextChildMapping[key] && !hasPrev &&
          !this.currentlyTransitioningKeys[key]) {
        this.keysToEnter.push(key);
      }
    }

    for (key in prevChildMapping) {
      var hasNext = nextChildMapping && nextChildMapping.hasOwnProperty(key);
      if (prevChildMapping[key] && !hasNext &&
          !this.currentlyTransitioningKeys[key]) {
        this.keysToLeave.push(key);
      }
    }

    // If we want to someday check for reordering, we could do it here.
  },

  componentWillMount: function() {
    this.currentlyTransitioningKeys = {};
    this.keysToEnter = [];
    this.keysToLeave = [];
  },

  componentDidUpdate: function() {
    var keysToEnter = this.keysToEnter;
    this.keysToEnter = [];
    keysToEnter.forEach(this.performEnter);

    var keysToLeave = this.keysToLeave;
    this.keysToLeave = [];
    keysToLeave.forEach(this.performLeave);
  },

  performEnter: function(key) {
    this.currentlyTransitioningKeys[key] = true;

    var component = this.refs[key];

    if (component.componentWillEnter) {
      component.componentWillEnter(
        this._handleDoneEntering.bind(this, key)
      );
    } else {
      this._handleDoneEntering(key);
    }
  },

  _handleDoneEntering: function(key) {
    var component = this.refs[key];
    if (component.componentDidEnter) {
      component.componentDidEnter();
    }

    delete this.currentlyTransitioningKeys[key];

    var currentChildMapping = ReactTransitionChildMapping.getChildMapping(
      this.props.children
    );

    if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key)) {
      // This was removed before it had fully entered. Remove it.
      this.performLeave(key);
    }
  },

  performLeave: function(key) {
    this.currentlyTransitioningKeys[key] = true;

    var component = this.refs[key];
    if (component.componentWillLeave) {
      component.componentWillLeave(this._handleDoneLeaving.bind(this, key));
    } else {
      // Note that this is somewhat dangerous b/c it calls setState()
      // again, effectively mutating the component before all the work
      // is done.
      this._handleDoneLeaving(key);
    }
  },

  _handleDoneLeaving: function(key) {
    var component = this.refs[key];

    if (component.componentDidLeave) {
      component.componentDidLeave();
    }

    delete this.currentlyTransitioningKeys[key];

    var currentChildMapping = ReactTransitionChildMapping.getChildMapping(
      this.props.children
    );

    if (currentChildMapping && currentChildMapping.hasOwnProperty(key)) {
      // This entered again before it fully left. Add it again.
      this.performEnter(key);
    } else {
      var newChildren = merge(this.state.children);
      delete newChildren[key];
      this.setState({children: newChildren});
    }
  },

  render: function() {
    // TODO: we could get rid of the need for the wrapper node
    // by cloning a single child
    var childrenToRender = {};
    for (var key in this.state.children) {
      var child = this.state.children[key];
      if (child) {
        // You may need to apply reactive updates to a child as it is leaving.
        // The normal React way to do it won't work since the child will have
        // already been removed. In case you need this behavior you can provide
        // a childFactory function to wrap every child, even the ones that are
        // leaving.
        childrenToRender[key] = cloneWithProps(
          this.props.childFactory(child),
          {ref: key}
        );
      }
    }
    return this.transferPropsTo(this.props.component(null, childrenToRender));
  }
});

module.exports = ReactTransitionGroup;

},{"./React":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/React.js","./ReactTransitionChildMapping":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactTransitionChildMapping.js","./cloneWithProps":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/cloneWithProps.js","./emptyFunction":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/emptyFunction.js","./merge":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/merge.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactUpdates.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactUpdates
 */

"use strict";

var CallbackQueue = require("./CallbackQueue");
var PooledClass = require("./PooledClass");
var ReactCurrentOwner = require("./ReactCurrentOwner");
var ReactPerf = require("./ReactPerf");
var Transaction = require("./Transaction");

var invariant = require("./invariant");
var mixInto = require("./mixInto");
var warning = require("./warning");

var dirtyComponents = [];

var batchingStrategy = null;

function ensureInjected() {
  ("production" !== process.env.NODE_ENV ? invariant(
    ReactUpdates.ReactReconcileTransaction && batchingStrategy,
    'ReactUpdates: must inject a reconcile transaction class and batching ' +
    'strategy'
  ) : invariant(ReactUpdates.ReactReconcileTransaction && batchingStrategy));
}

var NESTED_UPDATES = {
  initialize: function() {
    this.dirtyComponentsLength = dirtyComponents.length;
  },
  close: function() {
    if (this.dirtyComponentsLength !== dirtyComponents.length) {
      // Additional updates were enqueued by componentDidUpdate handlers or
      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run
      // these new updates so that if A's componentDidUpdate calls setState on
      // B, B will update before the callback A's updater provided when calling
      // setState.
      dirtyComponents.splice(0, this.dirtyComponentsLength);
      flushBatchedUpdates();
    } else {
      dirtyComponents.length = 0;
    }
  }
};

var UPDATE_QUEUEING = {
  initialize: function() {
    this.callbackQueue.reset();
  },
  close: function() {
    this.callbackQueue.notifyAll();
  }
};

var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];

function ReactUpdatesFlushTransaction() {
  this.reinitializeTransaction();
  this.dirtyComponentsLength = null;
  this.callbackQueue = CallbackQueue.getPooled(null);
  this.reconcileTransaction =
    ReactUpdates.ReactReconcileTransaction.getPooled();
}

mixInto(ReactUpdatesFlushTransaction, Transaction.Mixin);
mixInto(ReactUpdatesFlushTransaction, {
  getTransactionWrappers: function() {
    return TRANSACTION_WRAPPERS;
  },

  destructor: function() {
    this.dirtyComponentsLength = null;
    CallbackQueue.release(this.callbackQueue);
    this.callbackQueue = null;
    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
    this.reconcileTransaction = null;
  },

  perform: function(method, scope, a) {
    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`
    // with this transaction's wrappers around it.
    return Transaction.Mixin.perform.call(
      this,
      this.reconcileTransaction.perform,
      this.reconcileTransaction,
      method,
      scope,
      a
    );
  }
});

PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);

function batchedUpdates(callback, a, b) {
  ensureInjected();
  batchingStrategy.batchedUpdates(callback, a, b);
}

/**
 * Array comparator for ReactComponents by owner depth
 *
 * @param {ReactComponent} c1 first component you're comparing
 * @param {ReactComponent} c2 second component you're comparing
 * @return {number} Return value usable by Array.prototype.sort().
 */
function mountDepthComparator(c1, c2) {
  return c1._mountDepth - c2._mountDepth;
}

function runBatchedUpdates(transaction) {
  var len = transaction.dirtyComponentsLength;
  ("production" !== process.env.NODE_ENV ? invariant(
    len === dirtyComponents.length,
    'Expected flush transaction\'s stored dirty-components length (%s) to ' +
    'match dirty-components array length (%s).',
    len,
    dirtyComponents.length
  ) : invariant(len === dirtyComponents.length));

  // Since reconciling a component higher in the owner hierarchy usually (not
  // always -- see shouldComponentUpdate()) will reconcile children, reconcile
  // them before their children by sorting the array.
  dirtyComponents.sort(mountDepthComparator);

  for (var i = 0; i < len; i++) {
    // If a component is unmounted before pending changes apply, ignore them
    // TODO: Queue unmounts in the same list to avoid this happening at all
    var component = dirtyComponents[i];
    if (component.isMounted()) {
      // If performUpdateIfNecessary happens to enqueue any new updates, we
      // shouldn't execute the callbacks until the next render happens, so
      // stash the callbacks first
      var callbacks = component._pendingCallbacks;
      component._pendingCallbacks = null;
      component.performUpdateIfNecessary(transaction.reconcileTransaction);

      if (callbacks) {
        for (var j = 0; j < callbacks.length; j++) {
          transaction.callbackQueue.enqueue(
            callbacks[j],
            component
          );
        }
      }
    }
  }
}

var flushBatchedUpdates = ReactPerf.measure(
  'ReactUpdates',
  'flushBatchedUpdates',
  function() {
    // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents
    // array and perform any updates enqueued by mount-ready handlers (i.e.,
    // componentDidUpdate) but we need to check here too in order to catch
    // updates enqueued by setState callbacks.
    while (dirtyComponents.length) {
      var transaction = ReactUpdatesFlushTransaction.getPooled();
      transaction.perform(runBatchedUpdates, null, transaction);
      ReactUpdatesFlushTransaction.release(transaction);
    }
  }
);

/**
 * Mark a component as needing a rerender, adding an optional callback to a
 * list of functions which will be executed once the rerender occurs.
 */
function enqueueUpdate(component, callback) {
  ("production" !== process.env.NODE_ENV ? invariant(
    !callback || typeof callback === "function",
    'enqueueUpdate(...): You called `setProps`, `replaceProps`, ' +
    '`setState`, `replaceState`, or `forceUpdate` with a callback that ' +
    'isn\'t callable.'
  ) : invariant(!callback || typeof callback === "function"));
  ensureInjected();

  // Various parts of our code (such as ReactCompositeComponent's
  // _renderValidatedComponent) assume that calls to render aren't nested;
  // verify that that's the case. (This is called by each top-level update
  // function, like setProps, setState, forceUpdate, etc.; creation and
  // destruction of top-level components is guarded in ReactMount.)
  ("production" !== process.env.NODE_ENV ? warning(
    ReactCurrentOwner.current == null,
    'enqueueUpdate(): Render methods should be a pure function of props ' +
    'and state; triggering nested component updates from render is not ' +
    'allowed. If necessary, trigger nested updates in ' +
    'componentDidUpdate.'
  ) : null);

  if (!batchingStrategy.isBatchingUpdates) {
    batchingStrategy.batchedUpdates(enqueueUpdate, component, callback);
    return;
  }

  dirtyComponents.push(component);

  if (callback) {
    if (component._pendingCallbacks) {
      component._pendingCallbacks.push(callback);
    } else {
      component._pendingCallbacks = [callback];
    }
  }
}

var ReactUpdatesInjection = {
  injectReconcileTransaction: function(ReconcileTransaction) {
    ("production" !== process.env.NODE_ENV ? invariant(
      ReconcileTransaction,
      'ReactUpdates: must provide a reconcile transaction class'
    ) : invariant(ReconcileTransaction));
    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
  },

  injectBatchingStrategy: function(_batchingStrategy) {
    ("production" !== process.env.NODE_ENV ? invariant(
      _batchingStrategy,
      'ReactUpdates: must provide a batching strategy'
    ) : invariant(_batchingStrategy));
    ("production" !== process.env.NODE_ENV ? invariant(
      typeof _batchingStrategy.batchedUpdates === 'function',
      'ReactUpdates: must provide a batchedUpdates() function'
    ) : invariant(typeof _batchingStrategy.batchedUpdates === 'function'));
    ("production" !== process.env.NODE_ENV ? invariant(
      typeof _batchingStrategy.isBatchingUpdates === 'boolean',
      'ReactUpdates: must provide an isBatchingUpdates boolean attribute'
    ) : invariant(typeof _batchingStrategy.isBatchingUpdates === 'boolean'));
    batchingStrategy = _batchingStrategy;
  }
};

var ReactUpdates = {
  /**
   * React references `ReactReconcileTransaction` using this property in order
   * to allow dependency injection.
   *
   * @internal
   */
  ReactReconcileTransaction: null,

  batchedUpdates: batchedUpdates,
  enqueueUpdate: enqueueUpdate,
  flushBatchedUpdates: flushBatchedUpdates,
  injection: ReactUpdatesInjection
};

module.exports = ReactUpdates;

}).call(this,require('_process'))
},{"./CallbackQueue":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/CallbackQueue.js","./PooledClass":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/PooledClass.js","./ReactCurrentOwner":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactCurrentOwner.js","./ReactPerf":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactPerf.js","./Transaction":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/Transaction.js","./invariant":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/invariant.js","./mixInto":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/mixInto.js","./warning":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/warning.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactWithAddons.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ReactWithAddons
 */

/**
 * This module exists purely in the open source project, and is meant as a way
 * to create a separate standalone build of React. This build has "addons", or
 * functionality we've built and think might be useful but doesn't have a good
 * place to live inside React core.
 */

"use strict";

var LinkedStateMixin = require("./LinkedStateMixin");
var React = require("./React");
var ReactComponentWithPureRenderMixin =
  require("./ReactComponentWithPureRenderMixin");
var ReactCSSTransitionGroup = require("./ReactCSSTransitionGroup");
var ReactTransitionGroup = require("./ReactTransitionGroup");

var cx = require("./cx");
var cloneWithProps = require("./cloneWithProps");
var update = require("./update");

React.addons = {
  CSSTransitionGroup: ReactCSSTransitionGroup,
  LinkedStateMixin: LinkedStateMixin,
  PureRenderMixin: ReactComponentWithPureRenderMixin,
  TransitionGroup: ReactTransitionGroup,

  classSet: cx,
  cloneWithProps: cloneWithProps,
  update: update
};

if ("production" !== process.env.NODE_ENV) {
  React.addons.Perf = require("./ReactDefaultPerf");
  React.addons.TestUtils = require("./ReactTestUtils");
}

module.exports = React;


}).call(this,require('_process'))
},{"./LinkedStateMixin":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/LinkedStateMixin.js","./React":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/React.js","./ReactCSSTransitionGroup":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactCSSTransitionGroup.js","./ReactComponentWithPureRenderMixin":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactComponentWithPureRenderMixin.js","./ReactDefaultPerf":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDefaultPerf.js","./ReactTestUtils":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactTestUtils.js","./ReactTransitionGroup":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactTransitionGroup.js","./cloneWithProps":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/cloneWithProps.js","./cx":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/cx.js","./update":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/update.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/SVGDOMPropertyConfig.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule SVGDOMPropertyConfig
 */

/*jslint bitwise: true*/

"use strict";

var DOMProperty = require("./DOMProperty");

var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;

var SVGDOMPropertyConfig = {
  Properties: {
    cx: MUST_USE_ATTRIBUTE,
    cy: MUST_USE_ATTRIBUTE,
    d: MUST_USE_ATTRIBUTE,
    dx: MUST_USE_ATTRIBUTE,
    dy: MUST_USE_ATTRIBUTE,
    fill: MUST_USE_ATTRIBUTE,
    fillOpacity: MUST_USE_ATTRIBUTE,
    fontFamily: MUST_USE_ATTRIBUTE,
    fontSize: MUST_USE_ATTRIBUTE,
    fx: MUST_USE_ATTRIBUTE,
    fy: MUST_USE_ATTRIBUTE,
    gradientTransform: MUST_USE_ATTRIBUTE,
    gradientUnits: MUST_USE_ATTRIBUTE,
    markerEnd: MUST_USE_ATTRIBUTE,
    markerMid: MUST_USE_ATTRIBUTE,
    markerStart: MUST_USE_ATTRIBUTE,
    offset: MUST_USE_ATTRIBUTE,
    opacity: MUST_USE_ATTRIBUTE,
    patternContentUnits: MUST_USE_ATTRIBUTE,
    patternUnits: MUST_USE_ATTRIBUTE,
    points: MUST_USE_ATTRIBUTE,
    preserveAspectRatio: MUST_USE_ATTRIBUTE,
    r: MUST_USE_ATTRIBUTE,
    rx: MUST_USE_ATTRIBUTE,
    ry: MUST_USE_ATTRIBUTE,
    spreadMethod: MUST_USE_ATTRIBUTE,
    stopColor: MUST_USE_ATTRIBUTE,
    stopOpacity: MUST_USE_ATTRIBUTE,
    stroke: MUST_USE_ATTRIBUTE,
    strokeDasharray: MUST_USE_ATTRIBUTE,
    strokeLinecap: MUST_USE_ATTRIBUTE,
    strokeOpacity: MUST_USE_ATTRIBUTE,
    strokeWidth: MUST_USE_ATTRIBUTE,
    textAnchor: MUST_USE_ATTRIBUTE,
    transform: MUST_USE_ATTRIBUTE,
    version: MUST_USE_ATTRIBUTE,
    viewBox: MUST_USE_ATTRIBUTE,
    x1: MUST_USE_ATTRIBUTE,
    x2: MUST_USE_ATTRIBUTE,
    x: MUST_USE_ATTRIBUTE,
    y1: MUST_USE_ATTRIBUTE,
    y2: MUST_USE_ATTRIBUTE,
    y: MUST_USE_ATTRIBUTE
  },
  DOMAttributeNames: {
    fillOpacity: 'fill-opacity',
    fontFamily: 'font-family',
    fontSize: 'font-size',
    gradientTransform: 'gradientTransform',
    gradientUnits: 'gradientUnits',
    markerEnd: 'marker-end',
    markerMid: 'marker-mid',
    markerStart: 'marker-start',
    patternContentUnits: 'patternContentUnits',
    patternUnits: 'patternUnits',
    preserveAspectRatio: 'preserveAspectRatio',
    spreadMethod: 'spreadMethod',
    stopColor: 'stop-color',
    stopOpacity: 'stop-opacity',
    strokeDasharray: 'stroke-dasharray',
    strokeLinecap: 'stroke-linecap',
    strokeOpacity: 'stroke-opacity',
    strokeWidth: 'stroke-width',
    textAnchor: 'text-anchor',
    viewBox: 'viewBox'
  }
};

module.exports = SVGDOMPropertyConfig;

},{"./DOMProperty":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/DOMProperty.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/SelectEventPlugin.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule SelectEventPlugin
 */

"use strict";

var EventConstants = require("./EventConstants");
var EventPropagators = require("./EventPropagators");
var ReactInputSelection = require("./ReactInputSelection");
var SyntheticEvent = require("./SyntheticEvent");

var getActiveElement = require("./getActiveElement");
var isTextInputElement = require("./isTextInputElement");
var keyOf = require("./keyOf");
var shallowEqual = require("./shallowEqual");

var topLevelTypes = EventConstants.topLevelTypes;

var eventTypes = {
  select: {
    phasedRegistrationNames: {
      bubbled: keyOf({onSelect: null}),
      captured: keyOf({onSelectCapture: null})
    },
    dependencies: [
      topLevelTypes.topBlur,
      topLevelTypes.topContextMenu,
      topLevelTypes.topFocus,
      topLevelTypes.topKeyDown,
      topLevelTypes.topMouseDown,
      topLevelTypes.topMouseUp,
      topLevelTypes.topSelectionChange
    ]
  }
};

var activeElement = null;
var activeElementID = null;
var lastSelection = null;
var mouseDown = false;

/**
 * Get an object which is a unique representation of the current selection.
 *
 * The return value will not be consistent across nodes or browsers, but
 * two identical selections on the same node will return identical objects.
 *
 * @param {DOMElement} node
 * @param {object}
 */
function getSelection(node) {
  if ('selectionStart' in node &&
      ReactInputSelection.hasSelectionCapabilities(node)) {
    return {
      start: node.selectionStart,
      end: node.selectionEnd
    };
  } else if (document.selection) {
    var range = document.selection.createRange();
    return {
      parentElement: range.parentElement(),
      text: range.text,
      top: range.boundingTop,
      left: range.boundingLeft
    };
  } else {
    var selection = window.getSelection();
    return {
      anchorNode: selection.anchorNode,
      anchorOffset: selection.anchorOffset,
      focusNode: selection.focusNode,
      focusOffset: selection.focusOffset
    };
  }
}

/**
 * Poll selection to see whether it's changed.
 *
 * @param {object} nativeEvent
 * @return {?SyntheticEvent}
 */
function constructSelectEvent(nativeEvent) {
  // Ensure we have the right element, and that the user is not dragging a
  // selection (this matches native `select` event behavior). In HTML5, select
  // fires only on input and textarea thus if there's no focused element we
  // won't dispatch.
  if (mouseDown ||
      activeElement == null ||
      activeElement != getActiveElement()) {
    return;
  }

  // Only fire when selection has actually changed.
  var currentSelection = getSelection(activeElement);
  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
    lastSelection = currentSelection;

    var syntheticEvent = SyntheticEvent.getPooled(
      eventTypes.select,
      activeElementID,
      nativeEvent
    );

    syntheticEvent.type = 'select';
    syntheticEvent.target = activeElement;

    EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);

    return syntheticEvent;
  }
}

/**
 * This plugin creates an `onSelect` event that normalizes select events
 * across form elements.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - contentEditable
 *
 * This differs from native browser implementations in the following ways:
 * - Fires on contentEditable fields as well as inputs.
 * - Fires for collapsed selection.
 * - Fires after user input.
 */
var SelectEventPlugin = {

  eventTypes: eventTypes,

  /**
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function(
      topLevelType,
      topLevelTarget,
      topLevelTargetID,
      nativeEvent) {

    switch (topLevelType) {
      // Track the input node that has focus.
      case topLevelTypes.topFocus:
        if (isTextInputElement(topLevelTarget) ||
            topLevelTarget.contentEditable === 'true') {
          activeElement = topLevelTarget;
          activeElementID = topLevelTargetID;
          lastSelection = null;
        }
        break;
      case topLevelTypes.topBlur:
        activeElement = null;
        activeElementID = null;
        lastSelection = null;
        break;

      // Don't fire the event while the user is dragging. This matches the
      // semantics of the native select event.
      case topLevelTypes.topMouseDown:
        mouseDown = true;
        break;
      case topLevelTypes.topContextMenu:
      case topLevelTypes.topMouseUp:
        mouseDown = false;
        return constructSelectEvent(nativeEvent);

      // Chrome and IE fire non-standard event when selection is changed (and
      // sometimes when it hasn't).
      // Firefox doesn't support selectionchange, so check selection status
      // after each key entry. The selection changes after keydown and before
      // keyup, but we check on keydown as well in the case of holding down a
      // key, when multiple keydown events are fired but only one keyup is.
      case topLevelTypes.topSelectionChange:
      case topLevelTypes.topKeyDown:
      case topLevelTypes.topKeyUp:
        return constructSelectEvent(nativeEvent);
    }
  }
};

module.exports = SelectEventPlugin;

},{"./EventConstants":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/EventConstants.js","./EventPropagators":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/EventPropagators.js","./ReactInputSelection":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactInputSelection.js","./SyntheticEvent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/SyntheticEvent.js","./getActiveElement":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/getActiveElement.js","./isTextInputElement":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/isTextInputElement.js","./keyOf":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/keyOf.js","./shallowEqual":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/shallowEqual.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ServerReactRootIndex.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ServerReactRootIndex
 * @typechecks
 */

"use strict";

/**
 * Size of the reactRoot ID space. We generate random numbers for React root
 * IDs and if there's a collision the events and DOM update system will
 * get confused. In the future we need a way to generate GUIDs but for
 * now this will work on a smaller scale.
 */
var GLOBAL_MOUNT_POINT_MAX = Math.pow(2, 53);

var ServerReactRootIndex = {
  createReactRootIndex: function() {
    return Math.ceil(Math.random() * GLOBAL_MOUNT_POINT_MAX);
  }
};

module.exports = ServerReactRootIndex;

},{}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/SimpleEventPlugin.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule SimpleEventPlugin
 */

"use strict";

var EventConstants = require("./EventConstants");
var EventPluginUtils = require("./EventPluginUtils");
var EventPropagators = require("./EventPropagators");
var SyntheticClipboardEvent = require("./SyntheticClipboardEvent");
var SyntheticEvent = require("./SyntheticEvent");
var SyntheticFocusEvent = require("./SyntheticFocusEvent");
var SyntheticKeyboardEvent = require("./SyntheticKeyboardEvent");
var SyntheticMouseEvent = require("./SyntheticMouseEvent");
var SyntheticDragEvent = require("./SyntheticDragEvent");
var SyntheticTouchEvent = require("./SyntheticTouchEvent");
var SyntheticUIEvent = require("./SyntheticUIEvent");
var SyntheticWheelEvent = require("./SyntheticWheelEvent");

var invariant = require("./invariant");
var keyOf = require("./keyOf");

var topLevelTypes = EventConstants.topLevelTypes;

var eventTypes = {
  blur: {
    phasedRegistrationNames: {
      bubbled: keyOf({onBlur: true}),
      captured: keyOf({onBlurCapture: true})
    }
  },
  click: {
    phasedRegistrationNames: {
      bubbled: keyOf({onClick: true}),
      captured: keyOf({onClickCapture: true})
    }
  },
  contextMenu: {
    phasedRegistrationNames: {
      bubbled: keyOf({onContextMenu: true}),
      captured: keyOf({onContextMenuCapture: true})
    }
  },
  copy: {
    phasedRegistrationNames: {
      bubbled: keyOf({onCopy: true}),
      captured: keyOf({onCopyCapture: true})
    }
  },
  cut: {
    phasedRegistrationNames: {
      bubbled: keyOf({onCut: true}),
      captured: keyOf({onCutCapture: true})
    }
  },
  doubleClick: {
    phasedRegistrationNames: {
      bubbled: keyOf({onDoubleClick: true}),
      captured: keyOf({onDoubleClickCapture: true})
    }
  },
  drag: {
    phasedRegistrationNames: {
      bubbled: keyOf({onDrag: true}),
      captured: keyOf({onDragCapture: true})
    }
  },
  dragEnd: {
    phasedRegistrationNames: {
      bubbled: keyOf({onDragEnd: true}),
      captured: keyOf({onDragEndCapture: true})
    }
  },
  dragEnter: {
    phasedRegistrationNames: {
      bubbled: keyOf({onDragEnter: true}),
      captured: keyOf({onDragEnterCapture: true})
    }
  },
  dragExit: {
    phasedRegistrationNames: {
      bubbled: keyOf({onDragExit: true}),
      captured: keyOf({onDragExitCapture: true})
    }
  },
  dragLeave: {
    phasedRegistrationNames: {
      bubbled: keyOf({onDragLeave: true}),
      captured: keyOf({onDragLeaveCapture: true})
    }
  },
  dragOver: {
    phasedRegistrationNames: {
      bubbled: keyOf({onDragOver: true}),
      captured: keyOf({onDragOverCapture: true})
    }
  },
  dragStart: {
    phasedRegistrationNames: {
      bubbled: keyOf({onDragStart: true}),
      captured: keyOf({onDragStartCapture: true})
    }
  },
  drop: {
    phasedRegistrationNames: {
      bubbled: keyOf({onDrop: true}),
      captured: keyOf({onDropCapture: true})
    }
  },
  focus: {
    phasedRegistrationNames: {
      bubbled: keyOf({onFocus: true}),
      captured: keyOf({onFocusCapture: true})
    }
  },
  input: {
    phasedRegistrationNames: {
      bubbled: keyOf({onInput: true}),
      captured: keyOf({onInputCapture: true})
    }
  },
  keyDown: {
    phasedRegistrationNames: {
      bubbled: keyOf({onKeyDown: true}),
      captured: keyOf({onKeyDownCapture: true})
    }
  },
  keyPress: {
    phasedRegistrationNames: {
      bubbled: keyOf({onKeyPress: true}),
      captured: keyOf({onKeyPressCapture: true})
    }
  },
  keyUp: {
    phasedRegistrationNames: {
      bubbled: keyOf({onKeyUp: true}),
      captured: keyOf({onKeyUpCapture: true})
    }
  },
  load: {
    phasedRegistrationNames: {
      bubbled: keyOf({onLoad: true}),
      captured: keyOf({onLoadCapture: true})
    }
  },
  error: {
    phasedRegistrationNames: {
      bubbled: keyOf({onError: true}),
      captured: keyOf({onErrorCapture: true})
    }
  },
  // Note: We do not allow listening to mouseOver events. Instead, use the
  // onMouseEnter/onMouseLeave created by `EnterLeaveEventPlugin`.
  mouseDown: {
    phasedRegistrationNames: {
      bubbled: keyOf({onMouseDown: true}),
      captured: keyOf({onMouseDownCapture: true})
    }
  },
  mouseMove: {
    phasedRegistrationNames: {
      bubbled: keyOf({onMouseMove: true}),
      captured: keyOf({onMouseMoveCapture: true})
    }
  },
  mouseOut: {
    phasedRegistrationNames: {
      bubbled: keyOf({onMouseOut: true}),
      captured: keyOf({onMouseOutCapture: true})
    }
  },
  mouseOver: {
    phasedRegistrationNames: {
      bubbled: keyOf({onMouseOver: true}),
      captured: keyOf({onMouseOverCapture: true})
    }
  },
  mouseUp: {
    phasedRegistrationNames: {
      bubbled: keyOf({onMouseUp: true}),
      captured: keyOf({onMouseUpCapture: true})
    }
  },
  paste: {
    phasedRegistrationNames: {
      bubbled: keyOf({onPaste: true}),
      captured: keyOf({onPasteCapture: true})
    }
  },
  reset: {
    phasedRegistrationNames: {
      bubbled: keyOf({onReset: true}),
      captured: keyOf({onResetCapture: true})
    }
  },
  scroll: {
    phasedRegistrationNames: {
      bubbled: keyOf({onScroll: true}),
      captured: keyOf({onScrollCapture: true})
    }
  },
  submit: {
    phasedRegistrationNames: {
      bubbled: keyOf({onSubmit: true}),
      captured: keyOf({onSubmitCapture: true})
    }
  },
  touchCancel: {
    phasedRegistrationNames: {
      bubbled: keyOf({onTouchCancel: true}),
      captured: keyOf({onTouchCancelCapture: true})
    }
  },
  touchEnd: {
    phasedRegistrationNames: {
      bubbled: keyOf({onTouchEnd: true}),
      captured: keyOf({onTouchEndCapture: true})
    }
  },
  touchMove: {
    phasedRegistrationNames: {
      bubbled: keyOf({onTouchMove: true}),
      captured: keyOf({onTouchMoveCapture: true})
    }
  },
  touchStart: {
    phasedRegistrationNames: {
      bubbled: keyOf({onTouchStart: true}),
      captured: keyOf({onTouchStartCapture: true})
    }
  },
  wheel: {
    phasedRegistrationNames: {
      bubbled: keyOf({onWheel: true}),
      captured: keyOf({onWheelCapture: true})
    }
  }
};

var topLevelEventsToDispatchConfig = {
  topBlur:        eventTypes.blur,
  topClick:       eventTypes.click,
  topContextMenu: eventTypes.contextMenu,
  topCopy:        eventTypes.copy,
  topCut:         eventTypes.cut,
  topDoubleClick: eventTypes.doubleClick,
  topDrag:        eventTypes.drag,
  topDragEnd:     eventTypes.dragEnd,
  topDragEnter:   eventTypes.dragEnter,
  topDragExit:    eventTypes.dragExit,
  topDragLeave:   eventTypes.dragLeave,
  topDragOver:    eventTypes.dragOver,
  topDragStart:   eventTypes.dragStart,
  topDrop:        eventTypes.drop,
  topError:       eventTypes.error,
  topFocus:       eventTypes.focus,
  topInput:       eventTypes.input,
  topKeyDown:     eventTypes.keyDown,
  topKeyPress:    eventTypes.keyPress,
  topKeyUp:       eventTypes.keyUp,
  topLoad:        eventTypes.load,
  topMouseDown:   eventTypes.mouseDown,
  topMouseMove:   eventTypes.mouseMove,
  topMouseOut:    eventTypes.mouseOut,
  topMouseOver:   eventTypes.mouseOver,
  topMouseUp:     eventTypes.mouseUp,
  topPaste:       eventTypes.paste,
  topReset:       eventTypes.reset,
  topScroll:      eventTypes.scroll,
  topSubmit:      eventTypes.submit,
  topTouchCancel: eventTypes.touchCancel,
  topTouchEnd:    eventTypes.touchEnd,
  topTouchMove:   eventTypes.touchMove,
  topTouchStart:  eventTypes.touchStart,
  topWheel:       eventTypes.wheel
};

for (var topLevelType in topLevelEventsToDispatchConfig) {
  topLevelEventsToDispatchConfig[topLevelType].dependencies = [topLevelType];
}

var SimpleEventPlugin = {

  eventTypes: eventTypes,

  /**
   * Same as the default implementation, except cancels the event when return
   * value is false.
   *
   * @param {object} Event to be dispatched.
   * @param {function} Application-level callback.
   * @param {string} domID DOM ID to pass to the callback.
   */
  executeDispatch: function(event, listener, domID) {
    var returnValue = EventPluginUtils.executeDispatch(event, listener, domID);
    if (returnValue === false) {
      event.stopPropagation();
      event.preventDefault();
    }
  },

  /**
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function(
      topLevelType,
      topLevelTarget,
      topLevelTargetID,
      nativeEvent) {
    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
    if (!dispatchConfig) {
      return null;
    }
    var EventConstructor;
    switch (topLevelType) {
      case topLevelTypes.topInput:
      case topLevelTypes.topLoad:
      case topLevelTypes.topError:
      case topLevelTypes.topReset:
      case topLevelTypes.topSubmit:
        // HTML Events
        // @see http://www.w3.org/TR/html5/index.html#events-0
        EventConstructor = SyntheticEvent;
        break;
      case topLevelTypes.topKeyPress:
        // FireFox creates a keypress event for function keys too. This removes
        // the unwanted keypress events.
        if (nativeEvent.charCode === 0) {
          return null;
        }
        /* falls through */
      case topLevelTypes.topKeyDown:
      case topLevelTypes.topKeyUp:
        EventConstructor = SyntheticKeyboardEvent;
        break;
      case topLevelTypes.topBlur:
      case topLevelTypes.topFocus:
        EventConstructor = SyntheticFocusEvent;
        break;
      case topLevelTypes.topClick:
        // Firefox creates a click event on right mouse clicks. This removes the
        // unwanted click events.
        if (nativeEvent.button === 2) {
          return null;
        }
        /* falls through */
      case topLevelTypes.topContextMenu:
      case topLevelTypes.topDoubleClick:
      case topLevelTypes.topMouseDown:
      case topLevelTypes.topMouseMove:
      case topLevelTypes.topMouseOut:
      case topLevelTypes.topMouseOver:
      case topLevelTypes.topMouseUp:
        EventConstructor = SyntheticMouseEvent;
        break;
      case topLevelTypes.topDrag:
      case topLevelTypes.topDragEnd:
      case topLevelTypes.topDragEnter:
      case topLevelTypes.topDragExit:
      case topLevelTypes.topDragLeave:
      case topLevelTypes.topDragOver:
      case topLevelTypes.topDragStart:
      case topLevelTypes.topDrop:
        EventConstructor = SyntheticDragEvent;
        break;
      case topLevelTypes.topTouchCancel:
      case topLevelTypes.topTouchEnd:
      case topLevelTypes.topTouchMove:
      case topLevelTypes.topTouchStart:
        EventConstructor = SyntheticTouchEvent;
        break;
      case topLevelTypes.topScroll:
        EventConstructor = SyntheticUIEvent;
        break;
      case topLevelTypes.topWheel:
        EventConstructor = SyntheticWheelEvent;
        break;
      case topLevelTypes.topCopy:
      case topLevelTypes.topCut:
      case topLevelTypes.topPaste:
        EventConstructor = SyntheticClipboardEvent;
        break;
    }
    ("production" !== process.env.NODE_ENV ? invariant(
      EventConstructor,
      'SimpleEventPlugin: Unhandled event type, `%s`.',
      topLevelType
    ) : invariant(EventConstructor));
    var event = EventConstructor.getPooled(
      dispatchConfig,
      topLevelTargetID,
      nativeEvent
    );
    EventPropagators.accumulateTwoPhaseDispatches(event);
    return event;
  }

};

module.exports = SimpleEventPlugin;

}).call(this,require('_process'))
},{"./EventConstants":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/EventConstants.js","./EventPluginUtils":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/EventPluginUtils.js","./EventPropagators":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/EventPropagators.js","./SyntheticClipboardEvent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/SyntheticClipboardEvent.js","./SyntheticDragEvent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/SyntheticDragEvent.js","./SyntheticEvent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/SyntheticEvent.js","./SyntheticFocusEvent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/SyntheticFocusEvent.js","./SyntheticKeyboardEvent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/SyntheticKeyboardEvent.js","./SyntheticMouseEvent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/SyntheticMouseEvent.js","./SyntheticTouchEvent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/SyntheticTouchEvent.js","./SyntheticUIEvent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/SyntheticUIEvent.js","./SyntheticWheelEvent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/SyntheticWheelEvent.js","./invariant":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/invariant.js","./keyOf":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/keyOf.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/SyntheticClipboardEvent.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule SyntheticClipboardEvent
 * @typechecks static-only
 */

"use strict";

var SyntheticEvent = require("./SyntheticEvent");

/**
 * @interface Event
 * @see http://www.w3.org/TR/clipboard-apis/
 */
var ClipboardEventInterface = {
  clipboardData: function(event) {
    return (
      'clipboardData' in event ?
        event.clipboardData :
        window.clipboardData
    );
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent) {
  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
}

SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);

module.exports = SyntheticClipboardEvent;


},{"./SyntheticEvent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/SyntheticEvent.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/SyntheticCompositionEvent.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule SyntheticCompositionEvent
 * @typechecks static-only
 */

"use strict";

var SyntheticEvent = require("./SyntheticEvent");

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
 */
var CompositionEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticCompositionEvent(
  dispatchConfig,
  dispatchMarker,
  nativeEvent) {
  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
}

SyntheticEvent.augmentClass(
  SyntheticCompositionEvent,
  CompositionEventInterface
);

module.exports = SyntheticCompositionEvent;


},{"./SyntheticEvent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/SyntheticEvent.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/SyntheticDragEvent.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule SyntheticDragEvent
 * @typechecks static-only
 */

"use strict";

var SyntheticMouseEvent = require("./SyntheticMouseEvent");

/**
 * @interface DragEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var DragEventInterface = {
  dataTransfer: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent) {
  SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
}

SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);

module.exports = SyntheticDragEvent;

},{"./SyntheticMouseEvent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/SyntheticMouseEvent.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/SyntheticEvent.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule SyntheticEvent
 * @typechecks static-only
 */

"use strict";

var PooledClass = require("./PooledClass");

var emptyFunction = require("./emptyFunction");
var getEventTarget = require("./getEventTarget");
var merge = require("./merge");
var mergeInto = require("./mergeInto");

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var EventInterface = {
  type: null,
  target: getEventTarget,
  // currentTarget is set when dispatching; no use in copying it here
  currentTarget: emptyFunction.thatReturnsNull,
  eventPhase: null,
  bubbles: null,
  cancelable: null,
  timeStamp: function(event) {
    return event.timeStamp || Date.now();
  },
  defaultPrevented: null,
  isTrusted: null
};

/**
 * Synthetic events are dispatched by event plugins, typically in response to a
 * top-level event delegation handler.
 *
 * These systems should generally use pooling to reduce the frequency of garbage
 * collection. The system should check `isPersistent` to determine whether the
 * event should be released into the pool after being dispatched. Users that
 * need a persisted event should invoke `persist`.
 *
 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
 * normalizing browser quirks. Subclasses do not necessarily have to implement a
 * DOM interface; custom application-specific events can also subclass this.
 *
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 */
function SyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent) {
  this.dispatchConfig = dispatchConfig;
  this.dispatchMarker = dispatchMarker;
  this.nativeEvent = nativeEvent;

  var Interface = this.constructor.Interface;
  for (var propName in Interface) {
    if (!Interface.hasOwnProperty(propName)) {
      continue;
    }
    var normalize = Interface[propName];
    if (normalize) {
      this[propName] = normalize(nativeEvent);
    } else {
      this[propName] = nativeEvent[propName];
    }
  }

  var defaultPrevented = nativeEvent.defaultPrevented != null ?
    nativeEvent.defaultPrevented :
    nativeEvent.returnValue === false;
  if (defaultPrevented) {
    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
  } else {
    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
  }
  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
}

mergeInto(SyntheticEvent.prototype, {

  preventDefault: function() {
    this.defaultPrevented = true;
    var event = this.nativeEvent;
    event.preventDefault ? event.preventDefault() : event.returnValue = false;
    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
  },

  stopPropagation: function() {
    var event = this.nativeEvent;
    event.stopPropagation ? event.stopPropagation() : event.cancelBubble = true;
    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
  },

  /**
   * We release all dispatched `SyntheticEvent`s after each event loop, adding
   * them back into the pool. This allows a way to hold onto a reference that
   * won't be added back into the pool.
   */
  persist: function() {
    this.isPersistent = emptyFunction.thatReturnsTrue;
  },

  /**
   * Checks if this event should be released back into the pool.
   *
   * @return {boolean} True if this should not be released, false otherwise.
   */
  isPersistent: emptyFunction.thatReturnsFalse,

  /**
   * `PooledClass` looks for `destructor` on each instance it releases.
   */
  destructor: function() {
    var Interface = this.constructor.Interface;
    for (var propName in Interface) {
      this[propName] = null;
    }
    this.dispatchConfig = null;
    this.dispatchMarker = null;
    this.nativeEvent = null;
  }

});

SyntheticEvent.Interface = EventInterface;

/**
 * Helper to reduce boilerplate when creating subclasses.
 *
 * @param {function} Class
 * @param {?object} Interface
 */
SyntheticEvent.augmentClass = function(Class, Interface) {
  var Super = this;

  var prototype = Object.create(Super.prototype);
  mergeInto(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = merge(Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;

  PooledClass.addPoolingTo(Class, PooledClass.threeArgumentPooler);
};

PooledClass.addPoolingTo(SyntheticEvent, PooledClass.threeArgumentPooler);

module.exports = SyntheticEvent;

},{"./PooledClass":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/PooledClass.js","./emptyFunction":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/emptyFunction.js","./getEventTarget":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/getEventTarget.js","./merge":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/merge.js","./mergeInto":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/mergeInto.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/SyntheticFocusEvent.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule SyntheticFocusEvent
 * @typechecks static-only
 */

"use strict";

var SyntheticUIEvent = require("./SyntheticUIEvent");

/**
 * @interface FocusEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var FocusEventInterface = {
  relatedTarget: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent) {
  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
}

SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);

module.exports = SyntheticFocusEvent;

},{"./SyntheticUIEvent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/SyntheticUIEvent.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/SyntheticInputEvent.js":[function(require,module,exports){
/**
 * Copyright 2013 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule SyntheticInputEvent
 * @typechecks static-only
 */

"use strict";

var SyntheticEvent = require("./SyntheticEvent");

/**
 * @interface Event
 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
 *      /#events-inputevents
 */
var InputEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticInputEvent(
  dispatchConfig,
  dispatchMarker,
  nativeEvent) {
  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
}

SyntheticEvent.augmentClass(
  SyntheticInputEvent,
  InputEventInterface
);

module.exports = SyntheticInputEvent;


},{"./SyntheticEvent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/SyntheticEvent.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/SyntheticKeyboardEvent.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule SyntheticKeyboardEvent
 * @typechecks static-only
 */

"use strict";

var SyntheticUIEvent = require("./SyntheticUIEvent");

var getEventKey = require("./getEventKey");
var getEventModifierState = require("./getEventModifierState");

/**
 * @interface KeyboardEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var KeyboardEventInterface = {
  key: getEventKey,
  location: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  repeat: null,
  locale: null,
  getModifierState: getEventModifierState,
  // Legacy Interface
  charCode: function(event) {
    // `charCode` is the result of a KeyPress event and represents the value of
    // the actual printable character.

    // KeyPress is deprecated but its replacement is not yet final and not
    // implemented in any major browser.
    if (event.type === 'keypress') {
      // IE8 does not implement "charCode", but "keyCode" has the correct value.
      return 'charCode' in event ? event.charCode : event.keyCode;
    }
    return 0;
  },
  keyCode: function(event) {
    // `keyCode` is the result of a KeyDown/Up event and represents the value of
    // physical keyboard key.

    // The actual meaning of the value depends on the users' keyboard layout
    // which cannot be detected. Assuming that it is a US keyboard layout
    // provides a surprisingly accurate mapping for US and European users.
    // Due to this, it is left to the user to implement at this time.
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  },
  which: function(event) {
    // `which` is an alias for either `keyCode` or `charCode` depending on the
    // type of the event. There is no need to determine the type of the event
    // as `keyCode` and `charCode` are either aliased or default to zero.
    return event.keyCode || event.charCode;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent) {
  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
}

SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);

module.exports = SyntheticKeyboardEvent;

},{"./SyntheticUIEvent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/SyntheticUIEvent.js","./getEventKey":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/getEventKey.js","./getEventModifierState":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/getEventModifierState.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/SyntheticMouseEvent.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule SyntheticMouseEvent
 * @typechecks static-only
 */

"use strict";

var SyntheticUIEvent = require("./SyntheticUIEvent");
var ViewportMetrics = require("./ViewportMetrics");

var getEventModifierState = require("./getEventModifierState");

/**
 * @interface MouseEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var MouseEventInterface = {
  screenX: null,
  screenY: null,
  clientX: null,
  clientY: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  getModifierState: getEventModifierState,
  button: function(event) {
    // Webkit, Firefox, IE9+
    // which:  1 2 3
    // button: 0 1 2 (standard)
    var button = event.button;
    if ('which' in event) {
      return button;
    }
    // IE<9
    // which:  undefined
    // button: 0 0 0
    // button: 1 4 2 (onmouseup)
    return button === 2 ? 2 : button === 4 ? 1 : 0;
  },
  buttons: null,
  relatedTarget: function(event) {
    return event.relatedTarget || (
      event.fromElement === event.srcElement ?
        event.toElement :
        event.fromElement
    );
  },
  // "Proprietary" Interface.
  pageX: function(event) {
    return 'pageX' in event ?
      event.pageX :
      event.clientX + ViewportMetrics.currentScrollLeft;
  },
  pageY: function(event) {
    return 'pageY' in event ?
      event.pageY :
      event.clientY + ViewportMetrics.currentScrollTop;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent) {
  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
}

SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);

module.exports = SyntheticMouseEvent;

},{"./SyntheticUIEvent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/SyntheticUIEvent.js","./ViewportMetrics":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ViewportMetrics.js","./getEventModifierState":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/getEventModifierState.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/SyntheticTouchEvent.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule SyntheticTouchEvent
 * @typechecks static-only
 */

"use strict";

var SyntheticUIEvent = require("./SyntheticUIEvent");

var getEventModifierState = require("./getEventModifierState");

/**
 * @interface TouchEvent
 * @see http://www.w3.org/TR/touch-events/
 */
var TouchEventInterface = {
  touches: null,
  targetTouches: null,
  changedTouches: null,
  altKey: null,
  metaKey: null,
  ctrlKey: null,
  shiftKey: null,
  getModifierState: getEventModifierState
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent) {
  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
}

SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);

module.exports = SyntheticTouchEvent;

},{"./SyntheticUIEvent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/SyntheticUIEvent.js","./getEventModifierState":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/getEventModifierState.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/SyntheticUIEvent.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule SyntheticUIEvent
 * @typechecks static-only
 */

"use strict";

var SyntheticEvent = require("./SyntheticEvent");

var getEventTarget = require("./getEventTarget");

/**
 * @interface UIEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var UIEventInterface = {
  view: function(event) {
    if (event.view) {
      return event.view;
    }

    var target = getEventTarget(event);
    if (target != null && target.window === target) {
      // target is a window object
      return target;
    }

    var doc = target.ownerDocument;
    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
    if (doc) {
      return doc.defaultView || doc.parentWindow;
    } else {
      return window;
    }
  },
  detail: function(event) {
    return event.detail || 0;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent) {
  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
}

SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);

module.exports = SyntheticUIEvent;

},{"./SyntheticEvent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/SyntheticEvent.js","./getEventTarget":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/getEventTarget.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/SyntheticWheelEvent.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule SyntheticWheelEvent
 * @typechecks static-only
 */

"use strict";

var SyntheticMouseEvent = require("./SyntheticMouseEvent");

/**
 * @interface WheelEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var WheelEventInterface = {
  deltaX: function(event) {
    return (
      'deltaX' in event ? event.deltaX :
      // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
      'wheelDeltaX' in event ? -event.wheelDeltaX : 0
    );
  },
  deltaY: function(event) {
    return (
      'deltaY' in event ? event.deltaY :
      // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
      'wheelDeltaY' in event ? -event.wheelDeltaY :
      // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
      'wheelDelta' in event ? -event.wheelDelta : 0
    );
  },
  deltaZ: null,

  // Browsers without "deltaMode" is reporting in raw wheel delta where one
  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
  deltaMode: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticMouseEvent}
 */
function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent) {
  SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent);
}

SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);

module.exports = SyntheticWheelEvent;

},{"./SyntheticMouseEvent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/SyntheticMouseEvent.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/Transaction.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule Transaction
 */

"use strict";

var invariant = require("./invariant");

/**
 * `Transaction` creates a black box that is able to wrap any method such that
 * certain invariants are maintained before and after the method is invoked
 * (Even if an exception is thrown while invoking the wrapped method). Whoever
 * instantiates a transaction can provide enforcers of the invariants at
 * creation time. The `Transaction` class itself will supply one additional
 * automatic invariant for you - the invariant that any transaction instance
 * should not be run while it is already being run. You would typically create a
 * single instance of a `Transaction` for reuse multiple times, that potentially
 * is used to wrap several different methods. Wrappers are extremely simple -
 * they only require implementing two methods.
 *
 * <pre>
 *                       wrappers (injected at creation time)
 *                                      +        +
 *                                      |        |
 *                    +-----------------|--------|--------------+
 *                    |                 v        |              |
 *                    |      +---------------+   |              |
 *                    |   +--|    wrapper1   |---|----+         |
 *                    |   |  +---------------+   v    |         |
 *                    |   |          +-------------+  |         |
 *                    |   |     +----|   wrapper2  |--------+   |
 *                    |   |     |    +-------------+  |     |   |
 *                    |   |     |                     |     |   |
 *                    |   v     v                     v     v   | wrapper
 *                    | +---+ +---+   +---------+   +---+ +---+ | invariants
 * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained
 * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | +---+ +---+   +---------+   +---+ +---+ |
 *                    |  initialize                    close    |
 *                    +-----------------------------------------+
 * </pre>
 *
 * Use cases:
 * - Preserving the input selection ranges before/after reconciliation.
 *   Restoring selection even in the event of an unexpected error.
 * - Deactivating events while rearranging the DOM, preventing blurs/focuses,
 *   while guaranteeing that afterwards, the event system is reactivated.
 * - Flushing a queue of collected DOM mutations to the main UI thread after a
 *   reconciliation takes place in a worker thread.
 * - Invoking any collected `componentDidUpdate` callbacks after rendering new
 *   content.
 * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue
 *   to preserve the `scrollTop` (an automatic scroll aware DOM).
 * - (Future use case): Layout calculations before and after DOM upates.
 *
 * Transactional plugin API:
 * - A module that has an `initialize` method that returns any precomputation.
 * - and a `close` method that accepts the precomputation. `close` is invoked
 *   when the wrapped process is completed, or has failed.
 *
 * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules
 * that implement `initialize` and `close`.
 * @return {Transaction} Single transaction for reuse in thread.
 *
 * @class Transaction
 */
var Mixin = {
  /**
   * Sets up this instance so that it is prepared for collecting metrics. Does
   * so such that this setup method may be used on an instance that is already
   * initialized, in a way that does not consume additional memory upon reuse.
   * That can be useful if you decide to make your subclass of this mixin a
   * "PooledClass".
   */
  reinitializeTransaction: function() {
    this.transactionWrappers = this.getTransactionWrappers();
    if (!this.wrapperInitData) {
      this.wrapperInitData = [];
    } else {
      this.wrapperInitData.length = 0;
    }
    this._isInTransaction = false;
  },

  _isInTransaction: false,

  /**
   * @abstract
   * @return {Array<TransactionWrapper>} Array of transaction wrappers.
   */
  getTransactionWrappers: null,

  isInTransaction: function() {
    return !!this._isInTransaction;
  },

  /**
   * Executes the function within a safety window. Use this for the top level
   * methods that result in large amounts of computation/mutations that would
   * need to be safety checked.
   *
   * @param {function} method Member of scope to call.
   * @param {Object} scope Scope to invoke from.
   * @param {Object?=} args... Arguments to pass to the method (optional).
   *                           Helps prevent need to bind in many cases.
   * @return Return value from `method`.
   */
  perform: function(method, scope, a, b, c, d, e, f) {
    ("production" !== process.env.NODE_ENV ? invariant(
      !this.isInTransaction(),
      'Transaction.perform(...): Cannot initialize a transaction when there ' +
      'is already an outstanding transaction.'
    ) : invariant(!this.isInTransaction()));
    var errorThrown;
    var ret;
    try {
      this._isInTransaction = true;
      // Catching errors makes debugging more difficult, so we start with
      // errorThrown set to true before setting it to false after calling
      // close -- if it's still set to true in the finally block, it means
      // one of these calls threw.
      errorThrown = true;
      this.initializeAll(0);
      ret = method.call(scope, a, b, c, d, e, f);
      errorThrown = false;
    } finally {
      try {
        if (errorThrown) {
          // If `method` throws, prefer to show that stack trace over any thrown
          // by invoking `closeAll`.
          try {
            this.closeAll(0);
          } catch (err) {
          }
        } else {
          // Since `method` didn't throw, we don't want to silence the exception
          // here.
          this.closeAll(0);
        }
      } finally {
        this._isInTransaction = false;
      }
    }
    return ret;
  },

  initializeAll: function(startIndex) {
    var transactionWrappers = this.transactionWrappers;
    for (var i = startIndex; i < transactionWrappers.length; i++) {
      var wrapper = transactionWrappers[i];
      try {
        // Catching errors makes debugging more difficult, so we start with the
        // OBSERVED_ERROR state before overwriting it with the real return value
        // of initialize -- if it's still set to OBSERVED_ERROR in the finally
        // block, it means wrapper.initialize threw.
        this.wrapperInitData[i] = Transaction.OBSERVED_ERROR;
        this.wrapperInitData[i] = wrapper.initialize ?
          wrapper.initialize.call(this) :
          null;
      } finally {
        if (this.wrapperInitData[i] === Transaction.OBSERVED_ERROR) {
          // The initializer for wrapper i threw an error; initialize the
          // remaining wrappers but silence any exceptions from them to ensure
          // that the first error is the one to bubble up.
          try {
            this.initializeAll(i + 1);
          } catch (err) {
          }
        }
      }
    }
  },

  /**
   * Invokes each of `this.transactionWrappers.close[i]` functions, passing into
   * them the respective return values of `this.transactionWrappers.init[i]`
   * (`close`rs that correspond to initializers that failed will not be
   * invoked).
   */
  closeAll: function(startIndex) {
    ("production" !== process.env.NODE_ENV ? invariant(
      this.isInTransaction(),
      'Transaction.closeAll(): Cannot close transaction when none are open.'
    ) : invariant(this.isInTransaction()));
    var transactionWrappers = this.transactionWrappers;
    for (var i = startIndex; i < transactionWrappers.length; i++) {
      var wrapper = transactionWrappers[i];
      var initData = this.wrapperInitData[i];
      var errorThrown;
      try {
        // Catching errors makes debugging more difficult, so we start with
        // errorThrown set to true before setting it to false after calling
        // close -- if it's still set to true in the finally block, it means
        // wrapper.close threw.
        errorThrown = true;
        if (initData !== Transaction.OBSERVED_ERROR) {
          wrapper.close && wrapper.close.call(this, initData);
        }
        errorThrown = false;
      } finally {
        if (errorThrown) {
          // The closer for wrapper i threw an error; close the remaining
          // wrappers but silence any exceptions from them to ensure that the
          // first error is the one to bubble up.
          try {
            this.closeAll(i + 1);
          } catch (e) {
          }
        }
      }
    }
    this.wrapperInitData.length = 0;
  }
};

var Transaction = {

  Mixin: Mixin,

  /**
   * Token to look for to determine if an error occured.
   */
  OBSERVED_ERROR: {}

};

module.exports = Transaction;

}).call(this,require('_process'))
},{"./invariant":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/invariant.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ViewportMetrics.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule ViewportMetrics
 */

"use strict";

var getUnboundedScrollPosition = require("./getUnboundedScrollPosition");

var ViewportMetrics = {

  currentScrollLeft: 0,

  currentScrollTop: 0,

  refreshScrollValues: function() {
    var scrollPosition = getUnboundedScrollPosition(window);
    ViewportMetrics.currentScrollLeft = scrollPosition.x;
    ViewportMetrics.currentScrollTop = scrollPosition.y;
  }

};

module.exports = ViewportMetrics;

},{"./getUnboundedScrollPosition":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/getUnboundedScrollPosition.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/accumulate.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule accumulate
 */

"use strict";

var invariant = require("./invariant");

/**
 * Accumulates items that must not be null or undefined.
 *
 * This is used to conserve memory by avoiding array allocations.
 *
 * @return {*|array<*>} An accumulation of items.
 */
function accumulate(current, next) {
  ("production" !== process.env.NODE_ENV ? invariant(
    next != null,
    'accumulate(...): Accumulated items must be not be null or undefined.'
  ) : invariant(next != null));
  if (current == null) {
    return next;
  } else {
    // Both are not empty. Warning: Never call x.concat(y) when you are not
    // certain that x is an Array (x could be a string with concat method).
    var currentIsArray = Array.isArray(current);
    var nextIsArray = Array.isArray(next);
    if (currentIsArray) {
      return current.concat(next);
    } else {
      if (nextIsArray) {
        return [current].concat(next);
      } else {
        return [current, next];
      }
    }
  }
}

module.exports = accumulate;

}).call(this,require('_process'))
},{"./invariant":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/invariant.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/adler32.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule adler32
 */

/* jslint bitwise:true */

"use strict";

var MOD = 65521;

// This is a clean-room implementation of adler32 designed for detecting
// if markup is not what we expect it to be. It does not need to be
// cryptographically strong, only reasonable good at detecting if markup
// generated on the server is different than that on the client.
function adler32(data) {
  var a = 1;
  var b = 0;
  for (var i = 0; i < data.length; i++) {
    a = (a + data.charCodeAt(i)) % MOD;
    b = (b + a) % MOD;
  }
  return a | (b << 16);
}

module.exports = adler32;

},{}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/cloneWithProps.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @typechecks
 * @providesModule cloneWithProps
 */

"use strict";

var ReactPropTransferer = require("./ReactPropTransferer");

var keyOf = require("./keyOf");
var warning = require("./warning");

var CHILDREN_PROP = keyOf({children: null});

/**
 * Sometimes you want to change the props of a child passed to you. Usually
 * this is to add a CSS class.
 *
 * @param {object} child child component you'd like to clone
 * @param {object} props props you'd like to modify. They will be merged
 * as if you used `transferPropsTo()`.
 * @return {object} a clone of child with props merged in.
 */
function cloneWithProps(child, props) {
  if ("production" !== process.env.NODE_ENV) {
    ("production" !== process.env.NODE_ENV ? warning(
      !child.props.ref,
      'You are calling cloneWithProps() on a child with a ref. This is ' +
      'dangerous because you\'re creating a new child which will not be ' +
      'added as a ref to its parent.'
    ) : null);
  }

  var newProps = ReactPropTransferer.mergeProps(props, child.props);

  // Use `child.props.children` if it is provided.
  if (!newProps.hasOwnProperty(CHILDREN_PROP) &&
      child.props.hasOwnProperty(CHILDREN_PROP)) {
    newProps.children = child.props.children;
  }

  // The current API doesn't retain _owner and _context, which is why this
  // doesn't use ReactDescriptor.cloneAndReplaceProps.
  return child.constructor(newProps);
}

module.exports = cloneWithProps;

}).call(this,require('_process'))
},{"./ReactPropTransferer":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactPropTransferer.js","./keyOf":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/keyOf.js","./warning":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/warning.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/containsNode.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule containsNode
 * @typechecks
 */

var isTextNode = require("./isTextNode");

/*jslint bitwise:true */

/**
 * Checks if a given DOM node contains or is another DOM node.
 *
 * @param {?DOMNode} outerNode Outer DOM node.
 * @param {?DOMNode} innerNode Inner DOM node.
 * @return {boolean} True if `outerNode` contains or is `innerNode`.
 */
function containsNode(outerNode, innerNode) {
  if (!outerNode || !innerNode) {
    return false;
  } else if (outerNode === innerNode) {
    return true;
  } else if (isTextNode(outerNode)) {
    return false;
  } else if (isTextNode(innerNode)) {
    return containsNode(outerNode, innerNode.parentNode);
  } else if (outerNode.contains) {
    return outerNode.contains(innerNode);
  } else if (outerNode.compareDocumentPosition) {
    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
  } else {
    return false;
  }
}

module.exports = containsNode;

},{"./isTextNode":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/isTextNode.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/copyProperties.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule copyProperties
 */

/**
 * Copy properties from one or more objects (up to 5) into the first object.
 * This is a shallow copy. It mutates the first object and also returns it.
 *
 * NOTE: `arguments` has a very significant performance penalty, which is why
 * we don't support unlimited arguments.
 */
function copyProperties(obj, a, b, c, d, e, f) {
  obj = obj || {};

  if ("production" !== process.env.NODE_ENV) {
    if (f) {
      throw new Error('Too many arguments passed to copyProperties');
    }
  }

  var args = [a, b, c, d, e];
  var ii = 0, v;
  while (args[ii]) {
    v = args[ii++];
    for (var k in v) {
      obj[k] = v[k];
    }

    // IE ignores toString in object iteration.. See:
    // webreflection.blogspot.com/2007/07/quick-fix-internet-explorer-and.html
    if (v.hasOwnProperty && v.hasOwnProperty('toString') &&
        (typeof v.toString != 'undefined') && (obj.toString !== v.toString)) {
      obj.toString = v.toString;
    }
  }

  return obj;
}

module.exports = copyProperties;

}).call(this,require('_process'))
},{"_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/createArrayFrom.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule createArrayFrom
 * @typechecks
 */

var toArray = require("./toArray");

/**
 * Perform a heuristic test to determine if an object is "array-like".
 *
 *   A monk asked Joshu, a Zen master, "Has a dog Buddha nature?"
 *   Joshu replied: "Mu."
 *
 * This function determines if its argument has "array nature": it returns
 * true if the argument is an actual array, an `arguments' object, or an
 * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).
 *
 * It will return false for other array-like objects like Filelist.
 *
 * @param {*} obj
 * @return {boolean}
 */
function hasArrayNature(obj) {
  return (
    // not null/false
    !!obj &&
    // arrays are objects, NodeLists are functions in Safari
    (typeof obj == 'object' || typeof obj == 'function') &&
    // quacks like an array
    ('length' in obj) &&
    // not window
    !('setInterval' in obj) &&
    // no DOM node should be considered an array-like
    // a 'select' element has 'length' and 'item' properties on IE8
    (typeof obj.nodeType != 'number') &&
    (
      // a real array
      (// HTMLCollection/NodeList
      (Array.isArray(obj) ||
      // arguments
      ('callee' in obj) || 'item' in obj))
    )
  );
}

/**
 * Ensure that the argument is an array by wrapping it in an array if it is not.
 * Creates a copy of the argument if it is already an array.
 *
 * This is mostly useful idiomatically:
 *
 *   var createArrayFrom = require('createArrayFrom');
 *
 *   function takesOneOrMoreThings(things) {
 *     things = createArrayFrom(things);
 *     ...
 *   }
 *
 * This allows you to treat `things' as an array, but accept scalars in the API.
 *
 * If you need to convert an array-like object, like `arguments`, into an array
 * use toArray instead.
 *
 * @param {*} obj
 * @return {array}
 */
function createArrayFrom(obj) {
  if (!hasArrayNature(obj)) {
    return [obj];
  } else if (Array.isArray(obj)) {
    return obj.slice();
  } else {
    return toArray(obj);
  }
}

module.exports = createArrayFrom;

},{"./toArray":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/toArray.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/createFullPageComponent.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule createFullPageComponent
 * @typechecks
 */

"use strict";

// Defeat circular references by requiring this directly.
var ReactCompositeComponent = require("./ReactCompositeComponent");

var invariant = require("./invariant");

/**
 * Create a component that will throw an exception when unmounted.
 *
 * Components like <html> <head> and <body> can't be removed or added
 * easily in a cross-browser way, however it's valuable to be able to
 * take advantage of React's reconciliation for styling and <title>
 * management. So we just document it and throw in dangerous cases.
 *
 * @param {function} componentClass convenience constructor to wrap
 * @return {function} convenience constructor of new component
 */
function createFullPageComponent(componentClass) {
  var FullPageComponent = ReactCompositeComponent.createClass({
    displayName: 'ReactFullPageComponent' + (
      componentClass.type.displayName || ''
    ),

    componentWillUnmount: function() {
      ("production" !== process.env.NODE_ENV ? invariant(
        false,
        '%s tried to unmount. Because of cross-browser quirks it is ' +
        'impossible to unmount some top-level components (eg <html>, <head>, ' +
        'and <body>) reliably and efficiently. To fix this, have a single ' +
        'top-level component that never unmounts render these elements.',
        this.constructor.displayName
      ) : invariant(false));
    },

    render: function() {
      return this.transferPropsTo(componentClass(null, this.props.children));
    }
  });

  return FullPageComponent;
}

module.exports = createFullPageComponent;

}).call(this,require('_process'))
},{"./ReactCompositeComponent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactCompositeComponent.js","./invariant":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/invariant.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/createNodesFromMarkup.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule createNodesFromMarkup
 * @typechecks
 */

/*jslint evil: true, sub: true */

var ExecutionEnvironment = require("./ExecutionEnvironment");

var createArrayFrom = require("./createArrayFrom");
var getMarkupWrap = require("./getMarkupWrap");
var invariant = require("./invariant");

/**
 * Dummy container used to render all markup.
 */
var dummyNode =
  ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

/**
 * Pattern used by `getNodeName`.
 */
var nodeNamePattern = /^\s*<(\w+)/;

/**
 * Extracts the `nodeName` of the first element in a string of markup.
 *
 * @param {string} markup String of markup.
 * @return {?string} Node name of the supplied markup.
 */
function getNodeName(markup) {
  var nodeNameMatch = markup.match(nodeNamePattern);
  return nodeNameMatch && nodeNameMatch[1].toLowerCase();
}

/**
 * Creates an array containing the nodes rendered from the supplied markup. The
 * optionally supplied `handleScript` function will be invoked once for each
 * <script> element that is rendered. If no `handleScript` function is supplied,
 * an exception is thrown if any <script> elements are rendered.
 *
 * @param {string} markup A string of valid HTML markup.
 * @param {?function} handleScript Invoked once for each rendered <script>.
 * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.
 */
function createNodesFromMarkup(markup, handleScript) {
  var node = dummyNode;
  ("production" !== process.env.NODE_ENV ? invariant(!!dummyNode, 'createNodesFromMarkup dummy not initialized') : invariant(!!dummyNode));
  var nodeName = getNodeName(markup);

  var wrap = nodeName && getMarkupWrap(nodeName);
  if (wrap) {
    node.innerHTML = wrap[1] + markup + wrap[2];

    var wrapDepth = wrap[0];
    while (wrapDepth--) {
      node = node.lastChild;
    }
  } else {
    node.innerHTML = markup;
  }

  var scripts = node.getElementsByTagName('script');
  if (scripts.length) {
    ("production" !== process.env.NODE_ENV ? invariant(
      handleScript,
      'createNodesFromMarkup(...): Unexpected <script> element rendered.'
    ) : invariant(handleScript));
    createArrayFrom(scripts).forEach(handleScript);
  }

  var nodes = createArrayFrom(node.childNodes);
  while (node.lastChild) {
    node.removeChild(node.lastChild);
  }
  return nodes;
}

module.exports = createNodesFromMarkup;

}).call(this,require('_process'))
},{"./ExecutionEnvironment":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ExecutionEnvironment.js","./createArrayFrom":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/createArrayFrom.js","./getMarkupWrap":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/getMarkupWrap.js","./invariant":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/invariant.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/cx.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule cx
 */

/**
 * This function is used to mark string literals representing CSS class names
 * so that they can be transformed statically. This allows for modularization
 * and minification of CSS class names.
 *
 * In static_upstream, this function is actually implemented, but it should
 * eventually be replaced with something more descriptive, and the transform
 * that is used in the main stack should be ported for use elsewhere.
 *
 * @param string|object className to modularize, or an object of key/values.
 *                      In the object case, the values are conditions that
 *                      determine if the className keys should be included.
 * @param [string ...]  Variable list of classNames in the string case.
 * @return string       Renderable space-separated CSS className.
 */
function cx(classNames) {
  if (typeof classNames == 'object') {
    return Object.keys(classNames).filter(function(className) {
      return classNames[className];
    }).join(' ');
  } else {
    return Array.prototype.join.call(arguments, ' ');
  }
}

module.exports = cx;

},{}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/dangerousStyleValue.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule dangerousStyleValue
 * @typechecks static-only
 */

"use strict";

var CSSProperty = require("./CSSProperty");

var isUnitlessNumber = CSSProperty.isUnitlessNumber;

/**
 * Convert a value into the proper css writable value. The style name `name`
 * should be logical (no hyphens), as specified
 * in `CSSProperty.isUnitlessNumber`.
 *
 * @param {string} name CSS property name such as `topMargin`.
 * @param {*} value CSS property value such as `10px`.
 * @return {string} Normalized style value with dimensions applied.
 */
function dangerousStyleValue(name, value) {
  // Note that we've removed escapeTextForBrowser() calls here since the
  // whole string will be escaped when the attribute is injected into
  // the markup. If you provide unsafe user data here they can inject
  // arbitrary CSS which may be problematic (I couldn't repro this):
  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
  // This is not an XSS hole but instead a potential CSS injection issue
  // which has lead to a greater discussion about how we're going to
  // trust URLs moving forward. See #2115901

  var isEmpty = value == null || typeof value === 'boolean' || value === '';
  if (isEmpty) {
    return '';
  }

  var isNonNumeric = isNaN(value);
  if (isNonNumeric || value === 0 ||
      isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
    return '' + value; // cast to string
  }

  if (typeof value === 'string') {
    value = value.trim();
  }
  return value + 'px';
}

module.exports = dangerousStyleValue;

},{"./CSSProperty":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/CSSProperty.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/emptyFunction.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule emptyFunction
 */

var copyProperties = require("./copyProperties");

function makeEmptyFunction(arg) {
  return function() {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
function emptyFunction() {}

copyProperties(emptyFunction, {
  thatReturns: makeEmptyFunction,
  thatReturnsFalse: makeEmptyFunction(false),
  thatReturnsTrue: makeEmptyFunction(true),
  thatReturnsNull: makeEmptyFunction(null),
  thatReturnsThis: function() { return this; },
  thatReturnsArgument: function(arg) { return arg; }
});

module.exports = emptyFunction;

},{"./copyProperties":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/copyProperties.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/emptyObject.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule emptyObject
 */

"use strict";

var emptyObject = {};

if ("production" !== process.env.NODE_ENV) {
  Object.freeze(emptyObject);
}

module.exports = emptyObject;

}).call(this,require('_process'))
},{"_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/escapeTextForBrowser.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule escapeTextForBrowser
 * @typechecks static-only
 */

"use strict";

var ESCAPE_LOOKUP = {
  "&": "&amp;",
  ">": "&gt;",
  "<": "&lt;",
  "\"": "&quot;",
  "'": "&#x27;"
};

var ESCAPE_REGEX = /[&><"']/g;

function escaper(match) {
  return ESCAPE_LOOKUP[match];
}

/**
 * Escapes text to prevent scripting attacks.
 *
 * @param {*} text Text value to escape.
 * @return {string} An escaped string.
 */
function escapeTextForBrowser(text) {
  return ('' + text).replace(ESCAPE_REGEX, escaper);
}

module.exports = escapeTextForBrowser;

},{}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/flattenChildren.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule flattenChildren
 */

"use strict";

var traverseAllChildren = require("./traverseAllChildren");
var warning = require("./warning");

/**
 * @param {function} traverseContext Context passed through traversal.
 * @param {?ReactComponent} child React child component.
 * @param {!string} name String name of key path to child.
 */
function flattenSingleChildIntoContext(traverseContext, child, name) {
  // We found a component instance.
  var result = traverseContext;
  var keyUnique = !result.hasOwnProperty(name);
  ("production" !== process.env.NODE_ENV ? warning(
    keyUnique,
    'flattenChildren(...): Encountered two children with the same key, ' +
    '`%s`. Child keys must be unique; when two children share a key, only ' +
    'the first child will be used.',
    name
  ) : null);
  if (keyUnique && child != null) {
    result[name] = child;
  }
}

/**
 * Flattens children that are typically specified as `props.children`. Any null
 * children will not be included in the resulting object.
 * @return {!object} flattened children keyed by name.
 */
function flattenChildren(children) {
  if (children == null) {
    return children;
  }
  var result = {};
  traverseAllChildren(children, flattenSingleChildIntoContext, result);
  return result;
}

module.exports = flattenChildren;

}).call(this,require('_process'))
},{"./traverseAllChildren":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/traverseAllChildren.js","./warning":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/warning.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/focusNode.js":[function(require,module,exports){
/**
 * Copyright 2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule focusNode
 */

"use strict";

/**
 * IE8 throws if an input/textarea is disabled and we try to focus it.
 * Focus only when necessary.
 *
 * @param {DOMElement} node input/textarea to focus
 */
function focusNode(node) {
  if (!node.disabled) {
    node.focus();
  }
}

module.exports = focusNode;

},{}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/forEachAccumulated.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule forEachAccumulated
 */

"use strict";

/**
 * @param {array} an "accumulation" of items which is either an Array or
 * a single item. Useful when paired with the `accumulate` module. This is a
 * simple utility that allows us to reason about a collection of items, but
 * handling the case when there is exactly one item (and we do not need to
 * allocate an array).
 */
var forEachAccumulated = function(arr, cb, scope) {
  if (Array.isArray(arr)) {
    arr.forEach(cb, scope);
  } else if (arr) {
    cb.call(scope, arr);
  }
};

module.exports = forEachAccumulated;

},{}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/getActiveElement.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule getActiveElement
 * @typechecks
 */

/**
 * Same as document.activeElement but wraps in a try-catch block. In IE it is
 * not safe to call document.activeElement if there is nothing focused.
 *
 * The activeElement will be null only if the document body is not yet defined.
 */
function getActiveElement() /*?DOMElement*/ {
  try {
    return document.activeElement || document.body;
  } catch (e) {
    return document.body;
  }
}

module.exports = getActiveElement;

},{}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/getEventKey.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule getEventKey
 * @typechecks static-only
 */

"use strict";

var invariant = require("./invariant");

/**
 * Normalization of deprecated HTML5 `key` values
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var normalizeKey = {
  'Esc': 'Escape',
  'Spacebar': ' ',
  'Left': 'ArrowLeft',
  'Up': 'ArrowUp',
  'Right': 'ArrowRight',
  'Down': 'ArrowDown',
  'Del': 'Delete',
  'Win': 'OS',
  'Menu': 'ContextMenu',
  'Apps': 'ContextMenu',
  'Scroll': 'ScrollLock',
  'MozPrintableKey': 'Unidentified'
};

/**
 * Translation from legacy `which`/`keyCode` to HTML5 `key`
 * Only special keys supported, all others depend on keyboard layout or browser
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var translateToKey = {
  8: 'Backspace',
  9: 'Tab',
  12: 'Clear',
  13: 'Enter',
  16: 'Shift',
  17: 'Control',
  18: 'Alt',
  19: 'Pause',
  20: 'CapsLock',
  27: 'Escape',
  32: ' ',
  33: 'PageUp',
  34: 'PageDown',
  35: 'End',
  36: 'Home',
  37: 'ArrowLeft',
  38: 'ArrowUp',
  39: 'ArrowRight',
  40: 'ArrowDown',
  45: 'Insert',
  46: 'Delete',
  112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6',
  118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12',
  144: 'NumLock',
  145: 'ScrollLock',
  224: 'Meta'
};

/**
 * @param {object} nativeEvent Native browser event.
 * @return {string} Normalized `key` property.
 */
function getEventKey(nativeEvent) {
  if (nativeEvent.key) {
    // Normalize inconsistent values reported by browsers due to
    // implementations of a working draft specification.

    // FireFox implements `key` but returns `MozPrintableKey` for all
    // printable characters (normalized to `Unidentified`), ignore it.
    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
    if (key !== 'Unidentified') {
      return key;
    }
  }

  // Browser does not implement `key`, polyfill as much of it as we can.
  if (nativeEvent.type === 'keypress') {
    // Create the character from the `charCode` ourselves and use as an almost
    // perfect replacement.
    var charCode = 'charCode' in nativeEvent ?
      nativeEvent.charCode :
      nativeEvent.keyCode;

    // The enter-key is technically both printable and non-printable and can
    // thus be captured by `keypress`, no other non-printable key should.
    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
  }
  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
    // While user keyboard layout determines the actual meaning of each
    // `keyCode` value, almost all function keys have a universal value.
    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
  }

  ("production" !== process.env.NODE_ENV ? invariant(false, "Unexpected keyboard event type: %s", nativeEvent.type) : invariant(false));
}

module.exports = getEventKey;

}).call(this,require('_process'))
},{"./invariant":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/invariant.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/getEventModifierState.js":[function(require,module,exports){
/**
 * Copyright 2013 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule getEventModifierState
 * @typechecks static-only
 */

"use strict";

/**
 * Translation from modifier key to the associated property in the event.
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
 */

var modifierKeyToProp = {
  'Alt': 'altKey',
  'Control': 'ctrlKey',
  'Meta': 'metaKey',
  'Shift': 'shiftKey'
};

// IE8 does not implement getModifierState so we simply map it to the only
// modifier keys exposed by the event itself, does not support Lock-keys.
// Currently, all major browsers except Chrome seems to support Lock-keys.
function modifierStateGetter(keyArg) {
  /*jshint validthis:true */
  var syntheticEvent = this;
  var nativeEvent = syntheticEvent.nativeEvent;
  if (nativeEvent.getModifierState) {
    return nativeEvent.getModifierState(keyArg);
  }
  var keyProp = modifierKeyToProp[keyArg];
  return keyProp ? !!nativeEvent[keyProp] : false;
}

function getEventModifierState(nativeEvent) {
  return modifierStateGetter;
}

module.exports = getEventModifierState;

},{}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/getEventTarget.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule getEventTarget
 * @typechecks static-only
 */

"use strict";

/**
 * Gets the target node from a native browser event by accounting for
 * inconsistencies in browser DOM APIs.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {DOMEventTarget} Target node.
 */
function getEventTarget(nativeEvent) {
  var target = nativeEvent.target || nativeEvent.srcElement || window;
  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
  // @see http://www.quirksmode.org/js/events_properties.html
  return target.nodeType === 3 ? target.parentNode : target;
}

module.exports = getEventTarget;

},{}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/getMarkupWrap.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule getMarkupWrap
 */

var ExecutionEnvironment = require("./ExecutionEnvironment");

var invariant = require("./invariant");

/**
 * Dummy container used to detect which wraps are necessary.
 */
var dummyNode =
  ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

/**
 * Some browsers cannot use `innerHTML` to render certain elements standalone,
 * so we wrap them, render the wrapped nodes, then extract the desired node.
 *
 * In IE8, certain elements cannot render alone, so wrap all elements ('*').
 */
var shouldWrap = {
  // Force wrapping for SVG elements because if they get created inside a <div>,
  // they will be initialized in the wrong namespace (and will not display).
  'circle': true,
  'defs': true,
  'ellipse': true,
  'g': true,
  'line': true,
  'linearGradient': true,
  'path': true,
  'polygon': true,
  'polyline': true,
  'radialGradient': true,
  'rect': true,
  'stop': true,
  'text': true
};

var selectWrap = [1, '<select multiple="true">', '</select>'];
var tableWrap = [1, '<table>', '</table>'];
var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];

var svgWrap = [1, '<svg>', '</svg>'];

var markupWrap = {
  '*': [1, '?<div>', '</div>'],

  'area': [1, '<map>', '</map>'],
  'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
  'legend': [1, '<fieldset>', '</fieldset>'],
  'param': [1, '<object>', '</object>'],
  'tr': [2, '<table><tbody>', '</tbody></table>'],

  'optgroup': selectWrap,
  'option': selectWrap,

  'caption': tableWrap,
  'colgroup': tableWrap,
  'tbody': tableWrap,
  'tfoot': tableWrap,
  'thead': tableWrap,

  'td': trWrap,
  'th': trWrap,

  'circle': svgWrap,
  'defs': svgWrap,
  'ellipse': svgWrap,
  'g': svgWrap,
  'line': svgWrap,
  'linearGradient': svgWrap,
  'path': svgWrap,
  'polygon': svgWrap,
  'polyline': svgWrap,
  'radialGradient': svgWrap,
  'rect': svgWrap,
  'stop': svgWrap,
  'text': svgWrap
};

/**
 * Gets the markup wrap configuration for the supplied `nodeName`.
 *
 * NOTE: This lazily detects which wraps are necessary for the current browser.
 *
 * @param {string} nodeName Lowercase `nodeName`.
 * @return {?array} Markup wrap configuration, if applicable.
 */
function getMarkupWrap(nodeName) {
  ("production" !== process.env.NODE_ENV ? invariant(!!dummyNode, 'Markup wrapping node not initialized') : invariant(!!dummyNode));
  if (!markupWrap.hasOwnProperty(nodeName)) {
    nodeName = '*';
  }
  if (!shouldWrap.hasOwnProperty(nodeName)) {
    if (nodeName === '*') {
      dummyNode.innerHTML = '<link />';
    } else {
      dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
    }
    shouldWrap[nodeName] = !dummyNode.firstChild;
  }
  return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
}


module.exports = getMarkupWrap;

}).call(this,require('_process'))
},{"./ExecutionEnvironment":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ExecutionEnvironment.js","./invariant":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/invariant.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/getNodeForCharacterOffset.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule getNodeForCharacterOffset
 */

"use strict";

/**
 * Given any node return the first leaf node without children.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {DOMElement|DOMTextNode}
 */
function getLeafNode(node) {
  while (node && node.firstChild) {
    node = node.firstChild;
  }
  return node;
}

/**
 * Get the next sibling within a container. This will walk up the
 * DOM if a node's siblings have been exhausted.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {?DOMElement|DOMTextNode}
 */
function getSiblingNode(node) {
  while (node) {
    if (node.nextSibling) {
      return node.nextSibling;
    }
    node = node.parentNode;
  }
}

/**
 * Get object describing the nodes which contain characters at offset.
 *
 * @param {DOMElement|DOMTextNode} root
 * @param {number} offset
 * @return {?object}
 */
function getNodeForCharacterOffset(root, offset) {
  var node = getLeafNode(root);
  var nodeStart = 0;
  var nodeEnd = 0;

  while (node) {
    if (node.nodeType == 3) {
      nodeEnd = nodeStart + node.textContent.length;

      if (nodeStart <= offset && nodeEnd >= offset) {
        return {
          node: node,
          offset: offset - nodeStart
        };
      }

      nodeStart = nodeEnd;
    }

    node = getLeafNode(getSiblingNode(node));
  }
}

module.exports = getNodeForCharacterOffset;

},{}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/getReactRootElementInContainer.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule getReactRootElementInContainer
 */

"use strict";

var DOC_NODE_TYPE = 9;

/**
 * @param {DOMElement|DOMDocument} container DOM element that may contain
 *                                           a React component
 * @return {?*} DOM element that may have the reactRoot ID, or null.
 */
function getReactRootElementInContainer(container) {
  if (!container) {
    return null;
  }

  if (container.nodeType === DOC_NODE_TYPE) {
    return container.documentElement;
  } else {
    return container.firstChild;
  }
}

module.exports = getReactRootElementInContainer;

},{}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/getTextContentAccessor.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule getTextContentAccessor
 */

"use strict";

var ExecutionEnvironment = require("./ExecutionEnvironment");

var contentKey = null;

/**
 * Gets the key used to access text content on a DOM node.
 *
 * @return {?string} Key used to access text content.
 * @internal
 */
function getTextContentAccessor() {
  if (!contentKey && ExecutionEnvironment.canUseDOM) {
    // Prefer textContent to innerText because many browsers support both but
    // SVG <text> elements don't support innerText even when <div> does.
    contentKey = 'textContent' in document.documentElement ?
      'textContent' :
      'innerText';
  }
  return contentKey;
}

module.exports = getTextContentAccessor;

},{"./ExecutionEnvironment":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ExecutionEnvironment.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/getUnboundedScrollPosition.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule getUnboundedScrollPosition
 * @typechecks
 */

"use strict";

/**
 * Gets the scroll position of the supplied element or window.
 *
 * The return values are unbounded, unlike `getScrollPosition`. This means they
 * may be negative or exceed the element boundaries (which is possible using
 * inertial scrolling).
 *
 * @param {DOMWindow|DOMElement} scrollable
 * @return {object} Map with `x` and `y` keys.
 */
function getUnboundedScrollPosition(scrollable) {
  if (scrollable === window) {
    return {
      x: window.pageXOffset || document.documentElement.scrollLeft,
      y: window.pageYOffset || document.documentElement.scrollTop
    };
  }
  return {
    x: scrollable.scrollLeft,
    y: scrollable.scrollTop
  };
}

module.exports = getUnboundedScrollPosition;

},{}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/hyphenate.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule hyphenate
 * @typechecks
 */

var _uppercasePattern = /([A-Z])/g;

/**
 * Hyphenates a camelcased string, for example:
 *
 *   > hyphenate('backgroundColor')
 *   < "background-color"
 *
 * For CSS style names, use `hyphenateStyleName` instead which works properly
 * with all vendor prefixes, including `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenate(string) {
  return string.replace(_uppercasePattern, '-$1').toLowerCase();
}

module.exports = hyphenate;

},{}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/hyphenateStyleName.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule hyphenateStyleName
 * @typechecks
 */

"use strict";

var hyphenate = require("./hyphenate");

var msPattern = /^ms-/;

/**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenate('backgroundColor')
 *   < "background-color"
 *   > hyphenate('MozTransition')
 *   < "-moz-transition"
 *   > hyphenate('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenateStyleName(string) {
  return hyphenate(string).replace(msPattern, '-ms-');
}

module.exports = hyphenateStyleName;

},{"./hyphenate":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/hyphenate.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/instantiateReactComponent.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule instantiateReactComponent
 * @typechecks static-only
 */

"use strict";

var invariant = require("./invariant");

/**
 * Validate a `componentDescriptor`. This should be exposed publicly in a follow
 * up diff.
 *
 * @param {object} descriptor
 * @return {boolean} Returns true if this is a valid descriptor of a Component.
 */
function isValidComponentDescriptor(descriptor) {
  return (
    descriptor &&
    typeof descriptor.type === 'function' &&
    typeof descriptor.type.prototype.mountComponent === 'function' &&
    typeof descriptor.type.prototype.receiveComponent === 'function'
  );
}

/**
 * Given a `componentDescriptor` create an instance that will actually be
 * mounted. Currently it just extracts an existing clone from composite
 * components but this is an implementation detail which will change.
 *
 * @param {object} descriptor
 * @return {object} A new instance of componentDescriptor's constructor.
 * @protected
 */
function instantiateReactComponent(descriptor) {

  // TODO: Make warning
  // if (__DEV__) {
    ("production" !== process.env.NODE_ENV ? invariant(
      isValidComponentDescriptor(descriptor),
      'Only React Components are valid for mounting.'
    ) : invariant(isValidComponentDescriptor(descriptor)));
  // }

  return new descriptor.type(descriptor);
}

module.exports = instantiateReactComponent;

}).call(this,require('_process'))
},{"./invariant":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/invariant.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/invariant.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule invariant
 */

"use strict";

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function(condition, format, a, b, c, d, e, f) {
  if ("production" !== process.env.NODE_ENV) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        'Invariant Violation: ' +
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;

}).call(this,require('_process'))
},{"_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/isEventSupported.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule isEventSupported
 */

"use strict";

var ExecutionEnvironment = require("./ExecutionEnvironment");

var useHasFeature;
if (ExecutionEnvironment.canUseDOM) {
  useHasFeature =
    document.implementation &&
    document.implementation.hasFeature &&
    // always returns true in newer browsers as per the standard.
    // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
    document.implementation.hasFeature('', '') !== true;
}

/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
function isEventSupported(eventNameSuffix, capture) {
  if (!ExecutionEnvironment.canUseDOM ||
      capture && !('addEventListener' in document)) {
    return false;
  }

  var eventName = 'on' + eventNameSuffix;
  var isSupported = eventName in document;

  if (!isSupported) {
    var element = document.createElement('div');
    element.setAttribute(eventName, 'return;');
    isSupported = typeof element[eventName] === 'function';
  }

  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
    // This is the only way to test support for the `wheel` event in IE9+.
    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
  }

  return isSupported;
}

module.exports = isEventSupported;

},{"./ExecutionEnvironment":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ExecutionEnvironment.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/isNode.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule isNode
 * @typechecks
 */

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM node.
 */
function isNode(object) {
  return !!(object && (
    typeof Node === 'function' ? object instanceof Node :
      typeof object === 'object' &&
      typeof object.nodeType === 'number' &&
      typeof object.nodeName === 'string'
  ));
}

module.exports = isNode;

},{}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/isTextInputElement.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule isTextInputElement
 */

"use strict";

/**
 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
 */
var supportedInputTypes = {
  'color': true,
  'date': true,
  'datetime': true,
  'datetime-local': true,
  'email': true,
  'month': true,
  'number': true,
  'password': true,
  'range': true,
  'search': true,
  'tel': true,
  'text': true,
  'time': true,
  'url': true,
  'week': true
};

function isTextInputElement(elem) {
  return elem && (
    (elem.nodeName === 'INPUT' && supportedInputTypes[elem.type]) ||
    elem.nodeName === 'TEXTAREA'
  );
}

module.exports = isTextInputElement;

},{}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/isTextNode.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule isTextNode
 * @typechecks
 */

var isNode = require("./isNode");

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM text node.
 */
function isTextNode(object) {
  return isNode(object) && object.nodeType == 3;
}

module.exports = isTextNode;

},{"./isNode":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/isNode.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/joinClasses.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule joinClasses
 * @typechecks static-only
 */

"use strict";

/**
 * Combines multiple className strings into one.
 * http://jsperf.com/joinclasses-args-vs-array
 *
 * @param {...?string} classes
 * @return {string}
 */
function joinClasses(className/*, ... */) {
  if (!className) {
    className = '';
  }
  var nextClass;
  var argLength = arguments.length;
  if (argLength > 1) {
    for (var ii = 1; ii < argLength; ii++) {
      nextClass = arguments[ii];
      nextClass && (className += ' ' + nextClass);
    }
  }
  return className;
}

module.exports = joinClasses;

},{}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/keyMirror.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule keyMirror
 * @typechecks static-only
 */

"use strict";

var invariant = require("./invariant");

/**
 * Constructs an enumeration with keys equal to their value.
 *
 * For example:
 *
 *   var COLORS = keyMirror({blue: null, red: null});
 *   var myColor = COLORS.blue;
 *   var isColorValid = !!COLORS[myColor];
 *
 * The last line could not be performed if the values of the generated enum were
 * not equal to their keys.
 *
 *   Input:  {key1: val1, key2: val2}
 *   Output: {key1: key1, key2: key2}
 *
 * @param {object} obj
 * @return {object}
 */
var keyMirror = function(obj) {
  var ret = {};
  var key;
  ("production" !== process.env.NODE_ENV ? invariant(
    obj instanceof Object && !Array.isArray(obj),
    'keyMirror(...): Argument must be an object.'
  ) : invariant(obj instanceof Object && !Array.isArray(obj)));
  for (key in obj) {
    if (!obj.hasOwnProperty(key)) {
      continue;
    }
    ret[key] = key;
  }
  return ret;
};

module.exports = keyMirror;

}).call(this,require('_process'))
},{"./invariant":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/invariant.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/keyOf.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule keyOf
 */

/**
 * Allows extraction of a minified key. Let's the build system minify keys
 * without loosing the ability to dynamically use key strings as values
 * themselves. Pass in an object with a single key/val pair and it will return
 * you the string key of that single record. Suppose you want to grab the
 * value for a key 'className' inside of an object. Key/val minification may
 * have aliased that key to be 'xa12'. keyOf({className: null}) will return
 * 'xa12' in that case. Resolve keys you want to use once at startup time, then
 * reuse those resolutions.
 */
var keyOf = function(oneKeyObj) {
  var key;
  for (key in oneKeyObj) {
    if (!oneKeyObj.hasOwnProperty(key)) {
      continue;
    }
    return key;
  }
  return null;
};


module.exports = keyOf;

},{}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/mapObject.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule mapObject
 */

"use strict";

/**
 * For each key/value pair, invokes callback func and constructs a resulting
 * object which contains, for every key in obj, values that are the result of
 * of invoking the function:
 *
 *   func(value, key, iteration)
 *
 * Grepable names:
 *
 *   function objectMap()
 *   function objMap()
 *
 * @param {?object} obj Object to map keys over
 * @param {function} func Invoked for each key/val pair.
 * @param {?*} context
 * @return {?object} Result of mapping or null if obj is falsey
 */
function mapObject(obj, func, context) {
  if (!obj) {
    return null;
  }
  var i = 0;
  var ret = {};
  for (var key in obj) {
    if (obj.hasOwnProperty(key)) {
      ret[key] = func.call(context, obj[key], key, i++);
    }
  }
  return ret;
}

module.exports = mapObject;

},{}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/memoizeStringOnly.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule memoizeStringOnly
 * @typechecks static-only
 */

"use strict";

/**
 * Memoizes the return value of a function that accepts one string argument.
 *
 * @param {function} callback
 * @return {function}
 */
function memoizeStringOnly(callback) {
  var cache = {};
  return function(string) {
    if (cache.hasOwnProperty(string)) {
      return cache[string];
    } else {
      return cache[string] = callback.call(this, string);
    }
  };
}

module.exports = memoizeStringOnly;

},{}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/merge.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule merge
 */

"use strict";

var mergeInto = require("./mergeInto");

/**
 * Shallow merges two structures into a return value, without mutating either.
 *
 * @param {?object} one Optional object with properties to merge from.
 * @param {?object} two Optional object with properties to merge from.
 * @return {object} The shallow extension of one by two.
 */
var merge = function(one, two) {
  var result = {};
  mergeInto(result, one);
  mergeInto(result, two);
  return result;
};

module.exports = merge;

},{"./mergeInto":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/mergeInto.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/mergeHelpers.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule mergeHelpers
 *
 * requiresPolyfills: Array.isArray
 */

"use strict";

var invariant = require("./invariant");
var keyMirror = require("./keyMirror");

/**
 * Maximum number of levels to traverse. Will catch circular structures.
 * @const
 */
var MAX_MERGE_DEPTH = 36;

/**
 * We won't worry about edge cases like new String('x') or new Boolean(true).
 * Functions are considered terminals, and arrays are not.
 * @param {*} o The item/object/value to test.
 * @return {boolean} true iff the argument is a terminal.
 */
var isTerminal = function(o) {
  return typeof o !== 'object' || o === null;
};

var mergeHelpers = {

  MAX_MERGE_DEPTH: MAX_MERGE_DEPTH,

  isTerminal: isTerminal,

  /**
   * Converts null/undefined values into empty object.
   *
   * @param {?Object=} arg Argument to be normalized (nullable optional)
   * @return {!Object}
   */
  normalizeMergeArg: function(arg) {
    return arg === undefined || arg === null ? {} : arg;
  },

  /**
   * If merging Arrays, a merge strategy *must* be supplied. If not, it is
   * likely the caller's fault. If this function is ever called with anything
   * but `one` and `two` being `Array`s, it is the fault of the merge utilities.
   *
   * @param {*} one Array to merge into.
   * @param {*} two Array to merge from.
   */
  checkMergeArrayArgs: function(one, two) {
    ("production" !== process.env.NODE_ENV ? invariant(
      Array.isArray(one) && Array.isArray(two),
      'Tried to merge arrays, instead got %s and %s.',
      one,
      two
    ) : invariant(Array.isArray(one) && Array.isArray(two)));
  },

  /**
   * @param {*} one Object to merge into.
   * @param {*} two Object to merge from.
   */
  checkMergeObjectArgs: function(one, two) {
    mergeHelpers.checkMergeObjectArg(one);
    mergeHelpers.checkMergeObjectArg(two);
  },

  /**
   * @param {*} arg
   */
  checkMergeObjectArg: function(arg) {
    ("production" !== process.env.NODE_ENV ? invariant(
      !isTerminal(arg) && !Array.isArray(arg),
      'Tried to merge an object, instead got %s.',
      arg
    ) : invariant(!isTerminal(arg) && !Array.isArray(arg)));
  },

  /**
   * @param {*} arg
   */
  checkMergeIntoObjectArg: function(arg) {
    ("production" !== process.env.NODE_ENV ? invariant(
      (!isTerminal(arg) || typeof arg === 'function') && !Array.isArray(arg),
      'Tried to merge into an object, instead got %s.',
      arg
    ) : invariant((!isTerminal(arg) || typeof arg === 'function') && !Array.isArray(arg)));
  },

  /**
   * Checks that a merge was not given a circular object or an object that had
   * too great of depth.
   *
   * @param {number} Level of recursion to validate against maximum.
   */
  checkMergeLevel: function(level) {
    ("production" !== process.env.NODE_ENV ? invariant(
      level < MAX_MERGE_DEPTH,
      'Maximum deep merge depth exceeded. You may be attempting to merge ' +
      'circular structures in an unsupported way.'
    ) : invariant(level < MAX_MERGE_DEPTH));
  },

  /**
   * Checks that the supplied merge strategy is valid.
   *
   * @param {string} Array merge strategy.
   */
  checkArrayStrategy: function(strategy) {
    ("production" !== process.env.NODE_ENV ? invariant(
      strategy === undefined || strategy in mergeHelpers.ArrayStrategies,
      'You must provide an array strategy to deep merge functions to ' +
      'instruct the deep merge how to resolve merging two arrays.'
    ) : invariant(strategy === undefined || strategy in mergeHelpers.ArrayStrategies));
  },

  /**
   * Set of possible behaviors of merge algorithms when encountering two Arrays
   * that must be merged together.
   * - `clobber`: The left `Array` is ignored.
   * - `indexByIndex`: The result is achieved by recursively deep merging at
   *   each index. (not yet supported.)
   */
  ArrayStrategies: keyMirror({
    Clobber: true,
    IndexByIndex: true
  })

};

module.exports = mergeHelpers;

}).call(this,require('_process'))
},{"./invariant":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/invariant.js","./keyMirror":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/keyMirror.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/mergeInto.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule mergeInto
 * @typechecks static-only
 */

"use strict";

var mergeHelpers = require("./mergeHelpers");

var checkMergeObjectArg = mergeHelpers.checkMergeObjectArg;
var checkMergeIntoObjectArg = mergeHelpers.checkMergeIntoObjectArg;

/**
 * Shallow merges two structures by mutating the first parameter.
 *
 * @param {object|function} one Object to be merged into.
 * @param {?object} two Optional object with properties to merge from.
 */
function mergeInto(one, two) {
  checkMergeIntoObjectArg(one);
  if (two != null) {
    checkMergeObjectArg(two);
    for (var key in two) {
      if (!two.hasOwnProperty(key)) {
        continue;
      }
      one[key] = two[key];
    }
  }
}

module.exports = mergeInto;

},{"./mergeHelpers":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/mergeHelpers.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/mixInto.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule mixInto
 */

"use strict";

/**
 * Simply copies properties to the prototype.
 */
var mixInto = function(constructor, methodBag) {
  var methodName;
  for (methodName in methodBag) {
    if (!methodBag.hasOwnProperty(methodName)) {
      continue;
    }
    constructor.prototype[methodName] = methodBag[methodName];
  }
};

module.exports = mixInto;

},{}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/monitorCodeUse.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule monitorCodeUse
 */

"use strict";

var invariant = require("./invariant");

/**
 * Provides open-source compatible instrumentation for monitoring certain API
 * uses before we're ready to issue a warning or refactor. It accepts an event
 * name which may only contain the characters [a-z0-9_] and an optional data
 * object with further information.
 */

function monitorCodeUse(eventName, data) {
  ("production" !== process.env.NODE_ENV ? invariant(
    eventName && !/[^a-z0-9_]/.test(eventName),
    'You must provide an eventName using only the characters [a-z0-9_]'
  ) : invariant(eventName && !/[^a-z0-9_]/.test(eventName)));
}

module.exports = monitorCodeUse;

}).call(this,require('_process'))
},{"./invariant":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/invariant.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/onlyChild.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule onlyChild
 */
"use strict";

var ReactDescriptor = require("./ReactDescriptor");

var invariant = require("./invariant");

/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection. The current implementation of this
 * function assumes that a single child gets passed without a wrapper, but the
 * purpose of this helper function is to abstract away the particular structure
 * of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactComponent} The first and only `ReactComponent` contained in the
 * structure.
 */
function onlyChild(children) {
  ("production" !== process.env.NODE_ENV ? invariant(
    ReactDescriptor.isValidDescriptor(children),
    'onlyChild must be passed a children with exactly one child.'
  ) : invariant(ReactDescriptor.isValidDescriptor(children)));
  return children;
}

module.exports = onlyChild;

}).call(this,require('_process'))
},{"./ReactDescriptor":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactDescriptor.js","./invariant":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/invariant.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/performance.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule performance
 * @typechecks
 */

"use strict";

var ExecutionEnvironment = require("./ExecutionEnvironment");

var performance;

if (ExecutionEnvironment.canUseDOM) {
  performance =
    window.performance ||
    window.msPerformance ||
    window.webkitPerformance;
}

module.exports = performance || {};

},{"./ExecutionEnvironment":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ExecutionEnvironment.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/performanceNow.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule performanceNow
 * @typechecks
 */

var performance = require("./performance");

/**
 * Detect if we can use `window.performance.now()` and gracefully fallback to
 * `Date.now()` if it doesn't exist. We need to support Firefox < 15 for now
 * because of Facebook's testing infrastructure.
 */
if (!performance || !performance.now) {
  performance = Date;
}

var performanceNow = performance.now.bind(performance);

module.exports = performanceNow;

},{"./performance":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/performance.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/setInnerHTML.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule setInnerHTML
 */

"use strict";

var ExecutionEnvironment = require("./ExecutionEnvironment");

/**
 * Set the innerHTML property of a node, ensuring that whitespace is preserved
 * even in IE8.
 *
 * @param {DOMElement} node
 * @param {string} html
 * @internal
 */
var setInnerHTML = function(node, html) {
  node.innerHTML = html;
};

if (ExecutionEnvironment.canUseDOM) {
  // IE8: When updating a just created node with innerHTML only leading
  // whitespace is removed. When updating an existing node with innerHTML
  // whitespace in root TextNodes is also collapsed.
  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html

  // Feature detection; only IE8 is known to behave improperly like this.
  var testElement = document.createElement('div');
  testElement.innerHTML = ' ';
  if (testElement.innerHTML === '') {
    setInnerHTML = function(node, html) {
      // Magic theory: IE8 supposedly differentiates between added and updated
      // nodes when processing innerHTML, innerHTML on updated nodes suffers
      // from worse whitespace behavior. Re-adding a node like this triggers
      // the initial and more favorable whitespace behavior.
      // TODO: What to do on a detached node?
      if (node.parentNode) {
        node.parentNode.replaceChild(node, node);
      }

      // We also implement a workaround for non-visible tags disappearing into
      // thin air on IE8, this only happens if there is no visible text
      // in-front of the non-visible tags. Piggyback on the whitespace fix
      // and simply check if any non-visible tags appear in the source.
      if (html.match(/^[ \r\n\t\f]/) ||
          html[0] === '<' && (
            html.indexOf('<noscript') !== -1 ||
            html.indexOf('<script') !== -1 ||
            html.indexOf('<style') !== -1 ||
            html.indexOf('<meta') !== -1 ||
            html.indexOf('<link') !== -1)) {
        // Recover leading whitespace by temporarily prepending any character.
        // \uFEFF has the potential advantage of being zero-width/invisible.
        node.innerHTML = '\uFEFF' + html;

        // deleteData leaves an empty `TextNode` which offsets the index of all
        // children. Definitely want to avoid this.
        var textNode = node.firstChild;
        if (textNode.data.length === 1) {
          node.removeChild(textNode);
        } else {
          textNode.deleteData(0, 1);
        }
      } else {
        node.innerHTML = html;
      }
    };
  }
}

module.exports = setInnerHTML;

},{"./ExecutionEnvironment":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ExecutionEnvironment.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/shallowEqual.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule shallowEqual
 */

"use strict";

/**
 * Performs equality by iterating through keys on an object and returning
 * false when any key has values which are not strictly equal between
 * objA and objB. Returns true when the values of all keys are strictly equal.
 *
 * @return {boolean}
 */
function shallowEqual(objA, objB) {
  if (objA === objB) {
    return true;
  }
  var key;
  // Test for A's keys different from B.
  for (key in objA) {
    if (objA.hasOwnProperty(key) &&
        (!objB.hasOwnProperty(key) || objA[key] !== objB[key])) {
      return false;
    }
  }
  // Test for B'a keys missing from A.
  for (key in objB) {
    if (objB.hasOwnProperty(key) && !objA.hasOwnProperty(key)) {
      return false;
    }
  }
  return true;
}

module.exports = shallowEqual;

},{}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/shouldUpdateReactComponent.js":[function(require,module,exports){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule shouldUpdateReactComponent
 * @typechecks static-only
 */

"use strict";

/**
 * Given a `prevDescriptor` and `nextDescriptor`, determines if the existing
 * instance should be updated as opposed to being destroyed or replaced by a new
 * instance. Both arguments are descriptors. This ensures that this logic can
 * operate on stateless trees without any backing instance.
 *
 * @param {?object} prevDescriptor
 * @param {?object} nextDescriptor
 * @return {boolean} True if the existing instance should be updated.
 * @protected
 */
function shouldUpdateReactComponent(prevDescriptor, nextDescriptor) {
  if (prevDescriptor && nextDescriptor &&
      prevDescriptor.type === nextDescriptor.type && (
        (prevDescriptor.props && prevDescriptor.props.key) ===
        (nextDescriptor.props && nextDescriptor.props.key)
      ) && prevDescriptor._owner === nextDescriptor._owner) {
    return true;
  }
  return false;
}

module.exports = shouldUpdateReactComponent;

},{}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/toArray.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule toArray
 * @typechecks
 */

var invariant = require("./invariant");

/**
 * Convert array-like objects to arrays.
 *
 * This API assumes the caller knows the contents of the data type. For less
 * well defined inputs use createArrayFrom.
 *
 * @param {object|function|filelist} obj
 * @return {array}
 */
function toArray(obj) {
  var length = obj.length;

  // Some browse builtin objects can report typeof 'function' (e.g. NodeList in
  // old versions of Safari).
  ("production" !== process.env.NODE_ENV ? invariant(
    !Array.isArray(obj) &&
    (typeof obj === 'object' || typeof obj === 'function'),
    'toArray: Array-like object expected'
  ) : invariant(!Array.isArray(obj) &&
  (typeof obj === 'object' || typeof obj === 'function')));

  ("production" !== process.env.NODE_ENV ? invariant(
    typeof length === 'number',
    'toArray: Object needs a length property'
  ) : invariant(typeof length === 'number'));

  ("production" !== process.env.NODE_ENV ? invariant(
    length === 0 ||
    (length - 1) in obj,
    'toArray: Object should have keys for indices'
  ) : invariant(length === 0 ||
  (length - 1) in obj));

  // Old IE doesn't give collections access to hasOwnProperty. Assume inputs
  // without method will throw during the slice call and skip straight to the
  // fallback.
  if (obj.hasOwnProperty) {
    try {
      return Array.prototype.slice.call(obj);
    } catch (e) {
      // IE < 9 does not support Array#slice on collections objects
    }
  }

  // Fall back to copying key by key. This assumes all keys have a value,
  // so will not preserve sparsely populated inputs.
  var ret = Array(length);
  for (var ii = 0; ii < length; ii++) {
    ret[ii] = obj[ii];
  }
  return ret;
}

module.exports = toArray;

}).call(this,require('_process'))
},{"./invariant":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/invariant.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/traverseAllChildren.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule traverseAllChildren
 */

"use strict";

var ReactInstanceHandles = require("./ReactInstanceHandles");
var ReactTextComponent = require("./ReactTextComponent");

var invariant = require("./invariant");

var SEPARATOR = ReactInstanceHandles.SEPARATOR;
var SUBSEPARATOR = ':';

/**
 * TODO: Test that:
 * 1. `mapChildren` transforms strings and numbers into `ReactTextComponent`.
 * 2. it('should fail when supplied duplicate key', function() {
 * 3. That a single child and an array with one item have the same key pattern.
 * });
 */

var userProvidedKeyEscaperLookup = {
  '=': '=0',
  '.': '=1',
  ':': '=2'
};

var userProvidedKeyEscapeRegex = /[=.:]/g;

function userProvidedKeyEscaper(match) {
  return userProvidedKeyEscaperLookup[match];
}

/**
 * Generate a key string that identifies a component within a set.
 *
 * @param {*} component A component that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */
function getComponentKey(component, index) {
  if (component && component.props && component.props.key != null) {
    // Explicit key
    return wrapUserProvidedKey(component.props.key);
  }
  // Implicit key determined by the index in the set
  return index.toString(36);
}

/**
 * Escape a component key so that it is safe to use in a reactid.
 *
 * @param {*} key Component key to be escaped.
 * @return {string} An escaped string.
 */
function escapeUserProvidedKey(text) {
  return ('' + text).replace(
    userProvidedKeyEscapeRegex,
    userProvidedKeyEscaper
  );
}

/**
 * Wrap a `key` value explicitly provided by the user to distinguish it from
 * implicitly-generated keys generated by a component's index in its parent.
 *
 * @param {string} key Value of a user-provided `key` attribute
 * @return {string}
 */
function wrapUserProvidedKey(key) {
  return '$' + escapeUserProvidedKey(key);
}

/**
 * @param {?*} children Children tree container.
 * @param {!string} nameSoFar Name of the key path so far.
 * @param {!number} indexSoFar Number of children encountered until this point.
 * @param {!function} callback Callback to invoke with each child found.
 * @param {?*} traverseContext Used to pass information throughout the traversal
 * process.
 * @return {!number} The number of children in this subtree.
 */
var traverseAllChildrenImpl =
  function(children, nameSoFar, indexSoFar, callback, traverseContext) {
    var subtreeCount = 0;  // Count of children found in the current subtree.
    if (Array.isArray(children)) {
      for (var i = 0; i < children.length; i++) {
        var child = children[i];
        var nextName = (
          nameSoFar +
          (nameSoFar ? SUBSEPARATOR : SEPARATOR) +
          getComponentKey(child, i)
        );
        var nextIndex = indexSoFar + subtreeCount;
        subtreeCount += traverseAllChildrenImpl(
          child,
          nextName,
          nextIndex,
          callback,
          traverseContext
        );
      }
    } else {
      var type = typeof children;
      var isOnlyChild = nameSoFar === '';
      // If it's the only child, treat the name as if it was wrapped in an array
      // so that it's consistent if the number of children grows
      var storageName =
        isOnlyChild ? SEPARATOR + getComponentKey(children, 0) : nameSoFar;
      if (children == null || type === 'boolean') {
        // All of the above are perceived as null.
        callback(traverseContext, null, storageName, indexSoFar);
        subtreeCount = 1;
      } else if (children.type && children.type.prototype &&
                 children.type.prototype.mountComponentIntoNode) {
        callback(traverseContext, children, storageName, indexSoFar);
        subtreeCount = 1;
      } else {
        if (type === 'object') {
          ("production" !== process.env.NODE_ENV ? invariant(
            !children || children.nodeType !== 1,
            'traverseAllChildren(...): Encountered an invalid child; DOM ' +
            'elements are not valid children of React components.'
          ) : invariant(!children || children.nodeType !== 1));
          for (var key in children) {
            if (children.hasOwnProperty(key)) {
              subtreeCount += traverseAllChildrenImpl(
                children[key],
                (
                  nameSoFar + (nameSoFar ? SUBSEPARATOR : SEPARATOR) +
                  wrapUserProvidedKey(key) + SUBSEPARATOR +
                  getComponentKey(children[key], 0)
                ),
                indexSoFar + subtreeCount,
                callback,
                traverseContext
              );
            }
          }
        } else if (type === 'string') {
          var normalizedText = ReactTextComponent(children);
          callback(traverseContext, normalizedText, storageName, indexSoFar);
          subtreeCount += 1;
        } else if (type === 'number') {
          var normalizedNumber = ReactTextComponent('' + children);
          callback(traverseContext, normalizedNumber, storageName, indexSoFar);
          subtreeCount += 1;
        }
      }
    }
    return subtreeCount;
  };

/**
 * Traverses children that are typically specified as `props.children`, but
 * might also be specified through attributes:
 *
 * - `traverseAllChildren(this.props.children, ...)`
 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
 *
 * The `traverseContext` is an optional argument that is passed through the
 * entire traversal. It can be used to store accumulations or anything else that
 * the callback might find relevant.
 *
 * @param {?*} children Children tree object.
 * @param {!function} callback To invoke upon traversing each child.
 * @param {?*} traverseContext Context for traversal.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildren(children, callback, traverseContext) {
  if (children == null) {
    return 0;
  }

  return traverseAllChildrenImpl(children, '', 0, callback, traverseContext);
}

module.exports = traverseAllChildren;

}).call(this,require('_process'))
},{"./ReactInstanceHandles":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactInstanceHandles.js","./ReactTextComponent":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/ReactTextComponent.js","./invariant":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/invariant.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/update.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule update
 */

"use strict";

var copyProperties = require("./copyProperties");
var keyOf = require("./keyOf");
var invariant = require("./invariant");

function shallowCopy(x) {
  if (Array.isArray(x)) {
    return x.concat();
  } else if (x && typeof x === 'object') {
    return copyProperties(new x.constructor(), x);
  } else {
    return x;
  }
}

var COMMAND_PUSH = keyOf({$push: null});
var COMMAND_UNSHIFT = keyOf({$unshift: null});
var COMMAND_SPLICE = keyOf({$splice: null});
var COMMAND_SET = keyOf({$set: null});
var COMMAND_MERGE = keyOf({$merge: null});
var COMMAND_APPLY = keyOf({$apply: null});

var ALL_COMMANDS_LIST = [
  COMMAND_PUSH,
  COMMAND_UNSHIFT,
  COMMAND_SPLICE,
  COMMAND_SET,
  COMMAND_MERGE,
  COMMAND_APPLY
];

var ALL_COMMANDS_SET = {};

ALL_COMMANDS_LIST.forEach(function(command) {
  ALL_COMMANDS_SET[command] = true;
});

function invariantArrayCase(value, spec, command) {
  ("production" !== process.env.NODE_ENV ? invariant(
    Array.isArray(value),
    'update(): expected target of %s to be an array; got %s.',
    command,
    value
  ) : invariant(Array.isArray(value)));
  var specValue = spec[command];
  ("production" !== process.env.NODE_ENV ? invariant(
    Array.isArray(specValue),
    'update(): expected spec of %s to be an array; got %s. ' +
    'Did you forget to wrap your parameter in an array?',
    command,
    specValue
  ) : invariant(Array.isArray(specValue)));
}

function update(value, spec) {
  ("production" !== process.env.NODE_ENV ? invariant(
    typeof spec === 'object',
    'update(): You provided a key path to update() that did not contain one ' +
    'of %s. Did you forget to include {%s: ...}?',
    ALL_COMMANDS_LIST.join(', '),
    COMMAND_SET
  ) : invariant(typeof spec === 'object'));

  if (spec.hasOwnProperty(COMMAND_SET)) {
    ("production" !== process.env.NODE_ENV ? invariant(
      Object.keys(spec).length === 1,
      'Cannot have more than one key in an object with %s',
      COMMAND_SET
    ) : invariant(Object.keys(spec).length === 1));

    return spec[COMMAND_SET];
  }

  var nextValue = shallowCopy(value);

  if (spec.hasOwnProperty(COMMAND_MERGE)) {
    var mergeObj = spec[COMMAND_MERGE];
    ("production" !== process.env.NODE_ENV ? invariant(
      mergeObj && typeof mergeObj === 'object',
      'update(): %s expects a spec of type \'object\'; got %s',
      COMMAND_MERGE,
      mergeObj
    ) : invariant(mergeObj && typeof mergeObj === 'object'));
    ("production" !== process.env.NODE_ENV ? invariant(
      nextValue && typeof nextValue === 'object',
      'update(): %s expects a target of type \'object\'; got %s',
      COMMAND_MERGE,
      nextValue
    ) : invariant(nextValue && typeof nextValue === 'object'));
    copyProperties(nextValue, spec[COMMAND_MERGE]);
  }

  if (spec.hasOwnProperty(COMMAND_PUSH)) {
    invariantArrayCase(value, spec, COMMAND_PUSH);
    spec[COMMAND_PUSH].forEach(function(item) {
      nextValue.push(item);
    });
  }

  if (spec.hasOwnProperty(COMMAND_UNSHIFT)) {
    invariantArrayCase(value, spec, COMMAND_UNSHIFT);
    spec[COMMAND_UNSHIFT].forEach(function(item) {
      nextValue.unshift(item);
    });
  }

  if (spec.hasOwnProperty(COMMAND_SPLICE)) {
    ("production" !== process.env.NODE_ENV ? invariant(
      Array.isArray(value),
      'Expected %s target to be an array; got %s',
      COMMAND_SPLICE,
      value
    ) : invariant(Array.isArray(value)));
    ("production" !== process.env.NODE_ENV ? invariant(
      Array.isArray(spec[COMMAND_SPLICE]),
      'update(): expected spec of %s to be an array of arrays; got %s. ' +
      'Did you forget to wrap your parameters in an array?',
      COMMAND_SPLICE,
      spec[COMMAND_SPLICE]
    ) : invariant(Array.isArray(spec[COMMAND_SPLICE])));
    spec[COMMAND_SPLICE].forEach(function(args) {
      ("production" !== process.env.NODE_ENV ? invariant(
        Array.isArray(args),
        'update(): expected spec of %s to be an array of arrays; got %s. ' +
        'Did you forget to wrap your parameters in an array?',
        COMMAND_SPLICE,
        spec[COMMAND_SPLICE]
      ) : invariant(Array.isArray(args)));
      nextValue.splice.apply(nextValue, args);
    });
  }

  if (spec.hasOwnProperty(COMMAND_APPLY)) {
    ("production" !== process.env.NODE_ENV ? invariant(
      typeof spec[COMMAND_APPLY] === 'function',
      'update(): expected spec of %s to be a function; got %s.',
      COMMAND_APPLY,
      spec[COMMAND_APPLY]
    ) : invariant(typeof spec[COMMAND_APPLY] === 'function'));
    nextValue = spec[COMMAND_APPLY](nextValue);
  }

  for (var k in spec) {
    if (!(ALL_COMMANDS_SET.hasOwnProperty(k) && ALL_COMMANDS_SET[k])) {
      nextValue[k] = update(value[k], spec[k]);
    }
  }

  return nextValue;
}

module.exports = update;

}).call(this,require('_process'))
},{"./copyProperties":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/copyProperties.js","./invariant":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/invariant.js","./keyOf":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/keyOf.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/warning.js":[function(require,module,exports){
(function (process){
/**
 * Copyright 2014 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule warning
 */

"use strict";

var emptyFunction = require("./emptyFunction");

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if ("production" !== process.env.NODE_ENV) {
  warning = function(condition, format ) {var args=Array.prototype.slice.call(arguments,2);
    if (format === undefined) {
      throw new Error(
        '`warning(condition, format, ...args)` requires a warning ' +
        'message argument'
      );
    }

    if (!condition) {
      var argIndex = 0;
      console.warn('Warning: ' + format.replace(/%s/g, function()  {return args[argIndex++];}));
    }
  };
}

module.exports = warning;

}).call(this,require('_process'))
},{"./emptyFunction":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/emptyFunction.js","_process":"/Users/charlieschwabacher/Code/sinesaw/node_modules/browserify/node_modules/process/browser.js"}],"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/react.js":[function(require,module,exports){
module.exports = require('./lib/React');

},{"./lib/React":"/Users/charlieschwabacher/Code/sinesaw/node_modules/react/lib/React.js"}]},{},["./app/scripts/index.coffee"])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9hcHAvc2NyaXB0cy9pbmRleC5jb2ZmZWUiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9hcHAvc2NyaXB0cy9hcHAuY2pzeCIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L2FwcC9zY3JpcHRzL2RlZmF1bHRfc29uZy5jb2ZmZWUiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9hcHAvc2NyaXB0cy9kc3AvYXVkaW9fcmVjb3JkZXIuY29mZmVlIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvYXBwL3NjcmlwdHMvZHNwL2VudmVsb3BlLmNvZmZlZSIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L2FwcC9zY3JpcHRzL2RzcC9nbG9iYWxfY29udGV4dC5jb2ZmZWUiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9hcHAvc2NyaXB0cy9kc3AvaGlnaHBhc3NfZmlsdGVyLmNvZmZlZSIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L2FwcC9zY3JpcHRzL2RzcC9saW5lYXJfaW50ZXJwb2xhdG9yLmNvZmZlZSIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L2FwcC9zY3JpcHRzL2RzcC9sb3dwYXNzX2ZpbHRlci5jb2ZmZWUiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9hcHAvc2NyaXB0cy9kc3Avb3NjaWxsYXRvcnMuY29mZmVlIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvYXBwL3NjcmlwdHMvZHNwL3NpbXBsZV9lbnZlbG9wZS5jb2ZmZWUiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9hcHAvc2NyaXB0cy9kc3Avd2ViYXVkaW8uY29mZmVlIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvYXBwL3NjcmlwdHMvbW9kZWxzL2FuYWxvZ19zeW50aGVzaXplci5jb2ZmZWUiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9hcHAvc2NyaXB0cy9tb2RlbHMvYmFzaWNfc2FtcGxlci5jb2ZmZWUiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9hcHAvc2NyaXB0cy9tb2RlbHMvZHJ1bV9zYW1wbGVyLmNvZmZlZSIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L2FwcC9zY3JpcHRzL21vZGVscy9kcnVta2l0X3N5bnRoZXNpemVyLmNvZmZlZSIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L2FwcC9zY3JpcHRzL21vZGVscy9pbnN0cnVtZW50LmNvZmZlZSIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L2FwcC9zY3JpcHRzL21vZGVscy9sb29wX3NhbXBsZXIuY29mZmVlIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvYXBwL3NjcmlwdHMvbW9kZWxzL21vZGVsLmNvZmZlZSIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L2FwcC9zY3JpcHRzL21vZGVscy9yZWNvcmRpbmcuY29mZmVlIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvYXBwL3NjcmlwdHMvbW9kZWxzL3NlcXVlbmNlLmNvZmZlZSIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L2FwcC9zY3JpcHRzL21vZGVscy9zb25nLmNvZmZlZSIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L2FwcC9zY3JpcHRzL21vZGVscy90cmFjay5jb2ZmZWUiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9hcHAvc2NyaXB0cy91aS9hbmFsb2dfc3ludGhlc2l6ZXJfY29udHJvbC5janN4IiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvYXBwL3NjcmlwdHMvdWkvYmFzaWNfc2FtcGxlcl9jb250cm9sLmNqc3giLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9hcHAvc2NyaXB0cy91aS9jaG9vc2VyLmNqc3giLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9hcHAvc2NyaXB0cy91aS9kcnVtX3NhbXBsZXJfY29udHJvbC5janN4IiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvYXBwL3NjcmlwdHMvdWkvZHJ1bWtpdF9zeW50aGVzaXplcl9jb250cm9sLmNqc3giLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9hcHAvc2NyaXB0cy91aS9lbnZlbG9wZS5janN4IiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvYXBwL3NjcmlwdHMvdWkvZmlsdGVyLmNqc3giLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9hcHAvc2NyaXB0cy91aS9rbm9iLmNqc3giLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9hcHAvc2NyaXB0cy91aS9saXN0X2NvbnRyb2wuY2pzeCIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L2FwcC9zY3JpcHRzL3VpL2xvb3Bfc2FtcGxlcl9jb250cm9sLmNqc3giLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9hcHAvc2NyaXB0cy91aS9tZW51LmNqc3giLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9hcHAvc2NyaXB0cy91aS9tZXRlci5janN4IiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvYXBwL3NjcmlwdHMvdWkvbWl4aW5zL2RyYWdnYWJsZS5jb2ZmZWUiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9hcHAvc2NyaXB0cy91aS9taXhpbnMvbW9kZWxhYmxlLmNvZmZlZSIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L2FwcC9zY3JpcHRzL3VpL21peGlucy9zaXplX21lYXN1cmFibGUuY29mZmVlIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvYXBwL3NjcmlwdHMvdWkvbWl4aW5zL3NvcnRhYmxlLmNvZmZlZSIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L2FwcC9zY3JpcHRzL3VpL21peGlucy91cGRhdGFibGUuY29mZmVlIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvYXBwL3NjcmlwdHMvdWkvbW9kYWwuY2pzeCIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L2FwcC9zY3JpcHRzL3VpL29zY2lsbGF0b3IuY2pzeCIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L2FwcC9zY3JpcHRzL3VpL3BpYW5vX3JvbGwuY2pzeCIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L2FwcC9zY3JpcHRzL3VpL3BpYW5vX3JvbGwvZ3JpZF9saW5lcy5janN4IiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvYXBwL3NjcmlwdHMvdWkvcGlhbm9fcm9sbC9rZXlzLmNqc3giLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9hcHAvc2NyaXB0cy91aS9waWFub19yb2xsL25vdGVzLmNqc3giLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9hcHAvc2NyaXB0cy91aS9waWFub19yb2xsL3BsYXliYWNrX21hcmtlci5janN4IiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvYXBwL3NjcmlwdHMvdWkvcGlhbm9fcm9sbC9zZWxlY3Rpb24uY2pzeCIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L2FwcC9zY3JpcHRzL3VpL3BsYXliYWNrX2NvbnRyb2wuY2pzeCIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L2FwcC9zY3JpcHRzL3VpL3JlY29yZF9jb250cm9sLmNqc3giLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9hcHAvc2NyaXB0cy91aS9zYW1wbGVfY29udHJvbC5janN4IiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvYXBwL3NjcmlwdHMvdWkvc2NhbGVfaGFuZGxlLmNqc3giLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9hcHAvc2NyaXB0cy91aS9zbGlkZXIuY2pzeCIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L2FwcC9zY3JpcHRzL3VpL3RyYWNrX3NlbGVjdGlvbi5janN4IiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvYXBwL3NjcmlwdHMvdWkvd2F2ZWZvcm0uY2pzeCIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L2FwcC9zY3JpcHRzL3VpL3dhdmVmb3JtL21hcmtlci5janN4IiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvYXBwL3NjcmlwdHMvdWkvd2F2ZWZvcm0vdmlzdWFsaXphdGlvbi5janN4IiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvYXBwL3NjcmlwdHMvdXRpbC9jdXJzb3IuY29mZmVlIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvYXBwL3NjcmlwdHMvdXRpbC9rZXlfb3B0aW9ucy5jb2ZmZWUiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9hcHAvc2NyaXB0cy91dGlsL2tleWJvYXJkLmNvZmZlZSIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L2FwcC9zY3JpcHRzL3V0aWwvbG9nX3NhbXBsZS5jb2ZmZWUiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9hcHAvc2NyaXB0cy91dGlsL3JpbmdfYnVmZmVyLmNvZmZlZSIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L2FwcC9zY3JpcHRzL3V0aWwvdHJhbnNwb3NlX29wdGlvbnMuY29mZmVlIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL2FzeW5jL2xpYi9hc3luYy5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9iYXNlNjQtYXJyYXlidWZmZXIvbGliL2Jhc2U2NC1hcnJheWJ1ZmZlci5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvY3VpZC9kaXN0L2Jyb3dzZXItY3VpZC5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9pbW11dGFibGUvZGlzdC9JbW11dGFibGUuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvYWRkb25zLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9BdXRvRm9jdXNNaXhpbi5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvQmVmb3JlSW5wdXRFdmVudFBsdWdpbi5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvQ1NTQ29yZS5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvQ1NTUHJvcGVydHkuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL0NTU1Byb3BlcnR5T3BlcmF0aW9ucy5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvQ2FsbGJhY2tRdWV1ZS5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvQ2hhbmdlRXZlbnRQbHVnaW4uanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL0NsaWVudFJlYWN0Um9vdEluZGV4LmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9Db21wb3NpdGlvbkV2ZW50UGx1Z2luLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9ET01DaGlsZHJlbk9wZXJhdGlvbnMuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL0RPTVByb3BlcnR5LmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9ET01Qcm9wZXJ0eU9wZXJhdGlvbnMuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL0Rhbmdlci5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXIuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL0VudGVyTGVhdmVFdmVudFBsdWdpbi5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvRXZlbnRDb25zdGFudHMuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL0V2ZW50TGlzdGVuZXIuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL0V2ZW50UGx1Z2luSHViLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9FdmVudFBsdWdpblJlZ2lzdHJ5LmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9FdmVudFBsdWdpblV0aWxzLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9FdmVudFByb3BhZ2F0b3JzLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudC5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvSFRNTERPTVByb3BlcnR5Q29uZmlnLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9MaW5rZWRTdGF0ZU1peGluLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9MaW5rZWRWYWx1ZVV0aWxzLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9Mb2NhbEV2ZW50VHJhcE1peGluLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9Nb2JpbGVTYWZhcmlDbGlja0V2ZW50UGx1Z2luLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9Qb29sZWRDbGFzcy5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3QuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0QnJvd3NlckNvbXBvbmVudE1peGluLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0Q1NTVHJhbnNpdGlvbkdyb3VwLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdENTU1RyYW5zaXRpb25Hcm91cENoaWxkLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdENoaWxkcmVuLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudC5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50V2l0aFB1cmVSZW5kZXJNaXhpbi5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RDb21wb3NpdGVDb21wb25lbnQuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0Q29udGV4dC5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RDdXJyZW50T3duZXIuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RE9NLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERPTUJ1dHRvbi5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RET01Db21wb25lbnQuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RE9NRm9ybS5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RET01JRE9wZXJhdGlvbnMuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RE9NSW1nLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERPTUlucHV0LmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERPTU9wdGlvbi5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RET01TZWxlY3QuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RE9NU2VsZWN0aW9uLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERPTVRleHRhcmVhLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5LmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERlZmF1bHRJbmplY3Rpb24uanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RGVmYXVsdFBlcmYuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RGVmYXVsdFBlcmZBbmFseXNpcy5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3REZXNjcmlwdG9yLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERlc2NyaXB0b3JWYWxpZGF0b3IuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RW1wdHlDb21wb25lbnQuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RXJyb3JVdGlscy5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RFdmVudEVtaXR0ZXJNaXhpbi5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RFdmVudExpc3RlbmVyLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdEluamVjdGlvbi5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RJbnB1dFNlbGVjdGlvbi5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RJbnN0YW5jZUhhbmRsZXMuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0TGluay5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RNYXJrdXBDaGVja3N1bS5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RNb3VudC5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RNdWx0aUNoaWxkLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RPd25lci5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RQZXJmLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFByb3BUcmFuc2ZlcmVyLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcy5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZXMuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0UHV0TGlzdGVuZXJRdWV1ZS5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RSb290SW5kZXguanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0U2VydmVyUmVuZGVyaW5nLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFN0YXRlU2V0dGVycy5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RUZXN0VXRpbHMuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0VGV4dENvbXBvbmVudC5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RUcmFuc2l0aW9uQ2hpbGRNYXBwaW5nLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFRyYW5zaXRpb25FdmVudHMuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0VHJhbnNpdGlvbkdyb3VwLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFVwZGF0ZXMuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0V2l0aEFkZG9ucy5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvU1ZHRE9NUHJvcGVydHlDb25maWcuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1NlbGVjdEV2ZW50UGx1Z2luLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9TZXJ2ZXJSZWFjdFJvb3RJbmRleC5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvU2ltcGxlRXZlbnRQbHVnaW4uanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1N5bnRoZXRpY0NsaXBib2FyZEV2ZW50LmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9TeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9TeW50aGV0aWNEcmFnRXZlbnQuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1N5bnRoZXRpY0V2ZW50LmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9TeW50aGV0aWNGb2N1c0V2ZW50LmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9TeW50aGV0aWNJbnB1dEV2ZW50LmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9TeW50aGV0aWNLZXlib2FyZEV2ZW50LmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9TeW50aGV0aWNNb3VzZUV2ZW50LmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9TeW50aGV0aWNUb3VjaEV2ZW50LmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9TeW50aGV0aWNVSUV2ZW50LmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9TeW50aGV0aWNXaGVlbEV2ZW50LmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9UcmFuc2FjdGlvbi5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvVmlld3BvcnRNZXRyaWNzLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9hY2N1bXVsYXRlLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9hZGxlcjMyLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9jbG9uZVdpdGhQcm9wcy5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvY29udGFpbnNOb2RlLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9jb3B5UHJvcGVydGllcy5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvY3JlYXRlQXJyYXlGcm9tLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9jcmVhdGVGdWxsUGFnZUNvbXBvbmVudC5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvY3JlYXRlTm9kZXNGcm9tTWFya3VwLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9jeC5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvZGFuZ2Vyb3VzU3R5bGVWYWx1ZS5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvZW1wdHlGdW5jdGlvbi5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvZW1wdHlPYmplY3QuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL2VzY2FwZVRleHRGb3JCcm93c2VyLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9mbGF0dGVuQ2hpbGRyZW4uanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL2ZvY3VzTm9kZS5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvZm9yRWFjaEFjY3VtdWxhdGVkLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9nZXRBY3RpdmVFbGVtZW50LmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9nZXRFdmVudEtleS5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvZ2V0RXZlbnRNb2RpZmllclN0YXRlLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9nZXRFdmVudFRhcmdldC5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvZ2V0TWFya3VwV3JhcC5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldC5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9nZXRUZXh0Q29udGVudEFjY2Vzc29yLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9nZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbi5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvaHlwaGVuYXRlLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9oeXBoZW5hdGVTdHlsZU5hbWUuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL2ludmFyaWFudC5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvaXNFdmVudFN1cHBvcnRlZC5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvaXNOb2RlLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9pc1RleHRJbnB1dEVsZW1lbnQuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL2lzVGV4dE5vZGUuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL2pvaW5DbGFzc2VzLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9rZXlNaXJyb3IuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL2tleU9mLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9tYXBPYmplY3QuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL21lbW9pemVTdHJpbmdPbmx5LmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9tZXJnZS5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvbWVyZ2VIZWxwZXJzLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9tZXJnZUludG8uanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL21peEludG8uanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL21vbml0b3JDb2RlVXNlLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9vbmx5Q2hpbGQuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL3BlcmZvcm1hbmNlLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9wZXJmb3JtYW5jZU5vdy5qcyIsIi9Vc2Vycy9jaGFybGllc2Nod2FiYWNoZXIvQ29kZS9zaW5lc2F3L25vZGVfbW9kdWxlcy9yZWFjdC9saWIvc2V0SW5uZXJIVE1MLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9zaGFsbG93RXF1YWwuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL3Nob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50LmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi90b0FycmF5LmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi90cmF2ZXJzZUFsbENoaWxkcmVuLmpzIiwiL1VzZXJzL2NoYXJsaWVzY2h3YWJhY2hlci9Db2RlL3NpbmVzYXcvbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi91cGRhdGUuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvbGliL3dhcm5pbmcuanMiLCIvVXNlcnMvY2hhcmxpZXNjaHdhYmFjaGVyL0NvZGUvc2luZXNhdy9ub2RlX21vZHVsZXMvcmVhY3QvcmVhY3QuanMiXSwibmFtZXMiOltd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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcm1DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzc1RkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25ZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbk1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25OQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcGFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ROQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5YUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcmFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25NQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJ3aW5kb3cuUmVhY3QgPSByZXF1aXJlICdyZWFjdCdcbndpbmRvdy5JbW11dGFibGUgPSByZXF1aXJlICdpbW11dGFibGUnXG53aW5kb3cuQXBwID0gcmVxdWlyZSAnLi9hcHAnXG5cbiMgZXhwb3J0IHRoZXNlIGZvciBiZXR0ZXIgZXJyb3IgbWVzc2FnZXNcbndpbmRvdy5UcmFja1NlbGVjdGlvbiA9IHJlcXVpcmUgJy4vdWkvdHJhY2tfc2VsZWN0aW9uJ1xud2luZG93Lk1ldGVyID0gcmVxdWlyZSAnLi91aS9tZXRlcidcbndpbmRvdy5QaWFub1JvbGwgPSByZXF1aXJlICcuL3VpL3BpYW5vX3JvbGwnXG53aW5kb3cuR3JpZExpbmVzID0gcmVxdWlyZSAnLi91aS9waWFub19yb2xsL2dyaWRfbGluZXMnXG53aW5kb3cuS2V5cyA9IHJlcXVpcmUgJy4vdWkvcGlhbm9fcm9sbC9rZXlzJ1xud2luZG93Lk5vdGVzID0gcmVxdWlyZSAnLi91aS9waWFub19yb2xsL25vdGVzJ1xud2luZG93LlBsYXliYWNrTWFya2VyID0gcmVxdWlyZSAnLi91aS9waWFub19yb2xsL3BsYXliYWNrX21hcmtlcidcbndpbmRvdy5TZWxlY3Rpb24gPSByZXF1aXJlICcuL3VpL3BpYW5vX3JvbGwvc2VsZWN0aW9uJ1xuXG4jICMgaW5qZWN0IHJlcXVlc3QgYW5pbWF0aW9uIGZyYW1lIGJhdGNoaW5nIHN0cmF0ZWd5IGludG9cbiMgcmVxdWlyZSgncmVhY3QtcmFmLWJhdGNoaW5nJykuaW5qZWN0KClcblxuc2V0VGltZW91dCAtPlxuICBcbiAgcmVxdWlyZSgnLi9kZWZhdWx0X3NvbmcnKSAoc29uZ0RhdGEpIC0+XG5cbiAgICByZW5kZXIgPSAoZGF0YSkgLT5cbiAgICAgIFJlYWN0LnJlbmRlckNvbXBvbmVudCBBcHAoc29uZzogZGF0YS5jdXJzb3IgcmVuZGVyKSwgZG9jdW1lbnQuYm9keVxuXG4gICAgcmVuZGVyIEltbXV0YWJsZS5mcm9tSlMgc29uZ0RhdGFcbiIsIlxuXG5SZWFjdCA9IHJlcXVpcmUgJ3JlYWN0L2FkZG9ucydcblVwZGF0YWJsZSA9IHJlcXVpcmUgJy4vdWkvbWl4aW5zL3VwZGF0YWJsZSdcbk1vZGVsYWJsZSA9IHJlcXVpcmUgJy4vdWkvbWl4aW5zL21vZGVsYWJsZSdcblNvbmcgPSByZXF1aXJlICcuL21vZGVscy9zb25nJ1xuVHJhY2sgPSByZXF1aXJlICcuL21vZGVscy90cmFjaydcbkRydW1raXRTeW50aGVzaXplciA9IHJlcXVpcmUgJy4vbW9kZWxzL2RydW1raXRfc3ludGhlc2l6ZXInXG5BbmFsb2dTeW50aGVzaXplciA9IHJlcXVpcmUgJy4vbW9kZWxzL2FuYWxvZ19zeW50aGVzaXplcidcbkJhc2ljU2FtcGxlciA9IHJlcXVpcmUgJy4vbW9kZWxzL2Jhc2ljX3NhbXBsZXInXG5Mb29wU2FtcGxlciA9IHJlcXVpcmUgJy4vbW9kZWxzL2xvb3Bfc2FtcGxlcidcbkRydW1TYW1wbGVyID0gcmVxdWlyZSAnLi9tb2RlbHMvZHJ1bV9zYW1wbGVyJ1xuUGxheWJhY2tDb250cm9sID0gcmVxdWlyZSAnLi91aS9wbGF5YmFja19jb250cm9sJ1xuVHJhY2tTZWxlY3Rpb24gPSByZXF1aXJlICcuL3VpL3RyYWNrX3NlbGVjdGlvbidcblBpYW5vUm9sbCA9IHJlcXVpcmUgJy4vdWkvcGlhbm9fcm9sbCdcbkFuYWxvZ1N5bnRoZXNpemVyQ29udHJvbCA9IHJlcXVpcmUgJy4vdWkvYW5hbG9nX3N5bnRoZXNpemVyX2NvbnRyb2wnXG5EcnVta2l0U3ludGhlc2l6ZXJDb250cm9sID0gcmVxdWlyZSAnLi91aS9kcnVta2l0X3N5bnRoZXNpemVyX2NvbnRyb2wnXG5CYXNpY1NhbXBsZXJDb250cm9sID0gcmVxdWlyZSAnLi91aS9iYXNpY19zYW1wbGVyX2NvbnRyb2wnXG5EcnVtU2FtcGxlckNvbnRyb2wgPSByZXF1aXJlICcuL3VpL2RydW1fc2FtcGxlcl9jb250cm9sJ1xuTG9vcFNhbXBsZXJDb250cm9sID0gcmVxdWlyZSAnLi91aS9sb29wX3NhbXBsZXJfY29udHJvbCdcbk1vZGFsID0gcmVxdWlyZSAnLi91aS9tb2RhbCdcblJlYWN0Q1NTVHJhbnNpdGlvbkdyb3VwID0gUmVhY3QuYWRkb25zLkNTU1RyYW5zaXRpb25Hcm91cFxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0LmNyZWF0ZUNsYXNzXG5cbiAgbWl4aW5zOiBbTW9kZWxhYmxlLCBVcGRhdGFibGVdXG5cbiAgZ2V0SW5pdGlhbFN0YXRlOiAtPlxuICAgIHNlbGVjdGVkVHJhY2s6IDBcbiAgICBtb2RhbENvbnRlbnQ6IG51bGxcblxuICBsYXVuY2hNb2RhbDogKG1vZGFsQ29udGVudCkgLT5cbiAgICBAcHJvcHMuc29uZy51cGRhdGUgKHNvbmcpIC0+IHNvbmcuc2V0ICdwbGF5aW5nJywgZmFsc2VcbiAgICBAc2V0U3RhdGUge21vZGFsQ29udGVudH1cblxuICBkaXNtaXNzTW9kYWw6IC0+XG4gICAgQHNldFN0YXRlIG1vZGFsQ29udGVudDogbnVsbFxuXG4gIHJlbmRlcjogLT5cbiAgICB0cmFjayA9IEBwcm9wcy5zb25nLmN1cnNvciBbJ3RyYWNrcycsIEBzdGF0ZS5zZWxlY3RlZFRyYWNrXVxuXG4gICAgaWYgdHJhY2tcbiAgICAgIHNlcXVlbmNlID0gdHJhY2suY3Vyc29yICdzZXF1ZW5jZSdcbiAgICAgIGluc3RydW1lbnQgPSB0cmFjay5jdXJzb3IgJ2luc3RydW1lbnQnXG5cbiAgICAgIGNvbnRyb2xDbGFzcyA9IHN3aXRjaCBpbnN0cnVtZW50LmdldCAnX3R5cGUnXG4gICAgICAgIHdoZW4gJ0Jhc2ljU2FtcGxlcicgdGhlbiBCYXNpY1NhbXBsZXJDb250cm9sXG4gICAgICAgIHdoZW4gJ0FuYWxvZ1N5bnRoZXNpemVyJyB0aGVuIEFuYWxvZ1N5bnRoZXNpemVyQ29udHJvbFxuICAgICAgICB3aGVuICdEcnVta2l0U3ludGhlc2l6ZXInIHRoZW4gRHJ1bWtpdFN5bnRoZXNpemVyQ29udHJvbFxuICAgICAgICB3aGVuICdEcnVtU2FtcGxlcicgdGhlbiBEcnVtU2FtcGxlckNvbnRyb2xcbiAgICAgICAgd2hlbiAnTG9vcFNhbXBsZXInIHRoZW4gTG9vcFNhbXBsZXJDb250cm9sXG4gICAgICAgIGVsc2UgbnVsbFxuXG4gICAgICBpZiBjb250cm9sQ2xhc3M/XG4gICAgICAgIGluc3RydW1lbnRDb250cm9sID0gY29udHJvbENsYXNzKHtcImtleVwiOiAodHJhY2suZ2V0ICdfaWQnKSwgXCJpbnN0cnVtZW50XCI6IChpbnN0cnVtZW50KSwgXCJhcHBcIjogKHRoaXMpfSlcblxuICAgIGlmIEBzdGF0ZS5tb2RhbENvbnRlbnQ/XG4gICAgICBtb2RhbCA9IE1vZGFsKHtcImtleVwiOiAnbSd9LCAoQHN0YXRlLm1vZGFsQ29udGVudCkpXG5cbiAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcImFwcFwifSwgXG4gICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcInJvdyBwbGF5YmFja1wifSwgXG4gICAgICAgIFBsYXliYWNrQ29udHJvbCh7XCJzb25nXCI6IChAcHJvcHMuc29uZyl9KVxuICAgICAgKSwgXG4gICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcInJvdyBtYWluXCJ9LCBcbiAgICAgICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJjb2x1bW4gc2lkZWJhclwifSwgXG4gICAgICAgICAgVHJhY2tTZWxlY3Rpb24oeyBcXFxuICAgICAgICAgICAgXCJ0cmFja3NcIjogKEBwcm9wcy5zb25nLmN1cnNvciAndHJhY2tzJyksICBcXFxuICAgICAgICAgICAgXCJzZWxlY3RlZFRyYWNrXCI6IChAc3RhdGUuc2VsZWN0ZWRUcmFjayksICBcXFxuICAgICAgICAgICAgXCJzZWxlY3RUcmFja1wiOiAoQHVwZGF0ZSAnc2VsZWN0ZWRUcmFjaycpXG4gICAgICAgICAgfSlcbiAgICAgICAgKSwgXG4gICAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwiY29sdW1uIG1haW5cIn0sIFxuICAgICAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwicm93IHNlcXVlbmNlXCJ9LCBcbiAgICAgICAgICAgIFBpYW5vUm9sbCh7XCJzb25nXCI6IChAcHJvcHMuc29uZyksIFwic2VxdWVuY2VcIjogKHNlcXVlbmNlKX0pXG4gICAgICAgICAgKSwgXG4gICAgICAgICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJyb3cgaW5zdHJ1bWVudFwifSwgXG4gICAgICAgICAgICAoaW5zdHJ1bWVudENvbnRyb2wpXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICApLCBcbiAgICAgIFJlYWN0Q1NTVHJhbnNpdGlvbkdyb3VwKHtcInRyYW5zaXRpb25OYW1lXCI6IFwibW9kYWxcIn0sIFxuICAgICAgICAobW9kYWwpXG4gICAgICApXG4gICAgKVxuIiwiYXN5bmMgPSByZXF1aXJlICdhc3luYydcbmZzID0gcmVxdWlyZSAnZnMnXG5iMmEgPSByZXF1aXJlICdiYXNlNjQtYXJyYXlidWZmZXInXG5jdWlkID0gcmVxdWlyZSAnY3VpZCdcbmRlY29kZXIgPSBuZXcgd2Via2l0QXVkaW9Db250ZXh0XG5cbmJhc3MgPSBiMmEuZGVjb2RlIGZzLnJlYWRGaWxlU3luYyBcIiN7X19kaXJuYW1lfS8uLi9hdWRpby9iYXNzLndhdlwiLCAnYmFzZTY0J1xua2ljayA9IGIyYS5kZWNvZGUgZnMucmVhZEZpbGVTeW5jIFwiI3tfX2Rpcm5hbWV9Ly4uL2F1ZGlvL2tpY2sud2F2XCIsICdiYXNlNjQnXG5zbmFyZSA9IGIyYS5kZWNvZGUgZnMucmVhZEZpbGVTeW5jIFwiI3tfX2Rpcm5hbWV9Ly4uL2F1ZGlvL3NuYXJlLndhdlwiLCAnYmFzZTY0J1xuaGF0ID0gYjJhLmRlY29kZSBmcy5yZWFkRmlsZVN5bmMgXCIje19fZGlybmFtZX0vLi4vYXVkaW8vaGF0LndhdlwiLCAnYmFzZTY0J1xuXG5cbmxvYWRlZCA9IGZhbHNlXG5kYXRhID0gbnVsbFxuY2FsbGJhY2tzID0gW11cblxuXG5tb2R1bGUuZXhwb3J0cyA9IChjYikgLT5cbiAgaWYgbG9hZGVkXG4gICAgY2IgZGF0YVxuICBlbHNlXG4gICAgY2FsbGJhY2tzLnB1c2ggY2JcblxuXG4jIGxvYWQgc2FtcGxlIGRhdGFcbmFzeW5jLnBhcmFsbGVsXG4gIGJhc3M6IChjYikgLT4gZGVjb2Rlci5kZWNvZGVBdWRpb0RhdGEgYmFzcywgKGJ1ZmZlcikgLT4gY2IgbnVsbCwgYnVmZmVyXG4gIGtpY2s6IChjYikgLT4gZGVjb2Rlci5kZWNvZGVBdWRpb0RhdGEga2ljaywgKGJ1ZmZlcikgLT4gY2IgbnVsbCwgYnVmZmVyXG4gIHNuYXJlOiAoY2IpIC0+IGRlY29kZXIuZGVjb2RlQXVkaW9EYXRhIHNuYXJlLCAoYnVmZmVyKSAtPiBjYiBudWxsLCBidWZmZXJcbiAgaGF0OiAoY2IpIC0+IGRlY29kZXIuZGVjb2RlQXVkaW9EYXRhIGhhdCwgKGJ1ZmZlcikgLT4gY2IgbnVsbCwgYnVmZmVyXG5cbiAgKGVyciwgcmVzdWx0cykgLT5cblxuICAgIGRhdGEgPVxuICAgICAgX2lkOiBjdWlkKClcbiAgICAgIGJwbTogMTIwXG4gICAgICBwbGF5aW5nOiBmYWxzZVxuICAgICAgcmVjb3JkaW5nOiBmYWxzZVxuICAgICAgcG9zaXRpb246IDBcbiAgICAgIHRyYWNrczogW1xuICAgICAgICB7XG4gICAgICAgICAgX2lkOiBjdWlkKClcbiAgICAgICAgICBuYW1lOiAnQmFzaWMgU2FtcGxlcidcbiAgICAgICAgICBtZXRlckxldmVsOiAwXG4gICAgICAgICAgc2VxdWVuY2U6XG4gICAgICAgICAgICBfaWQ6IGN1aWQoKVxuICAgICAgICAgICAgbG9vcFNpemU6IDRcbiAgICAgICAgICAgIG5vdGVzOiB7fVxuICAgICAgICAgIGluc3RydW1lbnQ6XG4gICAgICAgICAgICBfaWQ6IGN1aWQoKVxuICAgICAgICAgICAgX3R5cGU6ICdCYXNpY1NhbXBsZXInXG4gICAgICAgICAgICBsZXZlbDogMC41XG4gICAgICAgICAgICBwYW46IDAuNVxuICAgICAgICAgICAgcG9seXBob255OiAxXG4gICAgICAgICAgICByb290S2V5OiA2MFxuICAgICAgICAgICAgc2FtcGxlRGF0YTogcmVzdWx0cy5iYXNzLmdldENoYW5uZWxEYXRhIDBcbiAgICAgICAgICAgIHNhbXBsZU5hbWU6ICdiYXNzLndhdidcbiAgICAgICAgICAgIHN0YXJ0OiAwLjNcbiAgICAgICAgICAgIGxvb3BBY3RpdmU6ICdsb29wJ1xuICAgICAgICAgICAgbG9vcDogMC43XG4gICAgICAgICAgICB0dW5lOiAwLjVcbiAgICAgICAgICAgIHZvbHVtZUVudjpcbiAgICAgICAgICAgICAgYTogMFxuICAgICAgICAgICAgICBkOiAwLjI1XG4gICAgICAgICAgICAgIHM6IDFcbiAgICAgICAgICAgICAgcjogMC41XG4gICAgICAgICAgICBmaWx0ZXJFbnY6XG4gICAgICAgICAgICAgIGE6IDBcbiAgICAgICAgICAgICAgZDogMC4yNVxuICAgICAgICAgICAgICBzOiAxXG4gICAgICAgICAgICAgIHI6IDAuNVxuICAgICAgICAgICAgZmlsdGVyOlxuICAgICAgICAgICAgICB0eXBlOiAnbm9uZSdcbiAgICAgICAgICAgICAgZnJlcTogMC4yN1xuICAgICAgICAgICAgICByZXM6IDAuMDVcbiAgICAgICAgICAgICAgZW52OiAwLjQ1XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBfaWQ6IGN1aWQoKVxuICAgICAgICAgIG5hbWU6ICdEcnVtIFNhbXBsZXInXG4gICAgICAgICAgbWV0ZXJMZXZlbDogMFxuICAgICAgICAgIHNlcXVlbmNlOlxuICAgICAgICAgICAgX2lkOiBjdWlkKClcbiAgICAgICAgICAgIGxvb3BTaXplOiA0XG4gICAgICAgICAgICBub3Rlczoge31cbiAgICAgICAgICBpbnN0cnVtZW50OlxuICAgICAgICAgICAgX2lkOiBjdWlkKClcbiAgICAgICAgICAgIF90eXBlOiAnRHJ1bVNhbXBsZXInXG4gICAgICAgICAgICBsZXZlbDogMC41XG4gICAgICAgICAgICBwYW46IDAuNVxuICAgICAgICAgICAgZHJ1bXM6IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdLaWNrJ1xuICAgICAgICAgICAgICAgIHNhbXBsZURhdGE6IHJlc3VsdHMua2ljay5nZXRDaGFubmVsRGF0YSAwXG4gICAgICAgICAgICAgICAgc2FtcGxlTmFtZTogJ2tpY2sud2F2J1xuICAgICAgICAgICAgICAgIHRyYW5zcG9zZTogMFxuICAgICAgICAgICAgICAgIGxldmVsOiAxXG4gICAgICAgICAgICAgICAga2V5OiAwXG4gICAgICAgICAgICAgICAgc3RhcnQ6IDBcbiAgICAgICAgICAgICAgICB2b2x1bWVFbnY6XG4gICAgICAgICAgICAgICAgICBhOiAwXG4gICAgICAgICAgICAgICAgICBkOiAxXG4gICAgICAgICAgICAgICAgICBzOiAxXG4gICAgICAgICAgICAgICAgICByOiAxXG4gICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnU25hcmUnXG4gICAgICAgICAgICAgICAgc2FtcGxlRGF0YTogcmVzdWx0cy5zbmFyZS5nZXRDaGFubmVsRGF0YSAwXG4gICAgICAgICAgICAgICAgc2FtcGxlTmFtZTogJ3NuYXJlLndhdidcbiAgICAgICAgICAgICAgICB0cmFuc3Bvc2U6IDBcbiAgICAgICAgICAgICAgICBsZXZlbDogMC4zNVxuICAgICAgICAgICAgICAgIGtleTogMVxuICAgICAgICAgICAgICAgIHN0YXJ0OiAwXG4gICAgICAgICAgICAgICAgdm9sdW1lRW52OlxuICAgICAgICAgICAgICAgICAgYTogMFxuICAgICAgICAgICAgICAgICAgZDogMVxuICAgICAgICAgICAgICAgICAgczogMVxuICAgICAgICAgICAgICAgICAgcjogMVxuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ0hpZ2ggSGF0J1xuICAgICAgICAgICAgICAgIHNhbXBsZURhdGE6IHJlc3VsdHMuaGF0LmdldENoYW5uZWxEYXRhIDBcbiAgICAgICAgICAgICAgICBzYW1wbGVOYW1lOiAnaGF0LndhdidcbiAgICAgICAgICAgICAgICB0cmFuc3Bvc2U6IDBcbiAgICAgICAgICAgICAgICBsZXZlbDogMC4yXG4gICAgICAgICAgICAgICAga2V5OiAyXG4gICAgICAgICAgICAgICAgc3RhcnQ6IDBcbiAgICAgICAgICAgICAgICB2b2x1bWVFbnY6XG4gICAgICAgICAgICAgICAgICBhOiAwXG4gICAgICAgICAgICAgICAgICBkOiAxXG4gICAgICAgICAgICAgICAgICBzOiAxXG4gICAgICAgICAgICAgICAgICByOiAxXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgICAgXVxuXG4gICAgY2IgZGF0YSBmb3IgY2IgaW4gY2FsbGJhY2tzXG4iLCJjb250ZXh0ID0gcmVxdWlyZSAnLi9nbG9iYWxfY29udGV4dCdcblxud29ya2VyU2NyaXB0ID0gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbJygnLCAoKHdpbmRvdykgLT5cblxuICBidWZmZXJzID0gW11cbiAgbGVuZ3RoID0gMFxuXG4gIHJlY29yZCA9IChpbnB1dEJ1ZmZlcikgLT5cbiAgICBidWZmZXJzLnB1c2ggaW5wdXRCdWZmZXJcbiAgICBsZW5ndGggKz0gaW5wdXRCdWZmZXIubGVuZ3RoXG5cbiAgY2xlYXIgPSAtPlxuICAgIGJ1ZmZlcnMgPSBbXVxuICAgIGxlbmd0aCA9IDBcblxuICBnZXRTYW1wbGVEYXRhID0gLT5cbiAgICAjIGpvaW4gYnVmZmVycyBpbnRvIGZsb2F0IGFycmF5XG4gICAgc2FtcGxlRGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkgbGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAgIGZvciBidWZmZXIgaW4gYnVmZmVyc1xuICAgICAgc2FtcGxlRGF0YS5zZXQgYnVmZmVyLCBvZmZzZXRcbiAgICAgIG9mZnNldCArPSBidWZmZXIubGVuZ3RoXG5cbiAgICAjIG5vcm1hbGl6ZVxuICAgIG1heCA9IC1JbmZpbml0eVxuICAgIGZvciB2YWx1ZSwgaSBpbiBzYW1wbGVEYXRhXG4gICAgICB2ID0gTWF0aC5hYnMgdmFsdWVcbiAgICAgIG1heCA9IHYgaWYgdiA+IG1heFxuXG4gICAgZm9yIHZhbHVlLCBpIGluIHNhbXBsZURhdGFcbiAgICAgIHNhbXBsZURhdGFbaV0gPSB2YWx1ZSAvIG1heFxuXG4gICAgd2luZG93LnBvc3RNZXNzYWdlIHNhbXBsZURhdGFcblxuICB3aW5kb3cub25tZXNzYWdlID0gKGUpIC0+XG4gICAgc3dpdGNoIGUuZGF0YS5jb21tYW5kXG4gICAgICB3aGVuICdyZWNvcmQnIHRoZW4gcmVjb3JkIGUuZGF0YS5idWZmZXJcbiAgICAgIHdoZW4gJ2NsZWFyJyB0aGVuIGNsZWFyKClcbiAgICAgIHdoZW4gJ2dldFNhbXBsZURhdGEnIHRoZW4gZ2V0U2FtcGxlRGF0YSgpXG5cbikudG9TdHJpbmcoKSwgJykodGhpcyknXSwgdHlwZTogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnKSlcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIEF1ZGlvUmVjb3JkZXJcblxuICBjb25zdHJ1Y3RvcjogKGlucHV0KSAtPlxuICAgIEBpbnB1dCA9IGlucHV0XG4gICAgQHJlY29yZGVyID0gY29udGV4dC5jcmVhdGVTY3JpcHRQcm9jZXNzb3IgNDA5NiwgMSwgMVxuICAgIEByZWNvcmRpbmcgPSBmYWxzZVxuICAgIEB3b3JrZXIgPSBuZXcgV29ya2VyIHdvcmtlclNjcmlwdFxuICAgIFxuICAgIEByZWNvcmRlci5vbmF1ZGlvcHJvY2VzcyA9IChlKSA9PlxuICAgICAgcmV0dXJuIHVubGVzcyBAcmVjb3JkaW5nXG4gICAgICBAd29ya2VyLnBvc3RNZXNzYWdlXG4gICAgICAgIGNvbW1hbmQ6ICdyZWNvcmQnXG4gICAgICAgIGJ1ZmZlcjogZS5pbnB1dEJ1ZmZlci5nZXRDaGFubmVsRGF0YSAwXG5cbiAgICBAd29ya2VyLm9ubWVzc2FnZSA9IChlKSA9PlxuICAgICAgQGN1cnJlbnRDYWxsYmFjaz8oZS5kYXRhKVxuICAgICAgQGN1cnJlbnRDYWxsYmFjayA9IG51bGxcblxuICAgIEBpbnB1dC5jb25uZWN0IEByZWNvcmRlclxuICAgIEByZWNvcmRlci5jb25uZWN0IGNvbnRleHQuZGVzdGluYXRpb25cblxuICByZWNvcmQ6IC0+XG4gICAgQHJlY29yZGluZyA9IHRydWVcbiAgICB0aGlzXG5cbiAgc3RvcDogLT5cbiAgICBAcmVjb3JkaW5nID0gZmFsc2VcbiAgICB0aGlzXG5cbiAgY2xlYXI6IC0+XG4gICAgQHdvcmtlci5wb3N0TWVzc2FnZSBjb21tYW5kOiAnY2xlYXInXG4gICAgdGhpc1xuXG4gIGdldFNhbXBsZURhdGE6IChjYWxsYmFjaykgLT5cbiAgICBAY3VycmVudENhbGxiYWNrID0gY2FsbGJhY2tcbiAgICBAd29ya2VyLnBvc3RNZXNzYWdlIGNvbW1hbmQ6ICdnZXRTYW1wbGVEYXRhJ1xuICAgIHRoaXNcbiIsIm1pbkVudlZhbHVlID0gMC4wMVxuXG5tb2R1bGUuZXhwb3J0cyA9IChlbnYsIG5vdGUsIHRpbWUpIC0+XG5cbiAgZWxhcHNlZCA9IHRpbWUgLSBub3RlLnRpbWVcbiAgYSA9IE1hdGgubWF4IG1pbkVudlZhbHVlLCBlbnYuYVxuICBkID0gTWF0aC5tYXggbWluRW52VmFsdWUsIGVudi5kXG4gIHMgPSBlbnYuc1xuICByID0gTWF0aC5tYXggbWluRW52VmFsdWUsIGVudi5yXG5cbiAgIyBhdHRhY2ssIGRlY2F5LCBzdXN0YWluXG4gIGwgPSBpZiBlbGFwc2VkID4gYSArIGRcbiAgICBsID0gc1xuICBlbHNlIGlmIGVsYXBzZWQgPiBhXG4gICAgbCA9IHMgKyAoMSAtIHMpICogKGEgKyBkIC0gZWxhcHNlZCkgLyBkXG4gIGVsc2VcbiAgICBlbGFwc2VkIC8gYVxuXG4gICMgcmVsZWFzZVxuICBpZiBlbGFwc2VkID4gbm90ZS5sZW5cbiAgICBsID0gbCAqIChyICsgbm90ZS5sZW4gLSBlbGFwc2VkKSAvIHJcblxuICBNYXRoLm1heCAwLCBsXG4iLCJtb2R1bGUuZXhwb3J0cyA9IG5ldyB3ZWJraXRBdWRpb0NvbnRleHRcbiIsInNhbXBsZVJhdGUgPSA0ODAwMFxubWF4RnJlcSA9IDEyMDAwXG5kYkdhaW4gPSAxMiAgICAjIGdhaW4gb2YgZmlsdGVyXG5iYW5kd2lkdGggPSAxICAjIGJhbmR3aWR0aCBpbiBvY3RhdmVzXG5cbiMgY29uc3RhbnRzXG5BID0gTWF0aC5wb3coMTAsIGRiR2FpbiAvIDQwKVxuZSA9IE1hdGgubG9nKDIpXG50YXUgPSAyICogTWF0aC5QSVxuYmV0YSA9IE1hdGguc3FydCgyICogQSlcblxuIyBoeXBlcmJvbGljIHNpbiBmdW5jdGlvblxuc2luaCA9ICh4KSAtPlxuICB5ID0gTWF0aC5leHAgeFxuICAoeSAtIDEgLyB5KSAvIDJcblxubW9kdWxlLmV4cG9ydHMgPSAtPlxuICBhMCA9IGExID0gYTIgPSBhMyA9IGE0ID0geDEgPSB4MiA9IHkxID0geTIgPSAwXG4gIGZyZXEgPSBvbWVnYSA9IHNuID0gYWxwaGEgPSAwXG4gIGNzID0gMVxuXG4gIGxhc3RDdXRvZmYgPSAwXG5cbiAgKHNhbXBsZSwgY3V0b2ZmKSAtPlxuICAgICMgY2FjaGUgZmlsdGVyIHZhbHVlcyB1bnRpbCBjdXRvZmYgY2hhbmdlc1xuICAgIGlmIGN1dG9mZiAhPSBsYXN0Q3V0b2ZmXG4gIFxuICAgICAgb2xkQ3V0b2ZmID0gY3V0b2ZmXG5cbiAgICAgIGZyZXEgPSBjdXRvZmYgKiBtYXhGcmVxXG4gICAgICBvbWVnYSA9IHRhdSAqIGZyZXEgLyBzYW1wbGVSYXRlXG4gICAgICBzbiA9IE1hdGguc2luIG9tZWdhXG4gICAgICBjcyA9IE1hdGguY29zIG9tZWdhXG4gICAgICBhbHBoYSA9IHNuICogc2luaChlIC8gMiAqIGJhbmR3aWR0aCAqIG9tZWdhIC8gc24pXG5cbiAgICAgIGIwID0gKDEgKyBjcykgLyAyXG4gICAgICBiMSA9IC0oMSArIGNzKVxuICAgICAgYjIgPSAoMSArIGNzKSAvIDJcbiAgICAgIGFhMCA9IDEgKyBhbHBoYVxuICAgICAgYWExID0gLTIgKiBjc1xuICAgICAgYWEyID0gMSAtIGFscGhhXG5cbiAgICAgIGEwID0gYjAgLyBhYTBcbiAgICAgIGExID0gYjEgLyBhYTBcbiAgICAgIGEyID0gYjIgLyBhYTBcbiAgICAgIGEzID0gYWExIC8gYWEwXG4gICAgICBhNCA9IGFhMiAvIGFhMFxuXG4gICAgIyBjb21wdXRlIHJlc3VsdFxuICAgIHMgPSBNYXRoLm1heCAtMSwgTWF0aC5taW4gMSwgc2FtcGxlXG4gICAgcmVzdWx0ID0gYTAgKiBzICsgYTEgKiB4MSArIGEyICogeDIgLSBhMyAqIHkxIC0gYTQgKiB5MlxuXG4gICAgIyBzaGlmdCB4MSB0byB4Miwgc2FtcGxlIHRvIHgxXG4gICAgeDIgPSB4MVxuICAgIHgxID0gc1xuXG4gICAgIyBzaGlmdCB5MSB0byB5MiwgcmVzdWx0IHRvIHkxXG4gICAgeTIgPSB5MVxuICAgIHkxID0gcmVzdWx0XG5cbiAgICByZXN1bHQiLCJtb2R1bGUuZXhwb3J0cyA9IChzYW1wbGVEYXRhLCB0cmFuc3Bvc2UsIHNhbXBsZXNFbGFwc2VkLCBvZmZzZXQgPSAwLCBsb29wQWN0aXZlID0gZmFsc2UsIGxvb3BQb2ludCkgLT5cbiAgaSA9IHNhbXBsZXNFbGFwc2VkICogTWF0aC5wb3cgMiwgdHJhbnNwb3NlIC8gMTJcbiAgaTEgPSBNYXRoLmZsb29yIGlcbiAgaTEgPSBpMSAlIChsb29wUG9pbnQgLSBvZmZzZXQpIGlmIGxvb3BBY3RpdmVcbiAgaTIgPSBpMSArIDFcbiAgbCA9IGkgJSAxXG5cbiAgc2FtcGxlRGF0YVtvZmZzZXQgKyBpMV0gKiAoMSAtIGwpICsgc2FtcGxlRGF0YVtvZmZzZXQgKyBpMl0gKiBsIiwic2FtcGxlUmF0ZSA9IDQ4MDAwXG5cbm1vZHVsZS5leHBvcnRzID0gLT5cblxuICB5MSA9IHkyID0geTMgPSB5NCA9IG9sZHggPSBvbGR5MSA9IG9sZHkyID0gb2xkeTMgPSAwXG4gIHAgPSBrID0gdDEgPSB0MiA9IHIgPSB4ID0gbnVsbFxuXG4gIChzYW1wbGUsIGN1dG9mZiwgcmVzKSAtPlxuICAgIGZyZXEgPSAyMCAqIE1hdGgucG93IDEwLCAzICogY3V0b2ZmXG4gICAgZnJlcSA9IGZyZXEgLyBzYW1wbGVSYXRlXG4gICAgcCA9IGZyZXEgKiAoMS44IC0gKDAuOCAqIGZyZXEpKVxuICAgIGsgPSAyICogTWF0aC5zaW4oZnJlcSAqIE1hdGguUEkgLyAyKSAtIDFcbiAgICB0MSA9ICgxIC0gcCkgKiAxLjM4NjI0OVxuICAgIHQyID0gMTIgKyB0MSAqIHQxXG4gICAgciA9IHJlcyAqIDAuNTcgKiAodDIgKyA2ICogdDEpIC8gKHQyIC0gNiAqIHQxKVxuXG4gICAgeCA9IHNhbXBsZSAtIHIgKiB5NFxuXG4gICAgIyBmb3VyIGNhc2NhZGVkIG9uZS1wb2xlIGZpbHRlcnMgKGJpbGluZWFyIHRyYW5zZm9ybSlcbiAgICB5MSA9ICB4ICogcCArIG9sZHggICogcCAtIGsgKiB5MVxuICAgIHkyID0geTEgKiBwICsgb2xkeTEgKiBwIC0gayAqIHkyXG4gICAgeTMgPSB5MiAqIHAgKyBvbGR5MiAqIHAgLSBrICogeTNcbiAgICB5NCA9IHkzICogcCArIG9sZHkzICogcCAtIGsgKiB5NFxuXG4gICAgIyBjbGlwcGVyIGJhbmQgbGltaXRlZCBzaWdtb2lkXG4gICAgeTQgLT0gKHk0ICogeTQgKiB5NCkgLyA2XG5cbiAgICBvbGR4ID0geFxuICAgIG9sZHkxID0geTFcbiAgICBvbGR5MiA9IHkyXG4gICAgb2xkeTMgPSB5M1xuXG4gICAgeTQiLCJ0YXUgPSBNYXRoLlBJICogMlxuXG5tb2R1bGUuZXhwb3J0cyA9XG5cbiAgc2luZTogKHRpbWUsIGZyZXF1ZW5jeSkgLT5cbiAgICBNYXRoLnNpbiB0aW1lICogdGF1ICogZnJlcXVlbmN5XG5cbiAgc3F1YXJlOiAodGltZSwgZnJlcXVlbmN5KSAtPlxuICAgIGlmICgodGltZSAlICgxIC8gZnJlcXVlbmN5KSkgKiBmcmVxdWVuY3kpICUgMSA+IDAuNSB0aGVuIDEgZWxzZSAtMVxuXG4gIHNhdzogKHRpbWUsIGZyZXF1ZW5jeSkgLT5cbiAgICAxIC0gMiAqICgoKHRpbWUgJSAoMSAvIGZyZXF1ZW5jeSkpICogZnJlcXVlbmN5KSAlIDEpXG5cbiAgbm9pc2U6IC0+XG4gICAgMiAqIE1hdGgucmFuZG9tKCkgLSAxIiwibW9kdWxlLmV4cG9ydHMgPSAoZGVjYXksIGVsYXBzZWQpIC0+XG4gIGlmIGVsYXBzZWQgPiBkZWNheVxuICAgIDBcbiAgZWxzZVxuICAgIDEgLSBlbGFwc2VkIC8gZGVjYXlcbiIsImJ1ZmZlclNpemUgPSA0MDk2XG5cbm1vZHVsZS5leHBvcnRzID0gKGNvbnRleHQsIGZuKSAtPlxuXG4gICMgYWNjZXB0IGEgc2luZ2xlIGFyZ3VtZW50XG4gIGlmIHR5cGVvZiBjb250ZXh0IGlzICdmdW5jdGlvbidcbiAgICBDb250ZXh0ID0gd2luZG93LkF1ZGlvQ29udGV4dCBvciB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0XG4gICAgdGhyb3cgbmV3IEVycm9yICdBdWRpb0NvbnRleHQgbm90IHN1cHBvcnRlZCcgdW5sZXNzIENvbnRleHRcbiAgICBmbiA9IGNvbnRleHRcbiAgICBjb250ZXh0ID0gbmV3IENvbnRleHQoKVxuXG4gIHNlbGYgPSBjb250ZXh0LmNyZWF0ZVNjcmlwdFByb2Nlc3NvciBidWZmZXJTaXplLCAxLCAxXG4gIHNlbGYuZm4gPSBmblxuICBzZWxmLmkgPSBzZWxmLnQgPSAwXG4gIHdpbmRvdy5fU0FNUExFUkFURSA9IHNlbGYuc2FtcGxlUmF0ZSA9IHNlbGYucmF0ZSA9IGNvbnRleHQuc2FtcGxlUmF0ZVxuICBzZWxmLmR1cmF0aW9uID0gSW5maW5pdHlcblxuICBzZWxmLm9uYXVkaW9wcm9jZXNzID0gKGUpIC0+XG4gICAgb3V0cHV0ID0gZS5vdXRwdXRCdWZmZXIuZ2V0Q2hhbm5lbERhdGEgMFxuICAgIHNlbGYudGljayBvdXRwdXRcblxuICAjIGEgZmlsbC1hLWJ1ZmZlciBmdW5jdGlvblxuICBzZWxmLnRpY2sgPSAob3V0cHV0KSAtPlxuICAgIGZvciBpIGluIFswLi4uYnVmZmVyU2l6ZV1cbiAgICAgIHNlbGYudCA9IHNlbGYuaSAvIHNlbGYucmF0ZVxuICAgICAgc2VsZi5pICs9IDFcblxuICAgICAgb3V0cHV0W2ldID0gc2VsZi5mbiBzZWxmLnQsIHNlbGYuaVxuXG4gICAgb3V0cHV0XG4gIFxuICBzZWxmLnN0b3AgPSAtPlxuICAgIHNlbGYuZGlzY29ubmVjdCgpXG4gICAgc2VsZi5wbGF5aW5nID0gZmFsc2VcblxuICBzZWxmLnBsYXkgPSAob3B0cykgLT5cbiAgICByZXR1cm4gaWYgc2VsZi5wbGF5aW5nXG4gICAgc2VsZi5jb25uZWN0IHNlbGYuY29udGV4dC5kZXN0aW5hdGlvblxuICAgIHNlbGYucGxheWluZyA9IHRydWVcblxuICAgICMgdGhpcyB0aW1lb3V0IHNlZW1zIHRvIGJlIHRoZSB0aGluZyB0aGF0IGtlZXBzIHRoZSBhdWRpbyBmcm9tIGNsaXBwaW5nICNXVEZBTEVSVFxuICAgIHNldFRpbWVvdXQgKC0+IHRoaXMubm9kZS5kaXNjb25uZWN0KCkpLCAxMDAwMDAwMDAwMDBcblxuICBzZWxmLnJlc2V0ID0gKCkgLT5cbiAgICBzZWxmLmkgPSBzZWxmLnQgPSAwXG5cbiAgc2VsZlxuIiwiSW5zdHJ1bWVudCA9IHJlcXVpcmUgJy4vaW5zdHJ1bWVudCdcblJpbmdCdWZmZXIgPSByZXF1aXJlICcuLi91dGlsL3JpbmdfYnVmZmVyJ1xubG93cGFzc0ZpbHRlciA9IHJlcXVpcmUgJy4uL2RzcC9sb3dwYXNzX2ZpbHRlcidcbmhpZ2hwYXNzRmlsdGVyID0gcmVxdWlyZSAnLi4vZHNwL2hpZ2hwYXNzX2ZpbHRlcidcbmVudmVsb3BlID0gcmVxdWlyZSAnLi4vZHNwL2VudmVsb3BlJ1xub3NjaWxsYXRvcnMgPSByZXF1aXJlICcuLi9kc3Avb3NjaWxsYXRvcnMnXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgQW5hbG9nU3ludGhlc2l6ZXIgZXh0ZW5kcyBJbnN0cnVtZW50XG5cbiAgQGRlZmF1bHRzOlxuICAgIF90eXBlOiAnQW5hbG9nU3ludGhlc2l6ZXInXG4gICAgbGV2ZWw6IDAuNVxuICAgIHBhbjogMC41XG4gICAgcG9seXBob255OiAzXG4gICAgbWF4UG9seXBob255OiA2XG4gICAgdm9sdW1lRW52OlxuICAgICAgYTogMFxuICAgICAgZDogMC4yNVxuICAgICAgczogMFxuICAgICAgcjogMC41XG4gICAgZmlsdGVyRW52OlxuICAgICAgYTogMFxuICAgICAgZDogMC4yNVxuICAgICAgczogMC4yXG4gICAgICByOiAwLjVcbiAgICBmaWx0ZXI6XG4gICAgICB0eXBlOiAnTFAnXG4gICAgICBmcmVxOiAwLjI3XG4gICAgICByZXM6IDAuMDVcbiAgICAgIGVudjogMC40NVxuICAgIG9zYzE6XG4gICAgICB3YXZlZm9ybTogJ3NhdydcbiAgICAgIGxldmVsOiAwLjVcbiAgICAgIHBpdGNoOiAwLjVcbiAgICAgIHR1bmU6IDAuNVxuICAgIG9zYzI6XG4gICAgICB3YXZlZm9ybTogJ3NhdydcbiAgICAgIGxldmVsOiAwLjVcbiAgICAgIHBpdGNoOiAwLjVcbiAgICAgIHR1bmU6IDAuNVxuXG4gICMgdHVuZSA9IDQ0MFxuICAjIGZyZXF1ZW5jeSA9IChrZXkpIC0+XG4gICMgICB0dW5lICogTWF0aC5wb3cgMiwgKGtleSAtIDY5KSAvIDEyXG5cbiAgIyBjb25zdHJ1Y3RvcjogLT5cbiAgIyAgIHN1cGVyXG4gICMgICBAbm90ZXMgPSBuZXcgUmluZ0J1ZmZlciBAbWF4UG9seXBob255LCBBcnJheSwgQHN0YXRlLnBvbHlwaG9ueVxuICAjICAgQGZpbHRlcnMgPVxuICAjICAgICBMUDogKGxvd3Bhc3NGaWx0ZXIoKSBmb3IgaSBpbiBbMC4uLkBtYXhQb2x5cGhvbnldKVxuICAjICAgICBIUDogKGhpZ2hwYXNzRmlsdGVyKCkgZm9yIGkgaW4gWzAuLi5AbWF4UG9seXBob255XSlcbiAgIyAgICAgbm9uZTogKCgoc2FtcGxlKSAtPiBzYW1wbGUpIGZvciBpIGluIFswLi4uQG1heFBvbHlwaG9ueV0pXG5cbiAgIyBzZXRQb2x5cGhvbnk6IChwb2x5cGhvbnkpIC0+XG4gICMgICBAbm90ZXMucmVzaXplIHBvbHlwaG9ueVxuICAjICAgQHNldCB7cG9seXBob255fVxuXG4gICMgcmVzZXQ6IC0+XG4gICMgICBAbm90ZXMucmVzZXQoKVxuXG4gICMgb3V0OiAodGltZSkgPT5cbiAgIyAgIHJldHVybiAwIGlmIEBzdGF0ZS5sZXZlbCA9PSAwXG5cbiAgIyAgICMgc3VtIGFsbCBhY3RpdmUgbm90ZXNcbiAgIyAgIHIgPSBNYXRoLm1heCAwLjAxLCBAc3RhdGUudm9sdW1lRW52LnJcbiAgIyAgIEBzdGF0ZS5sZXZlbCAqIEBub3Rlcy5yZWR1Y2UoKG1lbW8sIG5vdGUsIGluZGV4KSA9PlxuICAjICAgICByZXR1cm4gbWVtbyB1bmxlc3Mgbm90ZT9cbiAgIyAgICAgcmV0dXJuIG1lbW8gdW5sZXNzIG5vdGUubGVuICsgciA+IHRpbWUgLSBub3RlLnRpbWVcblxuICAjICAgICAjIHN1bSBvc2NpbGxhdG9ycyBhbmQgYXBwbHkgdm9sdW1lIGVudmVsb3BlXG4gICMgICAgIG9zYzFGcmVxID0gZnJlcXVlbmN5IG5vdGUua2V5ICsgQHN0YXRlLm9zYzEudHVuZSAtIDAuNSArIE1hdGgucm91bmQoMjQgKiAoQHN0YXRlLm9zYzEucGl0Y2ggLSAwLjUpKVxuICAjICAgICBvc2MyRnJlcSA9IGZyZXF1ZW5jeSBub3RlLmtleSArIEBzdGF0ZS5vc2MyLnR1bmUgLSAwLjUgKyBNYXRoLnJvdW5kKDI0ICogKEBzdGF0ZS5vc2MyLnBpdGNoIC0gMC41KSlcbiAgIyAgICAgc2FtcGxlID0gZW52ZWxvcGUoQHN0YXRlLnZvbHVtZUVudiwgbm90ZSwgdGltZSkgKiAoXG4gICMgICAgICAgQHN0YXRlLm9zYzEubGV2ZWwgKiBvc2NpbGxhdG9yc1tAc3RhdGUub3NjMS53YXZlZm9ybV0odGltZSwgb3NjMUZyZXEpICtcbiAgIyAgICAgICBAc3RhdGUub3NjMi5sZXZlbCAqIG9zY2lsbGF0b3JzW0BzdGF0ZS5vc2MyLndhdmVmb3JtXSh0aW1lLCBvc2MyRnJlcSlcbiAgIyAgICAgKVxuXG4gICMgICAgICMgYXBwbHkgZmlsdGVyIHdpdGggZW52ZWxvcGVcbiAgIyAgICAgZmlsdGVyQ3V0b2ZmID0gTWF0aC5taW4gMSwgQHN0YXRlLmZpbHRlci5mcmVxICsgQHN0YXRlLmZpbHRlci5lbnYgKiBlbnZlbG9wZShAc3RhdGUuZmlsdGVyRW52LCBub3RlLCB0aW1lKVxuICAjICAgICBzYW1wbGUgPSBAZmlsdGVyc1tAc3RhdGUuZmlsdGVyLnR5cGVdW2luZGV4XSBzYW1wbGUsIGZpbHRlckN1dG9mZiwgQHN0YXRlLmZpbHRlci5yZXNcblxuICAjICAgICAjIHJldHVybiByZXN1bHRcbiAgIyAgICAgbWVtbyArIHNhbXBsZVxuXG4gICMgICAsIDApXG5cbiAgIyB0aWNrOiAodGltZSwgaSwgYmVhdCwgYnBzLCBub3Rlc09uKSA9PlxuICAjICAgIyBhZGQgbmV3IG5vdGVzXG4gICMgICBub3Rlc09uLmZvckVhY2ggKG5vdGUpID0+XG4gICMgICAgIEBub3Rlcy5wdXNoIHt0aW1lLCBrZXk6IG5vdGUua2V5LCBsZW46IG5vdGUubGVuZ3RoIC8gYnBzfVxuIiwiSW5zdHJ1bWVudCA9IHJlcXVpcmUgJy4vaW5zdHJ1bWVudCdcblJpbmdCdWZmZXIgPSByZXF1aXJlICcuLi91dGlsL3JpbmdfYnVmZmVyJ1xubGluZWFySW50ZXJwb2xhdG9yID0gcmVxdWlyZSAnLi4vZHNwL2xpbmVhcl9pbnRlcnBvbGF0b3InXG5sb3dwYXNzRmlsdGVyID0gcmVxdWlyZSAnLi4vZHNwL2xvd3Bhc3NfZmlsdGVyJ1xuaGlnaHBhc3NGaWx0ZXIgPSByZXF1aXJlICcuLi9kc3AvaGlnaHBhc3NfZmlsdGVyJ1xuZW52ZWxvcGUgPSByZXF1aXJlICcuLi9kc3AvZW52ZWxvcGUnXG5cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBCYXNpY1NhbXBsZXIgZXh0ZW5kcyBJbnN0cnVtZW50XG5cbiAgQGRlZmF1bHRzOlxuICAgIF90eXBlOiAnQmFzaWNTYW1wbGVyJ1xuICAgIGxldmVsOiAwLjVcbiAgICBwYW46IDAuNVxuICAgIHBvbHlwaG9ueTogMVxuICAgIHJvb3RLZXk6IDYwXG4gICAgc2FtcGxlRGF0YTogbnVsbFxuICAgIHNhbXBsZU5hbWU6ICcnXG4gICAgc3RhcnQ6IDAuM1xuICAgIGxvb3BBY3RpdmU6ICdsb29wJ1xuICAgIGxvb3A6IDAuN1xuICAgIHR1bmU6IDAuNVxuICAgIHZvbHVtZUVudjpcbiAgICAgIGE6IDBcbiAgICAgIGQ6IDAuMjVcbiAgICAgIHM6IDFcbiAgICAgIHI6IDAuNVxuICAgIGZpbHRlckVudjpcbiAgICAgIGE6IDBcbiAgICAgIGQ6IDAuMjVcbiAgICAgIHM6IDFcbiAgICAgIHI6IDAuNVxuICAgIGZpbHRlcjpcbiAgICAgIHR5cGU6ICdub25lJ1xuICAgICAgZnJlcTogMC4yN1xuICAgICAgcmVzOiAwLjA1XG4gICAgICBlbnY6IDAuNDVcblxuICAjIGNvbnN0cnVjdG9yOiAtPlxuICAjICAgc3VwZXJcbiAgIyAgIEBub3RlcyA9IG5ldyBSaW5nQnVmZmVyIEBtYXhQb2x5cGhvbnksIEFycmF5LCBAc3RhdGUucG9seXBob255XG4gICMgICBAZmlsdGVycyA9XG4gICMgICAgIExQOiAobG93cGFzc0ZpbHRlcigpIGZvciBpIGluIFswLi4uQG1heFBvbHlwaG9ueV0pXG4gICMgICAgIEhQOiAoaGlnaHBhc3NGaWx0ZXIoKSBmb3IgaSBpbiBbMC4uLkBtYXhQb2x5cGhvbnldKVxuICAjICAgICBub25lOiAoKChzYW1wbGUpIC0+IHNhbXBsZSkgZm9yIGkgaW4gWzAuLi5AbWF4UG9seXBob255XSlcblxuICAjIHNldFBvbHlwaG9ueTogKHBvbHlwaG9ueSkgLT5cbiAgIyAgIEBub3Rlcy5yZXNpemUgcG9seXBob255XG4gICMgICBAc2V0IHtwb2x5cGhvbnl9XG5cbiAgIyBzZXRTdGFydDogKHZhbHVlKSA9PlxuICAjICAgQHNldFxuICAjICAgICBzdGFydDogdmFsdWVcbiAgIyAgICAgbG9vcDogTWF0aC5tYXggdmFsdWUsIEBzdGF0ZS5sb29wXG5cbiAgIyBzZXRMb29wOiAodmFsdWUpID0+XG4gICMgICBAc2V0XG4gICMgICAgIGxvb3A6IHZhbHVlXG4gICMgICAgIHN0YXJ0OiBNYXRoLm1pbiB2YWx1ZSwgQHN0YXRlLnN0YXJ0XG5cbiAgIyByZXNldDogLT5cbiAgIyAgIEBub3Rlcy5yZXNldCgpXG5cbiAgIyBvdXQ6ICh0aW1lLCBpKSA9PlxuICAjICAgcmV0dXJuIDAgaWYgQHN0YXRlLmxldmVsID09IDBcbiAgIyAgIHJldHVybiAwIHVubGVzcyBAc3RhdGUuc2FtcGxlRGF0YT9cblxuICAjICAgciA9IE1hdGgubWF4IDAuMDEsIEBzdGF0ZS52b2x1bWVFbnYuclxuICAjICAgQHN0YXRlLmxldmVsICogQG5vdGVzLnJlZHVjZSgobWVtbywgbm90ZSwgaW5kZXgpID0+XG4gICMgICAgIHJldHVybiBtZW1vIHVubGVzcyBub3RlP1xuICAjICAgICByZXR1cm4gbWVtbyB1bmxlc3Mgbm90ZS5sZW4gKyByID4gdGltZSAtIG5vdGUudGltZVxuXG4gICMgICAgICMgZ2V0IHBpdGNoIHNoaWZ0ZWQgaW50ZXJwb2xhdGVkIHNhbXBsZSBhbmQgYXBwbHkgdm9sdW1lIGVudmVsb3BlXG4gICMgICAgIHRyYW5zcG9zZSA9IG5vdGUua2V5IC0gQHN0YXRlLnJvb3RLZXkgKyBAc3RhdGUudHVuZSAtIDAuNVxuICAjICAgICBzYW1wbGVzRWxhcHNlZCA9IGkgLSBub3RlLmlcbiAgIyAgICAgb2Zmc2V0ID0gTWF0aC5mbG9vciBAc3RhdGUuc3RhcnQgKiBAc3RhdGUuc2FtcGxlRGF0YS5sZW5ndGhcbiAgIyAgICAgbG9vcFBvaW50ID0gTWF0aC5mbG9vciBAc3RhdGUubG9vcCAqIEBzdGF0ZS5zYW1wbGVEYXRhLmxlbmd0aFxuICAjICAgICBzYW1wbGUgPSBsaW5lYXJJbnRlcnBvbGF0b3IgQHN0YXRlLnNhbXBsZURhdGEsIHRyYW5zcG9zZSwgc2FtcGxlc0VsYXBzZWQsIG9mZnNldCwgQHN0YXRlLmxvb3BBY3RpdmUgPT0gJ2xvb3AnLCBsb29wUG9pbnRcbiAgIyAgICAgc2FtcGxlID0gZW52ZWxvcGUoQHN0YXRlLnZvbHVtZUVudiwgbm90ZSwgdGltZSkgKiAoc2FtcGxlIG9yIDApXG5cbiAgIyAgICAgIyBhcHBseSBmaWx0ZXIgd2l0aCBlbnZlbG9wZVxuICAjICAgICBmaWx0ZXJDdXRvZmYgPSBNYXRoLm1pbiAxLCBAc3RhdGUuZmlsdGVyLmZyZXEgKyBAc3RhdGUuZmlsdGVyLmVudiAqIGVudmVsb3BlKEBzdGF0ZS5maWx0ZXJFbnYsIG5vdGUsIHRpbWUpXG4gICMgICAgIHNhbXBsZSA9IEBmaWx0ZXJzW0BzdGF0ZS5maWx0ZXIudHlwZV1baW5kZXhdIHNhbXBsZSwgZmlsdGVyQ3V0b2ZmLCBAc3RhdGUuZmlsdGVyLnJlc1xuXG4gICMgICAgICMgcmV0dXJuIHJlc3VsdFxuICAjICAgICBtZW1vICsgc2FtcGxlXG5cbiAgIyAgICwgMClcblxuICAjIHRpY2s6ICh0aW1lLCBpLCBiZWF0LCBicHMsIG5vdGVzT24pID0+XG4gICMgICAjIGFkZCBuZXcgbm90ZXNcbiAgIyAgIG5vdGVzT24uZm9yRWFjaCAobm90ZSkgPT5cbiAgIyAgICAgQG5vdGVzLnB1c2gge3RpbWUsIGksIGtleTogbm90ZS5rZXksIGxlbjogbm90ZS5sZW5ndGggLyBicHN9XG4iLCJJbnN0cnVtZW50ID0gcmVxdWlyZSAnLi9pbnN0cnVtZW50J1xuZW52ZWxvcGUgPSByZXF1aXJlICcuLi9kc3AvZW52ZWxvcGUnXG5saW5lYXJJbnRlcnBvbGF0b3IgPSByZXF1aXJlICcuLi9kc3AvbGluZWFyX2ludGVycG9sYXRvcidcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBEcnVtU2FtcGxlciBleHRlbmRzIEluc3RydW1lbnRcblxuICBAZGVmYXVsdHM6XG4gICAgX3R5cGU6ICdEcnVtU2FtcGxlcidcbiAgICBsZXZlbDogMC41XG4gICAgcGFuOiAwLjVcbiAgICBkcnVtczogW1xuICAgICAge1xuICAgICAgICBuYW1lOiAnRHJ1bSAxJ1xuICAgICAgICBzYW1wbGVEYXRhOiBudWxsXG4gICAgICAgIHNhbXBsZU5hbWU6ICcnXG4gICAgICAgIHRyYW5zcG9zZTogMFxuICAgICAgICBsZXZlbDogMVxuICAgICAgICBzdGFydDogMFxuICAgICAgICBrZXk6IDBcbiAgICAgICAgdm9sdW1lRW52OlxuICAgICAgICAgIGE6IDBcbiAgICAgICAgICBkOiAxXG4gICAgICAgICAgczogMVxuICAgICAgICAgIHI6IDFcbiAgICAgIH1cbiAgICBdXG5cbiAgZGVmYXVsdERydW06IC0+XG4gICAgbmFtZTogXCJEcnVtICN7QHN0YXRlLmRydW1zLmxlbmd0aCArIDF9XCJcbiAgICBzYW1wbGVEYXRhOiBudWxsXG4gICAgc2FtcGxlTmFtZTogJydcbiAgICB0cmFuc3Bvc2U6IDBcbiAgICBsZXZlbDogMVxuICAgIHN0YXJ0OiAwXG4gICAga2V5OiBkbyA9PlxuICAgICAga2V5ID0gMFxuICAgICAga2V5ICs9IDEgd2hpbGUgQHN0YXRlLmRydW1zLnNvbWUgKGRydW0pIC0+IGRydW0ua2V5ID09IGtleVxuICAgICAga2V5XG4gICAgdm9sdW1lRW52OlxuICAgICAgYTogMFxuICAgICAgZDogMVxuICAgICAgczogMVxuICAgICAgcjogMVxuXG4gIGNvbnN0cnVjdG9yOiAtPlxuICAgIHN1cGVyXG4gICAgQG5vdGVzID0ge31cblxuICByZXNldDogLT5cbiAgICBAbm90ZXMgPSB7fVxuXG4gIGNyZWF0ZVNldHRlckZvckRydW06IChpbmRleCkgLT5cbiAgICAodmFsdWUpID0+XG4gICAgICBAc2V0IGRydW1zOiBAc3RhdGUuZHJ1bXMubWFwIChkcnVtLCBpKSAtPlxuICAgICAgICBpZiBpID09IGluZGV4IHRoZW4gdmFsdWUgZWxzZSBkcnVtXG5cbiAgYWRkRHJ1bTogPT5cbiAgICBkcnVtcyA9IEBzdGF0ZS5kcnVtcy5zbGljZSgwKVxuICAgIGRydW1zLnB1c2ggQGRlZmF1bHREcnVtKClcbiAgICBAc2V0IHtkcnVtc31cblxuICByZW1vdmVEcnVtOiAoaW5kZXgpID0+XG4gICAgZHJ1bXMgPSBAc3RhdGUuZHJ1bXMuc2xpY2UoMClcbiAgICBkcnVtcy5zcGxpY2UgaW5kZXgsIDFcbiAgICBAc2V0IHtkcnVtc31cblxuICBvdXQ6ICh0aW1lLCBpKSA9PlxuICAgIHJldHVybiAwIGlmIEBzdGF0ZS5sZXZlbCA9PSAwXG5cbiAgICAjIHN1bSBhbGwgYWN0aXZlIG5vdGVzXG4gICAgQHN0YXRlLmxldmVsICogQHN0YXRlLmRydW1zLnJlZHVjZSgobWVtbywgZHJ1bSkgPT5cbiAgICAgIHJldHVybiBtZW1vIHVubGVzcyBkcnVtLnNhbXBsZURhdGE/XG5cbiAgICAgIG5vdGUgPSBAbm90ZXNbZHJ1bS5rZXldXG4gICAgICByZXR1cm4gbWVtbyB1bmxlc3Mgbm90ZT9cblxuICAgICAgc2FtcGxlc0VsYXBzZWQgPSBpIC0gbm90ZS5pXG4gICAgICBvZmZzZXQgPSBNYXRoLmZsb29yIGRydW0uc3RhcnQgKiBkcnVtLnNhbXBsZURhdGEubGVuZ3RoXG4gICAgICByZXR1cm4gbWVtbyBpZiBzYW1wbGVzRWxhcHNlZCArIG9mZnNldCA+IGRydW0uc2FtcGxlRGF0YS5sZW5ndGhcblxuICAgICAgc2FtcGxlID0gbGluZWFySW50ZXJwb2xhdG9yIGRydW0uc2FtcGxlRGF0YSwgZHJ1bS50cmFuc3Bvc2UsIHNhbXBsZXNFbGFwc2VkLCBvZmZzZXRcbiAgICAgIG1lbW8gKyBkcnVtLmxldmVsICogZW52ZWxvcGUoZHJ1bS52b2x1bWVFbnYsIG5vdGUsIHRpbWUpICogKHNhbXBsZSBvciAwKVxuICAgICwgMClcblxuICB0aWNrOiAodGltZSwgaSwgYmVhdCwgYnBzLCBub3Rlc09uKSA9PlxuICAgICMgYWRkIG5ldyBub3Rlc1xuICAgIG5vdGVzT24uZm9yRWFjaCAobm90ZSkgPT5cbiAgICAgIEBub3Rlc1tub3RlLmtleV0gPSB7dGltZSwgaSwgbGVuOiBub3RlLmxlbmd0aCAvIGJwc31cbiIsIkluc3RydW1lbnQgPSByZXF1aXJlICcuL2luc3RydW1lbnQnXG5oaWdocGFzc0ZpbHRlciA9IHJlcXVpcmUgJy4uL2RzcC9oaWdocGFzc19maWx0ZXInXG5zaW1wbGVFbnZlbG9wZSA9IHJlcXVpcmUgJy4uL2RzcC9zaW1wbGVfZW52ZWxvcGUnXG5vc2NpbGxhdG9ycyA9IHJlcXVpcmUgJy4uL2RzcC9vc2NpbGxhdG9ycydcbmxvZ1NhbXBsZSA9IHJlcXVpcmUgJy4uL3V0aWwvbG9nX3NhbXBsZSdcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBEcnVta2l0U3ludGhlc2l6ZXIgZXh0ZW5kcyBJbnN0cnVtZW50XG5cbiAgbWluRnJlcSA9IDYwXG4gIG1heEZyZXEgPSAzMDAwXG4gIGZyZXFTY2FsZSA9IG1heEZyZXEgLSBtaW5GcmVxXG5cbiAgZHJ1bUlkID0gMFxuXG4gIGRlZmF1bHRzOlxuICAgIGxldmVsOiAwLjVcbiAgICBwYW46IDAuNVxuICAgIGRydW1zOiBbXG4gICAgICB7XG4gICAgICAgIGlkOiBkcnVtSWQgKz0gMVxuICAgICAgICBrZXk6IDBcbiAgICAgICAgbmFtZTogJ0tpY2snXG4gICAgICAgIGxldmVsOiAxXG4gICAgICAgIGhwOiAwXG4gICAgICAgIGRlY2F5OiAwLjM1XG4gICAgICAgIG5vaXNlOiAwLjAwMVxuICAgICAgICBwaXRjaDogMFxuICAgICAgICBiZW5kOiAwLjM5XG4gICAgICAgIGZtOiAxXG4gICAgICAgIGZtRGVjYXk6IDAuMDVcbiAgICAgICAgZm1GcmVxOiAwLjAyXG4gICAgICB9LCB7XG4gICAgICAgIGlkOiBkcnVtSWQgKz0gMVxuICAgICAgICBrZXk6IDFcbiAgICAgICAgbmFtZTogJ1NuYXJlJ1xuICAgICAgICBsZXZlbDogMC41XG4gICAgICAgIGhwOiAwLjIyXG4gICAgICAgIGRlY2F5OiAwLjFcbiAgICAgICAgbm9pc2U6IDAuOFxuICAgICAgICBwaXRjaDogMC4xXG4gICAgICAgIGJlbmQ6IDBcbiAgICAgICAgZm06IDBcbiAgICAgICAgZm1EZWNheTogMFxuICAgICAgICBmbUZyZXE6IDBcbiAgICAgIH0sIHtcbiAgICAgICAgaWQ6IGRydW1JZCArPSAxXG4gICAgICAgIGtleTogMlxuICAgICAgICBuYW1lOiAnSEgxJ1xuICAgICAgICBsZXZlbDogMC4wNVxuICAgICAgICBocDogMVxuICAgICAgICBkZWNheTogMC4wN1xuICAgICAgICBub2lzZTogMC44XG4gICAgICAgIHBpdGNoOiAwLjRcbiAgICAgICAgYmVuZDogMFxuICAgICAgICBmbTogMVxuICAgICAgICBmbURlY2F5OiAwLjRcbiAgICAgICAgZm1GcmVxOiAwXG4gICAgICB9LCB7XG4gICAgICAgIGlkOiBkcnVtSWQgKz0gMVxuICAgICAgICBrZXk6IDNcbiAgICAgICAgbmFtZTogJ0hIMidcbiAgICAgICAgbGV2ZWw6IDAuMlxuICAgICAgICBocDogMC42XG4gICAgICAgIGRlY2F5OiAwLjIyXG4gICAgICAgIG5vaXNlOiAxXG4gICAgICAgIHBpdGNoOiAwLjVcbiAgICAgICAgYmVuZDogMFxuICAgICAgICBmbTogMFxuICAgICAgICBmbURlY2F5OiAwXG4gICAgICAgIGZtRnJlcTogMFxuICAgICAgfVxuICAgIF1cblxuICBkZWZhdWx0RHJ1bTogLT5cbiAgICBpZDogZHJ1bUlkICs9IDFcbiAgICBuYW1lOiBcIkRydW0gI3tAc3RhdGUuZHJ1bXMubGVuZ3RoICsgMX1cIlxuICAgIGxldmVsOiAwLjVcbiAgICBrZXk6IGRvID0+XG4gICAgICBrZXkgPSAwXG4gICAgICBrZXkgKz0gMSB3aGlsZSBAc3RhdGUuZHJ1bXMuc29tZSAoZHJ1bSkgLT4gZHJ1bS5rZXkgPT0ga2V5XG4gICAgICBrZXlcbiAgICBocDogMFxuICAgIGRlY2F5OiAwLjVcbiAgICBub2lzZTogMC41XG4gICAgcGl0Y2g6IDAuNVxuICAgIGJlbmQ6IDBcbiAgICBmbTogMFxuICAgIGZtRGVjYXk6IDBcbiAgICBmbUZyZXE6IDBcblxuICBjb25zdHJ1Y3RvcjogLT5cbiAgICBzdXBlclxuICAgIEBub3RlcyA9IHt9XG4gICAgQGZpbHRlcnMgPSB7fVxuICAgIEB1cGRhdGVGaWx0ZXJzKClcblxuICByZXNldDogLT5cbiAgICBAbm90ZXMgPSB7fVxuXG4gIHVwZGF0ZUZpbHRlcnM6IC0+XG4gICAgQGZpbHRlcnMgPSBAc3RhdGUuZHJ1bXMucmVkdWNlKChtZW1vLCBkcnVtKSA9PlxuICAgICAgbWVtb1tkcnVtLmlkXSA9IEBmaWx0ZXJzW2RydW0uaWRdIG9yIGhpZ2hwYXNzRmlsdGVyKClcbiAgICAgIG1lbW9cbiAgICAsIHt9KVxuXG4gIGNyZWF0ZVNldHRlckZvckRydW06IChpbmRleCkgLT5cbiAgICAodmFsdWUpID0+XG4gICAgICBAc2V0IGRydW1zOiBAc3RhdGUuZHJ1bXMubWFwIChkcnVtLCBpKSAtPlxuICAgICAgICBpZiBpID09IGluZGV4IHRoZW4gdmFsdWUgZWxzZSBkcnVtXG5cbiAgYWRkRHJ1bTogPT5cbiAgICBkcnVtcyA9IEBzdGF0ZS5kcnVtcy5zbGljZSgwKVxuICAgIGRydW1zLnB1c2ggQGRlZmF1bHREcnVtKClcbiAgICBAc2V0IHtkcnVtc31cblxuICByZW1vdmVEcnVtOiAoaW5kZXgpID0+XG4gICAgZHJ1bXMgPSBAc3RhdGUuZHJ1bXMuc2xpY2UoMClcbiAgICBkcnVtcy5zcGxpY2UgaW5kZXgsIDFcbiAgICBAc2V0IHtkcnVtc31cblxuICBvdXQ6ICh0aW1lKSAtPlxuICAgIHJldHVybiAwIGlmIEBzdGF0ZS5sZXZlbCA9PSAwXG5cbiAgICAjIHN1bSBhbGwgYWN0aXZlIG5vdGVzXG4gICAgQHN0YXRlLmxldmVsICogQHN0YXRlLmRydW1zLnJlZHVjZSgobWVtbywgZHJ1bSkgPT5cbiAgICAgIG5vdGUgPSBAbm90ZXNbZHJ1bS5rZXldXG4gICAgICByZXR1cm4gbWVtbyB1bmxlc3Mgbm90ZT9cblxuICAgICAgZWxhcHNlZCA9IHRpbWUgLSBub3RlXG4gICAgICByZXR1cm4gbWVtbyBpZiBlbGFwc2VkID4gZHJ1bS5kZWNheVxuXG4gICAgICBlbnYgPSBzaW1wbGVFbnZlbG9wZSBkcnVtLmRlY2F5LCBlbGFwc2VkXG4gICAgICBmcmVxID0gbWluRnJlcSArIGRydW0ucGl0Y2ggKiBmcmVxU2NhbGVcblxuICAgICAgIyBhcHBseSBwaXRjaCBiZW5kXG4gICAgICBpZiBkcnVtLmJlbmRcbiAgICAgICAgZnJlcSA9ICgyIC0gZHJ1bS5iZW5kICsgZHJ1bS5iZW5kICogZW52KSAvIDIgKiBmcmVxXG5cbiAgICAgICMgYXBwbHkgZm1cbiAgICAgIGlmIGRydW0uZm0gPiAwXG4gICAgICAgIHNpZ25hbCA9IG9zY2lsbGF0b3JzLnNpbmUgZWxhcHNlZCwgbWluRnJlcSArIGRydW0uZm1GcmVxICogZnJlcVNjYWxlXG4gICAgICAgIGZyZXEgKz0gZHJ1bS5mbSAqIHNpZ25hbCAqIHNpbXBsZUVudmVsb3BlKGRydW0uZm1EZWNheSArIDAuMDEsIGVsYXBzZWQpIFxuXG4gICAgICAjIHN1bSBub2lzZSBhbmQgb3NjaWxsYXRvclxuICAgICAgc2FtcGxlID0gKFxuICAgICAgICAoMSAtIGRydW0ubm9pc2UpICogb3NjaWxsYXRvcnMuc2luZShlbGFwc2VkLCBmcmVxKSArXG4gICAgICAgIGRydW0ubm9pc2UgKiBvc2NpbGxhdG9ycy5ub2lzZSgpXG4gICAgICApXG5cbiAgICAgICMgYXBwbHkgaGlnaHBhc3NcbiAgICAgIGlmIGRydW0uaHAgPiAwXG4gICAgICAgIHNhbXBsZSA9IEBmaWx0ZXJzW2RydW0uaWRdIHNhbXBsZSwgZHJ1bS5ocFxuXG4gICAgICBtZW1vICsgZHJ1bS5sZXZlbCAqIGVudiAqIHNhbXBsZVxuICAgIFxuICAgICwgMClcblxuICB0aWNrOiAodGltZSwgaSwgYmVhdCwgYnBzLCBub3Rlc09uKSA9PlxuICAgICMgYWRkIG5ldyBub3Rlc1xuICAgIG5vdGVzT24uZm9yRWFjaCAobm90ZSkgPT5cbiAgICAgIEBub3Rlc1tub3RlLmtleV0gPSB0aW1lIGlmIEBzdGF0ZS5kcnVtc1tub3RlLmtleV0/XG4iLCJNb2RlbCA9IHJlcXVpcmUgJy4vbW9kZWwnXG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgSW5zdHJ1bWVudCBleHRlbmRzIE1vZGVsIiwiSW5zdHJ1bWVudCA9IHJlcXVpcmUgJy4vaW5zdHJ1bWVudCdcblJpbmdCdWZmZXIgPSByZXF1aXJlICcuLi91dGlsL3JpbmdfYnVmZmVyJ1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIExvb3BTYW1wbGVyIGV4dGVuZHMgSW5zdHJ1bWVudFxuXG4gIG1heFBvbHlwaG9ueTogNlxuXG4gIGRlZmF1bHRzOlxuICAgIGxldmVsOiAwLjVcbiAgICBwb2x5cGhvbnk6IDFcbiAgICBzbGljZXM6IFtdXG5cbiAgY29uc3RydWN0b3I6IC0+XG4gICAgc3VwZXJcbiAgICBAbm90ZXMgPSBuZXcgUmluZ0J1ZmZlciBAbWF4UG9seXBob255LCBBcnJheSwgQHN0YXRlLnBvbHlwaG9ueVxuXG4gIHNldFBvbHlwaG9ueTogKHBvbHlwaG9ueSkgLT5cbiAgICBAbm90ZXMucmVzaXplIHBvbHlwaG9ueVxuICAgIEBzZXQge3BvbHlwaG9ueX1cblxuICBvdXQ6IC0+XG4gICAgMFxuXG4gIHRpY2s6IC0+XG5cbiAgcmVzZXQ6IC0+XG4iLCJJbW11dGFibGUgPSByZXF1aXJlICdpbW11dGFibGUnXG5jdWlkID0gcmVxdWlyZSAnY3VpZCdcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIE1vZGVsXG5cbiAgIyBkZWZhdWx0IGF0dHJpYnV0ZXNcbiAgQGRlZmF1bHRzOiB7fVxuXG4gIEBidWlsZDogKGRhdGEgPSB7fSkgLT5cbiAgICBkYXRhLl9pZCA9IGN1aWQoKSB1bmxlc3MgZGF0YS5faWQ/XG4gICAgSW1tdXRhYmxlLmZyb21KUyhkYXRhKS5tZXJnZURlZXAgSW1tdXRhYmxlLmZyb21KUyBAZGVmYXVsdHNcbiIsIk1vZGVsID0gcmVxdWlyZSAnLi9tb2RlbCdcblNlcXVlbmNlID0gcmVxdWlyZSAnLi9zZXF1ZW5jZSdcbkF1ZGlvUmVjb3JkZXIgPSByZXF1aXJlICcuLi9kc3AvYXVkaW9fcmVjb3JkZXInXG5jb250ZXh0ID0gcmVxdWlyZSAnLi4vZHNwL2dsb2JhbF9jb250ZXh0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFJlY29yZGluZyBleHRlbmRzIE1vZGVsXG5cbiAgbWV0ZXJEZWNheSA9IDAuMDAwNVxuXG4gIGRlZmF1bHRzOlxuICAgIHNhbXBsZURhdGE6IG51bGxcbiAgICBlcnJvcjogbnVsbFxuICAgIGFjdGl2ZTogZmFsc2VcbiAgICBwbGF5aW5nOiBmYWxzZVxuICAgIGNyb3BTdGFydDogMFxuICAgIGNyb3BFbmQ6IDFcblxuICByZWNvcmQ6ID0+XG4gICAgcmV0dXJuIGlmIEBzdGF0ZS5hY3RpdmVcbiAgICBcbiAgICBAY2xlYXIoKVxuXG4gICAgbmF2aWdhdG9yLndlYmtpdEdldFVzZXJNZWRpYVxuICAgICAgYXVkaW86IHRydWVcbiAgICAgIChsb2NhbE1lZGlhU3RyZWFtKSA9PlxuICAgICAgICBpbnB1dCA9IGNvbnRleHQuY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UgbG9jYWxNZWRpYVN0cmVhbVxuICAgICAgICBAcmVjb3JkZXIgPSBuZXcgQXVkaW9SZWNvcmRlciBpbnB1dFxuICAgICAgICBAc2V0IGFjdGl2ZTogdHJ1ZVxuICAgICAgICBAcmVjb3JkZXIucmVjb3JkKClcbiAgICAgIChlcnJvckNvZGUpID0+XG4gICAgICAgIEBzZXQgZXJyb3I6ICdVbmFibGUgdG8gYWNjZXNzIG1pY3JvcGhvbmUnXG5cbiAgc2V0Q3JvcFN0YXJ0OiAodmFsdWUpID0+XG4gICAgQHNldFxuICAgICAgY3JvcFN0YXJ0OiB2YWx1ZVxuICAgICAgY3JvcEVuZDogTWF0aC5tYXggdmFsdWUsIEBzdGF0ZS5jcm9wU3RhcnRcblxuICBzZXRDcm9wRW5kOiAodmFsdWUpID0+XG4gICAgQHNldFxuICAgICAgY3JvcEVuZDogdmFsdWVcbiAgICAgIGNyb3BTdGFydDogTWF0aC5taW4gdmFsdWUsIEBzdGF0ZS5jcm9wRW5kXG5cbiAgY3JvcHBlZFNhbXBsZURhdGE6IC0+XG4gICAgbGVuZ3RoID0gQHN0YXRlLnNhbXBsZURhdGEubGVuZ3RoXG4gICAgQHN0YXRlLnNhbXBsZURhdGEuc3ViYXJyYXkgTWF0aC5mbG9vcihAc3RhdGUuY3JvcFN0YXJ0ICogbGVuZ3RoKSwgTWF0aC5mbG9vcihAc3RhdGUuY3JvcEVuZCAqIGxlbmd0aClcblxuICBzdG9wOiA9PlxuICAgIHJldHVybiB1bmxlc3MgQHN0YXRlLmFjdGl2ZVxuXG4gICAgaWYgQHBsYXllclxuICAgICAgQHBsYXllci5vbmVuZGVkID0gZmFsc2VcbiAgICAgIEBwbGF5ZXIuc3RvcCgpXG4gIFxuICAgIEByZWNvcmRlci5zdG9wKCkuZ2V0U2FtcGxlRGF0YSAoc2FtcGxlRGF0YSkgPT5cbiAgICAgIEByZWNvcmRlciA9IG51bGxcbiAgICAgIEBzZXRcbiAgICAgICAgc2FtcGxlRGF0YTogc2FtcGxlRGF0YVxuICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgICBhY3RpdmU6IGZhbHNlXG4gICAgICAgIHBsYXlpbmc6IGZhbHNlXG5cbiAgcGxheTogPT5cbiAgICBpZiBAcGxheWVyXG4gICAgICBAcGxheWVyLm9uZW5kZWQgPSBudWxsXG4gICAgICBAcGxheWVyLnN0b3AoKVxuICAgICAgQHBsYXllci5kaXNjb25uZWN0IGNvbnRleHQuZGVzdGluYXRpb25cblxuICAgIGRhdGEgPSBAY3JvcHBlZFNhbXBsZURhdGEoKVxuXG4gICAgQHBsYXllciA9IGNvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKClcbiAgICBAcGxheWVyLmNvbm5lY3QgY29udGV4dC5kZXN0aW5hdGlvblxuICAgIGF1ZGlvQnVmZmVyID0gY29udGV4dC5jcmVhdGVCdWZmZXIgMSwgZGF0YS5sZW5ndGgsIGNvbnRleHQuc2FtcGxlUmF0ZVxuICAgIGF1ZGlvQnVmZmVyLmdldENoYW5uZWxEYXRhKDApLnNldCBkYXRhXG4gICAgQHBsYXllci5idWZmZXIgPSBhdWRpb0J1ZmZlclxuICAgIEBwbGF5ZXIub25lbmRlZCA9ID0+IEBzZXQgcGxheWluZzogZmFsc2VcbiAgICBAcGxheWVyLnN0YXJ0KClcbiAgICBcbiAgICBAc2V0IHBsYXlpbmc6IHRydWVcblxuICBjbGVhcjogPT5cbiAgICBAc2V0IEBkZWZhdWx0c1xuIiwiTW9kZWwgPSByZXF1aXJlICcuL21vZGVsJ1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFNlcXVlbmNlIGV4dGVuZHMgTW9kZWxcblxuICBub3RlSWQgPSAwXG5cbiAgQGRlZmF1bHRzOlxuICAgIGxvb3BTaXplOiA0XG4gICAgbm90ZXM6IHt9XG5cbiAgY29uc3RydWN0b3I6IC0+XG4gICAgc3VwZXJcbiAgICBAbGFzdEJlYXQgPSAwXG4gICAgQGJhciA9IDBcblxuICBjbG9uZWROb3RlczogLT5cbiAgICBjbG9uZSA9IHt9XG4gICAgY2xvbmVba10gPSB2IGZvciBrLCB2IG9mIEBzdGF0ZS5ub3Rlc1xuICAgIGNsb25lXG5cbiAgY2xvbmVkTm90ZTogKGlkKSAtPlxuICAgIGNsb25lID0ge31cbiAgICBjbG9uZVtrXSA9IHYgZm9yIGssIHYgb2YgQHN0YXRlLm5vdGVzW2lkXVxuICAgIGNsb25lXG5cbiAgYWRkTm90ZTogKG5vdGUpIC0+XG4gICAgbm90ZUlkICs9IDFcbiAgICBub3RlLmlkID0gbm90ZUlkXG4gICAgbm90ZXMgPSBAY2xvbmVkTm90ZXMoKVxuICAgIG5vdGVzW25vdGVJZF0gPSBub3RlXG4gICAgQHNldCB7bm90ZXN9XG5cbiAgYWRkTm90ZXM6IChhZGRpdGlvbnMpIC0+XG4gICAgbm90ZXMgPSBAY2xvbmVkTm90ZXMoKVxuICAgIGZvciBpZCwgbm90ZSBvZiBhZGRpdGlvbnNcbiAgICAgIG5vdGVJZCArPSAxXG4gICAgICBub3RlLmlkID0gbm90ZUlkXG4gICAgICBub3Rlc1tub3RlSWRdID0gbm90ZVxuICAgIEBzZXQge25vdGVzfVxuXG4gIHJlbW92ZU5vdGU6IChpZCkgLT5cbiAgICBub3RlcyA9IEBjbG9uZWROb3RlcygpXG4gICAgZGVsZXRlIG5vdGVzW2lkXVxuICAgIEBzZXQge25vdGVzfVxuXG4gIHJlbW92ZU5vdGVzOiAoaWRzKSAtPlxuICAgIG5vdGVzID0gQGNsb25lZE5vdGVzKClcbiAgICBkZWxldGUgbm90ZXNbaWRdIGZvciBpZCBpbiBpZHNcbiAgICBAc2V0IHtub3Rlc31cblxuICB1cGRhdGVOb3RlOiAoaWQsIGF0dHJzKSAtPlxuICAgIG5vdGUgPSBAY2xvbmVkTm90ZSBpZFxuICAgIG5vdGVba10gPSB2IGZvciBrLCB2IG9mIGF0dHJzXG4gICAgbm90ZXMgPSBAY2xvbmVkTm90ZXMoKVxuICAgIG5vdGVzW2lkXSA9IG5vdGVcbiAgICBAc2V0IHtub3Rlc31cblxuICB1cGRhdGVOb3RlczogKGNoYW5nZXMpIC0+XG4gICAgbm90ZXMgPSBAY2xvbmVkTm90ZXMoKVxuICAgIGZvciBpZCwgYXR0cnMgb2YgY2hhbmdlc1xuICAgICAgbm90ZSA9IEBjbG9uZWROb3RlIGlkXG4gICAgICBub3RlW2tdID0gdiBmb3IgaywgdiBvZiBhdHRyc1xuICAgICAgbm90ZXNbaWRdID0gbm90ZVxuICAgIEBzZXQge25vdGVzfVxuXG4gIG5vdGVzT246IChiZWF0KSAtPlxuICAgIG5vdGVzID0gW11cbiAgICBiYXIgPSBNYXRoLmZsb29yIGJlYXQgLyBAc3RhdGUubG9vcFNpemVcbiAgICBiZWF0ID0gYmVhdCAlIEBzdGF0ZS5sb29wU2l6ZVxuICAgIGZvciBpZCwgbm90ZSBvZiBAc3RhdGUubm90ZXNcbiAgICAgIG5vdGVzLnB1c2ggbm90ZSBpZiBub3RlLnN0YXJ0IDwgYmVhdCBhbmQgKG5vdGUuc3RhcnQgPj0gQGxhc3RCZWF0IG9yIGJhciA+IEBiYXIpXG4gICAgQGxhc3RCZWF0ID0gYmVhdFxuICAgIEBiYXIgPSBiYXJcbiAgICBub3Rlc1xuXG4gIHJlc2V0OiAtPlxuICAgIEBsYXN0QmVhdCA9IDBcbiAgICBAbGFzdEJhciA9IDBcbiIsIk1vZGVsID0gcmVxdWlyZSAnLi9tb2RlbCdcbndlYmF1ZGlvID0gcmVxdWlyZSAnLi4vZHNwL3dlYmF1ZGlvJ1xuY29udGV4dCA9IHJlcXVpcmUgJy4uL2RzcC9nbG9iYWxfY29udGV4dCdcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBTb25nXG5cbiAgY2xvY2tSYXRpbyA9IDIzMFxuXG4gIGNsaXAgPSAoc2FtcGxlKSAtPlxuICAgIE1hdGgubWF4KDAsIE1hdGgubWluKDIsIHNhbXBsZSArIDEpKSAtIDFcblxuICBjb25zdHJ1Y3RvcjogLT5cbiAgICBAYXVkaW8gPSB3ZWJhdWRpbyBjb250ZXh0LCBAb3V0XG5cbiAgYWRkVHJhY2s6ICh0cmFjaykgPT5cbiAgICB0cmFja3MgPSBAc3RhdGUudHJhY2tzLnNsaWNlIDBcbiAgICB0cmFja3MucHVzaCB0cmFja1xuICAgIEBzZXQge3RyYWNrc31cblxuICByZW1vdmVUcmFjazogKGluZGV4KSA9PlxuICAgIHRyYWNrcyA9IEBzdGF0ZS50cmFja3Muc2xpY2UgMFxuICAgIHRyYWNrcy5zcGxpY2UgaW5kZXgsIDFcbiAgICBAc2V0IHt0cmFja3N9XG5cbiAgb3V0OiAodGltZSwgaSkgPT5cbiAgICBAdGljayB0aW1lLCBpIGlmIGkgJSBjbG9ja1JhdGlvIGlzIDBcblxuICAgIGNsaXAgQHN0YXRlLnRyYWNrcy5yZWR1Y2UoKHNhbXBsZSwgdCkgLT5cbiAgICAgIHNhbXBsZSArIHQub3V0IHRpbWUsIGlcbiAgICAsIDApXG5cbiAgdGljazogKHRpbWUsIGkpIC0+XG4gICAgYnBzID0gQHN0YXRlLmJwbSAvIDYwXG4gICAgYmVhdCA9IHRpbWUgKiBicHNcblxuICAgICMgdXBkYXRlIHVpIHN0YXRlIG9uIDEvNHRoIG5vdGVzXG4gICAgYiA9IE1hdGguZmxvb3IoYmVhdCAqIDQpIC8gNFxuICAgIEBzZXQgcG9zaXRpb246IGIgaWYgYiA+IEBzdGF0ZS5wb3NpdGlvbiBcblxuICAgIHRyYWNrLnRpY2sgdGltZSwgaSwgYmVhdCwgYnBzIGZvciB0cmFjayBpbiBAc3RhdGUudHJhY2tzIFxuXG4gIHBsYXk6ID0+XG4gICAgQHNldCBwbGF5aW5nOiB0cnVlXG4gICAgQGF1ZGlvLnBsYXkoKVxuXG4gIHBhdXNlOiA9PlxuICAgIEBzZXQgcGxheWluZzogZmFsc2VcbiAgICBAYXVkaW8uc3RvcCgpXG5cbiAgcmVjb3JkOiA9PlxuICAgIEBzZXQgcmVjb3JkaW5nOiAhQHN0YXRlLnJlY29yZGluZ1xuXG4gIHN0b3A6ID0+XG4gICAgQGF1ZGlvLnN0b3AoKVxuICAgIEBhdWRpby5yZXNldCgpXG4gICAgdHJhY2sucmVzZXQoKSBmb3IgdHJhY2sgaW4gQHN0YXRlLnRyYWNrc1xuICAgIEBzZXQgcGxheWluZzogZmFsc2UsIHJlY29yZGluZzogZmFsc2UsIHBvc2l0aW9uOiAwXG5cbiAgdG9KU09OOiAtPlxuICAgIHJlc3VsdCA9IGJwbTogQHN0YXRlLmJwbVxuICAgIHJlc3VsdC50cmFja3MgPSBAc3RhdGUudHJhY2tzLm1hcCAodCkgLT4gdC50b0pTT04oKVxuICAgIHJlc3VsdFxuIiwiTW9kZWwgPSByZXF1aXJlICcuL21vZGVsJ1xuU2VxdWVuY2UgPSByZXF1aXJlICcuL3NlcXVlbmNlJ1xuXG5pbnN0cnVtZW50VHlwZXMgPVxuICBBbmFsb2dTeW50aGVzaXplcjogcmVxdWlyZSAnLi9hbmFsb2dfc3ludGhlc2l6ZXInXG4gIEJhc2ljU2FtcGxlcjogcmVxdWlyZSAnLi9iYXNpY19zYW1wbGVyJ1xuICBEcnVtU2FtcGxlcjogcmVxdWlyZSAnLi9kcnVtX3NhbXBsZXInXG4gIERydW1raXRTeW50aGVzaXplcjogcmVxdWlyZSAnLi9kcnVta2l0X3N5bnRoZXNpemVyJ1xuICBMb29wU2FtcGxlcjogcmVxdWlyZSAnLi9sb29wX3NhbXBsZXInXG5cblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBUcmFjayBleHRlbmRzIE1vZGVsXG5cbiAgbWV0ZXJEZWNheSA9IDAuMDAwNVxuXG4gIEBkZWZhdWx0czpcbiAgICBuYW1lOiAnVHJhY2snXG4gICAgbWV0ZXJMZXZlbDogMFxuICAgIHNlcXVlbmNlOiBTZXF1ZW5jZS5idWlsZCgpXG5cbiAgIyBAb3V0OiAoZGF0YSwgdGltZSwgaSkgLT5cbiAgIyAgIHNhbXBsZSA9IEBlZmZlY3RzLnJlZHVjZSgoc2FtcGxlLCBlKSAtPlxuICAjICAgICBlLm91dCB0aW1lLCBpLCBzYW1wbGVcbiAgIyAgICwgQGluc3RydW1lbnQub3V0IHRpbWUsIGkpXG5cbiAgIyAgIGlmIHNhbXBsZSA+IEBtZXRlckxldmVsXG4gICMgICAgIEBtZXRlckxldmVsID0gc2FtcGxlXG4gICMgICBlbHNlIGlmIEBtZXRlckxldmVsID4gMFxuICAjICAgICBAbWV0ZXJMZXZlbCAtPSBtZXRlckRlY2F5XG5cbiAgIyAgIHNhbXBsZVxuXG4gICMgQHRpY2s6IChkYXRhLCB0aW1lLCBpLCBiZWF0LCBicHMpIC0+XG4gICMgICBub3Rlc09uID0gQHNlcXVlbmNlLm5vdGVzT24gYmVhdFxuICAjICAgQGluc3RydW1lbnQudGljayB0aW1lLCBpLCBiZWF0LCBicHMsIG5vdGVzT25cbiAgIyAgIEBlZmZlY3RzLmZvckVhY2ggKGUpIC0+IGUudGljayB0aW1lLCBiZWF0LCBicHNcbiAgIyAgIEBzZXQge0BtZXRlckxldmVsfVxuXG4gICMgQHJlc2V0OiAtPlxuICAjICAgQGluc3RydW1lbnQucmVzZXQoKVxuICAjICAgZWZmZWN0LnJlc2V0KCkgZm9yIGVmZmVjdCBpbiBAZWZmZWN0c1xuIiwiXG5cblJlYWN0ID0gcmVxdWlyZSAncmVhY3QnXG5Nb2RlbGFibGUgPSByZXF1aXJlICcuL21peGlucy9tb2RlbGFibGUnXG5TbGlkZXIgPSByZXF1aXJlICcuL3NsaWRlcidcbkVudmVsb3BlID0gcmVxdWlyZSAnLi9lbnZlbG9wZSdcbkZpbHRlciA9IHJlcXVpcmUgJy4vZmlsdGVyJ1xuT3NjaWxsYXRvciA9IHJlcXVpcmUgJy4vb3NjaWxsYXRvcidcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0LmNyZWF0ZUNsYXNzXG5cbiAgbWl4aW5zOiBbTW9kZWxhYmxlKCdpbnN0cnVtZW50JyldXG5cbiAgc2V0UG9seXBob255OiAoZSkgLT5cbiAgICBAcHJvcHMuaW5zdHJ1bWVudC5zZXRQb2x5cGhvbnkgcGFyc2VJbnQgZS50YXJnZXQudmFsdWVcblxuICByZW5kZXI6IC0+XG4gICAgb3B0aW9ucyA9IGZvciBpIGluIFsxLi5AcHJvcHMuaW5zdHJ1bWVudC5tYXhQb2x5cGhvbnldXG4gICAgICBSZWFjdC5ET00ub3B0aW9uKHtcImtleVwiOiAoaSksIFwidmFsdWVcIjogKGkpfSwgKGkpKVxuXG4gICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJ1aSBhbmFsb2dcIn0sIFxuICAgICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJjb2x1bW4gY2hhbm5lbFwifSwgXG4gICAgICAgIFNsaWRlcih7IFxcXG4gICAgICAgICAgXCJsYWJlbFwiOiBcIkxldmVsXCIsICBcXFxuICAgICAgICAgIFwidmFsdWVcIjogKEBzdGF0ZS5sZXZlbCksICBcXFxuICAgICAgICAgIFwib25DaGFuZ2VcIjogKEBwcm9wcy5pbnN0cnVtZW50LmNyZWF0ZVNldHRlckZvcignbGV2ZWwnKSlcbiAgICAgICAgfSksIFxuICAgICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcInVpXCJ9LCBcbiAgICAgICAgICBSZWFjdC5ET00uc2VsZWN0KHtcIm9uQ2hhbmdlXCI6IChAc2V0UG9seXBob255KSwgXCJ2YWx1ZVwiOiAoQHN0YXRlLnBvbHlwaG9ueSl9LCAob3B0aW9ucykpLCBcbiAgICAgICAgICBSZWFjdC5ET00ubGFiZWwobnVsbCwgXCJQb2x5XCIpXG4gICAgICAgIClcbiAgICAgICksIFxuICAgICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJjb2x1bW5cIn0sIFxuICAgICAgICBFbnZlbG9wZSh7IFxcXG4gICAgICAgICAgXCJsYWJlbFwiOiBcIlZvbHVtZSBFbnZcIiwgIFxcXG4gICAgICAgICAgXCJlbnZcIjogKEBwcm9wcy5pbnN0cnVtZW50LnN0YXRlLnZvbHVtZUVudiksICBcXFxuICAgICAgICAgIFwib25DaGFuZ2VcIjogKEBwcm9wcy5pbnN0cnVtZW50LmNyZWF0ZVNldHRlckZvcigndm9sdW1lRW52JykpXG4gICAgICAgIH0pXG4gICAgICApLCBcbiAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwiY29sdW1uXCJ9LCBcbiAgICAgICAgRW52ZWxvcGUoeyBcXFxuICAgICAgICAgIFwibGFiZWxcIjogXCJGaWx0ZXIgRW52XCIsICBcXFxuICAgICAgICAgIFwiZW52XCI6IChAcHJvcHMuaW5zdHJ1bWVudC5zdGF0ZS5maWx0ZXJFbnYpLCAgXFxcbiAgICAgICAgICBcIm9uQ2hhbmdlXCI6IChAcHJvcHMuaW5zdHJ1bWVudC5jcmVhdGVTZXR0ZXJGb3IoJ2ZpbHRlckVudicpKVxuICAgICAgICB9KVxuICAgICAgKSwgXG4gICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcImNvbHVtbiBvc2NpbGxhdG9yc1wifSwgXG4gICAgICAgIEZpbHRlcih7IFxcXG4gICAgICAgICAgXCJsYWJlbFwiOiBcIkZpbHRlclwiLCAgXFxcbiAgICAgICAgICBcImZpbHRlclwiOiAoQHByb3BzLmluc3RydW1lbnQuc3RhdGUuZmlsdGVyKSwgIFxcXG4gICAgICAgICAgXCJvbkNoYW5nZVwiOiAoQHByb3BzLmluc3RydW1lbnQuY3JlYXRlU2V0dGVyRm9yKCdmaWx0ZXInKSlcbiAgICAgICAgfSksIFxuICAgICAgICBPc2NpbGxhdG9yKHsgXFxcbiAgICAgICAgICBcImxhYmVsXCI6IFwiT3NjIDFcIiwgIFxcXG4gICAgICAgICAgXCJvc2NcIjogKEBwcm9wcy5pbnN0cnVtZW50LnN0YXRlLm9zYzEpLCAgXFxcbiAgICAgICAgICBcIm9uQ2hhbmdlXCI6IChAcHJvcHMuaW5zdHJ1bWVudC5jcmVhdGVTZXR0ZXJGb3IoJ29zYzEnKSlcbiAgICAgICAgfSksIFxuICAgICAgICBPc2NpbGxhdG9yKHsgXFxcbiAgICAgICAgICBcImxhYmVsXCI6IFwiT3NjIDJcIiwgIFxcXG4gICAgICAgICAgXCJvc2NcIjogKEBwcm9wcy5pbnN0cnVtZW50LnN0YXRlLm9zYzIpLCAgXFxcbiAgICAgICAgICBcIm9uQ2hhbmdlXCI6IChAcHJvcHMuaW5zdHJ1bWVudC5jcmVhdGVTZXR0ZXJGb3IoJ29zYzInKSlcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICApXG4iLCJcblxuUmVhY3QgPSByZXF1aXJlICdyZWFjdC9hZGRvbnMnXG5Nb2RlbGFibGUgPSByZXF1aXJlICcuL21peGlucy9tb2RlbGFibGUnXG5Lbm9iID0gcmVxdWlyZSAnLi9rbm9iJ1xuQ2hvb3NlciA9IHJlcXVpcmUgJy4vY2hvb3NlcidcblNsaWRlciA9IHJlcXVpcmUgJy4vc2xpZGVyJ1xuU2FtcGxlQ29udHJvbCA9IHJlcXVpcmUgJy4vc2FtcGxlX2NvbnRyb2wnXG5FbnZlbG9wZSA9IHJlcXVpcmUgJy4vZW52ZWxvcGUnXG5GaWx0ZXIgPSByZXF1aXJlICcuL2ZpbHRlcidcbmtleU9wdGlvbnMgPSByZXF1aXJlICcuLi91dGlsL2tleV9vcHRpb25zJ1xuXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3QuY3JlYXRlQ2xhc3NcblxuICBnZXRJbml0aWFsU3RhdGU6IC0+XG4gICAgYnVmZmVyOiBudWxsXG5cbiAgbWl4aW5zOiBbTW9kZWxhYmxlKCdpbnN0cnVtZW50JyldXG5cbiAgcmVuZGVyOiAtPlxuICAgIGluc3RydW1lbnQgPSBAcHJvcHMuaW5zdHJ1bWVudFxuXG4gICAgb3B0aW9ucyA9IGZvciBpIGluIFsxLi42XVxuICAgICAgUmVhY3QuRE9NLm9wdGlvbih7XCJrZXlcIjogKGkpLCBcInZhbHVlXCI6IChpKX0sIChpKSlcblxuICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwidWkgYmFzaWMtc2FtcGxlclwifSwgXG4gICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcImNvbHVtbiBjaGFubmVsXCJ9LCBcbiAgICAgICAgU2xpZGVyKHsgXFxcbiAgICAgICAgICBcImxhYmVsXCI6IFwiTGV2ZWxcIiwgIFxcXG4gICAgICAgICAgXCJ2YWx1ZVwiOiAoaW5zdHJ1bWVudC5nZXQgJ2xldmVsJyksICBcXFxuICAgICAgICAgIFwib25DaGFuZ2VcIjogKC0+KVxuICAgICAgICB9KSwgXG4gICAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwidWlcIn0sIFxuICAgICAgICAgIFJlYWN0LkRPTS5zZWxlY3Qoe1widmFsdWVcIjogKGluc3RydW1lbnQuZ2V0ICdwb2x5cGhvbnknKSwgXCJvbkNoYW5nZVwiOiAoLT4pfSwgKG9wdGlvbnMpKSwgXG4gICAgICAgICAgUmVhY3QuRE9NLmxhYmVsKG51bGwsIFwiUG9seVwiKVxuICAgICAgICApXG4gICAgICApLCBcbiAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwiY29sdW1uXCJ9LCBcbiAgICAgICAgU2FtcGxlQ29udHJvbCh7IFxcXG4gICAgICAgICAgXCJsYWJlbFwiOiBcIlNhbXBsZVwiLCAgXFxcbiAgICAgICAgICBcImFwcFwiOiAoQHByb3BzLmFwcCksICBcXFxuICAgICAgICAgIFwib25DaGFuZ2VcIjogKEBzZXRTYW1wbGUpLCAgXFxcbiAgICAgICAgICBcInNhbXBsZURhdGFcIjogKGluc3RydW1lbnQuZ2V0ICdzYW1wbGVEYXRhJyksICBcXFxuICAgICAgICAgIFwic2FtcGxlTmFtZVwiOiAoaW5zdHJ1bWVudC5nZXQgJ3NhbXBsZU5hbWUnKSwgIFxcXG4gICAgICAgICAgXCJzYW1wbGVTdGFydFwiOiAoaW5zdHJ1bWVudC5nZXQgJ3N0YXJ0JyksICBcXFxuICAgICAgICAgIFwib25DaGFuZ2VTdGFydFwiOiAoLT4pLCAgXFxcbiAgICAgICAgICBcImxvb3BBY3RpdmVcIjogKGluc3RydW1lbnQuZ2V0KCdsb29wQWN0aXZlJykgPT0gJ2xvb3AnKSwgIFxcXG4gICAgICAgICAgXCJzYW1wbGVMb29wXCI6IChpbnN0cnVtZW50LmdldCAnbG9vcCcpLCAgXFxcbiAgICAgICAgICBcIm9uQ2hhbmdlTG9vcFwiOiAoLT4pXG4gICAgICAgIH0pXG4gICAgICApLCBcbiAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwiY29sdW1uIGVudmVsb3BlXCJ9LCBcbiAgICAgICAgRW52ZWxvcGUoeyBcXFxuICAgICAgICAgIFwibGFiZWxcIjogXCJWb2x1bWUgRW52XCIsICBcXFxuICAgICAgICAgIFwiZW52XCI6IChpbnN0cnVtZW50LmdldCgndm9sdW1lRW52JykudG9KUygpKSwgIFxcXG4gICAgICAgICAgXCJvbkNoYW5nZVwiOiAoLT4pXG4gICAgICAgIH0pXG4gICAgICApLCBcbiAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwiY29sdW1uIGVudmVsb3BlXCJ9LCBcbiAgICAgICAgRW52ZWxvcGUoeyBcXFxuICAgICAgICAgIFwibGFiZWxcIjogXCJGaWx0ZXIgRW52XCIsICBcXFxuICAgICAgICAgIFwiZW52XCI6IChpbnN0cnVtZW50LmdldCgnZmlsdGVyRW52JykudG9KUygpKSwgIFxcXG4gICAgICAgICAgXCJvbkNoYW5nZVwiOiAoLT4pXG4gICAgICAgIH0pXG4gICAgICApLCBcbiAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwiY29sdW1uIGNvbnRyb2xzXCJ9LCBcbiAgICAgICAgRmlsdGVyKHsgXFxcbiAgICAgICAgICBcImxhYmVsXCI6IFwiRmlsdGVyXCIsICBcXFxuICAgICAgICAgIFwiZmlsdGVyXCI6IChpbnN0cnVtZW50LmdldCgnZmlsdGVyJykudG9KUygpKSwgIFxcXG4gICAgICAgICAgXCJvbkNoYW5nZVwiOiAoLT4pXG4gICAgICAgIH0pLCBcbiAgICAgICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJyb3cgc2FtcGxlXCJ9LCBcbiAgICAgICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcInVpXCJ9LCBcbiAgICAgICAgICAgIFJlYWN0LkRPTS5zZWxlY3QoeyBcXFxuICAgICAgICAgICAgICBcInZhbHVlXCI6IChpbnN0cnVtZW50LmdldCAncm9vdEtleScpLCAgXFxcbiAgICAgICAgICAgICAgXCJvbkNoYW5nZVwiOiAoLT4pXG4gICAgICAgICAgICB9LCBcbiAgICAgICAgICAgICAgKGtleU9wdGlvbnMoKSlcbiAgICAgICAgICAgICksIFxuICAgICAgICAgICAgUmVhY3QuRE9NLmxhYmVsKG51bGwsIFwiUm9vdFwiKVxuICAgICAgICAgICksIFxuICAgICAgICAgIEtub2IoeyBcXFxuICAgICAgICAgICAgXCJsYWJlbFwiOiBcIlR1bmVcIiwgIFxcXG4gICAgICAgICAgICBcInZhbHVlXCI6IChpbnN0cnVtZW50LmdldCAndHVuZScpLCAgXFxcbiAgICAgICAgICAgIFwib25DaGFuZ2VcIjogKC0+KVxuICAgICAgICAgIH0pXG4gICAgICAgICksIFxuICAgICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcInJvdyBzYW1wbGVcIn0sIFxuICAgICAgICAgIENob29zZXIoeyBcXFxuICAgICAgICAgICAgXCJvcHRpb25zXCI6IChbJ2xvb3AnLCdvZmYnXSksICBcXFxuICAgICAgICAgICAgXCJ2YWx1ZVwiOiAoaW5zdHJ1bWVudC5nZXQgJ2xvb3BBY3RpdmUnKSwgIFxcXG4gICAgICAgICAgICBcIm9uQ2hhbmdlXCI6ICgtPilcbiAgICAgICAgICB9KSwgXG4gICAgICAgICAgS25vYih7IFxcXG4gICAgICAgICAgICBcImxhYmVsXCI6IFwiTG9vcFwiLCAgXFxcbiAgICAgICAgICAgIFwidmFsdWVcIjogKGluc3RydW1lbnQuZ2V0ICdsb29wJyksICBcXFxuICAgICAgICAgICAgXCJkaXNhYmxlZFwiOiAoaW5zdHJ1bWVudC5nZXQoJ2xvb3BBY3RpdmUnKSA9PSAnb2ZmJyksICBcXFxuICAgICAgICAgICAgXCJvbkNoYW5nZVwiOiAoLT4pXG4gICAgICAgICAgfSksIFxuICAgICAgICAgIEtub2IoeyBcXFxuICAgICAgICAgICAgXCJsYWJlbFwiOiBcIlN0YXJ0XCIsICBcXFxuICAgICAgICAgICAgXCJ2YWx1ZVwiOiAoaW5zdHJ1bWVudC5nZXQgJ3N0YXJ0JyksICBcXFxuICAgICAgICAgICAgXCJvbkNoYW5nZVwiOiAoLT4pXG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKVxuICAgIClcbiIsIlxuXG5SZWFjdCA9IHJlcXVpcmUgJ3JlYWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0LmNyZWF0ZUNsYXNzXG5cbiAgb25DbGlja1ZhbHVlOiAoZSkgLT5cbiAgICBAcHJvcHMub25DaGFuZ2UgZS50YXJnZXQuZGF0YXNldC52YWx1ZVxuXG4gIHJlbmRlcjogLT5cbiAgICBvcHRpb25zID0gZm9yIHYsIGkgaW4gQHByb3BzLm9wdGlvbnNcbiAgICAgIGNsYXNzTmFtZSA9ICdvcHRpb24nXG4gICAgICBjbGFzc05hbWUgKz0gJyBzZWxlY3RlZCcgaWYgdiA9PSBAcHJvcHMudmFsdWVcbiAgICAgIFJlYWN0LkRPTS5kaXYoe1wia2V5XCI6IChpKSwgXCJjbGFzc05hbWVcIjogKGNsYXNzTmFtZSksIFwib25DbGlja1wiOiAoQG9uQ2xpY2tWYWx1ZSksIFwiZGF0YS12YWx1ZVwiOiAodil9LCAodikpXG5cbiAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcInVpIGNob29zZXJcIn0sIFxuICAgICAgKG9wdGlvbnMpXG4gICAgKSIsIlxuXG5SZWFjdCA9IHJlcXVpcmUgJ3JlYWN0J1xuVXBkYXRhYmxlID0gcmVxdWlyZSAnLi9taXhpbnMvdXBkYXRhYmxlJ1xuU29ydGFibGUgPSByZXF1aXJlICcuL21peGlucy9zb3J0YWJsZSdcbktub2IgPSByZXF1aXJlICcuL2tub2InXG5TbGlkZXIgPSByZXF1aXJlICcuL3NsaWRlcidcbkxpc3RDb250cm9sID0gcmVxdWlyZSAnLi9saXN0X2NvbnRyb2wnXG5TYW1wbGVDb250cm9sID0gcmVxdWlyZSAnLi9zYW1wbGVfY29udHJvbCdcbkVudmVsb3BlID0gcmVxdWlyZSAnLi9lbnZlbG9wZSdcbmtleU9wdGlvbnMgPSByZXF1aXJlICcuLi91dGlsL2tleV9vcHRpb25zJ1xudHJhbnNwb3NlT3B0aW9ucyA9IHJlcXVpcmUgJy4uL3V0aWwvdHJhbnNwb3NlX29wdGlvbnMnXG5cblxuRHJ1bSA9IFJlYWN0LmNyZWF0ZUNsYXNzXG5cbiAgbWl4aW5zOiBbU29ydGFibGUsIFJlYWN0LmFkZG9ucy5QdXJlXVxuXG4gIHNldFNhbXBsZTogKHNhbXBsZU5hbWUsIHNhbXBsZURhdGEpIC0+XG4gICAgIyBvID0ge31cbiAgICAjIG9ba10gPSB2IGZvciBrLCB2IG9mIEBwcm9wcy5kcnVtXG5cbiAgICAjIG8uc2FtcGxlTmFtZSA9IHNhbXBsZU5hbWVcbiAgICAjIG8uc2FtcGxlRGF0YSA9IHNhbXBsZURhdGFcblxuICAgICMgQHByb3BzLm9uQ2hhbmdlIG9cblxuICByZW5kZXI6IC0+XG4gICAgZHJ1bSA9IEBwcm9wcy5kcnVtXG5cbiAgICByZXR1cm4gUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJkcnVtXCJ9KSB1bmxlc3MgZHJ1bVxuXG4gICAgY29uc29sZS5sb2cgXCJIRVJFXCJcbiAgICBjb25zb2xlLmxvZyBkcnVtXG4gICAgY29uc29sZVxuXG4gICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJkcnVtXCJ9LCBcbiAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwiY29sdW1uXCJ9LCBcbiAgICAgICAgU2FtcGxlQ29udHJvbCh7IFxcXG4gICAgICAgICAgXCJsYWJlbFwiOiAoXCJTYW1wbGVcIiksICBcXFxuICAgICAgICAgIFwiYXBwXCI6IChAcHJvcHMuYXBwKSwgIFxcXG4gICAgICAgICAgXCJvbkNoYW5nZVwiOiAoQHNldFNhbXBsZSksICBcXFxuICAgICAgICAgIFwic2FtcGxlRGF0YVwiOiAoZHJ1bS5nZXQgJ3NhbXBsZURhdGEnKSwgIFxcXG4gICAgICAgICAgXCJzYW1wbGVOYW1lXCI6IChkcnVtLmdldCAnc2FtcGxlTmFtZScpLCAgXFxcbiAgICAgICAgICBcInNhbXBsZVN0YXJ0XCI6IChkcnVtLmdldCAnc3RhcnQnKSwgIFxcXG4gICAgICAgICAgXCJvbkNoYW5nZVN0YXJ0XCI6ICgtPilcbiAgICAgICAgfSlcbiAgICAgICksIFxuICAgICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJjb2x1bW4gZW52ZWxvcGVcIn0sIFxuICAgICAgICBFbnZlbG9wZSh7IFxcXG4gICAgICAgICAgXCJsYWJlbFwiOiBcIlZvbHVtZSBFbnZcIiwgIFxcXG4gICAgICAgICAgXCJlbnZcIjogKGRydW0uZ2V0KCd2b2x1bWVFbnYnKS50b0pTKCkpLCAgXFxcbiAgICAgICAgICBcIm9uQ2hhbmdlXCI6ICgtPilcbiAgICAgICAgfSlcbiAgICAgICksIFxuICAgICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJjb2x1bW4gY29udHJvbFwifSwgXG4gICAgICAgIEtub2IoeyBcXFxuICAgICAgICAgIFwibGFiZWxcIjogXCJMZXZlbFwiLCAgXFxcbiAgICAgICAgICBcInZhbHVlXCI6IChkcnVtLmdldCAnbGV2ZWwnKSwgIFxcXG4gICAgICAgICAgXCJvbkNoYW5nZVwiOiAoLT4pXG4gICAgICAgIH0pLCBcbiAgICAgICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJ1aVwifSwgXG4gICAgICAgICAgUmVhY3QuRE9NLnNlbGVjdCh7IFxcXG4gICAgICAgICAgICBcInZhbHVlXCI6IChkcnVtLmdldCAndHJhbnNwb3NlJyksICBcXFxuICAgICAgICAgICAgXCJvbkNoYW5nZVwiOiAoLT4pXG4gICAgICAgICAgfSwgXG4gICAgICAgICAgICAodHJhbnNwb3NlT3B0aW9ucygpKVxuICAgICAgICAgICksIFxuICAgICAgICAgIFJlYWN0LkRPTS5sYWJlbChudWxsLCBcIlRyYW5zcG9zZVwiKVxuICAgICAgICApLCBcbiAgICAgICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJ1aVwifSwgXG4gICAgICAgICAgUmVhY3QuRE9NLnNlbGVjdCh7IFxcXG4gICAgICAgICAgICBcInZhbHVlXCI6IChkcnVtLmdldCAna2V5JyksICBcXFxuICAgICAgICAgICAgXCJvbkNoYW5nZVwiOiAoLT4pXG4gICAgICAgICAgfSwgXG4gICAgICAgICAgICAoa2V5T3B0aW9ucygpKVxuICAgICAgICAgICksIFxuICAgICAgICAgIFJlYWN0LkRPTS5sYWJlbChudWxsLCBcIlRyaWdnZXJcIilcbiAgICAgICAgKVxuICAgICAgKVxuICAgIClcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0LmNyZWF0ZUNsYXNzXG5cbiAgbWl4aW5zOiBbVXBkYXRhYmxlXVxuXG4gIGdldEluaXRpYWxTdGF0ZTogLT5cbiAgICBhY3RpdmVEcnVtOiAwXG5cbiAgb25BZGREcnVtOiAtPlxuICAgICMgQHByb3BzLmluc3RydW1lbnQuYWRkRHJ1bSgpXG4gICAgIyBAc2V0U3RhdGUgYWN0aXZlRHJ1bTogQHByb3BzLmluc3RydW1lbnQuc3RhdGUuZHJ1bXMubGVuZ3RoIC0gMVxuXG4gIG9uUmVtb3ZlRHJ1bTogLT5cbiAgICAjIEBwcm9wcy5pbnN0cnVtZW50LnJlbW92ZURydW0gQHN0YXRlLmFjdGl2ZURydW1cbiAgICAjIEBzZXRTdGF0ZSBhY3RpdmVEcnVtOiBNYXRoLm1pbiBAc3RhdGUuYWN0aXZlRHJ1bSwgQHByb3BzLmluc3RydW1lbnQuc3RhdGUuZHJ1bXMubGVuZ3RoIC0gMVxuXG4gIHJlbmRlcjogLT5cbiAgICBpbnN0cnVtZW50ID0gQHByb3BzLmluc3RydW1lbnRcbiAgICBhY3RpdmVEcnVtID0gaW5zdHJ1bWVudC5jdXJzb3IgWydkcnVtcycsIEBzdGF0ZS5hY3RpdmVEcnVtXVxuXG4gICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJ1aSBkcnVtLXNhbXBsZXJcIn0sIFxuICAgICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJjb2x1bW4gY2hhbm5lbFwifSwgXG4gICAgICAgIFNsaWRlcih7IFxcXG4gICAgICAgICAgXCJsYWJlbFwiOiBcIkxldmVsXCIsICBcXFxuICAgICAgICAgIFwidmFsdWVcIjogKGluc3RydW1lbnQuZ2V0ICdsZXZlbCcpLCAgXFxcbiAgICAgICAgICBcIm9uQ2hhbmdlXCI6ICgtPilcbiAgICAgICAgfSlcbiAgICAgICksIFxuICAgICAgTGlzdENvbnRyb2woeyBcXFxuICAgICAgICBcIm9wdGlvbnNcIjogKGluc3RydW1lbnQuZ2V0ICdkcnVtcycpLCAgXFxcbiAgICAgICAgXCJzZWxlY3RlZEluZGV4XCI6IChAc3RhdGUuYWN0aXZlRHJ1bSksICBcXFxuICAgICAgICBcIm9uU2VsZWN0XCI6IChAdXBkYXRlICdhY3RpdmVEcnVtJyksICBcXFxuICAgICAgICBcIm9uQWRkXCI6IChAb25BZGREcnVtKSwgIFxcXG4gICAgICAgIFwib25SZW1vdmVcIjogKEBvblJlbW92ZURydW0pLCAgXFxcbiAgICAgICAgXCJvblNvcnRcIjogKC0+KVxuICAgICAgfSksIFxuICAgICAgRHJ1bSh7XCJkcnVtXCI6IChhY3RpdmVEcnVtKSwgXCJhcHBcIjogKEBwcm9wcy5hcHApfSlcbiAgICApIiwiXG5cblJlYWN0ID0gcmVxdWlyZSAncmVhY3QnXG5Nb2RlbGFibGUgPSByZXF1aXJlICcuL21peGlucy9tb2RlbGFibGUnXG5VcGRhdGFibGUgPSByZXF1aXJlICcuL21peGlucy91cGRhdGFibGUnXG5Lbm9iID0gcmVxdWlyZSAnLi9rbm9iJ1xuU2xpZGVyID0gcmVxdWlyZSAnLi9zbGlkZXInXG5MaXN0Q29udHJvbCA9IHJlcXVpcmUgJy4vbGlzdF9jb250cm9sJ1xua2V5T3B0aW9ucyA9IHJlcXVpcmUgJy4uL3V0aWwva2V5X29wdGlvbnMnXG5cblxuRHJ1bSA9IFJlYWN0LmNyZWF0ZUNsYXNzXG5cbiAgdXBkYXRlOiAoa2V5KSAtPlxuICAgICh2YWx1ZSkgPT5cbiAgICAgIG8gPSB7fVxuICAgICAgZm9yIGssIHYgb2YgQHByb3BzLmRydW1cbiAgICAgICAgb1trXSA9IGlmIGsgPT0ga2V5IHRoZW4gdmFsdWUgZWxzZSB2XG4gICAgICBAcHJvcHMub25DaGFuZ2Ugb1xuXG4gIGJpbmQ6IChrZXkpIC0+XG4gICAgdXBkYXRlID0gQHVwZGF0ZSBrZXlcbiAgICAoZSkgLT4gdXBkYXRlIGUudGFyZ2V0LnZhbHVlXG5cbiAgcmVuZGVyOiAtPlxuICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6ICdkcnVtJ30sIFxuICAgICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogJ2NvbHVtbiBhdHRycyd9LCBcbiAgICAgICAgS25vYih7IFxcXG4gICAgICAgICAgXCJsYWJlbFwiOiBcIkxldmVsXCIsICBcXFxuICAgICAgICAgIFwidmFsdWVcIjogKEBwcm9wcy5kcnVtLmxldmVsKSwgIFxcXG4gICAgICAgICAgXCJvbkNoYW5nZVwiOiAoQHVwZGF0ZSgnbGV2ZWwnKSlcbiAgICAgICAgfSksIFxuICAgICAgICBLbm9iKHsgXFxcbiAgICAgICAgICBcImxhYmVsXCI6IFwiUGl0Y2hcIiwgIFxcXG4gICAgICAgICAgXCJ2YWx1ZVwiOiAoQHByb3BzLmRydW0ucGl0Y2gpLCAgXFxcbiAgICAgICAgICBcIm9uQ2hhbmdlXCI6IChAdXBkYXRlKCdwaXRjaCcpKVxuICAgICAgICB9KSwgXG4gICAgICAgIEtub2IoeyBcXFxuICAgICAgICAgIFwibGFiZWxcIjogXCJGTVwiLCAgXFxcbiAgICAgICAgICBcInZhbHVlXCI6IChAcHJvcHMuZHJ1bS5mbSksICBcXFxuICAgICAgICAgIFwib25DaGFuZ2VcIjogKEB1cGRhdGUoJ2ZtJykpXG4gICAgICAgIH0pLCBcbiAgICAgICAgS25vYih7IFxcXG4gICAgICAgICAgXCJsYWJlbFwiOiBcIkRjeVwiLCAgXFxcbiAgICAgICAgICBcInZhbHVlXCI6IChAcHJvcHMuZHJ1bS5kZWNheSksICBcXFxuICAgICAgICAgIFwib25DaGFuZ2VcIjogKEB1cGRhdGUoJ2RlY2F5JykpXG4gICAgICAgIH0pLCBcbiAgICAgICAgS25vYih7IFxcXG4gICAgICAgICAgXCJsYWJlbFwiOiBcIkJlbmRcIiwgIFxcXG4gICAgICAgICAgXCJ2YWx1ZVwiOiAoQHByb3BzLmRydW0uYmVuZCksICBcXFxuICAgICAgICAgIFwib25DaGFuZ2VcIjogKEB1cGRhdGUoJ2JlbmQnKSlcbiAgICAgICAgfSksIFxuICAgICAgICBLbm9iKHsgXFxcbiAgICAgICAgICBcImxhYmVsXCI6IFwiTURjeVwiLCAgXFxcbiAgICAgICAgICBcInZhbHVlXCI6IChAcHJvcHMuZHJ1bS5mbURlY2F5KSwgIFxcXG4gICAgICAgICAgXCJvbkNoYW5nZVwiOiAoQHVwZGF0ZSgnZm1EZWNheScpKVxuICAgICAgICB9KSwgXG4gICAgICAgIEtub2IoeyBcXFxuICAgICAgICAgIFwibGFiZWxcIjogXCJOb2lzZVwiLCAgXFxcbiAgICAgICAgICBcInZhbHVlXCI6IChAcHJvcHMuZHJ1bS5ub2lzZSksICBcXFxuICAgICAgICAgIFwib25DaGFuZ2VcIjogKEB1cGRhdGUoJ25vaXNlJykpXG4gICAgICAgIH0pLCBcbiAgICAgICAgS25vYih7IFxcXG4gICAgICAgICAgXCJsYWJlbFwiOiBcIkhQXCIsICBcXFxuICAgICAgICAgIFwidmFsdWVcIjogKEBwcm9wcy5kcnVtLmhwKSwgIFxcXG4gICAgICAgICAgXCJvbkNoYW5nZVwiOiAoQHVwZGF0ZSgnaHAnKSlcbiAgICAgICAgfSksIFxuICAgICAgICBLbm9iKHsgXFxcbiAgICAgICAgICBcImxhYmVsXCI6IFwiTUZycVwiLCAgXFxcbiAgICAgICAgICBcInZhbHVlXCI6IChAcHJvcHMuZHJ1bS5mbUZyZXEpLCAgXFxcbiAgICAgICAgICBcIm9uQ2hhbmdlXCI6IChAdXBkYXRlKCdmbUZyZXEnKSlcbiAgICAgICAgfSlcbiAgICAgICksIFxuICAgICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJjb2x1bW4gY29udHJvbFwifSwgXG4gICAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwidWlcIn0sIFxuICAgICAgICAgIFJlYWN0LkRPTS5zZWxlY3QoeyBcXFxuICAgICAgICAgICAgXCJ2YWx1ZVwiOiAoQHByb3BzLmRydW0ua2V5KSwgIFxcXG4gICAgICAgICAgICBcIm9uQ2hhbmdlXCI6IChAYmluZCAna2V5JylcbiAgICAgICAgICB9LCBcbiAgICAgICAgICAgIChrZXlPcHRpb25zKCkpXG4gICAgICAgICAgKSwgXG4gICAgICAgICAgUmVhY3QuRE9NLmxhYmVsKG51bGwsIFwiVHJpZ2dlclwiKVxuICAgICAgICApXG4gICAgICApXG4gICAgKVxuXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3QuY3JlYXRlQ2xhc3NcblxuICBtaXhpbnM6IFtNb2RlbGFibGUsIFVwZGF0YWJsZV1cblxuICBnZXRJbml0aWFsU3RhdGU6IC0+XG4gICAgYWN0aXZlRHJ1bTogMFxuXG4gIG9uQWRkRHJ1bTogLT5cbiAgICBAcHJvcHMuaW5zdHJ1bWVudC5hZGREcnVtKClcbiAgICBAc2V0U3RhdGUgYWN0aXZlRHJ1bTogQHByb3BzLmluc3RydW1lbnQuc3RhdGUuZHJ1bXMubGVuZ3RoIC0gMVxuXG4gIG9uUmVtb3ZlRHJ1bTogLT5cbiAgICBAcHJvcHMuaW5zdHJ1bWVudC5yZW1vdmVEcnVtIEBzdGF0ZS5hY3RpdmVEcnVtXG4gICAgQHNldFN0YXRlIGFjdGl2ZURydW06IE1hdGgubWluIEBzdGF0ZS5hY3RpdmVEcnVtLCBAcHJvcHMuaW5zdHJ1bWVudC5zdGF0ZS5kcnVtcy5sZW5ndGggLSAxXG5cbiAgcmVuZGVyOiAtPlxuICAgIGFjdGl2ZURydW0gPSBAcHJvcHMuaW5zdHJ1bWVudC5zdGF0ZS5kcnVtc1tAc3RhdGUuYWN0aXZlRHJ1bV1cbiAgICB1cGRhdGVEcnVtID0gQHByb3BzLmluc3RydW1lbnQuY3JlYXRlU2V0dGVyRm9yRHJ1bSBAc3RhdGUuYWN0aXZlRHJ1bVxuXG4gICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJ1aSBkcnVta2l0XCJ9LCBcbiAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwiY29sdW1uIGNoYW5uZWxcIn0sIFxuICAgICAgICBTbGlkZXIoeyBcXFxuICAgICAgICAgIFwibGFiZWxcIjogXCJMZXZlbFwiLCAgXFxcbiAgICAgICAgICBcInZhbHVlXCI6IChAcHJvcHMuaW5zdHJ1bWVudC5zdGF0ZS5sZXZlbCksICBcXFxuICAgICAgICAgIFwib25DaGFuZ2VcIjogKEBwcm9wcy5pbnN0cnVtZW50LmNyZWF0ZVNldHRlckZvcignbGV2ZWwnKSlcbiAgICAgICAgfSlcbiAgICAgICksIFxuICAgICAgTGlzdENvbnRyb2woeyBcXFxuICAgICAgICBcIm9wdGlvbnNcIjogKEBwcm9wcy5pbnN0cnVtZW50LnN0YXRlLmRydW1zKSwgIFxcXG4gICAgICAgIFwic2VsZWN0ZWRJbmRleFwiOiAoQHN0YXRlLmFjdGl2ZURydW0pLCAgXFxcbiAgICAgICAgXCJvblNlbGVjdFwiOiAoQHVwZGF0ZSAnYWN0aXZlRHJ1bScpLCAgXFxcbiAgICAgICAgXCJvbkFkZFwiOiAoQG9uQWRkRHJ1bSksICBcXFxuICAgICAgICBcIm9uUmVtb3ZlXCI6IChAb25SZW1vdmVEcnVtKSwgIFxcXG4gICAgICAgIFwib25Tb3J0XCI6IChAcHJvcHMuaW5zdHJ1bWVudC5jcmVhdGVTZXR0ZXJGb3IgJ2RydW1zJylcbiAgICAgIH0pLCBcbiAgICAgIERydW0oe1wiZHJ1bVwiOiAoYWN0aXZlRHJ1bSksIFwib25DaGFuZ2VcIjogKHVwZGF0ZURydW0pfSlcbiAgICApXG4iLCJcblxuUmVhY3QgPSByZXF1aXJlICdyZWFjdCdcblNpemVNZWFzdXJhYmxlID0gcmVxdWlyZSAnLi9taXhpbnMvc2l6ZV9tZWFzdXJhYmxlJ1xuRHJhZ2dhYmxlID0gcmVxdWlyZSAnLi9taXhpbnMvZHJhZ2dhYmxlJ1xuS25vYiA9IHJlcXVpcmUgJy4va25vYidcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdC5jcmVhdGVDbGFzc1xuXG4gIG1peGluczogW1NpemVNZWFzdXJhYmxlLCBEcmFnZ2FibGVdXG5cbiAgZ2V0SW5pdGlhbFN0YXRlOiAtPlxuICAgIGRyYWdUYXJnZXQ6IG51bGxcblxuICBnZXREZWZhdWx0UHJvcHM6IC0+XG4gICAgZG90UmFkaXVzOiA1XG4gICAgbWFyZ2luOiA0XG5cbiAgYnVpbGRMaW5lczogLT5cbiAgICBsaW5lcyA9IFtdXG4gICAgZG90cyA9IFtdXG4gICAgbSA9IEBwcm9wcy5tYXJnaW4gKyBAcHJvcHMuZG90UmFkaXVzXG4gICAgdyA9IEBzdGF0ZS53aWR0aCAtIDIgKiBtXG4gICAgaCA9IEBzdGF0ZS5oZWlnaHQgLSAyICogbVxuICAgIGVudiA9IEBwcm9wcy5lbnZcblxuICAgIHAxID1cbiAgICAgIHg6IDBcbiAgICAgIHk6IGhcbiAgICBcbiAgICBwMiA9XG4gICAgICB4OiB3IC8gMyAqIGVudi5hXG4gICAgICB5OiAwXG4gICAgXG4gICAgcDMgPVxuICAgICAgeDogcDIueCArIHcgLyAzICogZW52LmRcbiAgICAgIHk6IGggKiAoMSAtIGVudi5zKVxuICAgIFxuICAgIHA0ID1cbiAgICAgIHg6IHcgKiAyIC8gM1xuICAgICAgeTogaCAqICgxIC0gZW52LnMpXG4gICAgXG4gICAgcDUgPVxuICAgICAgeDogdyAqICgyICsgZW52LnIpIC8gM1xuICAgICAgeTogaFxuXG4gICAgZm9yIHAgaW4gW3AxLCBwMiwgcDMsIHA0LCBwNV1cbiAgICAgIHAueCArPSBtXG4gICAgICBwLnkgKz0gbVxuXG4gICAgIyAjIGJhc2VcbiAgICAjIGxpbmVzLnB1c2ggPGxpbmUga2V5PVwiYlwiIHgxPXttfSB5MT17bStofSB4Mj17bSt3fSB5Mj17bStofS8+XG5cbiAgICAjIHBhdGhcbiAgICBkID0gJ00gJyArIFtwMSwgcDIsIHAzLCBwNCwgcDVdLm1hcCgocCkgLT4gXCIje3AueH0gI3twLnl9XCIpLmpvaW4gJyBMICdcbiAgICBsaW5lcy5wdXNoIFJlYWN0LkRPTS5wYXRoKHtcImtleVwiOiBcInBcIiwgXCJkXCI6IChkKX0pXG5cbiAgICAjIGF0dGFja1xuICAgIGNsYXNzTmFtZSA9IGlmIEBzdGF0ZS5kcmFnVGFyZ2V0IGlzICdhdHRhY2snIHRoZW4gJ2FjdGl2ZScgZWxzZSAnJ1xuICAgIGRvdHMucHVzaCBSZWFjdC5ET00uY2lyY2xlKHtcImtleVwiOiBcImFcIiwgXCJjbGFzc05hbWVcIjogKGNsYXNzTmFtZSksIFwiY3hcIjogKHAyLngpLCBcImN5XCI6IChwMi55KSwgXCJyXCI6IChAcHJvcHMuZG90UmFkaXVzKSwgXCJvbk1vdXNlRG93blwiOiAoQG9uTW91c2VEb3duQXR0YWNrKX0pXG5cbiAgICAjIGRlY2F5IC8gc3VzdGFpblxuICAgIGNsYXNzTmFtZSA9IGlmIEBzdGF0ZS5kcmFnVGFyZ2V0IGlzICdkZWNheScgdGhlbiAnYWN0aXZlJyBlbHNlICcnXG4gICAgZG90cy5wdXNoIFJlYWN0LkRPTS5jaXJjbGUoe1wia2V5XCI6IFwiZFwiLCBcImNsYXNzTmFtZVwiOiAoY2xhc3NOYW1lKSwgXCJjeFwiOiAocDMueCksIFwiY3lcIjogKHAzLnkpLCBcInJcIjogKEBwcm9wcy5kb3RSYWRpdXMpLCBcIm9uTW91c2VEb3duXCI6IChAb25Nb3VzZURvd25EZWNheSl9KVxuXG4gICAgI3JlbGVhc2VcbiAgICBjbGFzc05hbWUgPSBpZiBAc3RhdGUuZHJhZ1RhcmdldCBpcyAncmVsZWFzZScgdGhlbiAnYWN0aXZlJyBlbHNlICcnXG4gICAgZG90cy5wdXNoIFJlYWN0LkRPTS5jaXJjbGUoe1wia2V5XCI6IFwiclwiLCBcImNsYXNzTmFtZVwiOiAoY2xhc3NOYW1lKSwgXCJjeFwiOiAocDUueCksIFwiY3lcIjogKHA1LnkpLCBcInJcIjogKEBwcm9wcy5kb3RSYWRpdXMpLCBcIm9uTW91c2VEb3duXCI6IChAb25Nb3VzZURvd25SZWxlYXNlKX0pXG5cbiAgICBsaW5lcy5jb25jYXQgZG90c1xuXG4gIG9uTW91c2VEb3duQXR0YWNrOiAoZSkgLT5cbiAgICBAaW5pdGlhbFZhbHVlID0gQHByb3BzLmVudi5hXG4gICAgQHNldFN0YXRlIGRyYWdUYXJnZXQ6ICdhdHRhY2snXG4gICAgQGRyYWdnYWJsZU9uTW91c2VEb3duIGVcblxuICBvbk1vdXNlRG93bkRlY2F5OiAoZSkgLT5cbiAgICBAaW5pdGlhbFZhbHVlID0ge2Q6IEBwcm9wcy5lbnYuZCwgczogQHByb3BzLmVudi5zfVxuICAgIEBzZXRTdGF0ZSBkcmFnVGFyZ2V0OiAnZGVjYXknXG4gICAgQGRyYWdnYWJsZU9uTW91c2VEb3duIGVcblxuICBvbk1vdXNlRG93blJlbGVhc2U6IChlKSAtPlxuICAgIEBpbml0aWFsVmFsdWUgPSBAcHJvcHMuZW52LnJcbiAgICBAc2V0U3RhdGUgZHJhZ1RhcmdldDogJ3JlbGVhc2UnXG4gICAgQGRyYWdnYWJsZU9uTW91c2VEb3duIGVcblxuICBvbkRyYWc6IChkZWx0YSkgLT5cbiAgICBtID0gQHByb3BzLm1hcmdpbiArIEBwcm9wcy5kb3RSYWRpdXNcbiAgICB3ID0gKEBzdGF0ZS53aWR0aCAtIDIgKiBtKSAvIDNcbiAgICBoID0gQHN0YXRlLmhlaWdodCAtIDIgKiBtXG5cbiAgICBpZiBAc3RhdGUuZHJhZ1RhcmdldCBpcyAnYXR0YWNrJ1xuICAgICAgYSA9IEBpbml0aWFsVmFsdWUgKyBkZWx0YS54IC8gd1xuICAgICAgY2hhbmdlcyA9IHthfVxuICAgIGVsc2UgaWYgQHN0YXRlLmRyYWdUYXJnZXQgaXMgJ2RlY2F5J1xuICAgICAgZCA9IEBpbml0aWFsVmFsdWUuZCArIGRlbHRhLnggLyB3XG4gICAgICBzID0gQGluaXRpYWxWYWx1ZS5zICsgZGVsdGEueSAvIGhcbiAgICAgIGNoYW5nZXMgPSB7ZCwgc31cbiAgICBlbHNlIGlmIEBzdGF0ZS5kcmFnVGFyZ2V0IGlzICdyZWxlYXNlJ1xuICAgICAgciA9IEBpbml0aWFsVmFsdWUgKyBkZWx0YS54IC8gd1xuICAgICAgY2hhbmdlcyA9IHtyfVxuXG4gICAgZm9yIGssIHYgb2YgY2hhbmdlc1xuICAgICAgY2hhbmdlc1trXSA9IE1hdGgubWF4IDAsIE1hdGgubWluIDEsIHZcblxuICAgIGVudiA9IHt9XG4gICAgZm9yIGssIHYgb2YgQHByb3BzLmVudlxuICAgICAgZW52W2tdID0gaWYgY2hhbmdlc1trXT8gdGhlbiBjaGFuZ2VzW2tdIGVsc2UgdlxuICAgIEBwcm9wcy5vbkNoYW5nZSBlbnZcblxuICBvbkRyYWdFbmQ6IC0+XG4gICAgQGluaXRpYWxWYWx1ZSA9IG51bGxcbiAgICBAc2V0U3RhdGUgZHJhZ1RhcmdldDogbnVsbFxuXG4gIHVwZGF0ZTogKGF0dHIpIC0+XG4gICAgKHZhbHVlKSA9PlxuICAgICAgZW52ID0ge31cbiAgICAgIGZvciBrLCB2IG9mIEBwcm9wcy5lbnZcbiAgICAgICAgZW52W2tdID0gaWYgayA9PSBhdHRyIHRoZW4gdmFsdWUgZWxzZSB2XG4gICAgICBAcHJvcHMub25DaGFuZ2UgZW52XG5cbiAgcmVuZGVyOiAtPlxuICAgIGxpbmVzID0gQGJ1aWxkTGluZXMoKSBpZiBAc3RhdGUud2lkdGggPiAwXG5cbiAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiAndWkgZW52ZWxvcGUnfSwgXG4gICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiAnY29udHJvbCcsIFwicmVmXCI6ICdjb250YWluZXInfSwgXG4gICAgICAgIFJlYWN0LkRPTS5zdmcoe1wid2lkdGhcIjogKEBzdGF0ZS53aWR0aCksIFwiaGVpZ2h0XCI6IChAc3RhdGUuaGVpZ2h0KX0sIFxuICAgICAgICAgIChsaW5lcylcbiAgICAgICAgKVxuICAgICAgKSwgXG4gICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiAna25vYnMnfSwgXG4gICAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6ICdncm91cCd9LCBcbiAgICAgICAgICBLbm9iKHtcImxhYmVsXCI6ICdBJywgXCJ2YWx1ZVwiOiAoQHByb3BzLmVudi5hKSwgXCJvbkNoYW5nZVwiOiAoQHVwZGF0ZSgnYScpKX0pLCBcbiAgICAgICAgICBLbm9iKHtcImxhYmVsXCI6ICdEJywgXCJ2YWx1ZVwiOiAoQHByb3BzLmVudi5kKSwgXCJvbkNoYW5nZVwiOiAoQHVwZGF0ZSgnZCcpKX0pXG4gICAgICAgICksIFxuICAgICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiAnZ3JvdXAnfSwgXG4gICAgICAgICAgS25vYih7XCJsYWJlbFwiOiAnUycsIFwidmFsdWVcIjogKEBwcm9wcy5lbnYucyksIFwib25DaGFuZ2VcIjogKEB1cGRhdGUoJ3MnKSl9KSwgXG4gICAgICAgICAgS25vYih7XCJsYWJlbFwiOiAnUicsIFwidmFsdWVcIjogKEBwcm9wcy5lbnYuciksIFwib25DaGFuZ2VcIjogKEB1cGRhdGUoJ3InKSl9KVxuICAgICAgICApXG4gICAgICApLCBcbiAgICAgIFJlYWN0LkRPTS5sYWJlbChudWxsLCAoQHByb3BzLmxhYmVsKSlcbiAgICApIiwiXG5cblJlYWN0ID0gcmVxdWlyZSAncmVhY3QnXG5DaG9vc2VyID0gcmVxdWlyZSAnLi9jaG9vc2VyJ1xuS25vYiA9IHJlcXVpcmUgJy4va25vYidcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdC5jcmVhdGVDbGFzc1xuXG4gIHVwZGF0ZTogKGF0dHIpIC0+XG4gICAgKHZhbHVlKSA9PlxuICAgICAgZmlsdGVyID0ge31cbiAgICAgIGZvciBrLCB2IG9mIEBwcm9wcy5maWx0ZXJcbiAgICAgICAgZmlsdGVyW2tdID0gaWYgayA9PSBhdHRyIHRoZW4gdmFsdWUgZWxzZSB2XG4gICAgICBAcHJvcHMub25DaGFuZ2UgZmlsdGVyXG5cbiAgcmVuZGVyOiAtPlxuICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwidWkgZmlsdGVyXCJ9LCBcbiAgICAgIENob29zZXIoe1wib3B0aW9uc1wiOiAoWydMUCcsJ0hQJywnbm9uZSddKSwgXCJ2YWx1ZVwiOiAoQHByb3BzLmZpbHRlci50eXBlKSwgXCJvbkNoYW5nZVwiOiAoQHVwZGF0ZSgndHlwZScpKX0pLCBcbiAgICAgIEtub2Ioe1wibGFiZWxcIjogXCJGcmVxXCIsIFwidmFsdWVcIjogKEBwcm9wcy5maWx0ZXIuZnJlcSksIFwib25DaGFuZ2VcIjogKEB1cGRhdGUoJ2ZyZXEnKSl9KSwgXG4gICAgICBLbm9iKHtcImxhYmVsXCI6IFwiUmVzXCIsIFwidmFsdWVcIjogKEBwcm9wcy5maWx0ZXIucmVzKSwgXCJvbkNoYW5nZVwiOiAoQHVwZGF0ZSgncmVzJykpfSksICAgICBcbiAgICAgIEtub2Ioe1wibGFiZWxcIjogXCJFbnZcIiwgXCJ2YWx1ZVwiOiAoQHByb3BzLmZpbHRlci5lbnYpLCBcIm9uQ2hhbmdlXCI6IChAdXBkYXRlKCdlbnYnKSl9KSwgXG4gICAgICBSZWFjdC5ET00ubGFiZWwobnVsbCwgKEBwcm9wcy5sYWJlbCkpXG4gICAgKSIsIlxuXG5SZWFjdCA9IHJlcXVpcmUgJ3JlYWN0J1xuRHJhZ2dhYmxlID0gcmVxdWlyZSAnLi9taXhpbnMvZHJhZ2dhYmxlJ1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0LmNyZWF0ZUNsYXNzXG5cbiAgcmFuZ2U6IDEwMFxuXG4gIG1peGluczogW0RyYWdnYWJsZV1cblxuICBnZXRJbml0aWFsU3RhdGU6IC0+XG4gICAgYWN0aXZlOiBmYWxzZVxuXG4gIGdldERlZmF1bHRQcm9wczogLT5cbiAgICB2YWx1ZTogMC41XG5cbiAgb25EcmFnU3RhcnQ6IC0+XG4gICAgQGluaXRhbFZhbHVlID0gQHByb3BzLnZhbHVlXG4gICAgQHNldFN0YXRlIGFjdGl2ZTogdHJ1ZVxuXG4gIG9uRHJhZzogKGRlbHRhKSAtPlxuICAgIHJldHVybiBpZiBAcHJvcHMuZGlzYWJsZWRcblxuICAgIHVwUmFuZ2UgPSBNYXRoLm1pbiBAcmFuZ2UsIChAZHJhZ1N0YXJ0UG9zaXRpb24ueSAtIHdpbmRvdy5zY3JvbGxZKVxuICAgIGRvd25SYW5nZSA9IE1hdGgubWluIEByYW5nZSwgKHdpbmRvdy5pbm5lckhlaWdodCArIHdpbmRvdy5zY3JvbGxZIC0gQGRyYWdTdGFydFBvc2l0aW9uLnkpXG5cbiAgICBpZiBkZWx0YS55IDwgMFxuICAgICAgdmFsdWUgPSBNYXRoLm1heCAwLCBAaW5pdGFsVmFsdWUgKiAoZG93blJhbmdlICsgZGVsdGEueSkgLyBkb3duUmFuZ2VcbiAgICBlbHNlXG4gICAgICB2YWx1ZSA9IE1hdGgubWluIDEsIEBpbml0YWxWYWx1ZSArICgxIC0gQGluaXRhbFZhbHVlKSAqIGRlbHRhLnkgLyB1cFJhbmdlXG5cbiAgICBAcHJvcHMub25DaGFuZ2UgdmFsdWVcblxuICBvbkRyYWdFbmQ6IC0+XG4gICAgQGluaXRhbFZhbHVlID0gbnVsbFxuICAgIEBzZXRTdGF0ZSBhY3RpdmU6IGZhbHNlXG5cbiAgcHJldmVudERlZmF1bHQ6IChlKSAtPlxuICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcblxuICByZW5kZXI6IC0+XG4gICAgc3R5bGUgPSAnLXdlYmtpdC10cmFuc2Zvcm0nOiBcInJvdGF0ZSgjeyhAcHJvcHMudmFsdWUgLSAwLjUpICogMzAwfWRlZylcIlxuICAgIFxuICAgIGNsYXNzTmFtZSA9ICd1aSBrbm9iJ1xuICAgIGNsYXNzTmFtZSArPSAnIGFjdGl2ZScgaWYgQHN0YXRlLmFjdGl2ZVxuICAgIGNsYXNzTmFtZSArPSAnIGRpc2FibGVkJyBpZiBAcHJvcHMuZGlzYWJsZWRcblxuICAgICMgaW5jbHVkZSBkcmFnZ2FibGUgYW5kIG9uZHJhZ3N0YXJ0IHRvIGFsbG93IHVzZSBvZiB0aGUga25vYiBjb21wb25lbnRcbiAgICAjIGluc2lkZSBhIHBhcmVudCBlbGVtZW50IHVzaW5nIG5hdGl2ZSBodG1sIGRyYWcvZHJvcFxuICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IChjbGFzc05hbWUpLCBcImRyYWdnYWJsZVwiOiAodHJ1ZSksIFwib25EcmFnU3RhcnRcIjogKEBwcmV2ZW50RGVmYXVsdCl9LCBcbiAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwiY29udHJvbFwifSwgXG4gICAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwiaGFuZGxlXCIsIFwic3R5bGVcIjogKHN0eWxlKSwgXCJvbk1vdXNlRG93blwiOiAoQGRyYWdnYWJsZU9uTW91c2VEb3duKX0pXG4gICAgICApLCBcbiAgICAgIFJlYWN0LkRPTS5sYWJlbChudWxsLCAoQHByb3BzLmxhYmVsKSlcbiAgICApIiwiXG5cblJlYWN0ID0gcmVxdWlyZSAncmVhY3QvYWRkb25zJ1xuU29ydGFibGUgPSByZXF1aXJlICcuL21peGlucy9zb3J0YWJsZSdcblxuTGlzdE9wdGlvbiA9IFJlYWN0LmNyZWF0ZUNsYXNzXG5cbiAgbWl4aW5zOiBbU29ydGFibGUsIFJlYWN0LmFkZG9ucy5QdXJlUmVuZGVyTWl4aW5dXG5cbiAgcmVuZGVyOiAtPlxuICAgIGNsYXNzTmFtZSA9ICdvcHRpb24nXG4gICAgY2xhc3NOYW1lICs9ICcgc2VsZWN0ZWQnIGlmIEBwcm9wcy5zZWxlY3RlZFxuICAgIGNsYXNzTmFtZSArPSAnIGRyYWdnaW5nJyBpZiBAaXNEcmFnZ2luZygpXG5cbiAgICBSZWFjdC5ET00uZGl2KHsgXFxcbiAgICAgIFwiY2xhc3NOYW1lXCI6IChjbGFzc05hbWUpLCAgXFxcbiAgICAgIFwib25DbGlja1wiOiAoQHByb3BzLnNlbGVjdE9wdGlvbiksICBcXFxuICAgICAgXCJkcmFnZ2FibGVcIjogKHRydWUpLCAgXFxcbiAgICAgIFwib25EcmFnU3RhcnRcIjogKEBkcmFnU3RhcnQpLCAgXFxcbiAgICAgIFwib25EcmFnRW5kXCI6IChAZHJhZ0VuZCksICBcXFxuICAgICAgXCJvbkRyYWdPdmVyXCI6IChAZHJhZ092ZXIpLCAgXFxcbiAgICAgIFwiZGF0YS1pZFwiOiAoQHByb3BzLmtleSlcbiAgICB9LCBcbiAgICAgIChAcHJvcHMubmFtZSlcbiAgICApXG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0LmNyZWF0ZUNsYXNzXG5cbiAgbWl4aW5zOiBbUmVhY3QuYWRkb25zLlB1cmVSZW5kZXJNaXhpbl1cblxuICBnZXRJbml0aWFsU3RhdGU6IC0+XG4gICAgZHJhZ2dpbmc6IG51bGxcblxuICBvblJlbW92ZTogLT5cbiAgICBAcHJvcHMub25SZW1vdmUgQHByb3BzLnNlbGVjdGVkSW5kZXhcblxuICBzb3J0OiAoaXRlbXMsIGRyYWdnaW5nKSAtPlxuICAgIEBwcm9wcy5vblNvcnQgaXRlbXNcbiAgICBAcHJvcHMub25TZWxlY3QgZHJhZ2dpbmcgaWYgZHJhZ2dpbmc/XG4gICAgQHNldFN0YXRlIHtkcmFnZ2luZ31cblxuICByZW5kZXI6IC0+XG4gICAgb3B0aW9ucyA9IEBwcm9wcy5vcHRpb25zXG4gICAgICAubWFwIChvcHRpb24sIGkpID0+XG4gICAgICAgIExpc3RPcHRpb24oeyBcXFxuICAgICAgICAgIFwia2V5XCI6IChpKSwgIFxcXG4gICAgICAgICAgXCJuYW1lXCI6IChvcHRpb24uZ2V0ICduYW1lJyksICBcXFxuICAgICAgICAgIFwic2VsZWN0ZWRcIjogKGkgPT0gQHByb3BzLnNlbGVjdGVkSW5kZXgpLCAgXFxcbiAgICAgICAgICBcInNlbGVjdE9wdGlvblwiOiAoPT4gQHByb3BzLm9uU2VsZWN0IGkpLCAgXFxcbiAgICAgICAgICBcInNvcnRcIjogKEBzb3J0KSwgIFxcXG4gICAgICAgICAgXCJpdGVtc1wiOiAoQHByb3BzLm9wdGlvbnMpLCAgXFxcbiAgICAgICAgICBcImRyYWdnaW5nXCI6IChAc3RhdGUuZHJhZ2dpbmcpXG4gICAgICAgIH0pXG4gICAgICAudG9BcnJheSgpXG5cbiAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcInVpIGxpc3QtY29udHJvbFwifSwgXG4gICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcImxpc3RcIn0sIFxuICAgICAgICAob3B0aW9ucylcbiAgICAgICksIFxuICAgICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJjb250cm9sc1wifSwgXG4gICAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwiaWNvbiBpY29uLXBsdXMgcHVsbC1yaWdodFwiLCBcIm9uQ2xpY2tcIjogKEBwcm9wcy5vbkFkZCl9KSwgXG4gICAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwiaWNvbiBpY29uLW1pbnVzIHB1bGwtbGVmdFwiLCBcIm9uQ2xpY2tcIjogKEBvblJlbW92ZSl9KVxuICAgICAgKVxuICAgIClcbiIsIlxuXG5SZWFjdCA9IHJlcXVpcmUgJ3JlYWN0J1xuTW9kZWxhYmxlID0gcmVxdWlyZSAnLi9taXhpbnMvbW9kZWxhYmxlJ1xuS25vYiA9IHJlcXVpcmUgJy4va25vYidcblNsaWRlciA9IHJlcXVpcmUgJy4vc2xpZGVyJ1xuU2FtcGxlQ29udHJvbCA9IHJlcXVpcmUgJy4vc2FtcGxlX2NvbnRyb2wnXG5FbnZlbG9wZSA9IHJlcXVpcmUgJy4vZW52ZWxvcGUnXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3QuY3JlYXRlQ2xhc3NcblxuICBtaXhpbnM6IFtNb2RlbGFibGUoJ2luc3RydW1lbnQnKV1cblxuICBzZXRQb2x5cGhvbnk6IChlKSAtPlxuICAgIEBwcm9wcy5pbnN0cnVtZW50LnNldFBvbHlwaG9ueSBwYXJzZUludCBlLnRhcmdldC52YWx1ZVxuXG4gIHJlbmRlcjogLT5cbiAgICBvcHRpb25zID0gZm9yIGkgaW4gWzEuLkBwcm9wcy5pbnN0cnVtZW50Lm1heFBvbHlwaG9ueV1cbiAgICAgIFJlYWN0LkRPTS5vcHRpb24oe1wia2V5XCI6IChpKSwgXCJ2YWx1ZVwiOiAoaSl9LCAoaSkpXG5cbiAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcInVpIGxvb3Atc2FtcGxlclwifSwgXG4gICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcImNvbHVtbiBjaGFubmVsXCJ9LCBcbiAgICAgICAgU2xpZGVyKHsgXFxcbiAgICAgICAgICBcImxhYmVsXCI6IFwiTGV2ZWxcIiwgIFxcXG4gICAgICAgICAgXCJ2YWx1ZVwiOiAoQHN0YXRlLmxldmVsKSwgIFxcXG4gICAgICAgICAgXCJvbkNoYW5nZVwiOiAoQHByb3BzLmluc3RydW1lbnQuY3JlYXRlU2V0dGVyRm9yICdsZXZlbCcpXG4gICAgICAgIH0pLCBcbiAgICAgICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJ1aVwifSwgXG4gICAgICAgICAgUmVhY3QuRE9NLnNlbGVjdCh7XCJvbkNoYW5nZVwiOiAoQHNldFBvbHlwaG9ueSksIFwidmFsdWVcIjogKEBzdGF0ZS5wb2x5cGhvbnkpfSwgKG9wdGlvbnMpKSwgXG4gICAgICAgICAgUmVhY3QuRE9NLmxhYmVsKG51bGwsIFwiUG9seVwiKVxuICAgICAgICApXG4gICAgICApXG4gICAgKVxuIiwiUmVhY3QgPSByZXF1aXJlICdyZWFjdCdcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdC5jcmVhdGVDbGFzc1xuICBcbiAgb25DbGlja09wdGlvbjogKGUpIC0+XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgIEBwcm9wcy5vblNlbGVjdCBlLnRhcmdldC5kYXRhc2V0Lm9wdGlvblxuXG4gIHJlbmRlcjogLT5cbiAgICBvcHRpb25zID0gZm9yIG9wdGlvbiwgaSBpbiBAcHJvcHMub3B0aW9uc1xuICAgICAgZG8gKG9wdGlvbikgPT5cbiAgICAgICAgUmVhY3QuRE9NLmRpdih7XCJrZXlcIjogKGkpLCBcImNsYXNzTmFtZVwiOiBcIm9wdGlvblwiLCBcIm9uQ2xpY2tcIjogKEBvbkNsaWNrT3B0aW9uKSwgXCJkYXRhLW9wdGlvblwiOiAob3B0aW9uKX0sIChvcHRpb24pKVxuXG4gICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJ1aSBtZW51XCIsIFwic3R5bGVcIjogKHtkaXNwbGF5OiBpZiBAcHJvcHMub3BlbiB0aGVuICdibG9jaycgZWxzZSAnbm9uZSd9KX0sIChvcHRpb25zKSlcbiIsIlxuXG5SZWFjdCA9IHJlcXVpcmUgJ3JlYWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0LmNyZWF0ZUNsYXNzXG5cbiAgZ2V0RGVmYXVsdFByb3BzOiAtPlxuICAgIHN0ZXBzOiA2XG5cbiAgcmVuZGVyOiAtPlxuICAgIGxldmVsID0gTWF0aC5jZWlsKEBwcm9wcy50cmFjay5nZXQoJ21ldGVyTGV2ZWwnKSAqIEBwcm9wcy5zdGVwcylcbiAgICBcbiAgICBzdGVwcyA9IGZvciBpIGluIFsxLi5AcHJvcHMuc3RlcHNdXG4gICAgICBjbGFzc05hbWUgPSBpZiBpIDw9IGxldmVsIHRoZW4gJ29uJyBlbHNlICcnXG4gICAgICBSZWFjdC5ET00uZGl2KHtcImtleVwiOiAoaSksIFwiY2xhc3NOYW1lXCI6IChjbGFzc05hbWUpfSlcblxuICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwidWkgbWV0ZXJcIn0sIFxuICAgICAgKHN0ZXBzKVxuICAgIClcblxuICBzaG91bGRDb21wb25lbnRVcGRhdGU6IChuZXh0UHJvcHMpIC0+XG4gICAgTWF0aC5jZWlsKEBwcm9wcy50cmFjay5nZXQoJ21ldGVyTGV2ZWwnKSAqIEBwcm9wcy5zdGVwcykgIT0gTWF0aC5jZWlsKG5leHRQcm9wcy50cmFjay5nZXQoJ21ldGVyTGV2ZWwnKSAqIG5leHRQcm9wcy5zdGVwcylcbiIsIm1vZHVsZS5leHBvcnRzID1cblxuICBkcmFnZ2FibGVPbk1vdXNlRG93bjogKGUpIC0+XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgJ21vdXNlbW92ZScsIEBkcmFnZ2FibGVPbk1vdXNlTW92ZVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyICdtb3VzZXVwJywgQGRyYWdnYWJsZU9uTW91c2VVcFxuICAgIEBkcmFnU3RhcnRQb3NpdGlvbiA9IHg6IGUuY2xpZW50WCwgeTogZS5jbGllbnRZXG4gICAgQG9uRHJhZ1N0YXJ0PyhAZHJhZ1N0YXJ0UG9zaXRpb24sIGUpXG5cbiAgZHJhZ2dhYmxlT25Nb3VzZU1vdmU6IChlKSAtPlxuICAgIHggPSBlLmNsaWVudFggLSBAZHJhZ1N0YXJ0UG9zaXRpb24ueFxuICAgIHkgPSBAZHJhZ1N0YXJ0UG9zaXRpb24ueSAtIGUuY2xpZW50WVxuICAgIEBvbkRyYWc/KHt4LHl9LCBlKVxuXG4gIGRyYWdnYWJsZU9uTW91c2VVcDogKGUpIC0+XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIgJ21vdXNlbW92ZScsIEBkcmFnZ2FibGVPbk1vdXNlTW92ZVxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyICdtb3VzZXVwJywgQGRyYWdnYWJsZU9uTW91c2VVcFxuICAgIEBtb3VzZURvd25Qb3NpdGlvbiA9IG51bGxcbiAgICBAaW5pdGlhbFZhbHVlID0gbnVsbFxuICAgIEBvbkRyYWdFbmQ/KGUpXG4iLCJpZGVudGl0eSA9ICh2KSAtPiB2XG5cbmNhcGl0YWxpemUgPSAocykgLT4gcy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHMuc2xpY2UgMVxuXG5pbW11dGFibGVFcXVhbCA9IChvYmpBLCBvYmpCKSAtPlxuXG4gIHJldHVybiB0cnVlIGlmIG9iakEgaXMgb2JqQlxuXG4gICMgVGVzdCBmb3IgQSdzIGtleXMgZGlmZmVyZW50IGZyb20gQi5cbiAgZm9yIGtleSBvZiBvYmpBXG4gICAgaWYgb2JqQS5oYXNPd25Qcm9wZXJ0eSBrZXlcbiAgICAgIHJldHVybiBmYWxzZSB1bmxlc3Mgb2JqQi5oYXNPd25Qcm9wZXJ0eSBrZXlcblxuICAgICAgIyBpZiBvYmplY3RzIGFyZSBjdXJzb3JzLCBkZXJlZmVyZW5jZSBiZWZvcmUgY29tcGFyaW5nXG4gICAgICBpZiBvYmpBW2tleV0uZGVyZWY/XG4gICAgICAgIHJldHVybiBmYWxzZSBpZiBvYmpBW2tleV0uZGVyZWYoKSBpc250IG9iakJba2V5XS5kZXJlZigpXG4gICAgICBcbiAgICAgICNvdGhlcndpc2UgdGVzdCBmb3Igc3RyaWN0IGVxdWFsaXR5XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiBmYWxzZSBpZiBvYmpBW2tleV0gaXNudCBvYmpCW2tleV1cblxuICAjIFRlc3QgZm9yIEIncyBrZXlzIG1pc3NpbmcgZnJvbSBBLlxuICBmb3Iga2V5IG9mIG9iakJcbiAgICBpZiBvYmpCLmhhc093blByb3BlcnR5KGtleSlcbiAgICAgIHJldHVybiBmYWxzZSB1bmxlc3Mgb2JqQS5oYXNPd25Qcm9wZXJ0eShrZXkpXG4gIFxuICB0cnVlXG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IC0+XG5cbiAgbWl4aW4gPVxuICAgIHNob3VsZENvbXBvbmVudFVwZGF0ZTogKG5leHRQcm9wcywgbmV4dFN0YXRlKSAtPlxuICAgICAgIWltbXV0YWJsZUVxdWFsKEBwcm9wcywgbmV4dFByb3BzKSBvciAhaW1tdXRhYmxlRXF1YWwoQHN0YXRlLCBuZXh0U3RhdGUpXG5cbiAgZm9yIG1vZGVsIGluIGFyZ3VtZW50c1xuICAgIGRvIChtb2RlbCkgLT5cbiAgICAgIG1peGluW1widXBkYXRlI3tjYXBpdGFsaXplIG1vZGVsfVwiXSA9IChwYXRoLCB1cGRhdG9yID0gaWRlbnRpdHkpIC0+XG4gICAgICAgIGMgPSBAcHJvcHNbbW9kZWxdLmN1cnNvciBwYXRoXG4gICAgICAgICh2YWx1ZSkgLT5cbiAgICAgICAgICBjLnVwZGF0ZSAob2xkVmFsdWUpIC0+XG4gICAgICAgICAgICB1cGRhdG9yIHZhbHVlLCBvbGRWYWx1ZVxuXG4gIG1peGluXG4iLCJtb2R1bGUuZXhwb3J0cyA9XG5cbiAgZ2V0SW5pdGlhbFN0YXRlOiAtPlxuICAgIGhlaWdodDogMFxuICAgIHdpZHRoOiAwXG5cbiAgdXBkYXRlRGltZW5zaW9uczogKGUpIC0+XG4gICAgZWwgPSBAcmVmcy5jb250YWluZXIuZ2V0RE9NTm9kZSgpXG5cbiAgICBAc2V0U3RhdGVcbiAgICAgIHdpZHRoOiBlbC5jbGllbnRXaWR0aFxuICAgICAgaGVpZ2h0OiBlbC5jbGllbnRIZWlnaHRcblxuICBjb21wb25lbnREaWRNb3VudDogLT5cbiAgICBAdXBkYXRlRGltZW5zaW9ucygpXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgJ3Jlc2l6ZScsIEB1cGRhdGVEaW1lbnNpb25zXG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQ6IC0+XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIgJ3Jlc2l6ZScsIEB1cGRhdGVEaW1lbnNpb25zXG4iLCJtb2R1bGUuZXhwb3J0cyA9IFxuXG4gIGRyYWdTdGFydDogKGUpIC0+XG4gICAgQHByb3BzLnVwZGF0ZURyYWdnaW5nIHBhcnNlSW50IGUuY3VycmVudFRhcmdldC5kYXRhc2V0LmlkXG4gICAgQHByb3BzLnNlbGVjdFRyYWNrIHBhcnNlSW50IGUuY3VycmVudFRhcmdldC5kYXRhc2V0LmlkXG4gXG4gICAgZS5kYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dlZCA9ICdtb3ZlJ1xuICAgIGUuZGF0YVRyYW5zZmVyLnNldERhdGEgJ3RleHQvaHRtbCcsIG51bGxcblxuICBkcmFnRW5kOiAtPlxuICAgIEBwcm9wcy51cGRhdGVEcmFnZ2luZyBudWxsXG5cbiAgZHJhZ092ZXI6IChlKSAtPlxuICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIG92ZXIgPSBlLmN1cnJlbnRUYXJnZXRcbiAgICByZWxYID0gZS5jbGllbnRYIC0gb3Zlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0XG4gICAgcmVsWSA9IGUuY2xpZW50WSAtIG92ZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wXG4gICAgaGVpZ2h0ID0gb3Zlci5vZmZzZXRIZWlnaHQgLyAyXG4gICAgYXBwZW5kID0gcmVsWSA+IGhlaWdodFxuXG4gICAgZnJvbSA9IEBwcm9wcy5kcmFnZ2luZ1xuICAgIHRvID0gTnVtYmVyIG92ZXIuZGF0YXNldC5pZFxuICAgIHRvICs9IDEgaWYgYXBwZW5kXG4gICAgdG8gLT0gMSBpZiBmcm9tIDwgdG9cblxuICAgIHJldHVybiBpZiBmcm9tID09IHRvXG5cbiAgICBpdGVtcyA9IEBwcm9wcy5pdGVtcy5kZXJlZigpXG5cbiAgICBAcHJvcHMuaXRlbXMudXBkYXRlIChpdGVtcykgLT5cbiAgICAgIGl0ZW0gPSBpdGVtcy5nZXQgZnJvbVxuICAgICAgaXRlbXMgPSBpdGVtcy5zcGxpY2UgZnJvbSwgMVxuICAgICAgaXRlbXMgPSBpdGVtcy5zcGxpY2UgdG8sIDAsIGl0ZW1cbiAgICAgIGl0ZW1zLnRvVmVjdG9yKClcblxuICAgIEBwcm9wcy51cGRhdGVEcmFnZ2luZyB0b1xuICAgIEBwcm9wcy5zZWxlY3RUcmFjayB0b1xuXG4gIGlzRHJhZ2dpbmc6IC0+XG4gICAgQHByb3BzLmRyYWdnaW5nID09IEBwcm9wcy5pbmRleFxuIiwibW9kdWxlLmV4cG9ydHMgPVxuICBcbiAgdXBkYXRlOiAocHJvcCkgLT5cbiAgICAodmFsdWUpID0+XG4gICAgICBvYmogPSB7fVxuICAgICAgb2JqW3Byb3BdID0gdmFsdWVcbiAgICAgIEBzZXRTdGF0ZSBvYmpcblxuICB1cGRhdGVUbzogKHZhbHVlcykgLT5cbiAgICA9PiBAc2V0U3RhdGUgdmFsdWVzXG4iLCJcblxuUmVhY3QgPSByZXF1aXJlICdyZWFjdCdcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdC5jcmVhdGVDbGFzc1xuICBcbiAgcmVuZGVyOiAtPlxuICAgIFJlYWN0LkRPTS5kaXYobnVsbCwgXG4gICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcIm1vZGFsLWJhY2tkcm9wXCJ9KSwgXG4gICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcIm1vZGFsLWJvZHlcIn0sIFxuICAgICAgICAoQHByb3BzLmNoaWxkcmVuKVxuICAgICAgKVxuICAgICkiLCJcblxuUmVhY3QgPSByZXF1aXJlICdyZWFjdCdcbkNob29zZXIgPSByZXF1aXJlICcuL2Nob29zZXInXG5Lbm9iID0gcmVxdWlyZSAnLi9rbm9iJ1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0LmNyZWF0ZUNsYXNzXG5cbiAgdXBkYXRlOiAoYXR0cikgLT5cbiAgICAodmFsdWUpID0+XG4gICAgICBvc2MgPSB7fVxuICAgICAgZm9yIGssIHYgb2YgQHByb3BzLm9zY1xuICAgICAgICBvc2Nba10gPSBpZiBrID09IGF0dHIgdGhlbiB2YWx1ZSBlbHNlIHZcbiAgICAgIEBwcm9wcy5vbkNoYW5nZSBvc2NcblxuICByZW5kZXI6IC0+XG4gICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJ1aSBvc2NpbGxhdG9yXCJ9LCBcbiAgICAgIENob29zZXIoe1wib3B0aW9uc1wiOiAoWydzaW5lJywnc3F1YXJlJywnc2F3J10pLCBcInZhbHVlXCI6IChAcHJvcHMub3NjLndhdmVmb3JtKSwgXCJvbkNoYW5nZVwiOiAoQHVwZGF0ZSgnd2F2ZWZvcm0nKSl9KSwgXG4gICAgICBLbm9iKHtcImxhYmVsXCI6IFwiTGV2ZWxcIiwgXCJ2YWx1ZVwiOiAoQHByb3BzLm9zYy5sZXZlbCksIFwib25DaGFuZ2VcIjogKEB1cGRhdGUoJ2xldmVsJykpfSksIFxuICAgICAgS25vYih7XCJsYWJlbFwiOiBcIlBpdGNoXCIsIFwidmFsdWVcIjogKEBwcm9wcy5vc2MucGl0Y2gpLCBcIm9uQ2hhbmdlXCI6IChAdXBkYXRlKCdwaXRjaCcpKX0pLCAgICAgXG4gICAgICBLbm9iKHtcImxhYmVsXCI6IFwiVHVuZVwiLCBcInZhbHVlXCI6IChAcHJvcHMub3NjLnR1bmUpLCBcIm9uQ2hhbmdlXCI6IChAdXBkYXRlKCd0dW5lJykpfSksICAgICBcbiAgICAgIFJlYWN0LkRPTS5sYWJlbChudWxsLCAoQHByb3BzLmxhYmVsKSlcbiAgICApIiwiXG5cblJlYWN0ID0gcmVxdWlyZSAncmVhY3QvYWRkb25zJ1xuU2l6ZU1lYXN1cmFibGUgPSByZXF1aXJlICcuL21peGlucy9zaXplX21lYXN1cmFibGUnXG5VcGRhdGFibGUgPSByZXF1aXJlICcuL21peGlucy91cGRhdGFibGUnXG5EcmFnZ2FibGUgPSByZXF1aXJlICcuL21peGlucy9kcmFnZ2FibGUnXG5TY2FsZUhhbmRsZSA9IHJlcXVpcmUgJy4vc2NhbGVfaGFuZGxlJ1xuS2V5Ym9hcmQgPSByZXF1aXJlICcuLi91dGlsL2tleWJvYXJkJ1xuQ3Vyc29yID0gcmVxdWlyZSAnLi4vdXRpbC9jdXJzb3InXG5cbktleXMgPSByZXF1aXJlICcuL3BpYW5vX3JvbGwva2V5cydcbkdyaWRMaW5lcyA9IHJlcXVpcmUgJy4vcGlhbm9fcm9sbC9ncmlkX2xpbmVzJ1xuTm90ZXMgPSByZXF1aXJlICcuL3BpYW5vX3JvbGwvbm90ZXMnXG5QbGF5YmFja01hcmtlciA9IHJlcXVpcmUgJy4vcGlhbm9fcm9sbC9wbGF5YmFja19tYXJrZXInXG5TZWxlY3Rpb24gPSByZXF1aXJlICcuL3BpYW5vX3JvbGwvc2VsZWN0aW9uJ1xuXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3QuY3JlYXRlQ2xhc3NcbiAgXG4gIG1peGluczogW1NpemVNZWFzdXJhYmxlLCBVcGRhdGFibGUsIERyYWdnYWJsZV1cblxuICBnZXRJbml0aWFsU3RhdGU6IC0+XG4gICAgIyB4IHNjYWxlIGFuZCBzY3JvbGwgdmFsdWVzIGFyZSBpbiBiZWF0c1xuICAgICMgeSBzY2FsZSBhbmQgc2Nyb2xsIHZhbHVlcyBhcmUgaW4gaGFsZiBzdGVwc1xuICAgIFxuICAgICMgeCBhbmQgeSBzY2FsZSBhbmQgc2Nyb2xsIGFyZSBzZXQgYWZ0ZXIgY29tcG9uZW50IG1vdW50cyBiYXNlZCBvblxuICAgICMgc2VxdWVuY2UgcHJvcGVydHkgYW5kIHNpemUgb2YgZWxlbWVudCBvbiBzY3JlZW5cbiAgICB4U2NhbGU6IDFcbiAgICB5U2NhbGU6IDEyXG4gICAgeFNjcm9sbDogMFxuICAgIHlTY3JvbGw6IDBcbiAgICBcbiAgICAjIG1pbiBhbmQgbWF4IHNjYWxlcyBvZiB2aWV3cG9ydFxuICAgIG1pblhTY2FsZTogMVxuICAgIG1heFhTY2FsZTogNjRcbiAgICBtaW5ZU2NhbGU6IDEyXG4gICAgbWF4WVNjYWxlOiAxMjhcblxuICAgICMgZGlzdGFuY2UgYXJvdW5kIHRoZSBlbGVtZW50IHVzZWQgdG8gbWVhc3VyZSBzY3JvbGxpbmcsIHNob3VsZCBiZVxuICAgICMgbW9yZSB0aGFuIHRoZSBtYXhpbXVtIHBvc3NpYmxlIGRpc3RhbmNlIHRyYXZlbGxlZCBiZXR3ZWVuIHNjcm9sbCBldmVudHNcbiAgICBzY3JvbGxQYWRkaW5nOiA1MDBcblxuICAgICMgc2hvdWxkIG1hdGNoIHRoZSAkbGluZS13aWR0aCBhbmQgJG1hcmdpbiBzYXNzIHZhcmlhYmxlc1xuICAgIGxpbmVXaWR0aDogMS41XG5cbiAgICAjIHdpZHRoIG9mIGtleSBtYXJrZXJzXG4gICAga2V5V2lkdGg6IDQwXG5cbiAgICAjIG1vdmVkIG5vdGVzIHdpbGwgYmUgcXVhbnRpemVkIHRvIHRoaXMgZnJhY3Rpb24gb2YgYSBub3RlXG4gICAgcXVhbnRpemF0aW9uOiA0XG5cbiAgICAjIG1heGltdW0gd2lkdGggZnJvbSB0aGUgbGVmdC9yaWdodCBlZGdlIG9mIGEgbm90ZSB3aGVyZSBhIGRyYWcgd2lsbCByZXNpemVcbiAgICAjIHJhdGhlciB0aGFuIHRyYW5zbGF0ZSB0aGUgbm90ZVxuICAgIHJlc2l6ZUhhbmRsZVdpZHRoOiAxMFxuXG4gICAgIyBzdGF0ZSB1c2VkIGR1cmluZyBzZWxlY3Rpb24gLyByZXNpemUgLyB0cmFuc2xhdGUgYWN0aW9uc1xuICAgIHNlbGVjdGVkTm90ZXM6IFtdXG4gICAgc2VsZWN0aW9uT3JpZ2luOiBudWxsXG4gICAgc2VsZWN0aW9uUG9zaXRpb246IG51bGxcbiAgICByZXNpemVUYXJnZXQ6IG51bGxcbiAgICByZXNpemVEaXJlY3Rpb246IG51bGxcbiAgICB0cmFuc2xhdGVUYXJnZXQ6IG51bGxcblxuICBjb21wb25lbnREaWRNb3VudDogLT5cbiAgICBlbCA9IEByZWZzLmNvbnRhaW5lci5nZXRET01Ob2RlKClcbiAgICBcbiAgICBzZXRUaW1lb3V0ID0+XG4gICAgICBlbC5zY3JvbGxUb3AgPSBAc3RhdGUuc2Nyb2xsUGFkZGluZ1xuICAgICAgZWwuc2Nyb2xsTGVmdCA9IEBzdGF0ZS5zY3JvbGxQYWRkaW5nXG5cbiAgICBLZXlib2FyZC5vbiA4LCBAZGVsZXRlU2VsZWN0ZWROb3Rlc1xuICAgIEtleWJvYXJkLm9uIDM3LCBAb25BcnJvd0tleVxuICAgIEtleWJvYXJkLm9uIDM4LCBAb25BcnJvd0tleVxuICAgIEtleWJvYXJkLm9uIDM5LCBAb25BcnJvd0tleVxuICAgIEtleWJvYXJkLm9uIDQwLCBAb25BcnJvd0tleVxuXG4gICAgQHNjcm9sbERlbHRhWSA9IDBcbiAgICBAc2Nyb2xsRGVsdGFYID0gMFxuXG4gICAgQGF1dG9TY2FsZVZpZXdwb3J0IEBwcm9wcy5zZXF1ZW5jZVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50OiAtPlxuICAgIEtleWJvYXJkLm9mZiA4LCBAZGVsZXRlU2VsZWN0ZWROb3Rlc1xuICAgIEtleWJvYXJkLm9mZiAzNywgQG9uQXJyb3dLZXlcbiAgICBLZXlib2FyZC5vZmYgMzgsIEBvbkFycm93S2V5XG4gICAgS2V5Ym9hcmQub2ZmIDM5LCBAb25BcnJvd0tleVxuICAgIEtleWJvYXJkLm9mZiA0MCwgQG9uQXJyb3dLZXlcblxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiAobmV4dFByb3BzKSAtPlxuICAgIGlmIG5leHRQcm9wcy5zZXF1ZW5jZS5kZXJlZigpICE9IEBwcm9wcy5zZXF1ZW5jZS5kZXJlZigpXG4gICAgICBAYXV0b1NjYWxlVmlld3BvcnQgbmV4dFByb3BzLnNlcXVlbmNlXG5cbiAgc25hcFNjcm9sbGluZzogKGUpIC0+XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuXG4gICAgZWwgPSBlLnRhcmdldFxuICAgIHhRdWFudHVtID0gQHN0YXRlLndpZHRoIC8gQHN0YXRlLnhTY2FsZSAvIEBzdGF0ZS5xdWFudGl6YXRpb25cbiAgICB5UXVhbnR1bSA9IEBzdGF0ZS5oZWlnaHQgLyBAc3RhdGUueVNjYWxlXG4gICAgbG9vcFNpemUgPSBAcHJvcHMuc2VxdWVuY2UuZ2V0ICdsb29wU2l6ZSdcblxuICAgICMgdXBkYXRlIHNjcm9sbCBkZWx0YXNcbiAgICBAc2Nyb2xsRGVsdGFYICs9IGVsLnNjcm9sbExlZnQgLSBAc3RhdGUuc2Nyb2xsUGFkZGluZ1xuICAgIEBzY3JvbGxEZWx0YVkgKz0gQHN0YXRlLnNjcm9sbFBhZGRpbmcgLSBlbC5zY3JvbGxUb3BcbiAgICBcbiAgICAjIHByZXZlbnQgc2Nyb2xsXG4gICAgZWwuc2Nyb2xsVG9wID0gZWwuc2Nyb2xsTGVmdCA9IEBzdGF0ZS5zY3JvbGxQYWRkaW5nXG4gICAgXG4gICAgIyBnZXQgdXBkYXRlZCBzY3JvbGwgc3RhdGVcbiAgICBpZiBNYXRoLmFicyhAc2Nyb2xsRGVsdGFYKSA+IHhRdWFudHVtXG4gICAgICBxdWFudGEgPSAoaWYgQHNjcm9sbERlbHRhWCA+IDAgdGhlbiBNYXRoLmZsb29yIGVsc2UgTWF0aC5jZWlsKShAc2Nyb2xsRGVsdGFYIC8geFF1YW50dW0pXG4gICAgICBAc2Nyb2xsRGVsdGFYIC09IHF1YW50YSAqIHhRdWFudHVtXG4gICAgICB4U2Nyb2xsID0gTWF0aC5taW4gTWF0aC5tYXgoMCwgQHN0YXRlLnhTY3JvbGwgKyBxdWFudGEgLyBAc3RhdGUucXVhbnRpemF0aW9uKSwgbG9vcFNpemUgLSBAc3RhdGUueFNjYWxlXG5cbiAgICBpZiBNYXRoLmFicyhAc2Nyb2xsRGVsdGFZKSA+IHlRdWFudHVtXG4gICAgICBxdWFudGEgPSAoaWYgQHNjcm9sbERlbHRhWCA+IDAgdGhlbiBNYXRoLmZsb29yIGVsc2UgTWF0aC5jZWlsKShAc2Nyb2xsRGVsdGFZIC8geVF1YW50dW0pXG4gICAgICBAc2Nyb2xsRGVsdGFZIC09IHF1YW50YSAqIHlRdWFudHVtXG4gICAgICB5U2Nyb2xsID0gTWF0aC5taW4gTWF0aC5tYXgoMCwgQHN0YXRlLnlTY3JvbGwgKyBxdWFudGEpLCAxMjggLSBAc3RhdGUueVNjYWxlXG5cbiAgICAjIGFwcGx5IGNoYW5nZXNcbiAgICBpZiB4U2Nyb2xsPyBvciB5U2Nyb2xsP1xuICAgICAgQHNldFN0YXRlXG4gICAgICAgIHhTY3JvbGw6IGlmIHhTY3JvbGw/IHRoZW4geFNjcm9sbCBlbHNlIEBzdGF0ZS54U2Nyb2xsXG4gICAgICAgIHlTY3JvbGw6IGlmIHlTY3JvbGw/IHRoZW4geVNjcm9sbCBlbHNlIEBzdGF0ZS55U2Nyb2xsXG5cbiAgYXV0b1NjYWxlVmlld3BvcnQ6IChzZXF1ZW5jZSkgLT5cbiAgICByZXR1cm4gdW5sZXNzIHNlcXVlbmNlP1xuXG4gICAgbWluS2V5ID0gMTI4XG4gICAgbWF4S2V5ID0gMFxuXG4gICAgc2VxdWVuY2UuZ2V0KCdub3RlcycpLmZvckVhY2ggKGlkLCB7a2V5fSkgLT5cbiAgICAgIG1pbktleSA9IGtleSBpZiBrZXkgPCBtaW5LZXlcbiAgICAgIG1heEtleSA9IGtleSBpZiBrZXkgPiBtYXhLZXlcblxuICAgIHNpemUgPSBNYXRoLm1heChAc3RhdGUubWluWVNjYWxlLCBtYXhLZXkgLSBtaW5LZXkpICsgMTJcblxuICAgIEBzZXRTdGF0ZVxuICAgICAgeFNjcm9sbDogMFxuICAgICAgeFNjYWxlOiBzZXF1ZW5jZS5nZXQgJ2xvb3BTaXplJ1xuICAgICAgeVNjcm9sbDogTWF0aC5tYXggMCwgTWF0aC5jZWlsIChtaW5LZXkgKyBtYXhLZXkgLSBzaXplKSAvIDJcbiAgICAgIHlTY2FsZTogc2l6ZVxuXG4gIHVwZGF0ZUxvb3BTaXplOiAoZSkgLT5cbiAgICAjIHZhbHVlID0gcGFyc2VGbG9hdCBlLnRhcmdldC52YWx1ZVxuICAgICMgQHByb3BzLnNlcXVlbmNlLnNldCBsb29wU2l6ZTogdmFsdWVcbiAgICAjIEBzZXRTdGF0ZSB4U2NhbGU6IHZhbHVlXG5cbiAgdXBkYXRlUXVhbnRpemF0aW9uOiAoZSkgLT5cbiAgICB2YWx1ZSA9IHBhcnNlRmxvYXQgZS50YXJnZXQudmFsdWVcbiAgICBAc2V0U3RhdGUgcXVhbnRpemF0aW9uOiB2YWx1ZVxuXG4gIHVwZGF0ZVhTY2FsZTogKHNjYWxlKSAtPlxuICAgIGxvb3BTaXplID0gQHByb3BzLnNlcXVlbmNlLmdldCAnbG9vcFNpemUnXG4gICAgeFNjYWxlID0gTWF0aC5yb3VuZChzY2FsZSAqIEBzdGF0ZS5xdWFudGl6YXRpb24pIC8gQHN0YXRlLnF1YW50aXphdGlvblxuICAgIHhTY2FsZSA9IE1hdGgubWluIGxvb3BTaXplLCB4U2NhbGVcblxuICAgIHhTY3JvbGwgPSBNYXRoLm1pbiBAc3RhdGUueFNjcm9sbCwgbG9vcFNpemUgLSB4U2NhbGVcblxuICAgIEBzZXRTdGF0ZSB7eFNjYWxlLCB4U2Nyb2xsfVxuXG4gIHVwZGF0ZVlTY2FsZTogKHNjYWxlKSAtPlxuICAgIHlTY2FsZSA9IE1hdGgucm91bmQgc2NhbGVcblxuICAgIHlTY3JvbGwgPSBNYXRoLm1pbiBAc3RhdGUueVNjcm9sbCwgMTI4IC0gQHN0YXRlLnlTY2FsZVxuXG4gICAgQHNldFN0YXRlIHt5U2NhbGUsIHlTY3JvbGx9XG5cblxuICAjISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISFcbiAgIyB0aGlzIHNob3VsZCBiZSByZWZhY3RvcmVkIHRvICd1cGRhdGVOb3RlczogKGlkcywgZGVsdGEpIC0+JyBzbyB0aGF0IG5vdGVzXG4gICMgY2FuIG1vdmUgYXMgZmFyIGFzIHBvc3NpYmxlIHdoZW4geW91IGF0dGVtcHQgdG8gbW92ZSBhbiBvY3RhdmUgbmVhciB0aGUgZWRnZVxuICAjISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISFcblxuICB1cGRhdGVOb3RlczogKGNoYW5nZXMpIC0+XG4gICAgIyBub3RlcyA9IE9iamVjdC5rZXlzKGNoYW5nZXMpLm1hcCAoaSkgPT5cbiAgICAjICAga2V5OiBpZiBjaGFuZ2VzW2ldLmtleT8gdGhlbiBjaGFuZ2VzW2ldLmtleSBlbHNlIEBzdGF0ZS5ub3Rlc1tpXS5rZXlcbiAgICAjICAgc3RhcnQ6IGlmIGNoYW5nZXNbaV0uc3RhcnQ/IHRoZW4gY2hhbmdlc1tpXS5zdGFydCBlbHNlIEBzdGF0ZS5ub3Rlc1tpXS5zdGFydFxuICAgICMgICBsZW5ndGg6IGlmIGNoYW5nZXNbaV0ubGVuZ3RoPyB0aGVuIGNoYW5nZXNbaV0ubGVuZ3RoIGVsc2UgQHN0YXRlLm5vdGVzW2ldLmxlbmd0aFxuXG4gICAgIyBrZXlzID0gbm90ZXMubWFwIChub3RlKSAtPiBub3RlLmtleVxuICAgICMgc3RhcnRzID0gbm90ZXMubWFwIChub3RlKSAtPiBub3RlLnN0YXJ0XG4gICAgIyBlbmRzID0gbm90ZXMubWFwIChub3RlKSAtPiBub3RlLnN0YXJ0ICsgbm90ZS5sZW5ndGhcblxuICAgICMgbWluS2V5ID0gTWF0aC5taW4uYXBwbHkgbnVsbCwga2V5c1xuICAgICMgbWF4S2V5ID0gTWF0aC5tYXguYXBwbHkgbnVsbCwga2V5c1xuICAgICMgbWluU3RhcnQgPSBNYXRoLm1pbi5hcHBseSBudWxsLCBzdGFydHNcbiAgICAjIG1heEVuZCA9IE1hdGgubWF4LmFwcGx5IG51bGwsIGVuZHNcblxuICAgICMgIyBwcmV2ZW50IG5vdGVzIGZyb20gYmVpbmcgbW92ZWQgb3V0IG9mIHRoZSBhdmFpbGFibGUgcmFuZ2VcblxuICAgICMgcmV0dXJuIGZhbHNlIGlmIG1pbktleSA8IDAgb3IgbWF4S2V5ID4gMTI3XG4gICAgIyByZXR1cm4gZmFsc2UgaWYgbWluU3RhcnQgPCAwIG9yIG1heEVuZCA+IEBzdGF0ZS5sb29wU2l6ZVxuXG4gICAgIyAjIHVwZGF0ZSBzY3JvbGwgc28gbm90ZXMgcmVtYWluIG9uIHNjcmVlblxuXG4gICAgIyBzdGF0ZUNoYW5nZXMgPSB7fVxuXG4gICAgIyBpZiBtaW5LZXkgPCBAc3RhdGUueVNjcm9sbCBhbmQgbWF4S2V5IDw9IEBzdGF0ZS55U2Nyb2xsICsgQHN0YXRlLnlTY2FsZVxuICAgICMgICBzdGF0ZUNoYW5nZXMueVNjcm9sbCA9IG1pbktleVxuXG4gICAgIyBpZiBtYXhLZXkgPj0gQHN0YXRlLnlTY3JvbGwgKyBAc3RhdGUueVNjYWxlIGFuZCBtaW5LZXkgPiBAc3RhdGUueVNjcm9sbFxuICAgICMgICBzdGF0ZUNoYW5nZXMueVNjcm9sbCA9IG1heEtleSAtIEBzdGF0ZS55U2NhbGUgKyAxXG5cbiAgICAjIGlmIG1pblN0YXJ0IDwgQHN0YXRlLnhTY3JvbGwgYW5kIG1heEVuZCA8PSBAc3RhdGUueFNjcm9sbCArIEBzdGF0ZS54U2NhbGVcbiAgICAjICAgc3RhdGVDaGFuZ2VzLnhTY3JvbGwgPSBtaW5TdGFydFxuXG4gICAgIyBpZiBtYXhFbmQgPj0gQHN0YXRlLnhTY3JvbGwgKyBAc3RhdGUueFNjYWxlIGFuZCBtaW5TdGFydCA+IEBzdGF0ZS54U2Nyb2xsXG4gICAgIyAgIHN0YXRlQ2hhbmdlcy54U2Nyb2xsID0gbWF4RW5kIC0gQHN0YXRlLnhTY2FsZVxuXG4gICAgIyBAcHJvcHMuc2VxdWVuY2UudXBkYXRlTm90ZXMgY2hhbmdlc1xuICAgICMgQHNldFN0YXRlIHN0YXRlQ2hhbmdlc1xuXG4gIGdldFJlbGF0aXZlUG9zaXRpb246ICh7eCx5fSkgLT5cbiAgICB7dG9wLCBsZWZ0fSA9IEByZWZzLmdyaWQuZ2V0RE9NTm9kZSgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgaGVpZ2h0ID0gQHN0YXRlLmhlaWdodFxuICAgIHdpZHRoID0gQHN0YXRlLndpZHRoIC0gQHN0YXRlLmtleVdpZHRoXG5cbiAgICBrZXkgPSBNYXRoLmZsb29yKChoZWlnaHQgLSB5ICsgdG9wKSAvIGhlaWdodCAqIEBzdGF0ZS55U2NhbGUpICsgQHN0YXRlLnlTY3JvbGxcbiAgICBzdGFydCA9IE1hdGguZmxvb3IoKHggLSBsZWZ0KSAvIHdpZHRoICogQHN0YXRlLnhTY2FsZSAqIEBzdGF0ZS5xdWFudGl6YXRpb24pIC8gQHN0YXRlLnF1YW50aXphdGlvbiArIEBzdGF0ZS54U2Nyb2xsXG5cbiAgICB7a2V5LCBzdGFydH1cblxuICBkZWxldGVTZWxlY3RlZE5vdGVzOiAtPlxuICAgIEBwcm9wcy5zZXF1ZW5jZS5yZW1vdmVOb3RlcyBAc3RhdGUuc2VsZWN0ZWROb3Rlc1xuXG4gIG5vdGVzU2VsZWN0ZWRCeTogKGZyb20sIHRvKSAtPlxuICAgIG1pbktleSA9IE1hdGgubWluIGZyb20ua2V5LCB0by5rZXlcbiAgICBtYXhLZXkgPSBNYXRoLm1heCBmcm9tLmtleSwgdG8ua2V5XG4gICAgbWluRW5kID0gTWF0aC5taW4gZnJvbS5zdGFydCwgdG8uc3RhcnRcbiAgICBtYXhTdGFydCA9IE1hdGgubWF4IGZyb20uc3RhcnQsIHRvLnN0YXJ0XG5cbiAgICBub3RlcyA9IFtdXG4gICAgQHByb3BzLnNlcXVlbmNlLmdldCgnbm90ZXMnKS5mb3JFYWNoIChpZCwgbm90ZSkgLT5cbiAgICAgIG5vdGVzLnB1c2ggcGFyc2VJbnQgaWQgaWYgKFxuICAgICAgICBub3RlLmtleSA+PSBtaW5LZXkgYW5kXG4gICAgICAgIG5vdGUua2V5IDw9IG1heEtleSBhbmRcbiAgICAgICAgbm90ZS5zdGFydCArIG5vdGUubGVuZ3RoID4gbWluRW5kIGFuZFxuICAgICAgICBub3RlLnN0YXJ0IDw9IG1heFN0YXJ0XG4gICAgICApXG5cbiAgICBub3Rlc1xuXG4gIG9uQ2xpY2tLZXlzOiAoZSkgLT5cblxuICAjIGRlc2VsZWN0IGFueSBzZWxlY3RlZCBub3RlcyxcbiAgIyBzdGFydCBkcmFnIHNlbGVjdGlvblxuICBvbk1vdXNlRG93bkdyaWQ6IChlKSAtPlxuICAgIEBzZXRTdGF0ZSBzZWxlY3RlZE5vdGVzOiBbXSB1bmxlc3MgS2V5Ym9hcmQucHJlc3NlZFsxNl1cblxuICAgICMgaGFuZGxlIGRyYWcgc3RhcnQgXG4gICAgQGRyYWdnYWJsZU9uTW91c2VEb3duIGVcbiAgICBAc2V0U3RhdGUgc2VsZWN0aW9uT3JpZ2luOiBAZ2V0UmVsYXRpdmVQb3NpdGlvbiB7eDogZS5jbGllbnRYLCB5OiBlLmNsaWVudFl9XG5cbiAgIyBhZGQgYSBuZXcgbm90ZVxuICBvbkRvdWJsZUNsaWNrR3JpZDogKGUpIC0+XG4gICAge2tleSwgc3RhcnR9ID0gQGdldFJlbGF0aXZlUG9zaXRpb24geDogZS5jbGllbnRYLCB5OiBlLmNsaWVudFlcbiAgICBub3RlID0ge2tleSwgc3RhcnQsIGxlbmd0aDogMSAvIEBzdGF0ZS5xdWFudGl6YXRpb259XG4gICAgIyBAcHJvcHMuc2VxdWVuY2UuYWRkTm90ZSBub3RlXG5cbiAgIyBjaGFuZ2UgY3Vyc29yIHRvIGluZGljYXRlIHBvc3NpYmxlIGFjdGlvblxuICBvbk1vdXNlTW92ZU5vdGU6IChlKSAtPlxuICAgIHBvc2l0aW9uID0gZS50YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcblxuICAgIGhhbmRsZVNpemUgPSBNYXRoLm1heCAwLCBNYXRoLm1pbiBAc3RhdGUucmVzaXplSGFuZGxlV2lkdGgsIChwb3NpdGlvbi53aWR0aCAtIEBzdGF0ZS5yZXNpemVIYW5kbGVXaWR0aCkgLyAyXG5cbiAgICBpZiBwb3NpdGlvbi5sZWZ0ID4gZS5jbGllbnRYIC0gaGFuZGxlU2l6ZVxuICAgICAgQG5vdGVIb3ZlckN1cnNvciA9IEN1cnNvci5zZXQgJ3ctcmVzaXplJywgMSwgQG5vdGVIb3ZlckN1cnNvclxuICAgIGVsc2UgaWYgcG9zaXRpb24ucmlnaHQgPCBlLmNsaWVudFggKyBoYW5kbGVTaXplXG4gICAgICBAbm90ZUhvdmVyQ3Vyc29yID0gQ3Vyc29yLnNldCAnZS1yZXNpemUnLCAxLCBAbm90ZUhvdmVyQ3Vyc29yXG4gICAgZWxzZVxuICAgICAgQ3Vyc29yLmNsZWFyIEBub3RlSG92ZXJDdXJzb3JcblxuICBvbk1vdXNlT3V0Tm90ZTogKGUpIC0+XG4gICAgQ3Vyc29yLmNsZWFyIEBub3RlSG92ZXJDdXJzb3JcblxuICBvbk1vdXNlRG93bk5vdGU6IChlKSAtPlxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICBpZCA9IHBhcnNlSW50IGUudGFyZ2V0LmRhdGFzZXQuaWRcbiAgICBwb3NpdGlvbiA9IGUudGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG5cbiAgICAjIGhhbmRsZSBub3RlIHNlbGVjdGlvblxuICAgIGlmIEtleWJvYXJkLnByZXNzZWRbMTZdXG4gICAgICBzZWxlY3RlZE5vdGVzID0gQHN0YXRlLnNlbGVjdGVkTm90ZXMuc2xpY2UgMFxuICAgICAgaWYgaWQgaW4gQHN0YXRlLnNlbGVjdGVkTm90ZXNcbiAgICAgICAgc2VsZWN0ZWROb3Rlcy5zcGxpY2Ugc2VsZWN0ZWROb3Rlcy5pbmRleE9mKGlkKSwgMVxuICAgICAgZWxzZVxuICAgICAgICBzZWxlY3RlZE5vdGVzLnB1c2ggaWRcbiAgICBlbHNlXG4gICAgICB1bmxlc3MgaWQgaW4gQHN0YXRlLnNlbGVjdGVkTm90ZXNcbiAgICAgICAgc2VsZWN0ZWROb3RlcyA9IFtpZF1cbiAgICAgIGVsc2VcbiAgICAgICAgc2VsZWN0ZWROb3RlcyA9IEBzdGF0ZS5zZWxlY3RlZE5vdGVzXG5cbiAgICBzdGF0ZUNoYW5nZXMgPSB7c2VsZWN0ZWROb3Rlc31cblxuICAgICMgaGFuZGxlIGRyYWcgc3RhcnRcbiAgICBAZHJhZ2dhYmxlT25Nb3VzZURvd24gZVxuXG4gICAgIyBjYWNoZSBvcmlnaW5hbCB2YWx1ZXMgb2Ygc2VsZWN0ZWQgbm90ZXNcbiAgICBAb3JpZ2luYWxWYWx1ZSA9IEBwcm9wcy5zZXF1ZW5jZS5nZXQoJ25vdGVzJykuZmlsdGVyIChub3RlLCBpZCkgLT5cbiAgICAgIHNlbGVjdGVkTm90ZXMuaW5kZXhPZihpZCkgPj0gMFxuXG4gICAgQGRyYWdPcmlnaW4gPSBAcHJvcHMuc2VxdWVuY2UuZ2V0SW4gWydub3RlcycsIGlkXVxuXG4gICAgaGFuZGxlU2l6ZSA9IE1hdGgubWF4IDAsIE1hdGgubWluIEBzdGF0ZS5yZXNpemVIYW5kbGVXaWR0aCwgKHBvc2l0aW9uLndpZHRoIC0gQHN0YXRlLnJlc2l6ZUhhbmRsZVdpZHRoKSAvIDJcblxuICAgICMgaGFuZGxlIHJlc2l6ZVxuICAgIGlmIHBvc2l0aW9uLmxlZnQgPiBlLmNsaWVudFggLSBoYW5kbGVTaXplXG4gICAgICBzdGF0ZUNoYW5nZXMucmVzaXplVGFyZ2V0ID0gaWRcbiAgICAgIHN0YXRlQ2hhbmdlcy5yZXNpemVEaXJlY3Rpb24gPSAnbGVmdCdcbiAgICAgIEBkcmFnQWN0aW9uQ3Vyc29yID0gQ3Vyc29yLnNldCAndy1yZXNpemUnLCAyLCBAZHJhZ0FjdGlvbkN1cnNvclxuICAgIGVsc2UgaWYgcG9zaXRpb24ucmlnaHQgPCBlLmNsaWVudFggKyBoYW5kbGVTaXplXG4gICAgICBzdGF0ZUNoYW5nZXMucmVzaXplVGFyZ2V0ID0gaWRcbiAgICAgIHN0YXRlQ2hhbmdlcy5yZXNpemVEaXJlY3Rpb24gPSAncmlnaHQnXG4gICAgICBAZHJhZ0FjdGlvbkN1cnNvciA9IEN1cnNvci5zZXQgJ2UtcmVzaXplJywgMiwgQGRyYWdBY3Rpb25DdXJzb3JcbiAgICAjIGhhbmRsZSB0cmFuc2xhdGVcbiAgICBlbHNlIFxuICAgICAgc3RhdGVDaGFuZ2VzLnRyYW5zbGF0ZVRhcmdldCA9IGlkXG4gICAgICBAZHJhZ0FjdGlvbkN1cnNvciA9IEN1cnNvci5zZXQgJ21vdmUnLCAyLCBAZHJhZ0FjdGlvbkN1cnNvclxuXG4gICAgIyBhcHBseSBzdGF0ZSBjaGFuZ2VzXG4gICAgQHNldFN0YXRlIHN0YXRlQ2hhbmdlc1xuXG4gICMgcmVtb3ZlIHRoZSBkb3VibGUgY2xpY2tlZCBub3RlXG4gIG9uRG91YmxlQ2xpY2tOb3RlOiAoZSkgLT5cbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG4gICAgQHByb3BzLnNlcXVlbmNlLnJlbW92ZU5vdGUgZS50YXJnZXQuZGF0YXNldC5pZFxuXG4gIG9uRHJhZzogKGRlbHRhLCBlKSAtPlxuXG4gICAgcG9zaXRpb24gPSBAZ2V0UmVsYXRpdmVQb3NpdGlvbiB4OiBlLmNsaWVudFgsIHk6IGUuY2xpZW50WVxuXG4gICAgIyBoYW5kbGUgZHJhZyBzZWxlY3Rpb25cbiAgICBpZiBAc3RhdGUuc2VsZWN0aW9uT3JpZ2luP1xuICAgICAgQHNldFN0YXRlIHNlbGVjdGlvblBvc2l0aW9uOiBwb3NpdGlvblxuICAgIFxuICAgIGVsc2UgXG4gICAgICBrZXlEZWx0YSA9IHBvc2l0aW9uLmtleSAtIEBkcmFnT3JpZ2luLmtleVxuICAgICAgc3RhcnREZWx0YSA9IHBvc2l0aW9uLnN0YXJ0IC0gQGRyYWdPcmlnaW4uc3RhcnRcbiAgICAgIG5vdGVzID0ge31cblxuICAgICAgIyBoYW5kbGUgdHJhbnNsYXRpb24gb2Ygbm90ZXNcbiAgICAgIGlmIEBzdGF0ZS50cmFuc2xhdGVUYXJnZXQ/XG4gICAgICAgIGZvciBpLCBub3RlIG9mIEBvcmlnaW5hbFZhbHVlXG4gICAgICAgICAgbm90ZXNbaV0gPVxuICAgICAgICAgICAga2V5OiBub3RlLmtleSArIGtleURlbHRhXG4gICAgICAgICAgICBzdGFydDogbm90ZS5zdGFydCArIHN0YXJ0RGVsdGFcblxuICAgICAgIyBoYW5kbGUgcmVzaXplIG9mIG5vdGVzXG4gICAgICBpZiBAc3RhdGUucmVzaXplVGFyZ2V0P1xuICAgICAgICBtaW5MZW5ndGggPSAxIC8gQHN0YXRlLnF1YW50aXphdGlvblxuXG4gICAgICAgIGlmIEBzdGF0ZS5yZXNpemVEaXJlY3Rpb24gPT0gJ3JpZ2h0J1xuICAgICAgICAgIGZvciBpLCBub3RlIG9mIEBvcmlnaW5hbFZhbHVlXG4gICAgICAgICAgICBub3Rlc1tpXSA9IGxlbmd0aDogTWF0aC5tYXggbWluTGVuZ3RoLCBub3RlLmxlbmd0aCArIHN0YXJ0RGVsdGEgLSBAZHJhZ09yaWdpbi5sZW5ndGggKyBtaW5MZW5ndGhcblxuICAgICAgICBpZiBAc3RhdGUucmVzaXplRGlyZWN0aW9uID09ICdsZWZ0J1xuICAgICAgICAgIGZvciBpLCBub3RlIG9mIEBvcmlnaW5hbFZhbHVlXG4gICAgICAgICAgICBzdGFydCA9IG5vdGUuc3RhcnQgKyBzdGFydERlbHRhXG4gICAgICAgICAgICBzdGFydCA9IE1hdGgubWF4IDAsIHN0YXJ0XG4gICAgICAgICAgICBzdGFydCA9IE1hdGgubWluIHN0YXJ0LCBub3RlLnN0YXJ0ICsgbm90ZS5sZW5ndGggLSBtaW5MZW5ndGhcbiAgICAgICAgICAgIG5vdGVzW2ldID1cbiAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0XG4gICAgICAgICAgICAgIGxlbmd0aDogbm90ZS5zdGFydCArIG5vdGUubGVuZ3RoIC0gc3RhcnRcblxuICAgICAgQHVwZGF0ZU5vdGVzIG5vdGVzXG5cblxuICBvbkRyYWdFbmQ6IChlKSAtPlxuICAgICMgaWYgdGhlIGFsdCBrZXkgaXMgaGVsZCwgY29weSBub3Rlc1xuICAgIEBwcm9wcy5zZXF1ZW5jZS5hZGROb3RlcyBAb3JpZ2luYWxWYWx1ZSBpZiBAb3JpZ2luYWxWYWx1ZT8gYW5kIEtleWJvYXJkLnByZXNzZWRbMThdXG5cbiAgICBjaGFuZ2VzID1cbiAgICAgIHRyYW5zbGF0ZVRhcmdldDogbnVsbFxuICAgICAgcmVzaXplVGFyZ2V0OiBudWxsXG4gICAgICByZXNpemVEaXJlY3Rpb246IG51bGxcbiAgICAgIHNlbGVjdGlvbk9yaWdpbjogbnVsbFxuICAgICAgc2VsZWN0aW9uUG9zaXRpb246IG51bGxcblxuICAgICMgaGFuZGxlIGRyYWcgc2VsZWN0XG4gICAgaWYgQHN0YXRlLnNlbGVjdGlvbk9yaWdpbj9cbiAgICAgIHBvc2l0aW9uID0gQGdldFJlbGF0aXZlUG9zaXRpb24geDogZS5jbGllbnRYLCB5OiBlLmNsaWVudFlcbiAgICAgIHNlbGVjdGVkTm90ZXMgPSBAbm90ZXNTZWxlY3RlZEJ5IEBzdGF0ZS5zZWxlY3Rpb25PcmlnaW4sIHBvc2l0aW9uXG4gICAgICBzZWxlY3RlZE5vdGVzID0gQHN0YXRlLnNlbGVjdGVkTm90ZXMuc2xpY2UoMCkuY29uY2F0IHNlbGVjdGVkTm90ZXMgaWYgS2V5Ym9hcmQucHJlc3NlZFsxNl1cbiAgICAgIGNoYW5nZXMuc2VsZWN0ZWROb3RlcyA9IHNlbGVjdGVkTm90ZXNcblxuICAgIEBzZXRTdGF0ZSBjaGFuZ2VzXG5cbiAgICBAb3JpZ2luYWxWYWx1ZSA9IG51bGxcbiAgICBAZHJhZ09yaWdpbiA9IG51bGxcblxuICAgIEN1cnNvci5jbGVhciBAZHJhZ0FjdGlvbkN1cnNvclxuXG5cbiAgb25BcnJvd0tleTogKGUpIC0+XG4gICAgY2hhbmdlcyA9IHt9XG5cbiAgICBmb3IgaWQgaW4gQHN0YXRlLnNlbGVjdGVkTm90ZXNcblxuICAgICAgbm90ZSA9IEBzdGF0ZS5ub3Rlc1tpZF1cblxuICAgICAgIyBsZWZ0IGFycm93XG4gICAgICBpZiBlLmtleUNvZGUgaXMgMzdcbiAgICAgICAgY2hhbmdlc1tpZF0gPSBzdGFydDogbm90ZS5zdGFydCAtIDEgLyBAc3RhdGUucXVhbnRpemF0aW9uXG5cbiAgICAgICMgdXAgYXJyb3dcbiAgICAgIGVsc2UgaWYgZS5rZXlDb2RlIGlzIDM4XG4gICAgICAgIGRpc3RhbmNlID0gaWYgS2V5Ym9hcmQucHJlc3NlZFsxNl0gdGhlbiAxMiBlbHNlIDFcbiAgICAgICAgY2hhbmdlc1tpZF0gPSBrZXk6IG5vdGUua2V5ICsgZGlzdGFuY2VcblxuICAgICAgIyByaWdodCBhcnJvd1xuICAgICAgZWxzZSBpZiBlLmtleUNvZGUgaXMgMzlcbiAgICAgICAgY2hhbmdlc1tpZF0gPSBzdGFydDogbm90ZS5zdGFydCArIDEgLyBAc3RhdGUucXVhbnRpemF0aW9uXG5cbiAgICAgICMgZG93biBhcnJvd1xuICAgICAgZWxzZSBpZiBlLmtleUNvZGUgaXMgNDBcbiAgICAgICAgZGlzdGFuY2UgPSBpZiBLZXlib2FyZC5wcmVzc2VkWzE2XSB0aGVuIDEyIGVsc2UgMVxuICAgICAgICBjaGFuZ2VzW2lkXSA9IGtleTogbm90ZS5rZXkgLSBkaXN0YW5jZVxuXG4gICAgQHVwZGF0ZU5vdGVzIGNoYW5nZXNcblxuICByZW5kZXI6IC0+XG4gICAgb3V0ZXJTdHlsZSA9XG4gICAgICB3aWR0aDogQHN0YXRlLndpZHRoICsgMiAqIEBzdGF0ZS5zY3JvbGxQYWRkaW5nXG4gICAgICBoZWlnaHQ6IEBzdGF0ZS5oZWlnaHQgKyAyICogQHN0YXRlLnNjcm9sbFBhZGRpbmdcblxuICAgIGlubmVyU3R5bGUgPVxuICAgICAgdG9wOiBAc3RhdGUuc2Nyb2xsUGFkZGluZ1xuICAgICAgbGVmdDogQHN0YXRlLnNjcm9sbFBhZGRpbmdcblxuICAgIGdyaWRXaWR0aCA9IE1hdGgubWF4IDAsIEBzdGF0ZS53aWR0aCAtIEBzdGF0ZS5rZXlXaWR0aFxuXG4gICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJ1aSBwaWFuby1yb2xsXCJ9LCBcbiAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwiYm9keVwiLCBcInJlZlwiOiAnY29udGFpbmVyJywgXCJvblNjcm9sbFwiOiAoQHNuYXBTY3JvbGxpbmcpfSwgXG4gICAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwib3V0ZXJcIiwgXCJzdHlsZVwiOiAob3V0ZXJTdHlsZSl9LCBcbiAgICAgICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcImlubmVyXCIsIFwic3R5bGVcIjogKGlubmVyU3R5bGUpfSwgXG4gICAgICAgICAgICBLZXlzKHsgXFxcbiAgICAgICAgICAgICAgXCJ3aWR0aFwiOiAoQHN0YXRlLmtleVdpZHRoIC0gQHN0YXRlLmxpbmVXaWR0aCksICBcXFxuICAgICAgICAgICAgICBcImhlaWdodFwiOiAoQHN0YXRlLmhlaWdodCksICBcXFxuICAgICAgICAgICAgICBcInlTY3JvbGxcIjogKEBzdGF0ZS55U2Nyb2xsKSwgIFxcXG4gICAgICAgICAgICAgIFwieVNjYWxlXCI6IChAc3RhdGUueVNjYWxlKSwgIFxcXG4gICAgICAgICAgICAgIFwia2V5V2lkdGhcIjogKEBzdGF0ZS5rZXlXaWR0aCksICBcXFxuICAgICAgICAgICAgICBcIm9uQ2xpY2tcIjogKEBvbkNsaWNrS2V5cylcbiAgICAgICAgICAgIH0pLCBcbiAgICAgICAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6ICdncmlkJywgXCJyZWZcIjogJ2dyaWQnfSwgXG4gICAgICAgICAgICAgIFJlYWN0LkRPTS5zdmcoeyBcXFxuICAgICAgICAgICAgICAgIFwid2lkdGhcIjogKGdyaWRXaWR0aCksICBcXFxuICAgICAgICAgICAgICAgIFwiaGVpZ2h0XCI6IChAc3RhdGUuaGVpZ2h0KSwgIFxcXG4gICAgICAgICAgICAgICAgXCJvbk1vdXNlRG93blwiOiAoQG9uTW91c2VEb3duR3JpZCksICBcXFxuICAgICAgICAgICAgICAgIFwib25Nb3VzZVVwXCI6IChAb25Nb3VzZVVwR3JpZCksICBcXFxuICAgICAgICAgICAgICAgIFwib25Eb3VibGVDbGlja1wiOiAoQG9uRG91YmxlQ2xpY2tHcmlkKVxuICAgICAgICAgICAgICB9LCBcbiAgICAgICAgICAgICAgICBHcmlkTGluZXMoeyBcXFxuICAgICAgICAgICAgICAgICAgXCJ3aWR0aFwiOiAoZ3JpZFdpZHRoKSwgIFxcXG4gICAgICAgICAgICAgICAgICBcImhlaWdodFwiOiAoQHN0YXRlLmhlaWdodCksICBcXFxuICAgICAgICAgICAgICAgICAgXCJ5U2NhbGVcIjogKEBzdGF0ZS55U2NhbGUpLCAgXFxcbiAgICAgICAgICAgICAgICAgIFwieFNjYWxlXCI6IChAc3RhdGUueFNjYWxlKSwgIFxcXG4gICAgICAgICAgICAgICAgICBcInlTY3JvbGxcIjogKEBzdGF0ZS55U2Nyb2xsKSwgIFxcXG4gICAgICAgICAgICAgICAgICBcInhTY3JvbGxcIjogKEBzdGF0ZS54U2Nyb2xsKSwgIFxcXG4gICAgICAgICAgICAgICAgICBcInF1YW50aXphdGlvblwiOiAoQHN0YXRlLnF1YW50aXphdGlvbilcbiAgICAgICAgICAgICAgICB9KSwgXG4gICAgICAgICAgICAgICAgUGxheWJhY2tNYXJrZXIoeyBcXFxuICAgICAgICAgICAgICAgICAgXCJwb3NpdGlvblwiOiAoQHByb3BzLnNvbmcuZ2V0ICdwb3NpdGlvbicpLCAgXFxcbiAgICAgICAgICAgICAgICAgIFwibG9vcFNpemVcIjogKEBwcm9wcy5zZXF1ZW5jZS5nZXQgJ2xvb3BTaXplJyksICBcXFxuICAgICAgICAgICAgICAgICAgXCJ3aWR0aFwiOiAoZ3JpZFdpZHRoKSwgIFxcXG4gICAgICAgICAgICAgICAgICBcImhlaWdodFwiOiAoQHN0YXRlLmhlaWdodCksICBcXFxuICAgICAgICAgICAgICAgICAgXCJ4U2Nyb2xsXCI6IChAc3RhdGUueFNjcm9sbCksICBcXFxuICAgICAgICAgICAgICAgICAgXCJ4U2NhbGVcIjogKEBzdGF0ZS54U2NhbGUpLCAgXFxcbiAgICAgICAgICAgICAgICAgIFwicXVhbnRpemF0aW9uXCI6IChAc3RhdGUucXVhbnRpemF0aW9uKVxuICAgICAgICAgICAgICAgIH0pLCBcbiAgICAgICAgICAgICAgICBTZWxlY3Rpb24oeyBcXFxuICAgICAgICAgICAgICAgICAgXCJzZWxlY3Rpb25PcmlnaW5cIjogKEBzdGF0ZS5zZWxlY3Rpb25PcmlnaW4pLCAgXFxcbiAgICAgICAgICAgICAgICAgIFwic2VsZWN0aW9uUG9zaXRpb25cIjogKEBzdGF0ZS5zZWxlY3Rpb25Qb3NpdGlvbiksICBcXFxuICAgICAgICAgICAgICAgICAgXCJ3aWR0aFwiOiAoZ3JpZFdpZHRoKSwgIFxcXG4gICAgICAgICAgICAgICAgICBcImhlaWdodFwiOiAoQHN0YXRlLmhlaWdodCksICBcXFxuICAgICAgICAgICAgICAgICAgXCJ5U2NhbGVcIjogKEBzdGF0ZS55U2NhbGUpLCAgXFxcbiAgICAgICAgICAgICAgICAgIFwieFNjYWxlXCI6IChAc3RhdGUueFNjYWxlKSwgIFxcXG4gICAgICAgICAgICAgICAgICBcInlTY3JvbGxcIjogKEBzdGF0ZS55U2Nyb2xsKSwgIFxcXG4gICAgICAgICAgICAgICAgICBcInhTY3JvbGxcIjogKEBzdGF0ZS54U2Nyb2xsKSwgIFxcXG4gICAgICAgICAgICAgICAgICBcInF1YW50aXphdGlvblwiOiAoQHN0YXRlLnF1YW50aXphdGlvbilcbiAgICAgICAgICAgICAgICB9KSwgXG4gICAgICAgICAgICAgICAgTm90ZXMoeyBcXFxuICAgICAgICAgICAgICAgICAgXCJub3Rlc1wiOiAoQHByb3BzLnNlcXVlbmNlLmdldCAnbm90ZXMnKSwgIFxcXG4gICAgICAgICAgICAgICAgICBcInNlbGVjdGVkTm90ZXNcIjogKEBzdGF0ZS5zZWxlY3RlZE5vdGVzKSwgIFxcXG4gICAgICAgICAgICAgICAgICBcImRyYWdPcmlnaW5hbFZhbHVlXCI6IChAb3JpZ2luYWxWYWx1ZSksICBcXFxuICAgICAgICAgICAgICAgICAgXCJ0cmFuc2xhdGVUYXJnZXRcIjogKEBzdGF0ZS50cmFuc2xhdGVUYXJnZXQpLCAgXFxcbiAgICAgICAgICAgICAgICAgIFwicmVzaXplVGFyZ2V0XCI6IChAc3RhdGUucmVzaXplVGFyZ2V0KSwgIFxcXG4gICAgICAgICAgICAgICAgICBcIndpZHRoXCI6IChncmlkV2lkdGgpLCAgXFxcbiAgICAgICAgICAgICAgICAgIFwiaGVpZ2h0XCI6IChAc3RhdGUuaGVpZ2h0KSwgIFxcXG4gICAgICAgICAgICAgICAgICBcInlTY2FsZVwiOiAoQHN0YXRlLnlTY2FsZSksICBcXFxuICAgICAgICAgICAgICAgICAgXCJ4U2NhbGVcIjogKEBzdGF0ZS54U2NhbGUpLCAgXFxcbiAgICAgICAgICAgICAgICAgIFwieVNjcm9sbFwiOiAoQHN0YXRlLnlTY3JvbGwpLCAgXFxcbiAgICAgICAgICAgICAgICAgIFwieFNjcm9sbFwiOiAoQHN0YXRlLnhTY3JvbGwpLCAgXFxcbiAgICAgICAgICAgICAgICAgIFwibGluZVdpZHRoXCI6IChAc3RhdGUubGluZVdpZHRoKSwgIFxcXG4gICAgICAgICAgICAgICAgICBcInF1YW50aXphdGlvblwiOiAoQHN0YXRlLnF1YW50aXphdGlvbiksICBcXFxuICAgICAgICAgICAgICAgICAgXCJvbk1vdXNlRG93blwiOiAoQG9uTW91c2VEb3duTm90ZSksICBcXFxuICAgICAgICAgICAgICAgICAgXCJvbk1vdXNlTW92ZVwiOiAoQG9uTW91c2VNb3ZlTm90ZSksICBcXFxuICAgICAgICAgICAgICAgICAgXCJvbk1vdXNlT3V0XCI6IChAb25Nb3VzZU91dE5vdGUpLCAgXFxcbiAgICAgICAgICAgICAgICAgIFwib25Eb3VibGVDbGlja1wiOiAoQG9uRG91YmxlQ2xpY2tOb3RlKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgICksIFxuICAgICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJ2aWV3LWNvbnRyb2xzXCJ9LCBcbiAgICAgICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJzZXR0aW5nXCJ9LCBcbiAgICAgICAgICBSZWFjdC5ET00ubGFiZWwobnVsbCwgXCJHcmlkXCIpLCBcbiAgICAgICAgICBSZWFjdC5ET00uc2VsZWN0KHtcInZhbHVlXCI6IChAc3RhdGUucXVhbnRpemF0aW9uKSwgXCJvbkNoYW5nZVwiOiAoQHVwZGF0ZVF1YW50aXphdGlvbil9LCBcbiAgICAgICAgICAgIFJlYWN0LkRPTS5vcHRpb24oe1widmFsdWVcIjogXCIxXCJ9LCBcIjFcIiksIFxuICAgICAgICAgICAgUmVhY3QuRE9NLm9wdGlvbih7XCJ2YWx1ZVwiOiBcIjJcIn0sIFwiMVxceDJGMlwiKSwgXG4gICAgICAgICAgICBSZWFjdC5ET00ub3B0aW9uKHtcInZhbHVlXCI6IFwiM1wifSwgXCIxXFx4MkYzXCIpLCBcbiAgICAgICAgICAgIFJlYWN0LkRPTS5vcHRpb24oe1widmFsdWVcIjogXCI0XCJ9LCBcIjFcXHgyRjRcIiksIFxuICAgICAgICAgICAgUmVhY3QuRE9NLm9wdGlvbih7XCJ2YWx1ZVwiOiBcIjZcIn0sIFwiMVxceDJGNlwiKSwgXG4gICAgICAgICAgICBSZWFjdC5ET00ub3B0aW9uKHtcInZhbHVlXCI6IFwiOFwifSwgXCIxXFx4MkY4XCIpLCBcbiAgICAgICAgICAgIFJlYWN0LkRPTS5vcHRpb24oe1widmFsdWVcIjogXCIxMlwifSwgXCIxXFx4MkYxMlwiKSwgXG4gICAgICAgICAgICBSZWFjdC5ET00ub3B0aW9uKHtcInZhbHVlXCI6IFwiMTZcIn0sIFwiMVxceDJGMTZcIilcbiAgICAgICAgICApXG4gICAgICAgICksIFxuICAgICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcInNldHRpbmdcIn0sIFxuICAgICAgICAgIFJlYWN0LkRPTS5sYWJlbChudWxsLCBcIkxlbmd0aFwiKSwgXG4gICAgICAgICAgUmVhY3QuRE9NLnNlbGVjdCh7XCJ2YWx1ZVwiOiAoQHByb3BzLnNlcXVlbmNlLmdldCAnbG9vcFNpemUnKSwgXCJvbkNoYW5nZVwiOiAoQHVwZGF0ZUxvb3BTaXplKX0sIFxuICAgICAgICAgICAgUmVhY3QuRE9NLm9wdGlvbih7XCJ2YWx1ZVwiOiBcIjFcIn0sIFwiMVwiKSwgXG4gICAgICAgICAgICBSZWFjdC5ET00ub3B0aW9uKHtcInZhbHVlXCI6IFwiMlwifSwgXCIyXCIpLCBcbiAgICAgICAgICAgIFJlYWN0LkRPTS5vcHRpb24oe1widmFsdWVcIjogXCI0XCJ9LCBcIjRcIiksIFxuICAgICAgICAgICAgUmVhY3QuRE9NLm9wdGlvbih7XCJ2YWx1ZVwiOiBcIjhcIn0sIFwiOFwiKSwgXG4gICAgICAgICAgICBSZWFjdC5ET00ub3B0aW9uKHtcInZhbHVlXCI6IFwiMTZcIn0sIFwiMTZcIiksIFxuICAgICAgICAgICAgUmVhY3QuRE9NLm9wdGlvbih7XCJ2YWx1ZVwiOiBcIjMyXCJ9LCBcIjMyXCIpLCBcbiAgICAgICAgICAgIFJlYWN0LkRPTS5vcHRpb24oe1widmFsdWVcIjogXCI2NFwifSwgXCI2NFwiKVxuICAgICAgICAgIClcbiAgICAgICAgKSwgXG4gICAgICAgIFNjYWxlSGFuZGxlKHtcIm1pblwiOiAoQHN0YXRlLm1pbllTY2FsZSksIFwibWF4XCI6IChAc3RhdGUubWF4WVNjYWxlKSwgXCJ2YWx1ZVwiOiAoQHN0YXRlLnlTY2FsZSksIFwib25DaGFuZ2VcIjogKEB1cGRhdGVZU2NhbGUpfSwgXG4gICAgICAgICAgUmVhY3QuRE9NLnNwYW4oe1wiY2xhc3NOYW1lXCI6IFwiaWNvbiBpY29uLWFycm93LXVwXCJ9KSwgXG4gICAgICAgICAgUmVhY3QuRE9NLnNwYW4oe1wiY2xhc3NOYW1lXCI6IFwiaWNvbiBpY29uLWFycm93LWRvd25cIn0pXG4gICAgICAgICksIFxuICAgICAgICBTY2FsZUhhbmRsZSh7XCJtaW5cIjogKEBzdGF0ZS5taW5YU2NhbGUpLCBcIm1heFwiOiAoQHN0YXRlLm1heFhTY2FsZSksIFwidmFsdWVcIjogKEBzdGF0ZS54U2NhbGUpLCBcIm9uQ2hhbmdlXCI6IChAdXBkYXRlWFNjYWxlKX0sIFxuICAgICAgICAgIFJlYWN0LkRPTS5zcGFuKHtcImNsYXNzTmFtZVwiOiBcImljb24gaWNvbi1hcnJvdy1sZWZ0XCJ9KSwgXG4gICAgICAgICAgUmVhY3QuRE9NLnNwYW4oe1wiY2xhc3NOYW1lXCI6IFwiaWNvbiBpY29uLWFycm93LXJpZ2h0XCJ9KVxuICAgICAgICApXG4gICAgICApXG4gICAgKVxuIiwiUmVhY3QgPSByZXF1aXJlICdyZWFjdC9hZGRvbnMnXG5cbmtleVBhdHRlcm4gPSBbdHJ1ZSwgZmFsc2UsIHRydWUsIGZhbHNlLCB0cnVlLCB0cnVlLCBmYWxzZSwgdHJ1ZSwgZmFsc2UsIHRydWUsIGZhbHNlLCB0cnVlXVxuXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3QuY3JlYXRlQ2xhc3NcblxuICBtaXhpbnM6IFtSZWFjdC5hZGRvbnMuUHVyZVJlbmRlck1peGluXVxuXG4gIHByb3BUeXBlczpcbiAgICB3aWR0aDogUmVhY3QuUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkXG4gICAgaGVpZ2h0OiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWRcbiAgICB5U2NhbGU6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZFxuICAgIHhTY2FsZTogUmVhY3QuUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkXG4gICAgeVNjcm9sbDogUmVhY3QuUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkXG4gICAgeFNjcm9sbDogUmVhY3QuUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkXG4gICAgcXVhbnRpemF0aW9uOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWRcblxuICByZW5kZXI6IC0+XG4gICAgd2lkdGggPSBAcHJvcHMud2lkdGhcbiAgICBoZWlnaHQgPSBAcHJvcHMuaGVpZ2h0XG4gICAgc3F1YXJlSGVpZ2h0ID0gaGVpZ2h0IC8gQHByb3BzLnlTY2FsZVxuICAgIHF1YW50aXphdGlvbiA9IEBwcm9wcy5xdWFudGl6YXRpb25cbiAgICBjb2xzID0gQHByb3BzLnhTY2FsZSAqIHF1YW50aXphdGlvblxuICAgIHNxdWFyZVdpZHRoID0gd2lkdGggLyBjb2xzXG5cbiAgICBlbHMgPSBbXVxuXG4gICAgbWluUm93ID0gQHByb3BzLnlTY3JvbGxcbiAgICBtYXhSb3cgPSBtaW5Sb3cgKyBAcHJvcHMueVNjYWxlXG4gICAgcm93cyA9IFttaW5Sb3cuLi5tYXhSb3ddXG4gICAgXG4gICAgbWluQ29sID0gQHByb3BzLnhTY3JvbGwgKiBxdWFudGl6YXRpb25cbiAgICBtYXhDb2wgPSBtaW5Db2wgKyBAcHJvcHMueFNjYWxlICogcXVhbnRpemF0aW9uXG4gICAgY29scyA9IFttaW5Db2wuLi5tYXhDb2xdXG5cbiAgICAjIHJvdyBzaGFkaW5nXG4gICAgZm9yIHJvdywgaSBpbiByb3dzXG4gICAgICB1bmxlc3Mga2V5UGF0dGVybltyb3cgJSAxMl1cbiAgICAgICAgeSA9IGhlaWdodCAtIChpICsgMSkgKiBzcXVhcmVIZWlnaHRcbiAgICAgICAgZWxzLnB1c2ggUmVhY3QuRE9NLnJlY3Qoe1wia2V5XCI6ICgncycraSksIFwieFwiOiAoMCksIFwieVwiOiAoeSksIFwid2lkdGhcIjogKHdpZHRoKSwgXCJoZWlnaHRcIjogKHNxdWFyZUhlaWdodCksIFwiY2xhc3NOYW1lXCI6ICdzaGFkZSd9KVxuXG4gICAgIyBob3Jpem9udGFsIGxpbmVzIChzZXBhcmF0aW5nIGUgYW5kIGYpXG4gICAgZm9yIHJvdywgaSBpbiByb3dzXG4gICAgICBpZiByb3cgJSAxMiA9PSA1XG4gICAgICAgIHkgPSAocm93cy5sZW5ndGggLSBpKSAqIHNxdWFyZUhlaWdodFxuICAgICAgICBlbHMucHVzaCBSZWFjdC5ET00ubGluZSh7XCJrZXlcIjogKCdoJytpKSwgXCJ4MVwiOiAoMCksIFwieTFcIjogKHkpLCBcIngyXCI6ICh3aWR0aCksIFwieTJcIjogKHkpfSlcblxuICAgICMgdmVydGljYWwgbGluZXNcbiAgICBmb3IgY29sLCBpIGluIGNvbHNcbiAgICAgIHVubGVzcyBjb2wgJSBxdWFudGl6YXRpb24gPT0gMFxuICAgICAgICB4ID0gaSAqIHNxdWFyZVdpZHRoXG4gICAgICAgIGVscy5wdXNoIFJlYWN0LkRPTS5saW5lKHtcImtleVwiOiAoJ3YnK2kpLCBcIngxXCI6ICh4KSwgXCJ5MVwiOiAoMCksIFwieDJcIjogKHgpLCBcInkyXCI6IChoZWlnaHQpfSlcblxuICAgICMgc3Ryb25nIGhvcml6b250YWwgbGluZXMgKHNlcGFyYXRpbmcgYiBhbmQgYylcbiAgICBmb3Igcm93LCBpIGluIHJvd3NcbiAgICAgIGlmIHJvdyAlIDEyID09IDBcbiAgICAgICAgeSA9IChyb3dzLmxlbmd0aCAtIGkpICogc3F1YXJlSGVpZ2h0XG4gICAgICAgIGVscy5wdXNoIFJlYWN0LkRPTS5saW5lKHtcImtleVwiOiAoJ2hzJytpKSwgXCJ4MVwiOiAoMCksIFwieTFcIjogKHkpLCBcIngyXCI6ICh3aWR0aCksIFwieTJcIjogKHkpLCBcImNsYXNzTmFtZVwiOiAnc3Ryb25nJ30pXG5cbiAgICAjIHN0cm9uZyB2ZXJ0aWNhbCBsaW5lc1xuICAgIGZvciBjb2wsIGkgaW4gY29sc1xuICAgICAgaWYgaSAhPSAwIGFuZCBjb2wgJSBxdWFudGl6YXRpb24gPT0gMFxuICAgICAgICB4ID0gaSAqIHNxdWFyZVdpZHRoXG4gICAgICAgIGVscy5wdXNoIFJlYWN0LkRPTS5saW5lKHtcImtleVwiOiAoJ3ZzJytpKSwgXCJ4MVwiOiAoeCksIFwieTFcIjogKDApLCBcIngyXCI6ICh4KSwgXCJ5MlwiOiAoaGVpZ2h0KSwgXCJjbGFzc05hbWVcIjogJ3N0cm9uZyd9KVxuXG4gICAgUmVhY3QuRE9NLmcobnVsbCwgKGVscykpXG5cbiIsIlJlYWN0ID0gcmVxdWlyZSAncmVhY3QvYWRkb25zJ1xuXG5rZXlQYXR0ZXJuID0gW3RydWUsIGZhbHNlLCB0cnVlLCBmYWxzZSwgdHJ1ZSwgdHJ1ZSwgZmFsc2UsIHRydWUsIGZhbHNlLCB0cnVlLCBmYWxzZSwgdHJ1ZV1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0LmNyZWF0ZUNsYXNzXG4gIFxuICBtaXhpbnM6IFtSZWFjdC5hZGRvbnMuUHVyZVJlbmRlck1peGluXVxuXG4gIHByb3BUeXBlczpcbiAgICBoZWlnaHQ6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZFxuICAgIHlTY3JvbGw6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZFxuICAgIHlTY2FsZTogUmVhY3QuUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkXG4gICAga2V5V2lkdGg6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZFxuXG4gIHJlbmRlcjogLT5cbiAgICBoZWlnaHQgPSBAcHJvcHMuaGVpZ2h0XG4gICAga2V5SGVpZ2h0ID0gaGVpZ2h0IC8gQHByb3BzLnlTY2FsZVxuICAgIGtleVdpZHRoID0gQHByb3BzLmtleVdpZHRoXG5cbiAgICBlbHMgPSBbXVxuXG4gICAgbWluUm93ID0gQHByb3BzLnlTY3JvbGxcbiAgICBtYXhSb3cgPSBtaW5Sb3cgKyBAcHJvcHMueVNjYWxlXG4gICAgcm93cyA9IFttaW5Sb3cuLi5tYXhSb3ddXG5cbiAgICAjIGtleXNcbiAgICBmb3Igcm93LCBpIGluIHJvd3NcbiAgICAgIHVubGVzcyBrZXlQYXR0ZXJuW3JvdyAlIDEyXVxuICAgICAgICB5ID0gaGVpZ2h0IC0gKGkgKyAxKSAqIGtleUhlaWdodFxuICAgICAgICB0ZXh0ID0gbnVsbFxuICAgICAgICBlbHMucHVzaCBSZWFjdC5ET00ucmVjdCh7XCJrZXlcIjogKCdrJyArIGkpLCBcInhcIjogKDApLCBcInlcIjogKHkpLCBcIndpZHRoXCI6IChrZXlXaWR0aCksIFwiaGVpZ2h0XCI6IChrZXlIZWlnaHQpfSlcblxuICAgICMgIyBsaW5lc1xuICAgICMgZm9yIHJvdywgaSBpbiByb3dzXG4gICAgIyAgIHkgPSBpICoga2V5SGVpZ2h0XG4gICAgIyAgIGVscy5wdXNoIDxsaW5lIGtleT17J2wnICsgaX0geDE9ezB9IHkxPXt5fSB4Mj17a2V5V2lkdGh9IHkyPXt5fS8+XG5cbiAgICAjIHRleHRcbiAgICBmb3Igcm93LCBpIGluIHJvd3NcbiAgICAgIGlmIHJvdyAlIDEyID09IDBcbiAgICAgICAgeSA9IGhlaWdodCAtIChpICsgMC41KSAqIGtleUhlaWdodFxuICAgICAgICB0ZXh0ID0gXCJDICN7TWF0aC5mbG9vcihyb3cgLyAxMikgLSAyfVwiXG4gICAgICAgIGVscy5wdXNoIFJlYWN0LkRPTS50ZXh0KHtcImtleVwiOiAoJ3QnICsgaSksIFwieFwiOiAoa2V5V2lkdGggLSA0KSwgXCJ5XCI6ICh5KX0sICh0ZXh0KSlcblxuICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6ICdrZXlzJ30sIFxuICAgICAgUmVhY3QuRE9NLnN2Zyh7XCJ3aWR0aFwiOiAoa2V5V2lkdGgpLCBcImhlaWdodFwiOiAoaGVpZ2h0KSwgXCJvbkNsaWNrXCI6IChAcHJvcHMub25DbGljayl9LCBcbiAgICAgICAgKGVscylcbiAgICAgIClcbiAgICApXG4iLCJSZWFjdCA9IHJlcXVpcmUgJ3JlYWN0L2FkZG9ucydcbktleWJvYXJkID0gcmVxdWlyZSAnLi4vLi4vdXRpbC9rZXlib2FyZCdcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0LmNyZWF0ZUNsYXNzXG5cbiAgbWl4aW5zOiBbUmVhY3QuYWRkb25zLlB1cmVSZW5kZXJNaXhpbl1cblxuICBnZXREZWZhdWx0UHJvcHM6IC0+XG4gICAgcmFkaXVzOiAwXG5cbiAgcHJvcFR5cGVzOlxuICAgIG5vdGVzOiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWRcbiAgICBzZWxlY3RlZE5vdGVzOiBSZWFjdC5Qcm9wVHlwZXMuYXJyYXkuaXNSZXF1aXJlZFxuICAgIGRyYWdPcmlnaW5hbFZhbHVlOiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0XG4gICAgdHJhbnNsYXRlVGFyZ2V0OiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyXG4gICAgcmVzaXplVGFyZ2V0OiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyXG4gICAgd2lkdGg6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZFxuICAgIGhlaWdodDogUmVhY3QuUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkXG4gICAgbGluZVdpZHRoOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWRcbiAgICB5U2NhbGU6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZFxuICAgIHhTY2FsZTogUmVhY3QuUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkXG4gICAgeVNjcm9sbDogUmVhY3QuUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkXG4gICAgeFNjcm9sbDogUmVhY3QuUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkXG4gICAgcXVhbnRpemF0aW9uOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWRcbiAgICBvbk1vdXNlRG93bjogUmVhY3QuUHJvcFR5cGVzLmZ1bmNcbiAgICBvbk1vdXNlTW92ZTogUmVhY3QuUHJvcFR5cGVzLmZ1bmNcbiAgICBvbk1vdXNlT3V0OiBSZWFjdC5Qcm9wVHlwZXMuZnVuY1xuICAgIG9uQ2xpY2s6IFJlYWN0LlByb3BUeXBlcy5mdW5jXG4gICAgb25Eb3VibGVDbGljazogUmVhY3QuUHJvcFR5cGVzLmZ1bmNcblxuICBub3RlT25TY3JlZW46IChub3RlKSAtPlxuICAgIG5vdGUuc3RhcnQgPD0gQHByb3BzLnhTY3JvbGwgKyBAcHJvcHMueFNjYWxlIGFuZFxuICAgIG5vdGUuc3RhcnQgKyBub3RlLmxlbmd0aCA+PSBAcHJvcHMueFNjcm9sbCBhbmRcbiAgICBub3RlLmtleSA+PSBAcHJvcHMueVNjcm9sbCBhbmRcbiAgICBub3RlLmtleSA8PSBAcHJvcHMueVNjcm9sbCArIEBwcm9wcy55U2NhbGVcblxuICByZW5kZXI6IC0+XG4gICAgcmV0dXJuIFJlYWN0LkRPTS5nKG51bGwpIHVubGVzcyBAcHJvcHMud2lkdGggPiAwIGFuZCBAcHJvcHMuaGVpZ2h0ID4gMFxuXG4gICAgd2lkdGggPSBAcHJvcHMud2lkdGhcbiAgICBoZWlnaHQgPSBAcHJvcHMuaGVpZ2h0XG4gICAgbGluZVdpZHRoID0gQHByb3BzLmxpbmVXaWR0aFxuICAgIHNxdWFyZUhlaWdodCA9IGhlaWdodCAvIEBwcm9wcy55U2NhbGVcbiAgICBxdWFudGl6YXRpb24gPSBAcHJvcHMucXVhbnRpemF0aW9uXG4gICAgY29scyA9IEBwcm9wcy54U2NhbGUgKiBxdWFudGl6YXRpb25cbiAgICBzcXVhcmVXaWR0aCA9IHdpZHRoIC8gY29sc1xuXG4gICAgZWxzID0gW11cblxuICAgIG1pblJvdyA9IEBwcm9wcy55U2Nyb2xsXG4gICAgbWF4Um93ID0gbWluUm93ICsgQHByb3BzLnlTY2FsZVxuICAgIHJvd3MgPSBbbWluUm93Li4ubWF4Um93XVxuICAgIFxuICAgIG1pbkNvbCA9IEBwcm9wcy54U2Nyb2xsICogcXVhbnRpemF0aW9uXG4gICAgbWF4Q29sID0gbWluQ29sICsgQHByb3BzLnhTY2FsZSAqIHF1YW50aXphdGlvblxuICAgIGNvbHMgPSBbbWluQ29sLi4ubWF4Q29sXVxuXG4gICAgIyBnaG9zdCBub3Rlc1xuICAgIGlmIEBwcm9wcy50cmFuc2xhdGVUYXJnZXQ/IGFuZCBLZXlib2FyZC5wcmVzc2VkWzE4XVxuICAgICAgZm9yIGlkLCBub3RlIG9mIEBwcm9wcy5kcmFnT3JpZ2luYWxWYWx1ZVxuICAgICAgICBjb250aW51ZSB1bmxlc3MgQG5vdGVPblNjcmVlbiBub3RlXG5cbiAgICAgICAgeCA9IChub3RlLnN0YXJ0IC0gQHByb3BzLnhTY3JvbGwpICogc3F1YXJlV2lkdGggKiBxdWFudGl6YXRpb24gKyBsaW5lV2lkdGggLyAyXG4gICAgICAgIHkgPSAoQHByb3BzLnlTY2FsZSArIEBwcm9wcy55U2Nyb2xsIC0gbm90ZS5rZXkgLSAxKSAqIHNxdWFyZUhlaWdodCArIGxpbmVXaWR0aCAvIDJcbiAgICAgICAgdyA9IHNxdWFyZVdpZHRoICogbm90ZS5sZW5ndGggKiBAcHJvcHMucXVhbnRpemF0aW9uIC0gQHByb3BzLmxpbmVXaWR0aFxuICAgICAgICBoID0gc3F1YXJlSGVpZ2h0IC0gQHByb3BzLmxpbmVXaWR0aFxuXG4gICAgICAgIGVscy5wdXNoKFxuICAgICAgICAgIFJlYWN0LkRPTS5yZWN0KHsgXFxcbiAgICAgICAgICAgIFwiY2xhc3NOYW1lXCI6IFwiZ2hvc3Qgbm90ZVwiLCAgXFxcbiAgICAgICAgICAgIFwia2V5XCI6ICgnZycgKyBpZCksICBcXFxuICAgICAgICAgICAgXCJ4XCI6ICh4KSwgIFxcXG4gICAgICAgICAgICBcInlcIjogKHkpLCAgXFxcbiAgICAgICAgICAgIFwid2lkdGhcIjogKHcpLCAgXFxcbiAgICAgICAgICAgIFwiaGVpZ2h0XCI6IChoKSwgIFxcXG4gICAgICAgICAgICBcInJ4XCI6IChAcHJvcHMucmFkaXVzKSwgIFxcXG4gICAgICAgICAgICBcInJ5XCI6IChAcHJvcHMucmFkaXVzKVxuICAgICAgICAgIH0pXG4gICAgICAgIClcblxuICAgICMgbm90ZXNcbiAgICBAcHJvcHMubm90ZXMuZm9yRWFjaCAoaWQsIG5vdGUpID0+XG4gICAgICByZXR1cm4gdW5sZXNzIEBub3RlT25TY3JlZW4gbm90ZVxuXG4gICAgICB4ID0gKG5vdGUuc3RhcnQgLSBAcHJvcHMueFNjcm9sbCkgKiBzcXVhcmVXaWR0aCAqIEBwcm9wcy5xdWFudGl6YXRpb24gKyBsaW5lV2lkdGggLyAyXG4gICAgICB5ID0gKEBwcm9wcy55U2NhbGUgKyBAcHJvcHMueVNjcm9sbCAtIG5vdGUua2V5IC0gMSkgKiBzcXVhcmVIZWlnaHQgKyBsaW5lV2lkdGggLyAyXG4gICAgICB3ID0gc3F1YXJlV2lkdGggKiBub3RlLmxlbmd0aCAqIEBwcm9wcy5xdWFudGl6YXRpb24gLSBsaW5lV2lkdGhcbiAgICAgIGggPSBzcXVhcmVIZWlnaHQgLSBsaW5lV2lkdGhcblxuICAgICAgY2xhc3NOYW1lID0gJ25vdGUnXG4gICAgICBjbGFzc05hbWUgKz0gJyBzZWxlY3RlZCcgaWYgbm90ZS5pZCBpbiBAcHJvcHMuc2VsZWN0ZWROb3Rlc1xuICAgICAgY2xhc3NOYW1lICs9ICcgYWN0aXZlJyBpZiBAcHJvcHMudHJhbnNsYXRlVGFyZ2V0ID09IG5vdGUuaWQgb3IgQHByb3BzLnJlc2l6ZVRhcmdldCA9PSBub3RlLmlkXG5cbiAgICAgIGVscy5wdXNoKFxuICAgICAgICBSZWFjdC5ET00ucmVjdCh7IFxcXG4gICAgICAgICAgXCJjbGFzc05hbWVcIjogKGNsYXNzTmFtZSksICBcXFxuICAgICAgICAgIFwia2V5XCI6ICgnbicgKyBpZCksICBcXFxuICAgICAgICAgIFwieFwiOiAoeCksICBcXFxuICAgICAgICAgIFwieVwiOiAoeSksICBcXFxuICAgICAgICAgIFwid2lkdGhcIjogKHcpLCAgXFxcbiAgICAgICAgICBcImhlaWdodFwiOiAoaCksICBcXFxuICAgICAgICAgIFwicnhcIjogKEBwcm9wcy5yYWRpdXMpLCAgXFxcbiAgICAgICAgICBcInJ5XCI6IChAcHJvcHMucmFkaXVzKSwgIFxcXG4gICAgICAgICAgXCJkYXRhLWlkXCI6IChpZCksICBcXFxuICAgICAgICAgIFwib25Nb3VzZURvd25cIjogKEBwcm9wcy5vbk1vdXNlRG93biksICBcXFxuICAgICAgICAgIFwib25Nb3VzZU1vdmVcIjogKEBwcm9wcy5vbk1vdXNlTW92ZSksICBcXFxuICAgICAgICAgIFwib25Nb3VzZU91dFwiOiAoQHByb3BzLm9uTW91c2VPdXQpLCAgXFxcbiAgICAgICAgICBcIm9uQ2xpY2tcIjogKEBwcm9wcy5vbkNsaWNrKSwgIFxcXG4gICAgICAgICAgXCJvbkRvdWJsZUNsaWNrXCI6IChAcHJvcHMub25Eb3VibGVDbGljaylcbiAgICAgICAgfSlcbiAgICAgIClcblxuICAgIFJlYWN0LkRPTS5nKG51bGwsIChlbHMpKSIsIlJlYWN0ID0gcmVxdWlyZSAncmVhY3QvYWRkb25zJ1xuXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3QuY3JlYXRlQ2xhc3NcblxuICBtaXhpbnM6IFtSZWFjdC5hZGRvbnMuUHVyZVJlbmRlck1peGluXVxuXG4gIHByb3BUeXBlczpcbiAgICBwb3NpdGlvbjogUmVhY3QuUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkXG4gICAgbG9vcFNpemU6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZFxuICAgIHdpZHRoOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWRcbiAgICBoZWlnaHQ6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZFxuICAgIHhTY2FsZTogUmVhY3QuUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkXG4gICAgeFNjcm9sbDogUmVhY3QuUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkXG4gICAgcXVhbnRpemF0aW9uOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWRcblxuICByZW5kZXI6IC0+XG4gICAgd2lkdGggPSBAcHJvcHMud2lkdGhcbiAgICBoZWlnaHQgPSBAcHJvcHMuaGVpZ2h0XG4gICAgcG9zaXRpb24gPSBAcHJvcHMucG9zaXRpb24gJSBAcHJvcHMubG9vcFNpemVcbiAgICBjb2xzID0gQHByb3BzLnhTY2FsZSAqIEBwcm9wcy5xdWFudGl6YXRpb25cbiAgICBzcXVhcmVXaWR0aCA9IHdpZHRoIC8gY29sc1xuXG4gICAgaWYgcG9zaXRpb24gPj0gQHByb3BzLnhTY3JvbGwgYW5kIHBvc2l0aW9uIDw9IEBwcm9wcy54U2Nyb2xsICsgQHByb3BzLnhTY2FsZVxuICAgICAgeCA9IE1hdGguZmxvb3IocG9zaXRpb24gKiBAcHJvcHMucXVhbnRpemF0aW9uKSAqIHNxdWFyZVdpZHRoXG4gICAgICB1bmxlc3MgeCA8PSAwXG4gICAgICAgIGVsID0gUmVhY3QuRE9NLmxpbmUoe1wia2V5XCI6ICdwYicsIFwieDFcIjogKHgpLCBcInkxXCI6ICgwKSwgXCJ4MlwiOiAoeCksIFwieTJcIjogKGhlaWdodCl9KVxuICAgIFxuICAgIFJlYWN0LkRPTS5nKHtcImNsYXNzTmFtZVwiOiBcInBsYXliYWNrXCJ9LCAoZWwpKVxuIiwiUmVhY3QgPSByZXF1aXJlICdyZWFjdC9hZGRvbnMnXG5cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdC5jcmVhdGVDbGFzc1xuICBcbiAgbWl4aW5zOiBbUmVhY3QuYWRkb25zLlB1cmVSZW5kZXJNaXhpbl1cblxuICBwcm9wVHlwZXM6XG4gICAgc2VsZWN0aW9uT3JpZ2luOiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0XG4gICAgc2VsZWN0aW9uUG9zaXRpb246IFJlYWN0LlByb3BUeXBlcy5vYmplY3RcbiAgICB3aWR0aDogUmVhY3QuUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkXG4gICAgaGVpZ2h0OiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWRcbiAgICB5U2NhbGU6IFJlYWN0LlByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZFxuICAgIHhTY2FsZTogUmVhY3QuUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkXG4gICAgeVNjcm9sbDogUmVhY3QuUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkXG4gICAgeFNjcm9sbDogUmVhY3QuUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkXG4gICAgcXVhbnRpemF0aW9uOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWRcblxuICByZW5kZXI6IC0+XG4gICAgd2lkdGggPSBAcHJvcHMud2lkdGhcbiAgICBoZWlnaHQgPSBAcHJvcHMuaGVpZ2h0XG4gICAgc2VsZWN0aW9uT3JpZ2luID0gQHByb3BzLnNlbGVjdGlvbk9yaWdpblxuICAgIHNlbGVjdGlvblBvc2l0aW9uID0gQHByb3BzLnNlbGVjdGlvblBvc2l0aW9uXG4gICAgc3F1YXJlSGVpZ2h0ID0gaGVpZ2h0IC8gQHByb3BzLnlTY2FsZVxuICAgIHF1YW50aXphdGlvbiA9IEBwcm9wcy5xdWFudGl6YXRpb25cbiAgICBjb2xzID0gQHByb3BzLnhTY2FsZSAqIHF1YW50aXphdGlvblxuICAgIHNxdWFyZVdpZHRoID0gd2lkdGggLyBjb2xzXG5cbiAgICBpZiBzZWxlY3Rpb25PcmlnaW4/IGFuZCBzZWxlY3Rpb25Qb3NpdGlvbj9cbiAgICAgIGZyb21LZXkgPSBNYXRoLm1heCBzZWxlY3Rpb25PcmlnaW4ua2V5LCBzZWxlY3Rpb25Qb3NpdGlvbi5rZXlcbiAgICAgIGtleVdpZHRoID0gTWF0aC5hYnMgc2VsZWN0aW9uT3JpZ2luLmtleSAtIHNlbGVjdGlvblBvc2l0aW9uLmtleVxuICAgICAgZnJvbUJlYXQgPSAgTWF0aC5taW4gc2VsZWN0aW9uT3JpZ2luLnN0YXJ0LCBzZWxlY3Rpb25Qb3NpdGlvbi5zdGFydFxuICAgICAgYmVhdFdpZHRoID0gTWF0aC5hYnMgc2VsZWN0aW9uT3JpZ2luLnN0YXJ0IC0gc2VsZWN0aW9uUG9zaXRpb24uc3RhcnRcbiAgICAgIHggPSAoZnJvbUJlYXQgLSBAcHJvcHMueFNjcm9sbCkgKiBxdWFudGl6YXRpb24gKiBzcXVhcmVXaWR0aFxuICAgICAgeSA9IChAcHJvcHMueVNjYWxlICsgQHByb3BzLnlTY3JvbGwgLSBmcm9tS2V5IC0gMSkgKiBzcXVhcmVIZWlnaHRcbiAgICAgIHcgPSAoYmVhdFdpZHRoICogcXVhbnRpemF0aW9uICsgMSkgKiBzcXVhcmVXaWR0aFxuICAgICAgaCA9IChrZXlXaWR0aCArIDEpICogc3F1YXJlSGVpZ2h0XG4gICAgICBlbCA9IFJlYWN0LkRPTS5yZWN0KHtcImNsYXNzTmFtZVwiOiAnc2VsZWN0aW9uJywgXCJrZXlcIjogJ3NlbCcsIFwieFwiOiAoeCksIFwieVwiOiAoeSksIFwid2lkdGhcIjogKHcpLCBcImhlaWdodFwiOiAoaCl9KVxuXG4gICAgUmVhY3QuRE9NLmcobnVsbCwgKGVsKSkiLCJcblxuUmVhY3QgPSByZXF1aXJlICdyZWFjdCdcbk1vZGVsYWJsZSA9IHJlcXVpcmUgJy4vbWl4aW5zL21vZGVsYWJsZSdcblNjYWxlSGFuZGxlID0gcmVxdWlyZSAnLi9zY2FsZV9oYW5kbGUnXG5LZXlib2FyZCA9IHJlcXVpcmUgJy4uL3V0aWwva2V5Ym9hcmQnXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3QuY3JlYXRlQ2xhc3NcblxuICBjb21wb25lbnREaWRNb3VudDogLT5cbiAgICBLZXlib2FyZC5vbiAzMiwgQHBsYXlcblxuICBjb21wb25lbnRXaWxsVW5tb3VudDogLT5cbiAgICBLZXlib2FyZC5vZmYgMzIsIEBwbGF5XG5cbiAgcGxheTogLT5cbiAgICAjIGlmIEBwcm9wcy5zb25nLmdldCAncGxheWluZydcbiAgICAjICAgQHByb3BzLnNvbmcucGF1c2UoKVxuICAgICMgZWxzZVxuICAgICMgICBAcHJvcHMuc29uZy5wbGF5KClcblxuICBvbkNoYW5nZUJwbTogKGUpIC0+XG4gICAgIyBicG0gPSBwYXJzZUludCBlLnRhcmdldC52YWx1ZVxuICAgICMgQHByb3BzLnNvbmcuc2V0IHticG19XG5cbiAgc3RvcFByb3BhZ2F0aW9uOiAoZSkgLT5cbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG5cbiAgcmVuZGVyOiAtPlxuICAgIHNvbmcgPSBAcHJvcHMuc29uZ1xuXG4gICAgcGxheUNsYXNzTmFtZSA9ICdpY29uIGljb24tcGxheScgKyBpZiBzb25nLmdldCgncGxheWluZycpIHRoZW4gJyBhY3RpdmUnIGVsc2UgJydcbiAgICBcbiAgICBicG1PcHRpb25zID0gKFJlYWN0LkRPTS5vcHRpb24oe1wia2V5XCI6IChpKSwgXCJ2YWx1ZVwiOiAoaSl9LCAoaSksIFwiIGJwbVwiKSBmb3IgaSBpbiBbMjAwLi4yMF0pXG5cbiAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcInVpIHBsYXliYWNrLWNvbnRyb2xcIn0sIFxuICAgICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJncm91cCBwbGF5YmFja1wifSwgXG4gICAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IChwbGF5Q2xhc3NOYW1lKSwgXCJvbkNsaWNrXCI6ICgtPil9KSwgXG4gICAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwiaWNvbiBpY29uLXJlY29yZFwifSksIFxuICAgICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcImljb24gaWNvbi1zdG9wXCIsIFwib25DbGlja1wiOiAoLT4pfSlcbiAgICAgICksIFxuICAgICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJncm91cCB0ZW1wb1wifSwgXG4gICAgICAgIFJlYWN0LkRPTS5zZWxlY3Qoe1widmFsdWVcIjogKHNvbmcuZ2V0ICdicG0nKSwgXCJvbkNoYW5nZVwiOiAoLT4pfSwgKGJwbU9wdGlvbnMpKVxuICAgICAgKSwgXG4gICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcImxvZ29cIn0sIFwic2luZXNhd1wiKSwgXG4gICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcImdyb3VwIG1lbnVcIn0sIFxuICAgICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcImljb24gaWNvbi1haXJcIn0pXG4gICAgICApXG4gICAgKVxuIiwiXG5cblJlYWN0ID0gcmVxdWlyZSAncmVhY3QvYWRkb25zJ1xuTW9kZWxhYmxlID0gcmVxdWlyZSAnLi9taXhpbnMvbW9kZWxhYmxlJ1xuUmVjb3JkaW5nID0gcmVxdWlyZSAnLi4vbW9kZWxzL3JlY29yZGluZydcbldhdmVmb3JtID0gcmVxdWlyZSAnLi93YXZlZm9ybSdcbk1ldGVyID0gcmVxdWlyZSAnLi9tZXRlcidcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdC5jcmVhdGVDbGFzc1xuXG4gIG1peGluczogW01vZGVsYWJsZSgncmVjb3JkaW5nJyldXG5cbiAgb25DbGljazogLT5cbiAgICBpZiBAc3RhdGUuYWN0aXZlXG4gICAgICBAcHJvcHMucmVjb3JkaW5nLnN0b3AoKVxuICAgIGVsc2UgdW5sZXNzIEBzdGF0ZS5zYW1wbGVEYXRhP1xuICAgICAgQHByb3BzLnJlY29yZGluZy5yZWNvcmQoKVxuXG4gIGNvbmZpcm06IC0+XG4gICAgQHByb3BzLm9uQ29uZmlybSBAcHJvcHMucmVjb3JkaW5nLmNyb3BwZWRTYW1wbGVEYXRhKClcblxuICByZW5kZXI6IC0+XG5cbiAgICBsZWZ0QnV0dG9ucyA9IFtcbiAgICAgIFJlYWN0LkRPTS5kaXYoeyBcXFxuICAgICAgICBcImNsYXNzTmFtZVwiOiAoXCJpY29uIGljb24tcmVjb3JkICN7aWYgQHN0YXRlLmFjdGl2ZSB0aGVuICcgYWN0aXZlJyBlbHNlICcnfVwiKSwgIFxcXG4gICAgICAgIFwia2V5XCI6IFwiclwiLCAgXFxcbiAgICAgICAgXCJvbkNsaWNrXCI6IChpZiBAc3RhdGUuYWN0aXZlIHRoZW4gQHByb3BzLnJlY29yZGluZy5zdG9wIGVsc2UgQHByb3BzLnJlY29yZGluZy5yZWNvcmQpXG4gICAgICB9KVxuICAgIF1cblxuICAgIHJpZ2h0QnV0dG9ucyA9IFtcbiAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwiaWNvbiBpY29uLWNyb3NzXCIsIFwia2V5XCI6IFwiY1wiLCBcIm9uQ2xpY2tcIjogKEBwcm9wcy5vbkNhbmNlbCl9KVxuICAgIF1cblxuICAgIGlmIEBzdGF0ZS5zYW1wbGVEYXRhP1xuICAgICAgXG4gICAgICB3YXZlZm9ybSA9IFdhdmVmb3JtKHsgXFxcbiAgICAgICAgXCJzYW1wbGVEYXRhXCI6IChAc3RhdGUuc2FtcGxlRGF0YSksICBcXFxuICAgICAgICBcInNlbGVjdGlvblN0YXJ0XCI6IChAc3RhdGUuY3JvcFN0YXJ0KSwgIFxcXG4gICAgICAgIFwic2VsZWN0aW9uRW5kXCI6IChAc3RhdGUuY3JvcEVuZCksICBcXFxuICAgICAgICBcIm1hcmtlcnNcIjogKFxuICAgICAgICAgIHN0YXJ0OlxuICAgICAgICAgICAgdmFsdWU6IEBzdGF0ZS5jcm9wU3RhcnRcbiAgICAgICAgICAgIG9uQ2hhbmdlOiBAcHJvcHMucmVjb3JkaW5nLmNyZWF0ZVNldHRlckZvciAnY3JvcFN0YXJ0J1xuICAgICAgICAgIGVuZDpcbiAgICAgICAgICAgIHZhbHVlOiBAc3RhdGUuY3JvcEVuZFxuICAgICAgICAgICAgb25DaGFuZ2U6IEBwcm9wcy5yZWNvcmRpbmcuY3JlYXRlU2V0dGVyRm9yICdjcm9wRW5kJ1xuICAgICAgICApXG4gICAgICB9KVxuXG4gICAgICBsZWZ0QnV0dG9ucy5wdXNoIFJlYWN0LkRPTS5kaXYoeyBcXFxuICAgICAgICBcImNsYXNzTmFtZVwiOiBcImljb24gaWNvbi1wbGF5ICN7aWYgQHN0YXRlLnBsYXlpbmcgdGhlbiAnIGFjdGl2ZScgZWxzZSAnJ31cIiwgIFxcXG4gICAgICAgIFwia2V5XCI6IFwicFwiLCAgXFxcbiAgICAgICAgXCJvbkNsaWNrXCI6IChpZiBAc3RhdGUucGxheWluZyB0aGVuIEBwcm9wcy5yZWNvcmRpbmcuc3RvcCBlbHNlIEBwcm9wcy5yZWNvcmRpbmcucGxheSlcbiAgICAgIH0pXG5cbiAgICAgIHJpZ2h0QnV0dG9ucy5wdXNoIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwiaWNvbiBpY29uLWNoZWNrbWFya1wiLCBcImtleVwiOiBcInNcIiwgXCJvbkNsaWNrXCI6IChAY29uZmlybSl9KVxuXG4gICAgZWxzZVxuXG4gICAgICBtZXNzYWdlID0gaWYgQHN0YXRlLmVycm9yP1xuICAgICAgICBAcHJvcHMucmVjb3JkaW5nLnN0YXRlLmVycm9yXG4gICAgICBlbHNlIGlmIEBzdGF0ZS5hY3RpdmVcbiAgICAgICAgJ1JlY29yZGluZywgY2xpY2sgdG8gc3RvcCdcbiAgICAgIGVsc2VcbiAgICAgICAgJ0NsaWNrIHRvIHJlY29yZCdcblxuICAgICAgaW5zdHJ1Y3Rpb24gPSBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcImluc3RydWN0aW9uXCJ9LCAobWVzc2FnZSkpXG5cblxuICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwidWkgcmVjb3JkLWNvbnRyb2xcIn0sIFxuICAgICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJyb3cgc2FtcGxlXCJ9LCBcbiAgICAgICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJkaXNwbGF5XCIsIFwib25DbGlja1wiOiAoQG9uQ2xpY2spfSwgXG4gICAgICAgICAgKHdhdmVmb3JtKSwgXG4gICAgICAgICAgKGluc3RydWN0aW9uKVxuICAgICAgICApXG4gICAgICApLCBcbiAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwicm93IGNvbnRyb2xzXCJ9LCBcbiAgICAgICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJsZWZ0XCJ9LCBcbiAgICAgICAgICAobGVmdEJ1dHRvbnMpXG4gICAgICAgICksIFxuICAgICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcInJpZ2h0XCJ9LCBcbiAgICAgICAgICAocmlnaHRCdXR0b25zKVxuICAgICAgICApXG4gICAgICApXG4gICAgKVxuIiwiUmVhY3QgPSByZXF1aXJlICdyZWFjdC9hZGRvbnMnXG5SZWNvcmRpbmcgPSByZXF1aXJlICcuLi9tb2RlbHMvcmVjb3JkaW5nJ1xuV2F2ZWZvcm0gPSByZXF1aXJlICcuL3dhdmVmb3JtJ1xuUmVjb3JkQ29udHJvbCA9IHJlcXVpcmUgJy4vcmVjb3JkX2NvbnRyb2wnXG5cbmRlY29kZXIgPSBuZXcgd2Via2l0QXVkaW9Db250ZXh0XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3QuY3JlYXRlQ2xhc3NcblxuICAjIHJhbmdlIGluIHBpeGVscyBmb3IgdmVydGljYWwgZHJhZyB0byB6b29tXG4gIHJhbmdlOiAzMDBcbiAgZHJhZ1R5cGVEaXN0YW5jZTogMTBcblxuICBtaXhpbnM6IFtSZWFjdC5hZGRvbnMucHVyZVJlbmRlck1peGluXVxuXG4gIGdldERlZmF1bHRQcm9wczogLT5cbiAgICBzYW1wbGVTdGFydDogMFxuXG4gIHRyaWdnZXJGaWxlSW5wdXQ6IC0+XG4gICAgQHJlZnMuaW5wdXQuZ2V0RE9NTm9kZSgpLmNsaWNrKClcblxuICBvbkZpbGVTZWxlY3Q6IC0+XG4gICAgZmlsZSA9IEByZWZzLmlucHV0LmdldERPTU5vZGUoKS5maWxlc1swXVxuXG4gICAgaWYgZmlsZT9cbiAgICAgIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyXG4gICAgICByZWFkZXIub25sb2FkID0gKGUpID0+XG4gICAgICAgIGRlY29kZXIuZGVjb2RlQXVkaW9EYXRhIGUudGFyZ2V0LnJlc3VsdCwgKGJ1ZmZlcikgPT5cbiAgICAgICAgICBkYXRhID0gYnVmZmVyLmdldENoYW5uZWxEYXRhIDBcbiAgICAgICAgICBAcHJvcHMub25DaGFuZ2UgZmlsZS5uYW1lLCBkYXRhXG4gICAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIgZmlsZVxuXG4gIGNsZWFyOiAtPlxuICAgIEBwcm9wcy5vbkNoYW5nZSBudWxsLCBudWxsXG5cbiAgcmVjb3JkU2FtcGxlOiAtPlxuICAgIEBwcm9wcy5hcHAubGF1bmNoTW9kYWwgUmVjb3JkQ29udHJvbCh7IFxcXG4gICAgICBcInJlY29yZGluZ1wiOiAobmV3IFJlY29yZGluZyksICBcXFxuICAgICAgXCJvbkNhbmNlbFwiOiAoQHByb3BzLmFwcC5kaXNtaXNzTW9kYWwpLCAgXFxcbiAgICAgIFwib25Db25maXJtXCI6IChcbiAgICAgICAgKHNhbXBsZURhdGEpID0+XG4gICAgICAgICAgQHByb3BzLm9uQ2hhbmdlICdyZWNvcmRlZC53YXYnLCBzYW1wbGVEYXRhXG4gICAgICAgICAgQHByb3BzLmFwcC5kaXNtaXNzTW9kYWwoKVxuICAgICAgKVxuICAgIH0pXG5cbiAgcmVuZGVyOiAtPlxuICAgIG1hcmtlcnMgPSB7fVxuXG4gICAgaWYgQHByb3BzLnNhbXBsZVN0YXJ0P1xuICAgICAgbWFya2Vycy5zdGFydCA9XG4gICAgICAgIHZhbHVlOiBAcHJvcHMuc2FtcGxlU3RhcnRcbiAgICAgICAgb25DaGFuZ2U6IEBwcm9wcy5vbkNoYW5nZVN0YXJ0XG5cbiAgICBpZiBAcHJvcHMubG9vcEFjdGl2ZVxuICAgICAgbWFya2Vycy5sb29wID1cbiAgICAgICAgdmFsdWU6IEBwcm9wcy5zYW1wbGVMb29wXG4gICAgICAgIG9uQ2hhbmdlOiBAcHJvcHMub25DaGFuZ2VMb29wXG5cbiAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcInVpIHNhbXBsZS1jb250cm9sXCJ9LCBcbiAgICAgIFJlYWN0LkRPTS5pbnB1dCh7XCJ0eXBlXCI6IFwiZmlsZVwiLCBcInJlZlwiOiBcImlucHV0XCIsIFwib25DaGFuZ2VcIjogKEBvbkZpbGVTZWxlY3QpfSksIFxuICAgICAgUmVhY3QuRE9NLmRpdih7IFxcXG4gICAgICAgIFwiY2xhc3NOYW1lXCI6IFwiZGlzcGxheVwiLCAgXFxcbiAgICAgICAgXCJyZWZcIjogXCJjb250YWluZXJcIiwgIFxcXG4gICAgICAgIFwib25DbGlja1wiOiAoaWYgQHByb3BzLnNhbXBsZURhdGE/IHRoZW4gbnVsbCBlbHNlIEB0cmlnZ2VyRmlsZUlucHV0KVxuICAgICAgfSwgXG4gICAgICAgIChpZiBAcHJvcHMuc2FtcGxlRGF0YT8gdGhlbiBudWxsIGVsc2UgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJpbnN0cnVjdGlvblwifSwgXCJjbGljayB0byB1cGxvYWRcIikpLCBcbiAgICAgICAgV2F2ZWZvcm0oeyBcXFxuICAgICAgICAgIFwic2FtcGxlRGF0YVwiOiAoQHByb3BzLnNhbXBsZURhdGEpLCAgXFxcbiAgICAgICAgICBcInNlbGVjdGlvblN0YXJ0XCI6IChAcHJvcHMuc2FtcGxlU3RhcnQpLCAgXFxcbiAgICAgICAgICBcInNlbGVjdGlvbkVuZFwiOiAoaWYgQHByb3BzLmxvb3BBY3RpdmUgdGhlbiBAcHJvcHMuc2FtcGxlTG9vcCBlbHNlIDEpLCAgXFxcbiAgICAgICAgICBcIm1hcmtlcnNcIjogKG1hcmtlcnMpXG4gICAgICAgIH0pXG4gICAgICApLCBcbiAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwiY29udHJvbHNcIn0sIFxuICAgICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcImNvbnRyb2xcIiwgXCJvbkNsaWNrXCI6IChAdHJpZ2dlckZpbGVJbnB1dCl9LCBcbiAgICAgICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcImljb24gaWNvbi1hcnJvdy11cFwifSlcbiAgICAgICAgKSwgXG4gICAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwiY29udHJvbFwiLCBcIm9uQ2xpY2tcIjogKEByZWNvcmRTYW1wbGUpfSwgXG4gICAgICAgICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJpY29uIGljb24tcmVjb3JkXCJ9KVxuICAgICAgICApLCBcbiAgICAgICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJjb250cm9sXCIsIFwib25DbGlja1wiOiAoQGNsZWFyKX0sIFxuICAgICAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwiaWNvbiBpY29uLWNyb3NzXCJ9KVxuICAgICAgICApLCBcbiAgICAgICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJmaWxlLW5hbWVcIn0sIChAcHJvcHMuc2FtcGxlTmFtZSkpXG4gICAgICApLCBcbiAgICAgIFJlYWN0LkRPTS5sYWJlbChudWxsLCAoQHByb3BzLmxhYmVsKSlcbiAgICApXG4iLCJcblxuUmVhY3QgPSByZXF1aXJlICdyZWFjdCdcbkRyYWdnYWJsZSA9IHJlcXVpcmUgJy4vbWl4aW5zL2RyYWdnYWJsZSdcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdC5jcmVhdGVDbGFzc1xuXG4gIHJhbmdlOiAzMDBcblxuICBtaXhpbnM6IFtEcmFnZ2FibGVdXG5cbiAgZ2V0SW5pdGlhbFN0YXRlOiAtPlxuICAgIGFjdGl2ZTogZmFsc2VcblxuICBvbkRyYWdTdGFydDogLT5cbiAgICAjIG5vcm1hbGl6ZSB2YWx1ZVxuICAgIEBpbml0aWFsVmFsdWUgPSAoQHByb3BzLnZhbHVlIC0gQHByb3BzLm1pbikgLyAoQHByb3BzLm1heCAtIEBwcm9wcy5taW4pXG4gICAgQHNldFN0YXRlIGFjdGl2ZTogdHJ1ZVxuXG4gIG9uRHJhZzogKGRlbHRhKSAtPlxuICAgIHVwUmFuZ2UgPSBNYXRoLm1pbiBAcmFuZ2UsIChAZHJhZ1N0YXJ0UG9zaXRpb24ueSAtIHdpbmRvdy5zY3JvbGxZKVxuICAgIGRvd25SYW5nZSA9IE1hdGgubWluIEByYW5nZSwgKHdpbmRvdy5pbm5lckhlaWdodCArIHdpbmRvdy5zY3JvbGxZIC0gQGRyYWdTdGFydFBvc2l0aW9uLnkpXG5cbiAgICBpZiBkZWx0YS55IDwgMFxuICAgICAgdmFsdWUgPSBNYXRoLm1heCAwLCBAaW5pdGlhbFZhbHVlICogKGRvd25SYW5nZSArIGRlbHRhLnkpIC8gZG93blJhbmdlXG4gICAgZWxzZVxuICAgICAgdmFsdWUgPSBNYXRoLm1pbiAxLCBAaW5pdGlhbFZhbHVlICsgKDEgLSBAaW5pdGlhbFZhbHVlKSAqIGRlbHRhLnkgLyB1cFJhbmdlXG5cbiAgICAjIGRlbm9ybWFsaXplIHZhbHVlXG4gICAgdmFsdWUgPSAxICogQHByb3BzLm1pbiArIHZhbHVlICogKEBwcm9wcy5tYXggLSBAcHJvcHMubWluKVxuICAgIEBwcm9wcy5vbkNoYW5nZSB2YWx1ZVxuXG4gIG9uRHJhZ0VuZDogLT5cbiAgICBAaW5pdGlhbFZhbHVlID0gbnVsbFxuICAgIEBzZXRTdGF0ZSBhY3Rpb246IGZhbHNlXG5cbiAgcmVuZGVyOiAtPlxuICAgIGNsYXNzTmFtZSA9ICd1aSBzY2FsZS1oYW5kbGUnXG4gICAgY2xhc3NOYW1lICs9ICcgYWN0aXZlJyBpZiBAc3RhdGUuYWN0aXZlXG5cbiAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiAoY2xhc3NOYW1lKSwgXCJvbk1vdXNlRG93blwiOiAoQGRyYWdnYWJsZU9uTW91c2VEb3duKX0sIFxuICAgICAgKEBwcm9wcy5jaGlsZHJlbilcbiAgICApIiwiXG5cblJlYWN0ID0gcmVxdWlyZSAncmVhY3QnXG5TaXplTWVhc3VyYWJsZSA9IHJlcXVpcmUgJy4vbWl4aW5zL3NpemVfbWVhc3VyYWJsZSdcbkRyYWdnYWJsZSA9IHJlcXVpcmUgJy4vbWl4aW5zL2RyYWdnYWJsZSdcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdC5jcmVhdGVDbGFzc1xuICBcbiAgbWl4aW5zOiBbU2l6ZU1lYXN1cmFibGUsIERyYWdnYWJsZV1cblxuICBnZXRJbml0aWFsU3RhdGU6IC0+XG4gICAgYWN0aXZlOiBmYWxzZVxuXG4gIG9uRHJhZ1N0YXJ0OiAtPlxuICAgIEBpbml0YWxWYWx1ZSA9IEBwcm9wcy52YWx1ZVxuICAgIEBzZXRTdGF0ZSBhY3RpdmU6IHRydWVcblxuICBvbkRyYWc6IChkZWx0YSkgLT5cbiAgICB2YWx1ZSA9IEBpbml0YWxWYWx1ZSArIGRlbHRhLnkgLyBAc3RhdGUuaGVpZ2h0XG4gICAgdmFsdWUgPSBNYXRoLm1heCgwLCBNYXRoLm1pbih2YWx1ZSwgMSkpXG4gICAgQHByb3BzLm9uQ2hhbmdlIHZhbHVlXG5cbiAgb25EcmFnRW5kOiAtPlxuICAgIEBpbml0YWxWYWx1ZSA9IG51bGxcbiAgICBAc2V0U3RhdGUgYWN0aXZlOiBmYWxzZVxuXG4gIHJlbmRlcjogLT5cbiAgICBzdHlsZSA9IHRvcDogXCIjezEwMCooMSAtIEBwcm9wcy52YWx1ZSl9JVwiXG5cbiAgICBjbGFzc05hbWUgPSAndWkgc2xpZGVyJ1xuICAgIGNsYXNzTmFtZSArPSAnIGFjdGl2ZScgaWYgQHN0YXRlLmFjdGl2ZVxuXG4gICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogKGNsYXNzTmFtZSl9LCBcbiAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwiY29udHJvbFwiLCBcInJlZlwiOiBcImNvbnRhaW5lclwifSwgXG4gICAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwidHJhY2tcIn0pLCBcbiAgICAgICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJoYW5kbGVcIiwgXCJzdHlsZVwiOiAoc3R5bGUpLCBcIm9uTW91c2VEb3duXCI6IChAZHJhZ2dhYmxlT25Nb3VzZURvd24pfSlcbiAgICAgICksIFxuICAgICAgUmVhY3QuRE9NLmxhYmVsKG51bGwsIChAcHJvcHMubGFiZWwpKVxuICAgICkiLCJcblxuUmVhY3QgPSByZXF1aXJlICdyZWFjdC9hZGRvbnMnXG5Tb3J0YWJsZSA9IHJlcXVpcmUgJy4vbWl4aW5zL3NvcnRhYmxlJ1xuVXBkYXRhYmxlID0gcmVxdWlyZSAnLi9taXhpbnMvdXBkYXRhYmxlJ1xuRHJhZ2dhYmxlID0gcmVxdWlyZSAnLi9taXhpbnMvZHJhZ2dhYmxlJ1xuU2l6ZU1lYXN1cmFibGUgPSByZXF1aXJlICcuL21peGlucy9zaXplX21lYXN1cmFibGUnXG5Lbm9iID0gcmVxdWlyZSAnLi9rbm9iJ1xuTWV0ZXIgPSByZXF1aXJlICcuL21ldGVyJ1xuTWVudSA9IHJlcXVpcmUgJy4vbWVudSdcbkRydW1TYW1wbGVyID0gcmVxdWlyZSAnLi4vbW9kZWxzL2RydW1fc2FtcGxlcidcbkJhc2ljU2FtcGxlciA9IHJlcXVpcmUgJy4uL21vZGVscy9iYXNpY19zYW1wbGVyJ1xuTG9vcFNhbXBsZXIgPSByZXF1aXJlICcuLi9tb2RlbHMvbG9vcF9zYW1wbGVyJ1xuQW5hbG9nU3ludGhlc2l6ZXIgPSByZXF1aXJlICcuLi9tb2RlbHMvYW5hbG9nX3N5bnRoZXNpemVyJ1xuRHJ1bWtpdFN5bnRoZXNpemVyID0gcmVxdWlyZSAnLi4vbW9kZWxzL2RydW1raXRfc3ludGhlc2l6ZXInXG5UcmFjayA9IHJlcXVpcmUgJy4uL21vZGVscy90cmFjaydcblJlYWN0Q1NTVHJhbnNpdGlvbkdyb3VwID0gUmVhY3QuYWRkb25zLkNTU1RyYW5zaXRpb25Hcm91cFxuXG5cblRyYWNrUm93ID0gUmVhY3QuY3JlYXRlQ2xhc3NcblxuICBtaXhpbnM6IFtTb3J0YWJsZSwgUmVhY3QuYWRkb25zLlB1cmVSZW5kZXJNaXhpbl1cbiAgXG4gIHJlbmRlcjogLT5cbiAgICBjbGFzc05hbWUgPSAndHJhY2snXG4gICAgY2xhc3NOYW1lICs9ICcgc2VsZWN0ZWQnIGlmIEBwcm9wcy5zZWxlY3RlZFxuICAgIGNsYXNzTmFtZSArPSAnIGRyYWdnaW5nJyBpZiBAaXNEcmFnZ2luZygpXG5cbiAgICBSZWFjdC5ET00uZGl2KHsgXFxcbiAgICAgIFwiY2xhc3NOYW1lXCI6IChjbGFzc05hbWUpLCAgXFxcbiAgICAgIFwib25DbGlja1wiOiAoQHByb3BzLnNlbGVjdFRyYWNrKSwgIFxcXG4gICAgICBcImRyYWdnYWJsZVwiOiAodHJ1ZSksICBcXFxuICAgICAgXCJvbkRyYWdTdGFydFwiOiAoQGRyYWdTdGFydCksICBcXFxuICAgICAgXCJvbkRyYWdFbmRcIjogKEBkcmFnRW5kKSwgIFxcXG4gICAgICBcIm9uRHJhZ092ZXJcIjogKEBkcmFnT3ZlciksICBcXFxuICAgICAgXCJkYXRhLWlkXCI6IChAcHJvcHMuaW5kZXgpXG4gICAgfSwgXG4gICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiAnbmFtZSd9LCAoQHByb3BzLnRyYWNrLmdldCAnbmFtZScpKSwgXG4gICAgICBLbm9iKHsgXFxcbiAgICAgICAgXCJsYWJlbFwiOiBcIkxldmVsXCIsICBcXFxuICAgICAgICBcInZhbHVlXCI6IChAcHJvcHMudHJhY2suZ2V0SW4gJ2luc3RydW1lbnQnLCAnbGV2ZWwnKSwgIFxcXG4gICAgICAgIFwib25DaGFuZ2VcIjogKC0+KVxuICAgICAgfSksIFxuICAgICAgTWV0ZXIoe1widHJhY2tcIjogKEBwcm9wcy50cmFjayl9KVxuICAgIClcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0LmNyZWF0ZUNsYXNzXG5cbiAgbWl4aW5zOiBbVXBkYXRhYmxlLCBSZWFjdC5hZGRvbnMuUHVyZVJlbmRlck1peGluXVxuXG4gIHRyYWNrVHlwZXM6XG4gICAgJ0RydW0gU2FtcGxlcic6IERydW1TYW1wbGVyXG4gICAgJ0Jhc2ljIFNhbXBsZXInOiBCYXNpY1NhbXBsZXJcbiAgICAnTG9vcCBTYW1wbGVyJzogTG9vcFNhbXBsZXJcbiAgICAnQW5hbG9nIFN5bnRoJzogQW5hbG9nU3ludGhlc2l6ZXJcbiAgICAnRHJ1bSBTeW50aCc6IERydW1raXRTeW50aGVzaXplclxuXG4gIGdldEluaXRpYWxTdGF0ZTogLT5cbiAgICBtZW51T3BlbjogZmFsc2VcbiAgICBkcmFnZ2luZzogbnVsbFxuXG4gIGNvbXBvbmVudERpZE1vdW50OiAtPlxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyICdjbGljaycsIEBjbG9zZU1lbnVcblxuICBjb21wb25lbnRXaWxsVW5tb3VudDogLT5cbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciAnY2xpY2snLCBAY2xvc2VNZW51XG5cbiAgY2xvc2VNZW51OiAtPlxuICAgIEBzZXRTdGF0ZSBtZW51T3BlbjogZmFsc2UgaWYgQHN0YXRlLm1lbnVPcGVuXG5cbiAgdG9nZ2xlTWVudTogKGUpIC0+XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgIEBzZXRTdGF0ZSBtZW51T3BlbjogIUBzdGF0ZS5tZW51T3BlblxuXG4gIGFkZFRyYWNrOiAobmFtZSkgLT5cbiAgICB0cmFjayA9IFRyYWNrLmJ1aWxkIHtuYW1lLCBpbnN0cnVtZW50OiBAdHJhY2tUeXBlc1tuYW1lXS5idWlsZCgpfVxuICAgIGluZGV4ID0gQHByb3BzLnRyYWNrcy5sZW5ndGhcblxuICAgIEBwcm9wcy50cmFja3MudXBkYXRlICh0cmFja3MpIC0+IHRyYWNrcy5zZXQgaW5kZXgsIHRyYWNrXG4gICAgQHByb3BzLnNlbGVjdFRyYWNrIGluZGV4XG4gICAgQHNldFN0YXRlIG1lbnVPcGVuOiBmYWxzZVxuXG4gIHJlbW92ZVRyYWNrOiAtPlxuICAgIEBwcm9wcy50cmFja3MudXBkYXRlICh0cmFja3MpID0+IHRyYWNrcy5zcGxpY2UoQHByb3BzLnNlbGVjdGVkVHJhY2ssIDEpLnRvVmVjdG9yKClcbiAgICBAcHJvcHMuc2VsZWN0VHJhY2sgTWF0aC5tYXggMCwgTWF0aC5taW4gQHByb3BzLnNlbGVjdGVkVHJhY2ssIEBwcm9wcy50cmFja3MubGVuZ3RoIC0gMlxuXG4gIHJlbmRlcjogLT5cbiAgICB0cmFja1Jvd3MgPSBAcHJvcHMudHJhY2tzXG4gICAgICAubWFwICh0cmFjaywgaSkgPT5cbiAgICAgICAgaWYgdHJhY2tcbiAgICAgICAgICBUcmFja1Jvdyh7IFxcXG4gICAgICAgICAgICBcImtleVwiOiAodHJhY2suZ2V0ICdfaWQnKSwgIFxcXG4gICAgICAgICAgICBcImluZGV4XCI6IChpKSwgIFxcXG4gICAgICAgICAgICBcInRyYWNrXCI6ICh0cmFjayksICBcXFxuICAgICAgICAgICAgXCJzZWxlY3RlZFwiOiAoQHByb3BzLnNlbGVjdGVkVHJhY2sgPT0gaSksICBcXFxuICAgICAgICAgICAgXCJzZWxlY3RUcmFja1wiOiAoPT4gQHByb3BzLnNlbGVjdFRyYWNrIGkpLCAgXFxcbiAgICAgICAgICAgIFwiZHJhZ2dpbmdcIjogKEBzdGF0ZS5kcmFnZ2luZyksICBcXFxuICAgICAgICAgICAgXCJ1cGRhdGVEcmFnZ2luZ1wiOiAoQHVwZGF0ZSAnZHJhZ2dpbmcnKSwgIFxcXG4gICAgICAgICAgICBcIml0ZW1zXCI6IChAcHJvcHMudHJhY2tzKVxuICAgICAgICAgIH0pXG4gICAgICAudG9BcnJheSgpXG5cbiAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiAndWkgdHJhY2stc2VsZWN0aW9uJ30sIFxuICAgICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJ0cmFja3NcIn0sIFxuICAgICAgICBSZWFjdENTU1RyYW5zaXRpb25Hcm91cCh7XCJ0cmFuc2l0aW9uTmFtZVwiOiBcInRyYWNrXCJ9LCBcbiAgICAgICAgICAodHJhY2tSb3dzKVxuICAgICAgICApXG4gICAgICApLCBcbiAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwiY29udHJvbHNcIn0sIFxuICAgICAgICBNZW51KHtcIm9wdGlvbnNcIjogKE9iamVjdC5rZXlzIEB0cmFja1R5cGVzKSwgXCJvblNlbGVjdFwiOiAoQGFkZFRyYWNrKSwgXCJvcGVuXCI6IChAc3RhdGUubWVudU9wZW4pfSksIFxuICAgICAgICBSZWFjdC5ET00uZGl2KHtcImNsYXNzTmFtZVwiOiBcImljb24gaWNvbi1wbHVzIHB1bGwtcmlnaHRcIiwgXCJvbkNsaWNrXCI6IChAdG9nZ2xlTWVudSl9KSwgXG4gICAgICAgIFJlYWN0LkRPTS5kaXYoe1wiY2xhc3NOYW1lXCI6IFwiaWNvbiBpY29uLW1pbnVzIHB1bGwtbGVmdFwiLCBcIm9uQ2xpY2tcIjogKEByZW1vdmVUcmFjayl9KVxuICAgICAgKVxuICAgIClcbiIsIlJlYWN0ID0gcmVxdWlyZSAncmVhY3QvYWRkb25zJ1xuU2l6ZU1lYXN1cmFibGUgPSByZXF1aXJlICcuL21peGlucy9zaXplX21lYXN1cmFibGUnXG5EcmFnZ2FibGUgPSByZXF1aXJlICcuL21peGlucy9kcmFnZ2FibGUnXG5NYXJrZXIgPSByZXF1aXJlICcuL3dhdmVmb3JtL21hcmtlcidcblZpc3VhbGl6YXRpb24gPSByZXF1aXJlICcuL3dhdmVmb3JtL3Zpc3VhbGl6YXRpb24nXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3QuY3JlYXRlQ2xhc3NcblxuICBtaXhpbnM6IFtSZWFjdC5hZGRvbnMuUHVyZVJlbmRlck1peGluLCBTaXplTWVhc3VyYWJsZSwgRHJhZ2dhYmxlXVxuXG4gIHByb3BUeXBlczpcbiAgICBzYW1wbGVEYXRhOiBSZWFjdC5Qcm9wVHlwZXMub2JqZWN0XG4gICAgbWFya2VyczogUmVhY3QuUHJvcFR5cGVzLm9iamVjdFxuICAgIHNlbGVjdGlvblN0YXJ0OiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyXG4gICAgc2VsZWN0aW9uRW5kOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyXG4gICAgbWFyZ2luVG9wOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyXG4gICAgbWFyZ2luQm90dG9tOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyXG5cbiAgIyByYW5nZSBpbiBwaXhlbHMgZm9yIHZlcnRpY2FsIGRyYWcgdG8gem9vbVxuICByYW5nZTogMzAwXG4gIGRyYWdUeXBlRGlzdGFuY2U6IDEwXG5cbiAgZ2V0SW5pdGlhbFN0YXRlOiAtPlxuICAgIHdpbmRvd0NlbnRlcjogMC41XG4gICAgd2luZG93U2l6ZTogMVxuXG4gIGdldERlZmF1bHRQcm9wczogLT5cbiAgICBtYXJnaW5Ub3A6IDJcbiAgICBtYXJnaW5Cb3R0b206IDJcblxuICB2YWxpZGF0ZVdpbmRvd0NlbnRlcjogKGNlbnRlcikgLT5cbiAgICBoYWxmU2l6ZSA9IEBzdGF0ZS53aW5kb3dTaXplIC8gMlxuXG4gICAgaWYgY2VudGVyIDwgaGFsZlNpemVcbiAgICAgIGhhbGZTaXplXG4gICAgZWxzZSBpZiBjZW50ZXIgPiAxIC0gaGFsZlNpemVcbiAgICAgIDEgLSBoYWxmU2l6ZVxuICAgIGVsc2VcbiAgICAgIGNlbnRlclxuXG4gIG9uRHJhZ1N0YXJ0OiAtPlxuICAgIEBpbml0aWFsV2luZG93U2l6ZSA9IEBzdGF0ZS53aW5kb3dTaXplXG4gICAgQGluaXRpYWxXaW5kb3dDZW50ZXIgPSBAc3RhdGUud2luZG93Q2VudGVyXG5cbiAgICAjIGdldCBzYW1wbGUgaW5kZXggb2YgaW5pdGlhbCBtb3VzZG93blxuICAgIHJlbGF0aXZlUG9zaXRpb24gPSAoQGRyYWdTdGFydFBvc2l0aW9uLnggLSBAZ2V0RE9NTm9kZSgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQpIC8gQHN0YXRlLndpZHRoXG4gICAgQGluaXRpYWxQb3NpdGlvbiA9IEBzdGF0ZS53aW5kb3dDZW50ZXIgKyBAc3RhdGUud2luZG93U2l6ZSAqIChyZWxhdGl2ZVBvc2l0aW9uIC0gMC41KVxuXG4gIG9uRHJhZ0VuZDogLT5cbiAgICBAZHJhZ1R5cGUgPSBudWxsXG4gICAgQGluaXRpYWxXaW5kb3dTaXplID0gbnVsbFxuICAgIEBpbml0aWFsV2luZG93Q2VudGVyID0gbnVsbFxuICAgIEBpbml0aWFsUG9zaXRpb24gPSBudWxsXG5cbiAgb25EcmFnOiAoZGVsdGEpIC0+XG4gICAgaWYgQGRyYWdUeXBlID09ICdzY2FsZSdcblxuICAgICAgdXBSYW5nZSA9IE1hdGgubWluIEByYW5nZSwgKEBkcmFnU3RhcnRQb3NpdGlvbi55IC0gd2luZG93LnNjcm9sbFkpXG4gICAgICBkb3duUmFuZ2UgPSBNYXRoLm1pbiBAcmFuZ2UsICh3aW5kb3cuaW5uZXJIZWlnaHQgKyB3aW5kb3cuc2Nyb2xsWSAtIEBkcmFnU3RhcnRQb3NpdGlvbi55KVxuXG4gICAgICBpZiBkZWx0YS55IDwgMFxuICAgICAgICBtaW5WYWx1ZSA9IE1hdGgubWluIDEsIEBzdGF0ZS53aWR0aCAvIEBwcm9wcy5zYW1wbGVEYXRhLmxlbmd0aFxuICAgICAgICBzaXplID0gTWF0aC5tYXggbWluVmFsdWUsIEBpbml0aWFsV2luZG93U2l6ZSAqIChkb3duUmFuZ2UgKyBkZWx0YS55KSAvIGRvd25SYW5nZVxuICAgICAgZWxzZVxuICAgICAgICBzaXplID0gTWF0aC5taW4gMSwgQGluaXRpYWxXaW5kb3dTaXplICsgKDEgLSBAaW5pdGlhbFdpbmRvd1NpemUpICogZGVsdGEueSAvIHVwUmFuZ2VcblxuICAgICAgY2VudGVyID0gQGluaXRpYWxQb3NpdGlvbiAtIHNpemUgLyBAaW5pdGlhbFdpbmRvd1NpemUgKiAoQGluaXRpYWxQb3NpdGlvbiAtIEBpbml0aWFsV2luZG93Q2VudGVyKVxuXG4gICAgICBAc2V0U3RhdGVcbiAgICAgICAgd2luZG93U2l6ZTogc2l6ZVxuICAgICAgICB3aW5kb3dDZW50ZXI6IEB2YWxpZGF0ZVdpbmRvd0NlbnRlciBjZW50ZXJcblxuICAgIGVsc2UgaWYgQGRyYWdUeXBlID09ICdwYW4nXG5cbiAgICAgIGNlbnRlciA9IEBpbml0aWFsV2luZG93Q2VudGVyIC0gZGVsdGEueCAvIEBzdGF0ZS53aWR0aCAqIEBpbml0aWFsV2luZG93U2l6ZVxuICAgICAgQHNldFN0YXRlIHdpbmRvd0NlbnRlcjogQHZhbGlkYXRlV2luZG93Q2VudGVyIGNlbnRlclxuXG4gICAgZWxzZVxuICAgICAgaWYgTWF0aC5hYnMoZGVsdGEueCkgPiBAZHJhZ1R5cGVEaXN0YW5jZVxuICAgICAgICBAZHJhZ1R5cGUgPSAncGFuJ1xuICAgICAgZWxzZSBpZiBNYXRoLmFicyhkZWx0YS55KSA+IEBkcmFnVHlwZURpc3RhbmNlXG4gICAgICAgIEBkcmFnVHlwZSA9ICdzY2FsZSdcblxuICByZW5kZXI6IC0+XG5cbiAgICBpZiBAcHJvcHMuc2FtcGxlRGF0YT8gYW5kIEBzdGF0ZS53aWR0aCA+IDBcbiAgICAgIFxuICAgICAgIyByZW5kZXIgd2F2ZWZvcm1cblxuICAgICAgc2FtcGxlRGF0YSA9IEBwcm9wcy5zYW1wbGVEYXRhXG5cbiAgICAgICMgd2luZG93IHNpemUgaW4gc2xpY2VzXG4gICAgICByZXNvbHV0aW9uID0gQHN0YXRlLndpZHRoIC8gMlxuXG4gICAgICAjIHdpbmRvdyBzaXplIGluIHNhbXBsZXNcbiAgICAgIHdpbmRvd1NpemUgPSBNYXRoLm1heCAxLCBNYXRoLmZsb29yIEBzdGF0ZS53aW5kb3dTaXplICogc2FtcGxlRGF0YS5sZW5ndGhcblxuICAgICAgIyBzbGljZSBzaXplIGluIHNhbXBsZXNcbiAgICAgIHNsaWNlU2l6ZSA9IHdpbmRvd1NpemUgLyByZXNvbHV0aW9uXG5cbiAgICAgICMgd2luZG93IHN0YXJ0IGluIHNhbXBsZXNcbiAgICAgIHdpbmRvd1N0YXJ0ID0gTWF0aC5mbG9vciBAc3RhdGUud2luZG93Q2VudGVyICogc2FtcGxlRGF0YS5sZW5ndGggLSB3aW5kb3dTaXplIC8gMlxuXG4gICAgICAjIHNlbGVjdGlvbiBzdGFydCAvIGVuZCBpbiBzbGljZXNcbiAgICAgIHNlbGVjdGlvblN0YXJ0ID0gTWF0aC5mbG9vciAoQHByb3BzLnNlbGVjdGlvblN0YXJ0ICogc2FtcGxlRGF0YS5sZW5ndGggLSB3aW5kb3dTdGFydCkgLyBzbGljZVNpemVcbiAgICAgIHNlbGVjdGlvbkVuZCA9IE1hdGguY2VpbCAoQHByb3BzLnNlbGVjdGlvbkVuZCAqIHNhbXBsZURhdGEubGVuZ3RoIC0gd2luZG93U3RhcnQpIC8gc2xpY2VTaXplXG5cbiAgICAgIGlmIHNlbGVjdGlvblN0YXJ0ID4gMVxuICAgICAgICBwcmVTZWxlY3Rpb24gPSBWaXN1YWxpemF0aW9uKHsgXFxcbiAgICAgICAgICBcInNhbXBsZURhdGFcIjogKHNhbXBsZURhdGEpLCAgXFxcbiAgICAgICAgICBcInJlc29sdXRpb25cIjogKHJlc29sdXRpb24pLCAgXFxcbiAgICAgICAgICBcInNsaWNlU2l6ZVwiOiAoc2xpY2VTaXplKSwgIFxcXG4gICAgICAgICAgXCJ3aW5kb3dTdGFydFwiOiAod2luZG93U3RhcnQpLCAgXFxcbiAgICAgICAgICBcImZyb21TbGljZVwiOiAoMCksICBcXFxuICAgICAgICAgIFwidG9TbGljZVwiOiAoTWF0aC5taW4gcmVzb2x1dGlvbiwgc2VsZWN0aW9uU3RhcnQpLCAgXFxcbiAgICAgICAgICBcIndpZHRoXCI6IChAc3RhdGUud2lkdGgpLCAgXFxcbiAgICAgICAgICBcImhlaWdodFwiOiAoQHN0YXRlLmhlaWdodCksICBcXFxuICAgICAgICAgIFwibWFyZ2luVG9wXCI6IChAcHJvcHMubWFyZ2luVG9wKSwgIFxcXG4gICAgICAgICAgXCJtYXJnaW5Cb3R0b21cIjogKEBwcm9wcy5tYXJnaW5Cb3R0b20pXG4gICAgICAgIH0pXG4gIFxuICAgICAgaWYgc2VsZWN0aW9uU3RhcnQgIT0gc2VsZWN0aW9uRW5kXG4gICAgICAgIHNlbGVjdGlvbiA9IFZpc3VhbGl6YXRpb24oeyBcXFxuICAgICAgICAgIFwic2FtcGxlRGF0YVwiOiAoc2FtcGxlRGF0YSksICBcXFxuICAgICAgICAgIFwicmVzb2x1dGlvblwiOiAocmVzb2x1dGlvbiksICBcXFxuICAgICAgICAgIFwic2xpY2VTaXplXCI6IChzbGljZVNpemUpLCAgXFxcbiAgICAgICAgICBcIndpbmRvd1N0YXJ0XCI6ICh3aW5kb3dTdGFydCksICBcXFxuICAgICAgICAgIFwiZnJvbVNsaWNlXCI6IChNYXRoLm1heCAwLCBzZWxlY3Rpb25TdGFydCksICBcXFxuICAgICAgICAgIFwidG9TbGljZVwiOiAoTWF0aC5taW4gcmVzb2x1dGlvbiwgc2VsZWN0aW9uRW5kKSwgIFxcXG4gICAgICAgICAgXCJ3aWR0aFwiOiAoQHN0YXRlLndpZHRoKSwgIFxcXG4gICAgICAgICAgXCJoZWlnaHRcIjogKEBzdGF0ZS5oZWlnaHQpLCAgXFxcbiAgICAgICAgICBcIm1hcmdpblRvcFwiOiAoQHByb3BzLm1hcmdpblRvcCksICBcXFxuICAgICAgICAgIFwibWFyZ2luQm90dG9tXCI6IChAcHJvcHMubWFyZ2luQm90dG9tKSwgIFxcXG4gICAgICAgICAgXCJzZWxlY3Rpb25cIjogKHRydWUpXG4gICAgICAgIH0pXG4gICAgICBcbiAgICAgIGlmIHNlbGVjdGlvbkVuZCA8IHJlc29sdXRpb25cbiAgICAgICAgcG9zdFNlbGVjdGlvbiA9IFZpc3VhbGl6YXRpb24oeyBcXFxuICAgICAgICAgIFwic2FtcGxlRGF0YVwiOiAoc2FtcGxlRGF0YSksICBcXFxuICAgICAgICAgIFwicmVzb2x1dGlvblwiOiAocmVzb2x1dGlvbiksICBcXFxuICAgICAgICAgIFwic2xpY2VTaXplXCI6IChzbGljZVNpemUpLCAgXFxcbiAgICAgICAgICBcIndpbmRvd1N0YXJ0XCI6ICh3aW5kb3dTdGFydCksICBcXFxuICAgICAgICAgIFwiZnJvbVNsaWNlXCI6IChNYXRoLm1heCAwLCBzZWxlY3Rpb25FbmQpLCAgXFxcbiAgICAgICAgICBcInRvU2xpY2VcIjogKHJlc29sdXRpb24pLCAgXFxcbiAgICAgICAgICBcIndpZHRoXCI6IChAc3RhdGUud2lkdGgpLCAgXFxcbiAgICAgICAgICBcImhlaWdodFwiOiAoQHN0YXRlLmhlaWdodCksICBcXFxuICAgICAgICAgIFwibWFyZ2luVG9wXCI6IChAcHJvcHMubWFyZ2luVG9wKSwgIFxcXG4gICAgICAgICAgXCJtYXJnaW5Cb3R0b21cIjogKEBwcm9wcy5tYXJnaW5Cb3R0b20pXG4gICAgICAgIH0pXG5cbiAgICAgICMgcmVuZGVyIG1hcmtlcnNcbiAgICAgIG1hcmtlcnMgPSBbXVxuICAgICAgaWYgQHByb3BzLm1hcmtlcnM/XG4gICAgICAgIGZvciBuYW1lLCBkYXRhIG9mIEBwcm9wcy5tYXJrZXJzXG4gICAgICAgICAgbWFya2Vycy5wdXNoIE1hcmtlcih7IFxcXG4gICAgICAgICAgICBcImtleVwiOiAobmFtZSksICBcXFxuICAgICAgICAgICAgXCJuYW1lXCI6IChuYW1lKSwgIFxcXG4gICAgICAgICAgICBcInZhbHVlXCI6IChkYXRhLnZhbHVlKSwgIFxcXG4gICAgICAgICAgICBcIm9uQ2hhbmdlXCI6IChkYXRhLm9uQ2hhbmdlKSwgIFxcXG4gICAgICAgICAgICBcInBhcmVudFdpZHRoXCI6IChAc3RhdGUud2lkdGgpLCAgXFxcbiAgICAgICAgICAgIFwicGFyZW50SGVpZ2h0XCI6IChAc3RhdGUuaGVpZ2h0KSwgIFxcXG4gICAgICAgICAgICBcIndpbmRvd1NpemVcIjogKEBzdGF0ZS53aW5kb3dTaXplKSwgIFxcXG4gICAgICAgICAgICBcIndpbmRvd0NlbnRlclwiOiAoQHN0YXRlLndpbmRvd0NlbnRlcilcbiAgICAgICAgICB9KVxuXG4gICAgUmVhY3QuRE9NLmRpdih7XCJjbGFzc05hbWVcIjogXCJ1aSB3YXZlZm9ybVwiLCBcInJlZlwiOiBcImNvbnRhaW5lclwifSwgXG4gICAgICBSZWFjdC5ET00uc3ZnKHsgXFxcbiAgICAgICAgXCJ3aWR0aFwiOiAoQHN0YXRlLndpZHRoKSwgIFxcXG4gICAgICAgIFwiaGVpZ2h0XCI6IChAc3RhdGUuaGVpZ2h0KSwgIFxcXG4gICAgICAgIFwib25Nb3VzZURvd25cIjogKGlmIEBwcm9wcy5zYW1wbGVEYXRhPyB0aGVuIEBkcmFnZ2FibGVPbk1vdXNlRG93biBlbHNlIG51bGwpXG4gICAgICB9LCBcbiAgICAgICAgKHByZVNlbGVjdGlvbiksIFxuICAgICAgICAoc2VsZWN0aW9uKSwgXG4gICAgICAgIChwb3N0U2VsZWN0aW9uKSwgXG4gICAgICAgIChtYXJrZXJzKVxuICAgICAgKVxuICAgICkiLCJSZWFjdCA9IHJlcXVpcmUgJ3JlYWN0L2FkZG9ucydcbkRyYWdnYWJsZSA9IHJlcXVpcmUgJy4uL21peGlucy9kcmFnZ2FibGUnXG5cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdC5jcmVhdGVDbGFzc1xuXG4gIG1peGluczogW0RyYWdnYWJsZSwgUmVhY3QuYWRkb25zLlB1cmVSZW5kZXJNaXhpbl1cblxuICBwcm9wVHlwZXM6XG4gICAgbmFtZTogUmVhY3QuUHJvcFR5cGVzLnN0cmluZ1xuICAgIHZhbHVlOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyXG4gICAgcGFyZW50V2lkdGg6IFJlYWN0LlByb3BUeXBlcy5udW1iZXJcbiAgICBwYXJlbnRIZWlnaHQ6IFJlYWN0LlByb3BUeXBlcy5udW1iZXJcbiAgICB3aW5kb3dTaXplOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyXG4gICAgd2luZG93Q2VudGVyOiBSZWFjdC5Qcm9wVHlwZXMubnVtYmVyXG4gICAgd2lkdGg6IFJlYWN0LlByb3BUeXBlcy5udW1iZXJcbiAgICByYWRpdXM6IFJlYWN0LlByb3BUeXBlcy5udW1iZXJcblxuICBnZXREZWZhdWx0UHJvcHM6IC0+XG4gICAgcmFkaXVzOiAyXG4gICAgd2lkdGg6IDRcblxuICBnZXRJbml0aWFsU3RhdGU6IC0+XG4gICAgZHJhZ0FjdGl2ZTogZmFsc2VcblxuICBvbkRyYWdTdGFydDogKGRyYWdTdGFydFBvc2l0aW9uLCBlKSAtPlxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICBAc2V0U3RhdGUgZHJhZ0luaXRpYWxWYWx1ZTogQHByb3BzLnZhbHVlXG5cbiAgb25EcmFnRW5kOiAtPlxuICAgIEBzZXRTdGF0ZSBkcmFnSW5pdGlhbFZhbHVlOiBudWxsXG5cbiAgb25EcmFnOiAoZGVsdGEpIC0+XG4gICAgdmFsdWUgPSBNYXRoLm1heCAwLCBNYXRoLm1pbiAxLCBAc3RhdGUuZHJhZ0luaXRpYWxWYWx1ZSArIGRlbHRhLnggLyBAcHJvcHMucGFyZW50V2lkdGggKiBAcHJvcHMud2luZG93U2l6ZVxuICAgIEBwcm9wcy5vbkNoYW5nZSB2YWx1ZVxuXG4gIHJlbmRlcjogLT5cbiAgICB3aW5kb3dTdGFydCA9IEBwcm9wcy53aW5kb3dDZW50ZXIgLSBAcHJvcHMud2luZG93U2l6ZSAvIDJcbiAgICB3aW5kb3dFbmQgPSBAcHJvcHMud2luZG93Q2VudGVyICsgQHByb3BzLndpbmRvd1NpemUgLyAyXG5cbiAgICByZXR1cm4gUmVhY3QuRE9NLmcobnVsbCkgdW5sZXNzIEBwcm9wcy52YWx1ZSA+PSB3aW5kb3dTdGFydCBhbmQgQHByb3BzLnZhbHVlIDw9IHdpbmRvd0VuZFxuXG4gICAgeCA9IChAcHJvcHMudmFsdWUgLSB3aW5kb3dTdGFydCkgLyBAcHJvcHMud2luZG93U2l6ZSAqIEBwcm9wcy5wYXJlbnRXaWR0aCAtIEBwcm9wcy53aWR0aCAvIDJcbiAgICB4ID0gTWF0aC5tYXggMCwgTWF0aC5taW4gQHByb3BzLnBhcmVudFdpZHRoIC0gQHByb3BzLndpZHRoLCB4XG5cbiAgICBjbGFzc05hbWUgPSBcIm1hcmtlciAje0Bwcm9wcy5uYW1lfVwiXG4gICAgY2xhc3NOYW1lICs9ICcgYWN0aXZlJyBpZiBAc3RhdGUuZHJhZ0luaXRpYWxWYWx1ZT9cblxuICAgIFJlYWN0LkRPTS5nKG51bGwsIFxuICAgICAgUmVhY3QuRE9NLnJlY3QoeyBcXFxuICAgICAgICBcImNsYXNzTmFtZVwiOiAoY2xhc3NOYW1lKSwgIFxcXG4gICAgICAgIFwieFwiOiAoeCksICBcXFxuICAgICAgICBcInlcIjogKDApLCAgXFxcbiAgICAgICAgXCJ3aWR0aFwiOiAoQHByb3BzLndpZHRoKSwgIFxcXG4gICAgICAgIFwiaGVpZ2h0XCI6IChAcHJvcHMucGFyZW50SGVpZ2h0KSwgIFxcXG4gICAgICAgIFwicnhcIjogKEBwcm9wcy5yYWRpdXMpLCAgXFxcbiAgICAgICAgXCJyeVwiOiAoQHByb3BzLnJhZGl1cyksICBcXFxuICAgICAgICBcIm9uTW91c2VEb3duXCI6IChAZHJhZ2dhYmxlT25Nb3VzZURvd24pXG4gICAgICB9KVxuICAgIClcblxuIiwiUmVhY3QgPSByZXF1aXJlICdyZWFjdC9hZGRvbnMnXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3QuY3JlYXRlQ2xhc3NcblxuICBtaXhpbnM6IFtSZWFjdC5hZGRvbnMuUHVyZVJlbmRlck1peGluXVxuXG4gIHJlbmRlcjogLT5cbiAgICBzYW1wbGVEYXRhID0gQHByb3BzLnNhbXBsZURhdGFcbiAgICByZXNvbHV0aW9uID0gQHByb3BzLnJlc29sdXRpb25cbiAgICBzbGljZVNpemUgPSBAcHJvcHMuc2xpY2VTaXplXG4gICAgd2luZG93U3RhcnQgPSBAcHJvcHMud2luZG93U3RhcnRcbiAgICBmcm9tU2xpY2UgPSBAcHJvcHMuZnJvbVNsaWNlXG4gICAgdG9TbGljZSA9IEBwcm9wcy50b1NsaWNlXG4gICAgd2lkdGggPSBAcHJvcHMud2lkdGhcbiAgICBoZWlnaHQgPSBAcHJvcHMuaGVpZ2h0IC0gQHByb3BzLm1hcmdpblRvcCAtIEBwcm9wcy5tYXJnaW5Cb3R0b21cbiAgICB0b3AgPSBAcHJvcHMubWFyZ2luQm90dG9tXG4gICAgYm90dG9tID0gQHByb3BzLmhlaWdodCAtIEBwcm9wcy5tYXJnaW5Cb3R0b21cblxuICAgIHBvaW50cyA9IFtdXG5cbiAgICBwb2ludHMucHVzaCBcIiN7ZnJvbVNsaWNlICogd2lkdGggLyByZXNvbHV0aW9ufSAje2JvdHRvbX1cIlxuXG4gICAgZm9yIGkgaW4gW2Zyb21TbGljZS4udG9TbGljZV1cbiAgICAgIHNsaWNlU3RhcnQgPSBpICogc2xpY2VTaXplICsgd2luZG93U3RhcnRcbiAgICAgIHNsaWNlRW5kID0gc2xpY2VTdGFydCArIHNsaWNlU2l6ZVxuXG4gICAgICB4ID0gaSAqIHdpZHRoIC8gcmVzb2x1dGlvblxuXG4gICAgICB5ID0gMFxuICAgICAgZm9yIGogaW4gW01hdGguZmxvb3Ioc2xpY2VTdGFydCkuLi5NYXRoLmZsb29yKHNsaWNlRW5kKV1cbiAgICAgICAgdiA9IE1hdGguYWJzIHNhbXBsZURhdGFbal1cbiAgICAgICAgeSA9IHYgaWYgdiA+IHlcbiAgICAgIHkgPSAoKCgxIC0geSkgKiBoZWlnaHQpIHx8IDApICsgdG9wXG5cbiAgICAgIHBvaW50cy5wdXNoIFwiI3t4fSAje3l9XCJcblxuICAgIHBvaW50cy5wdXNoIFwiI3t4fSAje2JvdHRvbX1cIlxuXG4gICAgZCA9IFwiTSAje3BvaW50cy5qb2luICcgTCAnfVwiXG5cbiAgICBjbGFzc05hbWUgPSAnc2VsZWN0aW9uJyBpZiBAcHJvcHMuc2VsZWN0aW9uXG5cbiAgICBSZWFjdC5ET00ucGF0aCh7XCJjbGFzc05hbWVcIjogKGNsYXNzTmFtZSksIFwiZFwiOiAoZCl9KSIsIm5leHRJZCA9IDBcbmFjdGlvbnMgPSB7fVxuXG5hcHBseSA9IC0+XG4gIG1heCA9IG51bGxcbiAgXG4gIGZvciBpZCwgYWN0aW9uIG9mIGFjdGlvbnNcbiAgICBtYXggPSBpZCBpZiAhbWF4PyBvciBhY3Rpb24ucHJpb3JpdHkgPiBhY3Rpb25zW21heF0ucHJpb3JpdHkgXG5cbiAgZG9jdW1lbnQuYm9keS5zdHlsZS5jdXJzb3IgPSBpZiBtYXggdGhlbiBhY3Rpb25zW21heF0udmFsdWUgZWxzZSAnZGVmYXVsdCdcblxubW9kdWxlLmV4cG9ydHMgPVxuXG4gIHNldDogKHZhbHVlLCBwcmlvcml0eSwgaWQpIC0+XG4gICAgaWQgfHw9IG5leHRJZCArPSAxXG4gICAgYWN0aW9uc1tpZF0gPSB7dmFsdWUsIHByaW9yaXR5fVxuICAgIGFwcGx5KClcblxuICAgIGlkXG5cbiAgY2xlYXI6IChpZCkgLT5cbiAgICBkZWxldGUgYWN0aW9uc1tpZF1cbiAgICBhcHBseSgpXG4iLCJSZWFjdCA9IHJlcXVpcmUgJ3JlYWN0J1xuXG5rZXlzID0gWydDJywgJ0MjJywgJ0QnLCAnRCMnLCAnRScsICdGJywgJ0YjJywgJ0cnLCAnRyMnLCAnQScsICdBIycsICdCJ11cblxubW9kdWxlLmV4cG9ydHMgPSAtPlxuICBmb3IgaSBpbiBbMTI3Li4wXVxuICAgIG9jdGF2ZSA9IE1hdGguZmxvb3IoaSAvIDEyKSAtIDJcbiAgICBub3RlID0ga2V5c1tpICUgMTJdXG4gICAgUmVhY3QuRE9NLm9wdGlvbih7XCJrZXlcIjogKGkpLCBcInZhbHVlXCI6IChpKX0sIChcIiN7bm90ZX0je29jdGF2ZX1cIikpIiwiS2V5Ym9hcmQgPVxuXG4gIGNhbGxiYWNrczoge31cbiAgcHJlc3NlZDoge31cbiAgcmVzdHJpY3RlZDogWzgsIDMyLCAzNywgMzgsIDM5LCA0MF1cblxuICBvbjogKGtleSwgZm4pIC0+XG4gICAgQGNhbGxiYWNrc1trZXldIHx8PSBbXVxuICAgIEBjYWxsYmFja3Nba2V5XS5wdXNoIGZuXG5cbiAgb2ZmOiAoa2V5LCBmbikgLT5cbiAgICBpID0gQGNhbGxiYWNrc1trZXldLmluZGV4T2YgZm5cbiAgICBAY2FsbGJhY2tzW2tleV0uc3BsaWNlIGksIDEgaWYgaSA+PSAwXG5cblxuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciAna2V5ZG93bicsIChlKSAtPlxuICBLZXlib2FyZC5wcmVzc2VkW2Uua2V5Q29kZV0gPSB0cnVlXG5cbiAgZS5wcmV2ZW50RGVmYXVsdCgpIGlmIGUua2V5Q29kZSBpbiBLZXlib2FyZC5yZXN0cmljdGVkXG5cbiAgaWYgS2V5Ym9hcmQuY2FsbGJhY2tzW2Uua2V5Q29kZV0/XG4gICAgZm4gZSBmb3IgZm4gaW4gS2V5Ym9hcmQuY2FsbGJhY2tzW2Uua2V5Q29kZV1cblxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIgJ2tleXVwJywgKGUpIC0+XG4gIEtleWJvYXJkLnByZXNzZWRbZS5rZXlDb2RlXSA9IGZhbHNlXG5cbm1vZHVsZS5leHBvcnRzID0gS2V5Ym9hcmQiLCJpID0gMFxubW9kdWxlLmV4cG9ydHMgPSAodikgLT5cbiAgY29uc29sZS5sb2codikgaWYgaSA9PSAwXG4gIGkgPSAoaSArIDEpICUgMTAwMDBcbiIsIm1vZHVsZS5leHBvcnRzID0gY2xhc3MgUmluZ0J1ZmZlclxuICBcbiAgY29uc3RydWN0b3I6IChAbWF4TGVuZ3RoLCBAVHlwZSA9IEZsb2F0MzJBcnJheSwgQGxlbmd0aCkgLT5cbiAgICBAbGVuZ3RoIHx8PSBAbWF4TGVuZ3RoXG4gICAgQGFycmF5ID0gbmV3IFR5cGUgQG1heExlbmd0aFxuICAgIEBwb3MgPSAwXG5cbiAgcmVzZXQ6IC0+XG4gICAgQGFycmF5ID0gbmV3IEBUeXBlIEBtYXhMZW5ndGhcbiAgICB0aGlzXG5cbiAgcmVzaXplOiAoQGxlbmd0aCkgLT5cbiAgICBAcG9zID0gMCBpZiBAcG9zID49IEBsZW5ndGhcblxuICBwdXNoOiAoZWwpIC0+XG4gICAgQGFycmF5W0Bwb3NdID0gZWxcbiAgICBAcG9zICs9IDFcbiAgICBAcG9zID0gMCBpZiBAcG9zID09IEBsZW5ndGhcbiAgICB0aGlzXG5cbiAgZm9yRWFjaDogKGZuKSAtPlxuICAgIGB2YXIgaSwgbGVuO1xuICAgIGZvciAoaSA9IHRoaXMucG9zLCBsZW4gPSB0aGlzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBmbih0aGlzLmFycmF5W2ldLCBpKTtcbiAgICB9XG4gICAgZm9yIChpID0gMCwgbGVuID0gdGhpcy5wb3M7IGkgPCBsZW47IGkrKykge1xuICAgICAgZm4odGhpcy5hcnJheVtpXSwgaSk7XG4gICAgfWBcbiAgICB0aGlzXG5cbiAgcmVkdWNlOiAoZm4sIG1lbW8gPSAwKSAtPlxuICAgIEBmb3JFYWNoIChlbCwgaSkgLT5cbiAgICAgIG1lbW8gPSBmbiBtZW1vLCBlbCwgaVxuICAgIG1lbW9cbiIsIlJlYWN0ID0gcmVxdWlyZSAncmVhY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gLT5cbiAgZm9yIGkgaW4gWzI0Li4tMjRdXG4gICAgUmVhY3QuRE9NLm9wdGlvbih7XCJrZXlcIjogKGkpLCBcInZhbHVlXCI6IChpKX0sIChpKSlcbiIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKiFcbiAqIGFzeW5jXG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2FvbGFuL2FzeW5jXG4gKlxuICogQ29weXJpZ2h0IDIwMTAtMjAxNCBDYW9sYW4gTWNNYWhvblxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbi8qanNoaW50IG9uZXZhcjogZmFsc2UsIGluZGVudDo0ICovXG4vKmdsb2JhbCBzZXRJbW1lZGlhdGU6IGZhbHNlLCBzZXRUaW1lb3V0OiBmYWxzZSwgY29uc29sZTogZmFsc2UgKi9cbihmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgYXN5bmMgPSB7fTtcblxuICAgIC8vIGdsb2JhbCBvbiB0aGUgc2VydmVyLCB3aW5kb3cgaW4gdGhlIGJyb3dzZXJcbiAgICB2YXIgcm9vdCwgcHJldmlvdXNfYXN5bmM7XG5cbiAgICByb290ID0gdGhpcztcbiAgICBpZiAocm9vdCAhPSBudWxsKSB7XG4gICAgICBwcmV2aW91c19hc3luYyA9IHJvb3QuYXN5bmM7XG4gICAgfVxuXG4gICAgYXN5bmMubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcm9vdC5hc3luYyA9IHByZXZpb3VzX2FzeW5jO1xuICAgICAgICByZXR1cm4gYXN5bmM7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG9ubHlfb25jZShmbikge1xuICAgICAgICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChjYWxsZWQpIHRocm93IG5ldyBFcnJvcihcIkNhbGxiYWNrIHdhcyBhbHJlYWR5IGNhbGxlZC5cIik7XG4gICAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgZm4uYXBwbHkocm9vdCwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vLy8gY3Jvc3MtYnJvd3NlciBjb21wYXRpYmxpdHkgZnVuY3Rpb25zIC8vLy9cblxuICAgIHZhciBfdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4gICAgdmFyIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIH07XG5cbiAgICB2YXIgX2VhY2ggPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvcikge1xuICAgICAgICBpZiAoYXJyLmZvckVhY2gpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnIuZm9yRWFjaChpdGVyYXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKGFycltpXSwgaSwgYXJyKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgX21hcCA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yKSB7XG4gICAgICAgIGlmIChhcnIubWFwKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyLm1hcChpdGVyYXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgX2VhY2goYXJyLCBmdW5jdGlvbiAoeCwgaSwgYSkge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGl0ZXJhdG9yKHgsIGksIGEpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG5cbiAgICB2YXIgX3JlZHVjZSA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBtZW1vKSB7XG4gICAgICAgIGlmIChhcnIucmVkdWNlKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyLnJlZHVjZShpdGVyYXRvciwgbWVtbyk7XG4gICAgICAgIH1cbiAgICAgICAgX2VhY2goYXJyLCBmdW5jdGlvbiAoeCwgaSwgYSkge1xuICAgICAgICAgICAgbWVtbyA9IGl0ZXJhdG9yKG1lbW8sIHgsIGksIGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgfTtcblxuICAgIHZhciBfa2V5cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIga2V5cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBrIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5cztcbiAgICB9O1xuXG4gICAgLy8vLyBleHBvcnRlZCBhc3luYyBtb2R1bGUgZnVuY3Rpb25zIC8vLy9cblxuICAgIC8vLy8gbmV4dFRpY2sgaW1wbGVtZW50YXRpb24gd2l0aCBicm93c2VyLWNvbXBhdGlibGUgZmFsbGJhY2sgLy8vL1xuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcgfHwgIShwcm9jZXNzLm5leHRUaWNrKSkge1xuICAgICAgICBpZiAodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgYXN5bmMubmV4dFRpY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgICAgICAvLyBub3QgYSBkaXJlY3QgYWxpYXMgZm9yIElFMTAgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgICAgIHNldEltbWVkaWF0ZShmbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlID0gYXN5bmMubmV4dFRpY2s7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhc3luYy5uZXh0VGljayA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZm4sIDApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZSA9IGFzeW5jLm5leHRUaWNrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhc3luYy5uZXh0VGljayA9IHByb2Nlc3MubmV4dFRpY2s7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgIC8vIG5vdCBhIGRpcmVjdCBhbGlhcyBmb3IgSUUxMCBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICAgIHNldEltbWVkaWF0ZShmbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlID0gYXN5bmMubmV4dFRpY2s7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYy5lYWNoID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG4gICAgICAgIGlmICghYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbXBsZXRlZCA9IDA7XG4gICAgICAgIF9lYWNoKGFyciwgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgsIG9ubHlfb25jZShkb25lKSApO1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gZG9uZShlcnIpIHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBjb21wbGV0ZWQgKz0gMTtcbiAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlZCA+PSBhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBhc3luYy5mb3JFYWNoID0gYXN5bmMuZWFjaDtcblxuICAgIGFzeW5jLmVhY2hTZXJpZXMgPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgaWYgKCFhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29tcGxldGVkID0gMDtcbiAgICAgICAgdmFyIGl0ZXJhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpdGVyYXRvcihhcnJbY29tcGxldGVkXSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlZCArPSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGxldGVkID49IGFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVyYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgaXRlcmF0ZSgpO1xuICAgIH07XG4gICAgYXN5bmMuZm9yRWFjaFNlcmllcyA9IGFzeW5jLmVhY2hTZXJpZXM7XG5cbiAgICBhc3luYy5lYWNoTGltaXQgPSBmdW5jdGlvbiAoYXJyLCBsaW1pdCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBmbiA9IF9lYWNoTGltaXQobGltaXQpO1xuICAgICAgICBmbi5hcHBseShudWxsLCBbYXJyLCBpdGVyYXRvciwgY2FsbGJhY2tdKTtcbiAgICB9O1xuICAgIGFzeW5jLmZvckVhY2hMaW1pdCA9IGFzeW5jLmVhY2hMaW1pdDtcblxuICAgIHZhciBfZWFjaExpbWl0ID0gZnVuY3Rpb24gKGxpbWl0KSB7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgIGlmICghYXJyLmxlbmd0aCB8fCBsaW1pdCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY29tcGxldGVkID0gMDtcbiAgICAgICAgICAgIHZhciBzdGFydGVkID0gMDtcbiAgICAgICAgICAgIHZhciBydW5uaW5nID0gMDtcblxuICAgICAgICAgICAgKGZ1bmN0aW9uIHJlcGxlbmlzaCAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlZCA+PSBhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHdoaWxlIChydW5uaW5nIDwgbGltaXQgJiYgc3RhcnRlZCA8IGFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRlZCArPSAxO1xuICAgICAgICAgICAgICAgICAgICBydW5uaW5nICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yKGFycltzdGFydGVkIC0gMV0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZWQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydW5uaW5nIC09IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlZCA+PSBhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsZW5pc2goKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH07XG4gICAgfTtcblxuXG4gICAgdmFyIGRvUGFyYWxsZWwgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShudWxsLCBbYXN5bmMuZWFjaF0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHZhciBkb1BhcmFsbGVsTGltaXQgPSBmdW5jdGlvbihsaW1pdCwgZm4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShudWxsLCBbX2VhY2hMaW1pdChsaW1pdCldLmNvbmNhdChhcmdzKSk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICB2YXIgZG9TZXJpZXMgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShudWxsLCBbYXN5bmMuZWFjaFNlcmllc10uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG5cbiAgICB2YXIgX2FzeW5jTWFwID0gZnVuY3Rpb24gKGVhY2hmbiwgYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgYXJyID0gX21hcChhcnIsIGZ1bmN0aW9uICh4LCBpKSB7XG4gICAgICAgICAgICByZXR1cm4ge2luZGV4OiBpLCB2YWx1ZTogeH07XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvcih4LnZhbHVlLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgICAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvcih4LnZhbHVlLCBmdW5jdGlvbiAoZXJyLCB2KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHNbeC5pbmRleF0gPSB2O1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgYXN5bmMubWFwID0gZG9QYXJhbGxlbChfYXN5bmNNYXApO1xuICAgIGFzeW5jLm1hcFNlcmllcyA9IGRvU2VyaWVzKF9hc3luY01hcCk7XG4gICAgYXN5bmMubWFwTGltaXQgPSBmdW5jdGlvbiAoYXJyLCBsaW1pdCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBfbWFwTGltaXQobGltaXQpKGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgdmFyIF9tYXBMaW1pdCA9IGZ1bmN0aW9uKGxpbWl0KSB7XG4gICAgICAgIHJldHVybiBkb1BhcmFsbGVsTGltaXQobGltaXQsIF9hc3luY01hcCk7XG4gICAgfTtcblxuICAgIC8vIHJlZHVjZSBvbmx5IGhhcyBhIHNlcmllcyB2ZXJzaW9uLCBhcyBkb2luZyByZWR1Y2UgaW4gcGFyYWxsZWwgd29uJ3RcbiAgICAvLyB3b3JrIGluIG1hbnkgc2l0dWF0aW9ucy5cbiAgICBhc3luYy5yZWR1Y2UgPSBmdW5jdGlvbiAoYXJyLCBtZW1vLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgYXN5bmMuZWFjaFNlcmllcyhhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaXRlcmF0b3IobWVtbywgeCwgZnVuY3Rpb24gKGVyciwgdikge1xuICAgICAgICAgICAgICAgIG1lbW8gPSB2O1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyLCBtZW1vKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBpbmplY3QgYWxpYXNcbiAgICBhc3luYy5pbmplY3QgPSBhc3luYy5yZWR1Y2U7XG4gICAgLy8gZm9sZGwgYWxpYXNcbiAgICBhc3luYy5mb2xkbCA9IGFzeW5jLnJlZHVjZTtcblxuICAgIGFzeW5jLnJlZHVjZVJpZ2h0ID0gZnVuY3Rpb24gKGFyciwgbWVtbywgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXZlcnNlZCA9IF9tYXAoYXJyLCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH0pLnJldmVyc2UoKTtcbiAgICAgICAgYXN5bmMucmVkdWNlKHJldmVyc2VkLCBtZW1vLCBpdGVyYXRvciwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgLy8gZm9sZHIgYWxpYXNcbiAgICBhc3luYy5mb2xkciA9IGFzeW5jLnJlZHVjZVJpZ2h0O1xuXG4gICAgdmFyIF9maWx0ZXIgPSBmdW5jdGlvbiAoZWFjaGZuLCBhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBhcnIgPSBfbWFwKGFyciwgZnVuY3Rpb24gKHgsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiB7aW5kZXg6IGksIHZhbHVlOiB4fTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVhY2hmbihhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaXRlcmF0b3IoeC52YWx1ZSwgZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgY2FsbGJhY2soX21hcChyZXN1bHRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5pbmRleCAtIGIuaW5kZXg7XG4gICAgICAgICAgICB9KSwgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geC52YWx1ZTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBhc3luYy5maWx0ZXIgPSBkb1BhcmFsbGVsKF9maWx0ZXIpO1xuICAgIGFzeW5jLmZpbHRlclNlcmllcyA9IGRvU2VyaWVzKF9maWx0ZXIpO1xuICAgIC8vIHNlbGVjdCBhbGlhc1xuICAgIGFzeW5jLnNlbGVjdCA9IGFzeW5jLmZpbHRlcjtcbiAgICBhc3luYy5zZWxlY3RTZXJpZXMgPSBhc3luYy5maWx0ZXJTZXJpZXM7XG5cbiAgICB2YXIgX3JlamVjdCA9IGZ1bmN0aW9uIChlYWNoZm4sIGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIGFyciA9IF9tYXAoYXJyLCBmdW5jdGlvbiAoeCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHtpbmRleDogaSwgdmFsdWU6IHh9O1xuICAgICAgICB9KTtcbiAgICAgICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpdGVyYXRvcih4LnZhbHVlLCBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIGlmICghdikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgY2FsbGJhY2soX21hcChyZXN1bHRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5pbmRleCAtIGIuaW5kZXg7XG4gICAgICAgICAgICB9KSwgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geC52YWx1ZTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBhc3luYy5yZWplY3QgPSBkb1BhcmFsbGVsKF9yZWplY3QpO1xuICAgIGFzeW5jLnJlamVjdFNlcmllcyA9IGRvU2VyaWVzKF9yZWplY3QpO1xuXG4gICAgdmFyIF9kZXRlY3QgPSBmdW5jdGlvbiAoZWFjaGZuLCBhcnIsIGl0ZXJhdG9yLCBtYWluX2NhbGxiYWNrKSB7XG4gICAgICAgIGVhY2hmbihhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaXRlcmF0b3IoeCwgZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFpbl9jYWxsYmFjayh4KTtcbiAgICAgICAgICAgICAgICAgICAgbWFpbl9jYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgbWFpbl9jYWxsYmFjaygpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGFzeW5jLmRldGVjdCA9IGRvUGFyYWxsZWwoX2RldGVjdCk7XG4gICAgYXN5bmMuZGV0ZWN0U2VyaWVzID0gZG9TZXJpZXMoX2RldGVjdCk7XG5cbiAgICBhc3luYy5zb21lID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIG1haW5fY2FsbGJhY2spIHtcbiAgICAgICAgYXN5bmMuZWFjaChhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaXRlcmF0b3IoeCwgZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICBtYWluX2NhbGxiYWNrKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBtYWluX2NhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgbWFpbl9jYWxsYmFjayhmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gYW55IGFsaWFzXG4gICAgYXN5bmMuYW55ID0gYXN5bmMuc29tZTtcblxuICAgIGFzeW5jLmV2ZXJ5ID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIG1haW5fY2FsbGJhY2spIHtcbiAgICAgICAgYXN5bmMuZWFjaChhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaXRlcmF0b3IoeCwgZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXYpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFpbl9jYWxsYmFjayhmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIG1haW5fY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBtYWluX2NhbGxiYWNrKHRydWUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIGFsbCBhbGlhc1xuICAgIGFzeW5jLmFsbCA9IGFzeW5jLmV2ZXJ5O1xuXG4gICAgYXN5bmMuc29ydEJ5ID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGFzeW5jLm1hcChhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaXRlcmF0b3IoeCwgZnVuY3Rpb24gKGVyciwgY3JpdGVyaWEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCB7dmFsdWU6IHgsIGNyaXRlcmlhOiBjcml0ZXJpYX0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyLCByZXN1bHRzKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZm4gPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBsZWZ0LmNyaXRlcmlhLCBiID0gcmlnaHQuY3JpdGVyaWE7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogMDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIF9tYXAocmVzdWx0cy5zb3J0KGZuKSwgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHgudmFsdWU7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgYXN5bmMuYXV0byA9IGZ1bmN0aW9uICh0YXNrcywgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgdmFyIGtleXMgPSBfa2V5cyh0YXNrcyk7XG4gICAgICAgIHZhciByZW1haW5pbmdUYXNrcyA9IGtleXMubGVuZ3RoXG4gICAgICAgIGlmICghcmVtYWluaW5nVGFza3MpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdHMgPSB7fTtcblxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gW107XG4gICAgICAgIHZhciBhZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgbGlzdGVuZXJzLnVuc2hpZnQoZm4pO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1tpXSA9PT0gZm4pIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRhc2tDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlbWFpbmluZ1Rhc2tzLS1cbiAgICAgICAgICAgIF9lYWNoKGxpc3RlbmVycy5zbGljZSgwKSwgZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGFkZExpc3RlbmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghcmVtYWluaW5nVGFza3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGhlQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgICAgICAgICAvLyBwcmV2ZW50IGZpbmFsIGNhbGxiYWNrIGZyb20gY2FsbGluZyBpdHNlbGYgaWYgaXQgZXJyb3JzXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgICAgICAgICAgICAgIHRoZUNhbGxiYWNrKG51bGwsIHJlc3VsdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBfZWFjaChrZXlzLCBmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSBfaXNBcnJheSh0YXNrc1trXSkgPyB0YXNrc1trXTogW3Rhc2tzW2tdXTtcbiAgICAgICAgICAgIHZhciB0YXNrQ2FsbGJhY2sgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzYWZlUmVzdWx0cyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBfZWFjaChfa2V5cyhyZXN1bHRzKSwgZnVuY3Rpb24ocmtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2FmZVJlc3VsdHNbcmtleV0gPSByZXN1bHRzW3JrZXldO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc2FmZVJlc3VsdHNba10gPSBhcmdzO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIHNhZmVSZXN1bHRzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RvcCBzdWJzZXF1ZW50IGVycm9ycyBoaXR0aW5nIGNhbGxiYWNrIG11bHRpcGxlIHRpbWVzXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2tdID0gYXJncztcbiAgICAgICAgICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlKHRhc2tDb21wbGV0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciByZXF1aXJlcyA9IHRhc2suc2xpY2UoMCwgTWF0aC5hYnModGFzay5sZW5ndGggLSAxKSkgfHwgW107XG4gICAgICAgICAgICB2YXIgcmVhZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9yZWR1Y2UocmVxdWlyZXMsIGZ1bmN0aW9uIChhLCB4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoYSAmJiByZXN1bHRzLmhhc093blByb3BlcnR5KHgpKTtcbiAgICAgICAgICAgICAgICB9LCB0cnVlKSAmJiAhcmVzdWx0cy5oYXNPd25Qcm9wZXJ0eShrKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAocmVhZHkoKSkge1xuICAgICAgICAgICAgICAgIHRhc2tbdGFzay5sZW5ndGggLSAxXSh0YXNrQ2FsbGJhY2ssIHJlc3VsdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVhZHkoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFza1t0YXNrLmxlbmd0aCAtIDFdKHRhc2tDYWxsYmFjaywgcmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGFkZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGFzeW5jLnJldHJ5ID0gZnVuY3Rpb24odGltZXMsIHRhc2ssIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBERUZBVUxUX1RJTUVTID0gNTtcbiAgICAgICAgdmFyIGF0dGVtcHRzID0gW107XG4gICAgICAgIC8vIFVzZSBkZWZhdWx0cyBpZiB0aW1lcyBub3QgcGFzc2VkXG4gICAgICAgIGlmICh0eXBlb2YgdGltZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gdGFzaztcbiAgICAgICAgICAgIHRhc2sgPSB0aW1lcztcbiAgICAgICAgICAgIHRpbWVzID0gREVGQVVMVF9USU1FUztcbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgdGltZXMgaXMgYSBudW1iZXJcbiAgICAgICAgdGltZXMgPSBwYXJzZUludCh0aW1lcywgMTApIHx8IERFRkFVTFRfVElNRVM7XG4gICAgICAgIHZhciB3cmFwcGVkVGFzayA9IGZ1bmN0aW9uKHdyYXBwZWRDYWxsYmFjaywgd3JhcHBlZFJlc3VsdHMpIHtcbiAgICAgICAgICAgIHZhciByZXRyeUF0dGVtcHQgPSBmdW5jdGlvbih0YXNrLCBmaW5hbEF0dGVtcHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oc2VyaWVzQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdGFzayhmdW5jdGlvbihlcnIsIHJlc3VsdCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNDYWxsYmFjayghZXJyIHx8IGZpbmFsQXR0ZW1wdCwge2VycjogZXJyLCByZXN1bHQ6IHJlc3VsdH0pO1xuICAgICAgICAgICAgICAgICAgICB9LCB3cmFwcGVkUmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3aGlsZSAodGltZXMpIHtcbiAgICAgICAgICAgICAgICBhdHRlbXB0cy5wdXNoKHJldHJ5QXR0ZW1wdCh0YXNrLCAhKHRpbWVzLT0xKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXN5bmMuc2VyaWVzKGF0dGVtcHRzLCBmdW5jdGlvbihkb25lLCBkYXRhKXtcbiAgICAgICAgICAgICAgICBkYXRhID0gZGF0YVtkYXRhLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICh3cmFwcGVkQ2FsbGJhY2sgfHwgY2FsbGJhY2spKGRhdGEuZXJyLCBkYXRhLnJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBhIGNhbGxiYWNrIGlzIHBhc3NlZCwgcnVuIHRoaXMgYXMgYSBjb250cm9sbCBmbG93XG4gICAgICAgIHJldHVybiBjYWxsYmFjayA/IHdyYXBwZWRUYXNrKCkgOiB3cmFwcGVkVGFza1xuICAgIH07XG5cbiAgICBhc3luYy53YXRlcmZhbGwgPSBmdW5jdGlvbiAodGFza3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG4gICAgICAgIGlmICghX2lzQXJyYXkodGFza3MpKSB7XG4gICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgdG8gd2F0ZXJmYWxsIG11c3QgYmUgYW4gYXJyYXkgb2YgZnVuY3Rpb25zJyk7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0YXNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3cmFwSXRlcmF0b3IgPSBmdW5jdGlvbiAoaXRlcmF0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaCh3cmFwSXRlcmF0b3IobmV4dCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3IuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHdyYXBJdGVyYXRvcihhc3luYy5pdGVyYXRvcih0YXNrcykpKCk7XG4gICAgfTtcblxuICAgIHZhciBfcGFyYWxsZWwgPSBmdW5jdGlvbihlYWNoZm4sIHRhc2tzLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICBpZiAoX2lzQXJyYXkodGFza3MpKSB7XG4gICAgICAgICAgICBlYWNoZm4ubWFwKHRhc2tzLCBmdW5jdGlvbiAoZm4sIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICAgICAgICAgIGZuKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKG51bGwsIGVyciwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0ge307XG4gICAgICAgICAgICBlYWNoZm4uZWFjaChfa2V5cyh0YXNrcyksIGZ1bmN0aW9uIChrLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRhc2tzW2tdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1trXSA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGFzeW5jLnBhcmFsbGVsID0gZnVuY3Rpb24gKHRhc2tzLCBjYWxsYmFjaykge1xuICAgICAgICBfcGFyYWxsZWwoeyBtYXA6IGFzeW5jLm1hcCwgZWFjaDogYXN5bmMuZWFjaCB9LCB0YXNrcywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBhc3luYy5wYXJhbGxlbExpbWl0ID0gZnVuY3Rpb24odGFza3MsIGxpbWl0LCBjYWxsYmFjaykge1xuICAgICAgICBfcGFyYWxsZWwoeyBtYXA6IF9tYXBMaW1pdChsaW1pdCksIGVhY2g6IF9lYWNoTGltaXQobGltaXQpIH0sIHRhc2tzLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIGFzeW5jLnNlcmllcyA9IGZ1bmN0aW9uICh0YXNrcywgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgaWYgKF9pc0FycmF5KHRhc2tzKSkge1xuICAgICAgICAgICAgYXN5bmMubWFwU2VyaWVzKHRhc2tzLCBmdW5jdGlvbiAoZm4sIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICAgICAgICAgIGZuKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKG51bGwsIGVyciwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0ge307XG4gICAgICAgICAgICBhc3luYy5lYWNoU2VyaWVzKF9rZXlzKHRhc2tzKSwgZnVuY3Rpb24gKGssIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdGFza3Nba10oZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2tdID0gYXJncztcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgYXN5bmMuaXRlcmF0b3IgPSBmdW5jdGlvbiAodGFza3MpIHtcbiAgICAgICAgdmFyIG1ha2VDYWxsYmFjayA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgdmFyIGZuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh0YXNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFza3NbaW5kZXhdLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmbi5uZXh0KCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm4ubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGluZGV4IDwgdGFza3MubGVuZ3RoIC0gMSkgPyBtYWtlQ2FsbGJhY2soaW5kZXggKyAxKTogbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gZm47XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBtYWtlQ2FsbGJhY2soMCk7XG4gICAgfTtcblxuICAgIGFzeW5jLmFwcGx5ID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShcbiAgICAgICAgICAgICAgICBudWxsLCBhcmdzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIF9jb25jYXQgPSBmdW5jdGlvbiAoZWFjaGZuLCBhcnIsIGZuLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgciA9IFtdO1xuICAgICAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbiAoeCwgY2IpIHtcbiAgICAgICAgICAgIGZuKHgsIGZ1bmN0aW9uIChlcnIsIHkpIHtcbiAgICAgICAgICAgICAgICByID0gci5jb25jYXQoeSB8fCBbXSk7XG4gICAgICAgICAgICAgICAgY2IoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsIHIpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGFzeW5jLmNvbmNhdCA9IGRvUGFyYWxsZWwoX2NvbmNhdCk7XG4gICAgYXN5bmMuY29uY2F0U2VyaWVzID0gZG9TZXJpZXMoX2NvbmNhdCk7XG5cbiAgICBhc3luYy53aGlsc3QgPSBmdW5jdGlvbiAodGVzdCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0ZXN0KCkpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhc3luYy53aGlsc3QodGVzdCwgaXRlcmF0b3IsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBhc3luYy5kb1doaWxzdCA9IGZ1bmN0aW9uIChpdGVyYXRvciwgdGVzdCwgY2FsbGJhY2spIHtcbiAgICAgICAgaXRlcmF0b3IoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgaWYgKHRlc3QuYXBwbHkobnVsbCwgYXJncykpIHtcbiAgICAgICAgICAgICAgICBhc3luYy5kb1doaWxzdChpdGVyYXRvciwgdGVzdCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGFzeW5jLnVudGlsID0gZnVuY3Rpb24gKHRlc3QsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIXRlc3QoKSkge1xuICAgICAgICAgICAgaXRlcmF0b3IoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFzeW5jLnVudGlsKHRlc3QsIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgYXN5bmMuZG9VbnRpbCA9IGZ1bmN0aW9uIChpdGVyYXRvciwgdGVzdCwgY2FsbGJhY2spIHtcbiAgICAgICAgaXRlcmF0b3IoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgaWYgKCF0ZXN0LmFwcGx5KG51bGwsIGFyZ3MpKSB7XG4gICAgICAgICAgICAgICAgYXN5bmMuZG9VbnRpbChpdGVyYXRvciwgdGVzdCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGFzeW5jLnF1ZXVlID0gZnVuY3Rpb24gKHdvcmtlciwgY29uY3VycmVuY3kpIHtcbiAgICAgICAgaWYgKGNvbmN1cnJlbmN5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbmN1cnJlbmN5ID0gMTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBfaW5zZXJ0KHEsIGRhdGEsIHBvcywgY2FsbGJhY2spIHtcbiAgICAgICAgICBpZiAoIXEuc3RhcnRlZCl7XG4gICAgICAgICAgICBxLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIV9pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICAgIGRhdGEgPSBbZGF0YV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKGRhdGEubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAvLyBjYWxsIGRyYWluIGltbWVkaWF0ZWx5IGlmIHRoZXJlIGFyZSBubyB0YXNrc1xuICAgICAgICAgICAgIHJldHVybiBhc3luYy5zZXRJbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgIGlmIChxLmRyYWluKSB7XG4gICAgICAgICAgICAgICAgICAgICBxLmRyYWluKCk7XG4gICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX2VhY2goZGF0YSwgZnVuY3Rpb24odGFzaykge1xuICAgICAgICAgICAgICB2YXIgaXRlbSA9IHtcbiAgICAgICAgICAgICAgICAgIGRhdGE6IHRhc2ssXG4gICAgICAgICAgICAgICAgICBjYWxsYmFjazogdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nID8gY2FsbGJhY2sgOiBudWxsXG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgaWYgKHBvcykge1xuICAgICAgICAgICAgICAgIHEudGFza3MudW5zaGlmdChpdGVtKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBxLnRhc2tzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAocS5zYXR1cmF0ZWQgJiYgcS50YXNrcy5sZW5ndGggPT09IHEuY29uY3VycmVuY3kpIHtcbiAgICAgICAgICAgICAgICAgIHEuc2F0dXJhdGVkKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlKHEucHJvY2Vzcyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgd29ya2VycyA9IDA7XG4gICAgICAgIHZhciBxID0ge1xuICAgICAgICAgICAgdGFza3M6IFtdLFxuICAgICAgICAgICAgY29uY3VycmVuY3k6IGNvbmN1cnJlbmN5LFxuICAgICAgICAgICAgc2F0dXJhdGVkOiBudWxsLFxuICAgICAgICAgICAgZW1wdHk6IG51bGwsXG4gICAgICAgICAgICBkcmFpbjogbnVsbCxcbiAgICAgICAgICAgIHN0YXJ0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgcGF1c2VkOiBmYWxzZSxcbiAgICAgICAgICAgIHB1c2g6IGZ1bmN0aW9uIChkYXRhLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICBfaW5zZXJ0KHEsIGRhdGEsIGZhbHNlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAga2lsbDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBxLmRyYWluID0gbnVsbDtcbiAgICAgICAgICAgICAgcS50YXNrcyA9IFtdO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVuc2hpZnQ6IGZ1bmN0aW9uIChkYXRhLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICBfaW5zZXJ0KHEsIGRhdGEsIHRydWUsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcm9jZXNzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFxLnBhdXNlZCAmJiB3b3JrZXJzIDwgcS5jb25jdXJyZW5jeSAmJiBxLnRhc2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFzayA9IHEudGFza3Muc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHEuZW1wdHkgJiYgcS50YXNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHEuZW1wdHkoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3b3JrZXJzICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd29ya2VycyAtPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhc2suY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXNrLmNhbGxiYWNrLmFwcGx5KHRhc2ssIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocS5kcmFpbiAmJiBxLnRhc2tzLmxlbmd0aCArIHdvcmtlcnMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxLmRyYWluKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBxLnByb2Nlc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNiID0gb25seV9vbmNlKG5leHQpO1xuICAgICAgICAgICAgICAgICAgICB3b3JrZXIodGFzay5kYXRhLCBjYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxlbmd0aDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBxLnRhc2tzLmxlbmd0aDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBydW5uaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdvcmtlcnM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaWRsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHEudGFza3MubGVuZ3RoICsgd29ya2VycyA9PT0gMDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXVzZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChxLnBhdXNlZCA9PT0gdHJ1ZSkgeyByZXR1cm47IH1cbiAgICAgICAgICAgICAgICBxLnBhdXNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcS5wcm9jZXNzKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzdW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHEucGF1c2VkID09PSBmYWxzZSkgeyByZXR1cm47IH1cbiAgICAgICAgICAgICAgICBxLnBhdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHEucHJvY2VzcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcTtcbiAgICB9O1xuICAgIFxuICAgIGFzeW5jLnByaW9yaXR5UXVldWUgPSBmdW5jdGlvbiAod29ya2VyLCBjb25jdXJyZW5jeSkge1xuICAgICAgICBcbiAgICAgICAgZnVuY3Rpb24gX2NvbXBhcmVUYXNrcyhhLCBiKXtcbiAgICAgICAgICByZXR1cm4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHk7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBmdW5jdGlvbiBfYmluYXJ5U2VhcmNoKHNlcXVlbmNlLCBpdGVtLCBjb21wYXJlKSB7XG4gICAgICAgICAgdmFyIGJlZyA9IC0xLFxuICAgICAgICAgICAgICBlbmQgPSBzZXF1ZW5jZS5sZW5ndGggLSAxO1xuICAgICAgICAgIHdoaWxlIChiZWcgPCBlbmQpIHtcbiAgICAgICAgICAgIHZhciBtaWQgPSBiZWcgKyAoKGVuZCAtIGJlZyArIDEpID4+PiAxKTtcbiAgICAgICAgICAgIGlmIChjb21wYXJlKGl0ZW0sIHNlcXVlbmNlW21pZF0pID49IDApIHtcbiAgICAgICAgICAgICAgYmVnID0gbWlkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZW5kID0gbWlkIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGJlZztcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgZnVuY3Rpb24gX2luc2VydChxLCBkYXRhLCBwcmlvcml0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgICBpZiAoIXEuc3RhcnRlZCl7XG4gICAgICAgICAgICBxLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIV9pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICAgIGRhdGEgPSBbZGF0YV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKGRhdGEubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAvLyBjYWxsIGRyYWluIGltbWVkaWF0ZWx5IGlmIHRoZXJlIGFyZSBubyB0YXNrc1xuICAgICAgICAgICAgIHJldHVybiBhc3luYy5zZXRJbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgIGlmIChxLmRyYWluKSB7XG4gICAgICAgICAgICAgICAgICAgICBxLmRyYWluKCk7XG4gICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX2VhY2goZGF0YSwgZnVuY3Rpb24odGFzaykge1xuICAgICAgICAgICAgICB2YXIgaXRlbSA9IHtcbiAgICAgICAgICAgICAgICAgIGRhdGE6IHRhc2ssXG4gICAgICAgICAgICAgICAgICBwcmlvcml0eTogcHJpb3JpdHksXG4gICAgICAgICAgICAgICAgICBjYWxsYmFjazogdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nID8gY2FsbGJhY2sgOiBudWxsXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBxLnRhc2tzLnNwbGljZShfYmluYXJ5U2VhcmNoKHEudGFza3MsIGl0ZW0sIF9jb21wYXJlVGFza3MpICsgMSwgMCwgaXRlbSk7XG5cbiAgICAgICAgICAgICAgaWYgKHEuc2F0dXJhdGVkICYmIHEudGFza3MubGVuZ3RoID09PSBxLmNvbmN1cnJlbmN5KSB7XG4gICAgICAgICAgICAgICAgICBxLnNhdHVyYXRlZCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZShxLnByb2Nlc3MpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBTdGFydCB3aXRoIGEgbm9ybWFsIHF1ZXVlXG4gICAgICAgIHZhciBxID0gYXN5bmMucXVldWUod29ya2VyLCBjb25jdXJyZW5jeSk7XG4gICAgICAgIFxuICAgICAgICAvLyBPdmVycmlkZSBwdXNoIHRvIGFjY2VwdCBzZWNvbmQgcGFyYW1ldGVyIHJlcHJlc2VudGluZyBwcmlvcml0eVxuICAgICAgICBxLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSwgcHJpb3JpdHksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgX2luc2VydChxLCBkYXRhLCBwcmlvcml0eSwgY2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgLy8gUmVtb3ZlIHVuc2hpZnQgZnVuY3Rpb25cbiAgICAgICAgZGVsZXRlIHEudW5zaGlmdDtcblxuICAgICAgICByZXR1cm4gcTtcbiAgICB9O1xuXG4gICAgYXN5bmMuY2FyZ28gPSBmdW5jdGlvbiAod29ya2VyLCBwYXlsb2FkKSB7XG4gICAgICAgIHZhciB3b3JraW5nICAgICA9IGZhbHNlLFxuICAgICAgICAgICAgdGFza3MgICAgICAgPSBbXTtcblxuICAgICAgICB2YXIgY2FyZ28gPSB7XG4gICAgICAgICAgICB0YXNrczogdGFza3MsXG4gICAgICAgICAgICBwYXlsb2FkOiBwYXlsb2FkLFxuICAgICAgICAgICAgc2F0dXJhdGVkOiBudWxsLFxuICAgICAgICAgICAgZW1wdHk6IG51bGwsXG4gICAgICAgICAgICBkcmFpbjogbnVsbCxcbiAgICAgICAgICAgIGRyYWluZWQ6IHRydWUsXG4gICAgICAgICAgICBwdXNoOiBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoIV9pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBbZGF0YV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9lYWNoKGRhdGEsIGZ1bmN0aW9uKHRhc2spIHtcbiAgICAgICAgICAgICAgICAgICAgdGFza3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB0YXNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyA/IGNhbGxiYWNrIDogbnVsbFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY2FyZ28uZHJhaW5lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FyZ28uc2F0dXJhdGVkICYmIHRhc2tzLmxlbmd0aCA9PT0gcGF5bG9hZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FyZ28uc2F0dXJhdGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUoY2FyZ28ucHJvY2Vzcyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJvY2VzczogZnVuY3Rpb24gcHJvY2VzcygpIHtcbiAgICAgICAgICAgICAgICBpZiAod29ya2luZykgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmICh0YXNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoY2FyZ28uZHJhaW4gJiYgIWNhcmdvLmRyYWluZWQpIGNhcmdvLmRyYWluKCk7XG4gICAgICAgICAgICAgICAgICAgIGNhcmdvLmRyYWluZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHRzID0gdHlwZW9mIHBheWxvYWQgPT09ICdudW1iZXInXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0YXNrcy5zcGxpY2UoMCwgcGF5bG9hZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRhc2tzLnNwbGljZSgwLCB0YXNrcy5sZW5ndGgpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGRzID0gX21hcCh0cywgZnVuY3Rpb24gKHRhc2spIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhc2suZGF0YTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmKGNhcmdvLmVtcHR5KSBjYXJnby5lbXB0eSgpO1xuICAgICAgICAgICAgICAgIHdvcmtpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHdvcmtlcihkcywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB3b3JraW5nID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICAgICAgICAgIF9lYWNoKHRzLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGVuZ3RoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhc2tzLmxlbmd0aDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBydW5uaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdvcmtpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjYXJnbztcbiAgICB9O1xuXG4gICAgdmFyIF9jb25zb2xlX2ZuID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncy5jb25jYXQoW2Z1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uc29sZS5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjb25zb2xlW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZWFjaChhcmdzLCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGVbbmFtZV0oeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKSk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBhc3luYy5sb2cgPSBfY29uc29sZV9mbignbG9nJyk7XG4gICAgYXN5bmMuZGlyID0gX2NvbnNvbGVfZm4oJ2RpcicpO1xuICAgIC8qYXN5bmMuaW5mbyA9IF9jb25zb2xlX2ZuKCdpbmZvJyk7XG4gICAgYXN5bmMud2FybiA9IF9jb25zb2xlX2ZuKCd3YXJuJyk7XG4gICAgYXN5bmMuZXJyb3IgPSBfY29uc29sZV9mbignZXJyb3InKTsqL1xuXG4gICAgYXN5bmMubWVtb2l6ZSA9IGZ1bmN0aW9uIChmbiwgaGFzaGVyKSB7XG4gICAgICAgIHZhciBtZW1vID0ge307XG4gICAgICAgIHZhciBxdWV1ZXMgPSB7fTtcbiAgICAgICAgaGFzaGVyID0gaGFzaGVyIHx8IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcbiAgICAgICAgICAgIHZhciBrZXkgPSBoYXNoZXIuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgICBpZiAoa2V5IGluIG1lbW8pIHtcbiAgICAgICAgICAgICAgICBhc3luYy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIG1lbW9ba2V5XSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgaW4gcXVldWVzKSB7XG4gICAgICAgICAgICAgICAgcXVldWVzW2tleV0ucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBxdWV1ZXNba2V5XSA9IFtjYWxsYmFja107XG4gICAgICAgICAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncy5jb25jYXQoW2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVtb1trZXldID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcSA9IHF1ZXVlc1trZXldO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcXVldWVzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICBxW2ldLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBtZW1vaXplZC5tZW1vID0gbWVtbztcbiAgICAgICAgbWVtb2l6ZWQudW5tZW1vaXplZCA9IGZuO1xuICAgICAgICByZXR1cm4gbWVtb2l6ZWQ7XG4gICAgfTtcblxuICAgIGFzeW5jLnVubWVtb2l6ZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChmbi51bm1lbW9pemVkIHx8IGZuKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgYXN5bmMudGltZXMgPSBmdW5jdGlvbiAoY291bnQsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgY291bnRlciA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGNvdW50ZXIucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXN5bmMubWFwKGNvdW50ZXIsIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIGFzeW5jLnRpbWVzU2VyaWVzID0gZnVuY3Rpb24gKGNvdW50LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGNvdW50ZXIgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb3VudGVyLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzeW5jLm1hcFNlcmllcyhjb3VudGVyLCBpdGVyYXRvciwgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBhc3luYy5zZXEgPSBmdW5jdGlvbiAoLyogZnVuY3Rpb25zLi4uICovKSB7XG4gICAgICAgIHZhciBmbnMgPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzLnBvcCgpO1xuICAgICAgICAgICAgYXN5bmMucmVkdWNlKGZucywgYXJncywgZnVuY3Rpb24gKG5ld2FyZ3MsIGZuLCBjYikge1xuICAgICAgICAgICAgICAgIGZuLmFwcGx5KHRoYXQsIG5ld2FyZ3MuY29uY2F0KFtmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnIgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0YXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgICAgIGNiKGVyciwgbmV4dGFyZ3MpO1xuICAgICAgICAgICAgICAgIH1dKSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoZXJyLCByZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodGhhdCwgW2Vycl0uY29uY2F0KHJlc3VsdHMpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBhc3luYy5jb21wb3NlID0gZnVuY3Rpb24gKC8qIGZ1bmN0aW9ucy4uLiAqLykge1xuICAgICAgcmV0dXJuIGFzeW5jLnNlcS5hcHBseShudWxsLCBBcnJheS5wcm90b3R5cGUucmV2ZXJzZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIH07XG5cbiAgICB2YXIgX2FwcGx5RWFjaCA9IGZ1bmN0aW9uIChlYWNoZm4sIGZucyAvKmFyZ3MuLi4qLykge1xuICAgICAgICB2YXIgZ28gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzLnBvcCgpO1xuICAgICAgICAgICAgcmV0dXJuIGVhY2hmbihmbnMsIGZ1bmN0aW9uIChmbiwgY2IpIHtcbiAgICAgICAgICAgICAgICBmbi5hcHBseSh0aGF0LCBhcmdzLmNvbmNhdChbY2JdKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICAgICAgICAgIHJldHVybiBnby5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBnbztcbiAgICAgICAgfVxuICAgIH07XG4gICAgYXN5bmMuYXBwbHlFYWNoID0gZG9QYXJhbGxlbChfYXBwbHlFYWNoKTtcbiAgICBhc3luYy5hcHBseUVhY2hTZXJpZXMgPSBkb1NlcmllcyhfYXBwbHlFYWNoKTtcblxuICAgIGFzeW5jLmZvcmV2ZXIgPSBmdW5jdGlvbiAoZm4sIGNhbGxiYWNrKSB7XG4gICAgICAgIGZ1bmN0aW9uIG5leHQoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmbihuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0KCk7XG4gICAgfTtcblxuICAgIC8vIE5vZGUuanNcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBhc3luYztcbiAgICB9XG4gICAgLy8gQU1EIC8gUmVxdWlyZUpTXG4gICAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSAhPT0gJ3VuZGVmaW5lZCcgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoW10sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBhc3luYztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGluY2x1ZGVkIGRpcmVjdGx5IHZpYSA8c2NyaXB0PiB0YWdcbiAgICBlbHNlIHtcbiAgICAgICAgcm9vdC5hc3luYyA9IGFzeW5jO1xuICAgIH1cblxufSgpKTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiLypcbiAqIGJhc2U2NC1hcnJheWJ1ZmZlclxuICogaHR0cHM6Ly9naXRodWIuY29tL25pa2xhc3ZoL2Jhc2U2NC1hcnJheWJ1ZmZlclxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMiBOaWtsYXMgdm9uIEhlcnR6ZW5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqL1xuKGZ1bmN0aW9uKGNoYXJzKXtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbihhcnJheWJ1ZmZlcikge1xuICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKSxcbiAgICBpLCBsZW4gPSBieXRlcy5sZW5ndGgsIGJhc2U2NCA9IFwiXCI7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKz0zKSB7XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaV0gPj4gMl07XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbKChieXRlc1tpXSAmIDMpIDw8IDQpIHwgKGJ5dGVzW2kgKyAxXSA+PiA0KV07XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbKChieXRlc1tpICsgMV0gJiAxNSkgPDwgMikgfCAoYnl0ZXNbaSArIDJdID4+IDYpXTtcbiAgICAgIGJhc2U2NCArPSBjaGFyc1tieXRlc1tpICsgMl0gJiA2M107XG4gICAgfVxuXG4gICAgaWYgKChsZW4gJSAzKSA9PT0gMikge1xuICAgICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMSkgKyBcIj1cIjtcbiAgICB9IGVsc2UgaWYgKGxlbiAlIDMgPT09IDEpIHtcbiAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDIpICsgXCI9PVwiO1xuICAgIH1cblxuICAgIHJldHVybiBiYXNlNjQ7XG4gIH07XG5cbiAgZXhwb3J0cy5kZWNvZGUgPSAgZnVuY3Rpb24oYmFzZTY0KSB7XG4gICAgdmFyIGJ1ZmZlckxlbmd0aCA9IGJhc2U2NC5sZW5ndGggKiAwLjc1LFxuICAgIGxlbiA9IGJhc2U2NC5sZW5ndGgsIGksIHAgPSAwLFxuICAgIGVuY29kZWQxLCBlbmNvZGVkMiwgZW5jb2RlZDMsIGVuY29kZWQ0O1xuXG4gICAgaWYgKGJhc2U2NFtiYXNlNjQubGVuZ3RoIC0gMV0gPT09IFwiPVwiKSB7XG4gICAgICBidWZmZXJMZW5ndGgtLTtcbiAgICAgIGlmIChiYXNlNjRbYmFzZTY0Lmxlbmd0aCAtIDJdID09PSBcIj1cIikge1xuICAgICAgICBidWZmZXJMZW5ndGgtLTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYXJyYXlidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnVmZmVyTGVuZ3RoKSxcbiAgICBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrPTQpIHtcbiAgICAgIGVuY29kZWQxID0gY2hhcnMuaW5kZXhPZihiYXNlNjRbaV0pO1xuICAgICAgZW5jb2RlZDIgPSBjaGFycy5pbmRleE9mKGJhc2U2NFtpKzFdKTtcbiAgICAgIGVuY29kZWQzID0gY2hhcnMuaW5kZXhPZihiYXNlNjRbaSsyXSk7XG4gICAgICBlbmNvZGVkNCA9IGNoYXJzLmluZGV4T2YoYmFzZTY0W2krM10pO1xuXG4gICAgICBieXRlc1twKytdID0gKGVuY29kZWQxIDw8IDIpIHwgKGVuY29kZWQyID4+IDQpO1xuICAgICAgYnl0ZXNbcCsrXSA9ICgoZW5jb2RlZDIgJiAxNSkgPDwgNCkgfCAoZW5jb2RlZDMgPj4gMik7XG4gICAgICBieXRlc1twKytdID0gKChlbmNvZGVkMyAmIDMpIDw8IDYpIHwgKGVuY29kZWQ0ICYgNjMpO1xuICAgIH1cblxuICAgIHJldHVybiBhcnJheWJ1ZmZlcjtcbiAgfTtcbn0pKFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiKTtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnByb2Nlc3MubmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYW5TZXRJbW1lZGlhdGUgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5zZXRJbW1lZGlhdGU7XG4gICAgdmFyIGNhblBvc3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5wb3N0TWVzc2FnZSAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lclxuICAgIDtcblxuICAgIGlmIChjYW5TZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmKSB7IHJldHVybiB3aW5kb3cuc2V0SW1tZWRpYXRlKGYpIH07XG4gICAgfVxuXG4gICAgaWYgKGNhblBvc3QpIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gW107XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gZXYuc291cmNlO1xuICAgICAgICAgICAgaWYgKChzb3VyY2UgPT09IHdpbmRvdyB8fCBzb3VyY2UgPT09IG51bGwpICYmIGV2LmRhdGEgPT09ICdwcm9jZXNzLXRpY2snKSB7XG4gICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZuID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRydWUpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICAgICAgcXVldWUucHVzaChmbik7XG4gICAgICAgICAgICB3aW5kb3cucG9zdE1lc3NhZ2UoJ3Byb2Nlc3MtdGljaycsICcqJyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZm4sIDApO1xuICAgIH07XG59KSgpO1xuXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn1cblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuIiwiLyoqXG4gKiBjdWlkLmpzXG4gKiBDb2xsaXNpb24tcmVzaXN0YW50IFVJRCBnZW5lcmF0b3IgZm9yIGJyb3dzZXJzIGFuZCBub2RlLlxuICogU2VxdWVudGlhbCBmb3IgZmFzdCBkYiBsb29rdXBzIGFuZCByZWNlbmN5IHNvcnRpbmcuXG4gKiBTYWZlIGZvciBlbGVtZW50IElEcyBhbmQgc2VydmVyLXNpZGUgbG9va3Vwcy5cbiAqXG4gKiBFeHRyYWN0ZWQgZnJvbSBDTENUUlxuICogXG4gKiBDb3B5cmlnaHQgKGMpIEVyaWMgRWxsaW90dCAyMDEyXG4gKiBNSVQgTGljZW5zZVxuICovXG5cbi8qZ2xvYmFsIHdpbmRvdywgbmF2aWdhdG9yLCBkb2N1bWVudCwgcmVxdWlyZSwgcHJvY2VzcywgbW9kdWxlICovXG4oZnVuY3Rpb24gKGFwcCkge1xuICAndXNlIHN0cmljdCc7XG4gIHZhciBuYW1lc3BhY2UgPSAnY3VpZCcsXG4gICAgYyA9IDAsXG4gICAgYmxvY2tTaXplID0gNCxcbiAgICBiYXNlID0gMzYsXG4gICAgZGlzY3JldGVWYWx1ZXMgPSBNYXRoLnBvdyhiYXNlLCBibG9ja1NpemUpLFxuXG4gICAgcGFkID0gZnVuY3Rpb24gcGFkKG51bSwgc2l6ZSkge1xuICAgICAgdmFyIHMgPSBcIjAwMDAwMDAwMFwiICsgbnVtO1xuICAgICAgcmV0dXJuIHMuc3Vic3RyKHMubGVuZ3RoLXNpemUpO1xuICAgIH0sXG5cbiAgICByYW5kb21CbG9jayA9IGZ1bmN0aW9uIHJhbmRvbUJsb2NrKCkge1xuICAgICAgcmV0dXJuIHBhZCgoTWF0aC5yYW5kb20oKSAqXG4gICAgICAgICAgICBkaXNjcmV0ZVZhbHVlcyA8PCAwKVxuICAgICAgICAgICAgLnRvU3RyaW5nKGJhc2UpLCBibG9ja1NpemUpO1xuICAgIH0sXG5cbiAgICBzYWZlQ291bnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGMgPSAoYyA8IGRpc2NyZXRlVmFsdWVzKSA/IGMgOiAwO1xuICAgICAgYysrOyAvLyB0aGlzIGlzIG5vdCBzdWJsaW1pbmFsXG4gICAgICByZXR1cm4gYyAtIDE7XG4gICAgfSxcblxuICAgIGFwaSA9IGZ1bmN0aW9uIGN1aWQoKSB7XG4gICAgICAvLyBTdGFydGluZyB3aXRoIGEgbG93ZXJjYXNlIGxldHRlciBtYWtlc1xuICAgICAgLy8gaXQgSFRNTCBlbGVtZW50IElEIGZyaWVuZGx5LlxuICAgICAgdmFyIGxldHRlciA9ICdjJywgLy8gaGFyZC1jb2RlZCBhbGxvd3MgZm9yIHNlcXVlbnRpYWwgYWNjZXNzXG5cbiAgICAgICAgLy8gdGltZXN0YW1wXG4gICAgICAgIC8vIHdhcm5pbmc6IHRoaXMgZXhwb3NlcyB0aGUgZXhhY3QgZGF0ZSBhbmQgdGltZVxuICAgICAgICAvLyB0aGF0IHRoZSB1aWQgd2FzIGNyZWF0ZWQuXG4gICAgICAgIHRpbWVzdGFtcCA9IChuZXcgRGF0ZSgpLmdldFRpbWUoKSkudG9TdHJpbmcoYmFzZSksXG5cbiAgICAgICAgLy8gUHJldmVudCBzYW1lLW1hY2hpbmUgY29sbGlzaW9ucy5cbiAgICAgICAgY291bnRlcixcblxuICAgICAgICAvLyBBIGZldyBjaGFycyB0byBnZW5lcmF0ZSBkaXN0aW5jdCBpZHMgZm9yIGRpZmZlcmVudFxuICAgICAgICAvLyBjbGllbnRzIChzbyBkaWZmZXJlbnQgY29tcHV0ZXJzIGFyZSBmYXIgbGVzc1xuICAgICAgICAvLyBsaWtlbHkgdG8gZ2VuZXJhdGUgdGhlIHNhbWUgaWQpXG4gICAgICAgIGZpbmdlcnByaW50ID0gYXBpLmZpbmdlcnByaW50KCksXG5cbiAgICAgICAgLy8gR3JhYiBzb21lIG1vcmUgY2hhcnMgZnJvbSBNYXRoLnJhbmRvbSgpXG4gICAgICAgIHJhbmRvbSA9IHJhbmRvbUJsb2NrKCkgKyByYW5kb21CbG9jaygpO1xuXG4gICAgICAgIGNvdW50ZXIgPSBwYWQoc2FmZUNvdW50ZXIoKS50b1N0cmluZyhiYXNlKSwgYmxvY2tTaXplKTtcblxuICAgICAgcmV0dXJuICAobGV0dGVyICsgdGltZXN0YW1wICsgY291bnRlciArIGZpbmdlcnByaW50ICsgcmFuZG9tKTtcbiAgICB9O1xuXG4gIGFwaS5zbHVnID0gZnVuY3Rpb24gc2x1ZygpIHtcbiAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpLnRvU3RyaW5nKDM2KSxcbiAgICAgIGNvdW50ZXIsXG4gICAgICBwcmludCA9IGFwaS5maW5nZXJwcmludCgpLnNsaWNlKDAsMSkgK1xuICAgICAgICBhcGkuZmluZ2VycHJpbnQoKS5zbGljZSgtMSksXG4gICAgICByYW5kb20gPSByYW5kb21CbG9jaygpLnNsaWNlKC0yKTtcblxuICAgICAgY291bnRlciA9IHNhZmVDb3VudGVyKCkudG9TdHJpbmcoMzYpLnNsaWNlKC00KTtcblxuICAgIHJldHVybiBkYXRlLnNsaWNlKC0yKSArIFxuICAgICAgY291bnRlciArIHByaW50ICsgcmFuZG9tO1xuICB9O1xuXG4gIGFwaS5nbG9iYWxDb3VudCA9IGZ1bmN0aW9uIGdsb2JhbENvdW50KCkge1xuICAgIC8vIFdlIHdhbnQgdG8gY2FjaGUgdGhlIHJlc3VsdHMgb2YgdGhpc1xuICAgIHZhciBjYWNoZSA9IChmdW5jdGlvbiBjYWxjKCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICBjb3VudCA9IDA7XG5cbiAgICAgICAgZm9yIChpIGluIHdpbmRvdykge1xuICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgICB9KCkpO1xuXG4gICAgYXBpLmdsb2JhbENvdW50ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FjaGU7IH07XG4gICAgcmV0dXJuIGNhY2hlO1xuICB9O1xuXG4gIGFwaS5maW5nZXJwcmludCA9IGZ1bmN0aW9uIGJyb3dzZXJQcmludCgpIHtcbiAgICByZXR1cm4gcGFkKChuYXZpZ2F0b3IubWltZVR5cGVzLmxlbmd0aCArXG4gICAgICBuYXZpZ2F0b3IudXNlckFnZW50Lmxlbmd0aCkudG9TdHJpbmcoMzYpICtcbiAgICAgIGFwaS5nbG9iYWxDb3VudCgpLnRvU3RyaW5nKDM2KSwgNCk7XG4gIH07XG5cbiAgLy8gZG9uJ3QgY2hhbmdlIGFueXRoaW5nIGZyb20gaGVyZSBkb3duLlxuICBpZiAoYXBwLnJlZ2lzdGVyKSB7XG4gICAgYXBwLnJlZ2lzdGVyKG5hbWVzcGFjZSwgYXBpKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gYXBpO1xuICB9IGVsc2Uge1xuICAgIGFwcFtuYW1lc3BhY2VdID0gYXBpO1xuICB9XG5cbn0odGhpcy5hcHBsaXR1ZGUgfHwgdGhpcykpO1xuIiwiLyoqXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE0LCBGYWNlYm9vaywgSW5jLlxuICogIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5mdW5jdGlvbiB1bml2ZXJzYWxNb2R1bGUoKSB7XG4gIHZhciAkT2JqZWN0ID0gT2JqZWN0O1xuXG5mdW5jdGlvbiBjcmVhdGVDbGFzcyhjdG9yLCBtZXRob2RzLCBzdGF0aWNNZXRob2RzLCBzdXBlckNsYXNzKSB7XG4gIHZhciBwcm90bztcbiAgaWYgKHN1cGVyQ2xhc3MpIHtcbiAgICB2YXIgc3VwZXJQcm90byA9IHN1cGVyQ2xhc3MucHJvdG90eXBlO1xuICAgIHByb3RvID0gJE9iamVjdC5jcmVhdGUoc3VwZXJQcm90byk7XG4gIH0gZWxzZSB7XG4gICAgcHJvdG8gPSBjdG9yLnByb3RvdHlwZTtcbiAgfVxuICAkT2JqZWN0LmtleXMobWV0aG9kcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcHJvdG9ba2V5XSA9IG1ldGhvZHNba2V5XTtcbiAgfSk7XG4gICRPYmplY3Qua2V5cyhzdGF0aWNNZXRob2RzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBjdG9yW2tleV0gPSBzdGF0aWNNZXRob2RzW2tleV07XG4gIH0pO1xuICBwcm90by5jb25zdHJ1Y3RvciA9IGN0b3I7XG4gIGN0b3IucHJvdG90eXBlID0gcHJvdG87XG4gIHJldHVybiBjdG9yO1xufVxuXG5mdW5jdGlvbiBzdXBlckNhbGwoc2VsZiwgcHJvdG8sIG5hbWUsIGFyZ3MpIHtcbiAgcmV0dXJuICRPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pW25hbWVdLmFwcGx5KHNlbGYsIGFyZ3MpO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0U3VwZXJDYWxsKHNlbGYsIHByb3RvLCBhcmdzKSB7XG4gIHN1cGVyQ2FsbChzZWxmLCBwcm90bywgJ2NvbnN0cnVjdG9yJywgYXJncyk7XG59XG5cbnZhciAkdHJhY2V1clJ1bnRpbWUgPSB7fTtcbiR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcyA9IGNyZWF0ZUNsYXNzO1xuJHRyYWNldXJSdW50aW1lLnN1cGVyQ2FsbCA9IHN1cGVyQ2FsbDtcbiR0cmFjZXVyUnVudGltZS5kZWZhdWx0U3VwZXJDYWxsID0gZGVmYXVsdFN1cGVyQ2FsbDtcblwidXNlIHN0cmljdFwiO1xudmFyIFNISUZUID0gNTtcbnZhciBTSVpFID0gMSA8PCBTSElGVDtcbnZhciBNQVNLID0gU0laRSAtIDE7XG52YXIgTk9UX1NFVCA9IHt9O1xudmFyIENIQU5HRV9MRU5HVEggPSB7dmFsdWU6IGZhbHNlfTtcbnZhciBESURfQUxURVIgPSB7dmFsdWU6IGZhbHNlfTtcbmZ1bmN0aW9uIE1ha2VSZWYocmVmKSB7XG4gIHJlZi52YWx1ZSA9IGZhbHNlO1xuICByZXR1cm4gcmVmO1xufVxuZnVuY3Rpb24gU2V0UmVmKHJlZikge1xuICByZWYgJiYgKHJlZi52YWx1ZSA9IHRydWUpO1xufVxuZnVuY3Rpb24gT3duZXJJRCgpIHt9XG5mdW5jdGlvbiBhcnJDb3B5KGFyciwgb2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICB2YXIgbGVuID0gTWF0aC5tYXgoMCwgYXJyLmxlbmd0aCAtIG9mZnNldCk7XG4gIHZhciBuZXdBcnIgPSBuZXcgQXJyYXkobGVuKTtcbiAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGxlbjsgaWkrKykge1xuICAgIG5ld0FycltpaV0gPSBhcnJbaWkgKyBvZmZzZXRdO1xuICB9XG4gIHJldHVybiBuZXdBcnI7XG59XG52YXIgSVRFUl9SRVNVTFQgPSB7XG4gIHZhbHVlOiB1bmRlZmluZWQsXG4gIGRvbmU6IGZhbHNlXG59O1xuZnVuY3Rpb24gaXRlcmF0b3JWYWx1ZSh2YWx1ZSkge1xuICBJVEVSX1JFU1VMVC52YWx1ZSA9IHZhbHVlO1xuICBJVEVSX1JFU1VMVC5kb25lID0gZmFsc2U7XG4gIHJldHVybiBJVEVSX1JFU1VMVDtcbn1cbmZ1bmN0aW9uIGl0ZXJhdG9yRG9uZSgpIHtcbiAgSVRFUl9SRVNVTFQudmFsdWUgPSB1bmRlZmluZWQ7XG4gIElURVJfUkVTVUxULmRvbmUgPSB0cnVlO1xuICByZXR1cm4gSVRFUl9SRVNVTFQ7XG59XG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBlcnJvcikge1xuICBpZiAoIWNvbmRpdGlvbilcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpO1xufVxudmFyIERFTEVURSA9ICdkZWxldGUnO1xudmFyIElURVJBVE9SID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgPyBTeW1ib2wuaXRlcmF0b3IgOiAnQEBpdGVyYXRvcic7XG5mdW5jdGlvbiBoYXNoKG8pIHtcbiAgaWYgKCFvKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKG8gPT09IHRydWUpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiBvO1xuICBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAoKG8gfCAwKSA9PT0gbykge1xuICAgICAgcmV0dXJuIG8gJiBIQVNIX01BWF9WQUw7XG4gICAgfVxuICAgIG8gPSAnJyArIG87XG4gICAgdHlwZSA9ICdzdHJpbmcnO1xuICB9XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBvLmxlbmd0aCA+IFNUUklOR19IQVNIX0NBQ0hFX01JTl9TVFJMRU4gPyBjYWNoZWRIYXNoU3RyaW5nKG8pIDogaGFzaFN0cmluZyhvKTtcbiAgfVxuICBpZiAoby5oYXNoQ29kZSkge1xuICAgIHJldHVybiBoYXNoKHR5cGVvZiBvLmhhc2hDb2RlID09PSAnZnVuY3Rpb24nID8gby5oYXNoQ29kZSgpIDogby5oYXNoQ29kZSk7XG4gIH1cbiAgcmV0dXJuIGhhc2hKU09iaihvKTtcbn1cbmZ1bmN0aW9uIGNhY2hlZEhhc2hTdHJpbmcoc3RyaW5nKSB7XG4gIHZhciBoYXNoID0gU1RSSU5HX0hBU0hfQ0FDSEVbc3RyaW5nXTtcbiAgaWYgKGhhc2ggPT0gbnVsbCkge1xuICAgIGhhc2ggPSBoYXNoU3RyaW5nKHN0cmluZyk7XG4gICAgaWYgKFNUUklOR19IQVNIX0NBQ0hFX1NJWkUgPT09IFNUUklOR19IQVNIX0NBQ0hFX01BWF9TSVpFKSB7XG4gICAgICBTVFJJTkdfSEFTSF9DQUNIRV9TSVpFID0gMDtcbiAgICAgIFNUUklOR19IQVNIX0NBQ0hFID0ge307XG4gICAgfVxuICAgIFNUUklOR19IQVNIX0NBQ0hFX1NJWkUrKztcbiAgICBTVFJJTkdfSEFTSF9DQUNIRVtzdHJpbmddID0gaGFzaDtcbiAgfVxuICByZXR1cm4gaGFzaDtcbn1cbmZ1bmN0aW9uIGhhc2hTdHJpbmcoc3RyaW5nKSB7XG4gIHZhciBoYXNoID0gMDtcbiAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IHN0cmluZy5sZW5ndGg7IGlpKyspIHtcbiAgICBoYXNoID0gKDMxICogaGFzaCArIHN0cmluZy5jaGFyQ29kZUF0KGlpKSkgJiBIQVNIX01BWF9WQUw7XG4gIH1cbiAgcmV0dXJuIGhhc2g7XG59XG5mdW5jdGlvbiBoYXNoSlNPYmoob2JqKSB7XG4gIGlmIChvYmpbVUlEX0hBU0hfS0VZXSkge1xuICAgIHJldHVybiBvYmpbVUlEX0hBU0hfS0VZXTtcbiAgfVxuICB2YXIgdWlkID0gKytVSURfSEFTSF9DT1VOVCAmIEhBU0hfTUFYX1ZBTDtcbiAgaWYgKCFpc0lFOCkge1xuICAgIHRyeSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBVSURfSEFTSF9LRVksIHtcbiAgICAgICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAgICAgJ2NvbmZpZ3VyYWJsZSc6IGZhbHNlLFxuICAgICAgICAnd3JpdGFibGUnOiBmYWxzZSxcbiAgICAgICAgJ3ZhbHVlJzogdWlkXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB1aWQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaXNJRTggPSB0cnVlO1xuICAgIH1cbiAgfVxuICBvYmpbVUlEX0hBU0hfS0VZXSA9IHVpZDtcbiAgcmV0dXJuIHVpZDtcbn1cbnZhciBIQVNIX01BWF9WQUwgPSAweDdGRkZGRkZGO1xudmFyIFVJRF9IQVNIX0NPVU5UID0gMDtcbnZhciBVSURfSEFTSF9LRVkgPSAnX19pbW11dGFibGVoYXNoX18nO1xuaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnKSB7XG4gIFVJRF9IQVNIX0tFWSA9IFN5bWJvbChVSURfSEFTSF9LRVkpO1xufVxudmFyIGlzSUU4ID0gZmFsc2U7XG52YXIgU1RSSU5HX0hBU0hfQ0FDSEVfTUlOX1NUUkxFTiA9IDE2O1xudmFyIFNUUklOR19IQVNIX0NBQ0hFX01BWF9TSVpFID0gMjU1O1xudmFyIFNUUklOR19IQVNIX0NBQ0hFX1NJWkUgPSAwO1xudmFyIFNUUklOR19IQVNIX0NBQ0hFID0ge307XG52YXIgU2VxdWVuY2UgPSBmdW5jdGlvbiBTZXF1ZW5jZSh2YWx1ZSkge1xuICByZXR1cm4gJFNlcXVlbmNlLmZyb20oYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IHZhbHVlIDogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG59O1xudmFyICRTZXF1ZW5jZSA9IFNlcXVlbmNlO1xuKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoU2VxdWVuY2UsIHtcbiAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9fdG9TdHJpbmcoJ1NlcSB7JywgJ30nKTtcbiAgfSxcbiAgX190b1N0cmluZzogZnVuY3Rpb24oaGVhZCwgdGFpbCkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGhlYWQgKyB0YWlsO1xuICAgIH1cbiAgICByZXR1cm4gaGVhZCArICcgJyArIHRoaXMubWFwKHRoaXMuX190b1N0cmluZ01hcHBlcikuam9pbignLCAnKSArICcgJyArIHRhaWw7XG4gIH0sXG4gIF9fdG9TdHJpbmdNYXBwZXI6IGZ1bmN0aW9uKHYsIGspIHtcbiAgICByZXR1cm4gayArICc6ICcgKyBxdW90ZVN0cmluZyh2KTtcbiAgfSxcbiAgdG9KUzogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgJFNlcXVlbmNlID8gdmFsdWUudG9KUygpIDogdmFsdWU7XG4gICAgfSkpLl9fdG9KUygpO1xuICB9LFxuICB0b0FycmF5OiBmdW5jdGlvbigpIHtcbiAgICBhc3NlcnROb3RJbmZpbml0ZSh0aGlzLmxlbmd0aCk7XG4gICAgdmFyIGFycmF5ID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoIHx8IDApO1xuICAgIHRoaXMudmFsdWVTZXEoKS5mb3JFYWNoKChmdW5jdGlvbih2LCBpKSB7XG4gICAgICBhcnJheVtpXSA9IHY7XG4gICAgfSkpO1xuICAgIHJldHVybiBhcnJheTtcbiAgfSxcbiAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgIGFzc2VydE5vdEluZmluaXRlKHRoaXMubGVuZ3RoKTtcbiAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgdGhpcy5mb3JFYWNoKChmdW5jdGlvbih2LCBrKSB7XG4gICAgICBvYmplY3Rba10gPSB2O1xuICAgIH0pKTtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9LFxuICB0b1ZlY3RvcjogZnVuY3Rpb24oKSB7XG4gICAgYXNzZXJ0Tm90SW5maW5pdGUodGhpcy5sZW5ndGgpO1xuICAgIHJldHVybiBWZWN0b3IuZnJvbSh0aGlzKTtcbiAgfSxcbiAgdG9NYXA6IGZ1bmN0aW9uKCkge1xuICAgIGFzc2VydE5vdEluZmluaXRlKHRoaXMubGVuZ3RoKTtcbiAgICByZXR1cm4gTWFwLmZyb20odGhpcyk7XG4gIH0sXG4gIHRvT3JkZXJlZE1hcDogZnVuY3Rpb24oKSB7XG4gICAgYXNzZXJ0Tm90SW5maW5pdGUodGhpcy5sZW5ndGgpO1xuICAgIHJldHVybiBPcmRlcmVkTWFwLmZyb20odGhpcyk7XG4gIH0sXG4gIHRvU2V0OiBmdW5jdGlvbigpIHtcbiAgICBhc3NlcnROb3RJbmZpbml0ZSh0aGlzLmxlbmd0aCk7XG4gICAgcmV0dXJuIFNldC5mcm9tKHRoaXMpO1xuICB9LFxuICBoYXNoQ29kZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX19oYXNoIHx8ICh0aGlzLl9faGFzaCA9IHRoaXMubGVuZ3RoID09PSBJbmZpbml0eSA/IDAgOiB0aGlzLnJlZHVjZSgoZnVuY3Rpb24oaCwgdiwgaykge1xuICAgICAgcmV0dXJuIChoICsgKGhhc2godikgXiAodiA9PT0gayA/IDAgOiBoYXNoKGspKSkpICYgSEFTSF9NQVhfVkFMO1xuICAgIH0pLCAwKSk7XG4gIH0sXG4gIGVxdWFsczogZnVuY3Rpb24ob3RoZXIpIHtcbiAgICBpZiAodGhpcyA9PT0gb3RoZXIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mICRTZXF1ZW5jZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRoaXMubGVuZ3RoICE9IG51bGwgJiYgb3RoZXIubGVuZ3RoICE9IG51bGwpIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCAhPT0gb3RoZXIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCAmJiBvdGhlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLl9faGFzaCAhPSBudWxsICYmIG90aGVyLl9faGFzaCAhPSBudWxsICYmIHRoaXMuX19oYXNoICE9PSBvdGhlci5fX2hhc2gpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX19kZWVwRXF1YWxzKG90aGVyKTtcbiAgfSxcbiAgX19kZWVwRXF1YWxzOiBmdW5jdGlvbihvdGhlcikge1xuICAgIHZhciBlbnRyaWVzID0gdGhpcy5jYWNoZVJlc3VsdCgpLmVudHJ5U2VxKCkudG9BcnJheSgpO1xuICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICByZXR1cm4gb3RoZXIuZXZlcnkoKGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaXRlcmF0aW9ucysrXTtcbiAgICAgIHJldHVybiBpcyhrLCBlbnRyeVswXSkgJiYgaXModiwgZW50cnlbMV0pO1xuICAgIH0pKTtcbiAgfSxcbiAgam9pbjogZnVuY3Rpb24oc2VwYXJhdG9yKSB7XG4gICAgc2VwYXJhdG9yID0gc2VwYXJhdG9yIHx8ICcsJztcbiAgICB2YXIgc3RyaW5nID0gJyc7XG4gICAgdmFyIGlzRmlyc3QgPSB0cnVlO1xuICAgIHRoaXMuZm9yRWFjaCgoZnVuY3Rpb24odiwgaykge1xuICAgICAgaWYgKGlzRmlyc3QpIHtcbiAgICAgICAgaXNGaXJzdCA9IGZhbHNlO1xuICAgICAgICBzdHJpbmcgKz0gdjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cmluZyArPSBzZXBhcmF0b3IgKyB2O1xuICAgICAgfVxuICAgIH0pKTtcbiAgICByZXR1cm4gc3RyaW5nO1xuICB9LFxuICBjb3VudDogZnVuY3Rpb24ocHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgaWYgKCFwcmVkaWNhdGUpIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5mb3JFYWNoKHJldHVyblRydWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maWx0ZXIocHJlZGljYXRlLCB0aGlzQXJnKS5jb3VudCgpO1xuICB9LFxuICBjb3VudEJ5OiBmdW5jdGlvbihtYXBwZXIsIGNvbnRleHQpIHtcbiAgICB2YXIgc2VxID0gdGhpcztcbiAgICByZXR1cm4gT3JkZXJlZE1hcC5lbXB0eSgpLndpdGhNdXRhdGlvbnMoKGZ1bmN0aW9uKG1hcCkge1xuICAgICAgc2VxLmZvckVhY2goKGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgbWFwLnVwZGF0ZShtYXBwZXIodmFsdWUsIGtleSwgY29sbGVjdGlvbiksIGluY3JlbWVudCk7XG4gICAgICB9KSk7XG4gICAgfSkpO1xuICB9LFxuICBjb25jYXQ6IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIHZhbHVlcyA9IFtdLFxuICAgICAgICAkX18xID0gMDsgJF9fMSA8IGFyZ3VtZW50cy5sZW5ndGg7ICRfXzErKylcbiAgICAgIHZhbHVlc1skX18xXSA9IGFyZ3VtZW50c1skX18xXTtcbiAgICB2YXIgc2VxdWVuY2VzID0gW3RoaXNdLmNvbmNhdCh2YWx1ZXMubWFwKChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuICRTZXF1ZW5jZSh2YWx1ZSk7XG4gICAgfSkpKTtcbiAgICB2YXIgY29uY2F0U2VxdWVuY2UgPSB0aGlzLl9fbWFrZVNlcXVlbmNlKCk7XG4gICAgY29uY2F0U2VxdWVuY2UubGVuZ3RoID0gc2VxdWVuY2VzLnJlZHVjZSgoZnVuY3Rpb24oc3VtLCBzZXEpIHtcbiAgICAgIHJldHVybiBzdW0gIT0gbnVsbCAmJiBzZXEubGVuZ3RoICE9IG51bGwgPyBzdW0gKyBzZXEubGVuZ3RoIDogdW5kZWZpbmVkO1xuICAgIH0pLCAwKTtcbiAgICBjb25jYXRTZXF1ZW5jZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IChmdW5jdGlvbihmbiwgcmV2ZXJzZSkge1xuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgdmFyIHN0b3BwZWRJdGVyYXRpb247XG4gICAgICB2YXIgbGFzdEluZGV4ID0gc2VxdWVuY2VzLmxlbmd0aCAtIDE7XG4gICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDw9IGxhc3RJbmRleCAmJiAhc3RvcHBlZEl0ZXJhdGlvbjsgaWkrKykge1xuICAgICAgICB2YXIgc2VxID0gc2VxdWVuY2VzW3JldmVyc2UgPyBsYXN0SW5kZXggLSBpaSA6IGlpXTtcbiAgICAgICAgaXRlcmF0aW9ucyArPSBzZXEuX19pdGVyYXRlKChmdW5jdGlvbih2LCBrLCBjKSB7XG4gICAgICAgICAgaWYgKGZuKHYsIGssIGMpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgc3RvcHBlZEl0ZXJhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9KSwgcmV2ZXJzZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgICB9KTtcbiAgICByZXR1cm4gY29uY2F0U2VxdWVuY2U7XG4gIH0sXG4gIHJldmVyc2U6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZXF1ZW5jZSA9IHRoaXM7XG4gICAgdmFyIHJldmVyc2VkU2VxdWVuY2UgPSBzZXF1ZW5jZS5fX21ha2VTZXF1ZW5jZSgpO1xuICAgIHJldmVyc2VkU2VxdWVuY2UubGVuZ3RoID0gc2VxdWVuY2UubGVuZ3RoO1xuICAgIHJldmVyc2VkU2VxdWVuY2UuX19pdGVyYXRlVW5jYWNoZWQgPSAoZnVuY3Rpb24oZm4sIHJldmVyc2UpIHtcbiAgICAgIHJldHVybiBzZXF1ZW5jZS5fX2l0ZXJhdGUoZm4sICFyZXZlcnNlKTtcbiAgICB9KTtcbiAgICByZXZlcnNlZFNlcXVlbmNlLnJldmVyc2UgPSAoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc2VxdWVuY2U7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJldmVyc2VkU2VxdWVuY2U7XG4gIH0sXG4gIGtleVNlcTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZmxpcCgpLnZhbHVlU2VxKCk7XG4gIH0sXG4gIHZhbHVlU2VxOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VxdWVuY2UgPSB0aGlzO1xuICAgIHZhciB2YWx1ZXNTZXF1ZW5jZSA9IG1ha2VJbmRleGVkU2VxdWVuY2Uoc2VxdWVuY2UpO1xuICAgIHZhbHVlc1NlcXVlbmNlLmxlbmd0aCA9IHNlcXVlbmNlLmxlbmd0aDtcbiAgICB2YWx1ZXNTZXF1ZW5jZS52YWx1ZVNlcSA9IHJldHVyblRoaXM7XG4gICAgdmFsdWVzU2VxdWVuY2UuX19pdGVyYXRlVW5jYWNoZWQgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSwgZmxpcEluZGljZXMpIHtcbiAgICAgIGlmIChmbGlwSW5kaWNlcyAmJiB0aGlzLmxlbmd0aCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRlKGZuLCByZXZlcnNlLCBmbGlwSW5kaWNlcyk7XG4gICAgICB9XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICB2YXIgcHJlZGljYXRlO1xuICAgICAgaWYgKGZsaXBJbmRpY2VzKSB7XG4gICAgICAgIGl0ZXJhdGlvbnMgPSB0aGlzLmxlbmd0aCAtIDE7XG4gICAgICAgIHByZWRpY2F0ZSA9IChmdW5jdGlvbih2LCBrLCBjKSB7XG4gICAgICAgICAgcmV0dXJuIGZuKHYsIGl0ZXJhdGlvbnMtLSwgYykgIT09IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IChmdW5jdGlvbih2LCBrLCBjKSB7XG4gICAgICAgICAgcmV0dXJuIGZuKHYsIGl0ZXJhdGlvbnMrKywgYykgIT09IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHNlcXVlbmNlLl9faXRlcmF0ZShwcmVkaWNhdGUsIHJldmVyc2UpO1xuICAgICAgcmV0dXJuIGZsaXBJbmRpY2VzID8gdGhpcy5sZW5ndGggOiBpdGVyYXRpb25zO1xuICAgIH07XG4gICAgcmV0dXJuIHZhbHVlc1NlcXVlbmNlO1xuICB9LFxuICBlbnRyeVNlcTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlcXVlbmNlID0gdGhpcztcbiAgICBpZiAoc2VxdWVuY2UuX2NhY2hlKSB7XG4gICAgICByZXR1cm4gJFNlcXVlbmNlKHNlcXVlbmNlLl9jYWNoZSk7XG4gICAgfVxuICAgIHZhciBlbnRyaWVzU2VxdWVuY2UgPSBzZXF1ZW5jZS5tYXAoZW50cnlNYXBwZXIpLnZhbHVlU2VxKCk7XG4gICAgZW50cmllc1NlcXVlbmNlLmZyb21FbnRyaWVzID0gKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHNlcXVlbmNlO1xuICAgIH0pO1xuICAgIHJldHVybiBlbnRyaWVzU2VxdWVuY2U7XG4gIH0sXG4gIGZvckVhY2g6IGZ1bmN0aW9uKHNpZGVFZmZlY3QsIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gdGhpcy5fX2l0ZXJhdGUodGhpc0FyZyA/IHNpZGVFZmZlY3QuYmluZCh0aGlzQXJnKSA6IHNpZGVFZmZlY3QpO1xuICB9LFxuICByZWR1Y2U6IGZ1bmN0aW9uKHJlZHVjZXIsIGluaXRpYWxSZWR1Y3Rpb24sIHRoaXNBcmcpIHtcbiAgICB2YXIgcmVkdWN0aW9uID0gaW5pdGlhbFJlZHVjdGlvbjtcbiAgICB0aGlzLmZvckVhY2goKGZ1bmN0aW9uKHYsIGssIGMpIHtcbiAgICAgIHJlZHVjdGlvbiA9IHJlZHVjZXIuY2FsbCh0aGlzQXJnLCByZWR1Y3Rpb24sIHYsIGssIGMpO1xuICAgIH0pKTtcbiAgICByZXR1cm4gcmVkdWN0aW9uO1xuICB9LFxuICByZWR1Y2VSaWdodDogZnVuY3Rpb24ocmVkdWNlciwgaW5pdGlhbFJlZHVjdGlvbiwgdGhpc0FyZykge1xuICAgIHJldHVybiB0aGlzLnJldmVyc2UodHJ1ZSkucmVkdWNlKHJlZHVjZXIsIGluaXRpYWxSZWR1Y3Rpb24sIHRoaXNBcmcpO1xuICB9LFxuICBldmVyeTogZnVuY3Rpb24ocHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgdmFyIHJldHVyblZhbHVlID0gdHJ1ZTtcbiAgICB0aGlzLmZvckVhY2goKGZ1bmN0aW9uKHYsIGssIGMpIHtcbiAgICAgIGlmICghcHJlZGljYXRlLmNhbGwodGhpc0FyZywgdiwgaywgYykpIHtcbiAgICAgICAgcmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gIH0sXG4gIHNvbWU6IGZ1bmN0aW9uKHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgIHJldHVybiAhdGhpcy5ldmVyeShub3QocHJlZGljYXRlKSwgdGhpc0FyZyk7XG4gIH0sXG4gIGZpcnN0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5maW5kKHJldHVyblRydWUpO1xuICB9LFxuICBsYXN0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5maW5kTGFzdChyZXR1cm5UcnVlKTtcbiAgfSxcbiAgcmVzdDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2xpY2UoMSk7XG4gIH0sXG4gIGJ1dExhc3Q6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnNsaWNlKDAsIC0xKTtcbiAgfSxcbiAgaGFzOiBmdW5jdGlvbihzZWFyY2hLZXkpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoc2VhcmNoS2V5LCBOT1RfU0VUKSAhPT0gTk9UX1NFVDtcbiAgfSxcbiAgZ2V0OiBmdW5jdGlvbihzZWFyY2hLZXksIG5vdFNldFZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluZCgoZnVuY3Rpb24oXywga2V5KSB7XG4gICAgICByZXR1cm4gaXMoa2V5LCBzZWFyY2hLZXkpO1xuICAgIH0pLCBudWxsLCBub3RTZXRWYWx1ZSk7XG4gIH0sXG4gIGdldEluOiBmdW5jdGlvbihzZWFyY2hLZXlQYXRoLCBub3RTZXRWYWx1ZSkge1xuICAgIGlmICghc2VhcmNoS2V5UGF0aCB8fCBzZWFyY2hLZXlQYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBnZXRJbkRlZXBTZXF1ZW5jZSh0aGlzLCBzZWFyY2hLZXlQYXRoLCBub3RTZXRWYWx1ZSwgMCk7XG4gIH0sXG4gIGNvbnRhaW5zOiBmdW5jdGlvbihzZWFyY2hWYWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmZpbmQoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXModmFsdWUsIHNlYXJjaFZhbHVlKTtcbiAgICB9KSwgbnVsbCwgTk9UX1NFVCkgIT09IE5PVF9TRVQ7XG4gIH0sXG4gIGZpbmQ6IGZ1bmN0aW9uKHByZWRpY2F0ZSwgdGhpc0FyZywgbm90U2V0VmFsdWUpIHtcbiAgICB2YXIgZm91bmRWYWx1ZSA9IG5vdFNldFZhbHVlO1xuICAgIHRoaXMuZm9yRWFjaCgoZnVuY3Rpb24odiwgaywgYykge1xuICAgICAgaWYgKHByZWRpY2F0ZS5jYWxsKHRoaXNBcmcsIHYsIGssIGMpKSB7XG4gICAgICAgIGZvdW5kVmFsdWUgPSB2O1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIHJldHVybiBmb3VuZFZhbHVlO1xuICB9LFxuICBmaW5kS2V5OiBmdW5jdGlvbihwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICB2YXIgZm91bmRLZXk7XG4gICAgdGhpcy5mb3JFYWNoKChmdW5jdGlvbih2LCBrLCBjKSB7XG4gICAgICBpZiAocHJlZGljYXRlLmNhbGwodGhpc0FyZywgdiwgaywgYykpIHtcbiAgICAgICAgZm91bmRLZXkgPSBrO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIHJldHVybiBmb3VuZEtleTtcbiAgfSxcbiAgZmluZExhc3Q6IGZ1bmN0aW9uKHByZWRpY2F0ZSwgdGhpc0FyZywgbm90U2V0VmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5yZXZlcnNlKHRydWUpLmZpbmQocHJlZGljYXRlLCB0aGlzQXJnLCBub3RTZXRWYWx1ZSk7XG4gIH0sXG4gIGZpbmRMYXN0S2V5OiBmdW5jdGlvbihwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXZlcnNlKHRydWUpLmZpbmRLZXkocHJlZGljYXRlLCB0aGlzQXJnKTtcbiAgfSxcbiAgZmxpcDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlcXVlbmNlID0gdGhpcztcbiAgICB2YXIgZmxpcFNlcXVlbmNlID0gbWFrZVNlcXVlbmNlKCk7XG4gICAgZmxpcFNlcXVlbmNlLmxlbmd0aCA9IHNlcXVlbmNlLmxlbmd0aDtcbiAgICBmbGlwU2VxdWVuY2UuZmxpcCA9IChmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzZXF1ZW5jZTtcbiAgICB9KTtcbiAgICBmbGlwU2VxdWVuY2UuX19pdGVyYXRlVW5jYWNoZWQgPSAoZnVuY3Rpb24oZm4sIHJldmVyc2UpIHtcbiAgICAgIHJldHVybiBzZXF1ZW5jZS5fX2l0ZXJhdGUoKGZ1bmN0aW9uKHYsIGssIGMpIHtcbiAgICAgICAgcmV0dXJuIGZuKGssIHYsIGMpICE9PSBmYWxzZTtcbiAgICAgIH0pLCByZXZlcnNlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZmxpcFNlcXVlbmNlO1xuICB9LFxuICBtYXA6IGZ1bmN0aW9uKG1hcHBlciwgdGhpc0FyZykge1xuICAgIHZhciBzZXF1ZW5jZSA9IHRoaXM7XG4gICAgdmFyIG1hcHBlZFNlcXVlbmNlID0gc2VxdWVuY2UuX19tYWtlU2VxdWVuY2UoKTtcbiAgICBtYXBwZWRTZXF1ZW5jZS5sZW5ndGggPSBzZXF1ZW5jZS5sZW5ndGg7XG4gICAgbWFwcGVkU2VxdWVuY2UuX19pdGVyYXRlVW5jYWNoZWQgPSAoZnVuY3Rpb24oZm4sIHJldmVyc2UpIHtcbiAgICAgIHJldHVybiBzZXF1ZW5jZS5fX2l0ZXJhdGUoKGZ1bmN0aW9uKHYsIGssIGMpIHtcbiAgICAgICAgcmV0dXJuIGZuKG1hcHBlci5jYWxsKHRoaXNBcmcsIHYsIGssIGMpLCBrLCBjKSAhPT0gZmFsc2U7XG4gICAgICB9KSwgcmV2ZXJzZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG1hcHBlZFNlcXVlbmNlO1xuICB9LFxuICBtYXBLZXlzOiBmdW5jdGlvbihtYXBwZXIsIHRoaXNBcmcpIHtcbiAgICB2YXIgc2VxdWVuY2UgPSB0aGlzO1xuICAgIHZhciBtYXBwZWRTZXF1ZW5jZSA9IHNlcXVlbmNlLl9fbWFrZVNlcXVlbmNlKCk7XG4gICAgbWFwcGVkU2VxdWVuY2UubGVuZ3RoID0gc2VxdWVuY2UubGVuZ3RoO1xuICAgIG1hcHBlZFNlcXVlbmNlLl9faXRlcmF0ZVVuY2FjaGVkID0gKGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7XG4gICAgICByZXR1cm4gc2VxdWVuY2UuX19pdGVyYXRlKChmdW5jdGlvbih2LCBrLCBjKSB7XG4gICAgICAgIHJldHVybiBmbih2LCBtYXBwZXIuY2FsbCh0aGlzQXJnLCBrLCB2LCBjKSwgYykgIT09IGZhbHNlO1xuICAgICAgfSksIHJldmVyc2UpO1xuICAgIH0pO1xuICAgIHJldHVybiBtYXBwZWRTZXF1ZW5jZTtcbiAgfSxcbiAgZmlsdGVyOiBmdW5jdGlvbihwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gZmlsdGVyRmFjdG9yeSh0aGlzLCBwcmVkaWNhdGUsIHRoaXNBcmcsIHRydWUsIGZhbHNlKTtcbiAgfSxcbiAgc2xpY2U6IGZ1bmN0aW9uKGJlZ2luLCBlbmQpIHtcbiAgICBpZiAod2hvbGVTbGljZShiZWdpbiwgZW5kLCB0aGlzLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2YXIgcmVzb2x2ZWRCZWdpbiA9IHJlc29sdmVCZWdpbihiZWdpbiwgdGhpcy5sZW5ndGgpO1xuICAgIHZhciByZXNvbHZlZEVuZCA9IHJlc29sdmVFbmQoZW5kLCB0aGlzLmxlbmd0aCk7XG4gICAgaWYgKHJlc29sdmVkQmVnaW4gIT09IHJlc29sdmVkQmVnaW4gfHwgcmVzb2x2ZWRFbmQgIT09IHJlc29sdmVkRW5kKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbnRyeVNlcSgpLnNsaWNlKGJlZ2luLCBlbmQpLmZyb21FbnRyeVNlcSgpO1xuICAgIH1cbiAgICB2YXIgc2tpcHBlZCA9IHJlc29sdmVkQmVnaW4gPT09IDAgPyB0aGlzIDogdGhpcy5za2lwKHJlc29sdmVkQmVnaW4pO1xuICAgIHJldHVybiByZXNvbHZlZEVuZCA9PSBudWxsIHx8IHJlc29sdmVkRW5kID09PSB0aGlzLmxlbmd0aCA/IHNraXBwZWQgOiBza2lwcGVkLnRha2UocmVzb2x2ZWRFbmQgLSByZXNvbHZlZEJlZ2luKTtcbiAgfSxcbiAgdGFrZTogZnVuY3Rpb24oYW1vdW50KSB7XG4gICAgdmFyIHNlcXVlbmNlID0gdGhpcztcbiAgICBpZiAoYW1vdW50ID4gc2VxdWVuY2UubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gc2VxdWVuY2U7XG4gICAgfVxuICAgIHZhciB0YWtlU2VxdWVuY2UgPSBzZXF1ZW5jZS5fX21ha2VTZXF1ZW5jZSgpO1xuICAgIHRha2VTZXF1ZW5jZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlLCBmbGlwSW5kaWNlcykge1xuICAgICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVSZXN1bHQoKS5fX2l0ZXJhdGUoZm4sIHJldmVyc2UsIGZsaXBJbmRpY2VzKTtcbiAgICAgIH1cbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHNlcXVlbmNlLl9faXRlcmF0ZSgoZnVuY3Rpb24odiwgaywgYykge1xuICAgICAgICBpZiAoaXRlcmF0aW9ucyA8IGFtb3VudCAmJiBmbih2LCBrLCBjKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBpdGVyYXRpb25zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KSwgcmV2ZXJzZSwgZmxpcEluZGljZXMpO1xuICAgICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gICAgfTtcbiAgICB0YWtlU2VxdWVuY2UubGVuZ3RoID0gdGhpcy5sZW5ndGggJiYgTWF0aC5taW4odGhpcy5sZW5ndGgsIGFtb3VudCk7XG4gICAgcmV0dXJuIHRha2VTZXF1ZW5jZTtcbiAgfSxcbiAgdGFrZUxhc3Q6IGZ1bmN0aW9uKGFtb3VudCwgbWFpbnRhaW5JbmRpY2VzKSB7XG4gICAgcmV0dXJuIHRoaXMucmV2ZXJzZShtYWludGFpbkluZGljZXMpLnRha2UoYW1vdW50KS5yZXZlcnNlKG1haW50YWluSW5kaWNlcyk7XG4gIH0sXG4gIHRha2VXaGlsZTogZnVuY3Rpb24ocHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgdmFyIHNlcXVlbmNlID0gdGhpcztcbiAgICB2YXIgdGFrZVNlcXVlbmNlID0gc2VxdWVuY2UuX19tYWtlU2VxdWVuY2UoKTtcbiAgICB0YWtlU2VxdWVuY2UuX19pdGVyYXRlVW5jYWNoZWQgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSwgZmxpcEluZGljZXMpIHtcbiAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRlKGZuLCByZXZlcnNlLCBmbGlwSW5kaWNlcyk7XG4gICAgICB9XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICBzZXF1ZW5jZS5fX2l0ZXJhdGUoKGZ1bmN0aW9uKHYsIGssIGMpIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZS5jYWxsKHRoaXNBcmcsIHYsIGssIGMpICYmIGZuKHYsIGssIGMpICE9PSBmYWxzZSkge1xuICAgICAgICAgIGl0ZXJhdGlvbnMrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pLCByZXZlcnNlLCBmbGlwSW5kaWNlcyk7XG4gICAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgICB9O1xuICAgIHJldHVybiB0YWtlU2VxdWVuY2U7XG4gIH0sXG4gIHRha2VVbnRpbDogZnVuY3Rpb24ocHJlZGljYXRlLCB0aGlzQXJnLCBtYWludGFpbkluZGljZXMpIHtcbiAgICByZXR1cm4gdGhpcy50YWtlV2hpbGUobm90KHByZWRpY2F0ZSksIHRoaXNBcmcsIG1haW50YWluSW5kaWNlcyk7XG4gIH0sXG4gIHNraXA6IGZ1bmN0aW9uKGFtb3VudCwgbWFpbnRhaW5JbmRpY2VzKSB7XG4gICAgdmFyIHNlcXVlbmNlID0gdGhpcztcbiAgICBpZiAoYW1vdW50ID09PSAwKSB7XG4gICAgICByZXR1cm4gc2VxdWVuY2U7XG4gICAgfVxuICAgIHZhciBza2lwU2VxdWVuY2UgPSBzZXF1ZW5jZS5fX21ha2VTZXF1ZW5jZSgpO1xuICAgIHNraXBTZXF1ZW5jZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlLCBmbGlwSW5kaWNlcykge1xuICAgICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVSZXN1bHQoKS5fX2l0ZXJhdGUoZm4sIHJldmVyc2UsIGZsaXBJbmRpY2VzKTtcbiAgICAgIH1cbiAgICAgIHZhciBpc1NraXBwaW5nID0gdHJ1ZTtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHZhciBza2lwcGVkID0gMDtcbiAgICAgIHNlcXVlbmNlLl9faXRlcmF0ZSgoZnVuY3Rpb24odiwgaywgYykge1xuICAgICAgICBpZiAoIShpc1NraXBwaW5nICYmIChpc1NraXBwaW5nID0gc2tpcHBlZCsrIDwgYW1vdW50KSkpIHtcbiAgICAgICAgICBpZiAoZm4odiwgaywgYykgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpdGVyYXRpb25zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pLCByZXZlcnNlLCBmbGlwSW5kaWNlcyk7XG4gICAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgICB9O1xuICAgIHNraXBTZXF1ZW5jZS5sZW5ndGggPSB0aGlzLmxlbmd0aCAmJiBNYXRoLm1heCgwLCB0aGlzLmxlbmd0aCAtIGFtb3VudCk7XG4gICAgcmV0dXJuIHNraXBTZXF1ZW5jZTtcbiAgfSxcbiAgc2tpcExhc3Q6IGZ1bmN0aW9uKGFtb3VudCwgbWFpbnRhaW5JbmRpY2VzKSB7XG4gICAgcmV0dXJuIHRoaXMucmV2ZXJzZShtYWludGFpbkluZGljZXMpLnNraXAoYW1vdW50KS5yZXZlcnNlKG1haW50YWluSW5kaWNlcyk7XG4gIH0sXG4gIHNraXBXaGlsZTogZnVuY3Rpb24ocHJlZGljYXRlLCB0aGlzQXJnLCBtYWludGFpbkluZGljZXMpIHtcbiAgICB2YXIgc2VxdWVuY2UgPSB0aGlzO1xuICAgIHZhciBza2lwU2VxdWVuY2UgPSBzZXF1ZW5jZS5fX21ha2VTZXF1ZW5jZSgpO1xuICAgIHNraXBTZXF1ZW5jZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IGZ1bmN0aW9uKGZuLCByZXZlcnNlLCBmbGlwSW5kaWNlcykge1xuICAgICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVSZXN1bHQoKS5fX2l0ZXJhdGUoZm4sIHJldmVyc2UsIGZsaXBJbmRpY2VzKTtcbiAgICAgIH1cbiAgICAgIHZhciBpc1NraXBwaW5nID0gdHJ1ZTtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHNlcXVlbmNlLl9faXRlcmF0ZSgoZnVuY3Rpb24odiwgaywgYykge1xuICAgICAgICBpZiAoIShpc1NraXBwaW5nICYmIChpc1NraXBwaW5nID0gcHJlZGljYXRlLmNhbGwodGhpc0FyZywgdiwgaywgYykpKSkge1xuICAgICAgICAgIGlmIChmbih2LCBrLCBjKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGl0ZXJhdGlvbnMrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSksIHJldmVyc2UsIGZsaXBJbmRpY2VzKTtcbiAgICAgIHJldHVybiBpdGVyYXRpb25zO1xuICAgIH07XG4gICAgcmV0dXJuIHNraXBTZXF1ZW5jZTtcbiAgfSxcbiAgc2tpcFVudGlsOiBmdW5jdGlvbihwcmVkaWNhdGUsIHRoaXNBcmcsIG1haW50YWluSW5kaWNlcykge1xuICAgIHJldHVybiB0aGlzLnNraXBXaGlsZShub3QocHJlZGljYXRlKSwgdGhpc0FyZywgbWFpbnRhaW5JbmRpY2VzKTtcbiAgfSxcbiAgZ3JvdXBCeTogZnVuY3Rpb24obWFwcGVyLCBjb250ZXh0KSB7XG4gICAgdmFyIHNlcSA9IHRoaXM7XG4gICAgdmFyIGdyb3VwcyA9IE9yZGVyZWRNYXAuZW1wdHkoKS53aXRoTXV0YXRpb25zKChmdW5jdGlvbihtYXApIHtcbiAgICAgIHNlcS5mb3JFYWNoKChmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHZhciBncm91cEtleSA9IG1hcHBlcih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgdmFyIGdyb3VwID0gbWFwLmdldChncm91cEtleSwgTk9UX1NFVCk7XG4gICAgICAgIGlmIChncm91cCA9PT0gTk9UX1NFVCkge1xuICAgICAgICAgIGdyb3VwID0gW107XG4gICAgICAgICAgbWFwLnNldChncm91cEtleSwgZ3JvdXApO1xuICAgICAgICB9XG4gICAgICAgIGdyb3VwLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIH0pKTtcbiAgICB9KSk7XG4gICAgcmV0dXJuIGdyb3Vwcy5tYXAoKGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgICByZXR1cm4gJFNlcXVlbmNlKGdyb3VwKS5mcm9tRW50cnlTZXEoKTtcbiAgICB9KSk7XG4gIH0sXG4gIHNvcnQ6IGZ1bmN0aW9uKGNvbXBhcmF0b3IsIG1haW50YWluSW5kaWNlcykge1xuICAgIHJldHVybiB0aGlzLnNvcnRCeSh2YWx1ZU1hcHBlciwgY29tcGFyYXRvciwgbWFpbnRhaW5JbmRpY2VzKTtcbiAgfSxcbiAgc29ydEJ5OiBmdW5jdGlvbihtYXBwZXIsIGNvbXBhcmF0b3IsIG1haW50YWluSW5kaWNlcykge1xuICAgIGNvbXBhcmF0b3IgPSBjb21wYXJhdG9yIHx8IGRlZmF1bHRDb21wYXJhdG9yO1xuICAgIHZhciBzZXEgPSB0aGlzO1xuICAgIHJldHVybiAkU2VxdWVuY2UodGhpcy5lbnRyeVNlcSgpLmVudHJ5U2VxKCkudG9BcnJheSgpLnNvcnQoKGZ1bmN0aW9uKGluZGV4ZWRFbnRyeUEsIGluZGV4ZWRFbnRyeUIpIHtcbiAgICAgIHJldHVybiBjb21wYXJhdG9yKG1hcHBlcihpbmRleGVkRW50cnlBWzFdWzFdLCBpbmRleGVkRW50cnlBWzFdWzBdLCBzZXEpLCBtYXBwZXIoaW5kZXhlZEVudHJ5QlsxXVsxXSwgaW5kZXhlZEVudHJ5QlsxXVswXSwgc2VxKSkgfHwgaW5kZXhlZEVudHJ5QVswXSAtIGluZGV4ZWRFbnRyeUJbMF07XG4gICAgfSkpKS5mcm9tRW50cnlTZXEoKS52YWx1ZVNlcSgpLmZyb21FbnRyeVNlcSgpO1xuICB9LFxuICBjYWNoZVJlc3VsdDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLl9jYWNoZSAmJiB0aGlzLl9faXRlcmF0ZVVuY2FjaGVkKSB7XG4gICAgICBhc3NlcnROb3RJbmZpbml0ZSh0aGlzLmxlbmd0aCk7XG4gICAgICB0aGlzLl9jYWNoZSA9IHRoaXMuZW50cnlTZXEoKS50b0FycmF5KCk7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmxlbmd0aCA9IHRoaXMuX2NhY2hlLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIF9faXRlcmF0ZTogZnVuY3Rpb24oZm4sIHJldmVyc2UsIGZsaXBJbmRpY2VzKSB7XG4gICAgaWYgKCF0aGlzLl9jYWNoZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX19pdGVyYXRlVW5jYWNoZWQoZm4sIHJldmVyc2UsIGZsaXBJbmRpY2VzKTtcbiAgICB9XG4gICAgdmFyIG1heEluZGV4ID0gdGhpcy5sZW5ndGggLSAxO1xuICAgIHZhciBjYWNoZSA9IHRoaXMuX2NhY2hlO1xuICAgIHZhciBjID0gdGhpcztcbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgZm9yICh2YXIgaWkgPSBjYWNoZS5sZW5ndGggLSAxOyBpaSA+PSAwOyBpaS0tKSB7XG4gICAgICAgIHZhciByZXZFbnRyeSA9IGNhY2hlW2lpXTtcbiAgICAgICAgaWYgKGZuKHJldkVudHJ5WzFdLCBmbGlwSW5kaWNlcyA/IHJldkVudHJ5WzBdIDogbWF4SW5kZXggLSByZXZFbnRyeVswXSwgYykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY2FjaGUuZXZlcnkoZmxpcEluZGljZXMgPyAoZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgcmV0dXJuIGZuKGVudHJ5WzFdLCBtYXhJbmRleCAtIGVudHJ5WzBdLCBjKSAhPT0gZmFsc2U7XG4gICAgICB9KSA6IChmdW5jdGlvbihlbnRyeSkge1xuICAgICAgICByZXR1cm4gZm4oZW50cnlbMV0sIGVudHJ5WzBdLCBjKSAhPT0gZmFsc2U7XG4gICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbiAgfSxcbiAgX19tYWtlU2VxdWVuY2U6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBtYWtlU2VxdWVuY2UoKTtcbiAgfVxufSwge2Zyb206IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgJFNlcXVlbmNlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBuZXcgT2JqZWN0U2VxdWVuY2UodmFsdWUpO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSBbdmFsdWVdO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEFycmF5U2VxdWVuY2UodmFsdWUpO1xuICB9fSk7XG52YXIgU2VxdWVuY2VQcm90b3R5cGUgPSBTZXF1ZW5jZS5wcm90b3R5cGU7XG5TZXF1ZW5jZVByb3RvdHlwZS50b0pTT04gPSBTZXF1ZW5jZVByb3RvdHlwZS50b0pTO1xuU2VxdWVuY2VQcm90b3R5cGUuX190b0pTID0gU2VxdWVuY2VQcm90b3R5cGUudG9PYmplY3Q7XG5TZXF1ZW5jZVByb3RvdHlwZS5pbnNwZWN0ID0gU2VxdWVuY2VQcm90b3R5cGUudG9Tb3VyY2UgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbn07XG52YXIgSW5kZXhlZFNlcXVlbmNlID0gZnVuY3Rpb24gSW5kZXhlZFNlcXVlbmNlKCkge1xuICAkdHJhY2V1clJ1bnRpbWUuZGVmYXVsdFN1cGVyQ2FsbCh0aGlzLCAkSW5kZXhlZFNlcXVlbmNlLnByb3RvdHlwZSwgYXJndW1lbnRzKTtcbn07XG52YXIgJEluZGV4ZWRTZXF1ZW5jZSA9IEluZGV4ZWRTZXF1ZW5jZTtcbigkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKEluZGV4ZWRTZXF1ZW5jZSwge1xuICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX190b1N0cmluZygnU2VxIFsnLCAnXScpO1xuICB9LFxuICB0b0FycmF5OiBmdW5jdGlvbigpIHtcbiAgICBhc3NlcnROb3RJbmZpbml0ZSh0aGlzLmxlbmd0aCk7XG4gICAgdmFyIGFycmF5ID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoIHx8IDApO1xuICAgIGFycmF5Lmxlbmd0aCA9IHRoaXMuZm9yRWFjaCgoZnVuY3Rpb24odiwgaSkge1xuICAgICAgYXJyYXlbaV0gPSB2O1xuICAgIH0pKTtcbiAgICByZXR1cm4gYXJyYXk7XG4gIH0sXG4gIGZyb21FbnRyeVNlcTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlcXVlbmNlID0gdGhpcztcbiAgICB2YXIgZnJvbUVudHJpZXNTZXF1ZW5jZSA9IG1ha2VTZXF1ZW5jZSgpO1xuICAgIGZyb21FbnRyaWVzU2VxdWVuY2UubGVuZ3RoID0gc2VxdWVuY2UubGVuZ3RoO1xuICAgIGZyb21FbnRyaWVzU2VxdWVuY2UuZW50cnlTZXEgPSAoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc2VxdWVuY2U7XG4gICAgfSk7XG4gICAgZnJvbUVudHJpZXNTZXF1ZW5jZS5fX2l0ZXJhdGVVbmNhY2hlZCA9IChmdW5jdGlvbihmbiwgcmV2ZXJzZSwgZmxpcEluZGljZXMpIHtcbiAgICAgIHJldHVybiBzZXF1ZW5jZS5fX2l0ZXJhdGUoKGZ1bmN0aW9uKGVudHJ5LCBfLCBjKSB7XG4gICAgICAgIHJldHVybiBmbihlbnRyeVsxXSwgZW50cnlbMF0sIGMpO1xuICAgICAgfSksIHJldmVyc2UsIGZsaXBJbmRpY2VzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZnJvbUVudHJpZXNTZXF1ZW5jZTtcbiAgfSxcbiAgam9pbjogZnVuY3Rpb24oc2VwYXJhdG9yKSB7XG4gICAgc2VwYXJhdG9yID0gc2VwYXJhdG9yIHx8ICcsJztcbiAgICB2YXIgc3RyaW5nID0gJyc7XG4gICAgdmFyIHByZXZJbmRleCA9IDA7XG4gICAgdGhpcy5mb3JFYWNoKChmdW5jdGlvbih2LCBpKSB7XG4gICAgICB2YXIgbnVtU2VwYXJhdG9ycyA9IGkgLSBwcmV2SW5kZXg7XG4gICAgICBwcmV2SW5kZXggPSBpO1xuICAgICAgc3RyaW5nICs9IChudW1TZXBhcmF0b3JzID09PSAxID8gc2VwYXJhdG9yIDogcmVwZWF0U3RyaW5nKHNlcGFyYXRvciwgbnVtU2VwYXJhdG9ycykpICsgdjtcbiAgICB9KSk7XG4gICAgaWYgKHRoaXMubGVuZ3RoICYmIHByZXZJbmRleCA8IHRoaXMubGVuZ3RoIC0gMSkge1xuICAgICAgc3RyaW5nICs9IHJlcGVhdFN0cmluZyhzZXBhcmF0b3IsIHRoaXMubGVuZ3RoIC0gMSAtIHByZXZJbmRleCk7XG4gICAgfVxuICAgIHJldHVybiBzdHJpbmc7XG4gIH0sXG4gIGNvbmNhdDogZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgdmFsdWVzID0gW10sXG4gICAgICAgICRfXzIgPSAwOyAkX18yIDwgYXJndW1lbnRzLmxlbmd0aDsgJF9fMisrKVxuICAgICAgdmFsdWVzWyRfXzJdID0gYXJndW1lbnRzWyRfXzJdO1xuICAgIHZhciBzZXF1ZW5jZXMgPSBbdGhpc10uY29uY2F0KHZhbHVlcykubWFwKChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIFNlcXVlbmNlKHZhbHVlKTtcbiAgICB9KSk7XG4gICAgdmFyIGNvbmNhdFNlcXVlbmNlID0gdGhpcy5fX21ha2VTZXF1ZW5jZSgpO1xuICAgIGNvbmNhdFNlcXVlbmNlLmxlbmd0aCA9IHNlcXVlbmNlcy5yZWR1Y2UoKGZ1bmN0aW9uKHN1bSwgc2VxKSB7XG4gICAgICByZXR1cm4gc3VtICE9IG51bGwgJiYgc2VxLmxlbmd0aCAhPSBudWxsID8gc3VtICsgc2VxLmxlbmd0aCA6IHVuZGVmaW5lZDtcbiAgICB9KSwgMCk7XG4gICAgY29uY2F0U2VxdWVuY2UuX19pdGVyYXRlVW5jYWNoZWQgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSwgZmxpcEluZGljZXMpIHtcbiAgICAgIGlmIChmbGlwSW5kaWNlcyAmJiAhdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVSZXN1bHQoKS5fX2l0ZXJhdGUoZm4sIHJldmVyc2UsIGZsaXBJbmRpY2VzKTtcbiAgICAgIH1cbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHZhciBzdG9wcGVkSXRlcmF0aW9uO1xuICAgICAgdmFyIG1heEluZGV4ID0gZmxpcEluZGljZXMgJiYgdGhpcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIG1heFNlcXVlbmNlc0luZGV4ID0gc2VxdWVuY2VzLmxlbmd0aCAtIDE7XG4gICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDw9IG1heFNlcXVlbmNlc0luZGV4ICYmICFzdG9wcGVkSXRlcmF0aW9uOyBpaSsrKSB7XG4gICAgICAgIHZhciBzZXF1ZW5jZSA9IHNlcXVlbmNlc1tyZXZlcnNlID8gbWF4U2VxdWVuY2VzSW5kZXggLSBpaSA6IGlpXTtcbiAgICAgICAgaWYgKCEoc2VxdWVuY2UgaW5zdGFuY2VvZiAkSW5kZXhlZFNlcXVlbmNlKSkge1xuICAgICAgICAgIHNlcXVlbmNlID0gc2VxdWVuY2UudmFsdWVTZXEoKTtcbiAgICAgICAgfVxuICAgICAgICBpdGVyYXRpb25zICs9IHNlcXVlbmNlLl9faXRlcmF0ZSgoZnVuY3Rpb24odiwgaW5kZXgsIGMpIHtcbiAgICAgICAgICBpbmRleCArPSBpdGVyYXRpb25zO1xuICAgICAgICAgIGlmIChmbih2LCBmbGlwSW5kaWNlcyA/IG1heEluZGV4IC0gaW5kZXggOiBpbmRleCwgYykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBzdG9wcGVkSXRlcmF0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLCByZXZlcnNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVyYXRpb25zO1xuICAgIH07XG4gICAgcmV0dXJuIGNvbmNhdFNlcXVlbmNlO1xuICB9LFxuICByZXZlcnNlOiBmdW5jdGlvbihtYWludGFpbkluZGljZXMpIHtcbiAgICB2YXIgc2VxdWVuY2UgPSB0aGlzO1xuICAgIHZhciByZXZlcnNlZFNlcXVlbmNlID0gc2VxdWVuY2UuX19tYWtlU2VxdWVuY2UoKTtcbiAgICByZXZlcnNlZFNlcXVlbmNlLmxlbmd0aCA9IHNlcXVlbmNlLmxlbmd0aDtcbiAgICByZXZlcnNlZFNlcXVlbmNlLl9fcmV2ZXJzZWRJbmRpY2VzID0gISEobWFpbnRhaW5JbmRpY2VzIF4gc2VxdWVuY2UuX19yZXZlcnNlZEluZGljZXMpO1xuICAgIHJldmVyc2VkU2VxdWVuY2UuX19pdGVyYXRlVW5jYWNoZWQgPSAoZnVuY3Rpb24oZm4sIHJldmVyc2UsIGZsaXBJbmRpY2VzKSB7XG4gICAgICByZXR1cm4gc2VxdWVuY2UuX19pdGVyYXRlKGZuLCAhcmV2ZXJzZSwgZmxpcEluZGljZXMgXiBtYWludGFpbkluZGljZXMpO1xuICAgIH0pO1xuICAgIHJldmVyc2VkU2VxdWVuY2UucmV2ZXJzZSA9IGZ1bmN0aW9uKF9tYWludGFpbkluZGljZXMpIHtcbiAgICAgIHJldHVybiBtYWludGFpbkluZGljZXMgPT09IF9tYWludGFpbkluZGljZXMgPyBzZXF1ZW5jZSA6IEluZGV4ZWRTZXF1ZW5jZVByb3RvdHlwZS5yZXZlcnNlLmNhbGwodGhpcywgX21haW50YWluSW5kaWNlcyk7XG4gICAgfTtcbiAgICByZXR1cm4gcmV2ZXJzZWRTZXF1ZW5jZTtcbiAgfSxcbiAgdmFsdWVTZXE6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWx1ZXNTZXF1ZW5jZSA9ICR0cmFjZXVyUnVudGltZS5zdXBlckNhbGwodGhpcywgJEluZGV4ZWRTZXF1ZW5jZS5wcm90b3R5cGUsIFwidmFsdWVTZXFcIiwgW10pO1xuICAgIHZhbHVlc1NlcXVlbmNlLmxlbmd0aCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gdmFsdWVzU2VxdWVuY2U7XG4gIH0sXG4gIGZpbHRlcjogZnVuY3Rpb24ocHJlZGljYXRlLCB0aGlzQXJnLCBtYWludGFpbkluZGljZXMpIHtcbiAgICB2YXIgZmlsdGVyU2VxdWVuY2UgPSBmaWx0ZXJGYWN0b3J5KHRoaXMsIHByZWRpY2F0ZSwgdGhpc0FyZywgbWFpbnRhaW5JbmRpY2VzLCBtYWludGFpbkluZGljZXMpO1xuICAgIGlmIChtYWludGFpbkluZGljZXMpIHtcbiAgICAgIGZpbHRlclNlcXVlbmNlLmxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gZmlsdGVyU2VxdWVuY2U7XG4gIH0sXG4gIGluZGV4T2Y6IGZ1bmN0aW9uKHNlYXJjaFZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluZEluZGV4KChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzKHZhbHVlLCBzZWFyY2hWYWx1ZSk7XG4gICAgfSkpO1xuICB9LFxuICBsYXN0SW5kZXhPZjogZnVuY3Rpb24oc2VhcmNoVmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5yZXZlcnNlKHRydWUpLmluZGV4T2Yoc2VhcmNoVmFsdWUpO1xuICB9LFxuICBmaW5kSW5kZXg6IGZ1bmN0aW9uKHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgIHZhciBrZXkgPSB0aGlzLmZpbmRLZXkocHJlZGljYXRlLCB0aGlzQXJnKTtcbiAgICByZXR1cm4ga2V5ID09IG51bGwgPyAtMSA6IGtleTtcbiAgfSxcbiAgZmluZExhc3RJbmRleDogZnVuY3Rpb24ocHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIHRoaXMucmV2ZXJzZSh0cnVlKS5maW5kSW5kZXgocHJlZGljYXRlLCB0aGlzQXJnKTtcbiAgfSxcbiAgc2xpY2U6IGZ1bmN0aW9uKGJlZ2luLCBlbmQsIG1haW50YWluSW5kaWNlcykge1xuICAgIHZhciBzZXF1ZW5jZSA9IHRoaXM7XG4gICAgaWYgKHdob2xlU2xpY2UoYmVnaW4sIGVuZCwgc2VxdWVuY2UubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIHNlcXVlbmNlO1xuICAgIH1cbiAgICB2YXIgc2xpY2VTZXF1ZW5jZSA9IHNlcXVlbmNlLl9fbWFrZVNlcXVlbmNlKCk7XG4gICAgdmFyIHJlc29sdmVkQmVnaW4gPSByZXNvbHZlQmVnaW4oYmVnaW4sIHNlcXVlbmNlLmxlbmd0aCk7XG4gICAgdmFyIHJlc29sdmVkRW5kID0gcmVzb2x2ZUVuZChlbmQsIHNlcXVlbmNlLmxlbmd0aCk7XG4gICAgc2xpY2VTZXF1ZW5jZS5sZW5ndGggPSBzZXF1ZW5jZS5sZW5ndGggJiYgKG1haW50YWluSW5kaWNlcyA/IHNlcXVlbmNlLmxlbmd0aCA6IHJlc29sdmVkRW5kIC0gcmVzb2x2ZWRCZWdpbik7XG4gICAgc2xpY2VTZXF1ZW5jZS5fX3JldmVyc2VkSW5kaWNlcyA9IHNlcXVlbmNlLl9fcmV2ZXJzZWRJbmRpY2VzO1xuICAgIHNsaWNlU2VxdWVuY2UuX19pdGVyYXRlVW5jYWNoZWQgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSwgZmxpcEluZGljZXMpIHtcbiAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRlKGZuLCByZXZlcnNlLCBmbGlwSW5kaWNlcyk7XG4gICAgICB9XG4gICAgICB2YXIgcmV2ZXJzZWRJbmRpY2VzID0gdGhpcy5fX3JldmVyc2VkSW5kaWNlcyBeIGZsaXBJbmRpY2VzO1xuICAgICAgaWYgKHJlc29sdmVkQmVnaW4gIT09IHJlc29sdmVkQmVnaW4gfHwgcmVzb2x2ZWRFbmQgIT09IHJlc29sdmVkRW5kIHx8IChyZXZlcnNlZEluZGljZXMgJiYgc2VxdWVuY2UubGVuZ3RoID09IG51bGwpKSB7XG4gICAgICAgIHZhciBleGFjdExlbmd0aCA9IHNlcXVlbmNlLmNvdW50KCk7XG4gICAgICAgIHJlc29sdmVkQmVnaW4gPSByZXNvbHZlQmVnaW4oYmVnaW4sIGV4YWN0TGVuZ3RoKTtcbiAgICAgICAgcmVzb2x2ZWRFbmQgPSByZXNvbHZlRW5kKGVuZCwgZXhhY3RMZW5ndGgpO1xuICAgICAgfVxuICAgICAgdmFyIGlpQmVnaW4gPSByZXZlcnNlZEluZGljZXMgPyBzZXF1ZW5jZS5sZW5ndGggLSByZXNvbHZlZEVuZCA6IHJlc29sdmVkQmVnaW47XG4gICAgICB2YXIgaWlFbmQgPSByZXZlcnNlZEluZGljZXMgPyBzZXF1ZW5jZS5sZW5ndGggLSByZXNvbHZlZEJlZ2luIDogcmVzb2x2ZWRFbmQ7XG4gICAgICB2YXIgbGVuZ3RoSXRlcmF0ZWQgPSBzZXF1ZW5jZS5fX2l0ZXJhdGUoKGZ1bmN0aW9uKHYsIGlpLCBjKSB7XG4gICAgICAgIHJldHVybiByZXZlcnNlZEluZGljZXMgPyAoaWlFbmQgIT0gbnVsbCAmJiBpaSA+PSBpaUVuZCkgfHwgKGlpID49IGlpQmVnaW4pICYmIGZuKHYsIG1haW50YWluSW5kaWNlcyA/IGlpIDogaWkgLSBpaUJlZ2luLCBjKSAhPT0gZmFsc2UgOiAoaWkgPCBpaUJlZ2luKSB8fCAoaWlFbmQgPT0gbnVsbCB8fCBpaSA8IGlpRW5kKSAmJiBmbih2LCBtYWludGFpbkluZGljZXMgPyBpaSA6IGlpIC0gaWlCZWdpbiwgYykgIT09IGZhbHNlO1xuICAgICAgfSksIHJldmVyc2UsIGZsaXBJbmRpY2VzKTtcbiAgICAgIHJldHVybiB0aGlzLmxlbmd0aCAhPSBudWxsID8gdGhpcy5sZW5ndGggOiBtYWludGFpbkluZGljZXMgPyBsZW5ndGhJdGVyYXRlZCA6IE1hdGgubWF4KDAsIGxlbmd0aEl0ZXJhdGVkIC0gaWlCZWdpbik7XG4gICAgfTtcbiAgICByZXR1cm4gc2xpY2VTZXF1ZW5jZTtcbiAgfSxcbiAgc3BsaWNlOiBmdW5jdGlvbihpbmRleCwgcmVtb3ZlTnVtKSB7XG4gICAgdmFyIG51bUFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHJlbW92ZU51bSA9IE1hdGgubWF4KHJlbW92ZU51bSB8IDAsIDApO1xuICAgIGlmIChudW1BcmdzID09PSAwIHx8IChudW1BcmdzID09PSAyICYmICFyZW1vdmVOdW0pKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaW5kZXggPSByZXNvbHZlQmVnaW4oaW5kZXgsIHRoaXMubGVuZ3RoKTtcbiAgICB2YXIgc3BsaWNlZCA9IHRoaXMuc2xpY2UoMCwgaW5kZXgpO1xuICAgIHJldHVybiBudW1BcmdzID09PSAxID8gc3BsaWNlZCA6IHNwbGljZWQuY29uY2F0KGFyckNvcHkoYXJndW1lbnRzLCAyKSwgdGhpcy5zbGljZShpbmRleCArIHJlbW92ZU51bSkpO1xuICB9LFxuICB0YWtlOiBmdW5jdGlvbihhbW91bnQpIHtcbiAgICB2YXIgc2VxdWVuY2UgPSB0aGlzO1xuICAgIGlmIChhbW91bnQgPiBzZXF1ZW5jZS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBzZXF1ZW5jZTtcbiAgICB9XG4gICAgdmFyIHRha2VTZXF1ZW5jZSA9IHNlcXVlbmNlLl9fbWFrZVNlcXVlbmNlKCk7XG4gICAgdGFrZVNlcXVlbmNlLl9faXRlcmF0ZVVuY2FjaGVkID0gZnVuY3Rpb24oZm4sIHJldmVyc2UsIGZsaXBJbmRpY2VzKSB7XG4gICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0ZShmbiwgcmV2ZXJzZSwgZmxpcEluZGljZXMpO1xuICAgICAgfVxuICAgICAgdmFyIHRha2VuID0gMDtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHZhciBkaWRGaW5pc2ggPSB0cnVlO1xuICAgICAgdmFyIGxlbmd0aCA9IHNlcXVlbmNlLl9faXRlcmF0ZSgoZnVuY3Rpb24odiwgaWksIGMpIHtcbiAgICAgICAgaWYgKHRha2VuKysgPCBhbW91bnQgJiYgZm4odiwgaWksIGMpICE9PSBmYWxzZSkge1xuICAgICAgICAgIGl0ZXJhdGlvbnMgPSBpaTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkaWRGaW5pc2ggPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pLCByZXZlcnNlLCBmbGlwSW5kaWNlcyk7XG4gICAgICByZXR1cm4gZGlkRmluaXNoID8gbGVuZ3RoIDogaXRlcmF0aW9ucyArIDE7XG4gICAgfTtcbiAgICB0YWtlU2VxdWVuY2UubGVuZ3RoID0gdGhpcy5sZW5ndGggJiYgTWF0aC5taW4odGhpcy5sZW5ndGgsIGFtb3VudCk7XG4gICAgcmV0dXJuIHRha2VTZXF1ZW5jZTtcbiAgfSxcbiAgdGFrZVdoaWxlOiBmdW5jdGlvbihwcmVkaWNhdGUsIHRoaXNBcmcsIG1haW50YWluSW5kaWNlcykge1xuICAgIHZhciBzZXF1ZW5jZSA9IHRoaXM7XG4gICAgdmFyIHRha2VTZXF1ZW5jZSA9IHNlcXVlbmNlLl9fbWFrZVNlcXVlbmNlKCk7XG4gICAgdGFrZVNlcXVlbmNlLl9faXRlcmF0ZVVuY2FjaGVkID0gZnVuY3Rpb24oZm4sIHJldmVyc2UsIGZsaXBJbmRpY2VzKSB7XG4gICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0ZShmbiwgcmV2ZXJzZSwgZmxpcEluZGljZXMpO1xuICAgICAgfVxuICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgdmFyIGRpZEZpbmlzaCA9IHRydWU7XG4gICAgICB2YXIgbGVuZ3RoID0gc2VxdWVuY2UuX19pdGVyYXRlKChmdW5jdGlvbih2LCBpaSwgYykge1xuICAgICAgICBpZiAocHJlZGljYXRlLmNhbGwodGhpc0FyZywgdiwgaWksIGMpICYmIGZuKHYsIGlpLCBjKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBpdGVyYXRpb25zID0gaWk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGlkRmluaXNoID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KSwgcmV2ZXJzZSwgZmxpcEluZGljZXMpO1xuICAgICAgcmV0dXJuIG1haW50YWluSW5kaWNlcyA/IHRha2VTZXF1ZW5jZS5sZW5ndGggOiBkaWRGaW5pc2ggPyBsZW5ndGggOiBpdGVyYXRpb25zICsgMTtcbiAgICB9O1xuICAgIGlmIChtYWludGFpbkluZGljZXMpIHtcbiAgICAgIHRha2VTZXF1ZW5jZS5sZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHRha2VTZXF1ZW5jZTtcbiAgfSxcbiAgc2tpcDogZnVuY3Rpb24oYW1vdW50LCBtYWludGFpbkluZGljZXMpIHtcbiAgICB2YXIgc2VxdWVuY2UgPSB0aGlzO1xuICAgIGlmIChhbW91bnQgPT09IDApIHtcbiAgICAgIHJldHVybiBzZXF1ZW5jZTtcbiAgICB9XG4gICAgdmFyIHNraXBTZXF1ZW5jZSA9IHNlcXVlbmNlLl9fbWFrZVNlcXVlbmNlKCk7XG4gICAgaWYgKG1haW50YWluSW5kaWNlcykge1xuICAgICAgc2tpcFNlcXVlbmNlLmxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgIH1cbiAgICBza2lwU2VxdWVuY2UuX19pdGVyYXRlVW5jYWNoZWQgPSBmdW5jdGlvbihmbiwgcmV2ZXJzZSwgZmxpcEluZGljZXMpIHtcbiAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlUmVzdWx0KCkuX19pdGVyYXRlKGZuLCByZXZlcnNlLCBmbGlwSW5kaWNlcyk7XG4gICAgICB9XG4gICAgICB2YXIgcmV2ZXJzZWRJbmRpY2VzID0gc2VxdWVuY2UuX19yZXZlcnNlZEluZGljZXMgXiBmbGlwSW5kaWNlcztcbiAgICAgIHZhciBpc1NraXBwaW5nID0gdHJ1ZTtcbiAgICAgIHZhciBpbmRleE9mZnNldCA9IDA7XG4gICAgICB2YXIgc2tpcHBlZCA9IDA7XG4gICAgICB2YXIgbGVuZ3RoID0gc2VxdWVuY2UuX19pdGVyYXRlKChmdW5jdGlvbih2LCBpaSwgYykge1xuICAgICAgICBpZiAoaXNTa2lwcGluZykge1xuICAgICAgICAgIGlzU2tpcHBpbmcgPSBza2lwcGVkKysgPCBhbW91bnQ7XG4gICAgICAgICAgaWYgKCFpc1NraXBwaW5nKSB7XG4gICAgICAgICAgICBpbmRleE9mZnNldCA9IGlpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNTa2lwcGluZyB8fCBmbih2LCBmbGlwSW5kaWNlcyB8fCBtYWludGFpbkluZGljZXMgPyBpaSA6IGlpIC0gaW5kZXhPZmZzZXQsIGMpICE9PSBmYWxzZTtcbiAgICAgIH0pLCByZXZlcnNlLCBmbGlwSW5kaWNlcyk7XG4gICAgICByZXR1cm4gbWFpbnRhaW5JbmRpY2VzID8gbGVuZ3RoIDogcmV2ZXJzZWRJbmRpY2VzID8gaW5kZXhPZmZzZXQgKyAxIDogbGVuZ3RoIC0gaW5kZXhPZmZzZXQ7XG4gICAgfTtcbiAgICBza2lwU2VxdWVuY2UubGVuZ3RoID0gdGhpcy5sZW5ndGggJiYgTWF0aC5tYXgoMCwgdGhpcy5sZW5ndGggLSBhbW91bnQpO1xuICAgIHJldHVybiBza2lwU2VxdWVuY2U7XG4gIH0sXG4gIHNraXBXaGlsZTogZnVuY3Rpb24ocHJlZGljYXRlLCB0aGlzQXJnLCBtYWludGFpbkluZGljZXMpIHtcbiAgICB2YXIgc2VxdWVuY2UgPSB0aGlzO1xuICAgIHZhciBza2lwV2hpbGVTZXF1ZW5jZSA9IHNlcXVlbmNlLl9fbWFrZVNlcXVlbmNlKCk7XG4gICAgaWYgKG1haW50YWluSW5kaWNlcykge1xuICAgICAgc2tpcFdoaWxlU2VxdWVuY2UubGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgfVxuICAgIHNraXBXaGlsZVNlcXVlbmNlLl9faXRlcmF0ZVVuY2FjaGVkID0gZnVuY3Rpb24oZm4sIHJldmVyc2UsIGZsaXBJbmRpY2VzKSB7XG4gICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZVJlc3VsdCgpLl9faXRlcmF0ZShmbiwgcmV2ZXJzZSwgZmxpcEluZGljZXMpO1xuICAgICAgfVxuICAgICAgdmFyIHJldmVyc2VkSW5kaWNlcyA9IHNlcXVlbmNlLl9fcmV2ZXJzZWRJbmRpY2VzIF4gZmxpcEluZGljZXM7XG4gICAgICB2YXIgaXNTa2lwcGluZyA9IHRydWU7XG4gICAgICB2YXIgaW5kZXhPZmZzZXQgPSAwO1xuICAgICAgdmFyIGxlbmd0aCA9IHNlcXVlbmNlLl9faXRlcmF0ZSgoZnVuY3Rpb24odiwgaWksIGMpIHtcbiAgICAgICAgaWYgKGlzU2tpcHBpbmcpIHtcbiAgICAgICAgICBpc1NraXBwaW5nID0gcHJlZGljYXRlLmNhbGwodGhpc0FyZywgdiwgaWksIGMpO1xuICAgICAgICAgIGlmICghaXNTa2lwcGluZykge1xuICAgICAgICAgICAgaW5kZXhPZmZzZXQgPSBpaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzU2tpcHBpbmcgfHwgZm4odiwgZmxpcEluZGljZXMgfHwgbWFpbnRhaW5JbmRpY2VzID8gaWkgOiBpaSAtIGluZGV4T2Zmc2V0LCBjKSAhPT0gZmFsc2U7XG4gICAgICB9KSwgcmV2ZXJzZSwgZmxpcEluZGljZXMpO1xuICAgICAgcmV0dXJuIG1haW50YWluSW5kaWNlcyA/IGxlbmd0aCA6IHJldmVyc2VkSW5kaWNlcyA/IGluZGV4T2Zmc2V0ICsgMSA6IGxlbmd0aCAtIGluZGV4T2Zmc2V0O1xuICAgIH07XG4gICAgcmV0dXJuIHNraXBXaGlsZVNlcXVlbmNlO1xuICB9LFxuICBncm91cEJ5OiBmdW5jdGlvbihtYXBwZXIsIGNvbnRleHQsIG1haW50YWluSW5kaWNlcykge1xuICAgIHZhciBzZXEgPSB0aGlzO1xuICAgIHZhciBncm91cHMgPSBPcmRlcmVkTWFwLmVtcHR5KCkud2l0aE11dGF0aW9ucygoZnVuY3Rpb24obWFwKSB7XG4gICAgICBzZXEuZm9yRWFjaCgoZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHZhciBncm91cEtleSA9IG1hcHBlcih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICB2YXIgZ3JvdXAgPSBtYXAuZ2V0KGdyb3VwS2V5LCBOT1RfU0VUKTtcbiAgICAgICAgaWYgKGdyb3VwID09PSBOT1RfU0VUKSB7XG4gICAgICAgICAgZ3JvdXAgPSBuZXcgQXJyYXkobWFpbnRhaW5JbmRpY2VzID8gc2VxLmxlbmd0aCA6IDApO1xuICAgICAgICAgIG1hcC5zZXQoZ3JvdXBLZXksIGdyb3VwKTtcbiAgICAgICAgfVxuICAgICAgICBtYWludGFpbkluZGljZXMgPyAoZ3JvdXBbaW5kZXhdID0gdmFsdWUpIDogZ3JvdXAucHVzaCh2YWx1ZSk7XG4gICAgICB9KSk7XG4gICAgfSkpO1xuICAgIHJldHVybiBncm91cHMubWFwKChmdW5jdGlvbihncm91cCkge1xuICAgICAgcmV0dXJuIFNlcXVlbmNlKGdyb3VwKTtcbiAgICB9KSk7XG4gIH0sXG4gIHNvcnRCeTogZnVuY3Rpb24obWFwcGVyLCBjb21wYXJhdG9yLCBtYWludGFpbkluZGljZXMpIHtcbiAgICB2YXIgc29ydGVkU2VxID0gJHRyYWNldXJSdW50aW1lLnN1cGVyQ2FsbCh0aGlzLCAkSW5kZXhlZFNlcXVlbmNlLnByb3RvdHlwZSwgXCJzb3J0QnlcIiwgW21hcHBlciwgY29tcGFyYXRvcl0pO1xuICAgIGlmICghbWFpbnRhaW5JbmRpY2VzKSB7XG4gICAgICBzb3J0ZWRTZXEgPSBzb3J0ZWRTZXEudmFsdWVTZXEoKTtcbiAgICB9XG4gICAgc29ydGVkU2VxLmxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgIHJldHVybiBzb3J0ZWRTZXE7XG4gIH0sXG4gIF9fbWFrZVNlcXVlbmNlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbWFrZUluZGV4ZWRTZXF1ZW5jZSh0aGlzKTtcbiAgfVxufSwge30sIFNlcXVlbmNlKTtcbnZhciBJbmRleGVkU2VxdWVuY2VQcm90b3R5cGUgPSBJbmRleGVkU2VxdWVuY2UucHJvdG90eXBlO1xuSW5kZXhlZFNlcXVlbmNlUHJvdG90eXBlLl9fdG9KUyA9IEluZGV4ZWRTZXF1ZW5jZVByb3RvdHlwZS50b0FycmF5O1xuSW5kZXhlZFNlcXVlbmNlUHJvdG90eXBlLl9fdG9TdHJpbmdNYXBwZXIgPSBxdW90ZVN0cmluZztcbnZhciBPYmplY3RTZXF1ZW5jZSA9IGZ1bmN0aW9uIE9iamVjdFNlcXVlbmNlKG9iamVjdCkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gIHRoaXMuX29iamVjdCA9IG9iamVjdDtcbiAgdGhpcy5fa2V5cyA9IGtleXM7XG4gIHRoaXMubGVuZ3RoID0ga2V5cy5sZW5ndGg7XG59O1xuKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoT2JqZWN0U2VxdWVuY2UsIHtcbiAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9vYmplY3Q7XG4gIH0sXG4gIGdldDogZnVuY3Rpb24oa2V5LCBub3RTZXRWYWx1ZSkge1xuICAgIGlmIChub3RTZXRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICF0aGlzLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gbm90U2V0VmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9vYmplY3Rba2V5XTtcbiAgfSxcbiAgaGFzOiBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fb2JqZWN0Lmhhc093blByb3BlcnR5KGtleSk7XG4gIH0sXG4gIF9faXRlcmF0ZTogZnVuY3Rpb24oZm4sIHJldmVyc2UpIHtcbiAgICB2YXIgb2JqZWN0ID0gdGhpcy5fb2JqZWN0O1xuICAgIHZhciBrZXlzID0gdGhpcy5fa2V5cztcbiAgICB2YXIgbWF4SW5kZXggPSBrZXlzLmxlbmd0aCAtIDE7XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8PSBtYXhJbmRleDsgaWkrKykge1xuICAgICAgdmFyIGl0ZXJhdGlvbiA9IHJldmVyc2UgPyBtYXhJbmRleCAtIGlpIDogaWk7XG4gICAgICBpZiAoZm4ob2JqZWN0W2tleXNbaXRlcmF0aW9uXV0sIGtleXNbaXRlcmF0aW9uXSwgb2JqZWN0KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpaTtcbiAgfVxufSwge30sIFNlcXVlbmNlKTtcbnZhciBBcnJheVNlcXVlbmNlID0gZnVuY3Rpb24gQXJyYXlTZXF1ZW5jZShhcnJheSkge1xuICB0aGlzLl9hcnJheSA9IGFycmF5O1xuICB0aGlzLmxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbn07XG4oJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShBcnJheVNlcXVlbmNlLCB7XG4gIHRvQXJyYXk6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9hcnJheTtcbiAgfSxcbiAgX19pdGVyYXRlOiBmdW5jdGlvbihmbiwgcmV2ZXJzZSwgZmxpcEluZGljZXMpIHtcbiAgICB2YXIgYXJyYXkgPSB0aGlzLl9hcnJheTtcbiAgICB2YXIgbWF4SW5kZXggPSBhcnJheS5sZW5ndGggLSAxO1xuICAgIHZhciBsYXN0SW5kZXggPSAtMTtcbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgZm9yICh2YXIgaWkgPSBtYXhJbmRleDsgaWkgPj0gMDsgaWktLSkge1xuICAgICAgICBpZiAoYXJyYXkuaGFzT3duUHJvcGVydHkoaWkpICYmIGZuKGFycmF5W2lpXSwgZmxpcEluZGljZXMgPyBpaSA6IG1heEluZGV4IC0gaWksIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gbGFzdEluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0SW5kZXggPSBpaTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheS5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkaWRGaW5pc2ggPSBhcnJheS5ldmVyeSgoZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG4gICAgICAgIGlmIChmbih2YWx1ZSwgZmxpcEluZGljZXMgPyBtYXhJbmRleCAtIGluZGV4IDogaW5kZXgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGFzdEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiBkaWRGaW5pc2ggPyBhcnJheS5sZW5ndGggOiBsYXN0SW5kZXggKyAxO1xuICAgIH1cbiAgfVxufSwge30sIEluZGV4ZWRTZXF1ZW5jZSk7XG5BcnJheVNlcXVlbmNlLnByb3RvdHlwZS5nZXQgPSBPYmplY3RTZXF1ZW5jZS5wcm90b3R5cGUuZ2V0O1xuQXJyYXlTZXF1ZW5jZS5wcm90b3R5cGUuaGFzID0gT2JqZWN0U2VxdWVuY2UucHJvdG90eXBlLmhhcztcbnZhciBTZXF1ZW5jZUl0ZXJhdG9yID0gZnVuY3Rpb24gU2VxdWVuY2VJdGVyYXRvcigpIHt9O1xuKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoU2VxdWVuY2VJdGVyYXRvciwge3RvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJ1tJdGVyYXRvcl0nO1xuICB9fSwge30pO1xudmFyIFNlcXVlbmNlSXRlcmF0b3JQcm90b3R5cGUgPSBTZXF1ZW5jZUl0ZXJhdG9yLnByb3RvdHlwZTtcblNlcXVlbmNlSXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1JdID0gcmV0dXJuVGhpcztcblNlcXVlbmNlSXRlcmF0b3JQcm90b3R5cGUuaW5zcGVjdCA9IFNlcXVlbmNlSXRlcmF0b3JQcm90b3R5cGUudG9Tb3VyY2UgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbn07XG5mdW5jdGlvbiBtYWtlU2VxdWVuY2UoKSB7XG4gIHJldHVybiBPYmplY3QuY3JlYXRlKFNlcXVlbmNlUHJvdG90eXBlKTtcbn1cbmZ1bmN0aW9uIG1ha2VJbmRleGVkU2VxdWVuY2UocGFyZW50KSB7XG4gIHZhciBuZXdTZXF1ZW5jZSA9IE9iamVjdC5jcmVhdGUoSW5kZXhlZFNlcXVlbmNlUHJvdG90eXBlKTtcbiAgbmV3U2VxdWVuY2UuX19yZXZlcnNlZEluZGljZXMgPSBwYXJlbnQgPyBwYXJlbnQuX19yZXZlcnNlZEluZGljZXMgOiBmYWxzZTtcbiAgcmV0dXJuIG5ld1NlcXVlbmNlO1xufVxuZnVuY3Rpb24gZ2V0SW5EZWVwU2VxdWVuY2Uoc2VxLCBrZXlQYXRoLCBub3RTZXRWYWx1ZSwgcGF0aE9mZnNldCkge1xuICB2YXIgbmVzdGVkID0gc2VxLmdldCA/IHNlcS5nZXQoa2V5UGF0aFtwYXRoT2Zmc2V0XSwgTk9UX1NFVCkgOiBOT1RfU0VUO1xuICBpZiAobmVzdGVkID09PSBOT1RfU0VUKSB7XG4gICAgcmV0dXJuIG5vdFNldFZhbHVlO1xuICB9XG4gIGlmICgrK3BhdGhPZmZzZXQgPT09IGtleVBhdGgubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG5lc3RlZDtcbiAgfVxuICByZXR1cm4gZ2V0SW5EZWVwU2VxdWVuY2UobmVzdGVkLCBrZXlQYXRoLCBub3RTZXRWYWx1ZSwgcGF0aE9mZnNldCk7XG59XG5mdW5jdGlvbiB3aG9sZVNsaWNlKGJlZ2luLCBlbmQsIGxlbmd0aCkge1xuICByZXR1cm4gKGJlZ2luID09PSAwIHx8IChsZW5ndGggIT0gbnVsbCAmJiBiZWdpbiA8PSAtbGVuZ3RoKSkgJiYgKGVuZCA9PSBudWxsIHx8IChsZW5ndGggIT0gbnVsbCAmJiBlbmQgPj0gbGVuZ3RoKSk7XG59XG5mdW5jdGlvbiByZXNvbHZlQmVnaW4oYmVnaW4sIGxlbmd0aCkge1xuICByZXR1cm4gcmVzb2x2ZUluZGV4KGJlZ2luLCBsZW5ndGgsIDApO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUVuZChlbmQsIGxlbmd0aCkge1xuICByZXR1cm4gcmVzb2x2ZUluZGV4KGVuZCwgbGVuZ3RoLCBsZW5ndGgpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUluZGV4KGluZGV4LCBsZW5ndGgsIGRlZmF1bHRJbmRleCkge1xuICByZXR1cm4gaW5kZXggPT0gbnVsbCA/IGRlZmF1bHRJbmRleCA6IGluZGV4IDwgMCA/IE1hdGgubWF4KDAsIGxlbmd0aCArIGluZGV4KSA6IGxlbmd0aCA/IE1hdGgubWluKGxlbmd0aCwgaW5kZXgpIDogaW5kZXg7XG59XG5mdW5jdGlvbiB2YWx1ZU1hcHBlcih2KSB7XG4gIHJldHVybiB2O1xufVxuZnVuY3Rpb24gZW50cnlNYXBwZXIodiwgaykge1xuICByZXR1cm4gW2ssIHZdO1xufVxuZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiByZXR1cm5UaGlzKCkge1xuICByZXR1cm4gdGhpcztcbn1cbmZ1bmN0aW9uIGluY3JlbWVudCh2YWx1ZSkge1xuICByZXR1cm4gKHZhbHVlIHx8IDApICsgMTtcbn1cbmZ1bmN0aW9uIGZpbHRlckZhY3Rvcnkoc2VxdWVuY2UsIHByZWRpY2F0ZSwgdGhpc0FyZywgdXNlS2V5cywgbWFpbnRhaW5JbmRpY2VzKSB7XG4gIHZhciBmaWx0ZXJTZXF1ZW5jZSA9IHNlcXVlbmNlLl9fbWFrZVNlcXVlbmNlKCk7XG4gIGZpbHRlclNlcXVlbmNlLl9faXRlcmF0ZVVuY2FjaGVkID0gKGZ1bmN0aW9uKGZuLCByZXZlcnNlLCBmbGlwSW5kaWNlcykge1xuICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICB2YXIgbGVuZ3RoID0gc2VxdWVuY2UuX19pdGVyYXRlKChmdW5jdGlvbih2LCBrLCBjKSB7XG4gICAgICBpZiAocHJlZGljYXRlLmNhbGwodGhpc0FyZywgdiwgaywgYykpIHtcbiAgICAgICAgaWYgKGZuKHYsIHVzZUtleXMgPyBrIDogaXRlcmF0aW9ucywgYykgIT09IGZhbHNlKSB7XG4gICAgICAgICAgaXRlcmF0aW9ucysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pLCByZXZlcnNlLCBmbGlwSW5kaWNlcyk7XG4gICAgcmV0dXJuIG1haW50YWluSW5kaWNlcyA/IGxlbmd0aCA6IGl0ZXJhdGlvbnM7XG4gIH0pO1xuICByZXR1cm4gZmlsdGVyU2VxdWVuY2U7XG59XG5mdW5jdGlvbiBub3QocHJlZGljYXRlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gIXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuZnVuY3Rpb24gcXVvdGVTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgOiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHJlcGVhdFN0cmluZyhzdHJpbmcsIHRpbWVzKSB7XG4gIHZhciByZXBlYXRlZCA9ICcnO1xuICB3aGlsZSAodGltZXMpIHtcbiAgICBpZiAodGltZXMgJiAxKSB7XG4gICAgICByZXBlYXRlZCArPSBzdHJpbmc7XG4gICAgfVxuICAgIGlmICgodGltZXMgPj49IDEpKSB7XG4gICAgICBzdHJpbmcgKz0gc3RyaW5nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVwZWF0ZWQ7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q29tcGFyYXRvcihhLCBiKSB7XG4gIHJldHVybiBhID4gYiA/IDEgOiBhIDwgYiA/IC0xIDogMDtcbn1cbmZ1bmN0aW9uIGFzc2VydE5vdEluZmluaXRlKGxlbmd0aCkge1xuICBpbnZhcmlhbnQobGVuZ3RoICE9PSBJbmZpbml0eSwgJ0Nhbm5vdCBwZXJmb3JtIHRoaXMgYWN0aW9uIHdpdGggYW4gaW5maW5pdGUgc2VxdWVuY2UuJyk7XG59XG5mdW5jdGlvbiBpdGVyYXRvck1hcHBlcihpdGVyLCBmbikge1xuICB2YXIgbmV3SXRlciA9IG5ldyBTZXF1ZW5jZUl0ZXJhdG9yKCk7XG4gIG5ld0l0ZXIubmV4dCA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RlcCA9IGl0ZXIubmV4dCgpO1xuICAgIGlmIChzdGVwLmRvbmUpXG4gICAgICByZXR1cm4gc3RlcDtcbiAgICBzdGVwLnZhbHVlID0gZm4oc3RlcC52YWx1ZSk7XG4gICAgcmV0dXJuIHN0ZXA7XG4gIH0pO1xuICByZXR1cm4gbmV3SXRlcjtcbn1cbnZhciBDdXJzb3IgPSBmdW5jdGlvbiBDdXJzb3Iocm9vdERhdGEsIGtleVBhdGgsIG9uQ2hhbmdlLCB2YWx1ZSkge1xuICB2YWx1ZSA9IHZhbHVlID8gdmFsdWUgOiByb290RGF0YS5nZXRJbihrZXlQYXRoKTtcbiAgdGhpcy5sZW5ndGggPSB2YWx1ZSBpbnN0YW5jZW9mIFNlcXVlbmNlID8gdmFsdWUubGVuZ3RoIDogbnVsbDtcbiAgdGhpcy5fcm9vdERhdGEgPSByb290RGF0YTtcbiAgdGhpcy5fa2V5UGF0aCA9IGtleVBhdGg7XG4gIHRoaXMuX29uQ2hhbmdlID0gb25DaGFuZ2U7XG59O1xuKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoQ3Vyc29yLCB7XG4gIGRlcmVmOiBmdW5jdGlvbihub3RTZXRWYWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9yb290RGF0YS5nZXRJbih0aGlzLl9rZXlQYXRoLCBub3RTZXRWYWx1ZSk7XG4gIH0sXG4gIGdldDogZnVuY3Rpb24oa2V5LCBub3RTZXRWYWx1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGtleSkgJiYga2V5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHZhciB2YWx1ZSA9IHRoaXMuX3Jvb3REYXRhLmdldEluKHRoaXMuX2tleVBhdGguY29uY2F0KGtleSksIE5PVF9TRVQpO1xuICAgIHJldHVybiB2YWx1ZSA9PT0gTk9UX1NFVCA/IG5vdFNldFZhbHVlIDogd3JhcHBlZFZhbHVlKHRoaXMsIGtleSwgdmFsdWUpO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gdXBkYXRlQ3Vyc29yKHRoaXMsIChmdW5jdGlvbihtKSB7XG4gICAgICByZXR1cm4gbS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfSksIGtleSk7XG4gIH0sXG4gIHJlbW92ZTogZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIHVwZGF0ZUN1cnNvcih0aGlzLCAoZnVuY3Rpb24obSkge1xuICAgICAgcmV0dXJuIG0ucmVtb3ZlKGtleSk7XG4gICAgfSksIGtleSk7XG4gIH0sXG4gIGNsZWFyOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdXBkYXRlQ3Vyc29yKHRoaXMsIChmdW5jdGlvbihtKSB7XG4gICAgICByZXR1cm4gbS5jbGVhcigpO1xuICAgIH0pKTtcbiAgfSxcbiAgdXBkYXRlOiBmdW5jdGlvbihrZXlPckZuLCBub3RTZXRWYWx1ZSwgdXBkYXRlcikge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gdXBkYXRlQ3Vyc29yKHRoaXMsIGtleU9yRm4pIDogdXBkYXRlQ3Vyc29yKHRoaXMsIChmdW5jdGlvbihtYXApIHtcbiAgICAgIHJldHVybiBtYXAudXBkYXRlKGtleU9yRm4sIG5vdFNldFZhbHVlLCB1cGRhdGVyKTtcbiAgICB9KSwga2V5T3JGbik7XG4gIH0sXG4gIHdpdGhNdXRhdGlvbnM6IGZ1bmN0aW9uKGZuKSB7XG4gICAgcmV0dXJuIHVwZGF0ZUN1cnNvcih0aGlzLCAoZnVuY3Rpb24obSkge1xuICAgICAgcmV0dXJuIChtIHx8IE1hcC5lbXB0eSgpKS53aXRoTXV0YXRpb25zKGZuKTtcbiAgICB9KSk7XG4gIH0sXG4gIGN1cnNvcjogZnVuY3Rpb24oc3ViS2V5KSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoc3ViS2V5KSAmJiBzdWJLZXkubGVuZ3RoID09PSAwID8gdGhpcyA6IHN1YkN1cnNvcih0aGlzLCBzdWJLZXkpO1xuICB9LFxuICBfX2l0ZXJhdGU6IGZ1bmN0aW9uKGZuLCByZXZlcnNlLCBmbGlwSW5kaWNlcykge1xuICAgIHZhciBjdXJzb3IgPSB0aGlzO1xuICAgIHZhciBkZXJlZiA9IGN1cnNvci5kZXJlZigpO1xuICAgIHJldHVybiBkZXJlZiAmJiBkZXJlZi5fX2l0ZXJhdGUgPyBkZXJlZi5fX2l0ZXJhdGUoKGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybiBmbih3cmFwcGVkVmFsdWUoY3Vyc29yLCBrZXksIHZhbHVlKSwga2V5LCBjb2xsZWN0aW9uKTtcbiAgICB9KSwgcmV2ZXJzZSwgZmxpcEluZGljZXMpIDogMDtcbiAgfVxufSwge30sIFNlcXVlbmNlKTtcbkN1cnNvci5wcm90b3R5cGVbREVMRVRFXSA9IEN1cnNvci5wcm90b3R5cGUucmVtb3ZlO1xuQ3Vyc29yLnByb3RvdHlwZS5nZXRJbiA9IEN1cnNvci5wcm90b3R5cGUuZ2V0O1xuZnVuY3Rpb24gd3JhcHBlZFZhbHVlKGN1cnNvciwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBTZXF1ZW5jZSA/IHN1YkN1cnNvcihjdXJzb3IsIGtleSwgdmFsdWUpIDogdmFsdWU7XG59XG5mdW5jdGlvbiBzdWJDdXJzb3IoY3Vyc29yLCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBuZXcgQ3Vyc29yKGN1cnNvci5fcm9vdERhdGEsIGN1cnNvci5fa2V5UGF0aC5jb25jYXQoa2V5KSwgY3Vyc29yLl9vbkNoYW5nZSwgdmFsdWUpO1xufVxuZnVuY3Rpb24gdXBkYXRlQ3Vyc29yKGN1cnNvciwgY2hhbmdlRm4sIGNoYW5nZUtleSkge1xuICB2YXIgbmV3Um9vdERhdGEgPSBjdXJzb3IuX3Jvb3REYXRhLnVwZGF0ZUluKGN1cnNvci5fa2V5UGF0aCwgY2hhbmdlS2V5ID8gTWFwLmVtcHR5KCkgOiB1bmRlZmluZWQsIGNoYW5nZUZuKTtcbiAgdmFyIGtleVBhdGggPSBjdXJzb3IuX2tleVBhdGggfHwgW107XG4gIGN1cnNvci5fb25DaGFuZ2UgJiYgY3Vyc29yLl9vbkNoYW5nZS5jYWxsKHVuZGVmaW5lZCwgbmV3Um9vdERhdGEsIGN1cnNvci5fcm9vdERhdGEsIGNoYW5nZUtleSA/IGtleVBhdGguY29uY2F0KGNoYW5nZUtleSkgOiBrZXlQYXRoKTtcbiAgcmV0dXJuIG5ldyBDdXJzb3IobmV3Um9vdERhdGEsIGN1cnNvci5fa2V5UGF0aCwgY3Vyc29yLl9vbkNoYW5nZSk7XG59XG5mdW5jdGlvbiBpcyhmaXJzdCwgc2Vjb25kKSB7XG4gIGlmIChmaXJzdCBpbnN0YW5jZW9mIEN1cnNvcikge1xuICAgIGZpcnN0ID0gZmlyc3QuZGVyZWYoKTtcbiAgfVxuICBpZiAoc2Vjb25kIGluc3RhbmNlb2YgQ3Vyc29yKSB7XG4gICAgc2Vjb25kID0gc2Vjb25kLmRlcmVmKCk7XG4gIH1cbiAgaWYgKGZpcnN0ID09PSBzZWNvbmQpIHtcbiAgICByZXR1cm4gZmlyc3QgIT09IDAgfHwgc2Vjb25kICE9PSAwIHx8IDEgLyBmaXJzdCA9PT0gMSAvIHNlY29uZDtcbiAgfVxuICBpZiAoZmlyc3QgIT09IGZpcnN0KSB7XG4gICAgcmV0dXJuIHNlY29uZCAhPT0gc2Vjb25kO1xuICB9XG4gIGlmIChmaXJzdCBpbnN0YW5jZW9mIFNlcXVlbmNlKSB7XG4gICAgcmV0dXJuIGZpcnN0LmVxdWFscyhzZWNvbmQpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbnZhciBNYXAgPSBmdW5jdGlvbiBNYXAoc2VxdWVuY2UpIHtcbiAgdmFyIG1hcCA9ICRNYXAuZW1wdHkoKTtcbiAgcmV0dXJuIHNlcXVlbmNlID8gc2VxdWVuY2UuY29uc3RydWN0b3IgPT09ICRNYXAgPyBzZXF1ZW5jZSA6IG1hcC5tZXJnZShzZXF1ZW5jZSkgOiBtYXA7XG59O1xudmFyICRNYXAgPSBNYXA7XG4oJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShNYXAsIHtcbiAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9fdG9TdHJpbmcoJ01hcCB7JywgJ30nKTtcbiAgfSxcbiAgZ2V0OiBmdW5jdGlvbihrLCBub3RTZXRWYWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9yb290ID8gdGhpcy5fcm9vdC5nZXQoMCwgaGFzaChrKSwgaywgbm90U2V0VmFsdWUpIDogbm90U2V0VmFsdWU7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oaywgdikge1xuICAgIHJldHVybiB1cGRhdGVNYXAodGhpcywgaywgdik7XG4gIH0sXG4gIHJlbW92ZTogZnVuY3Rpb24oaykge1xuICAgIHJldHVybiB1cGRhdGVNYXAodGhpcywgaywgTk9UX1NFVCk7XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24oaywgbm90U2V0VmFsdWUsIHVwZGF0ZXIpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IHRoaXMudXBkYXRlSW4oW10sIG51bGwsIGspIDogdGhpcy51cGRhdGVJbihba10sIG5vdFNldFZhbHVlLCB1cGRhdGVyKTtcbiAgfSxcbiAgdXBkYXRlSW46IGZ1bmN0aW9uKGtleVBhdGgsIG5vdFNldFZhbHVlLCB1cGRhdGVyKSB7XG4gICAgdmFyICRfXzEyO1xuICAgIGlmICghdXBkYXRlcikge1xuICAgICAgKCRfXzEyID0gW25vdFNldFZhbHVlLCB1cGRhdGVyXSwgdXBkYXRlciA9ICRfXzEyWzBdLCBub3RTZXRWYWx1ZSA9ICRfXzEyWzFdLCAkX18xMik7XG4gICAgfVxuICAgIHJldHVybiB1cGRhdGVJbkRlZXBNYXAodGhpcywga2V5UGF0aCwgbm90U2V0VmFsdWUsIHVwZGF0ZXIsIDApO1xuICB9LFxuICBjbGVhcjogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKHRoaXMuX19vd25lcklEKSB7XG4gICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICB0aGlzLl9yb290ID0gbnVsbDtcbiAgICAgIHRoaXMuX19oYXNoID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fX2FsdGVyZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiAkTWFwLmVtcHR5KCk7XG4gIH0sXG4gIG1lcmdlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbWVyZ2VJbnRvTWFwV2l0aCh0aGlzLCBudWxsLCBhcmd1bWVudHMpO1xuICB9LFxuICBtZXJnZVdpdGg6IGZ1bmN0aW9uKG1lcmdlcikge1xuICAgIGZvciAodmFyIHNlcXMgPSBbXSxcbiAgICAgICAgJF9fMyA9IDE7ICRfXzMgPCBhcmd1bWVudHMubGVuZ3RoOyAkX18zKyspXG4gICAgICBzZXFzWyRfXzMgLSAxXSA9IGFyZ3VtZW50c1skX18zXTtcbiAgICByZXR1cm4gbWVyZ2VJbnRvTWFwV2l0aCh0aGlzLCBtZXJnZXIsIHNlcXMpO1xuICB9LFxuICBtZXJnZURlZXA6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBtZXJnZUludG9NYXBXaXRoKHRoaXMsIGRlZXBNZXJnZXIobnVsbCksIGFyZ3VtZW50cyk7XG4gIH0sXG4gIG1lcmdlRGVlcFdpdGg6IGZ1bmN0aW9uKG1lcmdlcikge1xuICAgIGZvciAodmFyIHNlcXMgPSBbXSxcbiAgICAgICAgJF9fNCA9IDE7ICRfXzQgPCBhcmd1bWVudHMubGVuZ3RoOyAkX180KyspXG4gICAgICBzZXFzWyRfXzQgLSAxXSA9IGFyZ3VtZW50c1skX180XTtcbiAgICByZXR1cm4gbWVyZ2VJbnRvTWFwV2l0aCh0aGlzLCBkZWVwTWVyZ2VyKG1lcmdlciksIHNlcXMpO1xuICB9LFxuICBjdXJzb3I6IGZ1bmN0aW9uKGtleVBhdGgsIG9uQ2hhbmdlKSB7XG4gICAgaWYgKCFvbkNoYW5nZSAmJiB0eXBlb2Yga2V5UGF0aCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb25DaGFuZ2UgPSBrZXlQYXRoO1xuICAgICAga2V5UGF0aCA9IFtdO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAga2V5UGF0aCA9IFtdO1xuICAgIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoa2V5UGF0aCkpIHtcbiAgICAgIGtleVBhdGggPSBba2V5UGF0aF07XG4gICAgfVxuICAgIHJldHVybiBuZXcgQ3Vyc29yKHRoaXMsIGtleVBhdGgsIG9uQ2hhbmdlKTtcbiAgfSxcbiAgd2l0aE11dGF0aW9uczogZnVuY3Rpb24oZm4pIHtcbiAgICB2YXIgbXV0YWJsZSA9IHRoaXMuYXNNdXRhYmxlKCk7XG4gICAgZm4obXV0YWJsZSk7XG4gICAgcmV0dXJuIG11dGFibGUud2FzQWx0ZXJlZCgpID8gbXV0YWJsZS5fX2Vuc3VyZU93bmVyKHRoaXMuX19vd25lcklEKSA6IHRoaXM7XG4gIH0sXG4gIGFzTXV0YWJsZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX19vd25lcklEID8gdGhpcyA6IHRoaXMuX19lbnN1cmVPd25lcihuZXcgT3duZXJJRCgpKTtcbiAgfSxcbiAgYXNJbW11dGFibGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9fZW5zdXJlT3duZXIoKTtcbiAgfSxcbiAgd2FzQWx0ZXJlZDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX19hbHRlcmVkO1xuICB9LFxuICBrZXlzOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IE1hcEl0ZXJhdG9yKHRoaXMsIDApO1xuICB9LFxuICB2YWx1ZXM6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgTWFwSXRlcmF0b3IodGhpcywgMSk7XG4gIH0sXG4gIGVudHJpZXM6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgTWFwSXRlcmF0b3IodGhpcywgMik7XG4gIH0sXG4gIF9faXRlcmF0b3I6IGZ1bmN0aW9uKHJldmVyc2UpIHtcbiAgICByZXR1cm4gbmV3IE1hcEl0ZXJhdG9yKHRoaXMsIDIsIHJldmVyc2UpO1xuICB9LFxuICBfX2l0ZXJhdGU6IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7XG4gICAgdmFyIG1hcCA9IHRoaXM7XG4gICAgaWYgKCFtYXAuX3Jvb3QpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgdGhpcy5fcm9vdC5pdGVyYXRlKChmdW5jdGlvbihlbnRyeSkge1xuICAgICAgaWYgKGZuKGVudHJ5WzFdLCBlbnRyeVswXSwgbWFwKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaXRlcmF0aW9ucysrO1xuICAgIH0pLCByZXZlcnNlKTtcbiAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgfSxcbiAgX19kZWVwRXF1YWw6IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBvdGhlci5ldmVyeSgoZnVuY3Rpb24odiwgaykge1xuICAgICAgcmV0dXJuIGlzKHNlbGYuZ2V0KGssIE5PVF9TRVQpLCB2KTtcbiAgICB9KSk7XG4gIH0sXG4gIF9fZW5zdXJlT3duZXI6IGZ1bmN0aW9uKG93bmVySUQpIHtcbiAgICBpZiAob3duZXJJRCA9PT0gdGhpcy5fX293bmVySUQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAoIW93bmVySUQpIHtcbiAgICAgIHRoaXMuX19vd25lcklEID0gb3duZXJJRDtcbiAgICAgIHRoaXMuX19hbHRlcmVkID0gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIG1ha2VNYXAodGhpcy5sZW5ndGgsIHRoaXMuX3Jvb3QsIG93bmVySUQsIHRoaXMuX19oYXNoKTtcbiAgfVxufSwge2VtcHR5OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gRU1QVFlfTUFQIHx8IChFTVBUWV9NQVAgPSBtYWtlTWFwKDApKTtcbiAgfX0sIFNlcXVlbmNlKTtcbnZhciBNYXBQcm90b3R5cGUgPSBNYXAucHJvdG90eXBlO1xuTWFwUHJvdG90eXBlW0RFTEVURV0gPSBNYXBQcm90b3R5cGUucmVtb3ZlO1xuTWFwUHJvdG90eXBlW0lURVJBVE9SXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5lbnRyaWVzKCk7XG59O1xuTWFwLmZyb20gPSBNYXA7XG52YXIgQml0bWFwSW5kZXhlZE5vZGUgPSBmdW5jdGlvbiBCaXRtYXBJbmRleGVkTm9kZShvd25lcklELCBiaXRtYXAsIG5vZGVzKSB7XG4gIHRoaXMub3duZXJJRCA9IG93bmVySUQ7XG4gIHRoaXMuYml0bWFwID0gYml0bWFwO1xuICB0aGlzLm5vZGVzID0gbm9kZXM7XG59O1xudmFyICRCaXRtYXBJbmRleGVkTm9kZSA9IEJpdG1hcEluZGV4ZWROb2RlO1xuKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoQml0bWFwSW5kZXhlZE5vZGUsIHtcbiAgZ2V0OiBmdW5jdGlvbihzaGlmdCwgaGFzaCwga2V5LCBub3RTZXRWYWx1ZSkge1xuICAgIHZhciBiaXQgPSAoMSA8PCAoKGhhc2ggPj4+IHNoaWZ0KSAmIE1BU0spKTtcbiAgICB2YXIgYml0bWFwID0gdGhpcy5iaXRtYXA7XG4gICAgcmV0dXJuIChiaXRtYXAgJiBiaXQpID09PSAwID8gbm90U2V0VmFsdWUgOiB0aGlzLm5vZGVzW3BvcENvdW50KGJpdG1hcCAmIChiaXQgLSAxKSldLmdldChzaGlmdCArIFNISUZULCBoYXNoLCBrZXksIG5vdFNldFZhbHVlKTtcbiAgfSxcbiAgdXBkYXRlOiBmdW5jdGlvbihvd25lcklELCBzaGlmdCwgaGFzaCwga2V5LCB2YWx1ZSwgZGlkQ2hhbmdlTGVuZ3RoLCBkaWRBbHRlcikge1xuICAgIHZhciBoYXNoRnJhZyA9IChoYXNoID4+PiBzaGlmdCkgJiBNQVNLO1xuICAgIHZhciBiaXQgPSAxIDw8IGhhc2hGcmFnO1xuICAgIHZhciBiaXRtYXAgPSB0aGlzLmJpdG1hcDtcbiAgICB2YXIgZXhpc3RzID0gKGJpdG1hcCAmIGJpdCkgIT09IDA7XG4gICAgaWYgKCFleGlzdHMgJiYgdmFsdWUgPT09IE5PVF9TRVQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2YXIgaWR4ID0gcG9wQ291bnQoYml0bWFwICYgKGJpdCAtIDEpKTtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzO1xuICAgIHZhciBub2RlID0gZXhpc3RzID8gbm9kZXNbaWR4XSA6IG51bGw7XG4gICAgdmFyIG5ld05vZGUgPSB1cGRhdGVOb2RlKG5vZGUsIG93bmVySUQsIHNoaWZ0ICsgU0hJRlQsIGhhc2gsIGtleSwgdmFsdWUsIGRpZENoYW5nZUxlbmd0aCwgZGlkQWx0ZXIpO1xuICAgIGlmIChuZXdOb2RlID09PSBub2RlKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKCFleGlzdHMgJiYgbmV3Tm9kZSAmJiBub2Rlcy5sZW5ndGggPj0gTUFYX0JJVE1BUF9TSVpFKSB7XG4gICAgICByZXR1cm4gZXhwYW5kTm9kZXMob3duZXJJRCwgbm9kZXMsIGJpdG1hcCwgaGFzaEZyYWcsIG5ld05vZGUpO1xuICAgIH1cbiAgICBpZiAoZXhpc3RzICYmICFuZXdOb2RlICYmIG5vZGVzLmxlbmd0aCA9PT0gMiAmJiBpc0xlYWZOb2RlKG5vZGVzW2lkeCBeIDFdKSkge1xuICAgICAgcmV0dXJuIG5vZGVzW2lkeCBeIDFdO1xuICAgIH1cbiAgICBpZiAoZXhpc3RzICYmIG5ld05vZGUgJiYgbm9kZXMubGVuZ3RoID09PSAxICYmIGlzTGVhZk5vZGUobmV3Tm9kZSkpIHtcbiAgICAgIHJldHVybiBuZXdOb2RlO1xuICAgIH1cbiAgICB2YXIgaXNFZGl0YWJsZSA9IG93bmVySUQgJiYgb3duZXJJRCA9PT0gdGhpcy5vd25lcklEO1xuICAgIHZhciBuZXdCaXRtYXAgPSBleGlzdHMgPyBuZXdOb2RlID8gYml0bWFwIDogYml0bWFwIF4gYml0IDogYml0bWFwIHwgYml0O1xuICAgIHZhciBuZXdOb2RlcyA9IGV4aXN0cyA/IG5ld05vZGUgPyBzZXRJbihub2RlcywgaWR4LCBuZXdOb2RlLCBpc0VkaXRhYmxlKSA6IHNwbGljZU91dChub2RlcywgaWR4LCBpc0VkaXRhYmxlKSA6IHNwbGljZUluKG5vZGVzLCBpZHgsIG5ld05vZGUsIGlzRWRpdGFibGUpO1xuICAgIGlmIChpc0VkaXRhYmxlKSB7XG4gICAgICB0aGlzLmJpdG1hcCA9IG5ld0JpdG1hcDtcbiAgICAgIHRoaXMubm9kZXMgPSBuZXdOb2RlcztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gbmV3ICRCaXRtYXBJbmRleGVkTm9kZShvd25lcklELCBuZXdCaXRtYXAsIG5ld05vZGVzKTtcbiAgfSxcbiAgaXRlcmF0ZTogZnVuY3Rpb24oZm4sIHJldmVyc2UpIHtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzO1xuICAgIGZvciAodmFyIGlpID0gMCxcbiAgICAgICAgbWF4SW5kZXggPSBub2Rlcy5sZW5ndGggLSAxOyBpaSA8PSBtYXhJbmRleDsgaWkrKykge1xuICAgICAgaWYgKG5vZGVzW3JldmVyc2UgPyBtYXhJbmRleCAtIGlpIDogaWldLml0ZXJhdGUoZm4sIHJldmVyc2UpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG59LCB7fSk7XG52YXIgQXJyYXlOb2RlID0gZnVuY3Rpb24gQXJyYXlOb2RlKG93bmVySUQsIGNvdW50LCBub2Rlcykge1xuICB0aGlzLm93bmVySUQgPSBvd25lcklEO1xuICB0aGlzLmNvdW50ID0gY291bnQ7XG4gIHRoaXMubm9kZXMgPSBub2Rlcztcbn07XG52YXIgJEFycmF5Tm9kZSA9IEFycmF5Tm9kZTtcbigkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKEFycmF5Tm9kZSwge1xuICBnZXQ6IGZ1bmN0aW9uKHNoaWZ0LCBoYXNoLCBrZXksIG5vdFNldFZhbHVlKSB7XG4gICAgdmFyIGlkeCA9IChoYXNoID4+PiBzaGlmdCkgJiBNQVNLO1xuICAgIHZhciBub2RlID0gdGhpcy5ub2Rlc1tpZHhdO1xuICAgIHJldHVybiBub2RlID8gbm9kZS5nZXQoc2hpZnQgKyBTSElGVCwgaGFzaCwga2V5LCBub3RTZXRWYWx1ZSkgOiBub3RTZXRWYWx1ZTtcbiAgfSxcbiAgdXBkYXRlOiBmdW5jdGlvbihvd25lcklELCBzaGlmdCwgaGFzaCwga2V5LCB2YWx1ZSwgZGlkQ2hhbmdlTGVuZ3RoLCBkaWRBbHRlcikge1xuICAgIHZhciBpZHggPSAoaGFzaCA+Pj4gc2hpZnQpICYgTUFTSztcbiAgICB2YXIgcmVtb3ZlZCA9IHZhbHVlID09PSBOT1RfU0VUO1xuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXM7XG4gICAgdmFyIG5vZGUgPSBub2Rlc1tpZHhdO1xuICAgIGlmIChyZW1vdmVkICYmICFub2RlKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIG5ld05vZGUgPSB1cGRhdGVOb2RlKG5vZGUsIG93bmVySUQsIHNoaWZ0ICsgU0hJRlQsIGhhc2gsIGtleSwgdmFsdWUsIGRpZENoYW5nZUxlbmd0aCwgZGlkQWx0ZXIpO1xuICAgIGlmIChuZXdOb2RlID09PSBub2RlKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIG5ld0NvdW50ID0gdGhpcy5jb3VudDtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIG5ld0NvdW50Kys7XG4gICAgfSBlbHNlIGlmICghbmV3Tm9kZSkge1xuICAgICAgbmV3Q291bnQtLTtcbiAgICAgIGlmIChuZXdDb3VudCA8IE1JTl9BUlJBWV9TSVpFKSB7XG4gICAgICAgIHJldHVybiBwYWNrTm9kZXMob3duZXJJRCwgbm9kZXMsIG5ld0NvdW50LCBpZHgpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgaXNFZGl0YWJsZSA9IG93bmVySUQgJiYgb3duZXJJRCA9PT0gdGhpcy5vd25lcklEO1xuICAgIHZhciBuZXdOb2RlcyA9IHNldEluKG5vZGVzLCBpZHgsIG5ld05vZGUsIGlzRWRpdGFibGUpO1xuICAgIGlmIChpc0VkaXRhYmxlKSB7XG4gICAgICB0aGlzLmNvdW50ID0gbmV3Q291bnQ7XG4gICAgICB0aGlzLm5vZGVzID0gbmV3Tm9kZXM7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIG5ldyAkQXJyYXlOb2RlKG93bmVySUQsIG5ld0NvdW50LCBuZXdOb2Rlcyk7XG4gIH0sXG4gIGl0ZXJhdGU6IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcztcbiAgICBmb3IgKHZhciBpaSA9IDAsXG4gICAgICAgIG1heEluZGV4ID0gbm9kZXMubGVuZ3RoIC0gMTsgaWkgPD0gbWF4SW5kZXg7IGlpKyspIHtcbiAgICAgIHZhciBub2RlID0gbm9kZXNbcmV2ZXJzZSA/IG1heEluZGV4IC0gaWkgOiBpaV07XG4gICAgICBpZiAobm9kZSAmJiBub2RlLml0ZXJhdGUoZm4sIHJldmVyc2UpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG59LCB7fSk7XG52YXIgSGFzaENvbGxpc2lvbk5vZGUgPSBmdW5jdGlvbiBIYXNoQ29sbGlzaW9uTm9kZShvd25lcklELCBoYXNoLCBlbnRyaWVzKSB7XG4gIHRoaXMub3duZXJJRCA9IG93bmVySUQ7XG4gIHRoaXMuaGFzaCA9IGhhc2g7XG4gIHRoaXMuZW50cmllcyA9IGVudHJpZXM7XG59O1xudmFyICRIYXNoQ29sbGlzaW9uTm9kZSA9IEhhc2hDb2xsaXNpb25Ob2RlO1xuKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoSGFzaENvbGxpc2lvbk5vZGUsIHtcbiAgZ2V0OiBmdW5jdGlvbihzaGlmdCwgaGFzaCwga2V5LCBub3RTZXRWYWx1ZSkge1xuICAgIHZhciBlbnRyaWVzID0gdGhpcy5lbnRyaWVzO1xuICAgIGZvciAodmFyIGlpID0gMCxcbiAgICAgICAgbGVuID0gZW50cmllcy5sZW5ndGg7IGlpIDwgbGVuOyBpaSsrKSB7XG4gICAgICBpZiAoaXMoa2V5LCBlbnRyaWVzW2lpXVswXSkpIHtcbiAgICAgICAgcmV0dXJuIGVudHJpZXNbaWldWzFdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm90U2V0VmFsdWU7XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24ob3duZXJJRCwgc2hpZnQsIGhhc2gsIGtleSwgdmFsdWUsIGRpZENoYW5nZUxlbmd0aCwgZGlkQWx0ZXIpIHtcbiAgICB2YXIgcmVtb3ZlZCA9IHZhbHVlID09PSBOT1RfU0VUO1xuICAgIGlmIChoYXNoICE9PSB0aGlzLmhhc2gpIHtcbiAgICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgU2V0UmVmKGRpZEFsdGVyKTtcbiAgICAgIFNldFJlZihkaWRDaGFuZ2VMZW5ndGgpO1xuICAgICAgcmV0dXJuIG1lcmdlSW50b05vZGUodGhpcywgb3duZXJJRCwgc2hpZnQsIGhhc2gsIFtrZXksIHZhbHVlXSk7XG4gICAgfVxuICAgIHZhciBlbnRyaWVzID0gdGhpcy5lbnRyaWVzO1xuICAgIHZhciBpZHggPSAwO1xuICAgIGZvciAodmFyIGxlbiA9IGVudHJpZXMubGVuZ3RoOyBpZHggPCBsZW47IGlkeCsrKSB7XG4gICAgICBpZiAoaXMoa2V5LCBlbnRyaWVzW2lkeF1bMF0pKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgZXhpc3RzID0gaWR4IDwgbGVuO1xuICAgIGlmIChyZW1vdmVkICYmICFleGlzdHMpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBTZXRSZWYoZGlkQWx0ZXIpO1xuICAgIChyZW1vdmVkIHx8ICFleGlzdHMpICYmIFNldFJlZihkaWRDaGFuZ2VMZW5ndGgpO1xuICAgIGlmIChyZW1vdmVkICYmIGxlbiA9PT0gMikge1xuICAgICAgcmV0dXJuIG5ldyBWYWx1ZU5vZGUob3duZXJJRCwgdGhpcy5oYXNoLCBlbnRyaWVzW2lkeCBeIDFdKTtcbiAgICB9XG4gICAgdmFyIGlzRWRpdGFibGUgPSBvd25lcklEICYmIG93bmVySUQgPT09IHRoaXMub3duZXJJRDtcbiAgICB2YXIgbmV3RW50cmllcyA9IGlzRWRpdGFibGUgPyBlbnRyaWVzIDogYXJyQ29weShlbnRyaWVzKTtcbiAgICBpZiAoZXhpc3RzKSB7XG4gICAgICBpZiAocmVtb3ZlZCkge1xuICAgICAgICBpZHggPT09IGxlbiAtIDEgPyBuZXdFbnRyaWVzLnBvcCgpIDogKG5ld0VudHJpZXNbaWR4XSA9IG5ld0VudHJpZXMucG9wKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3RW50cmllc1tpZHhdID0gW2tleSwgdmFsdWVdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXdFbnRyaWVzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICB9XG4gICAgaWYgKGlzRWRpdGFibGUpIHtcbiAgICAgIHRoaXMuZW50cmllcyA9IG5ld0VudHJpZXM7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIG5ldyAkSGFzaENvbGxpc2lvbk5vZGUob3duZXJJRCwgdGhpcy5oYXNoLCBuZXdFbnRyaWVzKTtcbiAgfSxcbiAgaXRlcmF0ZTogZnVuY3Rpb24oZm4sIHJldmVyc2UpIHtcbiAgICB2YXIgZW50cmllcyA9IHRoaXMuZW50cmllcztcbiAgICBmb3IgKHZhciBpaSA9IDAsXG4gICAgICAgIG1heEluZGV4ID0gZW50cmllcy5sZW5ndGggLSAxOyBpaSA8PSBtYXhJbmRleDsgaWkrKykge1xuICAgICAgaWYgKGZuKGVudHJpZXNbcmV2ZXJzZSA/IG1heEluZGV4IC0gaWkgOiBpaV0pID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG59LCB7fSk7XG52YXIgVmFsdWVOb2RlID0gZnVuY3Rpb24gVmFsdWVOb2RlKG93bmVySUQsIGhhc2gsIGVudHJ5KSB7XG4gIHRoaXMub3duZXJJRCA9IG93bmVySUQ7XG4gIHRoaXMuaGFzaCA9IGhhc2g7XG4gIHRoaXMuZW50cnkgPSBlbnRyeTtcbn07XG52YXIgJFZhbHVlTm9kZSA9IFZhbHVlTm9kZTtcbigkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKFZhbHVlTm9kZSwge1xuICBnZXQ6IGZ1bmN0aW9uKHNoaWZ0LCBoYXNoLCBrZXksIG5vdFNldFZhbHVlKSB7XG4gICAgcmV0dXJuIGlzKGtleSwgdGhpcy5lbnRyeVswXSkgPyB0aGlzLmVudHJ5WzFdIDogbm90U2V0VmFsdWU7XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24ob3duZXJJRCwgc2hpZnQsIGhhc2gsIGtleSwgdmFsdWUsIGRpZENoYW5nZUxlbmd0aCwgZGlkQWx0ZXIpIHtcbiAgICB2YXIgcmVtb3ZlZCA9IHZhbHVlID09PSBOT1RfU0VUO1xuICAgIHZhciBrZXlNYXRjaCA9IGlzKGtleSwgdGhpcy5lbnRyeVswXSk7XG4gICAgaWYgKGtleU1hdGNoID8gdmFsdWUgPT09IHRoaXMuZW50cnlbMV0gOiByZW1vdmVkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgU2V0UmVmKGRpZEFsdGVyKTtcbiAgICBpZiAocmVtb3ZlZCkge1xuICAgICAgU2V0UmVmKGRpZENoYW5nZUxlbmd0aCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGtleU1hdGNoKSB7XG4gICAgICBpZiAob3duZXJJRCAmJiBvd25lcklEID09PSB0aGlzLm93bmVySUQpIHtcbiAgICAgICAgdGhpcy5lbnRyeVsxXSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgJFZhbHVlTm9kZShvd25lcklELCBoYXNoLCBba2V5LCB2YWx1ZV0pO1xuICAgIH1cbiAgICBTZXRSZWYoZGlkQ2hhbmdlTGVuZ3RoKTtcbiAgICByZXR1cm4gbWVyZ2VJbnRvTm9kZSh0aGlzLCBvd25lcklELCBzaGlmdCwgaGFzaCwgW2tleSwgdmFsdWVdKTtcbiAgfSxcbiAgaXRlcmF0ZTogZnVuY3Rpb24oZm4pIHtcbiAgICByZXR1cm4gZm4odGhpcy5lbnRyeSk7XG4gIH1cbn0sIHt9KTtcbnZhciBNYXBJdGVyYXRvciA9IGZ1bmN0aW9uIE1hcEl0ZXJhdG9yKG1hcCwgdHlwZSwgcmV2ZXJzZSkge1xuICB0aGlzLl90eXBlID0gdHlwZTtcbiAgdGhpcy5fcmV2ZXJzZSA9IHJldmVyc2U7XG4gIHRoaXMuX3N0YWNrID0gbWFwLl9yb290ICYmIG1hcEl0ZXJhdG9yRnJhbWUobWFwLl9yb290KTtcbn07XG4oJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShNYXBJdGVyYXRvciwge25leHQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0eXBlID0gdGhpcy5fdHlwZTtcbiAgICB2YXIgc3RhY2sgPSB0aGlzLl9zdGFjaztcbiAgICB3aGlsZSAoc3RhY2spIHtcbiAgICAgIHZhciBub2RlID0gc3RhY2subm9kZTtcbiAgICAgIHZhciBpbmRleCA9IHN0YWNrLmluZGV4Kys7XG4gICAgICB2YXIgbWF4SW5kZXg7XG4gICAgICBpZiAobm9kZS5lbnRyeSkge1xuICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gbWFwSXRlcmF0b3JWYWx1ZSh0eXBlLCBub2RlLmVudHJ5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChub2RlLmVudHJpZXMpIHtcbiAgICAgICAgbWF4SW5kZXggPSBub2RlLmVudHJpZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGluZGV4IDw9IG1heEluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIG1hcEl0ZXJhdG9yVmFsdWUodHlwZSwgbm9kZS5lbnRyaWVzW3RoaXMuX3JldmVyc2UgPyBtYXhJbmRleCAtIGluZGV4IDogaW5kZXhdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF4SW5kZXggPSBub2RlLm5vZGVzLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChpbmRleCA8PSBtYXhJbmRleCkge1xuICAgICAgICAgIHZhciBzdWJOb2RlID0gbm9kZS5ub2Rlc1t0aGlzLl9yZXZlcnNlID8gbWF4SW5kZXggLSBpbmRleCA6IGluZGV4XTtcbiAgICAgICAgICBpZiAoc3ViTm9kZSkge1xuICAgICAgICAgICAgaWYgKHN1Yk5vZGUuZW50cnkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG1hcEl0ZXJhdG9yVmFsdWUodHlwZSwgc3ViTm9kZS5lbnRyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFjayA9IHRoaXMuX3N0YWNrID0gbWFwSXRlcmF0b3JGcmFtZShzdWJOb2RlLCBzdGFjayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGFjayA9IHRoaXMuX3N0YWNrID0gdGhpcy5fc3RhY2suX19wcmV2O1xuICAgIH1cbiAgICByZXR1cm4gaXRlcmF0b3JEb25lKCk7XG4gIH19LCB7fSwgU2VxdWVuY2VJdGVyYXRvcik7XG5mdW5jdGlvbiBtYXBJdGVyYXRvclZhbHVlKHR5cGUsIGVudHJ5KSB7XG4gIHJldHVybiBpdGVyYXRvclZhbHVlKHR5cGUgPT09IDAgfHwgdHlwZSA9PT0gMSA/IGVudHJ5W3R5cGVdIDogW2VudHJ5WzBdLCBlbnRyeVsxXV0pO1xufVxuZnVuY3Rpb24gbWFwSXRlcmF0b3JGcmFtZShub2RlLCBwcmV2KSB7XG4gIHJldHVybiB7XG4gICAgbm9kZTogbm9kZSxcbiAgICBpbmRleDogMCxcbiAgICBfX3ByZXY6IHByZXZcbiAgfTtcbn1cbmZ1bmN0aW9uIG1ha2VNYXAobGVuZ3RoLCByb290LCBvd25lcklELCBoYXNoKSB7XG4gIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKE1hcFByb3RvdHlwZSk7XG4gIG1hcC5sZW5ndGggPSBsZW5ndGg7XG4gIG1hcC5fcm9vdCA9IHJvb3Q7XG4gIG1hcC5fX293bmVySUQgPSBvd25lcklEO1xuICBtYXAuX19oYXNoID0gaGFzaDtcbiAgbWFwLl9fYWx0ZXJlZCA9IGZhbHNlO1xuICByZXR1cm4gbWFwO1xufVxuZnVuY3Rpb24gdXBkYXRlTWFwKG1hcCwgaywgdikge1xuICB2YXIgZGlkQ2hhbmdlTGVuZ3RoID0gTWFrZVJlZihDSEFOR0VfTEVOR1RIKTtcbiAgdmFyIGRpZEFsdGVyID0gTWFrZVJlZihESURfQUxURVIpO1xuICB2YXIgbmV3Um9vdCA9IHVwZGF0ZU5vZGUobWFwLl9yb290LCBtYXAuX19vd25lcklELCAwLCBoYXNoKGspLCBrLCB2LCBkaWRDaGFuZ2VMZW5ndGgsIGRpZEFsdGVyKTtcbiAgaWYgKCFkaWRBbHRlci52YWx1ZSkge1xuICAgIHJldHVybiBtYXA7XG4gIH1cbiAgdmFyIG5ld0xlbmd0aCA9IG1hcC5sZW5ndGggKyAoZGlkQ2hhbmdlTGVuZ3RoLnZhbHVlID8gdiA9PT0gTk9UX1NFVCA/IC0xIDogMSA6IDApO1xuICBpZiAobWFwLl9fb3duZXJJRCkge1xuICAgIG1hcC5sZW5ndGggPSBuZXdMZW5ndGg7XG4gICAgbWFwLl9yb290ID0gbmV3Um9vdDtcbiAgICBtYXAuX19oYXNoID0gdW5kZWZpbmVkO1xuICAgIG1hcC5fX2FsdGVyZWQgPSB0cnVlO1xuICAgIHJldHVybiBtYXA7XG4gIH1cbiAgcmV0dXJuIG5ld1Jvb3QgPyBtYWtlTWFwKG5ld0xlbmd0aCwgbmV3Um9vdCkgOiBNYXAuZW1wdHkoKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZU5vZGUobm9kZSwgb3duZXJJRCwgc2hpZnQsIGhhc2gsIGtleSwgdmFsdWUsIGRpZENoYW5nZUxlbmd0aCwgZGlkQWx0ZXIpIHtcbiAgaWYgKCFub2RlKSB7XG4gICAgaWYgKHZhbHVlID09PSBOT1RfU0VUKSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgU2V0UmVmKGRpZEFsdGVyKTtcbiAgICBTZXRSZWYoZGlkQ2hhbmdlTGVuZ3RoKTtcbiAgICByZXR1cm4gbmV3IFZhbHVlTm9kZShvd25lcklELCBoYXNoLCBba2V5LCB2YWx1ZV0pO1xuICB9XG4gIHJldHVybiBub2RlLnVwZGF0ZShvd25lcklELCBzaGlmdCwgaGFzaCwga2V5LCB2YWx1ZSwgZGlkQ2hhbmdlTGVuZ3RoLCBkaWRBbHRlcik7XG59XG5mdW5jdGlvbiBpc0xlYWZOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuY29uc3RydWN0b3IgPT09IFZhbHVlTm9kZSB8fCBub2RlLmNvbnN0cnVjdG9yID09PSBIYXNoQ29sbGlzaW9uTm9kZTtcbn1cbmZ1bmN0aW9uIG1lcmdlSW50b05vZGUobm9kZSwgb3duZXJJRCwgc2hpZnQsIGhhc2gsIGVudHJ5KSB7XG4gIGlmIChub2RlLmhhc2ggPT09IGhhc2gpIHtcbiAgICByZXR1cm4gbmV3IEhhc2hDb2xsaXNpb25Ob2RlKG93bmVySUQsIGhhc2gsIFtub2RlLmVudHJ5LCBlbnRyeV0pO1xuICB9XG4gIHZhciBpZHgxID0gKG5vZGUuaGFzaCA+Pj4gc2hpZnQpICYgTUFTSztcbiAgdmFyIGlkeDIgPSAoaGFzaCA+Pj4gc2hpZnQpICYgTUFTSztcbiAgdmFyIG5ld05vZGU7XG4gIHZhciBub2RlcyA9IGlkeDEgPT09IGlkeDIgPyBbbWVyZ2VJbnRvTm9kZShub2RlLCBvd25lcklELCBzaGlmdCArIFNISUZULCBoYXNoLCBlbnRyeSldIDogKChuZXdOb2RlID0gbmV3IFZhbHVlTm9kZShvd25lcklELCBoYXNoLCBlbnRyeSkpLCBpZHgxIDwgaWR4MiA/IFtub2RlLCBuZXdOb2RlXSA6IFtuZXdOb2RlLCBub2RlXSk7XG4gIHJldHVybiBuZXcgQml0bWFwSW5kZXhlZE5vZGUob3duZXJJRCwgKDEgPDwgaWR4MSkgfCAoMSA8PCBpZHgyKSwgbm9kZXMpO1xufVxuZnVuY3Rpb24gcGFja05vZGVzKG93bmVySUQsIG5vZGVzLCBjb3VudCwgZXhjbHVkaW5nKSB7XG4gIHZhciBiaXRtYXAgPSAwO1xuICB2YXIgcGFja2VkSUkgPSAwO1xuICB2YXIgcGFja2VkTm9kZXMgPSBuZXcgQXJyYXkoY291bnQpO1xuICBmb3IgKHZhciBpaSA9IDAsXG4gICAgICBiaXQgPSAxLFxuICAgICAgbGVuID0gbm9kZXMubGVuZ3RoOyBpaSA8IGxlbjsgaWkrKywgYml0IDw8PSAxKSB7XG4gICAgdmFyIG5vZGUgPSBub2Rlc1tpaV07XG4gICAgaWYgKG5vZGUgIT0gbnVsbCAmJiBpaSAhPT0gZXhjbHVkaW5nKSB7XG4gICAgICBiaXRtYXAgfD0gYml0O1xuICAgICAgcGFja2VkTm9kZXNbcGFja2VkSUkrK10gPSBub2RlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IEJpdG1hcEluZGV4ZWROb2RlKG93bmVySUQsIGJpdG1hcCwgcGFja2VkTm9kZXMpO1xufVxuZnVuY3Rpb24gZXhwYW5kTm9kZXMob3duZXJJRCwgbm9kZXMsIGJpdG1hcCwgaW5jbHVkaW5nLCBub2RlKSB7XG4gIHZhciBjb3VudCA9IDA7XG4gIHZhciBleHBhbmRlZE5vZGVzID0gbmV3IEFycmF5KFNJWkUpO1xuICBmb3IgKHZhciBpaSA9IDA7IGJpdG1hcCAhPT0gMDsgaWkrKywgYml0bWFwID4+Pj0gMSkge1xuICAgIGV4cGFuZGVkTm9kZXNbaWldID0gYml0bWFwICYgMSA/IG5vZGVzW2NvdW50KytdIDogbnVsbDtcbiAgfVxuICBleHBhbmRlZE5vZGVzW2luY2x1ZGluZ10gPSBub2RlO1xuICByZXR1cm4gbmV3IEFycmF5Tm9kZShvd25lcklELCBjb3VudCArIDEsIGV4cGFuZGVkTm9kZXMpO1xufVxuZnVuY3Rpb24gbWVyZ2VJbnRvTWFwV2l0aChtYXAsIG1lcmdlciwgaXRlcmFibGVzKSB7XG4gIHZhciBzZXFzID0gW107XG4gIGZvciAodmFyIGlpID0gMDsgaWkgPCBpdGVyYWJsZXMubGVuZ3RoOyBpaSsrKSB7XG4gICAgdmFyIHNlcSA9IGl0ZXJhYmxlc1tpaV07XG4gICAgc2VxICYmIHNlcXMucHVzaChBcnJheS5pc0FycmF5KHNlcSkgPyBTZXF1ZW5jZShzZXEpLmZyb21FbnRyeVNlcSgpIDogU2VxdWVuY2Uoc2VxKSk7XG4gIH1cbiAgcmV0dXJuIG1lcmdlSW50b0NvbGxlY3Rpb25XaXRoKG1hcCwgbWVyZ2VyLCBzZXFzKTtcbn1cbmZ1bmN0aW9uIGRlZXBNZXJnZXIobWVyZ2VyKSB7XG4gIHJldHVybiAoZnVuY3Rpb24oZXhpc3RpbmcsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGV4aXN0aW5nICYmIGV4aXN0aW5nLm1lcmdlRGVlcFdpdGggPyBleGlzdGluZy5tZXJnZURlZXBXaXRoKG1lcmdlciwgdmFsdWUpIDogbWVyZ2VyID8gbWVyZ2VyKGV4aXN0aW5nLCB2YWx1ZSkgOiB2YWx1ZTtcbiAgfSk7XG59XG5mdW5jdGlvbiBtZXJnZUludG9Db2xsZWN0aW9uV2l0aChjb2xsZWN0aW9uLCBtZXJnZXIsIHNlcXMpIHtcbiAgaWYgKHNlcXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gIH1cbiAgcmV0dXJuIGNvbGxlY3Rpb24ud2l0aE11dGF0aW9ucygoZnVuY3Rpb24oY29sbGVjdGlvbikge1xuICAgIHZhciBtZXJnZUludG9NYXAgPSBtZXJnZXIgPyAoZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgdmFyIGV4aXN0aW5nID0gY29sbGVjdGlvbi5nZXQoa2V5LCBOT1RfU0VUKTtcbiAgICAgIGNvbGxlY3Rpb24uc2V0KGtleSwgZXhpc3RpbmcgPT09IE5PVF9TRVQgPyB2YWx1ZSA6IG1lcmdlcihleGlzdGluZywgdmFsdWUpKTtcbiAgICB9KSA6IChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICBjb2xsZWN0aW9uLnNldChrZXksIHZhbHVlKTtcbiAgICB9KTtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgc2Vxcy5sZW5ndGg7IGlpKyspIHtcbiAgICAgIHNlcXNbaWldLmZvckVhY2gobWVyZ2VJbnRvTWFwKTtcbiAgICB9XG4gIH0pKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUluRGVlcE1hcChjb2xsZWN0aW9uLCBrZXlQYXRoLCBub3RTZXRWYWx1ZSwgdXBkYXRlciwgcGF0aE9mZnNldCkge1xuICB2YXIgcGF0aExlbiA9IGtleVBhdGgubGVuZ3RoO1xuICBpZiAocGF0aE9mZnNldCA9PT0gcGF0aExlbikge1xuICAgIHJldHVybiB1cGRhdGVyKGNvbGxlY3Rpb24pO1xuICB9XG4gIGludmFyaWFudChjb2xsZWN0aW9uLnNldCwgJ3VwZGF0ZUluIHdpdGggaW52YWxpZCBrZXlQYXRoJyk7XG4gIHZhciBub3RTZXQgPSBwYXRoT2Zmc2V0ID09PSBwYXRoTGVuIC0gMSA/IG5vdFNldFZhbHVlIDogTWFwLmVtcHR5KCk7XG4gIHZhciBrZXkgPSBrZXlQYXRoW3BhdGhPZmZzZXRdO1xuICB2YXIgZXhpc3RpbmcgPSBjb2xsZWN0aW9uLmdldChrZXksIG5vdFNldCk7XG4gIHZhciB2YWx1ZSA9IHVwZGF0ZUluRGVlcE1hcChleGlzdGluZywga2V5UGF0aCwgbm90U2V0VmFsdWUsIHVwZGF0ZXIsIHBhdGhPZmZzZXQgKyAxKTtcbiAgcmV0dXJuIHZhbHVlID09PSBleGlzdGluZyA/IGNvbGxlY3Rpb24gOiBjb2xsZWN0aW9uLnNldChrZXksIHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHBvcENvdW50KHgpIHtcbiAgeCA9IHggLSAoKHggPj4gMSkgJiAweDU1NTU1NTU1KTtcbiAgeCA9ICh4ICYgMHgzMzMzMzMzMykgKyAoKHggPj4gMikgJiAweDMzMzMzMzMzKTtcbiAgeCA9ICh4ICsgKHggPj4gNCkpICYgMHgwZjBmMGYwZjtcbiAgeCA9IHggKyAoeCA+PiA4KTtcbiAgeCA9IHggKyAoeCA+PiAxNik7XG4gIHJldHVybiB4ICYgMHg3Zjtcbn1cbmZ1bmN0aW9uIHNldEluKGFycmF5LCBpZHgsIHZhbCwgY2FuRWRpdCkge1xuICB2YXIgbmV3QXJyYXkgPSBjYW5FZGl0ID8gYXJyYXkgOiBhcnJDb3B5KGFycmF5KTtcbiAgbmV3QXJyYXlbaWR4XSA9IHZhbDtcbiAgcmV0dXJuIG5ld0FycmF5O1xufVxuZnVuY3Rpb24gc3BsaWNlSW4oYXJyYXksIGlkeCwgdmFsLCBjYW5FZGl0KSB7XG4gIHZhciBuZXdMZW4gPSBhcnJheS5sZW5ndGggKyAxO1xuICBpZiAoY2FuRWRpdCAmJiBpZHggKyAxID09PSBuZXdMZW4pIHtcbiAgICBhcnJheVtpZHhdID0gdmFsO1xuICAgIHJldHVybiBhcnJheTtcbiAgfVxuICB2YXIgbmV3QXJyYXkgPSBuZXcgQXJyYXkobmV3TGVuKTtcbiAgdmFyIGFmdGVyID0gMDtcbiAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IG5ld0xlbjsgaWkrKykge1xuICAgIGlmIChpaSA9PT0gaWR4KSB7XG4gICAgICBuZXdBcnJheVtpaV0gPSB2YWw7XG4gICAgICBhZnRlciA9IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdBcnJheVtpaV0gPSBhcnJheVtpaSArIGFmdGVyXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ld0FycmF5O1xufVxuZnVuY3Rpb24gc3BsaWNlT3V0KGFycmF5LCBpZHgsIGNhbkVkaXQpIHtcbiAgdmFyIG5ld0xlbiA9IGFycmF5Lmxlbmd0aCAtIDE7XG4gIGlmIChjYW5FZGl0ICYmIGlkeCA9PT0gbmV3TGVuKSB7XG4gICAgYXJyYXkucG9wKCk7XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG4gIHZhciBuZXdBcnJheSA9IG5ldyBBcnJheShuZXdMZW4pO1xuICB2YXIgYWZ0ZXIgPSAwO1xuICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbmV3TGVuOyBpaSsrKSB7XG4gICAgaWYgKGlpID09PSBpZHgpIHtcbiAgICAgIGFmdGVyID0gMTtcbiAgICB9XG4gICAgbmV3QXJyYXlbaWldID0gYXJyYXlbaWkgKyBhZnRlcl07XG4gIH1cbiAgcmV0dXJuIG5ld0FycmF5O1xufVxudmFyIE1BWF9CSVRNQVBfU0laRSA9IFNJWkUgLyAyO1xudmFyIE1JTl9BUlJBWV9TSVpFID0gU0laRSAvIDQ7XG52YXIgRU1QVFlfTUFQO1xudmFyIFZlY3RvciA9IGZ1bmN0aW9uIFZlY3RvcigpIHtcbiAgZm9yICh2YXIgdmFsdWVzID0gW10sXG4gICAgICAkX181ID0gMDsgJF9fNSA8IGFyZ3VtZW50cy5sZW5ndGg7ICRfXzUrKylcbiAgICB2YWx1ZXNbJF9fNV0gPSBhcmd1bWVudHNbJF9fNV07XG4gIHJldHVybiAkVmVjdG9yLmZyb20odmFsdWVzKTtcbn07XG52YXIgJFZlY3RvciA9IFZlY3RvcjtcbigkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKFZlY3Rvciwge1xuICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX190b1N0cmluZygnVmVjdG9yIFsnLCAnXScpO1xuICB9LFxuICBnZXQ6IGZ1bmN0aW9uKGluZGV4LCBub3RTZXRWYWx1ZSkge1xuICAgIGluZGV4ID0gcmF3SW5kZXgoaW5kZXgsIHRoaXMuX29yaWdpbik7XG4gICAgaWYgKGluZGV4ID49IHRoaXMuX3NpemUpIHtcbiAgICAgIHJldHVybiBub3RTZXRWYWx1ZTtcbiAgICB9XG4gICAgdmFyIG5vZGUgPSB2ZWN0b3JOb2RlRm9yKHRoaXMsIGluZGV4KTtcbiAgICB2YXIgbWFza2VkSW5kZXggPSBpbmRleCAmIE1BU0s7XG4gICAgcmV0dXJuIG5vZGUgJiYgKG5vdFNldFZhbHVlID09PSB1bmRlZmluZWQgfHwgbm9kZS5hcnJheS5oYXNPd25Qcm9wZXJ0eShtYXNrZWRJbmRleCkpID8gbm9kZS5hcnJheVttYXNrZWRJbmRleF0gOiBub3RTZXRWYWx1ZTtcbiAgfSxcbiAgZmlyc3Q6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmdldCgwKTtcbiAgfSxcbiAgbGFzdDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KHRoaXMubGVuZ3RoID8gdGhpcy5sZW5ndGggLSAxIDogMCk7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oaW5kZXgsIHZhbHVlKSB7XG4gICAgcmV0dXJuIHVwZGF0ZVZlY3Rvcih0aGlzLCBpbmRleCwgdmFsdWUpO1xuICB9LFxuICByZW1vdmU6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgcmV0dXJuIHVwZGF0ZVZlY3Rvcih0aGlzLCBpbmRleCwgTk9UX1NFVCk7XG4gIH0sXG4gIGNsZWFyOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAodGhpcy5fX293bmVySUQpIHtcbiAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5fb3JpZ2luID0gdGhpcy5fc2l6ZSA9IDA7XG4gICAgICB0aGlzLl9sZXZlbCA9IFNISUZUO1xuICAgICAgdGhpcy5fcm9vdCA9IHRoaXMuX3RhaWwgPSBudWxsO1xuICAgICAgdGhpcy5fX2hhc2ggPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9fYWx0ZXJlZCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuICRWZWN0b3IuZW1wdHkoKTtcbiAgfSxcbiAgcHVzaDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbHVlcyA9IGFyZ3VtZW50cztcbiAgICB2YXIgb2xkTGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgcmV0dXJuIHRoaXMud2l0aE11dGF0aW9ucygoZnVuY3Rpb24odmVjdCkge1xuICAgICAgc2V0VmVjdG9yQm91bmRzKHZlY3QsIDAsIG9sZExlbmd0aCArIHZhbHVlcy5sZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IHZhbHVlcy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgdmVjdC5zZXQob2xkTGVuZ3RoICsgaWksIHZhbHVlc1tpaV0pO1xuICAgICAgfVxuICAgIH0pKTtcbiAgfSxcbiAgcG9wOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2V0VmVjdG9yQm91bmRzKHRoaXMsIDAsIC0xKTtcbiAgfSxcbiAgdW5zaGlmdDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbHVlcyA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gdGhpcy53aXRoTXV0YXRpb25zKChmdW5jdGlvbih2ZWN0KSB7XG4gICAgICBzZXRWZWN0b3JCb3VuZHModmVjdCwgLXZhbHVlcy5sZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IHZhbHVlcy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgdmVjdC5zZXQoaWksIHZhbHVlc1tpaV0pO1xuICAgICAgfVxuICAgIH0pKTtcbiAgfSxcbiAgc2hpZnQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzZXRWZWN0b3JCb3VuZHModGhpcywgMSk7XG4gIH0sXG4gIG1lcmdlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbWVyZ2VJbnRvVmVjdG9yV2l0aCh0aGlzLCBudWxsLCBhcmd1bWVudHMpO1xuICB9LFxuICBtZXJnZVdpdGg6IGZ1bmN0aW9uKG1lcmdlcikge1xuICAgIGZvciAodmFyIHNlcXMgPSBbXSxcbiAgICAgICAgJF9fNiA9IDE7ICRfXzYgPCBhcmd1bWVudHMubGVuZ3RoOyAkX182KyspXG4gICAgICBzZXFzWyRfXzYgLSAxXSA9IGFyZ3VtZW50c1skX182XTtcbiAgICByZXR1cm4gbWVyZ2VJbnRvVmVjdG9yV2l0aCh0aGlzLCBtZXJnZXIsIHNlcXMpO1xuICB9LFxuICBtZXJnZURlZXA6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBtZXJnZUludG9WZWN0b3JXaXRoKHRoaXMsIGRlZXBNZXJnZXIobnVsbCksIGFyZ3VtZW50cyk7XG4gIH0sXG4gIG1lcmdlRGVlcFdpdGg6IGZ1bmN0aW9uKG1lcmdlcikge1xuICAgIGZvciAodmFyIHNlcXMgPSBbXSxcbiAgICAgICAgJF9fNyA9IDE7ICRfXzcgPCBhcmd1bWVudHMubGVuZ3RoOyAkX183KyspXG4gICAgICBzZXFzWyRfXzcgLSAxXSA9IGFyZ3VtZW50c1skX183XTtcbiAgICByZXR1cm4gbWVyZ2VJbnRvVmVjdG9yV2l0aCh0aGlzLCBkZWVwTWVyZ2VyKG1lcmdlciksIHNlcXMpO1xuICB9LFxuICBzZXRMZW5ndGg6IGZ1bmN0aW9uKGxlbmd0aCkge1xuICAgIHJldHVybiBzZXRWZWN0b3JCb3VuZHModGhpcywgMCwgbGVuZ3RoKTtcbiAgfSxcbiAgc2xpY2U6IGZ1bmN0aW9uKGJlZ2luLCBlbmQsIG1haW50YWluSW5kaWNlcykge1xuICAgIHZhciBzbGljZVNlcXVlbmNlID0gJHRyYWNldXJSdW50aW1lLnN1cGVyQ2FsbCh0aGlzLCAkVmVjdG9yLnByb3RvdHlwZSwgXCJzbGljZVwiLCBbYmVnaW4sIGVuZCwgbWFpbnRhaW5JbmRpY2VzXSk7XG4gICAgaWYgKCFtYWludGFpbkluZGljZXMgJiYgc2xpY2VTZXF1ZW5jZSAhPT0gdGhpcykge1xuICAgICAgdmFyIHZlY3RvciA9IHRoaXM7XG4gICAgICB2YXIgbGVuZ3RoID0gdmVjdG9yLmxlbmd0aDtcbiAgICAgIHNsaWNlU2VxdWVuY2UudG9WZWN0b3IgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzZXRWZWN0b3JCb3VuZHModmVjdG9yLCBiZWdpbiA8IDAgPyBNYXRoLm1heCgwLCBsZW5ndGggKyBiZWdpbikgOiBsZW5ndGggPyBNYXRoLm1pbihsZW5ndGgsIGJlZ2luKSA6IGJlZ2luLCBlbmQgPT0gbnVsbCA/IGxlbmd0aCA6IGVuZCA8IDAgPyBNYXRoLm1heCgwLCBsZW5ndGggKyBlbmQpIDogbGVuZ3RoID8gTWF0aC5taW4obGVuZ3RoLCBlbmQpIDogZW5kKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gc2xpY2VTZXF1ZW5jZTtcbiAgfSxcbiAga2V5czogZnVuY3Rpb24oc3BhcnNlKSB7XG4gICAgcmV0dXJuIG5ldyBWZWN0b3JJdGVyYXRvcih0aGlzLCAwLCBzcGFyc2UpO1xuICB9LFxuICB2YWx1ZXM6IGZ1bmN0aW9uKHNwYXJzZSkge1xuICAgIHJldHVybiBuZXcgVmVjdG9ySXRlcmF0b3IodGhpcywgMSwgc3BhcnNlKTtcbiAgfSxcbiAgZW50cmllczogZnVuY3Rpb24oc3BhcnNlKSB7XG4gICAgcmV0dXJuIG5ldyBWZWN0b3JJdGVyYXRvcih0aGlzLCAyLCBzcGFyc2UpO1xuICB9LFxuICBfX2l0ZXJhdG9yOiBmdW5jdGlvbihyZXZlcnNlLCBmbGlwSW5kaWNlcywgc3BhcnNlKSB7XG4gICAgcmV0dXJuIG5ldyBWZWN0b3JJdGVyYXRvcih0aGlzLCAyLCBzcGFyc2UsIHJldmVyc2UsIGZsaXBJbmRpY2VzKTtcbiAgfSxcbiAgX19pdGVyYXRlOiBmdW5jdGlvbihmbiwgcmV2ZXJzZSwgZmxpcEluZGljZXMpIHtcbiAgICB2YXIgdmVjdG9yID0gdGhpcztcbiAgICB2YXIgbGFzdEluZGV4ID0gMDtcbiAgICB2YXIgbWF4SW5kZXggPSB2ZWN0b3IubGVuZ3RoIC0gMTtcbiAgICBmbGlwSW5kaWNlcyBePSByZXZlcnNlO1xuICAgIHZhciBlYWNoRm4gPSAoZnVuY3Rpb24odmFsdWUsIGlpKSB7XG4gICAgICBpZiAoZm4odmFsdWUsIGZsaXBJbmRpY2VzID8gbWF4SW5kZXggLSBpaSA6IGlpLCB2ZWN0b3IpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXN0SW5kZXggPSBpaTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIGRpZENvbXBsZXRlO1xuICAgIHZhciB0YWlsT2Zmc2V0ID0gZ2V0VGFpbE9mZnNldCh0aGlzLl9zaXplKTtcbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgZGlkQ29tcGxldGUgPSBpdGVyYXRlVk5vZGUodGhpcy5fdGFpbCwgMCwgdGFpbE9mZnNldCAtIHRoaXMuX29yaWdpbiwgdGhpcy5fc2l6ZSAtIHRoaXMuX29yaWdpbiwgZWFjaEZuLCByZXZlcnNlKSAmJiBpdGVyYXRlVk5vZGUodGhpcy5fcm9vdCwgdGhpcy5fbGV2ZWwsIC10aGlzLl9vcmlnaW4sIHRhaWxPZmZzZXQgLSB0aGlzLl9vcmlnaW4sIGVhY2hGbiwgcmV2ZXJzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpZENvbXBsZXRlID0gaXRlcmF0ZVZOb2RlKHRoaXMuX3Jvb3QsIHRoaXMuX2xldmVsLCAtdGhpcy5fb3JpZ2luLCB0YWlsT2Zmc2V0IC0gdGhpcy5fb3JpZ2luLCBlYWNoRm4sIHJldmVyc2UpICYmIGl0ZXJhdGVWTm9kZSh0aGlzLl90YWlsLCAwLCB0YWlsT2Zmc2V0IC0gdGhpcy5fb3JpZ2luLCB0aGlzLl9zaXplIC0gdGhpcy5fb3JpZ2luLCBlYWNoRm4sIHJldmVyc2UpO1xuICAgIH1cbiAgICByZXR1cm4gKGRpZENvbXBsZXRlID8gbWF4SW5kZXggOiByZXZlcnNlID8gbWF4SW5kZXggLSBsYXN0SW5kZXggOiBsYXN0SW5kZXgpICsgMTtcbiAgfSxcbiAgX19kZWVwRXF1YWxzOiBmdW5jdGlvbihvdGhlcikge1xuICAgIHZhciBpdGVyYXRvciA9IHRoaXMuZW50cmllcyh0cnVlKTtcbiAgICByZXR1cm4gb3RoZXIuZXZlcnkoKGZ1bmN0aW9uKHYsIGkpIHtcbiAgICAgIHZhciBlbnRyeSA9IGl0ZXJhdG9yLm5leHQoKS52YWx1ZTtcbiAgICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeVswXSA9PT0gaSAmJiBpcyhlbnRyeVsxXSwgdik7XG4gICAgfSkpO1xuICB9LFxuICBfX2Vuc3VyZU93bmVyOiBmdW5jdGlvbihvd25lcklEKSB7XG4gICAgaWYgKG93bmVySUQgPT09IHRoaXMuX19vd25lcklEKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKCFvd25lcklEKSB7XG4gICAgICB0aGlzLl9fb3duZXJJRCA9IG93bmVySUQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIG1ha2VWZWN0b3IodGhpcy5fb3JpZ2luLCB0aGlzLl9zaXplLCB0aGlzLl9sZXZlbCwgdGhpcy5fcm9vdCwgdGhpcy5fdGFpbCwgb3duZXJJRCwgdGhpcy5fX2hhc2gpO1xuICB9XG59LCB7XG4gIGVtcHR5OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gRU1QVFlfVkVDVCB8fCAoRU1QVFlfVkVDVCA9IG1ha2VWZWN0b3IoMCwgMCwgU0hJRlQpKTtcbiAgfSxcbiAgZnJvbTogZnVuY3Rpb24oc2VxdWVuY2UpIHtcbiAgICBpZiAoIXNlcXVlbmNlIHx8IHNlcXVlbmNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuICRWZWN0b3IuZW1wdHkoKTtcbiAgICB9XG4gICAgaWYgKHNlcXVlbmNlLmNvbnN0cnVjdG9yID09PSAkVmVjdG9yKSB7XG4gICAgICByZXR1cm4gc2VxdWVuY2U7XG4gICAgfVxuICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShzZXF1ZW5jZSk7XG4gICAgaWYgKHNlcXVlbmNlLmxlbmd0aCA+IDAgJiYgc2VxdWVuY2UubGVuZ3RoIDwgU0laRSkge1xuICAgICAgcmV0dXJuIG1ha2VWZWN0b3IoMCwgc2VxdWVuY2UubGVuZ3RoLCBTSElGVCwgbnVsbCwgbmV3IFZOb2RlKGlzQXJyYXkgPyBhcnJDb3B5KHNlcXVlbmNlKSA6IFNlcXVlbmNlKHNlcXVlbmNlKS50b0FycmF5KCkpKTtcbiAgICB9XG4gICAgaWYgKCFpc0FycmF5KSB7XG4gICAgICBzZXF1ZW5jZSA9IFNlcXVlbmNlKHNlcXVlbmNlKTtcbiAgICAgIGlmICghKHNlcXVlbmNlIGluc3RhbmNlb2YgSW5kZXhlZFNlcXVlbmNlKSkge1xuICAgICAgICBzZXF1ZW5jZSA9IHNlcXVlbmNlLnZhbHVlU2VxKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAkVmVjdG9yLmVtcHR5KCkubWVyZ2Uoc2VxdWVuY2UpO1xuICB9XG59LCBJbmRleGVkU2VxdWVuY2UpO1xudmFyIFZlY3RvclByb3RvdHlwZSA9IFZlY3Rvci5wcm90b3R5cGU7XG5WZWN0b3JQcm90b3R5cGVbREVMRVRFXSA9IFZlY3RvclByb3RvdHlwZS5yZW1vdmU7XG5WZWN0b3JQcm90b3R5cGVbSVRFUkFUT1JdID0gVmVjdG9yUHJvdG90eXBlLnZhbHVlcztcblZlY3RvclByb3RvdHlwZS51cGRhdGUgPSBNYXBQcm90b3R5cGUudXBkYXRlO1xuVmVjdG9yUHJvdG90eXBlLnVwZGF0ZUluID0gTWFwUHJvdG90eXBlLnVwZGF0ZUluO1xuVmVjdG9yUHJvdG90eXBlLmN1cnNvciA9IE1hcFByb3RvdHlwZS5jdXJzb3I7XG5WZWN0b3JQcm90b3R5cGUud2l0aE11dGF0aW9ucyA9IE1hcFByb3RvdHlwZS53aXRoTXV0YXRpb25zO1xuVmVjdG9yUHJvdG90eXBlLmFzTXV0YWJsZSA9IE1hcFByb3RvdHlwZS5hc011dGFibGU7XG5WZWN0b3JQcm90b3R5cGUuYXNJbW11dGFibGUgPSBNYXBQcm90b3R5cGUuYXNJbW11dGFibGU7XG5WZWN0b3JQcm90b3R5cGUud2FzQWx0ZXJlZCA9IE1hcFByb3RvdHlwZS53YXNBbHRlcmVkO1xudmFyIFZOb2RlID0gZnVuY3Rpb24gVk5vZGUoYXJyYXksIG93bmVySUQpIHtcbiAgdGhpcy5hcnJheSA9IGFycmF5O1xuICB0aGlzLm93bmVySUQgPSBvd25lcklEO1xufTtcbnZhciAkVk5vZGUgPSBWTm9kZTtcbigkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKFZOb2RlLCB7XG4gIHJlbW92ZUJlZm9yZTogZnVuY3Rpb24ob3duZXJJRCwgbGV2ZWwsIGluZGV4KSB7XG4gICAgaWYgKGluZGV4ID09PSBsZXZlbCA/IDEgPDwgbGV2ZWwgOiAwIHx8IHRoaXMuYXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIG9yaWdpbkluZGV4ID0gKGluZGV4ID4+PiBsZXZlbCkgJiBNQVNLO1xuICAgIGlmIChvcmlnaW5JbmRleCA+PSB0aGlzLmFycmF5Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG5ldyAkVk5vZGUoW10sIG93bmVySUQpO1xuICAgIH1cbiAgICB2YXIgcmVtb3ZpbmdGaXJzdCA9IG9yaWdpbkluZGV4ID09PSAwO1xuICAgIHZhciBuZXdDaGlsZDtcbiAgICBpZiAobGV2ZWwgPiAwKSB7XG4gICAgICB2YXIgb2xkQ2hpbGQgPSB0aGlzLmFycmF5W29yaWdpbkluZGV4XTtcbiAgICAgIG5ld0NoaWxkID0gb2xkQ2hpbGQgJiYgb2xkQ2hpbGQucmVtb3ZlQmVmb3JlKG93bmVySUQsIGxldmVsIC0gU0hJRlQsIGluZGV4KTtcbiAgICAgIGlmIChuZXdDaGlsZCA9PT0gb2xkQ2hpbGQgJiYgcmVtb3ZpbmdGaXJzdCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlbW92aW5nRmlyc3QgJiYgIW5ld0NoaWxkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIGVkaXRhYmxlID0gZWRpdGFibGVWTm9kZSh0aGlzLCBvd25lcklEKTtcbiAgICBpZiAoIXJlbW92aW5nRmlyc3QpIHtcbiAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBvcmlnaW5JbmRleDsgaWkrKykge1xuICAgICAgICBkZWxldGUgZWRpdGFibGUuYXJyYXlbaWldO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmV3Q2hpbGQpIHtcbiAgICAgIGVkaXRhYmxlLmFycmF5W29yaWdpbkluZGV4XSA9IG5ld0NoaWxkO1xuICAgIH1cbiAgICByZXR1cm4gZWRpdGFibGU7XG4gIH0sXG4gIHJlbW92ZUFmdGVyOiBmdW5jdGlvbihvd25lcklELCBsZXZlbCwgaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPT09IGxldmVsID8gMSA8PCBsZXZlbCA6IDAgfHwgdGhpcy5hcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2YXIgc2l6ZUluZGV4ID0gKChpbmRleCAtIDEpID4+PiBsZXZlbCkgJiBNQVNLO1xuICAgIGlmIChzaXplSW5kZXggPj0gdGhpcy5hcnJheS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2YXIgcmVtb3ZpbmdMYXN0ID0gc2l6ZUluZGV4ID09PSB0aGlzLmFycmF5Lmxlbmd0aCAtIDE7XG4gICAgdmFyIG5ld0NoaWxkO1xuICAgIGlmIChsZXZlbCA+IDApIHtcbiAgICAgIHZhciBvbGRDaGlsZCA9IHRoaXMuYXJyYXlbc2l6ZUluZGV4XTtcbiAgICAgIG5ld0NoaWxkID0gb2xkQ2hpbGQgJiYgb2xkQ2hpbGQucmVtb3ZlQWZ0ZXIob3duZXJJRCwgbGV2ZWwgLSBTSElGVCwgaW5kZXgpO1xuICAgICAgaWYgKG5ld0NoaWxkID09PSBvbGRDaGlsZCAmJiByZW1vdmluZ0xhc3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyZW1vdmluZ0xhc3QgJiYgIW5ld0NoaWxkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIGVkaXRhYmxlID0gZWRpdGFibGVWTm9kZSh0aGlzLCBvd25lcklEKTtcbiAgICBpZiAoIXJlbW92aW5nTGFzdCkge1xuICAgICAgZWRpdGFibGUuYXJyYXkubGVuZ3RoID0gc2l6ZUluZGV4ICsgMTtcbiAgICB9XG4gICAgaWYgKG5ld0NoaWxkKSB7XG4gICAgICBlZGl0YWJsZS5hcnJheVtzaXplSW5kZXhdID0gbmV3Q2hpbGQ7XG4gICAgfVxuICAgIHJldHVybiBlZGl0YWJsZTtcbiAgfVxufSwge30pO1xuZnVuY3Rpb24gaXRlcmF0ZVZOb2RlKG5vZGUsIGxldmVsLCBvZmZzZXQsIG1heCwgZm4sIHJldmVyc2UpIHtcbiAgaWYgKG5vZGUpIHtcbiAgICB2YXIgaWk7XG4gICAgdmFyIGFycmF5ID0gbm9kZS5hcnJheTtcbiAgICB2YXIgbWF4SUkgPSBhcnJheS5sZW5ndGggLSAxO1xuICAgIGlmIChsZXZlbCA9PT0gMCkge1xuICAgICAgZm9yIChpaSA9IDA7IGlpIDw9IG1heElJOyBpaSsrKSB7XG4gICAgICAgIHZhciByYXdJbmRleCA9IHJldmVyc2UgPyBtYXhJSSAtIGlpIDogaWk7XG4gICAgICAgIGlmIChhcnJheS5oYXNPd25Qcm9wZXJ0eShyYXdJbmRleCkpIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSByYXdJbmRleCArIG9mZnNldDtcbiAgICAgICAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IG1heCAmJiBmbihhcnJheVtyYXdJbmRleF0sIGluZGV4KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0ZXAgPSAxIDw8IGxldmVsO1xuICAgICAgdmFyIG5ld0xldmVsID0gbGV2ZWwgLSBTSElGVDtcbiAgICAgIGZvciAoaWkgPSAwOyBpaSA8PSBtYXhJSTsgaWkrKykge1xuICAgICAgICB2YXIgbGV2ZWxJbmRleCA9IHJldmVyc2UgPyBtYXhJSSAtIGlpIDogaWk7XG4gICAgICAgIHZhciBuZXdPZmZzZXQgPSBvZmZzZXQgKyBsZXZlbEluZGV4ICogc3RlcDtcbiAgICAgICAgaWYgKG5ld09mZnNldCA8IG1heCAmJiBuZXdPZmZzZXQgKyBzdGVwID4gMCkge1xuICAgICAgICAgIHZhciBuZXh0Tm9kZSA9IGFycmF5W2xldmVsSW5kZXhdO1xuICAgICAgICAgIGlmIChuZXh0Tm9kZSAmJiAhaXRlcmF0ZVZOb2RlKG5leHROb2RlLCBuZXdMZXZlbCwgbmV3T2Zmc2V0LCBtYXgsIGZuLCByZXZlcnNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbnZhciBWZWN0b3JJdGVyYXRvciA9IGZ1bmN0aW9uIFZlY3Rvckl0ZXJhdG9yKHZlY3RvciwgdHlwZSwgc3BhcnNlLCByZXZlcnNlLCBmbGlwSW5kaWNlcykge1xuICB0aGlzLl90eXBlID0gdHlwZTtcbiAgdGhpcy5fc3BhcnNlID0gISFzcGFyc2U7XG4gIHRoaXMuX3JldmVyc2UgPSAhIXJldmVyc2U7XG4gIHRoaXMuX2ZsaXBJbmRpY2VzID0gISEoZmxpcEluZGljZXMgXiByZXZlcnNlKTtcbiAgdGhpcy5fbWF4SW5kZXggPSB2ZWN0b3IubGVuZ3RoIC0gMTtcbiAgdmFyIHRhaWxPZmZzZXQgPSBnZXRUYWlsT2Zmc2V0KHZlY3Rvci5fc2l6ZSk7XG4gIHZhciByb290U3RhY2sgPSB2ZWN0SXRlcmF0b3JGcmFtZSh2ZWN0b3IuX3Jvb3QgJiYgdmVjdG9yLl9yb290LmFycmF5LCB2ZWN0b3IuX2xldmVsLCAtdmVjdG9yLl9vcmlnaW4sIHRhaWxPZmZzZXQgLSB2ZWN0b3IuX29yaWdpbiAtIDEpO1xuICB2YXIgdGFpbFN0YWNrID0gdmVjdEl0ZXJhdG9yRnJhbWUodmVjdG9yLl90YWlsICYmIHZlY3Rvci5fdGFpbC5hcnJheSwgMCwgdGFpbE9mZnNldCAtIHZlY3Rvci5fb3JpZ2luLCB2ZWN0b3IuX3NpemUgLSB2ZWN0b3IuX29yaWdpbiAtIDEpO1xuICB0aGlzLl9zdGFjayA9IHJldmVyc2UgPyB0YWlsU3RhY2sgOiByb290U3RhY2s7XG4gIHRoaXMuX3N0YWNrLl9fcHJldiA9IHJldmVyc2UgPyByb290U3RhY2sgOiB0YWlsU3RhY2s7XG59O1xuKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoVmVjdG9ySXRlcmF0b3IsIHtuZXh0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3BhcnNlID0gdGhpcy5fc3BhcnNlO1xuICAgIHZhciBzdGFjayA9IHRoaXMuX3N0YWNrO1xuICAgIHdoaWxlIChzdGFjaykge1xuICAgICAgdmFyIGFycmF5ID0gc3RhY2suYXJyYXk7XG4gICAgICB2YXIgcmF3SW5kZXggPSBzdGFjay5pbmRleCsrO1xuICAgICAgaWYgKHRoaXMuX3JldmVyc2UpIHtcbiAgICAgICAgcmF3SW5kZXggPSBNQVNLIC0gcmF3SW5kZXg7XG4gICAgICAgIGlmIChyYXdJbmRleCA+IHN0YWNrLnJhd01heCkge1xuICAgICAgICAgIHJhd0luZGV4ID0gc3RhY2sucmF3TWF4O1xuICAgICAgICAgIHN0YWNrLmluZGV4ID0gU0laRSAtIHJhd0luZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmF3SW5kZXggPj0gMCAmJiByYXdJbmRleCA8IFNJWkUgJiYgcmF3SW5kZXggPD0gc3RhY2sucmF3TWF4KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5ICYmIGFycmF5W3Jhd0luZGV4XTtcbiAgICAgICAgaWYgKHN0YWNrLmxldmVsID09PSAwKSB7XG4gICAgICAgICAgaWYgKCFzcGFyc2UgfHwgdmFsdWUgIT0gbnVsbCB8fCAoYXJyYXkgJiYgcmF3SW5kZXggPCBhcnJheS5sZW5ndGggJiYgYXJyYXkuaGFzT3duUHJvcGVydHkocmF3SW5kZXgpKSkge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLl90eXBlO1xuICAgICAgICAgICAgdmFyIGluZGV4O1xuICAgICAgICAgICAgaWYgKHR5cGUgIT09IDEpIHtcbiAgICAgICAgICAgICAgaW5kZXggPSBzdGFjay5vZmZzZXQgKyAocmF3SW5kZXggPDwgc3RhY2subGV2ZWwpO1xuICAgICAgICAgICAgICBpZiAodGhpcy5fZmxpcEluZGljZXMpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMuX21heEluZGV4IC0gaW5kZXg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpdGVyYXRvclZhbHVlKHR5cGUgPT09IDAgPyBpbmRleCA6IHR5cGUgPT09IDEgPyB2YWx1ZSA6IFtpbmRleCwgdmFsdWVdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIXNwYXJzZSB8fCB2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5fc3RhY2sgPSBzdGFjayA9IHZlY3RJdGVyYXRvckZyYW1lKHZhbHVlICYmIHZhbHVlLmFycmF5LCBzdGFjay5sZXZlbCAtIFNISUZULCBzdGFjay5vZmZzZXQgKyAocmF3SW5kZXggPDwgc3RhY2subGV2ZWwpLCBzdGFjay5tYXgsIHN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHN0YWNrID0gdGhpcy5fc3RhY2sgPSB0aGlzLl9zdGFjay5fX3ByZXY7XG4gICAgfVxuICAgIHJldHVybiBpdGVyYXRvckRvbmUoKTtcbiAgfX0sIHt9LCBTZXF1ZW5jZUl0ZXJhdG9yKTtcbmZ1bmN0aW9uIHZlY3RJdGVyYXRvckZyYW1lKGFycmF5LCBsZXZlbCwgb2Zmc2V0LCBtYXgsIHByZXZGcmFtZSkge1xuICByZXR1cm4ge1xuICAgIGFycmF5OiBhcnJheSxcbiAgICBsZXZlbDogbGV2ZWwsXG4gICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgbWF4OiBtYXgsXG4gICAgcmF3TWF4OiAoKG1heCAtIG9mZnNldCkgPj4gbGV2ZWwpLFxuICAgIGluZGV4OiAwLFxuICAgIF9fcHJldjogcHJldkZyYW1lXG4gIH07XG59XG5mdW5jdGlvbiBtYWtlVmVjdG9yKG9yaWdpbiwgc2l6ZSwgbGV2ZWwsIHJvb3QsIHRhaWwsIG93bmVySUQsIGhhc2gpIHtcbiAgdmFyIHZlY3QgPSBPYmplY3QuY3JlYXRlKFZlY3RvclByb3RvdHlwZSk7XG4gIHZlY3QubGVuZ3RoID0gc2l6ZSAtIG9yaWdpbjtcbiAgdmVjdC5fb3JpZ2luID0gb3JpZ2luO1xuICB2ZWN0Ll9zaXplID0gc2l6ZTtcbiAgdmVjdC5fbGV2ZWwgPSBsZXZlbDtcbiAgdmVjdC5fcm9vdCA9IHJvb3Q7XG4gIHZlY3QuX3RhaWwgPSB0YWlsO1xuICB2ZWN0Ll9fb3duZXJJRCA9IG93bmVySUQ7XG4gIHZlY3QuX19oYXNoID0gaGFzaDtcbiAgdmVjdC5fX2FsdGVyZWQgPSBmYWxzZTtcbiAgcmV0dXJuIHZlY3Q7XG59XG5mdW5jdGlvbiB1cGRhdGVWZWN0b3IodmVjdG9yLCBpbmRleCwgdmFsdWUpIHtcbiAgaWYgKGluZGV4ID49IHZlY3Rvci5sZW5ndGgpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IE5PVF9TRVQgPyB2ZWN0b3IgOiB2ZWN0b3Iud2l0aE11dGF0aW9ucygoZnVuY3Rpb24odmVjdCkge1xuICAgICAgc2V0VmVjdG9yQm91bmRzKHZlY3QsIDAsIGluZGV4ICsgMSkuc2V0KGluZGV4LCB2YWx1ZSk7XG4gICAgfSkpO1xuICB9XG4gIGluZGV4ID0gcmF3SW5kZXgoaW5kZXgsIHZlY3Rvci5fb3JpZ2luKTtcbiAgdmFyIG5ld1RhaWwgPSB2ZWN0b3IuX3RhaWw7XG4gIHZhciBuZXdSb290ID0gdmVjdG9yLl9yb290O1xuICB2YXIgZGlkQWx0ZXIgPSBNYWtlUmVmKERJRF9BTFRFUik7XG4gIGlmIChpbmRleCA+PSBnZXRUYWlsT2Zmc2V0KHZlY3Rvci5fc2l6ZSkpIHtcbiAgICBuZXdUYWlsID0gdXBkYXRlVk5vZGUobmV3VGFpbCwgdmVjdG9yLl9fb3duZXJJRCwgMCwgaW5kZXgsIHZhbHVlLCBkaWRBbHRlcik7XG4gIH0gZWxzZSB7XG4gICAgbmV3Um9vdCA9IHVwZGF0ZVZOb2RlKG5ld1Jvb3QsIHZlY3Rvci5fX293bmVySUQsIHZlY3Rvci5fbGV2ZWwsIGluZGV4LCB2YWx1ZSwgZGlkQWx0ZXIpO1xuICB9XG4gIGlmICghZGlkQWx0ZXIudmFsdWUpIHtcbiAgICByZXR1cm4gdmVjdG9yO1xuICB9XG4gIGlmICh2ZWN0b3IuX19vd25lcklEKSB7XG4gICAgdmVjdG9yLl9yb290ID0gbmV3Um9vdDtcbiAgICB2ZWN0b3IuX3RhaWwgPSBuZXdUYWlsO1xuICAgIHZlY3Rvci5fX2hhc2ggPSB1bmRlZmluZWQ7XG4gICAgdmVjdG9yLl9fYWx0ZXJlZCA9IHRydWU7XG4gICAgcmV0dXJuIHZlY3RvcjtcbiAgfVxuICByZXR1cm4gbWFrZVZlY3Rvcih2ZWN0b3IuX29yaWdpbiwgdmVjdG9yLl9zaXplLCB2ZWN0b3IuX2xldmVsLCBuZXdSb290LCBuZXdUYWlsKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVZOb2RlKG5vZGUsIG93bmVySUQsIGxldmVsLCBpbmRleCwgdmFsdWUsIGRpZEFsdGVyKSB7XG4gIHZhciByZW1vdmVkID0gdmFsdWUgPT09IE5PVF9TRVQ7XG4gIHZhciBuZXdOb2RlO1xuICB2YXIgaWR4ID0gKGluZGV4ID4+PiBsZXZlbCkgJiBNQVNLO1xuICB2YXIgbm9kZUhhcyA9IG5vZGUgJiYgaWR4IDwgbm9kZS5hcnJheS5sZW5ndGggJiYgbm9kZS5hcnJheS5oYXNPd25Qcm9wZXJ0eShpZHgpO1xuICBpZiAocmVtb3ZlZCAmJiAhbm9kZUhhcykge1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGlmIChsZXZlbCA+IDApIHtcbiAgICB2YXIgbG93ZXJOb2RlID0gbm9kZSAmJiBub2RlLmFycmF5W2lkeF07XG4gICAgdmFyIG5ld0xvd2VyTm9kZSA9IHVwZGF0ZVZOb2RlKGxvd2VyTm9kZSwgb3duZXJJRCwgbGV2ZWwgLSBTSElGVCwgaW5kZXgsIHZhbHVlLCBkaWRBbHRlcik7XG4gICAgaWYgKG5ld0xvd2VyTm9kZSA9PT0gbG93ZXJOb2RlKSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgbmV3Tm9kZSA9IGVkaXRhYmxlVk5vZGUobm9kZSwgb3duZXJJRCk7XG4gICAgbmV3Tm9kZS5hcnJheVtpZHhdID0gbmV3TG93ZXJOb2RlO1xuICAgIHJldHVybiBuZXdOb2RlO1xuICB9XG4gIGlmICghcmVtb3ZlZCAmJiBub2RlSGFzICYmIG5vZGUuYXJyYXlbaWR4XSA9PT0gdmFsdWUpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBTZXRSZWYoZGlkQWx0ZXIpO1xuICBuZXdOb2RlID0gZWRpdGFibGVWTm9kZShub2RlLCBvd25lcklEKTtcbiAgcmVtb3ZlZCA/IChkZWxldGUgbmV3Tm9kZS5hcnJheVtpZHhdKSA6IChuZXdOb2RlLmFycmF5W2lkeF0gPSB2YWx1ZSk7XG4gIHJldHVybiBuZXdOb2RlO1xufVxuZnVuY3Rpb24gZWRpdGFibGVWTm9kZShub2RlLCBvd25lcklEKSB7XG4gIGlmIChvd25lcklEICYmIG5vZGUgJiYgb3duZXJJRCA9PT0gbm9kZS5vd25lcklEKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgcmV0dXJuIG5ldyBWTm9kZShub2RlID8gbm9kZS5hcnJheS5zbGljZSgpIDogW10sIG93bmVySUQpO1xufVxuZnVuY3Rpb24gdmVjdG9yTm9kZUZvcih2ZWN0b3IsIHJhd0luZGV4KSB7XG4gIGlmIChyYXdJbmRleCA+PSBnZXRUYWlsT2Zmc2V0KHZlY3Rvci5fc2l6ZSkpIHtcbiAgICByZXR1cm4gdmVjdG9yLl90YWlsO1xuICB9XG4gIGlmIChyYXdJbmRleCA8IDEgPDwgKHZlY3Rvci5fbGV2ZWwgKyBTSElGVCkpIHtcbiAgICB2YXIgbm9kZSA9IHZlY3Rvci5fcm9vdDtcbiAgICB2YXIgbGV2ZWwgPSB2ZWN0b3IuX2xldmVsO1xuICAgIHdoaWxlIChub2RlICYmIGxldmVsID4gMCkge1xuICAgICAgbm9kZSA9IG5vZGUuYXJyYXlbKHJhd0luZGV4ID4+PiBsZXZlbCkgJiBNQVNLXTtcbiAgICAgIGxldmVsIC09IFNISUZUO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0VmVjdG9yQm91bmRzKHZlY3RvciwgYmVnaW4sIGVuZCkge1xuICB2YXIgb3duZXIgPSB2ZWN0b3IuX19vd25lcklEIHx8IG5ldyBPd25lcklEKCk7XG4gIHZhciBvbGRPcmlnaW4gPSB2ZWN0b3IuX29yaWdpbjtcbiAgdmFyIG9sZFNpemUgPSB2ZWN0b3IuX3NpemU7XG4gIHZhciBuZXdPcmlnaW4gPSBvbGRPcmlnaW4gKyBiZWdpbjtcbiAgdmFyIG5ld1NpemUgPSBlbmQgPT0gbnVsbCA/IG9sZFNpemUgOiBlbmQgPCAwID8gb2xkU2l6ZSArIGVuZCA6IG9sZE9yaWdpbiArIGVuZDtcbiAgaWYgKG5ld09yaWdpbiA9PT0gb2xkT3JpZ2luICYmIG5ld1NpemUgPT09IG9sZFNpemUpIHtcbiAgICByZXR1cm4gdmVjdG9yO1xuICB9XG4gIGlmIChuZXdPcmlnaW4gPj0gbmV3U2l6ZSkge1xuICAgIHJldHVybiB2ZWN0b3IuY2xlYXIoKTtcbiAgfVxuICB2YXIgbmV3TGV2ZWwgPSB2ZWN0b3IuX2xldmVsO1xuICB2YXIgbmV3Um9vdCA9IHZlY3Rvci5fcm9vdDtcbiAgdmFyIG9mZnNldFNoaWZ0ID0gMDtcbiAgd2hpbGUgKG5ld09yaWdpbiArIG9mZnNldFNoaWZ0IDwgMCkge1xuICAgIG5ld1Jvb3QgPSBuZXcgVk5vZGUobmV3Um9vdCAmJiBuZXdSb290LmFycmF5Lmxlbmd0aCA/IFtudWxsLCBuZXdSb290XSA6IFtdLCBvd25lcik7XG4gICAgbmV3TGV2ZWwgKz0gU0hJRlQ7XG4gICAgb2Zmc2V0U2hpZnQgKz0gMSA8PCBuZXdMZXZlbDtcbiAgfVxuICBpZiAob2Zmc2V0U2hpZnQpIHtcbiAgICBuZXdPcmlnaW4gKz0gb2Zmc2V0U2hpZnQ7XG4gICAgb2xkT3JpZ2luICs9IG9mZnNldFNoaWZ0O1xuICAgIG5ld1NpemUgKz0gb2Zmc2V0U2hpZnQ7XG4gICAgb2xkU2l6ZSArPSBvZmZzZXRTaGlmdDtcbiAgfVxuICB2YXIgb2xkVGFpbE9mZnNldCA9IGdldFRhaWxPZmZzZXQob2xkU2l6ZSk7XG4gIHZhciBuZXdUYWlsT2Zmc2V0ID0gZ2V0VGFpbE9mZnNldChuZXdTaXplKTtcbiAgd2hpbGUgKG5ld1RhaWxPZmZzZXQgPj0gMSA8PCAobmV3TGV2ZWwgKyBTSElGVCkpIHtcbiAgICBuZXdSb290ID0gbmV3IFZOb2RlKG5ld1Jvb3QgJiYgbmV3Um9vdC5hcnJheS5sZW5ndGggPyBbbmV3Um9vdF0gOiBbXSwgb3duZXIpO1xuICAgIG5ld0xldmVsICs9IFNISUZUO1xuICB9XG4gIHZhciBvbGRUYWlsID0gdmVjdG9yLl90YWlsO1xuICB2YXIgbmV3VGFpbCA9IG5ld1RhaWxPZmZzZXQgPCBvbGRUYWlsT2Zmc2V0ID8gdmVjdG9yTm9kZUZvcih2ZWN0b3IsIG5ld1NpemUgLSAxKSA6IG5ld1RhaWxPZmZzZXQgPiBvbGRUYWlsT2Zmc2V0ID8gbmV3IFZOb2RlKFtdLCBvd25lcikgOiBvbGRUYWlsO1xuICBpZiAob2xkVGFpbCAmJiBuZXdUYWlsT2Zmc2V0ID4gb2xkVGFpbE9mZnNldCAmJiBuZXdPcmlnaW4gPCBvbGRTaXplICYmIG9sZFRhaWwuYXJyYXkubGVuZ3RoKSB7XG4gICAgbmV3Um9vdCA9IGVkaXRhYmxlVk5vZGUobmV3Um9vdCwgb3duZXIpO1xuICAgIHZhciBub2RlID0gbmV3Um9vdDtcbiAgICBmb3IgKHZhciBsZXZlbCA9IG5ld0xldmVsOyBsZXZlbCA+IFNISUZUOyBsZXZlbCAtPSBTSElGVCkge1xuICAgICAgdmFyIGlkeCA9IChvbGRUYWlsT2Zmc2V0ID4+PiBsZXZlbCkgJiBNQVNLO1xuICAgICAgbm9kZSA9IG5vZGUuYXJyYXlbaWR4XSA9IGVkaXRhYmxlVk5vZGUobm9kZS5hcnJheVtpZHhdLCBvd25lcik7XG4gICAgfVxuICAgIG5vZGUuYXJyYXlbKG9sZFRhaWxPZmZzZXQgPj4+IFNISUZUKSAmIE1BU0tdID0gb2xkVGFpbDtcbiAgfVxuICBpZiAobmV3U2l6ZSA8IG9sZFNpemUpIHtcbiAgICBuZXdUYWlsID0gbmV3VGFpbCAmJiBuZXdUYWlsLnJlbW92ZUFmdGVyKG93bmVyLCAwLCBuZXdTaXplKTtcbiAgfVxuICBpZiAobmV3T3JpZ2luID49IG5ld1RhaWxPZmZzZXQpIHtcbiAgICBuZXdPcmlnaW4gLT0gbmV3VGFpbE9mZnNldDtcbiAgICBuZXdTaXplIC09IG5ld1RhaWxPZmZzZXQ7XG4gICAgbmV3TGV2ZWwgPSBTSElGVDtcbiAgICBuZXdSb290ID0gbnVsbDtcbiAgICBuZXdUYWlsID0gbmV3VGFpbCAmJiBuZXdUYWlsLnJlbW92ZUJlZm9yZShvd25lciwgMCwgbmV3T3JpZ2luKTtcbiAgfSBlbHNlIGlmIChuZXdPcmlnaW4gPiBvbGRPcmlnaW4gfHwgbmV3VGFpbE9mZnNldCA8IG9sZFRhaWxPZmZzZXQpIHtcbiAgICB2YXIgYmVnaW5JbmRleCxcbiAgICAgICAgZW5kSW5kZXg7XG4gICAgb2Zmc2V0U2hpZnQgPSAwO1xuICAgIGRvIHtcbiAgICAgIGJlZ2luSW5kZXggPSAoKG5ld09yaWdpbikgPj4+IG5ld0xldmVsKSAmIE1BU0s7XG4gICAgICBlbmRJbmRleCA9ICgobmV3VGFpbE9mZnNldCAtIDEpID4+PiBuZXdMZXZlbCkgJiBNQVNLO1xuICAgICAgaWYgKGJlZ2luSW5kZXggPT09IGVuZEluZGV4KSB7XG4gICAgICAgIGlmIChiZWdpbkluZGV4KSB7XG4gICAgICAgICAgb2Zmc2V0U2hpZnQgKz0gKDEgPDwgbmV3TGV2ZWwpICogYmVnaW5JbmRleDtcbiAgICAgICAgfVxuICAgICAgICBuZXdMZXZlbCAtPSBTSElGVDtcbiAgICAgICAgbmV3Um9vdCA9IG5ld1Jvb3QgJiYgbmV3Um9vdC5hcnJheVtiZWdpbkluZGV4XTtcbiAgICAgIH1cbiAgICB9IHdoaWxlIChuZXdSb290ICYmIGJlZ2luSW5kZXggPT09IGVuZEluZGV4KTtcbiAgICBpZiAobmV3Um9vdCAmJiBuZXdPcmlnaW4gPiBvbGRPcmlnaW4pIHtcbiAgICAgIG5ld1Jvb3QgPSBuZXdSb290ICYmIG5ld1Jvb3QucmVtb3ZlQmVmb3JlKG93bmVyLCBuZXdMZXZlbCwgbmV3T3JpZ2luIC0gb2Zmc2V0U2hpZnQpO1xuICAgIH1cbiAgICBpZiAobmV3Um9vdCAmJiBuZXdUYWlsT2Zmc2V0IDwgb2xkVGFpbE9mZnNldCkge1xuICAgICAgbmV3Um9vdCA9IG5ld1Jvb3QgJiYgbmV3Um9vdC5yZW1vdmVBZnRlcihvd25lciwgbmV3TGV2ZWwsIG5ld1RhaWxPZmZzZXQgLSBvZmZzZXRTaGlmdCk7XG4gICAgfVxuICAgIGlmIChvZmZzZXRTaGlmdCkge1xuICAgICAgbmV3T3JpZ2luIC09IG9mZnNldFNoaWZ0O1xuICAgICAgbmV3U2l6ZSAtPSBvZmZzZXRTaGlmdDtcbiAgICB9XG4gIH1cbiAgaWYgKHZlY3Rvci5fX293bmVySUQpIHtcbiAgICB2ZWN0b3IubGVuZ3RoID0gbmV3U2l6ZSAtIG5ld09yaWdpbjtcbiAgICB2ZWN0b3IuX29yaWdpbiA9IG5ld09yaWdpbjtcbiAgICB2ZWN0b3IuX3NpemUgPSBuZXdTaXplO1xuICAgIHZlY3Rvci5fbGV2ZWwgPSBuZXdMZXZlbDtcbiAgICB2ZWN0b3IuX3Jvb3QgPSBuZXdSb290O1xuICAgIHZlY3Rvci5fdGFpbCA9IG5ld1RhaWw7XG4gICAgdmVjdG9yLl9faGFzaCA9IHVuZGVmaW5lZDtcbiAgICB2ZWN0b3IuX19hbHRlcmVkID0gdHJ1ZTtcbiAgICByZXR1cm4gdmVjdG9yO1xuICB9XG4gIHJldHVybiBtYWtlVmVjdG9yKG5ld09yaWdpbiwgbmV3U2l6ZSwgbmV3TGV2ZWwsIG5ld1Jvb3QsIG5ld1RhaWwpO1xufVxuZnVuY3Rpb24gbWVyZ2VJbnRvVmVjdG9yV2l0aCh2ZWN0b3IsIG1lcmdlciwgaXRlcmFibGVzKSB7XG4gIHZhciBzZXFzID0gW107XG4gIGZvciAodmFyIGlpID0gMDsgaWkgPCBpdGVyYWJsZXMubGVuZ3RoOyBpaSsrKSB7XG4gICAgdmFyIHNlcSA9IGl0ZXJhYmxlc1tpaV07XG4gICAgc2VxICYmIHNlcXMucHVzaChTZXF1ZW5jZShzZXEpKTtcbiAgfVxuICB2YXIgbWF4TGVuZ3RoID0gTWF0aC5tYXguYXBwbHkobnVsbCwgc2Vxcy5tYXAoKGZ1bmN0aW9uKHMpIHtcbiAgICByZXR1cm4gcy5sZW5ndGggfHwgMDtcbiAgfSkpKTtcbiAgaWYgKG1heExlbmd0aCA+IHZlY3Rvci5sZW5ndGgpIHtcbiAgICB2ZWN0b3IgPSB2ZWN0b3Iuc2V0TGVuZ3RoKG1heExlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIG1lcmdlSW50b0NvbGxlY3Rpb25XaXRoKHZlY3RvciwgbWVyZ2VyLCBzZXFzKTtcbn1cbmZ1bmN0aW9uIHJhd0luZGV4KGluZGV4LCBvcmlnaW4pIHtcbiAgaW52YXJpYW50KGluZGV4ID49IDAsICdJbmRleCBvdXQgb2YgYm91bmRzJyk7XG4gIHJldHVybiBpbmRleCArIG9yaWdpbjtcbn1cbmZ1bmN0aW9uIGdldFRhaWxPZmZzZXQoc2l6ZSkge1xuICByZXR1cm4gc2l6ZSA8IFNJWkUgPyAwIDogKCgoc2l6ZSAtIDEpID4+PiBTSElGVCkgPDwgU0hJRlQpO1xufVxudmFyIEVNUFRZX1ZFQ1Q7XG52YXIgU2V0ID0gZnVuY3Rpb24gU2V0KCkge1xuICBmb3IgKHZhciB2YWx1ZXMgPSBbXSxcbiAgICAgICRfXzggPSAwOyAkX184IDwgYXJndW1lbnRzLmxlbmd0aDsgJF9fOCsrKVxuICAgIHZhbHVlc1skX184XSA9IGFyZ3VtZW50c1skX184XTtcbiAgcmV0dXJuICRTZXQuZnJvbSh2YWx1ZXMpO1xufTtcbnZhciAkU2V0ID0gU2V0O1xuKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoU2V0LCB7XG4gIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fX3RvU3RyaW5nKCdTZXQgeycsICd9Jyk7XG4gIH0sXG4gIGhhczogZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLmhhcyh2YWx1ZSk7XG4gIH0sXG4gIGdldDogZnVuY3Rpb24odmFsdWUsIG5vdFNldFZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzKHZhbHVlKSA/IHZhbHVlIDogbm90U2V0VmFsdWU7XG4gIH0sXG4gIGFkZDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgbmV3TWFwID0gdGhpcy5fbWFwLnNldCh2YWx1ZSwgbnVsbCk7XG4gICAgaWYgKHRoaXMuX19vd25lcklEKSB7XG4gICAgICB0aGlzLmxlbmd0aCA9IG5ld01hcC5sZW5ndGg7XG4gICAgICB0aGlzLl9tYXAgPSBuZXdNYXA7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIG5ld01hcCA9PT0gdGhpcy5fbWFwID8gdGhpcyA6IG1ha2VTZXQobmV3TWFwKTtcbiAgfSxcbiAgcmVtb3ZlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciBuZXdNYXAgPSB0aGlzLl9tYXAucmVtb3ZlKHZhbHVlKTtcbiAgICBpZiAodGhpcy5fX293bmVySUQpIHtcbiAgICAgIHRoaXMubGVuZ3RoID0gbmV3TWFwLmxlbmd0aDtcbiAgICAgIHRoaXMuX21hcCA9IG5ld01hcDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gbmV3TWFwID09PSB0aGlzLl9tYXAgPyB0aGlzIDogbmV3TWFwLmxlbmd0aCA9PT0gMCA/ICRTZXQuZW1wdHkoKSA6IG1ha2VTZXQobmV3TWFwKTtcbiAgfSxcbiAgY2xlYXI6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmICh0aGlzLl9fb3duZXJJRCkge1xuICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgdGhpcy5fbWFwLmNsZWFyKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuICRTZXQuZW1wdHkoKTtcbiAgfSxcbiAgdW5pb246IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZXFzID0gYXJndW1lbnRzO1xuICAgIGlmIChzZXFzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLndpdGhNdXRhdGlvbnMoKGZ1bmN0aW9uKHNldCkge1xuICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IHNlcXMubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgIFNlcXVlbmNlKHNlcXNbaWldKS5mb3JFYWNoKChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBzZXQuYWRkKHZhbHVlKTtcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH0pKTtcbiAgfSxcbiAgaW50ZXJzZWN0OiBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBzZXFzID0gW10sXG4gICAgICAgICRfXzkgPSAwOyAkX185IDwgYXJndW1lbnRzLmxlbmd0aDsgJF9fOSsrKVxuICAgICAgc2Vxc1skX185XSA9IGFyZ3VtZW50c1skX185XTtcbiAgICBpZiAoc2Vxcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzZXFzID0gc2Vxcy5tYXAoKGZ1bmN0aW9uKHNlcSkge1xuICAgICAgcmV0dXJuIFNlcXVlbmNlKHNlcSk7XG4gICAgfSkpO1xuICAgIHZhciBvcmlnaW5hbFNldCA9IHRoaXM7XG4gICAgcmV0dXJuIHRoaXMud2l0aE11dGF0aW9ucygoZnVuY3Rpb24oc2V0KSB7XG4gICAgICBvcmlnaW5hbFNldC5mb3JFYWNoKChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAoIXNlcXMuZXZlcnkoKGZ1bmN0aW9uKHNlcSkge1xuICAgICAgICAgIHJldHVybiBzZXEuY29udGFpbnModmFsdWUpO1xuICAgICAgICB9KSkpIHtcbiAgICAgICAgICBzZXQucmVtb3ZlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgIH0pKTtcbiAgfSxcbiAgc3VidHJhY3Q6IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIHNlcXMgPSBbXSxcbiAgICAgICAgJF9fMTAgPSAwOyAkX18xMCA8IGFyZ3VtZW50cy5sZW5ndGg7ICRfXzEwKyspXG4gICAgICBzZXFzWyRfXzEwXSA9IGFyZ3VtZW50c1skX18xMF07XG4gICAgaWYgKHNlcXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2VxcyA9IHNlcXMubWFwKChmdW5jdGlvbihzZXEpIHtcbiAgICAgIHJldHVybiBTZXF1ZW5jZShzZXEpO1xuICAgIH0pKTtcbiAgICB2YXIgb3JpZ2luYWxTZXQgPSB0aGlzO1xuICAgIHJldHVybiB0aGlzLndpdGhNdXRhdGlvbnMoKGZ1bmN0aW9uKHNldCkge1xuICAgICAgb3JpZ2luYWxTZXQuZm9yRWFjaCgoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKHNlcXMuc29tZSgoZnVuY3Rpb24oc2VxKSB7XG4gICAgICAgICAgcmV0dXJuIHNlcS5jb250YWlucyh2YWx1ZSk7XG4gICAgICAgIH0pKSkge1xuICAgICAgICAgIHNldC5yZW1vdmUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfSkpO1xuICB9LFxuICBpc1N1YnNldDogZnVuY3Rpb24oc2VxKSB7XG4gICAgc2VxID0gU2VxdWVuY2Uoc2VxKTtcbiAgICByZXR1cm4gdGhpcy5ldmVyeSgoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBzZXEuY29udGFpbnModmFsdWUpO1xuICAgIH0pKTtcbiAgfSxcbiAgaXNTdXBlcnNldDogZnVuY3Rpb24oc2VxKSB7XG4gICAgdmFyIHNldCA9IHRoaXM7XG4gICAgc2VxID0gU2VxdWVuY2Uoc2VxKTtcbiAgICByZXR1cm4gc2VxLmV2ZXJ5KChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHNldC5jb250YWlucyh2YWx1ZSk7XG4gICAgfSkpO1xuICB9LFxuICB3YXNBbHRlcmVkOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLndhc0FsdGVyZWQoKTtcbiAgfSxcbiAgdmFsdWVzOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLmtleXMoKTtcbiAgfSxcbiAgZW50cmllczogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGl0ZXJhdG9yTWFwcGVyKHRoaXMudmFsdWVzKCksIChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBba2V5LCBrZXldO1xuICAgIH0pKTtcbiAgfSxcbiAgaGFzaENvZGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXAuaGFzaENvZGUoKTtcbiAgfSxcbiAgZXF1YWxzOiBmdW5jdGlvbihvdGhlcikge1xuICAgIHJldHVybiB0aGlzLl9tYXAuZXF1YWxzKG90aGVyLl9tYXApO1xuICB9LFxuICBfX2l0ZXJhdGU6IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7XG4gICAgdmFyIGNvbGxlY3Rpb24gPSB0aGlzO1xuICAgIHJldHVybiB0aGlzLl9tYXAuX19pdGVyYXRlKChmdW5jdGlvbihfLCBrKSB7XG4gICAgICByZXR1cm4gZm4oaywgaywgY29sbGVjdGlvbik7XG4gICAgfSksIHJldmVyc2UpO1xuICB9LFxuICBfX2Vuc3VyZU93bmVyOiBmdW5jdGlvbihvd25lcklEKSB7XG4gICAgaWYgKG93bmVySUQgPT09IHRoaXMuX19vd25lcklEKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIG5ld01hcCA9IHRoaXMuX21hcC5fX2Vuc3VyZU93bmVyKG93bmVySUQpO1xuICAgIGlmICghb3duZXJJRCkge1xuICAgICAgdGhpcy5fX293bmVySUQgPSBvd25lcklEO1xuICAgICAgdGhpcy5fbWFwID0gbmV3TWFwO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBtYWtlU2V0KG5ld01hcCwgb3duZXJJRCk7XG4gIH1cbn0sIHtcbiAgZW1wdHk6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBFTVBUWV9TRVQgfHwgKEVNUFRZX1NFVCA9IG1ha2VTZXQoTWFwLmVtcHR5KCkpKTtcbiAgfSxcbiAgZnJvbTogZnVuY3Rpb24oc2VxdWVuY2UpIHtcbiAgICB2YXIgc2V0ID0gJFNldC5lbXB0eSgpO1xuICAgIHJldHVybiBzZXF1ZW5jZSA/IHNlcXVlbmNlLmNvbnN0cnVjdG9yID09PSAkU2V0ID8gc2VxdWVuY2UgOiBzZXQudW5pb24oc2VxdWVuY2UpIDogc2V0O1xuICB9LFxuICBmcm9tS2V5czogZnVuY3Rpb24oc2VxdWVuY2UpIHtcbiAgICByZXR1cm4gJFNldC5mcm9tKFNlcXVlbmNlKHNlcXVlbmNlKS5mbGlwKCkpO1xuICB9XG59LCBTZXF1ZW5jZSk7XG52YXIgU2V0UHJvdG90eXBlID0gU2V0LnByb3RvdHlwZTtcblNldFByb3RvdHlwZVtERUxFVEVdID0gU2V0UHJvdG90eXBlLnJlbW92ZTtcblNldFByb3RvdHlwZVtJVEVSQVRPUl0gPSBTZXRQcm90b3R5cGUua2V5cyA9IFNldFByb3RvdHlwZS52YWx1ZXM7XG5TZXRQcm90b3R5cGUuY29udGFpbnMgPSBTZXRQcm90b3R5cGUuaGFzO1xuU2V0UHJvdG90eXBlLm1lcmdlRGVlcCA9IFNldFByb3RvdHlwZS5tZXJnZSA9IFNldFByb3RvdHlwZS51bmlvbjtcblNldFByb3RvdHlwZS5tZXJnZURlZXBXaXRoID0gU2V0UHJvdG90eXBlLm1lcmdlV2l0aCA9IGZ1bmN0aW9uKG1lcmdlcikge1xuICBmb3IgKHZhciBzZXFzID0gW10sXG4gICAgICAkX18xMSA9IDE7ICRfXzExIDwgYXJndW1lbnRzLmxlbmd0aDsgJF9fMTErKylcbiAgICBzZXFzWyRfXzExIC0gMV0gPSBhcmd1bWVudHNbJF9fMTFdO1xuICByZXR1cm4gdGhpcy5tZXJnZS5hcHBseSh0aGlzLCBzZXFzKTtcbn07XG5TZXRQcm90b3R5cGUud2l0aE11dGF0aW9ucyA9IE1hcFByb3RvdHlwZS53aXRoTXV0YXRpb25zO1xuU2V0UHJvdG90eXBlLmFzTXV0YWJsZSA9IE1hcFByb3RvdHlwZS5hc011dGFibGU7XG5TZXRQcm90b3R5cGUuYXNJbW11dGFibGUgPSBNYXBQcm90b3R5cGUuYXNJbW11dGFibGU7XG5TZXRQcm90b3R5cGUuX190b0pTID0gSW5kZXhlZFNlcXVlbmNlUHJvdG90eXBlLl9fdG9KUztcblNldFByb3RvdHlwZS5fX3RvU3RyaW5nTWFwcGVyID0gSW5kZXhlZFNlcXVlbmNlUHJvdG90eXBlLl9fdG9TdHJpbmdNYXBwZXI7XG5mdW5jdGlvbiBtYWtlU2V0KG1hcCwgb3duZXJJRCkge1xuICB2YXIgc2V0ID0gT2JqZWN0LmNyZWF0ZShTZXRQcm90b3R5cGUpO1xuICBzZXQubGVuZ3RoID0gbWFwID8gbWFwLmxlbmd0aCA6IDA7XG4gIHNldC5fbWFwID0gbWFwO1xuICBzZXQuX19vd25lcklEID0gb3duZXJJRDtcbiAgcmV0dXJuIHNldDtcbn1cbnZhciBFTVBUWV9TRVQ7XG52YXIgT3JkZXJlZE1hcCA9IGZ1bmN0aW9uIE9yZGVyZWRNYXAoc2VxdWVuY2UpIHtcbiAgdmFyIG1hcCA9ICRPcmRlcmVkTWFwLmVtcHR5KCk7XG4gIHJldHVybiBzZXF1ZW5jZSA/IHNlcXVlbmNlLmNvbnN0cnVjdG9yID09PSAkT3JkZXJlZE1hcCA/IHNlcXVlbmNlIDogbWFwLm1lcmdlKHNlcXVlbmNlKSA6IG1hcDtcbn07XG52YXIgJE9yZGVyZWRNYXAgPSBPcmRlcmVkTWFwO1xuKCR0cmFjZXVyUnVudGltZS5jcmVhdGVDbGFzcykoT3JkZXJlZE1hcCwge1xuICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX190b1N0cmluZygnT3JkZXJlZE1hcCB7JywgJ30nKTtcbiAgfSxcbiAgZ2V0OiBmdW5jdGlvbihrLCBub3RTZXRWYWx1ZSkge1xuICAgIHZhciBpbmRleCA9IHRoaXMuX21hcC5nZXQoayk7XG4gICAgcmV0dXJuIGluZGV4ICE9IG51bGwgPyB0aGlzLl92ZWN0b3IuZ2V0KGluZGV4KVsxXSA6IG5vdFNldFZhbHVlO1xuICB9LFxuICBjbGVhcjogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKHRoaXMuX19vd25lcklEKSB7XG4gICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICB0aGlzLl9tYXAuY2xlYXIoKTtcbiAgICAgIHRoaXMuX3ZlY3Rvci5jbGVhcigpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiAkT3JkZXJlZE1hcC5lbXB0eSgpO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKGssIHYpIHtcbiAgICByZXR1cm4gdXBkYXRlT3JkZXJlZE1hcCh0aGlzLCBrLCB2KTtcbiAgfSxcbiAgcmVtb3ZlOiBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIHVwZGF0ZU9yZGVyZWRNYXAodGhpcywgaywgTk9UX1NFVCk7XG4gIH0sXG4gIHdhc0FsdGVyZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXAud2FzQWx0ZXJlZCgpIHx8IHRoaXMuX3ZlY3Rvci53YXNBbHRlcmVkKCk7XG4gIH0sXG4gIGtleXM6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBpdGVyYXRvck1hcHBlcih0aGlzLmVudHJpZXMoKSwgKGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICByZXR1cm4gZW50cnlbMF07XG4gICAgfSkpO1xuICB9LFxuICB2YWx1ZXM6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBpdGVyYXRvck1hcHBlcih0aGlzLmVudHJpZXMoKSwgKGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICByZXR1cm4gZW50cnlbMV07XG4gICAgfSkpO1xuICB9LFxuICBlbnRyaWVzOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdmVjdG9yLnZhbHVlcyh0cnVlKTtcbiAgfSxcbiAgX19pdGVyYXRlOiBmdW5jdGlvbihmbiwgcmV2ZXJzZSkge1xuICAgIHJldHVybiB0aGlzLl92ZWN0b3IuZnJvbUVudHJ5U2VxKCkuX19pdGVyYXRlKGZuLCByZXZlcnNlKTtcbiAgfSxcbiAgX19kZWVwRXF1YWw6IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5lbnRyaWVzKCk7XG4gICAgcmV0dXJuIG90aGVyLmV2ZXJ5KChmdW5jdGlvbih2LCBrKSB7XG4gICAgICB2YXIgZW50cnkgPSBpdGVyYXRvci5uZXh0KCkudmFsdWU7XG4gICAgICByZXR1cm4gZW50cnkgJiYgaXMoZW50cnlbMF0sIGspICYmIGlzKGVudHJ5WzFdLCB2KTtcbiAgICB9KSk7XG4gIH0sXG4gIF9fZW5zdXJlT3duZXI6IGZ1bmN0aW9uKG93bmVySUQpIHtcbiAgICBpZiAob3duZXJJRCA9PT0gdGhpcy5fX293bmVySUQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2YXIgbmV3TWFwID0gdGhpcy5fbWFwLl9fZW5zdXJlT3duZXIob3duZXJJRCk7XG4gICAgdmFyIG5ld1ZlY3RvciA9IHRoaXMuX3ZlY3Rvci5fX2Vuc3VyZU93bmVyKG93bmVySUQpO1xuICAgIGlmICghb3duZXJJRCkge1xuICAgICAgdGhpcy5fX293bmVySUQgPSBvd25lcklEO1xuICAgICAgdGhpcy5fbWFwID0gbmV3TWFwO1xuICAgICAgdGhpcy5fdmVjdG9yID0gbmV3VmVjdG9yO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBtYWtlT3JkZXJlZE1hcChuZXdNYXAsIG5ld1ZlY3Rvciwgb3duZXJJRCwgdGhpcy5fX2hhc2gpO1xuICB9XG59LCB7ZW1wdHk6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBFTVBUWV9PUkRFUkVEX01BUCB8fCAoRU1QVFlfT1JERVJFRF9NQVAgPSBtYWtlT3JkZXJlZE1hcChNYXAuZW1wdHkoKSwgVmVjdG9yLmVtcHR5KCkpKTtcbiAgfX0sIE1hcCk7XG5PcmRlcmVkTWFwLmZyb20gPSBPcmRlcmVkTWFwO1xuT3JkZXJlZE1hcC5wcm90b3R5cGVbREVMRVRFXSA9IE9yZGVyZWRNYXAucHJvdG90eXBlLnJlbW92ZTtcbmZ1bmN0aW9uIG1ha2VPcmRlcmVkTWFwKG1hcCwgdmVjdG9yLCBvd25lcklELCBoYXNoKSB7XG4gIHZhciBvbWFwID0gT2JqZWN0LmNyZWF0ZShPcmRlcmVkTWFwLnByb3RvdHlwZSk7XG4gIG9tYXAubGVuZ3RoID0gbWFwID8gbWFwLmxlbmd0aCA6IDA7XG4gIG9tYXAuX21hcCA9IG1hcDtcbiAgb21hcC5fdmVjdG9yID0gdmVjdG9yO1xuICBvbWFwLl9fb3duZXJJRCA9IG93bmVySUQ7XG4gIG9tYXAuX19oYXNoID0gaGFzaDtcbiAgcmV0dXJuIG9tYXA7XG59XG5mdW5jdGlvbiB1cGRhdGVPcmRlcmVkTWFwKG9tYXAsIGssIHYpIHtcbiAgdmFyIG1hcCA9IG9tYXAuX21hcDtcbiAgdmFyIHZlY3RvciA9IG9tYXAuX3ZlY3RvcjtcbiAgdmFyIGkgPSBtYXAuZ2V0KGspO1xuICB2YXIgaGFzID0gaSAhPT0gdW5kZWZpbmVkO1xuICB2YXIgcmVtb3ZlZCA9IHYgPT09IE5PVF9TRVQ7XG4gIGlmICgoIWhhcyAmJiByZW1vdmVkKSB8fCAoaGFzICYmIHYgPT09IHZlY3Rvci5nZXQoaSlbMV0pKSB7XG4gICAgcmV0dXJuIG9tYXA7XG4gIH1cbiAgaWYgKCFoYXMpIHtcbiAgICBpID0gdmVjdG9yLmxlbmd0aDtcbiAgfVxuICB2YXIgbmV3TWFwID0gcmVtb3ZlZCA/IG1hcC5yZW1vdmUoaykgOiBoYXMgPyBtYXAgOiBtYXAuc2V0KGssIGkpO1xuICB2YXIgbmV3VmVjdG9yID0gcmVtb3ZlZCA/IHZlY3Rvci5yZW1vdmUoaSkgOiB2ZWN0b3Iuc2V0KGksIFtrLCB2XSk7XG4gIGlmIChvbWFwLl9fb3duZXJJRCkge1xuICAgIG9tYXAubGVuZ3RoID0gbmV3TWFwLmxlbmd0aDtcbiAgICBvbWFwLl9tYXAgPSBuZXdNYXA7XG4gICAgb21hcC5fdmVjdG9yID0gbmV3VmVjdG9yO1xuICAgIG9tYXAuX19oYXNoID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBvbWFwO1xuICB9XG4gIHJldHVybiBtYWtlT3JkZXJlZE1hcChuZXdNYXAsIG5ld1ZlY3Rvcik7XG59XG52YXIgRU1QVFlfT1JERVJFRF9NQVA7XG52YXIgUmVjb3JkID0gZnVuY3Rpb24gUmVjb3JkKGRlZmF1bHRWYWx1ZXMsIG5hbWUpIHtcbiAgdmFyIFJlY29yZFR5cGUgPSBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVjb3JkVHlwZSkpIHtcbiAgICAgIHJldHVybiBuZXcgUmVjb3JkVHlwZSh2YWx1ZXMpO1xuICAgIH1cbiAgICB0aGlzLl9tYXAgPSBNYXAodmFsdWVzKTtcbiAgfTtcbiAgZGVmYXVsdFZhbHVlcyA9IFNlcXVlbmNlKGRlZmF1bHRWYWx1ZXMpO1xuICB2YXIgUmVjb3JkVHlwZVByb3RvdHlwZSA9IFJlY29yZFR5cGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShSZWNvcmRQcm90b3R5cGUpO1xuICBSZWNvcmRUeXBlUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVjb3JkVHlwZTtcbiAgUmVjb3JkVHlwZVByb3RvdHlwZS5fbmFtZSA9IG5hbWU7XG4gIFJlY29yZFR5cGVQcm90b3R5cGUuX2RlZmF1bHRWYWx1ZXMgPSBkZWZhdWx0VmFsdWVzO1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRlZmF1bHRWYWx1ZXMpO1xuICBSZWNvcmRUeXBlLnByb3RvdHlwZS5sZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkge1xuICAgIGRlZmF1bHRWYWx1ZXMuZm9yRWFjaCgoZnVuY3Rpb24oXywga2V5KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVjb3JkVHlwZS5wcm90b3R5cGUsIGtleSwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmdldChrZXkpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgaW52YXJpYW50KHRoaXMuX19vd25lcklELCAnQ2Fubm90IHNldCBvbiBhbiBpbW11dGFibGUgcmVjb3JkLicpO1xuICAgICAgICAgIHRoaXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KSk7XG4gIH1cbiAgcmV0dXJuIFJlY29yZFR5cGU7XG59O1xudmFyICRSZWNvcmQgPSBSZWNvcmQ7XG4oJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShSZWNvcmQsIHtcbiAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9fdG9TdHJpbmcoKHRoaXMuX25hbWUgfHwgJ1JlY29yZCcpICsgJyB7JywgJ30nKTtcbiAgfSxcbiAgaGFzOiBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRWYWx1ZXMuaGFzKGspO1xuICB9LFxuICBnZXQ6IGZ1bmN0aW9uKGssIG5vdFNldFZhbHVlKSB7XG4gICAgaWYgKG5vdFNldFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIXRoaXMuaGFzKGspKSB7XG4gICAgICByZXR1cm4gbm90U2V0VmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9tYXAuZ2V0KGssIHRoaXMuX2RlZmF1bHRWYWx1ZXMuZ2V0KGspKTtcbiAgfSxcbiAgY2xlYXI6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9fb3duZXJJRCkge1xuICAgICAgdGhpcy5fbWFwLmNsZWFyKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIFJlY29yZCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gJFJlY29yZC5fZW1wdHkgfHwgKCRSZWNvcmQuX2VtcHR5ID0gbWFrZVJlY29yZCh0aGlzLCBNYXAuZW1wdHkoKSkpO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKGssIHYpIHtcbiAgICBpZiAoayA9PSBudWxsIHx8ICF0aGlzLmhhcyhrKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHZhciBuZXdNYXAgPSB0aGlzLl9tYXAuc2V0KGssIHYpO1xuICAgIGlmICh0aGlzLl9fb3duZXJJRCB8fCBuZXdNYXAgPT09IHRoaXMuX21hcCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBtYWtlUmVjb3JkKHRoaXMsIG5ld01hcCk7XG4gIH0sXG4gIHJlbW92ZTogZnVuY3Rpb24oaykge1xuICAgIGlmIChrID09IG51bGwgfHwgIXRoaXMuaGFzKGspKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIG5ld01hcCA9IHRoaXMuX21hcC5yZW1vdmUoayk7XG4gICAgaWYgKHRoaXMuX19vd25lcklEIHx8IG5ld01hcCA9PT0gdGhpcy5fbWFwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIG1ha2VSZWNvcmQodGhpcywgbmV3TWFwKTtcbiAgfSxcbiAga2V5czogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC5rZXlzKCk7XG4gIH0sXG4gIHZhbHVlczogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC52YWx1ZXMoKTtcbiAgfSxcbiAgZW50cmllczogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC5lbnRyaWVzKCk7XG4gIH0sXG4gIHdhc0FsdGVyZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXAud2FzQWx0ZXJlZCgpO1xuICB9LFxuICBfX2l0ZXJhdGU6IGZ1bmN0aW9uKGZuLCByZXZlcnNlKSB7XG4gICAgdmFyIHJlY29yZCA9IHRoaXM7XG4gICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRWYWx1ZXMubWFwKChmdW5jdGlvbihfLCBrKSB7XG4gICAgICByZXR1cm4gcmVjb3JkLmdldChrKTtcbiAgICB9KSkuX19pdGVyYXRlKGZuLCByZXZlcnNlKTtcbiAgfSxcbiAgX19lbnN1cmVPd25lcjogZnVuY3Rpb24ob3duZXJJRCkge1xuICAgIGlmIChvd25lcklEID09PSB0aGlzLl9fb3duZXJJRCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHZhciBuZXdNYXAgPSB0aGlzLl9tYXAgJiYgdGhpcy5fbWFwLl9fZW5zdXJlT3duZXIob3duZXJJRCk7XG4gICAgaWYgKCFvd25lcklEKSB7XG4gICAgICB0aGlzLl9fb3duZXJJRCA9IG93bmVySUQ7XG4gICAgICB0aGlzLl9tYXAgPSBuZXdNYXA7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIG1ha2VSZWNvcmQodGhpcywgbmV3TWFwLCBvd25lcklEKTtcbiAgfVxufSwge30sIFNlcXVlbmNlKTtcbnZhciBSZWNvcmRQcm90b3R5cGUgPSBSZWNvcmQucHJvdG90eXBlO1xuUmVjb3JkUHJvdG90eXBlW0RFTEVURV0gPSBSZWNvcmRQcm90b3R5cGUucmVtb3ZlO1xuUmVjb3JkUHJvdG90eXBlW0lURVJBVE9SXSA9IE1hcFByb3RvdHlwZVtJVEVSQVRPUl07XG5SZWNvcmRQcm90b3R5cGUubWVyZ2UgPSBNYXBQcm90b3R5cGUubWVyZ2U7XG5SZWNvcmRQcm90b3R5cGUubWVyZ2VXaXRoID0gTWFwUHJvdG90eXBlLm1lcmdlV2l0aDtcblJlY29yZFByb3RvdHlwZS5tZXJnZURlZXAgPSBNYXBQcm90b3R5cGUubWVyZ2VEZWVwO1xuUmVjb3JkUHJvdG90eXBlLm1lcmdlRGVlcFdpdGggPSBNYXBQcm90b3R5cGUubWVyZ2VEZWVwV2l0aDtcblJlY29yZFByb3RvdHlwZS51cGRhdGUgPSBNYXBQcm90b3R5cGUudXBkYXRlO1xuUmVjb3JkUHJvdG90eXBlLnVwZGF0ZUluID0gTWFwUHJvdG90eXBlLnVwZGF0ZUluO1xuUmVjb3JkUHJvdG90eXBlLmN1cnNvciA9IE1hcFByb3RvdHlwZS5jdXJzb3I7XG5SZWNvcmRQcm90b3R5cGUud2l0aE11dGF0aW9ucyA9IE1hcFByb3RvdHlwZS53aXRoTXV0YXRpb25zO1xuUmVjb3JkUHJvdG90eXBlLmFzTXV0YWJsZSA9IE1hcFByb3RvdHlwZS5hc011dGFibGU7XG5SZWNvcmRQcm90b3R5cGUuYXNJbW11dGFibGUgPSBNYXBQcm90b3R5cGUuYXNJbW11dGFibGU7XG5SZWNvcmRQcm90b3R5cGUuX19kZWVwRXF1YWwgPSBNYXBQcm90b3R5cGUuX19kZWVwRXF1YWw7XG5mdW5jdGlvbiBtYWtlUmVjb3JkKGxpa2VSZWNvcmQsIG1hcCwgb3duZXJJRCkge1xuICB2YXIgcmVjb3JkID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YobGlrZVJlY29yZCkpO1xuICByZWNvcmQuX21hcCA9IG1hcDtcbiAgcmVjb3JkLl9fb3duZXJJRCA9IG93bmVySUQ7XG4gIHJldHVybiByZWNvcmQ7XG59XG52YXIgUmFuZ2UgPSBmdW5jdGlvbiBSYW5nZShzdGFydCwgZW5kLCBzdGVwKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiAkUmFuZ2UpKSB7XG4gICAgcmV0dXJuIG5ldyAkUmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCk7XG4gIH1cbiAgaW52YXJpYW50KHN0ZXAgIT09IDAsICdDYW5ub3Qgc3RlcCBhIFJhbmdlIGJ5IDAnKTtcbiAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICBpZiAoZW5kID09IG51bGwpIHtcbiAgICBlbmQgPSBJbmZpbml0eTtcbiAgfVxuICBpZiAoc3RhcnQgPT09IGVuZCAmJiBfX0VNUFRZX1JBTkdFKSB7XG4gICAgcmV0dXJuIF9fRU1QVFlfUkFOR0U7XG4gIH1cbiAgc3RlcCA9IHN0ZXAgPT0gbnVsbCA/IDEgOiBNYXRoLmFicyhzdGVwKTtcbiAgaWYgKGVuZCA8IHN0YXJ0KSB7XG4gICAgc3RlcCA9IC1zdGVwO1xuICB9XG4gIHRoaXMuX3N0YXJ0ID0gc3RhcnQ7XG4gIHRoaXMuX2VuZCA9IGVuZDtcbiAgdGhpcy5fc3RlcCA9IHN0ZXA7XG4gIHRoaXMubGVuZ3RoID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKChlbmQgLSBzdGFydCkgLyBzdGVwIC0gMSkgKyAxKTtcbn07XG52YXIgJFJhbmdlID0gUmFuZ2U7XG4oJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzKShSYW5nZSwge1xuICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gJ1JhbmdlIFtdJztcbiAgICB9XG4gICAgcmV0dXJuICdSYW5nZSBbICcgKyB0aGlzLl9zdGFydCArICcuLi4nICsgdGhpcy5fZW5kICsgKHRoaXMuX3N0ZXAgPiAxID8gJyBieSAnICsgdGhpcy5fc3RlcCA6ICcnKSArICcgXSc7XG4gIH0sXG4gIGhhczogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICBpbnZhcmlhbnQoaW5kZXggPj0gMCwgJ0luZGV4IG91dCBvZiBib3VuZHMnKTtcbiAgICByZXR1cm4gaW5kZXggPCB0aGlzLmxlbmd0aDtcbiAgfSxcbiAgZ2V0OiBmdW5jdGlvbihpbmRleCwgbm90U2V0VmFsdWUpIHtcbiAgICBpbnZhcmlhbnQoaW5kZXggPj0gMCwgJ0luZGV4IG91dCBvZiBib3VuZHMnKTtcbiAgICByZXR1cm4gdGhpcy5sZW5ndGggPT09IEluZmluaXR5IHx8IGluZGV4IDwgdGhpcy5sZW5ndGggPyB0aGlzLl9zdGFydCArIGluZGV4ICogdGhpcy5fc3RlcCA6IG5vdFNldFZhbHVlO1xuICB9LFxuICBjb250YWluczogZnVuY3Rpb24oc2VhcmNoVmFsdWUpIHtcbiAgICB2YXIgcG9zc2libGVJbmRleCA9IChzZWFyY2hWYWx1ZSAtIHRoaXMuX3N0YXJ0KSAvIHRoaXMuX3N0ZXA7XG4gICAgcmV0dXJuIHBvc3NpYmxlSW5kZXggPj0gMCAmJiBwb3NzaWJsZUluZGV4IDwgdGhpcy5sZW5ndGggJiYgcG9zc2libGVJbmRleCA9PT0gTWF0aC5mbG9vcihwb3NzaWJsZUluZGV4KTtcbiAgfSxcbiAgc2xpY2U6IGZ1bmN0aW9uKGJlZ2luLCBlbmQsIG1haW50YWluSW5kaWNlcykge1xuICAgIGlmICh3aG9sZVNsaWNlKGJlZ2luLCBlbmQsIHRoaXMubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmIChtYWludGFpbkluZGljZXMpIHtcbiAgICAgIHJldHVybiAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDYWxsKHRoaXMsICRSYW5nZS5wcm90b3R5cGUsIFwic2xpY2VcIiwgW2JlZ2luLCBlbmQsIG1haW50YWluSW5kaWNlc10pO1xuICAgIH1cbiAgICBiZWdpbiA9IHJlc29sdmVCZWdpbihiZWdpbiwgdGhpcy5sZW5ndGgpO1xuICAgIGVuZCA9IHJlc29sdmVFbmQoZW5kLCB0aGlzLmxlbmd0aCk7XG4gICAgaWYgKGVuZCA8PSBiZWdpbikge1xuICAgICAgcmV0dXJuIF9fRU1QVFlfUkFOR0U7XG4gICAgfVxuICAgIHJldHVybiBuZXcgJFJhbmdlKHRoaXMuZ2V0KGJlZ2luLCB0aGlzLl9lbmQpLCB0aGlzLmdldChlbmQsIHRoaXMuX2VuZCksIHRoaXMuX3N0ZXApO1xuICB9LFxuICBpbmRleE9mOiBmdW5jdGlvbihzZWFyY2hWYWx1ZSkge1xuICAgIHZhciBvZmZzZXRWYWx1ZSA9IHNlYXJjaFZhbHVlIC0gdGhpcy5fc3RhcnQ7XG4gICAgaWYgKG9mZnNldFZhbHVlICUgdGhpcy5fc3RlcCA9PT0gMCkge1xuICAgICAgdmFyIGluZGV4ID0gb2Zmc2V0VmFsdWUgLyB0aGlzLl9zdGVwO1xuICAgICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfSxcbiAgbGFzdEluZGV4T2Y6IGZ1bmN0aW9uKHNlYXJjaFZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXhPZihzZWFyY2hWYWx1ZSk7XG4gIH0sXG4gIHRha2U6IGZ1bmN0aW9uKGFtb3VudCkge1xuICAgIHJldHVybiB0aGlzLnNsaWNlKDAsIGFtb3VudCk7XG4gIH0sXG4gIHNraXA6IGZ1bmN0aW9uKGFtb3VudCwgbWFpbnRhaW5JbmRpY2VzKSB7XG4gICAgcmV0dXJuIG1haW50YWluSW5kaWNlcyA/ICR0cmFjZXVyUnVudGltZS5zdXBlckNhbGwodGhpcywgJFJhbmdlLnByb3RvdHlwZSwgXCJza2lwXCIsIFthbW91bnRdKSA6IHRoaXMuc2xpY2UoYW1vdW50KTtcbiAgfSxcbiAgX19pdGVyYXRlOiBmdW5jdGlvbihmbiwgcmV2ZXJzZSwgZmxpcEluZGljZXMpIHtcbiAgICB2YXIgcmV2ZXJzZWRJbmRpY2VzID0gcmV2ZXJzZSBeIGZsaXBJbmRpY2VzO1xuICAgIHZhciBtYXhJbmRleCA9IHRoaXMubGVuZ3RoIC0gMTtcbiAgICB2YXIgc3RlcCA9IHRoaXMuX3N0ZXA7XG4gICAgdmFyIHZhbHVlID0gcmV2ZXJzZSA/IHRoaXMuX3N0YXJ0ICsgbWF4SW5kZXggKiBzdGVwIDogdGhpcy5fc3RhcnQ7XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8PSBtYXhJbmRleDsgaWkrKykge1xuICAgICAgaWYgKGZuKHZhbHVlLCByZXZlcnNlZEluZGljZXMgPyBtYXhJbmRleCAtIGlpIDogaWksIHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHZhbHVlICs9IHJldmVyc2UgPyAtc3RlcCA6IHN0ZXA7XG4gICAgfVxuICAgIHJldHVybiByZXZlcnNlZEluZGljZXMgPyB0aGlzLmxlbmd0aCA6IGlpO1xuICB9LFxuICBfX2RlZXBFcXVhbHM6IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXJ0ID09PSBvdGhlci5fc3RhcnQgJiYgdGhpcy5fZW5kID09PSBvdGhlci5fZW5kICYmIHRoaXMuX3N0ZXAgPT09IG90aGVyLl9zdGVwO1xuICB9XG59LCB7fSwgSW5kZXhlZFNlcXVlbmNlKTtcbnZhciBSYW5nZVByb3RvdHlwZSA9IFJhbmdlLnByb3RvdHlwZTtcblJhbmdlUHJvdG90eXBlLl9fdG9KUyA9IFJhbmdlUHJvdG90eXBlLnRvQXJyYXk7XG5SYW5nZVByb3RvdHlwZS5maXJzdCA9IFZlY3RvclByb3RvdHlwZS5maXJzdDtcblJhbmdlUHJvdG90eXBlLmxhc3QgPSBWZWN0b3JQcm90b3R5cGUubGFzdDtcbnZhciBfX0VNUFRZX1JBTkdFID0gUmFuZ2UoMCwgMCk7XG52YXIgUmVwZWF0ID0gZnVuY3Rpb24gUmVwZWF0KHZhbHVlLCB0aW1lcykge1xuICBpZiAodGltZXMgPT09IDAgJiYgRU1QVFlfUkVQRUFUKSB7XG4gICAgcmV0dXJuIEVNUFRZX1JFUEVBVDtcbiAgfVxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgJFJlcGVhdCkpIHtcbiAgICByZXR1cm4gbmV3ICRSZXBlYXQodmFsdWUsIHRpbWVzKTtcbiAgfVxuICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICB0aGlzLmxlbmd0aCA9IHRpbWVzID09IG51bGwgPyBJbmZpbml0eSA6IE1hdGgubWF4KDAsIHRpbWVzKTtcbn07XG52YXIgJFJlcGVhdCA9IFJlcGVhdDtcbigkdHJhY2V1clJ1bnRpbWUuY3JlYXRlQ2xhc3MpKFJlcGVhdCwge1xuICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gJ1JlcGVhdCBbXSc7XG4gICAgfVxuICAgIHJldHVybiAnUmVwZWF0IFsgJyArIHRoaXMuX3ZhbHVlICsgJyAnICsgdGhpcy5sZW5ndGggKyAnIHRpbWVzIF0nO1xuICB9LFxuICBnZXQ6IGZ1bmN0aW9uKGluZGV4LCBub3RTZXRWYWx1ZSkge1xuICAgIGludmFyaWFudChpbmRleCA+PSAwLCAnSW5kZXggb3V0IG9mIGJvdW5kcycpO1xuICAgIHJldHVybiB0aGlzLmxlbmd0aCA9PT0gSW5maW5pdHkgfHwgaW5kZXggPCB0aGlzLmxlbmd0aCA/IHRoaXMuX3ZhbHVlIDogbm90U2V0VmFsdWU7XG4gIH0sXG4gIGZpcnN0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gIH0sXG4gIGNvbnRhaW5zOiBmdW5jdGlvbihzZWFyY2hWYWx1ZSkge1xuICAgIHJldHVybiBpcyh0aGlzLl92YWx1ZSwgc2VhcmNoVmFsdWUpO1xuICB9LFxuICBzbGljZTogZnVuY3Rpb24oYmVnaW4sIGVuZCwgbWFpbnRhaW5JbmRpY2VzKSB7XG4gICAgaWYgKG1haW50YWluSW5kaWNlcykge1xuICAgICAgcmV0dXJuICR0cmFjZXVyUnVudGltZS5zdXBlckNhbGwodGhpcywgJFJlcGVhdC5wcm90b3R5cGUsIFwic2xpY2VcIiwgW2JlZ2luLCBlbmQsIG1haW50YWluSW5kaWNlc10pO1xuICAgIH1cbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgYmVnaW4gPSBiZWdpbiA8IDAgPyBNYXRoLm1heCgwLCBsZW5ndGggKyBiZWdpbikgOiBNYXRoLm1pbihsZW5ndGgsIGJlZ2luKTtcbiAgICBlbmQgPSBlbmQgPT0gbnVsbCA/IGxlbmd0aCA6IGVuZCA+IDAgPyBNYXRoLm1pbihsZW5ndGgsIGVuZCkgOiBNYXRoLm1heCgwLCBsZW5ndGggKyBlbmQpO1xuICAgIHJldHVybiBlbmQgPiBiZWdpbiA/IG5ldyAkUmVwZWF0KHRoaXMuX3ZhbHVlLCBlbmQgLSBiZWdpbikgOiBFTVBUWV9SRVBFQVQ7XG4gIH0sXG4gIHJldmVyc2U6IGZ1bmN0aW9uKG1haW50YWluSW5kaWNlcykge1xuICAgIHJldHVybiBtYWludGFpbkluZGljZXMgPyAkdHJhY2V1clJ1bnRpbWUuc3VwZXJDYWxsKHRoaXMsICRSZXBlYXQucHJvdG90eXBlLCBcInJldmVyc2VcIiwgW21haW50YWluSW5kaWNlc10pIDogdGhpcztcbiAgfSxcbiAgaW5kZXhPZjogZnVuY3Rpb24oc2VhcmNoVmFsdWUpIHtcbiAgICBpZiAoaXModGhpcy5fdmFsdWUsIHNlYXJjaFZhbHVlKSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfSxcbiAgbGFzdEluZGV4T2Y6IGZ1bmN0aW9uKHNlYXJjaFZhbHVlKSB7XG4gICAgaWYgKGlzKHRoaXMuX3ZhbHVlLCBzZWFyY2hWYWx1ZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9LFxuICBfX2l0ZXJhdGU6IGZ1bmN0aW9uKGZuLCByZXZlcnNlLCBmbGlwSW5kaWNlcykge1xuICAgIHZhciByZXZlcnNlZEluZGljZXMgPSByZXZlcnNlIF4gZmxpcEluZGljZXM7XG4gICAgaW52YXJpYW50KCFyZXZlcnNlZEluZGljZXMgfHwgdGhpcy5sZW5ndGggPCBJbmZpbml0eSwgJ0Nhbm5vdCBhY2Nlc3MgZW5kIG9mIGluZmluaXRlIHJhbmdlLicpO1xuICAgIHZhciBtYXhJbmRleCA9IHRoaXMubGVuZ3RoIC0gMTtcbiAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDw9IG1heEluZGV4OyBpaSsrKSB7XG4gICAgICBpZiAoZm4odGhpcy5fdmFsdWUsIHJldmVyc2VkSW5kaWNlcyA/IG1heEluZGV4IC0gaWkgOiBpaSwgdGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV2ZXJzZWRJbmRpY2VzID8gdGhpcy5sZW5ndGggOiBpaTtcbiAgfSxcbiAgX19kZWVwRXF1YWxzOiBmdW5jdGlvbihvdGhlcikge1xuICAgIHJldHVybiBpcyh0aGlzLl92YWx1ZSwgb3RoZXIuX3ZhbHVlKTtcbiAgfVxufSwge30sIEluZGV4ZWRTZXF1ZW5jZSk7XG52YXIgUmVwZWF0UHJvdG90eXBlID0gUmVwZWF0LnByb3RvdHlwZTtcblJlcGVhdFByb3RvdHlwZS5sYXN0ID0gUmVwZWF0UHJvdG90eXBlLmZpcnN0O1xuUmVwZWF0UHJvdG90eXBlLmhhcyA9IFJhbmdlUHJvdG90eXBlLmhhcztcblJlcGVhdFByb3RvdHlwZS50YWtlID0gUmFuZ2VQcm90b3R5cGUudGFrZTtcblJlcGVhdFByb3RvdHlwZS5za2lwID0gUmFuZ2VQcm90b3R5cGUuc2tpcDtcblJlcGVhdFByb3RvdHlwZS5fX3RvSlMgPSBSYW5nZVByb3RvdHlwZS5fX3RvSlM7XG52YXIgRU1QVFlfUkVQRUFUID0gbmV3IFJlcGVhdCh1bmRlZmluZWQsIDApO1xuZnVuY3Rpb24gZnJvbUpTKGpzb24sIGNvbnZlcnRlcikge1xuICBpZiAoY29udmVydGVyKSB7XG4gICAgcmV0dXJuIF9mcm9tSlNXaXRoKGNvbnZlcnRlciwganNvbiwgJycsIHsnJzoganNvbn0pO1xuICB9XG4gIHJldHVybiBfZnJvbUpTRGVmYXVsdChqc29uKTtcbn1cbmZ1bmN0aW9uIF9mcm9tSlNXaXRoKGNvbnZlcnRlciwganNvbiwga2V5LCBwYXJlbnRKU09OKSB7XG4gIGlmIChqc29uICYmIChBcnJheS5pc0FycmF5KGpzb24pIHx8IGpzb24uY29uc3RydWN0b3IgPT09IE9iamVjdCkpIHtcbiAgICByZXR1cm4gY29udmVydGVyLmNhbGwocGFyZW50SlNPTiwga2V5LCBTZXF1ZW5jZShqc29uKS5tYXAoKGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgIHJldHVybiBfZnJvbUpTV2l0aChjb252ZXJ0ZXIsIHYsIGssIGpzb24pO1xuICAgIH0pKSk7XG4gIH1cbiAgcmV0dXJuIGpzb247XG59XG5mdW5jdGlvbiBfZnJvbUpTRGVmYXVsdChqc29uKSB7XG4gIGlmIChqc29uKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoanNvbikpIHtcbiAgICAgIHJldHVybiBTZXF1ZW5jZShqc29uKS5tYXAoX2Zyb21KU0RlZmF1bHQpLnRvVmVjdG9yKCk7XG4gICAgfVxuICAgIGlmIChqc29uLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgIHJldHVybiBTZXF1ZW5jZShqc29uKS5tYXAoX2Zyb21KU0RlZmF1bHQpLnRvTWFwKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBqc29uO1xufVxudmFyIEltbXV0YWJsZSA9IHtcbiAgU2VxdWVuY2U6IFNlcXVlbmNlLFxuICBNYXA6IE1hcCxcbiAgVmVjdG9yOiBWZWN0b3IsXG4gIFNldDogU2V0LFxuICBPcmRlcmVkTWFwOiBPcmRlcmVkTWFwLFxuICBSZWNvcmQ6IFJlY29yZCxcbiAgUmFuZ2U6IFJhbmdlLFxuICBSZXBlYXQ6IFJlcGVhdCxcbiAgaXM6IGlzLFxuICBmcm9tSlM6IGZyb21KU1xufTtcblxuICByZXR1cm4gSW1tdXRhYmxlO1xufVxudHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnID8gbW9kdWxlLmV4cG9ydHMgPSB1bml2ZXJzYWxNb2R1bGUoKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSh1bml2ZXJzYWxNb2R1bGUpIDpcbiAgICBJbW11dGFibGUgPSB1bml2ZXJzYWxNb2R1bGUoKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvUmVhY3RXaXRoQWRkb25zJyk7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQXV0b0ZvY3VzTWl4aW5cbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBmb2N1c05vZGUgPSByZXF1aXJlKFwiLi9mb2N1c05vZGVcIik7XG5cbnZhciBBdXRvRm9jdXNNaXhpbiA9IHtcbiAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnByb3BzLmF1dG9Gb2N1cykge1xuICAgICAgZm9jdXNOb2RlKHRoaXMuZ2V0RE9NTm9kZSgpKTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQXV0b0ZvY3VzTWl4aW47XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzIEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEJlZm9yZUlucHV0RXZlbnRQbHVnaW5cbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoXCIuL0V2ZW50Q29uc3RhbnRzXCIpO1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKFwiLi9FdmVudFByb3BhZ2F0b3JzXCIpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZShcIi4vRXhlY3V0aW9uRW52aXJvbm1lbnRcIik7XG52YXIgU3ludGhldGljSW5wdXRFdmVudCA9IHJlcXVpcmUoXCIuL1N5bnRoZXRpY0lucHV0RXZlbnRcIik7XG5cbnZhciBrZXlPZiA9IHJlcXVpcmUoXCIuL2tleU9mXCIpO1xuXG52YXIgY2FuVXNlVGV4dElucHV0RXZlbnQgPSAoXG4gIEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJlxuICAnVGV4dEV2ZW50JyBpbiB3aW5kb3cgJiZcbiAgISgnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCB8fCBpc1ByZXN0bygpKVxuKTtcblxuLyoqXG4gKiBPcGVyYSA8PSAxMiBpbmNsdWRlcyBUZXh0RXZlbnQgaW4gd2luZG93LCBidXQgZG9lcyBub3QgZmlyZVxuICogdGV4dCBpbnB1dCBldmVudHMuIFJlbHkgb24ga2V5cHJlc3MgaW5zdGVhZC5cbiAqL1xuZnVuY3Rpb24gaXNQcmVzdG8oKSB7XG4gIHZhciBvcGVyYSA9IHdpbmRvdy5vcGVyYTtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2Ygb3BlcmEgPT09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIG9wZXJhLnZlcnNpb24gPT09ICdmdW5jdGlvbicgJiZcbiAgICBwYXJzZUludChvcGVyYS52ZXJzaW9uKCksIDEwKSA8PSAxMlxuICApO1xufVxuXG52YXIgU1BBQ0VCQVJfQ09ERSA9IDMyO1xudmFyIFNQQUNFQkFSX0NIQVIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKFNQQUNFQkFSX0NPREUpO1xuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG5cbi8vIEV2ZW50cyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSBuYW1lcy5cbnZhciBldmVudFR5cGVzID0ge1xuICBiZWZvcmVJbnB1dDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7b25CZWZvcmVJbnB1dDogbnVsbH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHtvbkJlZm9yZUlucHV0Q2FwdHVyZTogbnVsbH0pXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFtcbiAgICAgIHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25FbmQsXG4gICAgICB0b3BMZXZlbFR5cGVzLnRvcEtleVByZXNzLFxuICAgICAgdG9wTGV2ZWxUeXBlcy50b3BUZXh0SW5wdXQsXG4gICAgICB0b3BMZXZlbFR5cGVzLnRvcFBhc3RlXG4gICAgXVxuICB9XG59O1xuXG4vLyBUcmFjayBjaGFyYWN0ZXJzIGluc2VydGVkIHZpYSBrZXlwcmVzcyBhbmQgY29tcG9zaXRpb24gZXZlbnRzLlxudmFyIGZhbGxiYWNrQ2hhcnMgPSBudWxsO1xuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIGEgbmF0aXZlIGtleXByZXNzIGV2ZW50IGlzIGFzc3VtZWQgdG8gYmUgYSBjb21tYW5kLlxuICogVGhpcyBpcyByZXF1aXJlZCBiZWNhdXNlIEZpcmVmb3ggZmlyZXMgYGtleXByZXNzYCBldmVudHMgZm9yIGtleSBjb21tYW5kc1xuICogKGN1dCwgY29weSwgc2VsZWN0LWFsbCwgZXRjLikgZXZlbiB0aG91Z2ggbm8gY2hhcmFjdGVyIGlzIGluc2VydGVkLlxuICovXG5mdW5jdGlvbiBpc0tleXByZXNzQ29tbWFuZChuYXRpdmVFdmVudCkge1xuICByZXR1cm4gKFxuICAgIChuYXRpdmVFdmVudC5jdHJsS2V5IHx8IG5hdGl2ZUV2ZW50LmFsdEtleSB8fCBuYXRpdmVFdmVudC5tZXRhS2V5KSAmJlxuICAgIC8vIGN0cmxLZXkgJiYgYWx0S2V5IGlzIGVxdWl2YWxlbnQgdG8gQWx0R3IsIGFuZCBpcyBub3QgYSBjb21tYW5kLlxuICAgICEobmF0aXZlRXZlbnQuY3RybEtleSAmJiBuYXRpdmVFdmVudC5hbHRLZXkpXG4gICk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGBvbkJlZm9yZUlucHV0YCBldmVudCB0byBtYXRjaFxuICogaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAxMzExMDUvI2V2ZW50cy1pbnB1dGV2ZW50cy5cbiAqXG4gKiBUaGlzIGV2ZW50IHBsdWdpbiBpcyBiYXNlZCBvbiB0aGUgbmF0aXZlIGB0ZXh0SW5wdXRgIGV2ZW50XG4gKiBhdmFpbGFibGUgaW4gQ2hyb21lLCBTYWZhcmksIE9wZXJhLCBhbmQgSUUuIFRoaXMgZXZlbnQgZmlyZXMgYWZ0ZXJcbiAqIGBvbktleVByZXNzYCBhbmQgYG9uQ29tcG9zaXRpb25FbmRgLCBidXQgYmVmb3JlIGBvbklucHV0YC5cbiAqXG4gKiBgYmVmb3JlSW5wdXRgIGlzIHNwZWMnZCBidXQgbm90IGltcGxlbWVudGVkIGluIGFueSBicm93c2VycywgYW5kXG4gKiB0aGUgYGlucHV0YCBldmVudCBkb2VzIG5vdCBwcm92aWRlIGFueSB1c2VmdWwgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBoYXNcbiAqIGFjdHVhbGx5IGJlZW4gYWRkZWQsIGNvbnRyYXJ5IHRvIHRoZSBzcGVjLiBUaHVzLCBgdGV4dElucHV0YCBpcyB0aGUgYmVzdFxuICogYXZhaWxhYmxlIGV2ZW50IHRvIGlkZW50aWZ5IHRoZSBjaGFyYWN0ZXJzIHRoYXQgaGF2ZSBhY3R1YWxseSBiZWVuIGluc2VydGVkXG4gKiBpbnRvIHRoZSB0YXJnZXQgbm9kZS5cbiAqL1xudmFyIEJlZm9yZUlucHV0RXZlbnRQbHVnaW4gPSB7XG5cbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0b3BMZXZlbFRhcmdldCBUaGUgbGlzdGVuaW5nIGNvbXBvbmVudCByb290IG5vZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFRhcmdldElEIElEIG9mIGB0b3BMZXZlbFRhcmdldGAuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAgICogQHJldHVybiB7Kn0gQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gICAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmV4dHJhY3RFdmVudHN9XG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbihcbiAgICAgIHRvcExldmVsVHlwZSxcbiAgICAgIHRvcExldmVsVGFyZ2V0LFxuICAgICAgdG9wTGV2ZWxUYXJnZXRJRCxcbiAgICAgIG5hdGl2ZUV2ZW50KSB7XG5cbiAgICB2YXIgY2hhcnM7XG5cbiAgICBpZiAoY2FuVXNlVGV4dElucHV0RXZlbnQpIHtcbiAgICAgIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzczpcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBJZiBuYXRpdmUgYHRleHRJbnB1dGAgZXZlbnRzIGFyZSBhdmFpbGFibGUsIG91ciBnb2FsIGlzIHRvIG1ha2VcbiAgICAgICAgICAgKiB1c2Ugb2YgdGhlbS4gSG93ZXZlciwgdGhlcmUgaXMgYSBzcGVjaWFsIGNhc2U6IHRoZSBzcGFjZWJhciBrZXkuXG4gICAgICAgICAgICogSW4gV2Via2l0LCBwcmV2ZW50aW5nIGRlZmF1bHQgb24gYSBzcGFjZWJhciBgdGV4dElucHV0YCBldmVudFxuICAgICAgICAgICAqIGNhbmNlbHMgY2hhcmFjdGVyIGluc2VydGlvbiwgYnV0IGl0ICphbHNvKiBjYXVzZXMgdGhlIGJyb3dzZXJcbiAgICAgICAgICAgKiB0byBmYWxsIGJhY2sgdG8gaXRzIGRlZmF1bHQgc3BhY2ViYXIgYmVoYXZpb3Igb2Ygc2Nyb2xsaW5nIHRoZVxuICAgICAgICAgICAqIHBhZ2UuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBUcmFja2luZyBhdDpcbiAgICAgICAgICAgKiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MzU1MTAzXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBUbyBhdm9pZCB0aGlzIGlzc3VlLCB1c2UgdGhlIGtleXByZXNzIGV2ZW50IGFzIGlmIG5vIGB0ZXh0SW5wdXRgXG4gICAgICAgICAgICogZXZlbnQgaXMgYXZhaWxhYmxlLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIHZhciB3aGljaCA9IG5hdGl2ZUV2ZW50LndoaWNoO1xuICAgICAgICAgIGlmICh3aGljaCAhPT0gU1BBQ0VCQVJfQ09ERSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNoYXJzID0gU3RyaW5nLmZyb21DaGFyQ29kZSh3aGljaCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFRleHRJbnB1dDpcbiAgICAgICAgICAvLyBSZWNvcmQgdGhlIGNoYXJhY3RlcnMgdG8gYmUgYWRkZWQgdG8gdGhlIERPTS5cbiAgICAgICAgICBjaGFycyA9IG5hdGl2ZUV2ZW50LmRhdGE7XG5cbiAgICAgICAgICAvLyBJZiBpdCdzIGEgc3BhY2ViYXIgY2hhcmFjdGVyLCBhc3N1bWUgdGhhdCB3ZSBoYXZlIGFscmVhZHkgaGFuZGxlZFxuICAgICAgICAgIC8vIGl0IGF0IHRoZSBrZXlwcmVzcyBsZXZlbCBhbmQgYmFpbCBpbW1lZGlhdGVseS5cbiAgICAgICAgICBpZiAoY2hhcnMgPT09IFNQQUNFQkFSX0NIQVIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBPdGhlcndpc2UsIGNhcnJ5IG9uLlxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gRm9yIG90aGVyIG5hdGl2ZSBldmVudCB0eXBlcywgZG8gbm90aGluZy5cbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BQYXN0ZTpcbiAgICAgICAgICAvLyBJZiBhIHBhc3RlIGV2ZW50IG9jY3VycyBhZnRlciBhIGtleXByZXNzLCB0aHJvdyBvdXQgdGhlIGlucHV0XG4gICAgICAgICAgLy8gY2hhcnMuIFBhc3RlIGV2ZW50cyBzaG91bGQgbm90IGxlYWQgdG8gQmVmb3JlSW5wdXQgZXZlbnRzLlxuICAgICAgICAgIGZhbGxiYWNrQ2hhcnMgPSBudWxsO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3M6XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQXMgb2YgdjI3LCBGaXJlZm94IG1heSBmaXJlIGtleXByZXNzIGV2ZW50cyBldmVuIHdoZW4gbm8gY2hhcmFjdGVyXG4gICAgICAgICAgICogd2lsbCBiZSBpbnNlcnRlZC4gQSBmZXcgcG9zc2liaWxpdGllczpcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIC0gYHdoaWNoYCBpcyBgMGAuIEFycm93IGtleXMsIEVzYyBrZXksIGV0Yy5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIC0gYHdoaWNoYCBpcyB0aGUgcHJlc3NlZCBrZXkgY29kZSwgYnV0IG5vIGNoYXIgaXMgYXZhaWxhYmxlLlxuICAgICAgICAgICAqICAgRXg6ICdBbHRHciArIGRgIGluIFBvbGlzaC4gVGhlcmUgaXMgbm8gbW9kaWZpZWQgY2hhcmFjdGVyIGZvclxuICAgICAgICAgICAqICAgdGhpcyBrZXkgY29tYmluYXRpb24gYW5kIG5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZCBpbnRvIHRoZVxuICAgICAgICAgICAqICAgZG9jdW1lbnQsIGJ1dCBGRiBmaXJlcyB0aGUga2V5cHJlc3MgZm9yIGNoYXIgY29kZSBgMTAwYCBhbnl3YXkuXG4gICAgICAgICAgICogICBObyBgaW5wdXRgIGV2ZW50IHdpbGwgb2NjdXIuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiAtIGB3aGljaGAgaXMgdGhlIHByZXNzZWQga2V5IGNvZGUsIGJ1dCBhIGNvbW1hbmQgY29tYmluYXRpb24gaXNcbiAgICAgICAgICAgKiAgIGJlaW5nIHVzZWQuIEV4OiBgQ21kK0NgLiBObyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQsIGFuZCBub1xuICAgICAgICAgICAqICAgYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxuICAgICAgICAgICAqL1xuICAgICAgICAgIGlmIChuYXRpdmVFdmVudC53aGljaCAmJiAhaXNLZXlwcmVzc0NvbW1hbmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgICBmYWxsYmFja0NoYXJzID0gU3RyaW5nLmZyb21DaGFyQ29kZShuYXRpdmVFdmVudC53aGljaCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25FbmQ6XG4gICAgICAgICAgZmFsbGJhY2tDaGFycyA9IG5hdGl2ZUV2ZW50LmRhdGE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIG5vIGNoYW5nZXMgaGF2ZSBvY2N1cnJlZCB0byB0aGUgZmFsbGJhY2sgc3RyaW5nLCBubyByZWxldmFudFxuICAgICAgLy8gZXZlbnQgaGFzIGZpcmVkIGFuZCB3ZSdyZSBkb25lLlxuICAgICAgaWYgKGZhbGxiYWNrQ2hhcnMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjaGFycyA9IGZhbGxiYWNrQ2hhcnM7XG4gICAgfVxuXG4gICAgLy8gSWYgbm8gY2hhcmFjdGVycyBhcmUgYmVpbmcgaW5zZXJ0ZWQsIG5vIEJlZm9yZUlucHV0IGV2ZW50IHNob3VsZFxuICAgIC8vIGJlIGZpcmVkLlxuICAgIGlmICghY2hhcnMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZXZlbnQgPSBTeW50aGV0aWNJbnB1dEV2ZW50LmdldFBvb2xlZChcbiAgICAgIGV2ZW50VHlwZXMuYmVmb3JlSW5wdXQsXG4gICAgICB0b3BMZXZlbFRhcmdldElELFxuICAgICAgbmF0aXZlRXZlbnRcbiAgICApO1xuXG4gICAgZXZlbnQuZGF0YSA9IGNoYXJzO1xuICAgIGZhbGxiYWNrQ2hhcnMgPSBudWxsO1xuICAgIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJlZm9yZUlucHV0RXZlbnRQbHVnaW47XG4iLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIENTU0NvcmVcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcblxuLyoqXG4gKiBUaGUgQ1NTQ29yZSBtb2R1bGUgc3BlY2lmaWVzIHRoZSBBUEkgKGFuZCBpbXBsZW1lbnRzIG1vc3Qgb2YgdGhlIG1ldGhvZHMpXG4gKiB0aGF0IHNob3VsZCBiZSB1c2VkIHdoZW4gZGVhbGluZyB3aXRoIHRoZSBkaXNwbGF5IG9mIGVsZW1lbnRzICh2aWEgdGhlaXJcbiAqIENTUyBjbGFzc2VzIGFuZCB2aXNpYmlsaXR5IG9uIHNjcmVlbi4gSXQgaXMgYW4gQVBJIGZvY3VzZWQgb24gbXV0YXRpbmcgdGhlXG4gKiBkaXNwbGF5IGFuZCBub3QgcmVhZGluZyBpdCBhcyBubyBsb2dpY2FsIHN0YXRlIHNob3VsZCBiZSBlbmNvZGVkIGluIHRoZVxuICogZGlzcGxheSBvZiBlbGVtZW50cy5cbiAqL1xuXG52YXIgQ1NTQ29yZSA9IHtcblxuICAvKipcbiAgICogQWRkcyB0aGUgY2xhc3MgcGFzc2VkIGluIHRvIHRoZSBlbGVtZW50IGlmIGl0IGRvZXNuJ3QgYWxyZWFkeSBoYXZlIGl0LlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGVsZW1lbnQgdGhlIGVsZW1lbnQgdG8gc2V0IHRoZSBjbGFzcyBvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIHRoZSBDU1MgY2xhc3NOYW1lXG4gICAqIEByZXR1cm4ge0RPTUVsZW1lbnR9IHRoZSBlbGVtZW50IHBhc3NlZCBpblxuICAgKi9cbiAgYWRkQ2xhc3M6IGZ1bmN0aW9uKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAhL1xccy8udGVzdChjbGFzc05hbWUpLFxuICAgICAgJ0NTU0NvcmUuYWRkQ2xhc3MgdGFrZXMgb25seSBhIHNpbmdsZSBjbGFzcyBuYW1lLiBcIiVzXCIgY29udGFpbnMgJyArXG4gICAgICAnbXVsdGlwbGUgY2xhc3Nlcy4nLCBjbGFzc05hbWVcbiAgICApIDogaW52YXJpYW50KCEvXFxzLy50ZXN0KGNsYXNzTmFtZSkpKTtcblxuICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgICAgIH0gZWxzZSBpZiAoIUNTU0NvcmUuaGFzQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSkge1xuICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lICsgJyAnICsgY2xhc3NOYW1lO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgY2xhc3MgcGFzc2VkIGluIGZyb20gdGhlIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBlbGVtZW50IHRoZSBlbGVtZW50IHRvIHNldCB0aGUgY2xhc3Mgb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSB0aGUgQ1NTIGNsYXNzTmFtZVxuICAgKiBAcmV0dXJuIHtET01FbGVtZW50fSB0aGUgZWxlbWVudCBwYXNzZWQgaW5cbiAgICovXG4gIHJlbW92ZUNsYXNzOiBmdW5jdGlvbihlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgIS9cXHMvLnRlc3QoY2xhc3NOYW1lKSxcbiAgICAgICdDU1NDb3JlLnJlbW92ZUNsYXNzIHRha2VzIG9ubHkgYSBzaW5nbGUgY2xhc3MgbmFtZS4gXCIlc1wiIGNvbnRhaW5zICcgK1xuICAgICAgJ211bHRpcGxlIGNsYXNzZXMuJywgY2xhc3NOYW1lXG4gICAgKSA6IGludmFyaWFudCghL1xccy8udGVzdChjbGFzc05hbWUpKSk7XG5cbiAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gICAgICB9IGVsc2UgaWYgKENTU0NvcmUuaGFzQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSkge1xuICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lXG4gICAgICAgICAgLnJlcGxhY2UobmV3IFJlZ0V4cCgnKF58XFxcXHMpJyArIGNsYXNzTmFtZSArICcoPzpcXFxcc3wkKScsICdnJyksICckMScpXG4gICAgICAgICAgLnJlcGxhY2UoL1xccysvZywgJyAnKSAvLyBtdWx0aXBsZSBzcGFjZXMgdG8gb25lXG4gICAgICAgICAgLnJlcGxhY2UoL15cXHMqfFxccyokL2csICcnKTsgLy8gdHJpbSB0aGUgZW5kc1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfSxcblxuICAvKipcbiAgICogSGVscGVyIHRvIGFkZCBvciByZW1vdmUgYSBjbGFzcyBmcm9tIGFuIGVsZW1lbnQgYmFzZWQgb24gYSBjb25kaXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gZWxlbWVudCB0aGUgZWxlbWVudCB0byBzZXQgdGhlIGNsYXNzIG9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgdGhlIENTUyBjbGFzc05hbWVcbiAgICogQHBhcmFtIHsqfSBib29sIGNvbmRpdGlvbiB0byB3aGV0aGVyIHRvIGFkZCBvciByZW1vdmUgdGhlIGNsYXNzXG4gICAqIEByZXR1cm4ge0RPTUVsZW1lbnR9IHRoZSBlbGVtZW50IHBhc3NlZCBpblxuICAgKi9cbiAgY29uZGl0aW9uQ2xhc3M6IGZ1bmN0aW9uKGVsZW1lbnQsIGNsYXNzTmFtZSwgYm9vbCkge1xuICAgIHJldHVybiAoYm9vbCA/IENTU0NvcmUuYWRkQ2xhc3MgOiBDU1NDb3JlLnJlbW92ZUNsYXNzKShlbGVtZW50LCBjbGFzc05hbWUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUZXN0cyB3aGV0aGVyIHRoZSBlbGVtZW50IGhhcyB0aGUgY2xhc3Mgc3BlY2lmaWVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTU5vZGV8RE9NV2luZG93fSBlbGVtZW50IHRoZSBlbGVtZW50IHRvIHNldCB0aGUgY2xhc3Mgb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSB0aGUgQ1NTIGNsYXNzTmFtZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgZWxlbWVudCBoYXMgdGhlIGNsYXNzLCBmYWxzZSBpZiBub3RcbiAgICovXG4gIGhhc0NsYXNzOiBmdW5jdGlvbihlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgIS9cXHMvLnRlc3QoY2xhc3NOYW1lKSxcbiAgICAgICdDU1MuaGFzQ2xhc3MgdGFrZXMgb25seSBhIHNpbmdsZSBjbGFzcyBuYW1lLidcbiAgICApIDogaW52YXJpYW50KCEvXFxzLy50ZXN0KGNsYXNzTmFtZSkpKTtcbiAgICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHtcbiAgICAgIHJldHVybiAhIWNsYXNzTmFtZSAmJiBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gKCcgJyArIGVsZW1lbnQuY2xhc3NOYW1lICsgJyAnKS5pbmRleE9mKCcgJyArIGNsYXNzTmFtZSArICcgJykgPiAtMTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENTU0NvcmU7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBDU1NQcm9wZXJ0eVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIENTUyBwcm9wZXJ0aWVzIHdoaWNoIGFjY2VwdCBudW1iZXJzIGJ1dCBhcmUgbm90IGluIHVuaXRzIG9mIFwicHhcIi5cbiAqL1xudmFyIGlzVW5pdGxlc3NOdW1iZXIgPSB7XG4gIGNvbHVtbkNvdW50OiB0cnVlLFxuICBmaWxsT3BhY2l0eTogdHJ1ZSxcbiAgZmxleDogdHJ1ZSxcbiAgZmxleEdyb3c6IHRydWUsXG4gIGZsZXhTaHJpbms6IHRydWUsXG4gIGZvbnRXZWlnaHQ6IHRydWUsXG4gIGxpbmVDbGFtcDogdHJ1ZSxcbiAgbGluZUhlaWdodDogdHJ1ZSxcbiAgb3BhY2l0eTogdHJ1ZSxcbiAgb3JkZXI6IHRydWUsXG4gIG9ycGhhbnM6IHRydWUsXG4gIHdpZG93czogdHJ1ZSxcbiAgekluZGV4OiB0cnVlLFxuICB6b29tOiB0cnVlXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXggdmVuZG9yLXNwZWNpZmljIHByZWZpeCwgZWc6IFdlYmtpdFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBzdHlsZSBuYW1lLCBlZzogdHJhbnNpdGlvbkR1cmF0aW9uXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHN0eWxlIG5hbWUgcHJlZml4ZWQgd2l0aCBgcHJlZml4YCwgcHJvcGVybHkgY2FtZWxDYXNlZCwgZWc6XG4gKiBXZWJraXRUcmFuc2l0aW9uRHVyYXRpb25cbiAqL1xuZnVuY3Rpb24gcHJlZml4S2V5KHByZWZpeCwga2V5KSB7XG4gIHJldHVybiBwcmVmaXggKyBrZXkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrZXkuc3Vic3RyaW5nKDEpO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgc3R5bGUgbmFtZXMgdGhhdCBtYXkgY29tZSBwYXNzZWQgaW4gcHJlZml4ZWQgYnkgYWRkaW5nIHBlcm11dGF0aW9uc1xuICogb2YgdmVuZG9yIHByZWZpeGVzLlxuICovXG52YXIgcHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdtcycsICdNb3onLCAnTyddO1xuXG4vLyBVc2luZyBPYmplY3Qua2V5cyBoZXJlLCBvciBlbHNlIHRoZSB2YW5pbGxhIGZvci1pbiBsb29wIG1ha2VzIElFOCBnbyBpbnRvIGFuXG4vLyBpbmZpbml0ZSBsb29wLCBiZWNhdXNlIGl0IGl0ZXJhdGVzIG92ZXIgdGhlIG5ld2x5IGFkZGVkIHByb3BzIHRvby5cbk9iamVjdC5rZXlzKGlzVW5pdGxlc3NOdW1iZXIpLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuICBwcmVmaXhlcy5mb3JFYWNoKGZ1bmN0aW9uKHByZWZpeCkge1xuICAgIGlzVW5pdGxlc3NOdW1iZXJbcHJlZml4S2V5KHByZWZpeCwgcHJvcCldID0gaXNVbml0bGVzc051bWJlcltwcm9wXTtcbiAgfSk7XG59KTtcblxuLyoqXG4gKiBNb3N0IHN0eWxlIHByb3BlcnRpZXMgY2FuIGJlIHVuc2V0IGJ5IGRvaW5nIC5zdHlsZVtwcm9wXSA9ICcnIGJ1dCBJRThcbiAqIGRvZXNuJ3QgbGlrZSBkb2luZyB0aGF0IHdpdGggc2hvcnRoYW5kIHByb3BlcnRpZXMgc28gZm9yIHRoZSBwcm9wZXJ0aWVzIHRoYXRcbiAqIElFOCBicmVha3Mgb24sIHdoaWNoIGFyZSBsaXN0ZWQgaGVyZSwgd2UgaW5zdGVhZCB1bnNldCBlYWNoIG9mIHRoZVxuICogaW5kaXZpZHVhbCBwcm9wZXJ0aWVzLiBTZWUgaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzODUuXG4gKiBUaGUgNC12YWx1ZSAnY2xvY2snIHByb3BlcnRpZXMgbGlrZSBtYXJnaW4sIHBhZGRpbmcsIGJvcmRlci13aWR0aCBzZWVtIHRvXG4gKiBiZWhhdmUgd2l0aG91dCBhbnkgcHJvYmxlbXMuIEN1cmlvdXNseSwgbGlzdC1zdHlsZSB3b3JrcyB0b28gd2l0aG91dCBhbnlcbiAqIHNwZWNpYWwgcHJvZGRpbmcuXG4gKi9cbnZhciBzaG9ydGhhbmRQcm9wZXJ0eUV4cGFuc2lvbnMgPSB7XG4gIGJhY2tncm91bmQ6IHtcbiAgICBiYWNrZ3JvdW5kSW1hZ2U6IHRydWUsXG4gICAgYmFja2dyb3VuZFBvc2l0aW9uOiB0cnVlLFxuICAgIGJhY2tncm91bmRSZXBlYXQ6IHRydWUsXG4gICAgYmFja2dyb3VuZENvbG9yOiB0cnVlXG4gIH0sXG4gIGJvcmRlcjoge1xuICAgIGJvcmRlcldpZHRoOiB0cnVlLFxuICAgIGJvcmRlclN0eWxlOiB0cnVlLFxuICAgIGJvcmRlckNvbG9yOiB0cnVlXG4gIH0sXG4gIGJvcmRlckJvdHRvbToge1xuICAgIGJvcmRlckJvdHRvbVdpZHRoOiB0cnVlLFxuICAgIGJvcmRlckJvdHRvbVN0eWxlOiB0cnVlLFxuICAgIGJvcmRlckJvdHRvbUNvbG9yOiB0cnVlXG4gIH0sXG4gIGJvcmRlckxlZnQ6IHtcbiAgICBib3JkZXJMZWZ0V2lkdGg6IHRydWUsXG4gICAgYm9yZGVyTGVmdFN0eWxlOiB0cnVlLFxuICAgIGJvcmRlckxlZnRDb2xvcjogdHJ1ZVxuICB9LFxuICBib3JkZXJSaWdodDoge1xuICAgIGJvcmRlclJpZ2h0V2lkdGg6IHRydWUsXG4gICAgYm9yZGVyUmlnaHRTdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJSaWdodENvbG9yOiB0cnVlXG4gIH0sXG4gIGJvcmRlclRvcDoge1xuICAgIGJvcmRlclRvcFdpZHRoOiB0cnVlLFxuICAgIGJvcmRlclRvcFN0eWxlOiB0cnVlLFxuICAgIGJvcmRlclRvcENvbG9yOiB0cnVlXG4gIH0sXG4gIGZvbnQ6IHtcbiAgICBmb250U3R5bGU6IHRydWUsXG4gICAgZm9udFZhcmlhbnQ6IHRydWUsXG4gICAgZm9udFdlaWdodDogdHJ1ZSxcbiAgICBmb250U2l6ZTogdHJ1ZSxcbiAgICBsaW5lSGVpZ2h0OiB0cnVlLFxuICAgIGZvbnRGYW1pbHk6IHRydWVcbiAgfVxufTtcblxudmFyIENTU1Byb3BlcnR5ID0ge1xuICBpc1VuaXRsZXNzTnVtYmVyOiBpc1VuaXRsZXNzTnVtYmVyLFxuICBzaG9ydGhhbmRQcm9wZXJ0eUV4cGFuc2lvbnM6IHNob3J0aGFuZFByb3BlcnR5RXhwYW5zaW9uc1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDU1NQcm9wZXJ0eTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBDU1NQcm9wZXJ0eU9wZXJhdGlvbnNcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBDU1NQcm9wZXJ0eSA9IHJlcXVpcmUoXCIuL0NTU1Byb3BlcnR5XCIpO1xuXG52YXIgZGFuZ2Vyb3VzU3R5bGVWYWx1ZSA9IHJlcXVpcmUoXCIuL2Rhbmdlcm91c1N0eWxlVmFsdWVcIik7XG52YXIgaHlwaGVuYXRlU3R5bGVOYW1lID0gcmVxdWlyZShcIi4vaHlwaGVuYXRlU3R5bGVOYW1lXCIpO1xudmFyIG1lbW9pemVTdHJpbmdPbmx5ID0gcmVxdWlyZShcIi4vbWVtb2l6ZVN0cmluZ09ubHlcIik7XG5cbnZhciBwcm9jZXNzU3R5bGVOYW1lID0gbWVtb2l6ZVN0cmluZ09ubHkoZnVuY3Rpb24oc3R5bGVOYW1lKSB7XG4gIHJldHVybiBoeXBoZW5hdGVTdHlsZU5hbWUoc3R5bGVOYW1lKTtcbn0pO1xuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBDU1MgcHJvcGVydGllcy5cbiAqL1xudmFyIENTU1Byb3BlcnR5T3BlcmF0aW9ucyA9IHtcblxuICAvKipcbiAgICogU2VyaWFsaXplcyBhIG1hcHBpbmcgb2Ygc3R5bGUgcHJvcGVydGllcyBmb3IgdXNlIGFzIGlubGluZSBzdHlsZXM6XG4gICAqXG4gICAqICAgPiBjcmVhdGVNYXJrdXBGb3JTdHlsZXMoe3dpZHRoOiAnMjAwcHgnLCBoZWlnaHQ6IDB9KVxuICAgKiAgIFwid2lkdGg6MjAwcHg7aGVpZ2h0OjA7XCJcbiAgICpcbiAgICogVW5kZWZpbmVkIHZhbHVlcyBhcmUgaWdub3JlZCBzbyB0aGF0IGRlY2xhcmF0aXZlIHByb2dyYW1taW5nIGlzIGVhc2llci5cbiAgICogVGhlIHJlc3VsdCBzaG91bGQgYmUgSFRNTC1lc2NhcGVkIGJlZm9yZSBpbnNlcnRpb24gaW50byB0aGUgRE9NLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gc3R5bGVzXG4gICAqIEByZXR1cm4gez9zdHJpbmd9XG4gICAqL1xuICBjcmVhdGVNYXJrdXBGb3JTdHlsZXM6IGZ1bmN0aW9uKHN0eWxlcykge1xuICAgIHZhciBzZXJpYWxpemVkID0gJyc7XG4gICAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgICAgaWYgKCFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBzdHlsZVZhbHVlID0gc3R5bGVzW3N0eWxlTmFtZV07XG4gICAgICBpZiAoc3R5bGVWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHNlcmlhbGl6ZWQgKz0gcHJvY2Vzc1N0eWxlTmFtZShzdHlsZU5hbWUpICsgJzonO1xuICAgICAgICBzZXJpYWxpemVkICs9IGRhbmdlcm91c1N0eWxlVmFsdWUoc3R5bGVOYW1lLCBzdHlsZVZhbHVlKSArICc7JztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQgfHwgbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyB0aGUgdmFsdWUgZm9yIG11bHRpcGxlIHN0eWxlcyBvbiBhIG5vZGUuICBJZiBhIHZhbHVlIGlzIHNwZWNpZmllZCBhc1xuICAgKiAnJyAoZW1wdHkgc3RyaW5nKSwgdGhlIGNvcnJlc3BvbmRpbmcgc3R5bGUgcHJvcGVydHkgd2lsbCBiZSB1bnNldC5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzdHlsZXNcbiAgICovXG4gIHNldFZhbHVlRm9yU3R5bGVzOiBmdW5jdGlvbihub2RlLCBzdHlsZXMpIHtcbiAgICB2YXIgc3R5bGUgPSBub2RlLnN0eWxlO1xuICAgIGZvciAodmFyIHN0eWxlTmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgc3R5bGVWYWx1ZSA9IGRhbmdlcm91c1N0eWxlVmFsdWUoc3R5bGVOYW1lLCBzdHlsZXNbc3R5bGVOYW1lXSk7XG4gICAgICBpZiAoc3R5bGVWYWx1ZSkge1xuICAgICAgICBzdHlsZVtzdHlsZU5hbWVdID0gc3R5bGVWYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBleHBhbnNpb24gPSBDU1NQcm9wZXJ0eS5zaG9ydGhhbmRQcm9wZXJ0eUV4cGFuc2lvbnNbc3R5bGVOYW1lXTtcbiAgICAgICAgaWYgKGV4cGFuc2lvbikge1xuICAgICAgICAgIC8vIFNob3J0aGFuZCBwcm9wZXJ0eSB0aGF0IElFOCB3b24ndCBsaWtlIHVuc2V0dGluZywgc28gdW5zZXQgZWFjaFxuICAgICAgICAgIC8vIGNvbXBvbmVudCB0byBwbGFjYXRlIGl0XG4gICAgICAgICAgZm9yICh2YXIgaW5kaXZpZHVhbFN0eWxlTmFtZSBpbiBleHBhbnNpb24pIHtcbiAgICAgICAgICAgIHN0eWxlW2luZGl2aWR1YWxTdHlsZU5hbWVdID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0eWxlW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENTU1Byb3BlcnR5T3BlcmF0aW9ucztcbiIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQ2FsbGJhY2tRdWV1ZVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKFwiLi9Qb29sZWRDbGFzc1wiKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcbnZhciBtaXhJbnRvID0gcmVxdWlyZShcIi4vbWl4SW50b1wiKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHBzZXVkby1ldmVudCBtb2R1bGUgdG8gaGVscCBrZWVwIHRyYWNrIG9mIGNvbXBvbmVudHMgd2FpdGluZyB0b1xuICogYmUgbm90aWZpZWQgd2hlbiB0aGVpciBET00gcmVwcmVzZW50YXRpb25zIGFyZSBhdmFpbGFibGUgZm9yIHVzZS5cbiAqXG4gKiBUaGlzIGltcGxlbWVudHMgYFBvb2xlZENsYXNzYCwgc28geW91IHNob3VsZCBuZXZlciBuZWVkIHRvIGluc3RhbnRpYXRlIHRoaXMuXG4gKiBJbnN0ZWFkLCB1c2UgYENhbGxiYWNrUXVldWUuZ2V0UG9vbGVkKClgLlxuICpcbiAqIEBjbGFzcyBSZWFjdE1vdW50UmVhZHlcbiAqIEBpbXBsZW1lbnRzIFBvb2xlZENsYXNzXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gQ2FsbGJhY2tRdWV1ZSgpIHtcbiAgdGhpcy5fY2FsbGJhY2tzID0gbnVsbDtcbiAgdGhpcy5fY29udGV4dHMgPSBudWxsO1xufVxuXG5taXhJbnRvKENhbGxiYWNrUXVldWUsIHtcblxuICAvKipcbiAgICogRW5xdWV1ZXMgYSBjYWxsYmFjayB0byBiZSBpbnZva2VkIHdoZW4gYG5vdGlmeUFsbGAgaXMgaW52b2tlZC5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgSW52b2tlZCB3aGVuIGBub3RpZnlBbGxgIGlzIGludm9rZWQuXG4gICAqIEBwYXJhbSB7P29iamVjdH0gY29udGV4dCBDb250ZXh0IHRvIGNhbGwgYGNhbGxiYWNrYCB3aXRoLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWU6IGZ1bmN0aW9uKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IFtdO1xuICAgIHRoaXMuX2NvbnRleHRzID0gdGhpcy5fY29udGV4dHMgfHwgW107XG4gICAgdGhpcy5fY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIHRoaXMuX2NvbnRleHRzLnB1c2goY29udGV4dCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludm9rZXMgYWxsIGVucXVldWVkIGNhbGxiYWNrcyBhbmQgY2xlYXJzIHRoZSBxdWV1ZS4gVGhpcyBpcyBpbnZva2VkIGFmdGVyXG4gICAqIHRoZSBET00gcmVwcmVzZW50YXRpb24gb2YgYSBjb21wb25lbnQgaGFzIGJlZW4gY3JlYXRlZCBvciB1cGRhdGVkLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG5vdGlmeUFsbDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcztcbiAgICB2YXIgY29udGV4dHMgPSB0aGlzLl9jb250ZXh0cztcbiAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgICBjYWxsYmFja3MubGVuZ3RoID09PSBjb250ZXh0cy5sZW5ndGgsXG4gICAgICAgIFwiTWlzbWF0Y2hlZCBsaXN0IG9mIGNvbnRleHRzIGluIGNhbGxiYWNrIHF1ZXVlXCJcbiAgICAgICkgOiBpbnZhcmlhbnQoY2FsbGJhY2tzLmxlbmd0aCA9PT0gY29udGV4dHMubGVuZ3RoKSk7XG4gICAgICB0aGlzLl9jYWxsYmFja3MgPSBudWxsO1xuICAgICAgdGhpcy5fY29udGV4dHMgPSBudWxsO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGNhbGxiYWNrc1tpXS5jYWxsKGNvbnRleHRzW2ldKTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgICAgY29udGV4dHMubGVuZ3RoID0gMDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGUgaW50ZXJuYWwgcXVldWUuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IG51bGw7XG4gICAgdGhpcy5fY29udGV4dHMgPSBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciB0aGlzLlxuICAgKi9cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZXNldCgpO1xuICB9XG5cbn0pO1xuXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oQ2FsbGJhY2tRdWV1ZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FsbGJhY2tRdWV1ZTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIENoYW5nZUV2ZW50UGx1Z2luXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoXCIuL0V2ZW50Q29uc3RhbnRzXCIpO1xudmFyIEV2ZW50UGx1Z2luSHViID0gcmVxdWlyZShcIi4vRXZlbnRQbHVnaW5IdWJcIik7XG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHJlcXVpcmUoXCIuL0V2ZW50UHJvcGFnYXRvcnNcIik7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKFwiLi9FeGVjdXRpb25FbnZpcm9ubWVudFwiKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKFwiLi9SZWFjdFVwZGF0ZXNcIik7XG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKFwiLi9TeW50aGV0aWNFdmVudFwiKTtcblxudmFyIGlzRXZlbnRTdXBwb3J0ZWQgPSByZXF1aXJlKFwiLi9pc0V2ZW50U3VwcG9ydGVkXCIpO1xudmFyIGlzVGV4dElucHV0RWxlbWVudCA9IHJlcXVpcmUoXCIuL2lzVGV4dElucHV0RWxlbWVudFwiKTtcbnZhciBrZXlPZiA9IHJlcXVpcmUoXCIuL2tleU9mXCIpO1xuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG5cbnZhciBldmVudFR5cGVzID0ge1xuICBjaGFuZ2U6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2Yoe29uQ2hhbmdlOiBudWxsfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2Yoe29uQ2hhbmdlQ2FwdHVyZTogbnVsbH0pXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFtcbiAgICAgIHRvcExldmVsVHlwZXMudG9wQmx1cixcbiAgICAgIHRvcExldmVsVHlwZXMudG9wQ2hhbmdlLFxuICAgICAgdG9wTGV2ZWxUeXBlcy50b3BDbGljayxcbiAgICAgIHRvcExldmVsVHlwZXMudG9wRm9jdXMsXG4gICAgICB0b3BMZXZlbFR5cGVzLnRvcElucHV0LFxuICAgICAgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duLFxuICAgICAgdG9wTGV2ZWxUeXBlcy50b3BLZXlVcCxcbiAgICAgIHRvcExldmVsVHlwZXMudG9wU2VsZWN0aW9uQ2hhbmdlXG4gICAgXVxuICB9XG59O1xuXG4vKipcbiAqIEZvciBJRSBzaGltc1xuICovXG52YXIgYWN0aXZlRWxlbWVudCA9IG51bGw7XG52YXIgYWN0aXZlRWxlbWVudElEID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50VmFsdWUgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRWYWx1ZVByb3AgPSBudWxsO1xuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgY2hhbmdlYCBldmVudFxuICovXG5mdW5jdGlvbiBzaG91bGRVc2VDaGFuZ2VFdmVudChlbGVtKSB7XG4gIHJldHVybiAoXG4gICAgZWxlbS5ub2RlTmFtZSA9PT0gJ1NFTEVDVCcgfHxcbiAgICAoZWxlbS5ub2RlTmFtZSA9PT0gJ0lOUFVUJyAmJiBlbGVtLnR5cGUgPT09ICdmaWxlJylcbiAgKTtcbn1cblxudmFyIGRvZXNDaGFuZ2VFdmVudEJ1YmJsZSA9IGZhbHNlO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICAvLyBTZWUgYGhhbmRsZUNoYW5nZWAgY29tbWVudCBiZWxvd1xuICBkb2VzQ2hhbmdlRXZlbnRCdWJibGUgPSBpc0V2ZW50U3VwcG9ydGVkKCdjaGFuZ2UnKSAmJiAoXG4gICAgISgnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCkgfHwgZG9jdW1lbnQuZG9jdW1lbnRNb2RlID4gOFxuICApO1xufVxuXG5mdW5jdGlvbiBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBldmVudCA9IFN5bnRoZXRpY0V2ZW50LmdldFBvb2xlZChcbiAgICBldmVudFR5cGVzLmNoYW5nZSxcbiAgICBhY3RpdmVFbGVtZW50SUQsXG4gICAgbmF0aXZlRXZlbnRcbiAgKTtcbiAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcblxuICAvLyBJZiBjaGFuZ2UgYW5kIHByb3BlcnR5Y2hhbmdlIGJ1YmJsZWQsIHdlJ2QganVzdCBiaW5kIHRvIGl0IGxpa2UgYWxsIHRoZVxuICAvLyBvdGhlciBldmVudHMgYW5kIGhhdmUgaXQgZ28gdGhyb3VnaCBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuIFNpbmNlIGl0XG4gIC8vIGRvZXNuJ3QsIHdlIG1hbnVhbGx5IGxpc3RlbiBmb3IgdGhlIGV2ZW50cyBhbmQgc28gd2UgaGF2ZSB0byBlbnF1ZXVlIGFuZFxuICAvLyBwcm9jZXNzIHRoZSBhYnN0cmFjdCBldmVudCBtYW51YWxseS5cbiAgLy9cbiAgLy8gQmF0Y2hpbmcgaXMgbmVjZXNzYXJ5IGhlcmUgaW4gb3JkZXIgdG8gZW5zdXJlIHRoYXQgYWxsIGV2ZW50IGhhbmRsZXJzIHJ1blxuICAvLyBiZWZvcmUgdGhlIG5leHQgcmVyZW5kZXIgKGluY2x1ZGluZyBldmVudCBoYW5kbGVycyBhdHRhY2hlZCB0byBhbmNlc3RvclxuICAvLyBlbGVtZW50cyBpbnN0ZWFkIG9mIGRpcmVjdGx5IG9uIHRoZSBpbnB1dCkuIFdpdGhvdXQgdGhpcywgY29udHJvbGxlZFxuICAvLyBjb21wb25lbnRzIGRvbid0IHdvcmsgcHJvcGVybHkgaW4gY29uanVuY3Rpb24gd2l0aCBldmVudCBidWJibGluZyBiZWNhdXNlXG4gIC8vIHRoZSBjb21wb25lbnQgaXMgcmVyZW5kZXJlZCBhbmQgdGhlIHZhbHVlIHJldmVydGVkIGJlZm9yZSBhbGwgdGhlIGV2ZW50XG4gIC8vIGhhbmRsZXJzIGNhbiBydW4uIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcwOC5cbiAgUmVhY3RVcGRhdGVzLmJhdGNoZWRVcGRhdGVzKHJ1bkV2ZW50SW5CYXRjaCwgZXZlbnQpO1xufVxuXG5mdW5jdGlvbiBydW5FdmVudEluQmF0Y2goZXZlbnQpIHtcbiAgRXZlbnRQbHVnaW5IdWIuZW5xdWV1ZUV2ZW50cyhldmVudCk7XG4gIEV2ZW50UGx1Z2luSHViLnByb2Nlc3NFdmVudFF1ZXVlKCk7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0V2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCh0YXJnZXQsIHRhcmdldElEKSB7XG4gIGFjdGl2ZUVsZW1lbnQgPSB0YXJnZXQ7XG4gIGFjdGl2ZUVsZW1lbnRJRCA9IHRhcmdldElEO1xuICBhY3RpdmVFbGVtZW50LmF0dGFjaEV2ZW50KCdvbmNoYW5nZScsIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQpO1xufVxuXG5mdW5jdGlvbiBzdG9wV2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCgpIHtcbiAgaWYgKCFhY3RpdmVFbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFjdGl2ZUVsZW1lbnQuZGV0YWNoRXZlbnQoJ29uY2hhbmdlJywgbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudCk7XG4gIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICBhY3RpdmVFbGVtZW50SUQgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJREZvckNoYW5nZUV2ZW50KFxuICAgIHRvcExldmVsVHlwZSxcbiAgICB0b3BMZXZlbFRhcmdldCxcbiAgICB0b3BMZXZlbFRhcmdldElEKSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wQ2hhbmdlKSB7XG4gICAgcmV0dXJuIHRvcExldmVsVGFyZ2V0SUQ7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50c0ZvckNoYW5nZUV2ZW50SUU4KFxuICAgIHRvcExldmVsVHlwZSxcbiAgICB0b3BMZXZlbFRhcmdldCxcbiAgICB0b3BMZXZlbFRhcmdldElEKSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wRm9jdXMpIHtcbiAgICAvLyBzdG9wV2F0Y2hpbmcoKSBzaG91bGQgYmUgYSBub29wIGhlcmUgYnV0IHdlIGNhbGwgaXQganVzdCBpbiBjYXNlIHdlXG4gICAgLy8gbWlzc2VkIGEgYmx1ciBldmVudCBzb21laG93LlxuICAgIHN0b3BXYXRjaGluZ0ZvckNoYW5nZUV2ZW50SUU4KCk7XG4gICAgc3RhcnRXYXRjaGluZ0ZvckNoYW5nZUV2ZW50SUU4KHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElEKTtcbiAgfSBlbHNlIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wQmx1cikge1xuICAgIHN0b3BXYXRjaGluZ0ZvckNoYW5nZUV2ZW50SUU4KCk7XG4gIH1cbn1cblxuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgaW5wdXRgIGV2ZW50XG4gKi9cbnZhciBpc0lucHV0RXZlbnRTdXBwb3J0ZWQgPSBmYWxzZTtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgLy8gSUU5IGNsYWltcyB0byBzdXBwb3J0IHRoZSBpbnB1dCBldmVudCBidXQgZmFpbHMgdG8gdHJpZ2dlciBpdCB3aGVuXG4gIC8vIGRlbGV0aW5nIHRleHQsIHNvIHdlIGlnbm9yZSBpdHMgaW5wdXQgZXZlbnRzXG4gIGlzSW5wdXRFdmVudFN1cHBvcnRlZCA9IGlzRXZlbnRTdXBwb3J0ZWQoJ2lucHV0JykgJiYgKFxuICAgICEoJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQpIHx8IGRvY3VtZW50LmRvY3VtZW50TW9kZSA+IDlcbiAgKTtcbn1cblxuLyoqXG4gKiAoRm9yIG9sZCBJRS4pIFJlcGxhY2VtZW50IGdldHRlci9zZXR0ZXIgZm9yIHRoZSBgdmFsdWVgIHByb3BlcnR5IHRoYXQgZ2V0c1xuICogc2V0IG9uIHRoZSBhY3RpdmUgZWxlbWVudC5cbiAqL1xudmFyIG5ld1ZhbHVlUHJvcCA9ICB7XG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGFjdGl2ZUVsZW1lbnRWYWx1ZVByb3AuZ2V0LmNhbGwodGhpcyk7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24odmFsKSB7XG4gICAgLy8gQ2FzdCB0byBhIHN0cmluZyBzbyB3ZSBjYW4gZG8gZXF1YWxpdHkgY2hlY2tzLlxuICAgIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9ICcnICsgdmFsO1xuICAgIGFjdGl2ZUVsZW1lbnRWYWx1ZVByb3Auc2V0LmNhbGwodGhpcywgdmFsKTtcbiAgfVxufTtcblxuLyoqXG4gKiAoRm9yIG9sZCBJRS4pIFN0YXJ0cyB0cmFja2luZyBwcm9wZXJ0eWNoYW5nZSBldmVudHMgb24gdGhlIHBhc3NlZC1pbiBlbGVtZW50XG4gKiBhbmQgb3ZlcnJpZGUgdGhlIHZhbHVlIHByb3BlcnR5IHNvIHRoYXQgd2UgY2FuIGRpc3Rpbmd1aXNoIHVzZXIgZXZlbnRzIGZyb21cbiAqIHZhbHVlIGNoYW5nZXMgaW4gSlMuXG4gKi9cbmZ1bmN0aW9uIHN0YXJ0V2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSh0YXJnZXQsIHRhcmdldElEKSB7XG4gIGFjdGl2ZUVsZW1lbnQgPSB0YXJnZXQ7XG4gIGFjdGl2ZUVsZW1lbnRJRCA9IHRhcmdldElEO1xuICBhY3RpdmVFbGVtZW50VmFsdWUgPSB0YXJnZXQudmFsdWU7XG4gIGFjdGl2ZUVsZW1lbnRWYWx1ZVByb3AgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFxuICAgIHRhcmdldC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsXG4gICAgJ3ZhbHVlJ1xuICApO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhY3RpdmVFbGVtZW50LCAndmFsdWUnLCBuZXdWYWx1ZVByb3ApO1xuICBhY3RpdmVFbGVtZW50LmF0dGFjaEV2ZW50KCdvbnByb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UpO1xufVxuXG4vKipcbiAqIChGb3Igb2xkIElFLikgUmVtb3ZlcyB0aGUgZXZlbnQgbGlzdGVuZXJzIGZyb20gdGhlIGN1cnJlbnRseS10cmFja2VkIGVsZW1lbnQsXG4gKiBpZiBhbnkgZXhpc3RzLlxuICovXG5mdW5jdGlvbiBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpIHtcbiAgaWYgKCFhY3RpdmVFbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gZGVsZXRlIHJlc3RvcmVzIHRoZSBvcmlnaW5hbCBwcm9wZXJ0eSBkZWZpbml0aW9uXG4gIGRlbGV0ZSBhY3RpdmVFbGVtZW50LnZhbHVlO1xuICBhY3RpdmVFbGVtZW50LmRldGFjaEV2ZW50KCdvbnByb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UpO1xuXG4gIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICBhY3RpdmVFbGVtZW50SUQgPSBudWxsO1xuICBhY3RpdmVFbGVtZW50VmFsdWUgPSBudWxsO1xuICBhY3RpdmVFbGVtZW50VmFsdWVQcm9wID0gbnVsbDtcbn1cblxuLyoqXG4gKiAoRm9yIG9sZCBJRS4pIEhhbmRsZXMgYSBwcm9wZXJ0eWNoYW5nZSBldmVudCwgc2VuZGluZyBhIGBjaGFuZ2VgIGV2ZW50IGlmXG4gKiB0aGUgdmFsdWUgb2YgdGhlIGFjdGl2ZSBlbGVtZW50IGhhcyBjaGFuZ2VkLlxuICovXG5mdW5jdGlvbiBoYW5kbGVQcm9wZXJ0eUNoYW5nZShuYXRpdmVFdmVudCkge1xuICBpZiAobmF0aXZlRXZlbnQucHJvcGVydHlOYW1lICE9PSAndmFsdWUnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciB2YWx1ZSA9IG5hdGl2ZUV2ZW50LnNyY0VsZW1lbnQudmFsdWU7XG4gIGlmICh2YWx1ZSA9PT0gYWN0aXZlRWxlbWVudFZhbHVlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9IHZhbHVlO1xuXG4gIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQobmF0aXZlRXZlbnQpO1xufVxuXG4vKipcbiAqIElmIGEgYGNoYW5nZWAgZXZlbnQgc2hvdWxkIGJlIGZpcmVkLCByZXR1cm5zIHRoZSB0YXJnZXQncyBJRC5cbiAqL1xuZnVuY3Rpb24gZ2V0VGFyZ2V0SURGb3JJbnB1dEV2ZW50KFxuICAgIHRvcExldmVsVHlwZSxcbiAgICB0b3BMZXZlbFRhcmdldCxcbiAgICB0b3BMZXZlbFRhcmdldElEKSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wSW5wdXQpIHtcbiAgICAvLyBJbiBtb2Rlcm4gYnJvd3NlcnMgKGkuZS4sIG5vdCBJRTggb3IgSUU5KSwgdGhlIGlucHV0IGV2ZW50IGlzIGV4YWN0bHlcbiAgICAvLyB3aGF0IHdlIHdhbnQgc28gZmFsbCB0aHJvdWdoIGhlcmUgYW5kIHRyaWdnZXIgYW4gYWJzdHJhY3QgZXZlbnRcbiAgICByZXR1cm4gdG9wTGV2ZWxUYXJnZXRJRDtcbiAgfVxufVxuXG4vLyBGb3IgSUU4IGFuZCBJRTkuXG5mdW5jdGlvbiBoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50SUUoXG4gICAgdG9wTGV2ZWxUeXBlLFxuICAgIHRvcExldmVsVGFyZ2V0LFxuICAgIHRvcExldmVsVGFyZ2V0SUQpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BGb2N1cykge1xuICAgIC8vIEluIElFOCwgd2UgY2FuIGNhcHR1cmUgYWxtb3N0IGFsbCAudmFsdWUgY2hhbmdlcyBieSBhZGRpbmcgYVxuICAgIC8vIHByb3BlcnR5Y2hhbmdlIGhhbmRsZXIgYW5kIGxvb2tpbmcgZm9yIGV2ZW50cyB3aXRoIHByb3BlcnR5TmFtZVxuICAgIC8vIGVxdWFsIHRvICd2YWx1ZSdcbiAgICAvLyBJbiBJRTksIHByb3BlcnR5Y2hhbmdlIGZpcmVzIGZvciBtb3N0IGlucHV0IGV2ZW50cyBidXQgaXMgYnVnZ3kgYW5kXG4gICAgLy8gZG9lc24ndCBmaXJlIHdoZW4gdGV4dCBpcyBkZWxldGVkLCBidXQgY29udmVuaWVudGx5LCBzZWxlY3Rpb25jaGFuZ2VcbiAgICAvLyBhcHBlYXJzIHRvIGZpcmUgaW4gYWxsIG9mIHRoZSByZW1haW5pbmcgY2FzZXMgc28gd2UgY2F0Y2ggdGhvc2UgYW5kXG4gICAgLy8gZm9yd2FyZCB0aGUgZXZlbnQgaWYgdGhlIHZhbHVlIGhhcyBjaGFuZ2VkXG4gICAgLy8gSW4gZWl0aGVyIGNhc2UsIHdlIGRvbid0IHdhbnQgdG8gY2FsbCB0aGUgZXZlbnQgaGFuZGxlciBpZiB0aGUgdmFsdWVcbiAgICAvLyBpcyBjaGFuZ2VkIGZyb20gSlMgc28gd2UgcmVkZWZpbmUgYSBzZXR0ZXIgZm9yIGAudmFsdWVgIHRoYXQgdXBkYXRlc1xuICAgIC8vIG91ciBhY3RpdmVFbGVtZW50VmFsdWUgdmFyaWFibGUsIGFsbG93aW5nIHVzIHRvIGlnbm9yZSB0aG9zZSBjaGFuZ2VzXG4gICAgLy9cbiAgICAvLyBzdG9wV2F0Y2hpbmcoKSBzaG91bGQgYmUgYSBub29wIGhlcmUgYnV0IHdlIGNhbGwgaXQganVzdCBpbiBjYXNlIHdlXG4gICAgLy8gbWlzc2VkIGEgYmx1ciBldmVudCBzb21laG93LlxuICAgIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCk7XG4gICAgc3RhcnRXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElEKTtcbiAgfSBlbHNlIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wQmx1cikge1xuICAgIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCk7XG4gIH1cbn1cblxuLy8gRm9yIElFOCBhbmQgSUU5LlxuZnVuY3Rpb24gZ2V0VGFyZ2V0SURGb3JJbnB1dEV2ZW50SUUoXG4gICAgdG9wTGV2ZWxUeXBlLFxuICAgIHRvcExldmVsVGFyZ2V0LFxuICAgIHRvcExldmVsVGFyZ2V0SUQpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BTZWxlY3Rpb25DaGFuZ2UgfHxcbiAgICAgIHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BLZXlVcCB8fFxuICAgICAgdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcEtleURvd24pIHtcbiAgICAvLyBPbiB0aGUgc2VsZWN0aW9uY2hhbmdlIGV2ZW50LCB0aGUgdGFyZ2V0IGlzIGp1c3QgZG9jdW1lbnQgd2hpY2ggaXNuJ3RcbiAgICAvLyBoZWxwZnVsIGZvciB1cyBzbyBqdXN0IGNoZWNrIGFjdGl2ZUVsZW1lbnQgaW5zdGVhZC5cbiAgICAvL1xuICAgIC8vIDk5JSBvZiB0aGUgdGltZSwga2V5ZG93biBhbmQga2V5dXAgYXJlbid0IG5lY2Vzc2FyeS4gSUU4IGZhaWxzIHRvIGZpcmVcbiAgICAvLyBwcm9wZXJ0eWNoYW5nZSBvbiB0aGUgZmlyc3QgaW5wdXQgZXZlbnQgYWZ0ZXIgc2V0dGluZyBgdmFsdWVgIGZyb20gYVxuICAgIC8vIHNjcmlwdCBhbmQgZmlyZXMgb25seSBrZXlkb3duLCBrZXlwcmVzcywga2V5dXAuIENhdGNoaW5nIGtleXVwIHVzdWFsbHlcbiAgICAvLyBnZXRzIGl0IGFuZCBjYXRjaGluZyBrZXlkb3duIGxldHMgdXMgZmlyZSBhbiBldmVudCBmb3IgdGhlIGZpcnN0XG4gICAgLy8ga2V5c3Ryb2tlIGlmIHVzZXIgZG9lcyBhIGtleSByZXBlYXQgKGl0J2xsIGJlIGEgbGl0dGxlIGRlbGF5ZWQ6IHJpZ2h0XG4gICAgLy8gYmVmb3JlIHRoZSBzZWNvbmQga2V5c3Ryb2tlKS4gT3RoZXIgaW5wdXQgbWV0aG9kcyAoZS5nLiwgcGFzdGUpIHNlZW0gdG9cbiAgICAvLyBmaXJlIHNlbGVjdGlvbmNoYW5nZSBub3JtYWxseS5cbiAgICBpZiAoYWN0aXZlRWxlbWVudCAmJiBhY3RpdmVFbGVtZW50LnZhbHVlICE9PSBhY3RpdmVFbGVtZW50VmFsdWUpIHtcbiAgICAgIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9IGFjdGl2ZUVsZW1lbnQudmFsdWU7XG4gICAgICByZXR1cm4gYWN0aXZlRWxlbWVudElEO1xuICAgIH1cbiAgfVxufVxuXG5cbi8qKlxuICogU0VDVElPTjogaGFuZGxlIGBjbGlja2AgZXZlbnRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkVXNlQ2xpY2tFdmVudChlbGVtKSB7XG4gIC8vIFVzZSB0aGUgYGNsaWNrYCBldmVudCB0byBkZXRlY3QgY2hhbmdlcyB0byBjaGVja2JveCBhbmQgcmFkaW8gaW5wdXRzLlxuICAvLyBUaGlzIGFwcHJvYWNoIHdvcmtzIGFjcm9zcyBhbGwgYnJvd3NlcnMsIHdoZXJlYXMgYGNoYW5nZWAgZG9lcyBub3QgZmlyZVxuICAvLyB1bnRpbCBgYmx1cmAgaW4gSUU4LlxuICByZXR1cm4gKFxuICAgIGVsZW0ubm9kZU5hbWUgPT09ICdJTlBVVCcgJiZcbiAgICAoZWxlbS50eXBlID09PSAnY2hlY2tib3gnIHx8IGVsZW0udHlwZSA9PT0gJ3JhZGlvJylcbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0SURGb3JDbGlja0V2ZW50KFxuICAgIHRvcExldmVsVHlwZSxcbiAgICB0b3BMZXZlbFRhcmdldCxcbiAgICB0b3BMZXZlbFRhcmdldElEKSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wQ2xpY2spIHtcbiAgICByZXR1cm4gdG9wTGV2ZWxUYXJnZXRJRDtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uQ2hhbmdlYCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgY2hhbmdlIGV2ZW50c1xuICogYWNyb3NzIGZvcm0gZWxlbWVudHMuIFRoaXMgZXZlbnQgZmlyZXMgYXQgYSB0aW1lIHdoZW4gaXQncyBwb3NzaWJsZSB0b1xuICogY2hhbmdlIHRoZSBlbGVtZW50J3MgdmFsdWUgd2l0aG91dCBzZWVpbmcgYSBmbGlja2VyLlxuICpcbiAqIFN1cHBvcnRlZCBlbGVtZW50cyBhcmU6XG4gKiAtIGlucHV0IChzZWUgYGlzVGV4dElucHV0RWxlbWVudGApXG4gKiAtIHRleHRhcmVhXG4gKiAtIHNlbGVjdFxuICovXG52YXIgQ2hhbmdlRXZlbnRQbHVnaW4gPSB7XG5cbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0b3BMZXZlbFRhcmdldCBUaGUgbGlzdGVuaW5nIGNvbXBvbmVudCByb290IG5vZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFRhcmdldElEIElEIG9mIGB0b3BMZXZlbFRhcmdldGAuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAgICogQHJldHVybiB7Kn0gQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gICAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmV4dHJhY3RFdmVudHN9XG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbihcbiAgICAgIHRvcExldmVsVHlwZSxcbiAgICAgIHRvcExldmVsVGFyZ2V0LFxuICAgICAgdG9wTGV2ZWxUYXJnZXRJRCxcbiAgICAgIG5hdGl2ZUV2ZW50KSB7XG5cbiAgICB2YXIgZ2V0VGFyZ2V0SURGdW5jLCBoYW5kbGVFdmVudEZ1bmM7XG4gICAgaWYgKHNob3VsZFVzZUNoYW5nZUV2ZW50KHRvcExldmVsVGFyZ2V0KSkge1xuICAgICAgaWYgKGRvZXNDaGFuZ2VFdmVudEJ1YmJsZSkge1xuICAgICAgICBnZXRUYXJnZXRJREZ1bmMgPSBnZXRUYXJnZXRJREZvckNoYW5nZUV2ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFuZGxlRXZlbnRGdW5jID0gaGFuZGxlRXZlbnRzRm9yQ2hhbmdlRXZlbnRJRTg7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1RleHRJbnB1dEVsZW1lbnQodG9wTGV2ZWxUYXJnZXQpKSB7XG4gICAgICBpZiAoaXNJbnB1dEV2ZW50U3VwcG9ydGVkKSB7XG4gICAgICAgIGdldFRhcmdldElERnVuYyA9IGdldFRhcmdldElERm9ySW5wdXRFdmVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdldFRhcmdldElERnVuYyA9IGdldFRhcmdldElERm9ySW5wdXRFdmVudElFO1xuICAgICAgICBoYW5kbGVFdmVudEZ1bmMgPSBoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50SUU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzaG91bGRVc2VDbGlja0V2ZW50KHRvcExldmVsVGFyZ2V0KSkge1xuICAgICAgZ2V0VGFyZ2V0SURGdW5jID0gZ2V0VGFyZ2V0SURGb3JDbGlja0V2ZW50O1xuICAgIH1cblxuICAgIGlmIChnZXRUYXJnZXRJREZ1bmMpIHtcbiAgICAgIHZhciB0YXJnZXRJRCA9IGdldFRhcmdldElERnVuYyhcbiAgICAgICAgdG9wTGV2ZWxUeXBlLFxuICAgICAgICB0b3BMZXZlbFRhcmdldCxcbiAgICAgICAgdG9wTGV2ZWxUYXJnZXRJRFxuICAgICAgKTtcbiAgICAgIGlmICh0YXJnZXRJRCkge1xuICAgICAgICB2YXIgZXZlbnQgPSBTeW50aGV0aWNFdmVudC5nZXRQb29sZWQoXG4gICAgICAgICAgZXZlbnRUeXBlcy5jaGFuZ2UsXG4gICAgICAgICAgdGFyZ2V0SUQsXG4gICAgICAgICAgbmF0aXZlRXZlbnRcbiAgICAgICAgKTtcbiAgICAgICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYW5kbGVFdmVudEZ1bmMpIHtcbiAgICAgIGhhbmRsZUV2ZW50RnVuYyhcbiAgICAgICAgdG9wTGV2ZWxUeXBlLFxuICAgICAgICB0b3BMZXZlbFRhcmdldCxcbiAgICAgICAgdG9wTGV2ZWxUYXJnZXRJRFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDaGFuZ2VFdmVudFBsdWdpbjtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBDbGllbnRSZWFjdFJvb3RJbmRleFxuICogQHR5cGVjaGVja3NcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIG5leHRSZWFjdFJvb3RJbmRleCA9IDA7XG5cbnZhciBDbGllbnRSZWFjdFJvb3RJbmRleCA9IHtcbiAgY3JlYXRlUmVhY3RSb290SW5kZXg6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXh0UmVhY3RSb290SW5kZXgrKztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDbGllbnRSZWFjdFJvb3RJbmRleDtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBDb21wb3NpdGlvbkV2ZW50UGx1Z2luXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKFwiLi9FdmVudENvbnN0YW50c1wiKTtcbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZShcIi4vRXZlbnRQcm9wYWdhdG9yc1wiKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoXCIuL0V4ZWN1dGlvbkVudmlyb25tZW50XCIpO1xudmFyIFJlYWN0SW5wdXRTZWxlY3Rpb24gPSByZXF1aXJlKFwiLi9SZWFjdElucHV0U2VsZWN0aW9uXCIpO1xudmFyIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQgPSByZXF1aXJlKFwiLi9TeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50XCIpO1xuXG52YXIgZ2V0VGV4dENvbnRlbnRBY2Nlc3NvciA9IHJlcXVpcmUoXCIuL2dldFRleHRDb250ZW50QWNjZXNzb3JcIik7XG52YXIga2V5T2YgPSByZXF1aXJlKFwiLi9rZXlPZlwiKTtcblxudmFyIEVORF9LRVlDT0RFUyA9IFs5LCAxMywgMjcsIDMyXTsgLy8gVGFiLCBSZXR1cm4sIEVzYywgU3BhY2VcbnZhciBTVEFSVF9LRVlDT0RFID0gMjI5O1xuXG52YXIgdXNlQ29tcG9zaXRpb25FdmVudCA9IChcbiAgRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmXG4gICdDb21wb3NpdGlvbkV2ZW50JyBpbiB3aW5kb3dcbik7XG5cbi8vIEluIElFOSssIHdlIGhhdmUgYWNjZXNzIHRvIGNvbXBvc2l0aW9uIGV2ZW50cywgYnV0IHRoZSBkYXRhIHN1cHBsaWVkXG4vLyBieSB0aGUgbmF0aXZlIGNvbXBvc2l0aW9uZW5kIGV2ZW50IG1heSBiZSBpbmNvcnJlY3QuIEluIEtvcmVhbiwgZm9yIGV4YW1wbGUsXG4vLyB0aGUgY29tcG9zaXRpb25lbmQgZXZlbnQgY29udGFpbnMgb25seSBvbmUgY2hhcmFjdGVyIHJlZ2FyZGxlc3Mgb2Zcbi8vIGhvdyBtYW55IGNoYXJhY3RlcnMgaGF2ZSBiZWVuIGNvbXBvc2VkIHNpbmNlIGNvbXBvc2l0aW9uc3RhcnQuXG4vLyBXZSB0aGVyZWZvcmUgdXNlIHRoZSBmYWxsYmFjayBkYXRhIHdoaWxlIHN0aWxsIHVzaW5nIHRoZSBuYXRpdmVcbi8vIGV2ZW50cyBhcyB0cmlnZ2Vycy5cbnZhciB1c2VGYWxsYmFja0RhdGEgPSAoXG4gICF1c2VDb21wb3NpdGlvbkV2ZW50IHx8XG4gIChcbiAgICAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCAmJlxuICAgIGRvY3VtZW50LmRvY3VtZW50TW9kZSA+IDggJiZcbiAgICBkb2N1bWVudC5kb2N1bWVudE1vZGUgPD0gMTFcbiAgKVxuKTtcblxudmFyIHRvcExldmVsVHlwZXMgPSBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xudmFyIGN1cnJlbnRDb21wb3NpdGlvbiA9IG51bGw7XG5cbi8vIEV2ZW50cyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSBuYW1lcy5cbnZhciBldmVudFR5cGVzID0ge1xuICBjb21wb3NpdGlvbkVuZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7b25Db21wb3NpdGlvbkVuZDogbnVsbH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHtvbkNvbXBvc2l0aW9uRW5kQ2FwdHVyZTogbnVsbH0pXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFtcbiAgICAgIHRvcExldmVsVHlwZXMudG9wQmx1cixcbiAgICAgIHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25FbmQsXG4gICAgICB0b3BMZXZlbFR5cGVzLnRvcEtleURvd24sXG4gICAgICB0b3BMZXZlbFR5cGVzLnRvcEtleVByZXNzLFxuICAgICAgdG9wTGV2ZWxUeXBlcy50b3BLZXlVcCxcbiAgICAgIHRvcExldmVsVHlwZXMudG9wTW91c2VEb3duXG4gICAgXVxuICB9LFxuICBjb21wb3NpdGlvblN0YXJ0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHtvbkNvbXBvc2l0aW9uU3RhcnQ6IG51bGx9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7b25Db21wb3NpdGlvblN0YXJ0Q2FwdHVyZTogbnVsbH0pXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFtcbiAgICAgIHRvcExldmVsVHlwZXMudG9wQmx1cixcbiAgICAgIHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25TdGFydCxcbiAgICAgIHRvcExldmVsVHlwZXMudG9wS2V5RG93bixcbiAgICAgIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3MsXG4gICAgICB0b3BMZXZlbFR5cGVzLnRvcEtleVVwLFxuICAgICAgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd25cbiAgICBdXG4gIH0sXG4gIGNvbXBvc2l0aW9uVXBkYXRlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHtvbkNvbXBvc2l0aW9uVXBkYXRlOiBudWxsfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2Yoe29uQ29tcG9zaXRpb25VcGRhdGVDYXB0dXJlOiBudWxsfSlcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW1xuICAgICAgdG9wTGV2ZWxUeXBlcy50b3BCbHVyLFxuICAgICAgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvblVwZGF0ZSxcbiAgICAgIHRvcExldmVsVHlwZXMudG9wS2V5RG93bixcbiAgICAgIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3MsXG4gICAgICB0b3BMZXZlbFR5cGVzLnRvcEtleVVwLFxuICAgICAgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd25cbiAgICBdXG4gIH1cbn07XG5cbi8qKlxuICogVHJhbnNsYXRlIG5hdGl2ZSB0b3AgbGV2ZWwgZXZlbnRzIGludG8gZXZlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRDb21wb3NpdGlvbkV2ZW50VHlwZSh0b3BMZXZlbFR5cGUpIHtcbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25TdGFydDpcbiAgICAgIHJldHVybiBldmVudFR5cGVzLmNvbXBvc2l0aW9uU3RhcnQ7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uRW5kOlxuICAgICAgcmV0dXJuIGV2ZW50VHlwZXMuY29tcG9zaXRpb25FbmQ7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uVXBkYXRlOlxuICAgICAgcmV0dXJuIGV2ZW50VHlwZXMuY29tcG9zaXRpb25VcGRhdGU7XG4gIH1cbn1cblxuLyoqXG4gKiBEb2VzIG91ciBmYWxsYmFjayBiZXN0LWd1ZXNzIG1vZGVsIHRoaW5rIHRoaXMgZXZlbnQgc2lnbmlmaWVzIHRoYXRcbiAqIGNvbXBvc2l0aW9uIGhhcyBiZWd1bj9cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRmFsbGJhY2tTdGFydCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiAoXG4gICAgdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcEtleURvd24gJiZcbiAgICBuYXRpdmVFdmVudC5rZXlDb2RlID09PSBTVEFSVF9LRVlDT0RFXG4gICk7XG59XG5cbi8qKlxuICogRG9lcyBvdXIgZmFsbGJhY2sgbW9kZSB0aGluayB0aGF0IHRoaXMgZXZlbnQgaXMgdGhlIGVuZCBvZiBjb21wb3NpdGlvbj9cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRmFsbGJhY2tFbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlVcDpcbiAgICAgIC8vIENvbW1hbmQga2V5cyBpbnNlcnQgb3IgY2xlYXIgSU1FIGlucHV0LlxuICAgICAgcmV0dXJuIChFTkRfS0VZQ09ERVMuaW5kZXhPZihuYXRpdmVFdmVudC5rZXlDb2RlKSAhPT0gLTEpO1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duOlxuICAgICAgLy8gRXhwZWN0IElNRSBrZXlDb2RlIG9uIGVhY2gga2V5ZG93bi4gSWYgd2UgZ2V0IGFueSBvdGhlclxuICAgICAgLy8gY29kZSB3ZSBtdXN0IGhhdmUgZXhpdGVkIGVhcmxpZXIuXG4gICAgICByZXR1cm4gKG5hdGl2ZUV2ZW50LmtleUNvZGUgIT09IFNUQVJUX0tFWUNPREUpO1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzczpcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VEb3duOlxuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BCbHVyOlxuICAgICAgLy8gRXZlbnRzIGFyZSBub3QgcG9zc2libGUgd2l0aG91dCBjYW5jZWxsaW5nIElNRS5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBIZWxwZXIgY2xhc3Mgc3RvcmVzIGluZm9ybWF0aW9uIGFib3V0IHNlbGVjdGlvbiBhbmQgZG9jdW1lbnQgc3RhdGVcbiAqIHNvIHdlIGNhbiBmaWd1cmUgb3V0IHdoYXQgY2hhbmdlZCBhdCBhIGxhdGVyIGRhdGUuXG4gKlxuICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gcm9vdFxuICovXG5mdW5jdGlvbiBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUocm9vdCkge1xuICB0aGlzLnJvb3QgPSByb290O1xuICB0aGlzLnN0YXJ0U2VsZWN0aW9uID0gUmVhY3RJbnB1dFNlbGVjdGlvbi5nZXRTZWxlY3Rpb24ocm9vdCk7XG4gIHRoaXMuc3RhcnRWYWx1ZSA9IHRoaXMuZ2V0VGV4dCgpO1xufVxuXG4vKipcbiAqIEdldCBjdXJyZW50IHRleHQgb2YgaW5wdXQuXG4gKlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5GYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUucHJvdG90eXBlLmdldFRleHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMucm9vdC52YWx1ZSB8fCB0aGlzLnJvb3RbZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcigpXTtcbn07XG5cbi8qKlxuICogVGV4dCB0aGF0IGhhcyBjaGFuZ2VkIHNpbmNlIHRoZSBzdGFydCBvZiBjb21wb3NpdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbkZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZS5wcm90b3R5cGUuZ2V0RGF0YSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZW5kVmFsdWUgPSB0aGlzLmdldFRleHQoKTtcbiAgdmFyIHByZWZpeExlbmd0aCA9IHRoaXMuc3RhcnRTZWxlY3Rpb24uc3RhcnQ7XG4gIHZhciBzdWZmaXhMZW5ndGggPSB0aGlzLnN0YXJ0VmFsdWUubGVuZ3RoIC0gdGhpcy5zdGFydFNlbGVjdGlvbi5lbmQ7XG5cbiAgcmV0dXJuIGVuZFZhbHVlLnN1YnN0cihcbiAgICBwcmVmaXhMZW5ndGgsXG4gICAgZW5kVmFsdWUubGVuZ3RoIC0gc3VmZml4TGVuZ3RoIC0gcHJlZml4TGVuZ3RoXG4gICk7XG59O1xuXG4vKipcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYG9uQ29tcG9zaXRpb25TdGFydGAsIGBvbkNvbXBvc2l0aW9uVXBkYXRlYCBhbmRcbiAqIGBvbkNvbXBvc2l0aW9uRW5kYCBldmVudHMgb24gaW5wdXRzLCB0ZXh0YXJlYXMgYW5kIGNvbnRlbnRFZGl0YWJsZVxuICogbm9kZXMuXG4gKi9cbnZhciBDb21wb3NpdGlvbkV2ZW50UGx1Z2luID0ge1xuXG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdG9wTGV2ZWxUYXJnZXQgVGhlIGxpc3RlbmluZyBjb21wb25lbnQgcm9vdCBub2RlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUYXJnZXRJRCBJRCBvZiBgdG9wTGV2ZWxUYXJnZXRgLlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gICAqIEByZXR1cm4geyp9IEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxuICAgKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5leHRyYWN0RXZlbnRzfVxuICAgKi9cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24oXG4gICAgICB0b3BMZXZlbFR5cGUsXG4gICAgICB0b3BMZXZlbFRhcmdldCxcbiAgICAgIHRvcExldmVsVGFyZ2V0SUQsXG4gICAgICBuYXRpdmVFdmVudCkge1xuXG4gICAgdmFyIGV2ZW50VHlwZTtcbiAgICB2YXIgZGF0YTtcblxuICAgIGlmICh1c2VDb21wb3NpdGlvbkV2ZW50KSB7XG4gICAgICBldmVudFR5cGUgPSBnZXRDb21wb3NpdGlvbkV2ZW50VHlwZSh0b3BMZXZlbFR5cGUpO1xuICAgIH0gZWxzZSBpZiAoIWN1cnJlbnRDb21wb3NpdGlvbikge1xuICAgICAgaWYgKGlzRmFsbGJhY2tTdGFydCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICBldmVudFR5cGUgPSBldmVudFR5cGVzLmNvbXBvc2l0aW9uU3RhcnQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0ZhbGxiYWNrRW5kKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpKSB7XG4gICAgICBldmVudFR5cGUgPSBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kO1xuICAgIH1cblxuICAgIGlmICh1c2VGYWxsYmFja0RhdGEpIHtcbiAgICAgIC8vIFRoZSBjdXJyZW50IGNvbXBvc2l0aW9uIGlzIHN0b3JlZCBzdGF0aWNhbGx5IGFuZCBtdXN0IG5vdCBiZVxuICAgICAgLy8gb3ZlcndyaXR0ZW4gd2hpbGUgY29tcG9zaXRpb24gY29udGludWVzLlxuICAgICAgaWYgKCFjdXJyZW50Q29tcG9zaXRpb24gJiYgZXZlbnRUeXBlID09PSBldmVudFR5cGVzLmNvbXBvc2l0aW9uU3RhcnQpIHtcbiAgICAgICAgY3VycmVudENvbXBvc2l0aW9uID0gbmV3IEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZSh0b3BMZXZlbFRhcmdldCk7XG4gICAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZSA9PT0gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZCkge1xuICAgICAgICBpZiAoY3VycmVudENvbXBvc2l0aW9uKSB7XG4gICAgICAgICAgZGF0YSA9IGN1cnJlbnRDb21wb3NpdGlvbi5nZXREYXRhKCk7XG4gICAgICAgICAgY3VycmVudENvbXBvc2l0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChldmVudFR5cGUpIHtcbiAgICAgIHZhciBldmVudCA9IFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuZ2V0UG9vbGVkKFxuICAgICAgICBldmVudFR5cGUsXG4gICAgICAgIHRvcExldmVsVGFyZ2V0SUQsXG4gICAgICAgIG5hdGl2ZUV2ZW50XG4gICAgICApO1xuICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgLy8gSW5qZWN0IGRhdGEgZ2VuZXJhdGVkIGZyb20gZmFsbGJhY2sgcGF0aCBpbnRvIHRoZSBzeW50aGV0aWMgZXZlbnQuXG4gICAgICAgIC8vIFRoaXMgbWF0Y2hlcyB0aGUgcHJvcGVydHkgb2YgbmF0aXZlIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UuXG4gICAgICAgIGV2ZW50LmRhdGEgPSBkYXRhO1xuICAgICAgfVxuICAgICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgICAgIHJldHVybiBldmVudDtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9zaXRpb25FdmVudFBsdWdpbjtcbiIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRE9NQ2hpbGRyZW5PcGVyYXRpb25zXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgRGFuZ2VyID0gcmVxdWlyZShcIi4vRGFuZ2VyXCIpO1xudmFyIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzID0gcmVxdWlyZShcIi4vUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXNcIik7XG5cbnZhciBnZXRUZXh0Q29udGVudEFjY2Vzc29yID0gcmVxdWlyZShcIi4vZ2V0VGV4dENvbnRlbnRBY2Nlc3NvclwiKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbi8qKlxuICogVGhlIERPTSBwcm9wZXJ0eSB0byB1c2Ugd2hlbiBzZXR0aW5nIHRleHQgY29udGVudC5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xudmFyIHRleHRDb250ZW50QWNjZXNzb3IgPSBnZXRUZXh0Q29udGVudEFjY2Vzc29yKCk7XG5cbi8qKlxuICogSW5zZXJ0cyBgY2hpbGROb2RlYCBhcyBhIGNoaWxkIG9mIGBwYXJlbnROb2RlYCBhdCB0aGUgYGluZGV4YC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IHBhcmVudE5vZGUgUGFyZW50IG5vZGUgaW4gd2hpY2ggdG8gaW5zZXJ0LlxuICogQHBhcmFtIHtET01FbGVtZW50fSBjaGlsZE5vZGUgQ2hpbGQgbm9kZSB0byBpbnNlcnQuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggYXQgd2hpY2ggdG8gaW5zZXJ0IHRoZSBjaGlsZC5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBpbnNlcnRDaGlsZEF0KHBhcmVudE5vZGUsIGNoaWxkTm9kZSwgaW5kZXgpIHtcbiAgLy8gQnkgZXhwbG9pdGluZyBhcnJheXMgcmV0dXJuaW5nIGB1bmRlZmluZWRgIGZvciBhbiB1bmRlZmluZWQgaW5kZXgsIHdlIGNhblxuICAvLyByZWx5IGV4Y2x1c2l2ZWx5IG9uIGBpbnNlcnRCZWZvcmUobm9kZSwgbnVsbClgIGluc3RlYWQgb2YgYWxzbyB1c2luZ1xuICAvLyBgYXBwZW5kQ2hpbGQobm9kZSlgLiBIb3dldmVyLCB1c2luZyBgdW5kZWZpbmVkYCBpcyBub3QgYWxsb3dlZCBieSBhbGxcbiAgLy8gYnJvd3NlcnMgc28gd2UgbXVzdCByZXBsYWNlIGl0IHdpdGggYG51bGxgLlxuICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShcbiAgICBjaGlsZE5vZGUsXG4gICAgcGFyZW50Tm9kZS5jaGlsZE5vZGVzW2luZGV4XSB8fCBudWxsXG4gICk7XG59XG5cbnZhciB1cGRhdGVUZXh0Q29udGVudDtcbmlmICh0ZXh0Q29udGVudEFjY2Vzc29yID09PSAndGV4dENvbnRlbnQnKSB7XG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0ZXh0IGNvbnRlbnQgb2YgYG5vZGVgIHRvIGB0ZXh0YC5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlIE5vZGUgdG8gY2hhbmdlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IE5ldyB0ZXh0IGNvbnRlbnRcbiAgICovXG4gIHVwZGF0ZVRleHRDb250ZW50ID0gZnVuY3Rpb24obm9kZSwgdGV4dCkge1xuICAgIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xuICB9O1xufSBlbHNlIHtcbiAgLyoqXG4gICAqIFNldHMgdGhlIHRleHQgY29udGVudCBvZiBgbm9kZWAgdG8gYHRleHRgLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGUgTm9kZSB0byBjaGFuZ2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgTmV3IHRleHQgY29udGVudFxuICAgKi9cbiAgdXBkYXRlVGV4dENvbnRlbnQgPSBmdW5jdGlvbihub2RlLCB0ZXh0KSB7XG4gICAgLy8gSW4gb3JkZXIgdG8gcHJlc2VydmUgbmV3bGluZXMgY29ycmVjdGx5LCB3ZSBjYW4ndCB1c2UgLmlubmVyVGV4dCB0byBzZXRcbiAgICAvLyB0aGUgY29udGVudHMgKHNlZSAjMTA4MCksIHNvIHdlIGVtcHR5IHRoZSBlbGVtZW50IHRoZW4gYXBwZW5kIGEgdGV4dCBub2RlXG4gICAgd2hpbGUgKG5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICBpZiAodGV4dCkge1xuICAgICAgdmFyIGRvYyA9IG5vZGUub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudDtcbiAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoZG9jLmNyZWF0ZVRleHROb2RlKHRleHQpKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogT3BlcmF0aW9ucyBmb3IgdXBkYXRpbmcgd2l0aCBET00gY2hpbGRyZW4uXG4gKi9cbnZhciBET01DaGlsZHJlbk9wZXJhdGlvbnMgPSB7XG5cbiAgZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXA6IERhbmdlci5kYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCxcblxuICB1cGRhdGVUZXh0Q29udGVudDogdXBkYXRlVGV4dENvbnRlbnQsXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYSBjb21wb25lbnQncyBjaGlsZHJlbiBieSBwcm9jZXNzaW5nIGEgc2VyaWVzIG9mIHVwZGF0ZXMuIFRoZVxuICAgKiB1cGRhdGUgY29uZmlndXJhdGlvbnMgYXJlIGVhY2ggZXhwZWN0ZWQgdG8gaGF2ZSBhIGBwYXJlbnROb2RlYCBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHthcnJheTxvYmplY3Q+fSB1cGRhdGVzIExpc3Qgb2YgdXBkYXRlIGNvbmZpZ3VyYXRpb25zLlxuICAgKiBAcGFyYW0ge2FycmF5PHN0cmluZz59IG1hcmt1cExpc3QgTGlzdCBvZiBtYXJrdXAgc3RyaW5ncy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcm9jZXNzVXBkYXRlczogZnVuY3Rpb24odXBkYXRlcywgbWFya3VwTGlzdCkge1xuICAgIHZhciB1cGRhdGU7XG4gICAgLy8gTWFwcGluZyBmcm9tIHBhcmVudCBJRHMgdG8gaW5pdGlhbCBjaGlsZCBvcmRlcmluZ3MuXG4gICAgdmFyIGluaXRpYWxDaGlsZHJlbiA9IG51bGw7XG4gICAgLy8gTGlzdCBvZiBjaGlsZHJlbiB0aGF0IHdpbGwgYmUgbW92ZWQgb3IgcmVtb3ZlZC5cbiAgICB2YXIgdXBkYXRlZENoaWxkcmVuID0gbnVsbDtcblxuICAgIGZvciAodmFyIGkgPSAwOyB1cGRhdGUgPSB1cGRhdGVzW2ldOyBpKyspIHtcbiAgICAgIGlmICh1cGRhdGUudHlwZSA9PT0gUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuTU9WRV9FWElTVElORyB8fFxuICAgICAgICAgIHVwZGF0ZS50eXBlID09PSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5SRU1PVkVfTk9ERSkge1xuICAgICAgICB2YXIgdXBkYXRlZEluZGV4ID0gdXBkYXRlLmZyb21JbmRleDtcbiAgICAgICAgdmFyIHVwZGF0ZWRDaGlsZCA9IHVwZGF0ZS5wYXJlbnROb2RlLmNoaWxkTm9kZXNbdXBkYXRlZEluZGV4XTtcbiAgICAgICAgdmFyIHBhcmVudElEID0gdXBkYXRlLnBhcmVudElEO1xuXG4gICAgICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAgICAgdXBkYXRlZENoaWxkLFxuICAgICAgICAgICdwcm9jZXNzVXBkYXRlcygpOiBVbmFibGUgdG8gZmluZCBjaGlsZCAlcyBvZiBlbGVtZW50LiBUaGlzICcgK1xuICAgICAgICAgICdwcm9iYWJseSBtZWFucyB0aGUgRE9NIHdhcyB1bmV4cGVjdGVkbHkgbXV0YXRlZCAoZS5nLiwgYnkgdGhlICcgK1xuICAgICAgICAgICdicm93c2VyKSwgdXN1YWxseSBkdWUgdG8gZm9yZ2V0dGluZyBhIDx0Ym9keT4gd2hlbiB1c2luZyB0YWJsZXMsICcgK1xuICAgICAgICAgICduZXN0aW5nIDxwPiBvciA8YT4gdGFncywgb3IgdXNpbmcgbm9uLVNWRyBlbGVtZW50cyBpbiBhbiA8c3ZnPiAnK1xuICAgICAgICAgICdwYXJlbnQuIFRyeSBpbnNwZWN0aW5nIHRoZSBjaGlsZCBub2RlcyBvZiB0aGUgZWxlbWVudCB3aXRoIFJlYWN0ICcgK1xuICAgICAgICAgICdJRCBgJXNgLicsXG4gICAgICAgICAgdXBkYXRlZEluZGV4LFxuICAgICAgICAgIHBhcmVudElEXG4gICAgICAgICkgOiBpbnZhcmlhbnQodXBkYXRlZENoaWxkKSk7XG5cbiAgICAgICAgaW5pdGlhbENoaWxkcmVuID0gaW5pdGlhbENoaWxkcmVuIHx8IHt9O1xuICAgICAgICBpbml0aWFsQ2hpbGRyZW5bcGFyZW50SURdID0gaW5pdGlhbENoaWxkcmVuW3BhcmVudElEXSB8fCBbXTtcbiAgICAgICAgaW5pdGlhbENoaWxkcmVuW3BhcmVudElEXVt1cGRhdGVkSW5kZXhdID0gdXBkYXRlZENoaWxkO1xuXG4gICAgICAgIHVwZGF0ZWRDaGlsZHJlbiA9IHVwZGF0ZWRDaGlsZHJlbiB8fCBbXTtcbiAgICAgICAgdXBkYXRlZENoaWxkcmVuLnB1c2godXBkYXRlZENoaWxkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVuZGVyZWRNYXJrdXAgPSBEYW5nZXIuZGFuZ2Vyb3VzbHlSZW5kZXJNYXJrdXAobWFya3VwTGlzdCk7XG5cbiAgICAvLyBSZW1vdmUgdXBkYXRlZCBjaGlsZHJlbiBmaXJzdCBzbyB0aGF0IGB0b0luZGV4YCBpcyBjb25zaXN0ZW50LlxuICAgIGlmICh1cGRhdGVkQ2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdXBkYXRlZENoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHVwZGF0ZWRDaGlsZHJlbltqXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHVwZGF0ZWRDaGlsZHJlbltqXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgayA9IDA7IHVwZGF0ZSA9IHVwZGF0ZXNba107IGsrKykge1xuICAgICAgc3dpdGNoICh1cGRhdGUudHlwZSkge1xuICAgICAgICBjYXNlIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLklOU0VSVF9NQVJLVVA6XG4gICAgICAgICAgaW5zZXJ0Q2hpbGRBdChcbiAgICAgICAgICAgIHVwZGF0ZS5wYXJlbnROb2RlLFxuICAgICAgICAgICAgcmVuZGVyZWRNYXJrdXBbdXBkYXRlLm1hcmt1cEluZGV4XSxcbiAgICAgICAgICAgIHVwZGF0ZS50b0luZGV4XG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5NT1ZFX0VYSVNUSU5HOlxuICAgICAgICAgIGluc2VydENoaWxkQXQoXG4gICAgICAgICAgICB1cGRhdGUucGFyZW50Tm9kZSxcbiAgICAgICAgICAgIGluaXRpYWxDaGlsZHJlblt1cGRhdGUucGFyZW50SURdW3VwZGF0ZS5mcm9tSW5kZXhdLFxuICAgICAgICAgICAgdXBkYXRlLnRvSW5kZXhcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLlRFWFRfQ09OVEVOVDpcbiAgICAgICAgICB1cGRhdGVUZXh0Q29udGVudChcbiAgICAgICAgICAgIHVwZGF0ZS5wYXJlbnROb2RlLFxuICAgICAgICAgICAgdXBkYXRlLnRleHRDb250ZW50XG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5SRU1PVkVfTk9ERTpcbiAgICAgICAgICAvLyBBbHJlYWR5IHJlbW92ZWQgYnkgdGhlIGZvci1sb29wIGFib3ZlLlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERPTUNoaWxkcmVuT3BlcmF0aW9ucztcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBET01Qcm9wZXJ0eVxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4vKmpzbGludCBiaXR3aXNlOiB0cnVlICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xuXG52YXIgRE9NUHJvcGVydHlJbmplY3Rpb24gPSB7XG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gbm9ybWFsaXplZCwgY2FtZWxjYXNlZCBwcm9wZXJ0eSBuYW1lcyB0byBhIGNvbmZpZ3VyYXRpb24gdGhhdFxuICAgKiBzcGVjaWZpZXMgaG93IHRoZSBhc3NvY2lhdGVkIERPTSBwcm9wZXJ0eSBzaG91bGQgYmUgYWNjZXNzZWQgb3IgcmVuZGVyZWQuXG4gICAqL1xuICBNVVNUX1VTRV9BVFRSSUJVVEU6IDB4MSxcbiAgTVVTVF9VU0VfUFJPUEVSVFk6IDB4MixcbiAgSEFTX1NJREVfRUZGRUNUUzogMHg0LFxuICBIQVNfQk9PTEVBTl9WQUxVRTogMHg4LFxuICBIQVNfTlVNRVJJQ19WQUxVRTogMHgxMCxcbiAgSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUU6IDB4MjAgfCAweDEwLFxuICBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFOiAweDQwLFxuXG4gIC8qKlxuICAgKiBJbmplY3Qgc29tZSBzcGVjaWFsaXplZCBrbm93bGVkZ2UgYWJvdXQgdGhlIERPTS4gVGhpcyB0YWtlcyBhIGNvbmZpZyBvYmplY3RcbiAgICogd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqIGlzQ3VzdG9tQXR0cmlidXRlOiBmdW5jdGlvbiB0aGF0IGdpdmVuIGFuIGF0dHJpYnV0ZSBuYW1lIHdpbGwgcmV0dXJuIHRydWVcbiAgICogaWYgaXQgY2FuIGJlIGluc2VydGVkIGludG8gdGhlIERPTSB2ZXJiYXRpbS4gVXNlZnVsIGZvciBkYXRhLSogb3IgYXJpYS0qXG4gICAqIGF0dHJpYnV0ZXMgd2hlcmUgaXQncyBpbXBvc3NpYmxlIHRvIGVudW1lcmF0ZSBhbGwgb2YgdGhlIHBvc3NpYmxlXG4gICAqIGF0dHJpYnV0ZSBuYW1lcyxcbiAgICpcbiAgICogUHJvcGVydGllczogb2JqZWN0IG1hcHBpbmcgRE9NIHByb3BlcnR5IG5hbWUgdG8gb25lIG9mIHRoZVxuICAgKiBET01Qcm9wZXJ0eUluamVjdGlvbiBjb25zdGFudHMgb3IgbnVsbC4gSWYgeW91ciBhdHRyaWJ1dGUgaXNuJ3QgaW4gaGVyZSxcbiAgICogaXQgd29uJ3QgZ2V0IHdyaXR0ZW4gdG8gdGhlIERPTS5cbiAgICpcbiAgICogRE9NQXR0cmlidXRlTmFtZXM6IG9iamVjdCBtYXBwaW5nIFJlYWN0IGF0dHJpYnV0ZSBuYW1lIHRvIHRoZSBET01cbiAgICogYXR0cmlidXRlIG5hbWUuIEF0dHJpYnV0ZSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSB0aGUgKipsb3dlcmNhc2UqKlxuICAgKiBub3JtYWxpemVkIG5hbWUuXG4gICAqXG4gICAqIERPTVByb3BlcnR5TmFtZXM6IHNpbWlsYXIgdG8gRE9NQXR0cmlidXRlTmFtZXMgYnV0IGZvciBET00gcHJvcGVydGllcy5cbiAgICogUHJvcGVydHkgbmFtZXMgbm90IHNwZWNpZmllZCB1c2UgdGhlIG5vcm1hbGl6ZWQgbmFtZS5cbiAgICpcbiAgICogRE9NTXV0YXRpb25NZXRob2RzOiBQcm9wZXJ0aWVzIHRoYXQgcmVxdWlyZSBzcGVjaWFsIG11dGF0aW9uIG1ldGhvZHMuIElmXG4gICAqIGB2YWx1ZWAgaXMgdW5kZWZpbmVkLCB0aGUgbXV0YXRpb24gbWV0aG9kIHNob3VsZCB1bnNldCB0aGUgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkb21Qcm9wZXJ0eUNvbmZpZyB0aGUgY29uZmlnIGFzIGRlc2NyaWJlZCBhYm92ZS5cbiAgICovXG4gIGluamVjdERPTVByb3BlcnR5Q29uZmlnOiBmdW5jdGlvbihkb21Qcm9wZXJ0eUNvbmZpZykge1xuICAgIHZhciBQcm9wZXJ0aWVzID0gZG9tUHJvcGVydHlDb25maWcuUHJvcGVydGllcyB8fCB7fTtcbiAgICB2YXIgRE9NQXR0cmlidXRlTmFtZXMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01BdHRyaWJ1dGVOYW1lcyB8fCB7fTtcbiAgICB2YXIgRE9NUHJvcGVydHlOYW1lcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTVByb3BlcnR5TmFtZXMgfHwge307XG4gICAgdmFyIERPTU11dGF0aW9uTWV0aG9kcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTU11dGF0aW9uTWV0aG9kcyB8fCB7fTtcblxuICAgIGlmIChkb21Qcm9wZXJ0eUNvbmZpZy5pc0N1c3RvbUF0dHJpYnV0ZSkge1xuICAgICAgRE9NUHJvcGVydHkuX2lzQ3VzdG9tQXR0cmlidXRlRnVuY3Rpb25zLnB1c2goXG4gICAgICAgIGRvbVByb3BlcnR5Q29uZmlnLmlzQ3VzdG9tQXR0cmlidXRlXG4gICAgICApO1xuICAgIH1cblxuICAgIGZvciAodmFyIHByb3BOYW1lIGluIFByb3BlcnRpZXMpIHtcbiAgICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAgICFET01Qcm9wZXJ0eS5pc1N0YW5kYXJkTmFtZS5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSksXG4gICAgICAgICdpbmplY3RET01Qcm9wZXJ0eUNvbmZpZyguLi4pOiBZb3VcXCdyZSB0cnlpbmcgdG8gaW5qZWN0IERPTSBwcm9wZXJ0eSAnICtcbiAgICAgICAgJ1xcJyVzXFwnIHdoaWNoIGhhcyBhbHJlYWR5IGJlZW4gaW5qZWN0ZWQuIFlvdSBtYXkgYmUgYWNjaWRlbnRhbGx5ICcgK1xuICAgICAgICAnaW5qZWN0aW5nIHRoZSBzYW1lIERPTSBwcm9wZXJ0eSBjb25maWcgdHdpY2UsIG9yIHlvdSBtYXkgYmUgJyArXG4gICAgICAgICdpbmplY3RpbmcgdHdvIGNvbmZpZ3MgdGhhdCBoYXZlIGNvbmZsaWN0aW5nIHByb3BlcnR5IG5hbWVzLicsXG4gICAgICAgIHByb3BOYW1lXG4gICAgICApIDogaW52YXJpYW50KCFET01Qcm9wZXJ0eS5pc1N0YW5kYXJkTmFtZS5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpKTtcblxuICAgICAgRE9NUHJvcGVydHkuaXNTdGFuZGFyZE5hbWVbcHJvcE5hbWVdID0gdHJ1ZTtcblxuICAgICAgdmFyIGxvd2VyQ2FzZWQgPSBwcm9wTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgRE9NUHJvcGVydHkuZ2V0UG9zc2libGVTdGFuZGFyZE5hbWVbbG93ZXJDYXNlZF0gPSBwcm9wTmFtZTtcblxuICAgICAgaWYgKERPTUF0dHJpYnV0ZU5hbWVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IERPTUF0dHJpYnV0ZU5hbWVzW3Byb3BOYW1lXTtcbiAgICAgICAgRE9NUHJvcGVydHkuZ2V0UG9zc2libGVTdGFuZGFyZE5hbWVbYXR0cmlidXRlTmFtZV0gPSBwcm9wTmFtZTtcbiAgICAgICAgRE9NUHJvcGVydHkuZ2V0QXR0cmlidXRlTmFtZVtwcm9wTmFtZV0gPSBhdHRyaWJ1dGVOYW1lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgRE9NUHJvcGVydHkuZ2V0QXR0cmlidXRlTmFtZVtwcm9wTmFtZV0gPSBsb3dlckNhc2VkO1xuICAgICAgfVxuXG4gICAgICBET01Qcm9wZXJ0eS5nZXRQcm9wZXJ0eU5hbWVbcHJvcE5hbWVdID1cbiAgICAgICAgRE9NUHJvcGVydHlOYW1lcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkgP1xuICAgICAgICAgIERPTVByb3BlcnR5TmFtZXNbcHJvcE5hbWVdIDpcbiAgICAgICAgICBwcm9wTmFtZTtcblxuICAgICAgaWYgKERPTU11dGF0aW9uTWV0aG9kcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgRE9NUHJvcGVydHkuZ2V0TXV0YXRpb25NZXRob2RbcHJvcE5hbWVdID0gRE9NTXV0YXRpb25NZXRob2RzW3Byb3BOYW1lXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIERPTVByb3BlcnR5LmdldE11dGF0aW9uTWV0aG9kW3Byb3BOYW1lXSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9wQ29uZmlnID0gUHJvcGVydGllc1twcm9wTmFtZV07XG4gICAgICBET01Qcm9wZXJ0eS5tdXN0VXNlQXR0cmlidXRlW3Byb3BOYW1lXSA9XG4gICAgICAgIHByb3BDb25maWcgJiBET01Qcm9wZXJ0eUluamVjdGlvbi5NVVNUX1VTRV9BVFRSSUJVVEU7XG4gICAgICBET01Qcm9wZXJ0eS5tdXN0VXNlUHJvcGVydHlbcHJvcE5hbWVdID1cbiAgICAgICAgcHJvcENvbmZpZyAmIERPTVByb3BlcnR5SW5qZWN0aW9uLk1VU1RfVVNFX1BST1BFUlRZO1xuICAgICAgRE9NUHJvcGVydHkuaGFzU2lkZUVmZmVjdHNbcHJvcE5hbWVdID1cbiAgICAgICAgcHJvcENvbmZpZyAmIERPTVByb3BlcnR5SW5qZWN0aW9uLkhBU19TSURFX0VGRkVDVFM7XG4gICAgICBET01Qcm9wZXJ0eS5oYXNCb29sZWFuVmFsdWVbcHJvcE5hbWVdID1cbiAgICAgICAgcHJvcENvbmZpZyAmIERPTVByb3BlcnR5SW5qZWN0aW9uLkhBU19CT09MRUFOX1ZBTFVFO1xuICAgICAgRE9NUHJvcGVydHkuaGFzTnVtZXJpY1ZhbHVlW3Byb3BOYW1lXSA9XG4gICAgICAgIHByb3BDb25maWcgJiBET01Qcm9wZXJ0eUluamVjdGlvbi5IQVNfTlVNRVJJQ19WQUxVRTtcbiAgICAgIERPTVByb3BlcnR5Lmhhc1Bvc2l0aXZlTnVtZXJpY1ZhbHVlW3Byb3BOYW1lXSA9XG4gICAgICAgIHByb3BDb25maWcgJiBET01Qcm9wZXJ0eUluamVjdGlvbi5IQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRTtcbiAgICAgIERPTVByb3BlcnR5Lmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWVbcHJvcE5hbWVdID1cbiAgICAgICAgcHJvcENvbmZpZyAmIERPTVByb3BlcnR5SW5qZWN0aW9uLkhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUU7XG5cbiAgICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAgICFET01Qcm9wZXJ0eS5tdXN0VXNlQXR0cmlidXRlW3Byb3BOYW1lXSB8fFxuICAgICAgICAgICFET01Qcm9wZXJ0eS5tdXN0VXNlUHJvcGVydHlbcHJvcE5hbWVdLFxuICAgICAgICAnRE9NUHJvcGVydHk6IENhbm5vdCByZXF1aXJlIHVzaW5nIGJvdGggYXR0cmlidXRlIGFuZCBwcm9wZXJ0eTogJXMnLFxuICAgICAgICBwcm9wTmFtZVxuICAgICAgKSA6IGludmFyaWFudCghRE9NUHJvcGVydHkubXVzdFVzZUF0dHJpYnV0ZVtwcm9wTmFtZV0gfHxcbiAgICAgICAgIURPTVByb3BlcnR5Lm11c3RVc2VQcm9wZXJ0eVtwcm9wTmFtZV0pKTtcbiAgICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAgIERPTVByb3BlcnR5Lm11c3RVc2VQcm9wZXJ0eVtwcm9wTmFtZV0gfHxcbiAgICAgICAgICAhRE9NUHJvcGVydHkuaGFzU2lkZUVmZmVjdHNbcHJvcE5hbWVdLFxuICAgICAgICAnRE9NUHJvcGVydHk6IFByb3BlcnRpZXMgdGhhdCBoYXZlIHNpZGUgZWZmZWN0cyBtdXN0IHVzZSBwcm9wZXJ0eTogJXMnLFxuICAgICAgICBwcm9wTmFtZVxuICAgICAgKSA6IGludmFyaWFudChET01Qcm9wZXJ0eS5tdXN0VXNlUHJvcGVydHlbcHJvcE5hbWVdIHx8XG4gICAgICAgICFET01Qcm9wZXJ0eS5oYXNTaWRlRWZmZWN0c1twcm9wTmFtZV0pKTtcbiAgICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAgICEhRE9NUHJvcGVydHkuaGFzQm9vbGVhblZhbHVlW3Byb3BOYW1lXSArXG4gICAgICAgICAgISFET01Qcm9wZXJ0eS5oYXNOdW1lcmljVmFsdWVbcHJvcE5hbWVdICtcbiAgICAgICAgICAhIURPTVByb3BlcnR5Lmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWVbcHJvcE5hbWVdIDw9IDEsXG4gICAgICAgICdET01Qcm9wZXJ0eTogVmFsdWUgY2FuIGJlIG9uZSBvZiBib29sZWFuLCBvdmVybG9hZGVkIGJvb2xlYW4sIG9yICcgK1xuICAgICAgICAnbnVtZXJpYyB2YWx1ZSwgYnV0IG5vdCBhIGNvbWJpbmF0aW9uOiAlcycsXG4gICAgICAgIHByb3BOYW1lXG4gICAgICApIDogaW52YXJpYW50KCEhRE9NUHJvcGVydHkuaGFzQm9vbGVhblZhbHVlW3Byb3BOYW1lXSArXG4gICAgICAgICEhRE9NUHJvcGVydHkuaGFzTnVtZXJpY1ZhbHVlW3Byb3BOYW1lXSArXG4gICAgICAgICEhRE9NUHJvcGVydHkuaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZVtwcm9wTmFtZV0gPD0gMSkpO1xuICAgIH1cbiAgfVxufTtcbnZhciBkZWZhdWx0VmFsdWVDYWNoZSA9IHt9O1xuXG4vKipcbiAqIERPTVByb3BlcnR5IGV4cG9ydHMgbG9va3VwIG9iamVjdHMgdGhhdCBjYW4gYmUgdXNlZCBsaWtlIGZ1bmN0aW9uczpcbiAqXG4gKiAgID4gRE9NUHJvcGVydHkuaXNWYWxpZFsnaWQnXVxuICogICB0cnVlXG4gKiAgID4gRE9NUHJvcGVydHkuaXNWYWxpZFsnZm9vYmFyJ11cbiAqICAgdW5kZWZpbmVkXG4gKlxuICogQWx0aG91Z2ggdGhpcyBtYXkgYmUgY29uZnVzaW5nLCBpdCBwZXJmb3JtcyBiZXR0ZXIgaW4gZ2VuZXJhbC5cbiAqXG4gKiBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2tleS1leGlzdHNcbiAqIEBzZWUgaHR0cDovL2pzcGVyZi5jb20va2V5LW1pc3NpbmdcbiAqL1xudmFyIERPTVByb3BlcnR5ID0ge1xuXG4gIElEX0FUVFJJQlVURV9OQU1FOiAnZGF0YS1yZWFjdGlkJyxcblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgYSBwcm9wZXJ0eSBuYW1lIGlzIGEgc3RhbmRhcmQgcHJvcGVydHkuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBpc1N0YW5kYXJkTmFtZToge30sXG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSBsb3dlcmNhc2UgcHJvcGVydHkgbmFtZXMgdG8gdGhlIHByb3Blcmx5IGNhc2VkIHZlcnNpb24sIHVzZWRcbiAgICogdG8gd2FybiBpbiB0aGUgY2FzZSBvZiBtaXNzaW5nIHByb3BlcnRpZXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBnZXRQb3NzaWJsZVN0YW5kYXJkTmFtZToge30sXG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSBub3JtYWxpemVkIG5hbWVzIHRvIGF0dHJpYnV0ZSBuYW1lcyB0aGF0IGRpZmZlci4gQXR0cmlidXRlXG4gICAqIG5hbWVzIGFyZSB1c2VkIHdoZW4gcmVuZGVyaW5nIG1hcmt1cCBvciB3aXRoIGAqQXR0cmlidXRlKClgLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0QXR0cmlidXRlTmFtZToge30sXG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSBub3JtYWxpemVkIG5hbWVzIHRvIHByb3BlcnRpZXMgb24gRE9NIG5vZGUgaW5zdGFuY2VzLlxuICAgKiAoVGhpcyBpbmNsdWRlcyBwcm9wZXJ0aWVzIHRoYXQgbXV0YXRlIGR1ZSB0byBleHRlcm5hbCBmYWN0b3JzLilcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIGdldFByb3BlcnR5TmFtZToge30sXG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSBub3JtYWxpemVkIG5hbWVzIHRvIG11dGF0aW9uIG1ldGhvZHMuIFRoaXMgd2lsbCBvbmx5IGV4aXN0IGlmXG4gICAqIG11dGF0aW9uIGNhbm5vdCBiZSBzZXQgc2ltcGx5IGJ5IHRoZSBwcm9wZXJ0eSBvciBgc2V0QXR0cmlidXRlKClgLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0TXV0YXRpb25NZXRob2Q6IHt9LFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIGFjY2Vzc2VkIGFuZCBtdXRhdGVkIGFzIGFuIG9iamVjdCBwcm9wZXJ0eS5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIG11c3RVc2VBdHRyaWJ1dGU6IHt9LFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIGFjY2Vzc2VkIGFuZCBtdXRhdGVkIHVzaW5nIGAqQXR0cmlidXRlKClgLlxuICAgKiAoVGhpcyBpbmNsdWRlcyBhbnl0aGluZyB0aGF0IGZhaWxzIGA8cHJvcE5hbWU+IGluIDxlbGVtZW50PmAuKVxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgbXVzdFVzZVByb3BlcnR5OiB7fSxcblxuICAvKipcbiAgICogV2hldGhlciBvciBub3Qgc2V0dGluZyBhIHZhbHVlIGNhdXNlcyBzaWRlIGVmZmVjdHMgc3VjaCBhcyB0cmlnZ2VyaW5nXG4gICAqIHJlc291cmNlcyB0byBiZSBsb2FkZWQgb3IgdGV4dCBzZWxlY3Rpb24gY2hhbmdlcy4gV2UgbXVzdCBlbnN1cmUgdGhhdFxuICAgKiB0aGUgdmFsdWUgaXMgb25seSBzZXQgaWYgaXQgaGFzIGNoYW5nZWQuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBoYXNTaWRlRWZmZWN0czoge30sXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIHByb3BlcnR5IHNob3VsZCBiZSByZW1vdmVkIHdoZW4gc2V0IHRvIGEgZmFsc2V5IHZhbHVlLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgaGFzQm9vbGVhblZhbHVlOiB7fSxcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgcHJvcGVydHkgbXVzdCBiZSBudW1lcmljIG9yIHBhcnNlIGFzIGFcbiAgICogbnVtZXJpYyBhbmQgc2hvdWxkIGJlIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBoYXNOdW1lcmljVmFsdWU6IHt9LFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIHBvc2l0aXZlIG51bWVyaWMgb3IgcGFyc2UgYXMgYSBwb3NpdGl2ZVxuICAgKiBudW1lcmljIGFuZCBzaG91bGQgYmUgcmVtb3ZlZCB3aGVuIHNldCB0byBhIGZhbHNleSB2YWx1ZS5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIGhhc1Bvc2l0aXZlTnVtZXJpY1ZhbHVlOiB7fSxcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgcHJvcGVydHkgY2FuIGJlIHVzZWQgYXMgYSBmbGFnIGFzIHdlbGwgYXMgd2l0aCBhIHZhbHVlLiBSZW1vdmVkXG4gICAqIHdoZW4gc3RyaWN0bHkgZXF1YWwgdG8gZmFsc2U7IHByZXNlbnQgd2l0aG91dCBhIHZhbHVlIHdoZW4gc3RyaWN0bHkgZXF1YWxcbiAgICogdG8gdHJ1ZTsgcHJlc2VudCB3aXRoIGEgdmFsdWUgb3RoZXJ3aXNlLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZToge30sXG5cbiAgLyoqXG4gICAqIEFsbCBvZiB0aGUgaXNDdXN0b21BdHRyaWJ1dGUoKSBmdW5jdGlvbnMgdGhhdCBoYXZlIGJlZW4gaW5qZWN0ZWQuXG4gICAqL1xuICBfaXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnM6IFtdLFxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBhIHByb3BlcnR5IG5hbWUgaXMgYSBjdXN0b20gYXR0cmlidXRlLlxuICAgKiBAbWV0aG9kXG4gICAqL1xuICBpc0N1c3RvbUF0dHJpYnV0ZTogZnVuY3Rpb24oYXR0cmlidXRlTmFtZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgRE9NUHJvcGVydHkuX2lzQ3VzdG9tQXR0cmlidXRlRnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXNDdXN0b21BdHRyaWJ1dGVGbiA9IERPTVByb3BlcnR5Ll9pc0N1c3RvbUF0dHJpYnV0ZUZ1bmN0aW9uc1tpXTtcbiAgICAgIGlmIChpc0N1c3RvbUF0dHJpYnV0ZUZuKGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRlZmF1bHQgcHJvcGVydHkgdmFsdWUgZm9yIGEgRE9NIHByb3BlcnR5IChpLmUuLCBub3QgYW5cbiAgICogYXR0cmlidXRlKS4gTW9zdCBkZWZhdWx0IHZhbHVlcyBhcmUgJycgb3IgZmFsc2UsIGJ1dCBub3QgYWxsLiBXb3JzZSB5ZXQsXG4gICAqIHNvbWUgKGluIHBhcnRpY3VsYXIsIGB0eXBlYCkgdmFyeSBkZXBlbmRpbmcgb24gdGhlIHR5cGUgb2YgZWxlbWVudC5cbiAgICpcbiAgICogVE9ETzogSXMgaXQgYmV0dGVyIHRvIGdyYWIgYWxsIHRoZSBwb3NzaWJsZSBwcm9wZXJ0aWVzIHdoZW4gY3JlYXRpbmcgYW5cbiAgICogZWxlbWVudCB0byBhdm9pZCBoYXZpbmcgdG8gY3JlYXRlIHRoZSBzYW1lIGVsZW1lbnQgdHdpY2U/XG4gICAqL1xuICBnZXREZWZhdWx0VmFsdWVGb3JQcm9wZXJ0eTogZnVuY3Rpb24obm9kZU5hbWUsIHByb3ApIHtcbiAgICB2YXIgbm9kZURlZmF1bHRzID0gZGVmYXVsdFZhbHVlQ2FjaGVbbm9kZU5hbWVdO1xuICAgIHZhciB0ZXN0RWxlbWVudDtcbiAgICBpZiAoIW5vZGVEZWZhdWx0cykge1xuICAgICAgZGVmYXVsdFZhbHVlQ2FjaGVbbm9kZU5hbWVdID0gbm9kZURlZmF1bHRzID0ge307XG4gICAgfVxuICAgIGlmICghKHByb3AgaW4gbm9kZURlZmF1bHRzKSkge1xuICAgICAgdGVzdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5vZGVOYW1lKTtcbiAgICAgIG5vZGVEZWZhdWx0c1twcm9wXSA9IHRlc3RFbGVtZW50W3Byb3BdO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZURlZmF1bHRzW3Byb3BdO1xuICB9LFxuXG4gIGluamVjdGlvbjogRE9NUHJvcGVydHlJbmplY3Rpb25cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRE9NUHJvcGVydHk7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRE9NUHJvcGVydHlPcGVyYXRpb25zXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKFwiLi9ET01Qcm9wZXJ0eVwiKTtcblxudmFyIGVzY2FwZVRleHRGb3JCcm93c2VyID0gcmVxdWlyZShcIi4vZXNjYXBlVGV4dEZvckJyb3dzZXJcIik7XG52YXIgbWVtb2l6ZVN0cmluZ09ubHkgPSByZXF1aXJlKFwiLi9tZW1vaXplU3RyaW5nT25seVwiKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZShcIi4vd2FybmluZ1wiKTtcblxuZnVuY3Rpb24gc2hvdWxkSWdub3JlVmFsdWUobmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgfHxcbiAgICAoRE9NUHJvcGVydHkuaGFzQm9vbGVhblZhbHVlW25hbWVdICYmICF2YWx1ZSkgfHxcbiAgICAoRE9NUHJvcGVydHkuaGFzTnVtZXJpY1ZhbHVlW25hbWVdICYmIGlzTmFOKHZhbHVlKSkgfHxcbiAgICAoRE9NUHJvcGVydHkuaGFzUG9zaXRpdmVOdW1lcmljVmFsdWVbbmFtZV0gJiYgKHZhbHVlIDwgMSkpIHx8XG4gICAgKERPTVByb3BlcnR5Lmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWVbbmFtZV0gJiYgdmFsdWUgPT09IGZhbHNlKTtcbn1cblxudmFyIHByb2Nlc3NBdHRyaWJ1dGVOYW1lQW5kUHJlZml4ID0gbWVtb2l6ZVN0cmluZ09ubHkoZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gZXNjYXBlVGV4dEZvckJyb3dzZXIobmFtZSkgKyAnPVwiJztcbn0pO1xuXG5pZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gIHZhciByZWFjdFByb3BzID0ge1xuICAgIGNoaWxkcmVuOiB0cnVlLFxuICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB0cnVlLFxuICAgIGtleTogdHJ1ZSxcbiAgICByZWY6IHRydWVcbiAgfTtcbiAgdmFyIHdhcm5lZFByb3BlcnRpZXMgPSB7fTtcblxuICB2YXIgd2FyblVua25vd25Qcm9wZXJ0eSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBpZiAocmVhY3RQcm9wcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiByZWFjdFByb3BzW25hbWVdIHx8XG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkUHJvcGVydGllc1tuYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgIC8vIGRhdGEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uXG4gICAgdmFyIHN0YW5kYXJkTmFtZSA9IChcbiAgICAgIERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKGxvd2VyQ2FzZWROYW1lKSA/XG4gICAgICAgIGxvd2VyQ2FzZWROYW1lIDpcbiAgICAgIERPTVByb3BlcnR5LmdldFBvc3NpYmxlU3RhbmRhcmROYW1lLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/XG4gICAgICAgIERPTVByb3BlcnR5LmdldFBvc3NpYmxlU3RhbmRhcmROYW1lW2xvd2VyQ2FzZWROYW1lXSA6XG4gICAgICAgIG51bGxcbiAgICApO1xuXG4gICAgLy8gRm9yIG5vdywgb25seSB3YXJuIHdoZW4gd2UgaGF2ZSBhIHN1Z2dlc3RlZCBjb3JyZWN0aW9uLiBUaGlzIHByZXZlbnRzXG4gICAgLy8gbG9nZ2luZyB0b28gbXVjaCB3aGVuIHVzaW5nIHRyYW5zZmVyUHJvcHNUby5cbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyhcbiAgICAgIHN0YW5kYXJkTmFtZSA9PSBudWxsLFxuICAgICAgJ1Vua25vd24gRE9NIHByb3BlcnR5ICcgKyBuYW1lICsgJy4gRGlkIHlvdSBtZWFuICcgKyBzdGFuZGFyZE5hbWUgKyAnPydcbiAgICApIDogbnVsbCk7XG5cbiAgfTtcbn1cblxuLyoqXG4gKiBPcGVyYXRpb25zIGZvciBkZWFsaW5nIHdpdGggRE9NIHByb3BlcnRpZXMuXG4gKi9cbnZhciBET01Qcm9wZXJ0eU9wZXJhdGlvbnMgPSB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciB0aGUgSUQgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBVbmVzY2FwZWQgSUQuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIHN0cmluZy5cbiAgICovXG4gIGNyZWF0ZU1hcmt1cEZvcklEOiBmdW5jdGlvbihpZCkge1xuICAgIHJldHVybiBwcm9jZXNzQXR0cmlidXRlTmFtZUFuZFByZWZpeChET01Qcm9wZXJ0eS5JRF9BVFRSSUJVVEVfTkFNRSkgK1xuICAgICAgZXNjYXBlVGV4dEZvckJyb3dzZXIoaWQpICsgJ1wiJztcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIGEgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHJldHVybiB7P3N0cmluZ30gTWFya3VwIHN0cmluZywgb3IgbnVsbCBpZiB0aGUgcHJvcGVydHkgd2FzIGludmFsaWQuXG4gICAqL1xuICBjcmVhdGVNYXJrdXBGb3JQcm9wZXJ0eTogZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoRE9NUHJvcGVydHkuaXNTdGFuZGFyZE5hbWUuaGFzT3duUHJvcGVydHkobmFtZSkgJiZcbiAgICAgICAgRE9NUHJvcGVydHkuaXNTdGFuZGFyZE5hbWVbbmFtZV0pIHtcbiAgICAgIGlmIChzaG91bGRJZ25vcmVWYWx1ZShuYW1lLCB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBET01Qcm9wZXJ0eS5nZXRBdHRyaWJ1dGVOYW1lW25hbWVdO1xuICAgICAgaWYgKERPTVByb3BlcnR5Lmhhc0Jvb2xlYW5WYWx1ZVtuYW1lXSB8fFxuICAgICAgICAgIChET01Qcm9wZXJ0eS5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlW25hbWVdICYmIHZhbHVlID09PSB0cnVlKSkge1xuICAgICAgICByZXR1cm4gZXNjYXBlVGV4dEZvckJyb3dzZXIoYXR0cmlidXRlTmFtZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvY2Vzc0F0dHJpYnV0ZU5hbWVBbmRQcmVmaXgoYXR0cmlidXRlTmFtZSkgK1xuICAgICAgICBlc2NhcGVUZXh0Rm9yQnJvd3Nlcih2YWx1ZSkgKyAnXCInO1xuICAgIH0gZWxzZSBpZiAoRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcm9jZXNzQXR0cmlidXRlTmFtZUFuZFByZWZpeChuYW1lKSArXG4gICAgICAgIGVzY2FwZVRleHRGb3JCcm93c2VyKHZhbHVlKSArICdcIic7XG4gICAgfSBlbHNlIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgIHdhcm5Vbmtub3duUHJvcGVydHkobmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqL1xuICBzZXRWYWx1ZUZvclByb3BlcnR5OiBmdW5jdGlvbihub2RlLCBuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChET01Qcm9wZXJ0eS5pc1N0YW5kYXJkTmFtZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJlxuICAgICAgICBET01Qcm9wZXJ0eS5pc1N0YW5kYXJkTmFtZVtuYW1lXSkge1xuICAgICAgdmFyIG11dGF0aW9uTWV0aG9kID0gRE9NUHJvcGVydHkuZ2V0TXV0YXRpb25NZXRob2RbbmFtZV07XG4gICAgICBpZiAobXV0YXRpb25NZXRob2QpIHtcbiAgICAgICAgbXV0YXRpb25NZXRob2Qobm9kZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChzaG91bGRJZ25vcmVWYWx1ZShuYW1lLCB2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5kZWxldGVWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUpO1xuICAgICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5tdXN0VXNlQXR0cmlidXRlW25hbWVdKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKERPTVByb3BlcnR5LmdldEF0dHJpYnV0ZU5hbWVbbmFtZV0sICcnICsgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHByb3BOYW1lID0gRE9NUHJvcGVydHkuZ2V0UHJvcGVydHlOYW1lW25hbWVdO1xuICAgICAgICBpZiAoIURPTVByb3BlcnR5Lmhhc1NpZGVFZmZlY3RzW25hbWVdIHx8IG5vZGVbcHJvcE5hbWVdICE9PSB2YWx1ZSkge1xuICAgICAgICAgIG5vZGVbcHJvcE5hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKG5hbWUpKSB7XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKG5hbWUsICcnICsgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICB3YXJuVW5rbm93blByb3BlcnR5KG5hbWUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGVsZXRlcyB0aGUgdmFsdWUgZm9yIGEgcHJvcGVydHkgb24gYSBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICovXG4gIGRlbGV0ZVZhbHVlRm9yUHJvcGVydHk6IGZ1bmN0aW9uKG5vZGUsIG5hbWUpIHtcbiAgICBpZiAoRE9NUHJvcGVydHkuaXNTdGFuZGFyZE5hbWUuaGFzT3duUHJvcGVydHkobmFtZSkgJiZcbiAgICAgICAgRE9NUHJvcGVydHkuaXNTdGFuZGFyZE5hbWVbbmFtZV0pIHtcbiAgICAgIHZhciBtdXRhdGlvbk1ldGhvZCA9IERPTVByb3BlcnR5LmdldE11dGF0aW9uTWV0aG9kW25hbWVdO1xuICAgICAgaWYgKG11dGF0aW9uTWV0aG9kKSB7XG4gICAgICAgIG11dGF0aW9uTWV0aG9kKG5vZGUsIHVuZGVmaW5lZCk7XG4gICAgICB9IGVsc2UgaWYgKERPTVByb3BlcnR5Lm11c3RVc2VBdHRyaWJ1dGVbbmFtZV0pIHtcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoRE9NUHJvcGVydHkuZ2V0QXR0cmlidXRlTmFtZVtuYW1lXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcHJvcE5hbWUgPSBET01Qcm9wZXJ0eS5nZXRQcm9wZXJ0eU5hbWVbbmFtZV07XG4gICAgICAgIHZhciBkZWZhdWx0VmFsdWUgPSBET01Qcm9wZXJ0eS5nZXREZWZhdWx0VmFsdWVGb3JQcm9wZXJ0eShcbiAgICAgICAgICBub2RlLm5vZGVOYW1lLFxuICAgICAgICAgIHByb3BOYW1lXG4gICAgICAgICk7XG4gICAgICAgIGlmICghRE9NUHJvcGVydHkuaGFzU2lkZUVmZmVjdHNbbmFtZV0gfHxcbiAgICAgICAgICAgIG5vZGVbcHJvcE5hbWVdICE9PSBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICBub2RlW3Byb3BOYW1lXSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIH0gZWxzZSBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICB3YXJuVW5rbm93blByb3BlcnR5KG5hbWUpO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERPTVByb3BlcnR5T3BlcmF0aW9ucztcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBEYW5nZXJcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuLypqc2xpbnQgZXZpbDogdHJ1ZSwgc3ViOiB0cnVlICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKFwiLi9FeGVjdXRpb25FbnZpcm9ubWVudFwiKTtcblxudmFyIGNyZWF0ZU5vZGVzRnJvbU1hcmt1cCA9IHJlcXVpcmUoXCIuL2NyZWF0ZU5vZGVzRnJvbU1hcmt1cFwiKTtcbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZShcIi4vZW1wdHlGdW5jdGlvblwiKTtcbnZhciBnZXRNYXJrdXBXcmFwID0gcmVxdWlyZShcIi4vZ2V0TWFya3VwV3JhcFwiKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbnZhciBPUEVOX1RBR19OQU1FX0VYUCA9IC9eKDxbXiBcXC8+XSspLztcbnZhciBSRVNVTFRfSU5ERVhfQVRUUiA9ICdkYXRhLWRhbmdlci1pbmRleCc7XG5cbi8qKlxuICogRXh0cmFjdHMgdGhlIGBub2RlTmFtZWAgZnJvbSBhIHN0cmluZyBvZiBtYXJrdXAuXG4gKlxuICogTk9URTogRXh0cmFjdGluZyB0aGUgYG5vZGVOYW1lYCBkb2VzIG5vdCByZXF1aXJlIGEgcmVndWxhciBleHByZXNzaW9uIG1hdGNoXG4gKiBiZWNhdXNlIHdlIG1ha2UgYXNzdW1wdGlvbnMgYWJvdXQgUmVhY3QtZ2VuZXJhdGVkIG1hcmt1cCAoaS5lLiB0aGVyZSBhcmUgbm9cbiAqIHNwYWNlcyBzdXJyb3VuZGluZyB0aGUgb3BlbmluZyB0YWcgYW5kIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBhdHRyaWJ1dGUpLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgU3RyaW5nIG9mIG1hcmt1cC5cbiAqIEByZXR1cm4ge3N0cmluZ30gTm9kZSBuYW1lIG9mIHRoZSBzdXBwbGllZCBtYXJrdXAuXG4gKiBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2V4dHJhY3Qtbm9kZW5hbWVcbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZU5hbWUobWFya3VwKSB7XG4gIHJldHVybiBtYXJrdXAuc3Vic3RyaW5nKDEsIG1hcmt1cC5pbmRleE9mKCcgJykpO1xufVxuXG52YXIgRGFuZ2VyID0ge1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIG1hcmt1cCBpbnRvIGFuIGFycmF5IG9mIG5vZGVzLiBUaGUgbWFya3VwIGlzIGV4cGVjdGVkIHRvIHJlbmRlclxuICAgKiBpbnRvIGEgbGlzdCBvZiByb290IG5vZGVzLiBBbHNvLCB0aGUgbGVuZ3RoIG9mIGByZXN1bHRMaXN0YCBhbmRcbiAgICogYG1hcmt1cExpc3RgIHNob3VsZCBiZSB0aGUgc2FtZS5cbiAgICpcbiAgICogQHBhcmFtIHthcnJheTxzdHJpbmc+fSBtYXJrdXBMaXN0IExpc3Qgb2YgbWFya3VwIHN0cmluZ3MgdG8gcmVuZGVyLlxuICAgKiBAcmV0dXJuIHthcnJheTxET01FbGVtZW50Pn0gTGlzdCBvZiByZW5kZXJlZCBub2Rlcy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBkYW5nZXJvdXNseVJlbmRlck1hcmt1cDogZnVuY3Rpb24obWFya3VwTGlzdCkge1xuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00sXG4gICAgICAnZGFuZ2Vyb3VzbHlSZW5kZXJNYXJrdXAoLi4uKTogQ2Fubm90IHJlbmRlciBtYXJrdXAgaW4gYSBXb3JrZXIgJyArXG4gICAgICAndGhyZWFkLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiB0aGUgZnJhbWV3b3JrLiBQbGVhc2UgcmVwb3J0ICcgK1xuICAgICAgJ2ltbWVkaWF0ZWx5LidcbiAgICApIDogaW52YXJpYW50KEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkpO1xuICAgIHZhciBub2RlTmFtZTtcbiAgICB2YXIgbWFya3VwQnlOb2RlTmFtZSA9IHt9O1xuICAgIC8vIEdyb3VwIG1hcmt1cCBieSBgbm9kZU5hbWVgIGlmIGEgd3JhcCBpcyBuZWNlc3NhcnksIGVsc2UgYnkgJyonLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya3VwTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICAgbWFya3VwTGlzdFtpXSxcbiAgICAgICAgJ2Rhbmdlcm91c2x5UmVuZGVyTWFya3VwKC4uLik6IE1pc3NpbmcgbWFya3VwLidcbiAgICAgICkgOiBpbnZhcmlhbnQobWFya3VwTGlzdFtpXSkpO1xuICAgICAgbm9kZU5hbWUgPSBnZXROb2RlTmFtZShtYXJrdXBMaXN0W2ldKTtcbiAgICAgIG5vZGVOYW1lID0gZ2V0TWFya3VwV3JhcChub2RlTmFtZSkgPyBub2RlTmFtZSA6ICcqJztcbiAgICAgIG1hcmt1cEJ5Tm9kZU5hbWVbbm9kZU5hbWVdID0gbWFya3VwQnlOb2RlTmFtZVtub2RlTmFtZV0gfHwgW107XG4gICAgICBtYXJrdXBCeU5vZGVOYW1lW25vZGVOYW1lXVtpXSA9IG1hcmt1cExpc3RbaV07XG4gICAgfVxuICAgIHZhciByZXN1bHRMaXN0ID0gW107XG4gICAgdmFyIHJlc3VsdExpc3RBc3NpZ25tZW50Q291bnQgPSAwO1xuICAgIGZvciAobm9kZU5hbWUgaW4gbWFya3VwQnlOb2RlTmFtZSkge1xuICAgICAgaWYgKCFtYXJrdXBCeU5vZGVOYW1lLmhhc093blByb3BlcnR5KG5vZGVOYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBtYXJrdXBMaXN0QnlOb2RlTmFtZSA9IG1hcmt1cEJ5Tm9kZU5hbWVbbm9kZU5hbWVdO1xuXG4gICAgICAvLyBUaGlzIGZvci1pbiBsb29wIHNraXBzIHRoZSBob2xlcyBvZiB0aGUgc3BhcnNlIGFycmF5LiBUaGUgb3JkZXIgb2ZcbiAgICAgIC8vIGl0ZXJhdGlvbiBzaG91bGQgZm9sbG93IHRoZSBvcmRlciBvZiBhc3NpZ25tZW50LCB3aGljaCBoYXBwZW5zIHRvIG1hdGNoXG4gICAgICAvLyBudW1lcmljYWwgaW5kZXggb3JkZXIsIGJ1dCB3ZSBkb24ndCByZWx5IG9uIHRoYXQuXG4gICAgICBmb3IgKHZhciByZXN1bHRJbmRleCBpbiBtYXJrdXBMaXN0QnlOb2RlTmFtZSkge1xuICAgICAgICBpZiAobWFya3VwTGlzdEJ5Tm9kZU5hbWUuaGFzT3duUHJvcGVydHkocmVzdWx0SW5kZXgpKSB7XG4gICAgICAgICAgdmFyIG1hcmt1cCA9IG1hcmt1cExpc3RCeU5vZGVOYW1lW3Jlc3VsdEluZGV4XTtcblxuICAgICAgICAgIC8vIFB1c2ggdGhlIHJlcXVlc3RlZCBtYXJrdXAgd2l0aCBhbiBhZGRpdGlvbmFsIFJFU1VMVF9JTkRFWF9BVFRSXG4gICAgICAgICAgLy8gYXR0cmlidXRlLiAgSWYgdGhlIG1hcmt1cCBkb2VzIG5vdCBzdGFydCB3aXRoIGEgPCBjaGFyYWN0ZXIsIGl0XG4gICAgICAgICAgLy8gd2lsbCBiZSBkaXNjYXJkZWQgYmVsb3cgKHdpdGggYW4gYXBwcm9wcmlhdGUgY29uc29sZS5lcnJvcikuXG4gICAgICAgICAgbWFya3VwTGlzdEJ5Tm9kZU5hbWVbcmVzdWx0SW5kZXhdID0gbWFya3VwLnJlcGxhY2UoXG4gICAgICAgICAgICBPUEVOX1RBR19OQU1FX0VYUCxcbiAgICAgICAgICAgIC8vIFRoaXMgaW5kZXggd2lsbCBiZSBwYXJzZWQgYmFjayBvdXQgYmVsb3cuXG4gICAgICAgICAgICAnJDEgJyArIFJFU1VMVF9JTkRFWF9BVFRSICsgJz1cIicgKyByZXN1bHRJbmRleCArICdcIiAnXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBSZW5kZXIgZWFjaCBncm91cCBvZiBtYXJrdXAgd2l0aCBzaW1pbGFyIHdyYXBwaW5nIGBub2RlTmFtZWAuXG4gICAgICB2YXIgcmVuZGVyTm9kZXMgPSBjcmVhdGVOb2Rlc0Zyb21NYXJrdXAoXG4gICAgICAgIG1hcmt1cExpc3RCeU5vZGVOYW1lLmpvaW4oJycpLFxuICAgICAgICBlbXB0eUZ1bmN0aW9uIC8vIERvIG5vdGhpbmcgc3BlY2lhbCB3aXRoIDxzY3JpcHQ+IHRhZ3MuXG4gICAgICApO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgcmVuZGVyTm9kZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHJlbmRlck5vZGUgPSByZW5kZXJOb2Rlc1tpXTtcbiAgICAgICAgaWYgKHJlbmRlck5vZGUuaGFzQXR0cmlidXRlICYmXG4gICAgICAgICAgICByZW5kZXJOb2RlLmhhc0F0dHJpYnV0ZShSRVNVTFRfSU5ERVhfQVRUUikpIHtcblxuICAgICAgICAgIHJlc3VsdEluZGV4ID0gK3JlbmRlck5vZGUuZ2V0QXR0cmlidXRlKFJFU1VMVF9JTkRFWF9BVFRSKTtcbiAgICAgICAgICByZW5kZXJOb2RlLnJlbW92ZUF0dHJpYnV0ZShSRVNVTFRfSU5ERVhfQVRUUik7XG5cbiAgICAgICAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgICAgICAgIXJlc3VsdExpc3QuaGFzT3duUHJvcGVydHkocmVzdWx0SW5kZXgpLFxuICAgICAgICAgICAgJ0RhbmdlcjogQXNzaWduaW5nIHRvIGFuIGFscmVhZHktb2NjdXBpZWQgcmVzdWx0IGluZGV4LidcbiAgICAgICAgICApIDogaW52YXJpYW50KCFyZXN1bHRMaXN0Lmhhc093blByb3BlcnR5KHJlc3VsdEluZGV4KSkpO1xuXG4gICAgICAgICAgcmVzdWx0TGlzdFtyZXN1bHRJbmRleF0gPSByZW5kZXJOb2RlO1xuXG4gICAgICAgICAgLy8gVGhpcyBzaG91bGQgbWF0Y2ggcmVzdWx0TGlzdC5sZW5ndGggYW5kIG1hcmt1cExpc3QubGVuZ3RoIHdoZW5cbiAgICAgICAgICAvLyB3ZSdyZSBkb25lLlxuICAgICAgICAgIHJlc3VsdExpc3RBc3NpZ25tZW50Q291bnQgKz0gMTtcblxuICAgICAgICB9IGVsc2UgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIkRhbmdlcjogRGlzY2FyZGluZyB1bmV4cGVjdGVkIG5vZGU6XCIsXG4gICAgICAgICAgICByZW5kZXJOb2RlXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFsdGhvdWdoIHJlc3VsdExpc3Qgd2FzIHBvcHVsYXRlZCBvdXQgb2Ygb3JkZXIsIGl0IHNob3VsZCBub3cgYmUgYSBkZW5zZVxuICAgIC8vIGFycmF5LlxuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICByZXN1bHRMaXN0QXNzaWdubWVudENvdW50ID09PSByZXN1bHRMaXN0Lmxlbmd0aCxcbiAgICAgICdEYW5nZXI6IERpZCBub3QgYXNzaWduIHRvIGV2ZXJ5IGluZGV4IG9mIHJlc3VsdExpc3QuJ1xuICAgICkgOiBpbnZhcmlhbnQocmVzdWx0TGlzdEFzc2lnbm1lbnRDb3VudCA9PT0gcmVzdWx0TGlzdC5sZW5ndGgpKTtcblxuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICByZXN1bHRMaXN0Lmxlbmd0aCA9PT0gbWFya3VwTGlzdC5sZW5ndGgsXG4gICAgICAnRGFuZ2VyOiBFeHBlY3RlZCBtYXJrdXAgdG8gcmVuZGVyICVzIG5vZGVzLCBidXQgcmVuZGVyZWQgJXMuJyxcbiAgICAgIG1hcmt1cExpc3QubGVuZ3RoLFxuICAgICAgcmVzdWx0TGlzdC5sZW5ndGhcbiAgICApIDogaW52YXJpYW50KHJlc3VsdExpc3QubGVuZ3RoID09PSBtYXJrdXBMaXN0Lmxlbmd0aCkpO1xuXG4gICAgcmV0dXJuIHJlc3VsdExpc3Q7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGEgbm9kZSB3aXRoIGEgc3RyaW5nIG9mIG1hcmt1cCBhdCBpdHMgY3VycmVudCBwb3NpdGlvbiB3aXRoaW4gaXRzXG4gICAqIHBhcmVudC4gVGhlIG1hcmt1cCBtdXN0IHJlbmRlciBpbnRvIGEgc2luZ2xlIHJvb3Qgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBvbGRDaGlsZCBDaGlsZCBub2RlIHRvIHJlcGxhY2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgTWFya3VwIHRvIHJlbmRlciBpbiBwbGFjZSBvZiB0aGUgY2hpbGQgbm9kZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cDogZnVuY3Rpb24ob2xkQ2hpbGQsIG1hcmt1cCkge1xuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00sXG4gICAgICAnZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAoLi4uKTogQ2Fubm90IHJlbmRlciBtYXJrdXAgaW4gYSAnICtcbiAgICAgICd3b3JrZXIgdGhyZWFkLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiB0aGUgZnJhbWV3b3JrLiBQbGVhc2UgcmVwb3J0ICcgK1xuICAgICAgJ2ltbWVkaWF0ZWx5LidcbiAgICApIDogaW52YXJpYW50KEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkpO1xuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQobWFya3VwLCAnZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAoLi4uKTogTWlzc2luZyBtYXJrdXAuJykgOiBpbnZhcmlhbnQobWFya3VwKSk7XG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgIG9sZENoaWxkLnRhZ05hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ2h0bWwnLFxuICAgICAgJ2Rhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwKC4uLik6IENhbm5vdCByZXBsYWNlIG1hcmt1cCBvZiB0aGUgJyArXG4gICAgICAnPGh0bWw+IG5vZGUuIFRoaXMgaXMgYmVjYXVzZSBicm93c2VyIHF1aXJrcyBtYWtlIHRoaXMgdW5yZWxpYWJsZSAnICtcbiAgICAgICdhbmQvb3Igc2xvdy4gSWYgeW91IHdhbnQgdG8gcmVuZGVyIHRvIHRoZSByb290IHlvdSBtdXN0IHVzZSAnICtcbiAgICAgICdzZXJ2ZXIgcmVuZGVyaW5nLiBTZWUgcmVuZGVyQ29tcG9uZW50VG9TdHJpbmcoKS4nXG4gICAgKSA6IGludmFyaWFudChvbGRDaGlsZC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdodG1sJykpO1xuXG4gICAgdmFyIG5ld0NoaWxkID0gY3JlYXRlTm9kZXNGcm9tTWFya3VwKG1hcmt1cCwgZW1wdHlGdW5jdGlvbilbMF07XG4gICAgb2xkQ2hpbGQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobmV3Q2hpbGQsIG9sZENoaWxkKTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhbmdlcjtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERlZmF1bHRFdmVudFBsdWdpbk9yZGVyXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbiB2YXIga2V5T2YgPSByZXF1aXJlKFwiLi9rZXlPZlwiKTtcblxuLyoqXG4gKiBNb2R1bGUgdGhhdCBpcyBpbmplY3RhYmxlIGludG8gYEV2ZW50UGx1Z2luSHViYCwgdGhhdCBzcGVjaWZpZXMgYVxuICogZGV0ZXJtaW5pc3RpYyBvcmRlcmluZyBvZiBgRXZlbnRQbHVnaW5gcy4gQSBjb252ZW5pZW50IHdheSB0byByZWFzb24gYWJvdXRcbiAqIHBsdWdpbnMsIHdpdGhvdXQgaGF2aW5nIHRvIHBhY2thZ2UgZXZlcnkgb25lIG9mIHRoZW0uIFRoaXMgaXMgYmV0dGVyIHRoYW5cbiAqIGhhdmluZyBwbHVnaW5zIGJlIG9yZGVyZWQgaW4gdGhlIHNhbWUgb3JkZXIgdGhhdCB0aGV5IGFyZSBpbmplY3RlZCBiZWNhdXNlXG4gKiB0aGF0IG9yZGVyaW5nIHdvdWxkIGJlIGluZmx1ZW5jZWQgYnkgdGhlIHBhY2thZ2luZyBvcmRlci5cbiAqIGBSZXNwb25kZXJFdmVudFBsdWdpbmAgbXVzdCBvY2N1ciBiZWZvcmUgYFNpbXBsZUV2ZW50UGx1Z2luYCBzbyB0aGF0XG4gKiBwcmV2ZW50aW5nIGRlZmF1bHQgb24gZXZlbnRzIGlzIGNvbnZlbmllbnQgaW4gYFNpbXBsZUV2ZW50UGx1Z2luYCBoYW5kbGVycy5cbiAqL1xudmFyIERlZmF1bHRFdmVudFBsdWdpbk9yZGVyID0gW1xuICBrZXlPZih7UmVzcG9uZGVyRXZlbnRQbHVnaW46IG51bGx9KSxcbiAga2V5T2Yoe1NpbXBsZUV2ZW50UGx1Z2luOiBudWxsfSksXG4gIGtleU9mKHtUYXBFdmVudFBsdWdpbjogbnVsbH0pLFxuICBrZXlPZih7RW50ZXJMZWF2ZUV2ZW50UGx1Z2luOiBudWxsfSksXG4gIGtleU9mKHtDaGFuZ2VFdmVudFBsdWdpbjogbnVsbH0pLFxuICBrZXlPZih7U2VsZWN0RXZlbnRQbHVnaW46IG51bGx9KSxcbiAga2V5T2Yoe0NvbXBvc2l0aW9uRXZlbnRQbHVnaW46IG51bGx9KSxcbiAga2V5T2Yoe0JlZm9yZUlucHV0RXZlbnRQbHVnaW46IG51bGx9KSxcbiAga2V5T2Yoe0FuYWx5dGljc0V2ZW50UGx1Z2luOiBudWxsfSksXG4gIGtleU9mKHtNb2JpbGVTYWZhcmlDbGlja0V2ZW50UGx1Z2luOiBudWxsfSlcbl07XG5cbm1vZHVsZS5leHBvcnRzID0gRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXI7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKFwiLi9FdmVudENvbnN0YW50c1wiKTtcbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZShcIi4vRXZlbnRQcm9wYWdhdG9yc1wiKTtcbnZhciBTeW50aGV0aWNNb3VzZUV2ZW50ID0gcmVxdWlyZShcIi4vU3ludGhldGljTW91c2VFdmVudFwiKTtcblxudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKFwiLi9SZWFjdE1vdW50XCIpO1xudmFyIGtleU9mID0gcmVxdWlyZShcIi4va2V5T2ZcIik7XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcbnZhciBnZXRGaXJzdFJlYWN0RE9NID0gUmVhY3RNb3VudC5nZXRGaXJzdFJlYWN0RE9NO1xuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgbW91c2VFbnRlcjoge1xuICAgIHJlZ2lzdHJhdGlvbk5hbWU6IGtleU9mKHtvbk1vdXNlRW50ZXI6IG51bGx9KSxcbiAgICBkZXBlbmRlbmNpZXM6IFtcbiAgICAgIHRvcExldmVsVHlwZXMudG9wTW91c2VPdXQsXG4gICAgICB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3ZlclxuICAgIF1cbiAgfSxcbiAgbW91c2VMZWF2ZToge1xuICAgIHJlZ2lzdHJhdGlvbk5hbWU6IGtleU9mKHtvbk1vdXNlTGVhdmU6IG51bGx9KSxcbiAgICBkZXBlbmRlbmNpZXM6IFtcbiAgICAgIHRvcExldmVsVHlwZXMudG9wTW91c2VPdXQsXG4gICAgICB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3ZlclxuICAgIF1cbiAgfVxufTtcblxudmFyIGV4dHJhY3RlZEV2ZW50cyA9IFtudWxsLCBudWxsXTtcblxudmFyIEVudGVyTGVhdmVFdmVudFBsdWdpbiA9IHtcblxuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxuXG4gIC8qKlxuICAgKiBGb3IgYWxtb3N0IGV2ZXJ5IGludGVyYWN0aW9uIHdlIGNhcmUgYWJvdXQsIHRoZXJlIHdpbGwgYmUgYm90aCBhIHRvcC1sZXZlbFxuICAgKiBgbW91c2VvdmVyYCBhbmQgYG1vdXNlb3V0YCBldmVudCB0aGF0IG9jY3Vycy4gT25seSB1c2UgYG1vdXNlb3V0YCBzbyB0aGF0XG4gICAqIHdlIGRvIG5vdCBleHRyYWN0IGR1cGxpY2F0ZSBldmVudHMuIEhvd2V2ZXIsIG1vdmluZyB0aGUgbW91c2UgaW50byB0aGVcbiAgICogYnJvd3NlciBmcm9tIG91dHNpZGUgd2lsbCBub3QgZmlyZSBhIGBtb3VzZW91dGAgZXZlbnQuIEluIHRoaXMgY2FzZSwgd2UgdXNlXG4gICAqIHRoZSBgbW91c2VvdmVyYCB0b3AtbGV2ZWwgZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdG9wTGV2ZWxUYXJnZXQgVGhlIGxpc3RlbmluZyBjb21wb25lbnQgcm9vdCBub2RlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUYXJnZXRJRCBJRCBvZiBgdG9wTGV2ZWxUYXJnZXRgLlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gICAqIEByZXR1cm4geyp9IEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxuICAgKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5leHRyYWN0RXZlbnRzfVxuICAgKi9cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24oXG4gICAgICB0b3BMZXZlbFR5cGUsXG4gICAgICB0b3BMZXZlbFRhcmdldCxcbiAgICAgIHRvcExldmVsVGFyZ2V0SUQsXG4gICAgICBuYXRpdmVFdmVudCkge1xuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wTW91c2VPdmVyICYmXG4gICAgICAgIChuYXRpdmVFdmVudC5yZWxhdGVkVGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LmZyb21FbGVtZW50KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0b3BMZXZlbFR5cGUgIT09IHRvcExldmVsVHlwZXMudG9wTW91c2VPdXQgJiZcbiAgICAgICAgdG9wTGV2ZWxUeXBlICE9PSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3Zlcikge1xuICAgICAgLy8gTXVzdCBub3QgYmUgYSBtb3VzZSBpbiBvciBtb3VzZSBvdXQgLSBpZ25vcmluZy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciB3aW47XG4gICAgaWYgKHRvcExldmVsVGFyZ2V0LndpbmRvdyA9PT0gdG9wTGV2ZWxUYXJnZXQpIHtcbiAgICAgIC8vIGB0b3BMZXZlbFRhcmdldGAgaXMgcHJvYmFibHkgYSB3aW5kb3cgb2JqZWN0LlxuICAgICAgd2luID0gdG9wTGV2ZWxUYXJnZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRPRE86IEZpZ3VyZSBvdXQgd2h5IGBvd25lckRvY3VtZW50YCBpcyBzb21ldGltZXMgdW5kZWZpbmVkIGluIElFOC5cbiAgICAgIHZhciBkb2MgPSB0b3BMZXZlbFRhcmdldC5vd25lckRvY3VtZW50O1xuICAgICAgaWYgKGRvYykge1xuICAgICAgICB3aW4gPSBkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbiA9IHdpbmRvdztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZnJvbSwgdG87XG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU91dCkge1xuICAgICAgZnJvbSA9IHRvcExldmVsVGFyZ2V0O1xuICAgICAgdG8gPVxuICAgICAgICBnZXRGaXJzdFJlYWN0RE9NKG5hdGl2ZUV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgbmF0aXZlRXZlbnQudG9FbGVtZW50KSB8fFxuICAgICAgICB3aW47XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyb20gPSB3aW47XG4gICAgICB0byA9IHRvcExldmVsVGFyZ2V0O1xuICAgIH1cblxuICAgIGlmIChmcm9tID09PSB0bykge1xuICAgICAgLy8gTm90aGluZyBwZXJ0YWlucyB0byBvdXIgbWFuYWdlZCBjb21wb25lbnRzLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGZyb21JRCA9IGZyb20gPyBSZWFjdE1vdW50LmdldElEKGZyb20pIDogJyc7XG4gICAgdmFyIHRvSUQgPSB0byA/IFJlYWN0TW91bnQuZ2V0SUQodG8pIDogJyc7XG5cbiAgICB2YXIgbGVhdmUgPSBTeW50aGV0aWNNb3VzZUV2ZW50LmdldFBvb2xlZChcbiAgICAgIGV2ZW50VHlwZXMubW91c2VMZWF2ZSxcbiAgICAgIGZyb21JRCxcbiAgICAgIG5hdGl2ZUV2ZW50XG4gICAgKTtcbiAgICBsZWF2ZS50eXBlID0gJ21vdXNlbGVhdmUnO1xuICAgIGxlYXZlLnRhcmdldCA9IGZyb207XG4gICAgbGVhdmUucmVsYXRlZFRhcmdldCA9IHRvO1xuXG4gICAgdmFyIGVudGVyID0gU3ludGhldGljTW91c2VFdmVudC5nZXRQb29sZWQoXG4gICAgICBldmVudFR5cGVzLm1vdXNlRW50ZXIsXG4gICAgICB0b0lELFxuICAgICAgbmF0aXZlRXZlbnRcbiAgICApO1xuICAgIGVudGVyLnR5cGUgPSAnbW91c2VlbnRlcic7XG4gICAgZW50ZXIudGFyZ2V0ID0gdG87XG4gICAgZW50ZXIucmVsYXRlZFRhcmdldCA9IGZyb207XG5cbiAgICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlcyhsZWF2ZSwgZW50ZXIsIGZyb21JRCwgdG9JRCk7XG5cbiAgICBleHRyYWN0ZWRFdmVudHNbMF0gPSBsZWF2ZTtcbiAgICBleHRyYWN0ZWRFdmVudHNbMV0gPSBlbnRlcjtcblxuICAgIHJldHVybiBleHRyYWN0ZWRFdmVudHM7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFbnRlckxlYXZlRXZlbnRQbHVnaW47XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRXZlbnRDb25zdGFudHNcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGtleU1pcnJvciA9IHJlcXVpcmUoXCIuL2tleU1pcnJvclwiKTtcblxudmFyIFByb3BhZ2F0aW9uUGhhc2VzID0ga2V5TWlycm9yKHtidWJibGVkOiBudWxsLCBjYXB0dXJlZDogbnVsbH0pO1xuXG4vKipcbiAqIFR5cGVzIG9mIHJhdyBzaWduYWxzIGZyb20gdGhlIGJyb3dzZXIgY2F1Z2h0IGF0IHRoZSB0b3AgbGV2ZWwuXG4gKi9cbnZhciB0b3BMZXZlbFR5cGVzID0ga2V5TWlycm9yKHtcbiAgdG9wQmx1cjogbnVsbCxcbiAgdG9wQ2hhbmdlOiBudWxsLFxuICB0b3BDbGljazogbnVsbCxcbiAgdG9wQ29tcG9zaXRpb25FbmQ6IG51bGwsXG4gIHRvcENvbXBvc2l0aW9uU3RhcnQ6IG51bGwsXG4gIHRvcENvbXBvc2l0aW9uVXBkYXRlOiBudWxsLFxuICB0b3BDb250ZXh0TWVudTogbnVsbCxcbiAgdG9wQ29weTogbnVsbCxcbiAgdG9wQ3V0OiBudWxsLFxuICB0b3BEb3VibGVDbGljazogbnVsbCxcbiAgdG9wRHJhZzogbnVsbCxcbiAgdG9wRHJhZ0VuZDogbnVsbCxcbiAgdG9wRHJhZ0VudGVyOiBudWxsLFxuICB0b3BEcmFnRXhpdDogbnVsbCxcbiAgdG9wRHJhZ0xlYXZlOiBudWxsLFxuICB0b3BEcmFnT3ZlcjogbnVsbCxcbiAgdG9wRHJhZ1N0YXJ0OiBudWxsLFxuICB0b3BEcm9wOiBudWxsLFxuICB0b3BFcnJvcjogbnVsbCxcbiAgdG9wRm9jdXM6IG51bGwsXG4gIHRvcElucHV0OiBudWxsLFxuICB0b3BLZXlEb3duOiBudWxsLFxuICB0b3BLZXlQcmVzczogbnVsbCxcbiAgdG9wS2V5VXA6IG51bGwsXG4gIHRvcExvYWQ6IG51bGwsXG4gIHRvcE1vdXNlRG93bjogbnVsbCxcbiAgdG9wTW91c2VNb3ZlOiBudWxsLFxuICB0b3BNb3VzZU91dDogbnVsbCxcbiAgdG9wTW91c2VPdmVyOiBudWxsLFxuICB0b3BNb3VzZVVwOiBudWxsLFxuICB0b3BQYXN0ZTogbnVsbCxcbiAgdG9wUmVzZXQ6IG51bGwsXG4gIHRvcFNjcm9sbDogbnVsbCxcbiAgdG9wU2VsZWN0aW9uQ2hhbmdlOiBudWxsLFxuICB0b3BTdWJtaXQ6IG51bGwsXG4gIHRvcFRleHRJbnB1dDogbnVsbCxcbiAgdG9wVG91Y2hDYW5jZWw6IG51bGwsXG4gIHRvcFRvdWNoRW5kOiBudWxsLFxuICB0b3BUb3VjaE1vdmU6IG51bGwsXG4gIHRvcFRvdWNoU3RhcnQ6IG51bGwsXG4gIHRvcFdoZWVsOiBudWxsXG59KTtcblxudmFyIEV2ZW50Q29uc3RhbnRzID0ge1xuICB0b3BMZXZlbFR5cGVzOiB0b3BMZXZlbFR5cGVzLFxuICBQcm9wYWdhdGlvblBoYXNlczogUHJvcGFnYXRpb25QaGFzZXNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRDb25zdGFudHM7XG4iLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRXZlbnRMaXN0ZW5lclxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoXCIuL2VtcHR5RnVuY3Rpb25cIik7XG5cbi8qKlxuICogVXBzdHJlYW0gdmVyc2lvbiBvZiBldmVudCBsaXN0ZW5lci4gRG9lcyBub3QgdGFrZSBpbnRvIGFjY291bnQgc3BlY2lmaWNcbiAqIG5hdHVyZSBvZiBwbGF0Zm9ybS5cbiAqL1xudmFyIEV2ZW50TGlzdGVuZXIgPSB7XG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8gRE9NIGV2ZW50cyBkdXJpbmcgdGhlIGJ1YmJsZSBwaGFzZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdGFyZ2V0IERPTSBlbGVtZW50IHRvIHJlZ2lzdGVyIGxpc3RlbmVyIG9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIEV2ZW50IHR5cGUsIGUuZy4gJ2NsaWNrJyBvciAnbW91c2VvdmVyJy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IHdpdGggYSBgcmVtb3ZlYCBtZXRob2QuXG4gICAqL1xuICBsaXN0ZW46IGZ1bmN0aW9uKHRhcmdldCwgZXZlbnRUeXBlLCBjYWxsYmFjaykge1xuICAgIGlmICh0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0YXJnZXQuYXR0YWNoRXZlbnQpIHtcbiAgICAgIHRhcmdldC5hdHRhY2hFdmVudCgnb24nICsgZXZlbnRUeXBlLCBjYWxsYmFjayk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRhcmdldC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnRUeXBlLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8gRE9NIGV2ZW50cyBkdXJpbmcgdGhlIGNhcHR1cmUgcGhhc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRhcmdldCBET00gZWxlbWVudCB0byByZWdpc3RlciBsaXN0ZW5lciBvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSBFdmVudCB0eXBlLCBlLmcuICdjbGljaycgb3IgJ21vdXNlb3ZlcicuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCB3aXRoIGEgYHJlbW92ZWAgbWV0aG9kLlxuICAgKi9cbiAgY2FwdHVyZTogZnVuY3Rpb24odGFyZ2V0LCBldmVudFR5cGUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICdBdHRlbXB0ZWQgdG8gbGlzdGVuIHRvIGV2ZW50cyBkdXJpbmcgdGhlIGNhcHR1cmUgcGhhc2Ugb24gYSAnICtcbiAgICAgICAgICAnYnJvd3NlciB0aGF0IGRvZXMgbm90IHN1cHBvcnQgdGhlIGNhcHR1cmUgcGhhc2UuIFlvdXIgYXBwbGljYXRpb24gJyArXG4gICAgICAgICAgJ3dpbGwgbm90IHJlY2VpdmUgc29tZSBldmVudHMuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBlbXB0eUZ1bmN0aW9uXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCB0cnVlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9LFxuXG4gIHJlZ2lzdGVyRGVmYXVsdDogZnVuY3Rpb24oKSB7fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudExpc3RlbmVyO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEV2ZW50UGx1Z2luSHViXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0gcmVxdWlyZShcIi4vRXZlbnRQbHVnaW5SZWdpc3RyeVwiKTtcbnZhciBFdmVudFBsdWdpblV0aWxzID0gcmVxdWlyZShcIi4vRXZlbnRQbHVnaW5VdGlsc1wiKTtcblxudmFyIGFjY3VtdWxhdGUgPSByZXF1aXJlKFwiLi9hY2N1bXVsYXRlXCIpO1xudmFyIGZvckVhY2hBY2N1bXVsYXRlZCA9IHJlcXVpcmUoXCIuL2ZvckVhY2hBY2N1bXVsYXRlZFwiKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG52YXIgaXNFdmVudFN1cHBvcnRlZCA9IHJlcXVpcmUoXCIuL2lzRXZlbnRTdXBwb3J0ZWRcIik7XG52YXIgbW9uaXRvckNvZGVVc2UgPSByZXF1aXJlKFwiLi9tb25pdG9yQ29kZVVzZVwiKTtcblxuLyoqXG4gKiBJbnRlcm5hbCBzdG9yZSBmb3IgZXZlbnQgbGlzdGVuZXJzXG4gKi9cbnZhciBsaXN0ZW5lckJhbmsgPSB7fTtcblxuLyoqXG4gKiBJbnRlcm5hbCBxdWV1ZSBvZiBldmVudHMgdGhhdCBoYXZlIGFjY3VtdWxhdGVkIHRoZWlyIGRpc3BhdGNoZXMgYW5kIGFyZVxuICogd2FpdGluZyB0byBoYXZlIHRoZWlyIGRpc3BhdGNoZXMgZXhlY3V0ZWQuXG4gKi9cbnZhciBldmVudFF1ZXVlID0gbnVsbDtcblxuLyoqXG4gKiBEaXNwYXRjaGVzIGFuIGV2ZW50IGFuZCByZWxlYXNlcyBpdCBiYWNrIGludG8gdGhlIHBvb2wsIHVubGVzcyBwZXJzaXN0ZW50LlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gZXZlbnQgU3ludGhldGljIGV2ZW50IHRvIGJlIGRpc3BhdGNoZWQuXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgaWYgKGV2ZW50KSB7XG4gICAgdmFyIGV4ZWN1dGVEaXNwYXRjaCA9IEV2ZW50UGx1Z2luVXRpbHMuZXhlY3V0ZURpc3BhdGNoO1xuICAgIC8vIFBsdWdpbnMgY2FuIHByb3ZpZGUgY3VzdG9tIGJlaGF2aW9yIHdoZW4gZGlzcGF0Y2hpbmcgZXZlbnRzLlxuICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LmdldFBsdWdpbk1vZHVsZUZvckV2ZW50KGV2ZW50KTtcbiAgICBpZiAoUGx1Z2luTW9kdWxlICYmIFBsdWdpbk1vZHVsZS5leGVjdXRlRGlzcGF0Y2gpIHtcbiAgICAgIGV4ZWN1dGVEaXNwYXRjaCA9IFBsdWdpbk1vZHVsZS5leGVjdXRlRGlzcGF0Y2g7XG4gICAgfVxuICAgIEV2ZW50UGx1Z2luVXRpbHMuZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyKGV2ZW50LCBleGVjdXRlRGlzcGF0Y2gpO1xuXG4gICAgaWYgKCFldmVudC5pc1BlcnNpc3RlbnQoKSkge1xuICAgICAgZXZlbnQuY29uc3RydWN0b3IucmVsZWFzZShldmVudCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIC0gYEluc3RhbmNlSGFuZGxlYDogW3JlcXVpcmVkXSBNb2R1bGUgdGhhdCBwZXJmb3JtcyBsb2dpY2FsIHRyYXZlcnNhbHMgb2YgRE9NXG4gKiAgIGhpZXJhcmNoeSBnaXZlbiBpZHMgb2YgdGhlIGxvZ2ljYWwgRE9NIGVsZW1lbnRzIGludm9sdmVkLlxuICovXG52YXIgSW5zdGFuY2VIYW5kbGUgPSBudWxsO1xuXG5mdW5jdGlvbiB2YWxpZGF0ZUluc3RhbmNlSGFuZGxlKCkge1xuICB2YXIgaW52YWxpZCA9ICFJbnN0YW5jZUhhbmRsZXx8XG4gICAgIUluc3RhbmNlSGFuZGxlLnRyYXZlcnNlVHdvUGhhc2UgfHxcbiAgICAhSW5zdGFuY2VIYW5kbGUudHJhdmVyc2VFbnRlckxlYXZlO1xuICBpZiAoaW52YWxpZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5zdGFuY2VIYW5kbGUgbm90IGluamVjdGVkIGJlZm9yZSB1c2UhJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGlzIGEgdW5pZmllZCBpbnRlcmZhY2UgZm9yIGV2ZW50IHBsdWdpbnMgdG8gYmUgaW5zdGFsbGVkIGFuZCBjb25maWd1cmVkLlxuICpcbiAqIEV2ZW50IHBsdWdpbnMgY2FuIGltcGxlbWVudCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICBgZXh0cmFjdEV2ZW50c2Age2Z1bmN0aW9uKHN0cmluZywgRE9NRXZlbnRUYXJnZXQsIHN0cmluZywgb2JqZWN0KTogKn1cbiAqICAgICBSZXF1aXJlZC4gV2hlbiBhIHRvcC1sZXZlbCBldmVudCBpcyBmaXJlZCwgdGhpcyBtZXRob2QgaXMgZXhwZWN0ZWQgdG9cbiAqICAgICBleHRyYWN0IHN5bnRoZXRpYyBldmVudHMgdGhhdCB3aWxsIGluIHR1cm4gYmUgcXVldWVkIGFuZCBkaXNwYXRjaGVkLlxuICpcbiAqICAgYGV2ZW50VHlwZXNgIHtvYmplY3R9XG4gKiAgICAgT3B0aW9uYWwsIHBsdWdpbnMgdGhhdCBmaXJlIGV2ZW50cyBtdXN0IHB1Ymxpc2ggYSBtYXBwaW5nIG9mIHJlZ2lzdHJhdGlvblxuICogICAgIG5hbWVzIHRoYXQgYXJlIHVzZWQgdG8gcmVnaXN0ZXIgbGlzdGVuZXJzLiBWYWx1ZXMgb2YgdGhpcyBtYXBwaW5nIG11c3RcbiAqICAgICBiZSBvYmplY3RzIHRoYXQgY29udGFpbiBgcmVnaXN0cmF0aW9uTmFtZWAgb3IgYHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzYC5cbiAqXG4gKiAgIGBleGVjdXRlRGlzcGF0Y2hgIHtmdW5jdGlvbihvYmplY3QsIGZ1bmN0aW9uLCBzdHJpbmcpfVxuICogICAgIE9wdGlvbmFsLCBhbGxvd3MgcGx1Z2lucyB0byBvdmVycmlkZSBob3cgYW4gZXZlbnQgZ2V0cyBkaXNwYXRjaGVkLiBCeVxuICogICAgIGRlZmF1bHQsIHRoZSBsaXN0ZW5lciBpcyBzaW1wbHkgaW52b2tlZC5cbiAqXG4gKiBFYWNoIHBsdWdpbiB0aGF0IGlzIGluamVjdGVkIGludG8gYEV2ZW50c1BsdWdpbkh1YmAgaXMgaW1tZWRpYXRlbHkgb3BlcmFibGUuXG4gKlxuICogQHB1YmxpY1xuICovXG52YXIgRXZlbnRQbHVnaW5IdWIgPSB7XG5cbiAgLyoqXG4gICAqIE1ldGhvZHMgZm9yIGluamVjdGluZyBkZXBlbmRlbmNpZXMuXG4gICAqL1xuICBpbmplY3Rpb246IHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBJbmplY3RlZE1vdW50XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGluamVjdE1vdW50OiBFdmVudFBsdWdpblV0aWxzLmluamVjdGlvbi5pbmplY3RNb3VudCxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBJbmplY3RlZEluc3RhbmNlSGFuZGxlXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGluamVjdEluc3RhbmNlSGFuZGxlOiBmdW5jdGlvbihJbmplY3RlZEluc3RhbmNlSGFuZGxlKSB7XG4gICAgICBJbnN0YW5jZUhhbmRsZSA9IEluamVjdGVkSW5zdGFuY2VIYW5kbGU7XG4gICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAgIHZhbGlkYXRlSW5zdGFuY2VIYW5kbGUoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0SW5zdGFuY2VIYW5kbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgICB2YWxpZGF0ZUluc3RhbmNlSGFuZGxlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gSW5zdGFuY2VIYW5kbGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7YXJyYXl9IEluamVjdGVkRXZlbnRQbHVnaW5PcmRlclxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBpbmplY3RFdmVudFBsdWdpbk9yZGVyOiBFdmVudFBsdWdpblJlZ2lzdHJ5LmluamVjdEV2ZW50UGx1Z2luT3JkZXIsXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gaW5qZWN0ZWROYW1lc1RvUGx1Z2lucyBNYXAgZnJvbSBuYW1lcyB0byBwbHVnaW4gbW9kdWxlcy5cbiAgICAgKi9cbiAgICBpbmplY3RFdmVudFBsdWdpbnNCeU5hbWU6IEV2ZW50UGx1Z2luUmVnaXN0cnkuaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lXG5cbiAgfSxcblxuICBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3M6IEV2ZW50UGx1Z2luUmVnaXN0cnkuZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzLFxuXG4gIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzOiBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLFxuXG4gIC8qKlxuICAgKiBTdG9yZXMgYGxpc3RlbmVyYCBhdCBgbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdW2lkXWAuIElzIGlkZW1wb3RlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiB0aGUgRE9NIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGxpc3RlbmVyIFRoZSBjYWxsYmFjayB0byBzdG9yZS5cbiAgICovXG4gIHB1dExpc3RlbmVyOiBmdW5jdGlvbihpZCwgcmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpIHtcbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgIWxpc3RlbmVyIHx8IHR5cGVvZiBsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJyxcbiAgICAgICdFeHBlY3RlZCAlcyBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLCBpbnN0ZWFkIGdvdCB0eXBlICVzJyxcbiAgICAgIHJlZ2lzdHJhdGlvbk5hbWUsIHR5cGVvZiBsaXN0ZW5lclxuICAgICkgOiBpbnZhcmlhbnQoIWxpc3RlbmVyIHx8IHR5cGVvZiBsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykpO1xuXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgLy8gSUU4IGhhcyBubyBBUEkgZm9yIGV2ZW50IGNhcHR1cmluZyBhbmQgdGhlIGBvblNjcm9sbGAgZXZlbnQgZG9lc24ndFxuICAgICAgLy8gYnViYmxlLlxuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgPT09ICdvblNjcm9sbCcgJiZcbiAgICAgICAgICAhaXNFdmVudFN1cHBvcnRlZCgnc2Nyb2xsJywgdHJ1ZSkpIHtcbiAgICAgICAgbW9uaXRvckNvZGVVc2UoJ3JlYWN0X25vX3Njcm9sbF9ldmVudCcpO1xuICAgICAgICBjb25zb2xlLndhcm4oJ1RoaXMgYnJvd3NlciBkb2VzblxcJ3Qgc3VwcG9ydCB0aGUgYG9uU2Nyb2xsYCBldmVudCcpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUgPVxuICAgICAgbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdIHx8IChsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV0gPSB7fSk7XG4gICAgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWVbaWRdID0gbGlzdGVuZXI7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiB0aGUgRE9NIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAgICogQHJldHVybiB7P2Z1bmN0aW9ufSBUaGUgc3RvcmVkIGNhbGxiYWNrLlxuICAgKi9cbiAgZ2V0TGlzdGVuZXI6IGZ1bmN0aW9uKGlkLCByZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgdmFyIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lID0gbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgIHJldHVybiBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSAmJiBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZVtpZF07XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgYSBsaXN0ZW5lciBmcm9tIHRoZSByZWdpc3RyYXRpb24gYmFuay5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIElEIG9mIHRoZSBET00gZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgTmFtZSBvZiBsaXN0ZW5lciAoZS5nLiBgb25DbGlja2ApLlxuICAgKi9cbiAgZGVsZXRlTGlzdGVuZXI6IGZ1bmN0aW9uKGlkLCByZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgdmFyIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lID0gbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgIGlmIChiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSkge1xuICAgICAgZGVsZXRlIGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lW2lkXTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgYWxsIGxpc3RlbmVycyBmb3IgdGhlIERPTSBlbGVtZW50IHdpdGggdGhlIHN1cHBsaWVkIElELlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgb2YgdGhlIERPTSBlbGVtZW50LlxuICAgKi9cbiAgZGVsZXRlQWxsTGlzdGVuZXJzOiBmdW5jdGlvbihpZCkge1xuICAgIGZvciAodmFyIHJlZ2lzdHJhdGlvbk5hbWUgaW4gbGlzdGVuZXJCYW5rKSB7XG4gICAgICBkZWxldGUgbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdW2lkXTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFsbG93cyByZWdpc3RlcmVkIHBsdWdpbnMgYW4gb3Bwb3J0dW5pdHkgdG8gZXh0cmFjdCBldmVudHMgZnJvbSB0b3AtbGV2ZWxcbiAgICogbmF0aXZlIGJyb3dzZXIgZXZlbnRzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRvcExldmVsVGFyZ2V0IFRoZSBsaXN0ZW5pbmcgY29tcG9uZW50IHJvb3Qgbm9kZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVGFyZ2V0SUQgSUQgb2YgYHRvcExldmVsVGFyZ2V0YC5cbiAgICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICAgKiBAcmV0dXJuIHsqfSBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbihcbiAgICAgIHRvcExldmVsVHlwZSxcbiAgICAgIHRvcExldmVsVGFyZ2V0LFxuICAgICAgdG9wTGV2ZWxUYXJnZXRJRCxcbiAgICAgIG5hdGl2ZUV2ZW50KSB7XG4gICAgdmFyIGV2ZW50cztcbiAgICB2YXIgcGx1Z2lucyA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucGx1Z2lucztcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHBsdWdpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAvLyBOb3QgZXZlcnkgcGx1Z2luIGluIHRoZSBvcmRlcmluZyBtYXkgYmUgbG9hZGVkIGF0IHJ1bnRpbWUuXG4gICAgICB2YXIgcG9zc2libGVQbHVnaW4gPSBwbHVnaW5zW2ldO1xuICAgICAgaWYgKHBvc3NpYmxlUGx1Z2luKSB7XG4gICAgICAgIHZhciBleHRyYWN0ZWRFdmVudHMgPSBwb3NzaWJsZVBsdWdpbi5leHRyYWN0RXZlbnRzKFxuICAgICAgICAgIHRvcExldmVsVHlwZSxcbiAgICAgICAgICB0b3BMZXZlbFRhcmdldCxcbiAgICAgICAgICB0b3BMZXZlbFRhcmdldElELFxuICAgICAgICAgIG5hdGl2ZUV2ZW50XG4gICAgICAgICk7XG4gICAgICAgIGlmIChleHRyYWN0ZWRFdmVudHMpIHtcbiAgICAgICAgICBldmVudHMgPSBhY2N1bXVsYXRlKGV2ZW50cywgZXh0cmFjdGVkRXZlbnRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXZlbnRzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIHN5bnRoZXRpYyBldmVudCB0aGF0IHNob3VsZCBiZSBkaXNwYXRjaGVkIHdoZW5cbiAgICogYHByb2Nlc3NFdmVudFF1ZXVlYCBpcyBpbnZva2VkLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGV2ZW50cyBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRXZlbnRzOiBmdW5jdGlvbihldmVudHMpIHtcbiAgICBpZiAoZXZlbnRzKSB7XG4gICAgICBldmVudFF1ZXVlID0gYWNjdW11bGF0ZShldmVudFF1ZXVlLCBldmVudHMpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBhbGwgc3ludGhldGljIGV2ZW50cyBvbiB0aGUgZXZlbnQgcXVldWUuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJvY2Vzc0V2ZW50UXVldWU6IGZ1bmN0aW9uKCkge1xuICAgIC8vIFNldCBgZXZlbnRRdWV1ZWAgdG8gbnVsbCBiZWZvcmUgcHJvY2Vzc2luZyBpdCBzbyB0aGF0IHdlIGNhbiB0ZWxsIGlmIG1vcmVcbiAgICAvLyBldmVudHMgZ2V0IGVucXVldWVkIHdoaWxlIHByb2Nlc3NpbmcuXG4gICAgdmFyIHByb2Nlc3NpbmdFdmVudFF1ZXVlID0gZXZlbnRRdWV1ZTtcbiAgICBldmVudFF1ZXVlID0gbnVsbDtcbiAgICBmb3JFYWNoQWNjdW11bGF0ZWQocHJvY2Vzc2luZ0V2ZW50UXVldWUsIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZSk7XG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICFldmVudFF1ZXVlLFxuICAgICAgJ3Byb2Nlc3NFdmVudFF1ZXVlKCk6IEFkZGl0aW9uYWwgZXZlbnRzIHdlcmUgZW5xdWV1ZWQgd2hpbGUgcHJvY2Vzc2luZyAnICtcbiAgICAgICdhbiBldmVudCBxdWV1ZS4gU3VwcG9ydCBmb3IgdGhpcyBoYXMgbm90IHlldCBiZWVuIGltcGxlbWVudGVkLidcbiAgICApIDogaW52YXJpYW50KCFldmVudFF1ZXVlKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoZXNlIGFyZSBuZWVkZWQgZm9yIHRlc3RzIG9ubHkuIERvIG5vdCB1c2UhXG4gICAqL1xuICBfX3B1cmdlOiBmdW5jdGlvbigpIHtcbiAgICBsaXN0ZW5lckJhbmsgPSB7fTtcbiAgfSxcblxuICBfX2dldExpc3RlbmVyQmFuazogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQmFuaztcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50UGx1Z2luSHViO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEV2ZW50UGx1Z2luUmVnaXN0cnlcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbi8qKlxuICogSW5qZWN0YWJsZSBvcmRlcmluZyBvZiBldmVudCBwbHVnaW5zLlxuICovXG52YXIgRXZlbnRQbHVnaW5PcmRlciA9IG51bGw7XG5cbi8qKlxuICogSW5qZWN0YWJsZSBtYXBwaW5nIGZyb20gbmFtZXMgdG8gZXZlbnQgcGx1Z2luIG1vZHVsZXMuXG4gKi9cbnZhciBuYW1lc1RvUGx1Z2lucyA9IHt9O1xuXG4vKipcbiAqIFJlY29tcHV0ZXMgdGhlIHBsdWdpbiBsaXN0IHVzaW5nIHRoZSBpbmplY3RlZCBwbHVnaW5zIGFuZCBwbHVnaW4gb3JkZXJpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjb21wdXRlUGx1Z2luT3JkZXJpbmcoKSB7XG4gIGlmICghRXZlbnRQbHVnaW5PcmRlcikge1xuICAgIC8vIFdhaXQgdW50aWwgYW4gYEV2ZW50UGx1Z2luT3JkZXJgIGlzIGluamVjdGVkLlxuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKHZhciBwbHVnaW5OYW1lIGluIG5hbWVzVG9QbHVnaW5zKSB7XG4gICAgdmFyIFBsdWdpbk1vZHVsZSA9IG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdO1xuICAgIHZhciBwbHVnaW5JbmRleCA9IEV2ZW50UGx1Z2luT3JkZXIuaW5kZXhPZihwbHVnaW5OYW1lKTtcbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgcGx1Z2luSW5kZXggPiAtMSxcbiAgICAgICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBDYW5ub3QgaW5qZWN0IGV2ZW50IHBsdWdpbnMgdGhhdCBkbyBub3QgZXhpc3QgaW4gJyArXG4gICAgICAndGhlIHBsdWdpbiBvcmRlcmluZywgYCVzYC4nLFxuICAgICAgcGx1Z2luTmFtZVxuICAgICkgOiBpbnZhcmlhbnQocGx1Z2luSW5kZXggPiAtMSkpO1xuICAgIGlmIChFdmVudFBsdWdpblJlZ2lzdHJ5LnBsdWdpbnNbcGx1Z2luSW5kZXhdKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgIFBsdWdpbk1vZHVsZS5leHRyYWN0RXZlbnRzLFxuICAgICAgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IEV2ZW50IHBsdWdpbnMgbXVzdCBpbXBsZW1lbnQgYW4gYGV4dHJhY3RFdmVudHNgICcgK1xuICAgICAgJ21ldGhvZCwgYnV0IGAlc2AgZG9lcyBub3QuJyxcbiAgICAgIHBsdWdpbk5hbWVcbiAgICApIDogaW52YXJpYW50KFBsdWdpbk1vZHVsZS5leHRyYWN0RXZlbnRzKSk7XG4gICAgRXZlbnRQbHVnaW5SZWdpc3RyeS5wbHVnaW5zW3BsdWdpbkluZGV4XSA9IFBsdWdpbk1vZHVsZTtcbiAgICB2YXIgcHVibGlzaGVkRXZlbnRzID0gUGx1Z2luTW9kdWxlLmV2ZW50VHlwZXM7XG4gICAgZm9yICh2YXIgZXZlbnROYW1lIGluIHB1Ymxpc2hlZEV2ZW50cykge1xuICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICAgcHVibGlzaEV2ZW50Rm9yUGx1Z2luKFxuICAgICAgICAgIHB1Ymxpc2hlZEV2ZW50c1tldmVudE5hbWVdLFxuICAgICAgICAgIFBsdWdpbk1vZHVsZSxcbiAgICAgICAgICBldmVudE5hbWVcbiAgICAgICAgKSxcbiAgICAgICAgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IEZhaWxlZCB0byBwdWJsaXNoIGV2ZW50IGAlc2AgZm9yIHBsdWdpbiBgJXNgLicsXG4gICAgICAgIGV2ZW50TmFtZSxcbiAgICAgICAgcGx1Z2luTmFtZVxuICAgICAgKSA6IGludmFyaWFudChwdWJsaXNoRXZlbnRGb3JQbHVnaW4oXG4gICAgICAgIHB1Ymxpc2hlZEV2ZW50c1tldmVudE5hbWVdLFxuICAgICAgICBQbHVnaW5Nb2R1bGUsXG4gICAgICAgIGV2ZW50TmFtZVxuICAgICAgKSkpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFB1Ymxpc2hlcyBhbiBldmVudCBzbyB0aGF0IGl0IGNhbiBiZSBkaXNwYXRjaGVkIGJ5IHRoZSBzdXBwbGllZCBwbHVnaW4uXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIERpc3BhdGNoIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBldmVudC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBQbHVnaW5Nb2R1bGUgUGx1Z2luIHB1Ymxpc2hpbmcgdGhlIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXZlbnQgd2FzIHN1Y2Nlc3NmdWxseSBwdWJsaXNoZWQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwdWJsaXNoRXZlbnRGb3JQbHVnaW4oZGlzcGF0Y2hDb25maWcsIFBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSB7XG4gIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgIUV2ZW50UGx1Z2luUmVnaXN0cnkuZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzLmhhc093blByb3BlcnR5KGV2ZW50TmFtZSksXG4gICAgJ0V2ZW50UGx1Z2luSHViOiBNb3JlIHRoYW4gb25lIHBsdWdpbiBhdHRlbXB0ZWQgdG8gcHVibGlzaCB0aGUgc2FtZSAnICtcbiAgICAnZXZlbnQgbmFtZSwgYCVzYC4nLFxuICAgIGV2ZW50TmFtZVxuICApIDogaW52YXJpYW50KCFFdmVudFBsdWdpblJlZ2lzdHJ5LmV2ZW50TmFtZURpc3BhdGNoQ29uZmlncy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpKSk7XG4gIEV2ZW50UGx1Z2luUmVnaXN0cnkuZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzW2V2ZW50TmFtZV0gPSBkaXNwYXRjaENvbmZpZztcblxuICB2YXIgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMgPSBkaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcztcbiAgaWYgKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgZm9yICh2YXIgcGhhc2VOYW1lIGluIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgICBpZiAocGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkocGhhc2VOYW1lKSkge1xuICAgICAgICB2YXIgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZSA9IHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzW3BoYXNlTmFtZV07XG4gICAgICAgIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKFxuICAgICAgICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWUsXG4gICAgICAgICAgUGx1Z2luTW9kdWxlLFxuICAgICAgICAgIGV2ZW50TmFtZVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgcHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUoXG4gICAgICBkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lLFxuICAgICAgUGx1Z2luTW9kdWxlLFxuICAgICAgZXZlbnROYW1lXG4gICAgKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUHVibGlzaGVzIGEgcmVnaXN0cmF0aW9uIG5hbWUgdGhhdCBpcyB1c2VkIHRvIGlkZW50aWZ5IGRpc3BhdGNoZWQgZXZlbnRzIGFuZFxuICogY2FuIGJlIHVzZWQgd2l0aCBgRXZlbnRQbHVnaW5IdWIucHV0TGlzdGVuZXJgIHRvIHJlZ2lzdGVyIGxpc3RlbmVycy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBSZWdpc3RyYXRpb24gbmFtZSB0byBhZGQuXG4gKiBAcGFyYW0ge29iamVjdH0gUGx1Z2luTW9kdWxlIFBsdWdpbiBwdWJsaXNoaW5nIHRoZSBldmVudC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKHJlZ2lzdHJhdGlvbk5hbWUsIFBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSB7XG4gIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgIUV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV0sXG4gICAgJ0V2ZW50UGx1Z2luSHViOiBNb3JlIHRoYW4gb25lIHBsdWdpbiBhdHRlbXB0ZWQgdG8gcHVibGlzaCB0aGUgc2FtZSAnICtcbiAgICAncmVnaXN0cmF0aW9uIG5hbWUsIGAlc2AuJyxcbiAgICByZWdpc3RyYXRpb25OYW1lXG4gICkgOiBpbnZhcmlhbnQoIUV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV0pKTtcbiAgRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXSA9IFBsdWdpbk1vZHVsZTtcbiAgRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdID1cbiAgICBQbHVnaW5Nb2R1bGUuZXZlbnRUeXBlc1tldmVudE5hbWVdLmRlcGVuZGVuY2llcztcbn1cblxuLyoqXG4gKiBSZWdpc3RlcnMgcGx1Z2lucyBzbyB0aGF0IHRoZXkgY2FuIGV4dHJhY3QgYW5kIGRpc3BhdGNoIGV2ZW50cy5cbiAqXG4gKiBAc2VlIHtFdmVudFBsdWdpbkh1Yn1cbiAqL1xudmFyIEV2ZW50UGx1Z2luUmVnaXN0cnkgPSB7XG5cbiAgLyoqXG4gICAqIE9yZGVyZWQgbGlzdCBvZiBpbmplY3RlZCBwbHVnaW5zLlxuICAgKi9cbiAgcGx1Z2luczogW10sXG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSBldmVudCBuYW1lIHRvIGRpc3BhdGNoIGNvbmZpZ1xuICAgKi9cbiAgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzOiB7fSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIHJlZ2lzdHJhdGlvbiBuYW1lIHRvIHBsdWdpbiBtb2R1bGVcbiAgICovXG4gIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzOiB7fSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIHJlZ2lzdHJhdGlvbiBuYW1lIHRvIGV2ZW50IG5hbWVcbiAgICovXG4gIHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXM6IHt9LFxuXG4gIC8qKlxuICAgKiBJbmplY3RzIGFuIG9yZGVyaW5nIG9mIHBsdWdpbnMgKGJ5IHBsdWdpbiBuYW1lKS4gVGhpcyBhbGxvd3MgdGhlIG9yZGVyaW5nXG4gICAqIHRvIGJlIGRlY291cGxlZCBmcm9tIGluamVjdGlvbiBvZiB0aGUgYWN0dWFsIHBsdWdpbnMgc28gdGhhdCBvcmRlcmluZyBpc1xuICAgKiBhbHdheXMgZGV0ZXJtaW5pc3RpYyByZWdhcmRsZXNzIG9mIHBhY2thZ2luZywgb24tdGhlLWZseSBpbmplY3Rpb24sIGV0Yy5cbiAgICpcbiAgICogQHBhcmFtIHthcnJheX0gSW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5PcmRlcn1cbiAgICovXG4gIGluamVjdEV2ZW50UGx1Z2luT3JkZXI6IGZ1bmN0aW9uKEluamVjdGVkRXZlbnRQbHVnaW5PcmRlcikge1xuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAhRXZlbnRQbHVnaW5PcmRlcixcbiAgICAgICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBDYW5ub3QgaW5qZWN0IGV2ZW50IHBsdWdpbiBvcmRlcmluZyBtb3JlIHRoYW4gJyArXG4gICAgICAnb25jZS4gWW91IGFyZSBsaWtlbHkgdHJ5aW5nIHRvIGxvYWQgbW9yZSB0aGFuIG9uZSBjb3B5IG9mIFJlYWN0LidcbiAgICApIDogaW52YXJpYW50KCFFdmVudFBsdWdpbk9yZGVyKSk7XG4gICAgLy8gQ2xvbmUgdGhlIG9yZGVyaW5nIHNvIGl0IGNhbm5vdCBiZSBkeW5hbWljYWxseSBtdXRhdGVkLlxuICAgIEV2ZW50UGx1Z2luT3JkZXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXIpO1xuICAgIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluamVjdHMgcGx1Z2lucyB0byBiZSB1c2VkIGJ5IGBFdmVudFBsdWdpbkh1YmAuIFRoZSBwbHVnaW4gbmFtZXMgbXVzdCBiZVxuICAgKiBpbiB0aGUgb3JkZXJpbmcgaW5qZWN0ZWQgYnkgYGluamVjdEV2ZW50UGx1Z2luT3JkZXJgLlxuICAgKlxuICAgKiBQbHVnaW5zIGNhbiBiZSBpbmplY3RlZCBhcyBwYXJ0IG9mIHBhZ2UgaW5pdGlhbGl6YXRpb24gb3Igb24tdGhlLWZseS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGluamVjdGVkTmFtZXNUb1BsdWdpbnMgTWFwIGZyb20gbmFtZXMgdG8gcGx1Z2luIG1vZHVsZXMuXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lfVxuICAgKi9cbiAgaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lOiBmdW5jdGlvbihpbmplY3RlZE5hbWVzVG9QbHVnaW5zKSB7XG4gICAgdmFyIGlzT3JkZXJpbmdEaXJ0eSA9IGZhbHNlO1xuICAgIGZvciAodmFyIHBsdWdpbk5hbWUgaW4gaW5qZWN0ZWROYW1lc1RvUGx1Z2lucykge1xuICAgICAgaWYgKCFpbmplY3RlZE5hbWVzVG9QbHVnaW5zLmhhc093blByb3BlcnR5KHBsdWdpbk5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIFBsdWdpbk1vZHVsZSA9IGluamVjdGVkTmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV07XG4gICAgICBpZiAoIW5hbWVzVG9QbHVnaW5zLmhhc093blByb3BlcnR5KHBsdWdpbk5hbWUpIHx8XG4gICAgICAgICAgbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gIT09IFBsdWdpbk1vZHVsZSkge1xuICAgICAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgICAgICFuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSxcbiAgICAgICAgICAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCB0d28gZGlmZmVyZW50IGV2ZW50IHBsdWdpbnMgJyArXG4gICAgICAgICAgJ3VzaW5nIHRoZSBzYW1lIG5hbWUsIGAlc2AuJyxcbiAgICAgICAgICBwbHVnaW5OYW1lXG4gICAgICAgICkgOiBpbnZhcmlhbnQoIW5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdKSk7XG4gICAgICAgIG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdID0gUGx1Z2luTW9kdWxlO1xuICAgICAgICBpc09yZGVyaW5nRGlydHkgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNPcmRlcmluZ0RpcnR5KSB7XG4gICAgICByZWNvbXB1dGVQbHVnaW5PcmRlcmluZygpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTG9va3MgdXAgdGhlIHBsdWdpbiBmb3IgdGhlIHN1cHBsaWVkIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZXZlbnQgQSBzeW50aGV0aWMgZXZlbnQuXG4gICAqIEByZXR1cm4gez9vYmplY3R9IFRoZSBwbHVnaW4gdGhhdCBjcmVhdGVkIHRoZSBzdXBwbGllZCBldmVudC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXRQbHVnaW5Nb2R1bGVGb3JFdmVudDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgZGlzcGF0Y2hDb25maWcgPSBldmVudC5kaXNwYXRjaENvbmZpZztcbiAgICBpZiAoZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgICAgcmV0dXJuIEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbXG4gICAgICAgIGRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWVcbiAgICAgIF0gfHwgbnVsbDtcbiAgICB9XG4gICAgZm9yICh2YXIgcGhhc2UgaW4gZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICAgIGlmICghZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkocGhhc2UpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIFBsdWdpbk1vZHVsZSA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbXG4gICAgICAgIGRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzW3BoYXNlXVxuICAgICAgXTtcbiAgICAgIGlmIChQbHVnaW5Nb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuIFBsdWdpbk1vZHVsZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV4cG9zZWQgZm9yIHVuaXQgdGVzdGluZy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZXNldEV2ZW50UGx1Z2luczogZnVuY3Rpb24oKSB7XG4gICAgRXZlbnRQbHVnaW5PcmRlciA9IG51bGw7XG4gICAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBuYW1lc1RvUGx1Z2lucykge1xuICAgICAgaWYgKG5hbWVzVG9QbHVnaW5zLmhhc093blByb3BlcnR5KHBsdWdpbk5hbWUpKSB7XG4gICAgICAgIGRlbGV0ZSBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gICAgRXZlbnRQbHVnaW5SZWdpc3RyeS5wbHVnaW5zLmxlbmd0aCA9IDA7XG5cbiAgICB2YXIgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5ldmVudE5hbWVEaXNwYXRjaENvbmZpZ3M7XG4gICAgZm9yICh2YXIgZXZlbnROYW1lIGluIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlncykge1xuICAgICAgaWYgKGV2ZW50TmFtZURpc3BhdGNoQ29uZmlncy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpKSB7XG4gICAgICAgIGRlbGV0ZSBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3NbZXZlbnROYW1lXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzO1xuICAgIGZvciAodmFyIHJlZ2lzdHJhdGlvbk5hbWUgaW4gcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMpIHtcbiAgICAgIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShyZWdpc3RyYXRpb25OYW1lKSkge1xuICAgICAgICBkZWxldGUgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRQbHVnaW5SZWdpc3RyeTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFdmVudFBsdWdpblV0aWxzXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoXCIuL0V2ZW50Q29uc3RhbnRzXCIpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xuXG4vKipcbiAqIEluamVjdGVkIGRlcGVuZGVuY2llczpcbiAqL1xuXG4vKipcbiAqIC0gYE1vdW50YDogW3JlcXVpcmVkXSBNb2R1bGUgdGhhdCBjYW4gY29udmVydCBiZXR3ZWVuIFJlYWN0IGRvbSBJRHMgYW5kXG4gKiAgIGFjdHVhbCBub2RlIHJlZmVyZW5jZXMuXG4gKi9cbnZhciBpbmplY3Rpb24gPSB7XG4gIE1vdW50OiBudWxsLFxuICBpbmplY3RNb3VudDogZnVuY3Rpb24oSW5qZWN0ZWRNb3VudCkge1xuICAgIGluamVjdGlvbi5Nb3VudCA9IEluamVjdGVkTW91bnQ7XG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICAgSW5qZWN0ZWRNb3VudCAmJiBJbmplY3RlZE1vdW50LmdldE5vZGUsXG4gICAgICAgICdFdmVudFBsdWdpblV0aWxzLmluamVjdGlvbi5pbmplY3RNb3VudCguLi4pOiBJbmplY3RlZCBNb3VudCBtb2R1bGUgJyArXG4gICAgICAgICdpcyBtaXNzaW5nIGdldE5vZGUuJ1xuICAgICAgKSA6IGludmFyaWFudChJbmplY3RlZE1vdW50ICYmIEluamVjdGVkTW91bnQuZ2V0Tm9kZSkpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHRvcExldmVsVHlwZXMgPSBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuXG5mdW5jdGlvbiBpc0VuZGlzaCh0b3BMZXZlbFR5cGUpIHtcbiAgcmV0dXJuIHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BNb3VzZVVwIHx8XG4gICAgICAgICB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wVG91Y2hFbmQgfHxcbiAgICAgICAgIHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BUb3VjaENhbmNlbDtcbn1cblxuZnVuY3Rpb24gaXNNb3ZlaXNoKHRvcExldmVsVHlwZSkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlTW92ZSB8fFxuICAgICAgICAgdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcFRvdWNoTW92ZTtcbn1cbmZ1bmN0aW9uIGlzU3RhcnRpc2godG9wTGV2ZWxUeXBlKSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wTW91c2VEb3duIHx8XG4gICAgICAgICB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wVG91Y2hTdGFydDtcbn1cblxuXG52YXIgdmFsaWRhdGVFdmVudERpc3BhdGNoZXM7XG5pZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gICAgdmFyIGRpc3BhdGNoSURzID0gZXZlbnQuX2Rpc3BhdGNoSURzO1xuXG4gICAgdmFyIGxpc3RlbmVyc0lzQXJyID0gQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycyk7XG4gICAgdmFyIGlkc0lzQXJyID0gQXJyYXkuaXNBcnJheShkaXNwYXRjaElEcyk7XG4gICAgdmFyIElEc0xlbiA9IGlkc0lzQXJyID8gZGlzcGF0Y2hJRHMubGVuZ3RoIDogZGlzcGF0Y2hJRHMgPyAxIDogMDtcbiAgICB2YXIgbGlzdGVuZXJzTGVuID0gbGlzdGVuZXJzSXNBcnIgP1xuICAgICAgZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoIDpcbiAgICAgIGRpc3BhdGNoTGlzdGVuZXJzID8gMSA6IDA7XG5cbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgaWRzSXNBcnIgPT09IGxpc3RlbmVyc0lzQXJyICYmIElEc0xlbiA9PT0gbGlzdGVuZXJzTGVuLFxuICAgICAgJ0V2ZW50UGx1Z2luVXRpbHM6IEludmFsaWQgYGV2ZW50YC4nXG4gICAgKSA6IGludmFyaWFudChpZHNJc0FyciA9PT0gbGlzdGVuZXJzSXNBcnIgJiYgSURzTGVuID09PSBsaXN0ZW5lcnNMZW4pKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjYihldmVudCwgbGlzdGVuZXIsIGlkKWAuIEF2b2lkcyB1c2luZyBjYWxsIGlmIG5vIHNjb3BlIGlzXG4gKiBwcm92aWRlZC4gVGhlIGAobGlzdGVuZXIsaWQpYCBwYWlyIGVmZmVjdGl2ZWx5IGZvcm1zIHRoZSBcImRpc3BhdGNoXCIgYnV0IGFyZVxuICoga2VwdCBzZXBhcmF0ZSB0byBjb25zZXJ2ZSBtZW1vcnkuXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hFdmVudERpc3BhdGNoKGV2ZW50LCBjYikge1xuICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gIHZhciBkaXNwYXRjaElEcyA9IGV2ZW50Ll9kaXNwYXRjaElEcztcbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycykpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIExpc3RlbmVycyBhbmQgSURzIGFyZSB0d28gcGFyYWxsZWwgYXJyYXlzIHRoYXQgYXJlIGFsd2F5cyBpbiBzeW5jLlxuICAgICAgY2IoZXZlbnQsIGRpc3BhdGNoTGlzdGVuZXJzW2ldLCBkaXNwYXRjaElEc1tpXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRpc3BhdGNoTGlzdGVuZXJzKSB7XG4gICAgY2IoZXZlbnQsIGRpc3BhdGNoTGlzdGVuZXJzLCBkaXNwYXRjaElEcyk7XG4gIH1cbn1cblxuLyoqXG4gKiBEZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIFBsdWdpbk1vZHVsZS5leGVjdXRlRGlzcGF0Y2goKS5cbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IFN5bnRoZXRpY0V2ZW50IHRvIGhhbmRsZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gQXBwbGljYXRpb24tbGV2ZWwgY2FsbGJhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBkb21JRCBET00gaWQgdG8gcGFzcyB0byB0aGUgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgbGlzdGVuZXIsIGRvbUlEKSB7XG4gIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBpbmplY3Rpb24uTW91bnQuZ2V0Tm9kZShkb21JRCk7XG4gIHZhciByZXR1cm5WYWx1ZSA9IGxpc3RlbmVyKGV2ZW50LCBkb21JRCk7XG4gIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBudWxsO1xuICByZXR1cm4gcmV0dXJuVmFsdWU7XG59XG5cbi8qKlxuICogU3RhbmRhcmQvc2ltcGxlIGl0ZXJhdGlvbiB0aHJvdWdoIGFuIGV2ZW50J3MgY29sbGVjdGVkIGRpc3BhdGNoZXMuXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcihldmVudCwgZXhlY3V0ZURpc3BhdGNoKSB7XG4gIGZvckVhY2hFdmVudERpc3BhdGNoKGV2ZW50LCBleGVjdXRlRGlzcGF0Y2gpO1xuICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBudWxsO1xuICBldmVudC5fZGlzcGF0Y2hJRHMgPSBudWxsO1xufVxuXG4vKipcbiAqIFN0YW5kYXJkL3NpbXBsZSBpdGVyYXRpb24gdGhyb3VnaCBhbiBldmVudCdzIGNvbGxlY3RlZCBkaXNwYXRjaGVzLCBidXQgc3RvcHNcbiAqIGF0IHRoZSBmaXJzdCBkaXNwYXRjaCBleGVjdXRpb24gcmV0dXJuaW5nIHRydWUsIGFuZCByZXR1cm5zIHRoYXQgaWQuXG4gKlxuICogQHJldHVybiBpZCBvZiB0aGUgZmlyc3QgZGlzcGF0Y2ggZXhlY3V0aW9uIHdobydzIGxpc3RlbmVyIHJldHVybnMgdHJ1ZSwgb3JcbiAqIG51bGwgaWYgbm8gbGlzdGVuZXIgcmV0dXJuZWQgdHJ1ZS5cbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZUltcGwoZXZlbnQpIHtcbiAgdmFyIGRpc3BhdGNoTGlzdGVuZXJzID0gZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xuICB2YXIgZGlzcGF0Y2hJRHMgPSBldmVudC5fZGlzcGF0Y2hJRHM7XG4gIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyhldmVudCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcnMpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXNwYXRjaExpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBMaXN0ZW5lcnMgYW5kIElEcyBhcmUgdHdvIHBhcmFsbGVsIGFycmF5cyB0aGF0IGFyZSBhbHdheXMgaW4gc3luYy5cbiAgICAgIGlmIChkaXNwYXRjaExpc3RlbmVyc1tpXShldmVudCwgZGlzcGF0Y2hJRHNbaV0pKSB7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaElEc1tpXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnMpIHtcbiAgICBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnMoZXZlbnQsIGRpc3BhdGNoSURzKSkge1xuICAgICAgcmV0dXJuIGRpc3BhdGNoSURzO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBAc2VlIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWUoZXZlbnQpIHtcbiAgdmFyIHJldCA9IGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsKGV2ZW50KTtcbiAgZXZlbnQuX2Rpc3BhdGNoSURzID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBFeGVjdXRpb24gb2YgYSBcImRpcmVjdFwiIGRpc3BhdGNoIC0gdGhlcmUgbXVzdCBiZSBhdCBtb3N0IG9uZSBkaXNwYXRjaFxuICogYWNjdW11bGF0ZWQgb24gdGhlIGV2ZW50IG9yIGl0IGlzIGNvbnNpZGVyZWQgYW4gZXJyb3IuIEl0IGRvZXNuJ3QgcmVhbGx5IG1ha2VcbiAqIHNlbnNlIGZvciBhbiBldmVudCB3aXRoIG11bHRpcGxlIGRpc3BhdGNoZXMgKGJ1YmJsZWQpIHRvIGtlZXAgdHJhY2sgb2YgdGhlXG4gKiByZXR1cm4gdmFsdWVzIGF0IGVhY2ggZGlzcGF0Y2ggZXhlY3V0aW9uLCBidXQgaXQgZG9lcyB0ZW5kIHRvIG1ha2Ugc2Vuc2Ugd2hlblxuICogZGVhbGluZyB3aXRoIFwiZGlyZWN0XCIgZGlzcGF0Y2hlcy5cbiAqXG4gKiBAcmV0dXJuIFRoZSByZXR1cm4gdmFsdWUgb2YgZXhlY3V0aW5nIHRoZSBzaW5nbGUgZGlzcGF0Y2guXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXJlY3REaXNwYXRjaChldmVudCkge1xuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMoZXZlbnQpO1xuICB9XG4gIHZhciBkaXNwYXRjaExpc3RlbmVyID0gZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xuICB2YXIgZGlzcGF0Y2hJRCA9IGV2ZW50Ll9kaXNwYXRjaElEcztcbiAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAhQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVyKSxcbiAgICAnZXhlY3V0ZURpcmVjdERpc3BhdGNoKC4uLik6IEludmFsaWQgYGV2ZW50YC4nXG4gICkgOiBpbnZhcmlhbnQoIUFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcikpKTtcbiAgdmFyIHJlcyA9IGRpc3BhdGNoTGlzdGVuZXIgP1xuICAgIGRpc3BhdGNoTGlzdGVuZXIoZXZlbnQsIGRpc3BhdGNoSUQpIDpcbiAgICBudWxsO1xuICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBudWxsO1xuICBldmVudC5fZGlzcGF0Y2hJRHMgPSBudWxsO1xuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50XG4gKiBAcmV0dXJuIHtib29sfSBUcnVlIGlmZiBudW1iZXIgb2YgZGlzcGF0Y2hlcyBhY2N1bXVsYXRlZCBpcyBncmVhdGVyIHRoYW4gMC5cbiAqL1xuZnVuY3Rpb24gaGFzRGlzcGF0Y2hlcyhldmVudCkge1xuICByZXR1cm4gISFldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG59XG5cbi8qKlxuICogR2VuZXJhbCB1dGlsaXRpZXMgdGhhdCBhcmUgdXNlZnVsIGluIGNyZWF0aW5nIGN1c3RvbSBFdmVudCBQbHVnaW5zLlxuICovXG52YXIgRXZlbnRQbHVnaW5VdGlscyA9IHtcbiAgaXNFbmRpc2g6IGlzRW5kaXNoLFxuICBpc01vdmVpc2g6IGlzTW92ZWlzaCxcbiAgaXNTdGFydGlzaDogaXNTdGFydGlzaCxcblxuICBleGVjdXRlRGlyZWN0RGlzcGF0Y2g6IGV4ZWN1dGVEaXJlY3REaXNwYXRjaCxcbiAgZXhlY3V0ZURpc3BhdGNoOiBleGVjdXRlRGlzcGF0Y2gsXG4gIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcjogZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyLFxuICBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlOiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlLFxuICBoYXNEaXNwYXRjaGVzOiBoYXNEaXNwYXRjaGVzLFxuICBpbmplY3Rpb246IGluamVjdGlvbixcbiAgdXNlVG91Y2hFdmVudHM6IGZhbHNlXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50UGx1Z2luVXRpbHM7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRXZlbnRQcm9wYWdhdG9yc1xuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKFwiLi9FdmVudENvbnN0YW50c1wiKTtcbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoXCIuL0V2ZW50UGx1Z2luSHViXCIpO1xuXG52YXIgYWNjdW11bGF0ZSA9IHJlcXVpcmUoXCIuL2FjY3VtdWxhdGVcIik7XG52YXIgZm9yRWFjaEFjY3VtdWxhdGVkID0gcmVxdWlyZShcIi4vZm9yRWFjaEFjY3VtdWxhdGVkXCIpO1xuXG52YXIgUHJvcGFnYXRpb25QaGFzZXMgPSBFdmVudENvbnN0YW50cy5Qcm9wYWdhdGlvblBoYXNlcztcbnZhciBnZXRMaXN0ZW5lciA9IEV2ZW50UGx1Z2luSHViLmdldExpc3RlbmVyO1xuXG4vKipcbiAqIFNvbWUgZXZlbnQgdHlwZXMgaGF2ZSBhIG5vdGlvbiBvZiBkaWZmZXJlbnQgcmVnaXN0cmF0aW9uIG5hbWVzIGZvciBkaWZmZXJlbnRcbiAqIFwicGhhc2VzXCIgb2YgcHJvcGFnYXRpb24uIFRoaXMgZmluZHMgbGlzdGVuZXJzIGJ5IGEgZ2l2ZW4gcGhhc2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RlbmVyQXRQaGFzZShpZCwgZXZlbnQsIHByb3BhZ2F0aW9uUGhhc2UpIHtcbiAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPVxuICAgIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzW3Byb3BhZ2F0aW9uUGhhc2VdO1xuICByZXR1cm4gZ2V0TGlzdGVuZXIoaWQsIHJlZ2lzdHJhdGlvbk5hbWUpO1xufVxuXG4vKipcbiAqIFRhZ3MgYSBgU3ludGhldGljRXZlbnRgIHdpdGggZGlzcGF0Y2hlZCBsaXN0ZW5lcnMuIENyZWF0aW5nIHRoaXMgZnVuY3Rpb25cbiAqIGhlcmUsIGFsbG93cyB1cyB0byBub3QgaGF2ZSB0byBiaW5kIG9yIGNyZWF0ZSBmdW5jdGlvbnMgZm9yIGVhY2ggZXZlbnQuXG4gKiBNdXRhdGluZyB0aGUgZXZlbnQncyBtZW1iZXJzIGFsbG93cyB1cyB0byBub3QgaGF2ZSB0byBjcmVhdGUgYSB3cmFwcGluZ1xuICogXCJkaXNwYXRjaFwiIG9iamVjdCB0aGF0IHBhaXJzIHRoZSBldmVudCB3aXRoIHRoZSBsaXN0ZW5lci5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcyhkb21JRCwgdXB3YXJkcywgZXZlbnQpIHtcbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgIGlmICghZG9tSUQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRGlzcGF0Y2hpbmcgaWQgbXVzdCBub3QgYmUgbnVsbCcpO1xuICAgIH1cbiAgfVxuICB2YXIgcGhhc2UgPSB1cHdhcmRzID8gUHJvcGFnYXRpb25QaGFzZXMuYnViYmxlZCA6IFByb3BhZ2F0aW9uUGhhc2VzLmNhcHR1cmVkO1xuICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lckF0UGhhc2UoZG9tSUQsIGV2ZW50LCBwaGFzZSk7XG4gIGlmIChsaXN0ZW5lcikge1xuICAgIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IGFjY3VtdWxhdGUoZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzLCBsaXN0ZW5lcik7XG4gICAgZXZlbnQuX2Rpc3BhdGNoSURzID0gYWNjdW11bGF0ZShldmVudC5fZGlzcGF0Y2hJRHMsIGRvbUlEKTtcbiAgfVxufVxuXG4vKipcbiAqIENvbGxlY3QgZGlzcGF0Y2hlcyAobXVzdCBiZSBlbnRpcmVseSBjb2xsZWN0ZWQgYmVmb3JlIGRpc3BhdGNoaW5nIC0gc2VlIHVuaXRcbiAqIHRlc3RzKS4gTGF6aWx5IGFsbG9jYXRlIHRoZSBhcnJheSB0byBjb25zZXJ2ZSBtZW1vcnkuICBXZSBtdXN0IGxvb3AgdGhyb3VnaFxuICogZWFjaCBldmVudCBhbmQgcGVyZm9ybSB0aGUgdHJhdmVyc2FsIGZvciBlYWNoIG9uZS4gV2UgY2FuIG5vdCBwZXJmb3JtIGFcbiAqIHNpbmdsZSB0cmF2ZXJzYWwgZm9yIHRoZSBlbnRpcmUgY29sbGVjdGlvbiBvZiBldmVudHMgYmVjYXVzZSBlYWNoIGV2ZW50IG1heVxuICogaGF2ZSBhIGRpZmZlcmVudCB0YXJnZXQuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGUoZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgRXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmdldEluc3RhbmNlSGFuZGxlKCkudHJhdmVyc2VUd29QaGFzZShcbiAgICAgIGV2ZW50LmRpc3BhdGNoTWFya2VyLFxuICAgICAgYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcyxcbiAgICAgIGV2ZW50XG4gICAgKTtcbiAgfVxufVxuXG5cbi8qKlxuICogQWNjdW11bGF0ZXMgd2l0aG91dCByZWdhcmQgdG8gZGlyZWN0aW9uLCBkb2VzIG5vdCBsb29rIGZvciBwaGFzZWRcbiAqIHJlZ2lzdHJhdGlvbiBuYW1lcy4gU2FtZSBhcyBgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGVgIGJ1dCB3aXRob3V0XG4gKiByZXF1aXJpbmcgdGhhdCB0aGUgYGRpc3BhdGNoTWFya2VyYCBiZSB0aGUgc2FtZSBhcyB0aGUgZGlzcGF0Y2hlZCBJRC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpc3BhdGNoZXMoaWQsIGlnbm9yZWREaXJlY3Rpb24sIGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lO1xuICAgIHZhciBsaXN0ZW5lciA9IGdldExpc3RlbmVyKGlkLCByZWdpc3RyYXRpb25OYW1lKTtcbiAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IGFjY3VtdWxhdGUoZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzLCBsaXN0ZW5lcik7XG4gICAgICBldmVudC5fZGlzcGF0Y2hJRHMgPSBhY2N1bXVsYXRlKGV2ZW50Ll9kaXNwYXRjaElEcywgaWQpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFjY3VtdWxhdGVzIGRpc3BhdGNoZXMgb24gYW4gYFN5bnRoZXRpY0V2ZW50YCwgYnV0IG9ubHkgZm9yIHRoZVxuICogYGRpc3BhdGNoTWFya2VyYC5cbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50XG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlKGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgYWNjdW11bGF0ZURpc3BhdGNoZXMoZXZlbnQuZGlzcGF0Y2hNYXJrZXIsIG51bGwsIGV2ZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlKTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzKGxlYXZlLCBlbnRlciwgZnJvbUlELCB0b0lEKSB7XG4gIEV2ZW50UGx1Z2luSHViLmluamVjdGlvbi5nZXRJbnN0YW5jZUhhbmRsZSgpLnRyYXZlcnNlRW50ZXJMZWF2ZShcbiAgICBmcm9tSUQsXG4gICAgdG9JRCxcbiAgICBhY2N1bXVsYXRlRGlzcGF0Y2hlcyxcbiAgICBsZWF2ZSxcbiAgICBlbnRlclxuICApO1xufVxuXG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzKGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZSk7XG59XG5cblxuXG4vKipcbiAqIEEgc21hbGwgc2V0IG9mIHByb3BhZ2F0aW9uIHBhdHRlcm5zLCBlYWNoIG9mIHdoaWNoIHdpbGwgYWNjZXB0IGEgc21hbGwgYW1vdW50XG4gKiBvZiBpbmZvcm1hdGlvbiwgYW5kIGdlbmVyYXRlIGEgc2V0IG9mIFwiZGlzcGF0Y2ggcmVhZHkgZXZlbnQgb2JqZWN0c1wiIC0gd2hpY2hcbiAqIGFyZSBzZXRzIG9mIGV2ZW50cyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIGFubm90YXRlZCB3aXRoIGEgc2V0IG9mIGRpc3BhdGNoZWRcbiAqIGxpc3RlbmVyIGZ1bmN0aW9ucy9pZHMuIFRoZSBBUEkgaXMgZGVzaWduZWQgdGhpcyB3YXkgdG8gZGlzY291cmFnZSB0aGVzZVxuICogcHJvcGFnYXRpb24gc3RyYXRlZ2llcyBmcm9tIGFjdHVhbGx5IGV4ZWN1dGluZyB0aGUgZGlzcGF0Y2hlcywgc2luY2Ugd2VcbiAqIGFsd2F5cyB3YW50IHRvIGNvbGxlY3QgdGhlIGVudGlyZSBzZXQgb2YgZGlzcGF0Y2hlcyBiZWZvcmUgZXhlY3V0aW5nIGV2ZW50IGFcbiAqIHNpbmdsZSBvbmUuXG4gKlxuICogQGNvbnN0cnVjdG9yIEV2ZW50UHJvcGFnYXRvcnNcbiAqL1xudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSB7XG4gIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXM6IGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMsXG4gIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzOiBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlcyxcbiAgYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzOiBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRQcm9wYWdhdG9ycztcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEV4ZWN1dGlvbkVudmlyb25tZW50XG4gKi9cblxuLypqc2xpbnQgZXZpbDogdHJ1ZSAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGNhblVzZURPTSA9ICEhKFxuICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICB3aW5kb3cuZG9jdW1lbnQgJiZcbiAgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnRcbik7XG5cbi8qKlxuICogU2ltcGxlLCBsaWdodHdlaWdodCBtb2R1bGUgYXNzaXN0aW5nIHdpdGggdGhlIGRldGVjdGlvbiBhbmQgY29udGV4dCBvZlxuICogV29ya2VyLiBIZWxwcyBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmNpZXMgYW5kIGFsbG93cyBjb2RlIHRvIHJlYXNvbiBhYm91dFxuICogd2hldGhlciBvciBub3QgdGhleSBhcmUgaW4gYSBXb3JrZXIsIGV2ZW4gaWYgdGhleSBuZXZlciBpbmNsdWRlIHRoZSBtYWluXG4gKiBgUmVhY3RXb3JrZXJgIGRlcGVuZGVuY3kuXG4gKi9cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHtcblxuICBjYW5Vc2VET006IGNhblVzZURPTSxcblxuICBjYW5Vc2VXb3JrZXJzOiB0eXBlb2YgV29ya2VyICE9PSAndW5kZWZpbmVkJyxcblxuICBjYW5Vc2VFdmVudExpc3RlbmVyczpcbiAgICBjYW5Vc2VET00gJiYgISEod2luZG93LmFkZEV2ZW50TGlzdGVuZXIgfHwgd2luZG93LmF0dGFjaEV2ZW50KSxcblxuICBjYW5Vc2VWaWV3cG9ydDogY2FuVXNlRE9NICYmICEhd2luZG93LnNjcmVlbixcblxuICBpc0luV29ya2VyOiAhY2FuVXNlRE9NIC8vIEZvciBub3csIHRoaXMgaXMgdHJ1ZSAtIG1pZ2h0IGNoYW5nZSBpbiB0aGUgZnV0dXJlLlxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV4ZWN1dGlvbkVudmlyb25tZW50O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEhUTUxET01Qcm9wZXJ0eUNvbmZpZ1xuICovXG5cbi8qanNsaW50IGJpdHdpc2U6IHRydWUqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZShcIi4vRE9NUHJvcGVydHlcIik7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKFwiLi9FeGVjdXRpb25FbnZpcm9ubWVudFwiKTtcblxudmFyIE1VU1RfVVNFX0FUVFJJQlVURSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5NVVNUX1VTRV9BVFRSSUJVVEU7XG52YXIgTVVTVF9VU0VfUFJPUEVSVFkgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uTVVTVF9VU0VfUFJPUEVSVFk7XG52YXIgSEFTX0JPT0xFQU5fVkFMVUUgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uSEFTX0JPT0xFQU5fVkFMVUU7XG52YXIgSEFTX1NJREVfRUZGRUNUUyA9IERPTVByb3BlcnR5LmluamVjdGlvbi5IQVNfU0lERV9FRkZFQ1RTO1xudmFyIEhBU19OVU1FUklDX1ZBTFVFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLkhBU19OVU1FUklDX1ZBTFVFO1xudmFyIEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFID1cbiAgRE9NUHJvcGVydHkuaW5qZWN0aW9uLkhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFO1xudmFyIEhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUgPVxuICBET01Qcm9wZXJ0eS5pbmplY3Rpb24uSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRTtcblxudmFyIGhhc1NWRztcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgdmFyIGltcGxlbWVudGF0aW9uID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb247XG4gIGhhc1NWRyA9IChcbiAgICBpbXBsZW1lbnRhdGlvbiAmJlxuICAgIGltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUgJiZcbiAgICBpbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKFxuICAgICAgJ2h0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ZlYXR1cmUjQmFzaWNTdHJ1Y3R1cmUnLFxuICAgICAgJzEuMSdcbiAgICApXG4gICk7XG59XG5cblxudmFyIEhUTUxET01Qcm9wZXJ0eUNvbmZpZyA9IHtcbiAgaXNDdXN0b21BdHRyaWJ1dGU6IFJlZ0V4cC5wcm90b3R5cGUudGVzdC5iaW5kKFxuICAgIC9eKGRhdGF8YXJpYSktW2Etel9dW2EtelxcZF8uXFwtXSokL1xuICApLFxuICBQcm9wZXJ0aWVzOiB7XG4gICAgLyoqXG4gICAgICogU3RhbmRhcmQgUHJvcGVydGllc1xuICAgICAqL1xuICAgIGFjY2VwdDogbnVsbCxcbiAgICBhY2Nlc3NLZXk6IG51bGwsXG4gICAgYWN0aW9uOiBudWxsLFxuICAgIGFsbG93RnVsbFNjcmVlbjogTVVTVF9VU0VfQVRUUklCVVRFIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgYWxsb3dUcmFuc3BhcmVuY3k6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBhbHQ6IG51bGwsXG4gICAgYXN5bmM6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGF1dG9Db21wbGV0ZTogbnVsbCxcbiAgICAvLyBhdXRvRm9jdXMgaXMgcG9seWZpbGxlZC9ub3JtYWxpemVkIGJ5IEF1dG9Gb2N1c01peGluXG4gICAgLy8gYXV0b0ZvY3VzOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBhdXRvUGxheTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgY2VsbFBhZGRpbmc6IG51bGwsXG4gICAgY2VsbFNwYWNpbmc6IG51bGwsXG4gICAgY2hhclNldDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGNoZWNrZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgLy8gVG8gc2V0IGNsYXNzTmFtZSBvbiBTVkcgZWxlbWVudHMsIGl0J3MgbmVjZXNzYXJ5IHRvIHVzZSAuc2V0QXR0cmlidXRlO1xuICAgIC8vIHRoaXMgd29ya3Mgb24gSFRNTCBlbGVtZW50cyB0b28gaW4gYWxsIGJyb3dzZXJzIGV4Y2VwdCBJRTguIENvbnZlbmllbnRseSxcbiAgICAvLyBJRTggZG9lc24ndCBzdXBwb3J0IFNWRyBhbmQgc28gd2UgY2FuIHNpbXBseSB1c2UgdGhlIGF0dHJpYnV0ZSBpblxuICAgIC8vIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBTVkcgYW5kIHRoZSBwcm9wZXJ0eSBpbiBicm93c2VycyB0aGF0IGRvbid0LFxuICAgIC8vIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgZWxlbWVudCBpcyBIVE1MIG9yIFNWRy5cbiAgICBjbGFzc05hbWU6IGhhc1NWRyA/IE1VU1RfVVNFX0FUVFJJQlVURSA6IE1VU1RfVVNFX1BST1BFUlRZLFxuICAgIGNvbHM6IE1VU1RfVVNFX0FUVFJJQlVURSB8IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIGNvbFNwYW46IG51bGwsXG4gICAgY29udGVudDogbnVsbCxcbiAgICBjb250ZW50RWRpdGFibGU6IG51bGwsXG4gICAgY29udGV4dE1lbnU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBjb250cm9sczogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjb29yZHM6IG51bGwsXG4gICAgY3Jvc3NPcmlnaW46IG51bGwsXG4gICAgZGF0YTogbnVsbCwgLy8gRm9yIGA8b2JqZWN0IC8+YCBhY3RzIGFzIGBzcmNgLlxuICAgIGRhdGVUaW1lOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZGVmZXI6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGRpcjogbnVsbCxcbiAgICBkaXNhYmxlZDogTVVTVF9VU0VfQVRUUklCVVRFIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZG93bmxvYWQ6IEhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUsXG4gICAgZHJhZ2dhYmxlOiBudWxsLFxuICAgIGVuY1R5cGU6IG51bGwsXG4gICAgZm9ybTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZvcm1Ob1ZhbGlkYXRlOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBmcmFtZUJvcmRlcjogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGhlaWdodDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGhpZGRlbjogTVVTVF9VU0VfQVRUUklCVVRFIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgaHJlZjogbnVsbCxcbiAgICBocmVmTGFuZzogbnVsbCxcbiAgICBodG1sRm9yOiBudWxsLFxuICAgIGh0dHBFcXVpdjogbnVsbCxcbiAgICBpY29uOiBudWxsLFxuICAgIGlkOiBNVVNUX1VTRV9QUk9QRVJUWSxcbiAgICBsYWJlbDogbnVsbCxcbiAgICBsYW5nOiBudWxsLFxuICAgIGxpc3Q6IG51bGwsXG4gICAgbG9vcDogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBtYXg6IG51bGwsXG4gICAgbWF4TGVuZ3RoOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgbWVkaWFHcm91cDogbnVsbCxcbiAgICBtZXRob2Q6IG51bGwsXG4gICAgbWluOiBudWxsLFxuICAgIG11bHRpcGxlOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIG11dGVkOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIG5hbWU6IG51bGwsXG4gICAgbm9WYWxpZGF0ZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcGF0dGVybjogbnVsbCxcbiAgICBwbGFjZWhvbGRlcjogbnVsbCxcbiAgICBwb3N0ZXI6IG51bGwsXG4gICAgcHJlbG9hZDogbnVsbCxcbiAgICByYWRpb0dyb3VwOiBudWxsLFxuICAgIHJlYWRPbmx5OiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJlbDogbnVsbCxcbiAgICByZXF1aXJlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcm9sZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHJvd3M6IE1VU1RfVVNFX0FUVFJJQlVURSB8IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHJvd1NwYW46IG51bGwsXG4gICAgc2FuZGJveDogbnVsbCxcbiAgICBzY29wZTogbnVsbCxcbiAgICBzY3JvbGxMZWZ0OiBNVVNUX1VTRV9QUk9QRVJUWSxcbiAgICBzY3JvbGxpbmc6IG51bGwsXG4gICAgc2Nyb2xsVG9wOiBNVVNUX1VTRV9QUk9QRVJUWSxcbiAgICBzZWFtbGVzczogTVVTVF9VU0VfQVRUUklCVVRFIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgc2VsZWN0ZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgc2hhcGU6IG51bGwsXG4gICAgc2l6ZTogTVVTVF9VU0VfQVRUUklCVVRFIHwgSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgc3BhbjogSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgc3BlbGxDaGVjazogbnVsbCxcbiAgICBzcmM6IG51bGwsXG4gICAgc3JjRG9jOiBNVVNUX1VTRV9QUk9QRVJUWSxcbiAgICBzcmNTZXQ6IG51bGwsXG4gICAgc3RhcnQ6IEhBU19OVU1FUklDX1ZBTFVFLFxuICAgIHN0ZXA6IG51bGwsXG4gICAgc3R5bGU6IG51bGwsXG4gICAgdGFiSW5kZXg6IG51bGwsXG4gICAgdGFyZ2V0OiBudWxsLFxuICAgIHRpdGxlOiBudWxsLFxuICAgIHR5cGU6IG51bGwsXG4gICAgdXNlTWFwOiBudWxsLFxuICAgIHZhbHVlOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19TSURFX0VGRkVDVFMsXG4gICAgd2lkdGg6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB3bW9kZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuXG4gICAgLyoqXG4gICAgICogTm9uLXN0YW5kYXJkIFByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBhdXRvQ2FwaXRhbGl6ZTogbnVsbCwgLy8gU3VwcG9ydGVkIGluIE1vYmlsZSBTYWZhcmkgZm9yIGtleWJvYXJkIGhpbnRzXG4gICAgYXV0b0NvcnJlY3Q6IG51bGwsIC8vIFN1cHBvcnRlZCBpbiBNb2JpbGUgU2FmYXJpIGZvciBrZXlib2FyZCBoaW50c1xuICAgIGl0ZW1Qcm9wOiBNVVNUX1VTRV9BVFRSSUJVVEUsIC8vIE1pY3JvZGF0YTogaHR0cDovL3NjaGVtYS5vcmcvZG9jcy9ncy5odG1sXG4gICAgaXRlbVNjb3BlOiBNVVNUX1VTRV9BVFRSSUJVVEUgfCBIQVNfQk9PTEVBTl9WQUxVRSwgLy8gTWljcm9kYXRhOiBodHRwOi8vc2NoZW1hLm9yZy9kb2NzL2dzLmh0bWxcbiAgICBpdGVtVHlwZTogTVVTVF9VU0VfQVRUUklCVVRFLCAvLyBNaWNyb2RhdGE6IGh0dHA6Ly9zY2hlbWEub3JnL2RvY3MvZ3MuaHRtbFxuICAgIHByb3BlcnR5OiBudWxsIC8vIFN1cHBvcnRzIE9HIGluIG1ldGEgdGFnc1xuICB9LFxuICBET01BdHRyaWJ1dGVOYW1lczoge1xuICAgIGNsYXNzTmFtZTogJ2NsYXNzJyxcbiAgICBodG1sRm9yOiAnZm9yJyxcbiAgICBodHRwRXF1aXY6ICdodHRwLWVxdWl2J1xuICB9LFxuICBET01Qcm9wZXJ0eU5hbWVzOiB7XG4gICAgYXV0b0NhcGl0YWxpemU6ICdhdXRvY2FwaXRhbGl6ZScsXG4gICAgYXV0b0NvbXBsZXRlOiAnYXV0b2NvbXBsZXRlJyxcbiAgICBhdXRvQ29ycmVjdDogJ2F1dG9jb3JyZWN0JyxcbiAgICBhdXRvRm9jdXM6ICdhdXRvZm9jdXMnLFxuICAgIGF1dG9QbGF5OiAnYXV0b3BsYXknLFxuICAgIGVuY1R5cGU6ICdlbmN0eXBlJyxcbiAgICBocmVmTGFuZzogJ2hyZWZsYW5nJyxcbiAgICByYWRpb0dyb3VwOiAncmFkaW9ncm91cCcsXG4gICAgc3BlbGxDaGVjazogJ3NwZWxsY2hlY2snLFxuICAgIHNyY0RvYzogJ3NyY2RvYycsXG4gICAgc3JjU2V0OiAnc3Jjc2V0J1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhUTUxET01Qcm9wZXJ0eUNvbmZpZztcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBMaW5rZWRTdGF0ZU1peGluXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgUmVhY3RMaW5rID0gcmVxdWlyZShcIi4vUmVhY3RMaW5rXCIpO1xudmFyIFJlYWN0U3RhdGVTZXR0ZXJzID0gcmVxdWlyZShcIi4vUmVhY3RTdGF0ZVNldHRlcnNcIik7XG5cbi8qKlxuICogQSBzaW1wbGUgbWl4aW4gYXJvdW5kIFJlYWN0TGluay5mb3JTdGF0ZSgpLlxuICovXG52YXIgTGlua2VkU3RhdGVNaXhpbiA9IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIFJlYWN0TGluayB0aGF0J3MgbGlua2VkIHRvIHBhcnQgb2YgdGhpcyBjb21wb25lbnQncyBzdGF0ZS4gVGhlXG4gICAqIFJlYWN0TGluayB3aWxsIGhhdmUgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhpcy5zdGF0ZVtrZXldIGFuZCB3aWxsIGNhbGxcbiAgICogc2V0U3RhdGUoKSB3aGVuIGEgY2hhbmdlIGlzIHJlcXVlc3RlZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBzdGF0ZSBrZXkgdG8gdXBkYXRlLiBOb3RlOiB5b3UgbWF5IHdhbnQgdG8gdXNlIGtleU9mKClcbiAgICogaWYgeW91J3JlIHVzaW5nIEdvb2dsZSBDbG9zdXJlIENvbXBpbGVyIGFkdmFuY2VkIG1vZGUuXG4gICAqIEByZXR1cm4ge1JlYWN0TGlua30gUmVhY3RMaW5rIGluc3RhbmNlIGxpbmtpbmcgdG8gdGhlIHN0YXRlLlxuICAgKi9cbiAgbGlua1N0YXRlOiBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gbmV3IFJlYWN0TGluayhcbiAgICAgIHRoaXMuc3RhdGVba2V5XSxcbiAgICAgIFJlYWN0U3RhdGVTZXR0ZXJzLmNyZWF0ZVN0YXRlS2V5U2V0dGVyKHRoaXMsIGtleSlcbiAgICApO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmtlZFN0YXRlTWl4aW47XG4iLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIExpbmtlZFZhbHVlVXRpbHNcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBSZWFjdFByb3BUeXBlcyA9IHJlcXVpcmUoXCIuL1JlYWN0UHJvcFR5cGVzXCIpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xuXG52YXIgaGFzUmVhZE9ubHlWYWx1ZSA9IHtcbiAgJ2J1dHRvbic6IHRydWUsXG4gICdjaGVja2JveCc6IHRydWUsXG4gICdpbWFnZSc6IHRydWUsXG4gICdoaWRkZW4nOiB0cnVlLFxuICAncmFkaW8nOiB0cnVlLFxuICAncmVzZXQnOiB0cnVlLFxuICAnc3VibWl0JzogdHJ1ZVxufTtcblxuZnVuY3Rpb24gX2Fzc2VydFNpbmdsZUxpbmsoaW5wdXQpIHtcbiAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICBpbnB1dC5wcm9wcy5jaGVja2VkTGluayA9PSBudWxsIHx8IGlucHV0LnByb3BzLnZhbHVlTGluayA9PSBudWxsLFxuICAgICdDYW5ub3QgcHJvdmlkZSBhIGNoZWNrZWRMaW5rIGFuZCBhIHZhbHVlTGluay4gSWYgeW91IHdhbnQgdG8gdXNlICcgK1xuICAgICdjaGVja2VkTGluaywgeW91IHByb2JhYmx5IGRvblxcJ3Qgd2FudCB0byB1c2UgdmFsdWVMaW5rIGFuZCB2aWNlIHZlcnNhLidcbiAgKSA6IGludmFyaWFudChpbnB1dC5wcm9wcy5jaGVja2VkTGluayA9PSBudWxsIHx8IGlucHV0LnByb3BzLnZhbHVlTGluayA9PSBudWxsKSk7XG59XG5mdW5jdGlvbiBfYXNzZXJ0VmFsdWVMaW5rKGlucHV0KSB7XG4gIF9hc3NlcnRTaW5nbGVMaW5rKGlucHV0KTtcbiAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICBpbnB1dC5wcm9wcy52YWx1ZSA9PSBudWxsICYmIGlucHV0LnByb3BzLm9uQ2hhbmdlID09IG51bGwsXG4gICAgJ0Nhbm5vdCBwcm92aWRlIGEgdmFsdWVMaW5rIGFuZCBhIHZhbHVlIG9yIG9uQ2hhbmdlIGV2ZW50LiBJZiB5b3Ugd2FudCAnICtcbiAgICAndG8gdXNlIHZhbHVlIG9yIG9uQ2hhbmdlLCB5b3UgcHJvYmFibHkgZG9uXFwndCB3YW50IHRvIHVzZSB2YWx1ZUxpbmsuJ1xuICApIDogaW52YXJpYW50KGlucHV0LnByb3BzLnZhbHVlID09IG51bGwgJiYgaW5wdXQucHJvcHMub25DaGFuZ2UgPT0gbnVsbCkpO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0Q2hlY2tlZExpbmsoaW5wdXQpIHtcbiAgX2Fzc2VydFNpbmdsZUxpbmsoaW5wdXQpO1xuICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgIGlucHV0LnByb3BzLmNoZWNrZWQgPT0gbnVsbCAmJiBpbnB1dC5wcm9wcy5vbkNoYW5nZSA9PSBudWxsLFxuICAgICdDYW5ub3QgcHJvdmlkZSBhIGNoZWNrZWRMaW5rIGFuZCBhIGNoZWNrZWQgcHJvcGVydHkgb3Igb25DaGFuZ2UgZXZlbnQuICcgK1xuICAgICdJZiB5b3Ugd2FudCB0byB1c2UgY2hlY2tlZCBvciBvbkNoYW5nZSwgeW91IHByb2JhYmx5IGRvblxcJ3Qgd2FudCB0byAnICtcbiAgICAndXNlIGNoZWNrZWRMaW5rJ1xuICApIDogaW52YXJpYW50KGlucHV0LnByb3BzLmNoZWNrZWQgPT0gbnVsbCAmJiBpbnB1dC5wcm9wcy5vbkNoYW5nZSA9PSBudWxsKSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZSBjaGFuZ2UgZXZlbnQgdG8gaGFuZGxlXG4gKi9cbmZ1bmN0aW9uIF9oYW5kbGVMaW5rZWRWYWx1ZUNoYW5nZShlKSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHRoaXMucHJvcHMudmFsdWVMaW5rLnJlcXVlc3RDaGFuZ2UoZS50YXJnZXQudmFsdWUpO1xufVxuXG4vKipcbiAgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBlIGNoYW5nZSBldmVudCB0byBoYW5kbGVcbiAgKi9cbmZ1bmN0aW9uIF9oYW5kbGVMaW5rZWRDaGVja0NoYW5nZShlKSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHRoaXMucHJvcHMuY2hlY2tlZExpbmsucmVxdWVzdENoYW5nZShlLnRhcmdldC5jaGVja2VkKTtcbn1cblxuLyoqXG4gKiBQcm92aWRlIGEgbGlua2VkIGB2YWx1ZWAgYXR0cmlidXRlIGZvciBjb250cm9sbGVkIGZvcm1zLiBZb3Ugc2hvdWxkIG5vdCB1c2VcbiAqIHRoaXMgb3V0c2lkZSBvZiB0aGUgUmVhY3RET00gY29udHJvbGxlZCBmb3JtIGNvbXBvbmVudHMuXG4gKi9cbnZhciBMaW5rZWRWYWx1ZVV0aWxzID0ge1xuICBNaXhpbjoge1xuICAgIHByb3BUeXBlczoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgICAgICBpZiAoIXByb3BzW3Byb3BOYW1lXSB8fFxuICAgICAgICAgICAgaGFzUmVhZE9ubHlWYWx1ZVtwcm9wcy50eXBlXSB8fFxuICAgICAgICAgICAgcHJvcHMub25DaGFuZ2UgfHxcbiAgICAgICAgICAgIHByb3BzLnJlYWRPbmx5IHx8XG4gICAgICAgICAgICBwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgICAgICAgICdZb3UgcHJvdmlkZWQgYSBgdmFsdWVgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArXG4gICAgICAgICAgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArXG4gICAgICAgICAgJ3RoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRWYWx1ZWAuIE90aGVyd2lzZSwgJyArXG4gICAgICAgICAgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLidcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICBjaGVja2VkOiBmdW5jdGlvbihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICAgICAgaWYgKCFwcm9wc1twcm9wTmFtZV0gfHxcbiAgICAgICAgICAgIHByb3BzLm9uQ2hhbmdlIHx8XG4gICAgICAgICAgICBwcm9wcy5yZWFkT25seSB8fFxuICAgICAgICAgICAgcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICAgICAgICAnWW91IHByb3ZpZGVkIGEgYGNoZWNrZWRgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArXG4gICAgICAgICAgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArXG4gICAgICAgICAgJ3RoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRDaGVja2VkYC4gT3RoZXJ3aXNlLCAnICtcbiAgICAgICAgICAnc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuJ1xuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIG9uQ2hhbmdlOiBSZWFjdFByb3BUeXBlcy5mdW5jXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBpbnB1dCBGb3JtIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHsqfSBjdXJyZW50IHZhbHVlIG9mIHRoZSBpbnB1dCBlaXRoZXIgZnJvbSB2YWx1ZSBwcm9wIG9yIGxpbmsuXG4gICAqL1xuICBnZXRWYWx1ZTogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQucHJvcHMudmFsdWVMaW5rKSB7XG4gICAgICBfYXNzZXJ0VmFsdWVMaW5rKGlucHV0KTtcbiAgICAgIHJldHVybiBpbnB1dC5wcm9wcy52YWx1ZUxpbmsudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dC5wcm9wcy52YWx1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gaW5wdXQgRm9ybSBjb21wb25lbnRcbiAgICogQHJldHVybiB7Kn0gY3VycmVudCBjaGVja2VkIHN0YXR1cyBvZiB0aGUgaW5wdXQgZWl0aGVyIGZyb20gY2hlY2tlZCBwcm9wXG4gICAqICAgICAgICAgICAgIG9yIGxpbmsuXG4gICAqL1xuICBnZXRDaGVja2VkOiBmdW5jdGlvbihpbnB1dCkge1xuICAgIGlmIChpbnB1dC5wcm9wcy5jaGVja2VkTGluaykge1xuICAgICAgX2Fzc2VydENoZWNrZWRMaW5rKGlucHV0KTtcbiAgICAgIHJldHVybiBpbnB1dC5wcm9wcy5jaGVja2VkTGluay52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0LnByb3BzLmNoZWNrZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGlucHV0IEZvcm0gY29tcG9uZW50XG4gICAqIEByZXR1cm4ge2Z1bmN0aW9ufSBjaGFuZ2UgY2FsbGJhY2sgZWl0aGVyIGZyb20gb25DaGFuZ2UgcHJvcCBvciBsaW5rLlxuICAgKi9cbiAgZ2V0T25DaGFuZ2U6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgaWYgKGlucHV0LnByb3BzLnZhbHVlTGluaykge1xuICAgICAgX2Fzc2VydFZhbHVlTGluayhpbnB1dCk7XG4gICAgICByZXR1cm4gX2hhbmRsZUxpbmtlZFZhbHVlQ2hhbmdlO1xuICAgIH0gZWxzZSBpZiAoaW5wdXQucHJvcHMuY2hlY2tlZExpbmspIHtcbiAgICAgIF9hc3NlcnRDaGVja2VkTGluayhpbnB1dCk7XG4gICAgICByZXR1cm4gX2hhbmRsZUxpbmtlZENoZWNrQ2hhbmdlO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXQucHJvcHMub25DaGFuZ2U7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTGlua2VkVmFsdWVVdGlscztcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgTG9jYWxFdmVudFRyYXBNaXhpblxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcIi4vUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyXCIpO1xuXG52YXIgYWNjdW11bGF0ZSA9IHJlcXVpcmUoXCIuL2FjY3VtdWxhdGVcIik7XG52YXIgZm9yRWFjaEFjY3VtdWxhdGVkID0gcmVxdWlyZShcIi4vZm9yRWFjaEFjY3VtdWxhdGVkXCIpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcblxuZnVuY3Rpb24gcmVtb3ZlKGV2ZW50KSB7XG4gIGV2ZW50LnJlbW92ZSgpO1xufVxuXG52YXIgTG9jYWxFdmVudFRyYXBNaXhpbiA9IHtcbiAgdHJhcEJ1YmJsZWRFdmVudDpmdW5jdGlvbih0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSkge1xuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQodGhpcy5pc01vdW50ZWQoKSwgJ011c3QgYmUgbW91bnRlZCB0byB0cmFwIGV2ZW50cycpIDogaW52YXJpYW50KHRoaXMuaXNNb3VudGVkKCkpKTtcbiAgICB2YXIgbGlzdGVuZXIgPSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudChcbiAgICAgIHRvcExldmVsVHlwZSxcbiAgICAgIGhhbmRsZXJCYXNlTmFtZSxcbiAgICAgIHRoaXMuZ2V0RE9NTm9kZSgpXG4gICAgKTtcbiAgICB0aGlzLl9sb2NhbEV2ZW50TGlzdGVuZXJzID0gYWNjdW11bGF0ZSh0aGlzLl9sb2NhbEV2ZW50TGlzdGVuZXJzLCBsaXN0ZW5lcik7XG4gIH0sXG5cbiAgLy8gdHJhcENhcHR1cmVkRXZlbnQgd291bGQgbG9vayBuZWFybHkgaWRlbnRpY2FsLiBXZSBkb24ndCBpbXBsZW1lbnQgdGhhdFxuICAvLyBtZXRob2QgYmVjYXVzZSBpdCBpc24ndCBjdXJyZW50bHkgbmVlZGVkLlxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50OmZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9sb2NhbEV2ZW50TGlzdGVuZXJzKSB7XG4gICAgICBmb3JFYWNoQWNjdW11bGF0ZWQodGhpcy5fbG9jYWxFdmVudExpc3RlbmVycywgcmVtb3ZlKTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTG9jYWxFdmVudFRyYXBNaXhpbjtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIE1vYmlsZVNhZmFyaUNsaWNrRXZlbnRQbHVnaW5cbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoXCIuL0V2ZW50Q29uc3RhbnRzXCIpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoXCIuL2VtcHR5RnVuY3Rpb25cIik7XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcblxuLyoqXG4gKiBNb2JpbGUgU2FmYXJpIGRvZXMgbm90IGZpcmUgcHJvcGVybHkgYnViYmxlIGNsaWNrIGV2ZW50cyBvbiBub24taW50ZXJhY3RpdmVcbiAqIGVsZW1lbnRzLCB3aGljaCBtZWFucyBkZWxlZ2F0ZWQgY2xpY2sgbGlzdGVuZXJzIGRvIG5vdCBmaXJlLiBUaGUgd29ya2Fyb3VuZFxuICogZm9yIHRoaXMgYnVnIGludm9sdmVzIGF0dGFjaGluZyBhbiBlbXB0eSBjbGljayBsaXN0ZW5lciBvbiB0aGUgdGFyZ2V0IG5vZGUuXG4gKlxuICogVGhpcyBwYXJ0aWN1bGFyIHBsdWdpbiB3b3JrcyBhcm91bmQgdGhlIGJ1ZyBieSBhdHRhY2hpbmcgYW4gZW1wdHkgY2xpY2tcbiAqIGxpc3RlbmVyIG9uIGB0b3VjaHN0YXJ0YCAod2hpY2ggZG9lcyBmaXJlIG9uIGV2ZXJ5IGVsZW1lbnQpLlxuICovXG52YXIgTW9iaWxlU2FmYXJpQ2xpY2tFdmVudFBsdWdpbiA9IHtcblxuICBldmVudFR5cGVzOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRvcExldmVsVGFyZ2V0IFRoZSBsaXN0ZW5pbmcgY29tcG9uZW50IHJvb3Qgbm9kZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVGFyZ2V0SUQgSUQgb2YgYHRvcExldmVsVGFyZ2V0YC5cbiAgICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICAgKiBAcmV0dXJuIHsqfSBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAgICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuZXh0cmFjdEV2ZW50c31cbiAgICovXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uKFxuICAgICAgdG9wTGV2ZWxUeXBlLFxuICAgICAgdG9wTGV2ZWxUYXJnZXQsXG4gICAgICB0b3BMZXZlbFRhcmdldElELFxuICAgICAgbmF0aXZlRXZlbnQpIHtcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcFRvdWNoU3RhcnQpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBuYXRpdmVFdmVudC50YXJnZXQ7XG4gICAgICBpZiAodGFyZ2V0ICYmICF0YXJnZXQub25jbGljaykge1xuICAgICAgICB0YXJnZXQub25jbGljayA9IGVtcHR5RnVuY3Rpb247XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTW9iaWxlU2FmYXJpQ2xpY2tFdmVudFBsdWdpbjtcbiIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUG9vbGVkQ2xhc3NcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcblxuLyoqXG4gKiBTdGF0aWMgcG9vbGVycy4gU2V2ZXJhbCBjdXN0b20gdmVyc2lvbnMgZm9yIGVhY2ggcG90ZW50aWFsIG51bWJlciBvZlxuICogYXJndW1lbnRzLiBBIGNvbXBsZXRlbHkgZ2VuZXJpYyBwb29sZXIgaXMgZWFzeSB0byBpbXBsZW1lbnQsIGJ1dCB3b3VsZFxuICogcmVxdWlyZSBhY2Nlc3NpbmcgdGhlIGBhcmd1bWVudHNgIG9iamVjdC4gSW4gZWFjaCBvZiB0aGVzZSwgYHRoaXNgIHJlZmVycyB0b1xuICogdGhlIENsYXNzIGl0c2VsZiwgbm90IGFuIGluc3RhbmNlLiBJZiBhbnkgb3RoZXJzIGFyZSBuZWVkZWQsIHNpbXBseSBhZGQgdGhlbVxuICogaGVyZSwgb3IgaW4gdGhlaXIgb3duIGZpbGVzLlxuICovXG52YXIgb25lQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbihjb3B5RmllbGRzRnJvbSkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBjb3B5RmllbGRzRnJvbSk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoY29weUZpZWxkc0Zyb20pO1xuICB9XG59O1xuXG52YXIgdHdvQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbihhMSwgYTIpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBLbGFzcy5pbnN0YW5jZVBvb2wucG9wKCk7XG4gICAgS2xhc3MuY2FsbChpbnN0YW5jZSwgYTEsIGEyKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhhMSwgYTIpO1xuICB9XG59O1xuXG52YXIgdGhyZWVBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uKGExLCBhMiwgYTMpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBLbGFzcy5pbnN0YW5jZVBvb2wucG9wKCk7XG4gICAgS2xhc3MuY2FsbChpbnN0YW5jZSwgYTEsIGEyLCBhMyk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyLCBhMyk7XG4gIH1cbn07XG5cbnZhciBmaXZlQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbihhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBLbGFzcy5pbnN0YW5jZVBvb2wucG9wKCk7XG4gICAgS2xhc3MuY2FsbChpbnN0YW5jZSwgYTEsIGEyLCBhMywgYTQsIGE1KTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhhMSwgYTIsIGEzLCBhNCwgYTUpO1xuICB9XG59O1xuXG52YXIgc3RhbmRhcmRSZWxlYXNlciA9IGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgaW5zdGFuY2UgaW5zdGFuY2VvZiBLbGFzcyxcbiAgICAnVHJ5aW5nIHRvIHJlbGVhc2UgYW4gaW5zdGFuY2UgaW50byBhIHBvb2wgb2YgYSBkaWZmZXJlbnQgdHlwZS4nXG4gICkgOiBpbnZhcmlhbnQoaW5zdGFuY2UgaW5zdGFuY2VvZiBLbGFzcykpO1xuICBpZiAoaW5zdGFuY2UuZGVzdHJ1Y3Rvcikge1xuICAgIGluc3RhbmNlLmRlc3RydWN0b3IoKTtcbiAgfVxuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCA8IEtsYXNzLnBvb2xTaXplKSB7XG4gICAgS2xhc3MuaW5zdGFuY2VQb29sLnB1c2goaW5zdGFuY2UpO1xuICB9XG59O1xuXG52YXIgREVGQVVMVF9QT09MX1NJWkUgPSAxMDtcbnZhciBERUZBVUxUX1BPT0xFUiA9IG9uZUFyZ3VtZW50UG9vbGVyO1xuXG4vKipcbiAqIEF1Z21lbnRzIGBDb3B5Q29uc3RydWN0b3JgIHRvIGJlIGEgcG9vbGFibGUgY2xhc3MsIGF1Z21lbnRpbmcgb25seSB0aGUgY2xhc3NcbiAqIGl0c2VsZiAoc3RhdGljYWxseSkgbm90IGFkZGluZyBhbnkgcHJvdG90eXBpY2FsIGZpZWxkcy4gQW55IENvcHlDb25zdHJ1Y3RvclxuICogeW91IGdpdmUgdGhpcyBtYXkgaGF2ZSBhIGBwb29sU2l6ZWAgcHJvcGVydHksIGFuZCB3aWxsIGxvb2sgZm9yIGFcbiAqIHByb3RvdHlwaWNhbCBgZGVzdHJ1Y3RvcmAgb24gaW5zdGFuY2VzIChvcHRpb25hbCkuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gQ29weUNvbnN0cnVjdG9yIENvbnN0cnVjdG9yIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVzZXQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwb29sZXIgQ3VzdG9taXphYmxlIHBvb2xlci5cbiAqL1xudmFyIGFkZFBvb2xpbmdUbyA9IGZ1bmN0aW9uKENvcHlDb25zdHJ1Y3RvciwgcG9vbGVyKSB7XG4gIHZhciBOZXdLbGFzcyA9IENvcHlDb25zdHJ1Y3RvcjtcbiAgTmV3S2xhc3MuaW5zdGFuY2VQb29sID0gW107XG4gIE5ld0tsYXNzLmdldFBvb2xlZCA9IHBvb2xlciB8fCBERUZBVUxUX1BPT0xFUjtcbiAgaWYgKCFOZXdLbGFzcy5wb29sU2l6ZSkge1xuICAgIE5ld0tsYXNzLnBvb2xTaXplID0gREVGQVVMVF9QT09MX1NJWkU7XG4gIH1cbiAgTmV3S2xhc3MucmVsZWFzZSA9IHN0YW5kYXJkUmVsZWFzZXI7XG4gIHJldHVybiBOZXdLbGFzcztcbn07XG5cbnZhciBQb29sZWRDbGFzcyA9IHtcbiAgYWRkUG9vbGluZ1RvOiBhZGRQb29saW5nVG8sXG4gIG9uZUFyZ3VtZW50UG9vbGVyOiBvbmVBcmd1bWVudFBvb2xlcixcbiAgdHdvQXJndW1lbnRQb29sZXI6IHR3b0FyZ3VtZW50UG9vbGVyLFxuICB0aHJlZUFyZ3VtZW50UG9vbGVyOiB0aHJlZUFyZ3VtZW50UG9vbGVyLFxuICBmaXZlQXJndW1lbnRQb29sZXI6IGZpdmVBcmd1bWVudFBvb2xlclxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb29sZWRDbGFzcztcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgRE9NUHJvcGVydHlPcGVyYXRpb25zID0gcmVxdWlyZShcIi4vRE9NUHJvcGVydHlPcGVyYXRpb25zXCIpO1xudmFyIEV2ZW50UGx1Z2luVXRpbHMgPSByZXF1aXJlKFwiLi9FdmVudFBsdWdpblV0aWxzXCIpO1xudmFyIFJlYWN0Q2hpbGRyZW4gPSByZXF1aXJlKFwiLi9SZWFjdENoaWxkcmVuXCIpO1xudmFyIFJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZShcIi4vUmVhY3RDb21wb25lbnRcIik7XG52YXIgUmVhY3RDb21wb3NpdGVDb21wb25lbnQgPSByZXF1aXJlKFwiLi9SZWFjdENvbXBvc2l0ZUNvbXBvbmVudFwiKTtcbnZhciBSZWFjdENvbnRleHQgPSByZXF1aXJlKFwiLi9SZWFjdENvbnRleHRcIik7XG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKFwiLi9SZWFjdEN1cnJlbnRPd25lclwiKTtcbnZhciBSZWFjdERlc2NyaXB0b3IgPSByZXF1aXJlKFwiLi9SZWFjdERlc2NyaXB0b3JcIik7XG52YXIgUmVhY3RET00gPSByZXF1aXJlKFwiLi9SZWFjdERPTVwiKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudCA9IHJlcXVpcmUoXCIuL1JlYWN0RE9NQ29tcG9uZW50XCIpO1xudmFyIFJlYWN0RGVmYXVsdEluamVjdGlvbiA9IHJlcXVpcmUoXCIuL1JlYWN0RGVmYXVsdEluamVjdGlvblwiKTtcbnZhciBSZWFjdEluc3RhbmNlSGFuZGxlcyA9IHJlcXVpcmUoXCIuL1JlYWN0SW5zdGFuY2VIYW5kbGVzXCIpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKFwiLi9SZWFjdE1vdW50XCIpO1xudmFyIFJlYWN0TXVsdGlDaGlsZCA9IHJlcXVpcmUoXCIuL1JlYWN0TXVsdGlDaGlsZFwiKTtcbnZhciBSZWFjdFBlcmYgPSByZXF1aXJlKFwiLi9SZWFjdFBlcmZcIik7XG52YXIgUmVhY3RQcm9wVHlwZXMgPSByZXF1aXJlKFwiLi9SZWFjdFByb3BUeXBlc1wiKTtcbnZhciBSZWFjdFNlcnZlclJlbmRlcmluZyA9IHJlcXVpcmUoXCIuL1JlYWN0U2VydmVyUmVuZGVyaW5nXCIpO1xudmFyIFJlYWN0VGV4dENvbXBvbmVudCA9IHJlcXVpcmUoXCIuL1JlYWN0VGV4dENvbXBvbmVudFwiKTtcblxudmFyIG9ubHlDaGlsZCA9IHJlcXVpcmUoXCIuL29ubHlDaGlsZFwiKTtcblxuUmVhY3REZWZhdWx0SW5qZWN0aW9uLmluamVjdCgpO1xuXG52YXIgUmVhY3QgPSB7XG4gIENoaWxkcmVuOiB7XG4gICAgbWFwOiBSZWFjdENoaWxkcmVuLm1hcCxcbiAgICBmb3JFYWNoOiBSZWFjdENoaWxkcmVuLmZvckVhY2gsXG4gICAgY291bnQ6IFJlYWN0Q2hpbGRyZW4uY291bnQsXG4gICAgb25seTogb25seUNoaWxkXG4gIH0sXG4gIERPTTogUmVhY3RET00sXG4gIFByb3BUeXBlczogUmVhY3RQcm9wVHlwZXMsXG4gIGluaXRpYWxpemVUb3VjaEV2ZW50czogZnVuY3Rpb24oc2hvdWxkVXNlVG91Y2gpIHtcbiAgICBFdmVudFBsdWdpblV0aWxzLnVzZVRvdWNoRXZlbnRzID0gc2hvdWxkVXNlVG91Y2g7XG4gIH0sXG4gIGNyZWF0ZUNsYXNzOiBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5jcmVhdGVDbGFzcyxcbiAgY3JlYXRlRGVzY3JpcHRvcjogZnVuY3Rpb24odHlwZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIHJldHVybiB0eXBlLmFwcGx5KG51bGwsIGFyZ3MpO1xuICB9LFxuICBjb25zdHJ1Y3RBbmRSZW5kZXJDb21wb25lbnQ6IFJlYWN0TW91bnQuY29uc3RydWN0QW5kUmVuZGVyQ29tcG9uZW50LFxuICBjb25zdHJ1Y3RBbmRSZW5kZXJDb21wb25lbnRCeUlEOiBSZWFjdE1vdW50LmNvbnN0cnVjdEFuZFJlbmRlckNvbXBvbmVudEJ5SUQsXG4gIHJlbmRlckNvbXBvbmVudDogUmVhY3RQZXJmLm1lYXN1cmUoXG4gICAgJ1JlYWN0JyxcbiAgICAncmVuZGVyQ29tcG9uZW50JyxcbiAgICBSZWFjdE1vdW50LnJlbmRlckNvbXBvbmVudFxuICApLFxuICByZW5kZXJDb21wb25lbnRUb1N0cmluZzogUmVhY3RTZXJ2ZXJSZW5kZXJpbmcucmVuZGVyQ29tcG9uZW50VG9TdHJpbmcsXG4gIHJlbmRlckNvbXBvbmVudFRvU3RhdGljTWFya3VwOlxuICAgIFJlYWN0U2VydmVyUmVuZGVyaW5nLnJlbmRlckNvbXBvbmVudFRvU3RhdGljTWFya3VwLFxuICB1bm1vdW50Q29tcG9uZW50QXROb2RlOiBSZWFjdE1vdW50LnVubW91bnRDb21wb25lbnRBdE5vZGUsXG4gIGlzVmFsaWRDbGFzczogUmVhY3REZXNjcmlwdG9yLmlzVmFsaWRGYWN0b3J5LFxuICBpc1ZhbGlkQ29tcG9uZW50OiBSZWFjdERlc2NyaXB0b3IuaXNWYWxpZERlc2NyaXB0b3IsXG4gIHdpdGhDb250ZXh0OiBSZWFjdENvbnRleHQud2l0aENvbnRleHQsXG4gIF9faW50ZXJuYWxzOiB7XG4gICAgQ29tcG9uZW50OiBSZWFjdENvbXBvbmVudCxcbiAgICBDdXJyZW50T3duZXI6IFJlYWN0Q3VycmVudE93bmVyLFxuICAgIERPTUNvbXBvbmVudDogUmVhY3RET01Db21wb25lbnQsXG4gICAgRE9NUHJvcGVydHlPcGVyYXRpb25zOiBET01Qcm9wZXJ0eU9wZXJhdGlvbnMsXG4gICAgSW5zdGFuY2VIYW5kbGVzOiBSZWFjdEluc3RhbmNlSGFuZGxlcyxcbiAgICBNb3VudDogUmVhY3RNb3VudCxcbiAgICBNdWx0aUNoaWxkOiBSZWFjdE11bHRpQ2hpbGQsXG4gICAgVGV4dENvbXBvbmVudDogUmVhY3RUZXh0Q29tcG9uZW50XG4gIH1cbn07XG5cbmlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgdmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZShcIi4vRXhlY3V0aW9uRW52aXJvbm1lbnRcIik7XG4gIGlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiZcbiAgICAgIHdpbmRvdy50b3AgPT09IHdpbmRvdy5zZWxmICYmXG4gICAgICBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0Nocm9tZScpID4gLTEpIHtcbiAgICBjb25zb2xlLmRlYnVnKFxuICAgICAgJ0Rvd25sb2FkIHRoZSBSZWFjdCBEZXZUb29scyBmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTogJyArXG4gICAgICAnaHR0cDovL2ZiLm1lL3JlYWN0LWRldnRvb2xzJ1xuICAgICk7XG5cbiAgICB2YXIgZXhwZWN0ZWRGZWF0dXJlcyA9IFtcbiAgICAgIC8vIHNoaW1zXG4gICAgICBBcnJheS5pc0FycmF5LFxuICAgICAgQXJyYXkucHJvdG90eXBlLmV2ZXJ5LFxuICAgICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2gsXG4gICAgICBBcnJheS5wcm90b3R5cGUuaW5kZXhPZixcbiAgICAgIEFycmF5LnByb3RvdHlwZS5tYXAsXG4gICAgICBEYXRlLm5vdyxcbiAgICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLFxuICAgICAgT2JqZWN0LmtleXMsXG4gICAgICBTdHJpbmcucHJvdG90eXBlLnNwbGl0LFxuICAgICAgU3RyaW5nLnByb3RvdHlwZS50cmltLFxuXG4gICAgICAvLyBzaGFtc1xuICAgICAgT2JqZWN0LmNyZWF0ZSxcbiAgICAgIE9iamVjdC5mcmVlemVcbiAgICBdO1xuXG4gICAgZm9yICh2YXIgaSBpbiBleHBlY3RlZEZlYXR1cmVzKSB7XG4gICAgICBpZiAoIWV4cGVjdGVkRmVhdHVyZXNbaV0pIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAnT25lIG9yIG1vcmUgRVM1IHNoaW0vc2hhbXMgZXhwZWN0ZWQgYnkgUmVhY3QgYXJlIG5vdCBhdmFpbGFibGU6ICcgK1xuICAgICAgICAgICdodHRwOi8vZmIubWUvcmVhY3Qtd2FybmluZy1wb2x5ZmlsbHMnXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBWZXJzaW9uIGV4aXN0cyBvbmx5IGluIHRoZSBvcGVuLXNvdXJjZSB2ZXJzaW9uIG9mIFJlYWN0LCBub3QgaW4gRmFjZWJvb2snc1xuLy8gaW50ZXJuYWwgdmVyc2lvbi5cblJlYWN0LnZlcnNpb24gPSAnMC4xMS4xJztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdDtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpblxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudCA9IHJlcXVpcmUoXCIuL1JlYWN0RW1wdHlDb21wb25lbnRcIik7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoXCIuL1JlYWN0TW91bnRcIik7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbnZhciBSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbiA9IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIERPTSBub2RlIHJlbmRlcmVkIGJ5IHRoaXMgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtET01FbGVtZW50fSBUaGUgcm9vdCBub2RlIG9mIHRoaXMgY29tcG9uZW50LlxuICAgKiBAZmluYWxcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgZ2V0RE9NTm9kZTogZnVuY3Rpb24oKSB7XG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgIHRoaXMuaXNNb3VudGVkKCksXG4gICAgICAnZ2V0RE9NTm9kZSgpOiBBIGNvbXBvbmVudCBtdXN0IGJlIG1vdW50ZWQgdG8gaGF2ZSBhIERPTSBub2RlLidcbiAgICApIDogaW52YXJpYW50KHRoaXMuaXNNb3VudGVkKCkpKTtcbiAgICBpZiAoUmVhY3RFbXB0eUNvbXBvbmVudC5pc051bGxDb21wb25lbnRJRCh0aGlzLl9yb290Tm9kZUlEKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBSZWFjdE1vdW50LmdldE5vZGUodGhpcy5fcm9vdE5vZGVJRCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW47XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoXCIuL0V2ZW50Q29uc3RhbnRzXCIpO1xudmFyIEV2ZW50UGx1Z2luSHViID0gcmVxdWlyZShcIi4vRXZlbnRQbHVnaW5IdWJcIik7XG52YXIgRXZlbnRQbHVnaW5SZWdpc3RyeSA9IHJlcXVpcmUoXCIuL0V2ZW50UGx1Z2luUmVnaXN0cnlcIik7XG52YXIgUmVhY3RFdmVudEVtaXR0ZXJNaXhpbiA9IHJlcXVpcmUoXCIuL1JlYWN0RXZlbnRFbWl0dGVyTWl4aW5cIik7XG52YXIgVmlld3BvcnRNZXRyaWNzID0gcmVxdWlyZShcIi4vVmlld3BvcnRNZXRyaWNzXCIpO1xuXG52YXIgaXNFdmVudFN1cHBvcnRlZCA9IHJlcXVpcmUoXCIuL2lzRXZlbnRTdXBwb3J0ZWRcIik7XG52YXIgbWVyZ2UgPSByZXF1aXJlKFwiLi9tZXJnZVwiKTtcblxuLyoqXG4gKiBTdW1tYXJ5IG9mIGBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJgIGV2ZW50IGhhbmRsaW5nOlxuICpcbiAqICAtIFRvcC1sZXZlbCBkZWxlZ2F0aW9uIGlzIHVzZWQgdG8gdHJhcCBtb3N0IG5hdGl2ZSBicm93c2VyIGV2ZW50cy4gVGhpc1xuICogICAgbWF5IG9ubHkgb2NjdXIgaW4gdGhlIG1haW4gdGhyZWFkIGFuZCBpcyB0aGUgcmVzcG9uc2liaWxpdHkgb2ZcbiAqICAgIFJlYWN0RXZlbnRMaXN0ZW5lciwgd2hpY2ggaXMgaW5qZWN0ZWQgYW5kIGNhbiB0aGVyZWZvcmUgc3VwcG9ydCBwbHVnZ2FibGVcbiAqICAgIGV2ZW50IHNvdXJjZXMuIFRoaXMgaXMgdGhlIG9ubHkgd29yayB0aGF0IG9jY3VycyBpbiB0aGUgbWFpbiB0aHJlYWQuXG4gKlxuICogIC0gV2Ugbm9ybWFsaXplIGFuZCBkZS1kdXBsaWNhdGUgZXZlbnRzIHRvIGFjY291bnQgZm9yIGJyb3dzZXIgcXVpcmtzLiBUaGlzXG4gKiAgICBtYXkgYmUgZG9uZSBpbiB0aGUgd29ya2VyIHRocmVhZC5cbiAqXG4gKiAgLSBGb3J3YXJkIHRoZXNlIG5hdGl2ZSBldmVudHMgKHdpdGggdGhlIGFzc29jaWF0ZWQgdG9wLWxldmVsIHR5cGUgdXNlZCB0b1xuICogICAgdHJhcCBpdCkgdG8gYEV2ZW50UGx1Z2luSHViYCwgd2hpY2ggaW4gdHVybiB3aWxsIGFzayBwbHVnaW5zIGlmIHRoZXkgd2FudFxuICogICAgdG8gZXh0cmFjdCBhbnkgc3ludGhldGljIGV2ZW50cy5cbiAqXG4gKiAgLSBUaGUgYEV2ZW50UGx1Z2luSHViYCB3aWxsIHRoZW4gcHJvY2VzcyBlYWNoIGV2ZW50IGJ5IGFubm90YXRpbmcgdGhlbSB3aXRoXG4gKiAgICBcImRpc3BhdGNoZXNcIiwgYSBzZXF1ZW5jZSBvZiBsaXN0ZW5lcnMgYW5kIElEcyB0aGF0IGNhcmUgYWJvdXQgdGhhdCBldmVudC5cbiAqXG4gKiAgLSBUaGUgYEV2ZW50UGx1Z2luSHViYCB0aGVuIGRpc3BhdGNoZXMgdGhlIGV2ZW50cy5cbiAqXG4gKiBPdmVydmlldyBvZiBSZWFjdCBhbmQgdGhlIGV2ZW50IHN5c3RlbTpcbiAqXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiB8ICAgIERPTSAgICAgfCAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiAgICAgICB8ICAgICAgICAgICAuXG4gKiAgICAgICB2ICAgICAgICAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiB8IFJlYWN0RXZlbnQgfCAgICAuXG4gKiB8ICBMaXN0ZW5lciAgfCAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICArLS0tLS0tLS0rfFNpbXBsZUV2ZW50fFxuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgIHwgICAgICAgICB8UGx1Z2luICAgICB8XG4gKiArLS0tLS18LS0tLS0tKyAgICAuICAgICAgICAgICAgICAgdiAgICAgICAgICstLS0tLS0tLS0tLStcbiAqIHwgICAgIHwgICAgICB8ICAgIC4gICAgKy0tLS0tLS0tLS0tLS0tKyAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLStcbiAqIHwgICAgICstLS0tLS0tLS0tLS4tLS0+fEV2ZW50UGx1Z2luSHVifCAgICAgICAgICAgICAgICAgICAgfCAgICBFdmVudCAgIHxcbiAqIHwgICAgICAgICAgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgKy0tLS0tLS0tLS0tKyAgfCBQcm9wYWdhdG9yc3xcbiAqIHwgUmVhY3RFdmVudCB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgfFRhcEV2ZW50ICAgfCAgfC0tLS0tLS0tLS0tLXxcbiAqIHwgIEVtaXR0ZXIgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfDwtLS0rfFBsdWdpbiAgICAgfCAgfG90aGVyIHBsdWdpbnxcbiAqIHwgICAgICAgICAgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgKy0tLS0tLS0tLS0tKyAgfCAgdXRpbGl0aWVzIHxcbiAqIHwgICAgICstLS0tLS0tLS0tLS4tLS0+fCAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLStcbiAqIHwgICAgIHwgICAgICB8ICAgIC4gICAgKy0tLS0tLS0tLS0tLS0tK1xuICogKy0tLS0tfC0tLS0tLSsgICAgLiAgICAgICAgICAgICAgICBeICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgIHwgICAgICAgIHxFbnRlci9MZWF2ZXxcbiAqICAgICAgICsgICAgICAgICAgIC4gICAgICAgICAgICAgICAgKy0tLS0tLS0rfFBsdWdpbiAgICAgfFxuICogKy0tLS0tLS0tLS0tLS0rICAgLiAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiB8IGFwcGxpY2F0aW9uIHwgICAuXG4gKiB8LS0tLS0tLS0tLS0tLXwgICAuXG4gKiB8ICAgICAgICAgICAgIHwgICAuXG4gKiB8ICAgICAgICAgICAgIHwgICAuXG4gKiArLS0tLS0tLS0tLS0tLSsgICAuXG4gKiAgICAgICAgICAgICAgICAgICAuXG4gKiAgICBSZWFjdCBDb3JlICAgICAuICBHZW5lcmFsIFB1cnBvc2UgRXZlbnQgUGx1Z2luIFN5c3RlbVxuICovXG5cbnZhciBhbHJlYWR5TGlzdGVuaW5nVG8gPSB7fTtcbnZhciBpc01vbml0b3JpbmdTY3JvbGxWYWx1ZSA9IGZhbHNlO1xudmFyIHJlYWN0VG9wTGlzdGVuZXJzQ291bnRlciA9IDA7XG5cbi8vIEZvciBldmVudHMgbGlrZSAnc3VibWl0JyB3aGljaCBkb24ndCBjb25zaXN0ZW50bHkgYnViYmxlICh3aGljaCB3ZSB0cmFwIGF0IGFcbi8vIGxvd2VyIG5vZGUgdGhhbiBgZG9jdW1lbnRgKSwgYmluZGluZyBhdCBgZG9jdW1lbnRgIHdvdWxkIGNhdXNlIGR1cGxpY2F0ZVxuLy8gZXZlbnRzIHNvIHdlIGRvbid0IGluY2x1ZGUgdGhlbSBoZXJlXG52YXIgdG9wRXZlbnRNYXBwaW5nID0ge1xuICB0b3BCbHVyOiAnYmx1cicsXG4gIHRvcENoYW5nZTogJ2NoYW5nZScsXG4gIHRvcENsaWNrOiAnY2xpY2snLFxuICB0b3BDb21wb3NpdGlvbkVuZDogJ2NvbXBvc2l0aW9uZW5kJyxcbiAgdG9wQ29tcG9zaXRpb25TdGFydDogJ2NvbXBvc2l0aW9uc3RhcnQnLFxuICB0b3BDb21wb3NpdGlvblVwZGF0ZTogJ2NvbXBvc2l0aW9udXBkYXRlJyxcbiAgdG9wQ29udGV4dE1lbnU6ICdjb250ZXh0bWVudScsXG4gIHRvcENvcHk6ICdjb3B5JyxcbiAgdG9wQ3V0OiAnY3V0JyxcbiAgdG9wRG91YmxlQ2xpY2s6ICdkYmxjbGljaycsXG4gIHRvcERyYWc6ICdkcmFnJyxcbiAgdG9wRHJhZ0VuZDogJ2RyYWdlbmQnLFxuICB0b3BEcmFnRW50ZXI6ICdkcmFnZW50ZXInLFxuICB0b3BEcmFnRXhpdDogJ2RyYWdleGl0JyxcbiAgdG9wRHJhZ0xlYXZlOiAnZHJhZ2xlYXZlJyxcbiAgdG9wRHJhZ092ZXI6ICdkcmFnb3ZlcicsXG4gIHRvcERyYWdTdGFydDogJ2RyYWdzdGFydCcsXG4gIHRvcERyb3A6ICdkcm9wJyxcbiAgdG9wRm9jdXM6ICdmb2N1cycsXG4gIHRvcElucHV0OiAnaW5wdXQnLFxuICB0b3BLZXlEb3duOiAna2V5ZG93bicsXG4gIHRvcEtleVByZXNzOiAna2V5cHJlc3MnLFxuICB0b3BLZXlVcDogJ2tleXVwJyxcbiAgdG9wTW91c2VEb3duOiAnbW91c2Vkb3duJyxcbiAgdG9wTW91c2VNb3ZlOiAnbW91c2Vtb3ZlJyxcbiAgdG9wTW91c2VPdXQ6ICdtb3VzZW91dCcsXG4gIHRvcE1vdXNlT3ZlcjogJ21vdXNlb3ZlcicsXG4gIHRvcE1vdXNlVXA6ICdtb3VzZXVwJyxcbiAgdG9wUGFzdGU6ICdwYXN0ZScsXG4gIHRvcFNjcm9sbDogJ3Njcm9sbCcsXG4gIHRvcFNlbGVjdGlvbkNoYW5nZTogJ3NlbGVjdGlvbmNoYW5nZScsXG4gIHRvcFRleHRJbnB1dDogJ3RleHRJbnB1dCcsXG4gIHRvcFRvdWNoQ2FuY2VsOiAndG91Y2hjYW5jZWwnLFxuICB0b3BUb3VjaEVuZDogJ3RvdWNoZW5kJyxcbiAgdG9wVG91Y2hNb3ZlOiAndG91Y2htb3ZlJyxcbiAgdG9wVG91Y2hTdGFydDogJ3RvdWNoc3RhcnQnLFxuICB0b3BXaGVlbDogJ3doZWVsJ1xufTtcblxuLyoqXG4gKiBUbyBlbnN1cmUgbm8gY29uZmxpY3RzIHdpdGggb3RoZXIgcG90ZW50aWFsIFJlYWN0IGluc3RhbmNlcyBvbiB0aGUgcGFnZVxuICovXG52YXIgdG9wTGlzdGVuZXJzSURLZXkgPSBcIl9yZWFjdExpc3RlbmVyc0lEXCIgKyBTdHJpbmcoTWF0aC5yYW5kb20oKSkuc2xpY2UoMik7XG5cbmZ1bmN0aW9uIGdldExpc3RlbmluZ0ZvckRvY3VtZW50KG1vdW50QXQpIHtcbiAgLy8gSW4gSUU4LCBgbW91bnRBdGAgaXMgYSBob3N0IG9iamVjdCBhbmQgZG9lc24ndCBoYXZlIGBoYXNPd25Qcm9wZXJ0eWBcbiAgLy8gZGlyZWN0bHkuXG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vdW50QXQsIHRvcExpc3RlbmVyc0lES2V5KSkge1xuICAgIG1vdW50QXRbdG9wTGlzdGVuZXJzSURLZXldID0gcmVhY3RUb3BMaXN0ZW5lcnNDb3VudGVyKys7XG4gICAgYWxyZWFkeUxpc3RlbmluZ1RvW21vdW50QXRbdG9wTGlzdGVuZXJzSURLZXldXSA9IHt9O1xuICB9XG4gIHJldHVybiBhbHJlYWR5TGlzdGVuaW5nVG9bbW91bnRBdFt0b3BMaXN0ZW5lcnNJREtleV1dO1xufVxuXG4vKipcbiAqIGBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJgIGlzIHVzZWQgdG8gYXR0YWNoIHRvcC1sZXZlbCBldmVudCBsaXN0ZW5lcnMuIEZvclxuICogZXhhbXBsZTpcbiAqXG4gKiAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5wdXRMaXN0ZW5lcignbXlJRCcsICdvbkNsaWNrJywgbXlGdW5jdGlvbik7XG4gKlxuICogVGhpcyB3b3VsZCBhbGxvY2F0ZSBhIFwicmVnaXN0cmF0aW9uXCIgb2YgYCgnb25DbGljaycsIG15RnVuY3Rpb24pYCBvbiAnbXlJRCcuXG4gKlxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSBtZXJnZShSZWFjdEV2ZW50RW1pdHRlck1peGluLCB7XG5cbiAgLyoqXG4gICAqIEluamVjdGFibGUgZXZlbnQgYmFja2VuZFxuICAgKi9cbiAgUmVhY3RFdmVudExpc3RlbmVyOiBudWxsLFxuXG4gIGluamVjdGlvbjoge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBSZWFjdEV2ZW50TGlzdGVuZXJcbiAgICAgKi9cbiAgICBpbmplY3RSZWFjdEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uKFJlYWN0RXZlbnRMaXN0ZW5lcikge1xuICAgICAgUmVhY3RFdmVudExpc3RlbmVyLnNldEhhbmRsZVRvcExldmVsKFxuICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuaGFuZGxlVG9wTGV2ZWxcbiAgICAgICk7XG4gICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyID0gUmVhY3RFdmVudExpc3RlbmVyO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU2V0cyB3aGV0aGVyIG9yIG5vdCBhbnkgY3JlYXRlZCBjYWxsYmFja3Mgc2hvdWxkIGJlIGVuYWJsZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZCBUcnVlIGlmIGNhbGxiYWNrcyBzaG91bGQgYmUgZW5hYmxlZC5cbiAgICovXG4gIHNldEVuYWJsZWQ6IGZ1bmN0aW9uKGVuYWJsZWQpIHtcbiAgICBpZiAoUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lcikge1xuICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci5zZXRFbmFibGVkKGVuYWJsZWQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBjYWxsYmFja3MgYXJlIGVuYWJsZWQuXG4gICAqL1xuICBpc0VuYWJsZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhIShcbiAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIgJiZcbiAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIuaXNFbmFibGVkKClcbiAgICApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXZSBsaXN0ZW4gZm9yIGJ1YmJsZWQgdG91Y2ggZXZlbnRzIG9uIHRoZSBkb2N1bWVudCBvYmplY3QuXG4gICAqXG4gICAqIEZpcmVmb3ggdjguMDEgKGFuZCBwb3NzaWJseSBvdGhlcnMpIGV4aGliaXRlZCBzdHJhbmdlIGJlaGF2aW9yIHdoZW5cbiAgICogbW91bnRpbmcgYG9ubW91c2Vtb3ZlYCBldmVudHMgYXQgc29tZSBub2RlIHRoYXQgd2FzIG5vdCB0aGUgZG9jdW1lbnRcbiAgICogZWxlbWVudC4gVGhlIHN5bXB0b21zIHdlcmUgdGhhdCBpZiB5b3VyIG1vdXNlIGlzIG5vdCBtb3Zpbmcgb3ZlciBzb21ldGhpbmdcbiAgICogY29udGFpbmVkIHdpdGhpbiB0aGF0IG1vdW50IHBvaW50IChmb3IgZXhhbXBsZSBvbiB0aGUgYmFja2dyb3VuZCkgdGhlXG4gICAqIHRvcC1sZXZlbCBsaXN0ZW5lcnMgZm9yIGBvbm1vdXNlbW92ZWAgd29uJ3QgYmUgY2FsbGVkLiBIb3dldmVyLCBpZiB5b3VcbiAgICogcmVnaXN0ZXIgdGhlIGBtb3VzZW1vdmVgIG9uIHRoZSBkb2N1bWVudCBvYmplY3QsIHRoZW4gaXQgd2lsbCBvZiBjb3Vyc2VcbiAgICogY2F0Y2ggYWxsIGBtb3VzZW1vdmVgcy4gVGhpcyBhbG9uZyB3aXRoIGlPUyBxdWlya3MsIGp1c3RpZmllcyByZXN0cmljdGluZ1xuICAgKiB0b3AtbGV2ZWwgbGlzdGVuZXJzIHRvIHRoZSBkb2N1bWVudCBvYmplY3Qgb25seSwgYXQgbGVhc3QgZm9yIHRoZXNlXG4gICAqIG1vdmVtZW50IHR5cGVzIG9mIGV2ZW50cyBhbmQgcG9zc2libHkgYWxsIGV2ZW50cy5cbiAgICpcbiAgICogQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxMC8wOS9jbGlja19ldmVudF9kZWwuaHRtbFxuICAgKlxuICAgKiBBbHNvLCBga2V5dXBgL2BrZXlwcmVzc2AvYGtleWRvd25gIGRvIG5vdCBidWJibGUgdG8gdGhlIHdpbmRvdyBvbiBJRSwgYnV0XG4gICAqIHRoZXkgYnViYmxlIHRvIGRvY3VtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZW50RG9jdW1lbnRIYW5kbGUgRG9jdW1lbnQgd2hpY2ggb3ducyB0aGUgY29udGFpbmVyXG4gICAqL1xuICBsaXN0ZW5UbzogZnVuY3Rpb24ocmVnaXN0cmF0aW9uTmFtZSwgY29udGVudERvY3VtZW50SGFuZGxlKSB7XG4gICAgdmFyIG1vdW50QXQgPSBjb250ZW50RG9jdW1lbnRIYW5kbGU7XG4gICAgdmFyIGlzTGlzdGVuaW5nID0gZ2V0TGlzdGVuaW5nRm9yRG9jdW1lbnQobW91bnRBdCk7XG4gICAgdmFyIGRlcGVuZGVuY2llcyA9IEV2ZW50UGx1Z2luUmVnaXN0cnkuXG4gICAgICByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuXG4gICAgdmFyIHRvcExldmVsVHlwZXMgPSBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gZGVwZW5kZW5jaWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGRlcGVuZGVuY3kgPSBkZXBlbmRlbmNpZXNbaV07XG4gICAgICBpZiAoIShcbiAgICAgICAgICAgIGlzTGlzdGVuaW5nLmhhc093blByb3BlcnR5KGRlcGVuZGVuY3kpICYmXG4gICAgICAgICAgICBpc0xpc3RlbmluZ1tkZXBlbmRlbmN5XVxuICAgICAgICAgICkpIHtcbiAgICAgICAgaWYgKGRlcGVuZGVuY3kgPT09IHRvcExldmVsVHlwZXMudG9wV2hlZWwpIHtcbiAgICAgICAgICBpZiAoaXNFdmVudFN1cHBvcnRlZCgnd2hlZWwnKSkge1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KFxuICAgICAgICAgICAgICB0b3BMZXZlbFR5cGVzLnRvcFdoZWVsLFxuICAgICAgICAgICAgICAnd2hlZWwnLFxuICAgICAgICAgICAgICBtb3VudEF0XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNFdmVudFN1cHBvcnRlZCgnbW91c2V3aGVlbCcpKSB7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQoXG4gICAgICAgICAgICAgIHRvcExldmVsVHlwZXMudG9wV2hlZWwsXG4gICAgICAgICAgICAgICdtb3VzZXdoZWVsJyxcbiAgICAgICAgICAgICAgbW91bnRBdFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRmlyZWZveCBuZWVkcyB0byBjYXB0dXJlIGEgZGlmZmVyZW50IG1vdXNlIHNjcm9sbCBldmVudC5cbiAgICAgICAgICAgIC8vIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9kb20vZXZlbnRzL3Rlc3RzL3Njcm9sbC5odG1sXG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQoXG4gICAgICAgICAgICAgIHRvcExldmVsVHlwZXMudG9wV2hlZWwsXG4gICAgICAgICAgICAgICdET01Nb3VzZVNjcm9sbCcsXG4gICAgICAgICAgICAgIG1vdW50QXRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGRlcGVuZGVuY3kgPT09IHRvcExldmVsVHlwZXMudG9wU2Nyb2xsKSB7XG5cbiAgICAgICAgICBpZiAoaXNFdmVudFN1cHBvcnRlZCgnc2Nyb2xsJywgdHJ1ZSkpIHtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcENhcHR1cmVkRXZlbnQoXG4gICAgICAgICAgICAgIHRvcExldmVsVHlwZXMudG9wU2Nyb2xsLFxuICAgICAgICAgICAgICAnc2Nyb2xsJyxcbiAgICAgICAgICAgICAgbW91bnRBdFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KFxuICAgICAgICAgICAgICB0b3BMZXZlbFR5cGVzLnRvcFNjcm9sbCxcbiAgICAgICAgICAgICAgJ3Njcm9sbCcsXG4gICAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIuV0lORE9XX0hBTkRMRVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZGVwZW5kZW5jeSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BGb2N1cyB8fFxuICAgICAgICAgICAgZGVwZW5kZW5jeSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BCbHVyKSB7XG5cbiAgICAgICAgICBpZiAoaXNFdmVudFN1cHBvcnRlZCgnZm9jdXMnLCB0cnVlKSkge1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQ2FwdHVyZWRFdmVudChcbiAgICAgICAgICAgICAgdG9wTGV2ZWxUeXBlcy50b3BGb2N1cyxcbiAgICAgICAgICAgICAgJ2ZvY3VzJyxcbiAgICAgICAgICAgICAgbW91bnRBdFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcENhcHR1cmVkRXZlbnQoXG4gICAgICAgICAgICAgIHRvcExldmVsVHlwZXMudG9wQmx1cixcbiAgICAgICAgICAgICAgJ2JsdXInLFxuICAgICAgICAgICAgICBtb3VudEF0XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNFdmVudFN1cHBvcnRlZCgnZm9jdXNpbicpKSB7XG4gICAgICAgICAgICAvLyBJRSBoYXMgYGZvY3VzaW5gIGFuZCBgZm9jdXNvdXRgIGV2ZW50cyB3aGljaCBidWJibGUuXG4gICAgICAgICAgICAvLyBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvYmxvZy9hcmNoaXZlcy8yMDA4LzA0L2RlbGVnYXRpbmdfdGhlLmh0bWxcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudChcbiAgICAgICAgICAgICAgdG9wTGV2ZWxUeXBlcy50b3BGb2N1cyxcbiAgICAgICAgICAgICAgJ2ZvY3VzaW4nLFxuICAgICAgICAgICAgICBtb3VudEF0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KFxuICAgICAgICAgICAgICB0b3BMZXZlbFR5cGVzLnRvcEJsdXIsXG4gICAgICAgICAgICAgICdmb2N1c291dCcsXG4gICAgICAgICAgICAgIG1vdW50QXRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gdG8gbWFrZSBzdXJlIGJsdXIgYW5kIGZvY3VzIGV2ZW50IGxpc3RlbmVycyBhcmUgb25seSBhdHRhY2hlZCBvbmNlXG4gICAgICAgICAgaXNMaXN0ZW5pbmdbdG9wTGV2ZWxUeXBlcy50b3BCbHVyXSA9IHRydWU7XG4gICAgICAgICAgaXNMaXN0ZW5pbmdbdG9wTGV2ZWxUeXBlcy50b3BGb2N1c10gPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHRvcEV2ZW50TWFwcGluZy5oYXNPd25Qcm9wZXJ0eShkZXBlbmRlbmN5KSkge1xuICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudChcbiAgICAgICAgICAgIGRlcGVuZGVuY3ksXG4gICAgICAgICAgICB0b3BFdmVudE1hcHBpbmdbZGVwZW5kZW5jeV0sXG4gICAgICAgICAgICBtb3VudEF0XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlzTGlzdGVuaW5nW2RlcGVuZGVuY3ldID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdHJhcEJ1YmJsZWRFdmVudDogZnVuY3Rpb24odG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGhhbmRsZSkge1xuICAgIHJldHVybiBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQoXG4gICAgICB0b3BMZXZlbFR5cGUsXG4gICAgICBoYW5kbGVyQmFzZU5hbWUsXG4gICAgICBoYW5kbGVcbiAgICApO1xuICB9LFxuXG4gIHRyYXBDYXB0dXJlZEV2ZW50OiBmdW5jdGlvbih0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKSB7XG4gICAgcmV0dXJuIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcENhcHR1cmVkRXZlbnQoXG4gICAgICB0b3BMZXZlbFR5cGUsXG4gICAgICBoYW5kbGVyQmFzZU5hbWUsXG4gICAgICBoYW5kbGVcbiAgICApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBMaXN0ZW5zIHRvIHdpbmRvdyBzY3JvbGwgYW5kIHJlc2l6ZSBldmVudHMuIFdlIGNhY2hlIHNjcm9sbCB2YWx1ZXMgc28gdGhhdFxuICAgKiBhcHBsaWNhdGlvbiBjb2RlIGNhbiBhY2Nlc3MgdGhlbSB3aXRob3V0IHRyaWdnZXJpbmcgcmVmbG93cy5cbiAgICpcbiAgICogTk9URTogU2Nyb2xsIGV2ZW50cyBkbyBub3QgYnViYmxlLlxuICAgKlxuICAgKiBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvZG9tL2V2ZW50cy9zY3JvbGwuaHRtbFxuICAgKi9cbiAgZW5zdXJlU2Nyb2xsVmFsdWVNb25pdG9yaW5nOiBmdW5jdGlvbigpe1xuICAgIGlmICghaXNNb25pdG9yaW5nU2Nyb2xsVmFsdWUpIHtcbiAgICAgIHZhciByZWZyZXNoID0gVmlld3BvcnRNZXRyaWNzLnJlZnJlc2hTY3JvbGxWYWx1ZXM7XG4gICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLm1vbml0b3JTY3JvbGxWYWx1ZShyZWZyZXNoKTtcbiAgICAgIGlzTW9uaXRvcmluZ1Njcm9sbFZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH0sXG5cbiAgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzOiBFdmVudFBsdWdpbkh1Yi5ldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MsXG5cbiAgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXM6IEV2ZW50UGx1Z2luSHViLnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLFxuXG4gIHB1dExpc3RlbmVyOiBFdmVudFBsdWdpbkh1Yi5wdXRMaXN0ZW5lcixcblxuICBnZXRMaXN0ZW5lcjogRXZlbnRQbHVnaW5IdWIuZ2V0TGlzdGVuZXIsXG5cbiAgZGVsZXRlTGlzdGVuZXI6IEV2ZW50UGx1Z2luSHViLmRlbGV0ZUxpc3RlbmVyLFxuXG4gIGRlbGV0ZUFsbExpc3RlbmVyczogRXZlbnRQbHVnaW5IdWIuZGVsZXRlQWxsTGlzdGVuZXJzXG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcjtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDU1NUcmFuc2l0aW9uR3JvdXBcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIFJlYWN0ID0gcmVxdWlyZShcIi4vUmVhY3RcIik7XG5cbnZhciBSZWFjdFRyYW5zaXRpb25Hcm91cCA9IHJlcXVpcmUoXCIuL1JlYWN0VHJhbnNpdGlvbkdyb3VwXCIpO1xudmFyIFJlYWN0Q1NTVHJhbnNpdGlvbkdyb3VwQ2hpbGQgPSByZXF1aXJlKFwiLi9SZWFjdENTU1RyYW5zaXRpb25Hcm91cENoaWxkXCIpO1xuXG52YXIgUmVhY3RDU1NUcmFuc2l0aW9uR3JvdXAgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnUmVhY3RDU1NUcmFuc2l0aW9uR3JvdXAnLFxuXG4gIHByb3BUeXBlczoge1xuICAgIHRyYW5zaXRpb25OYW1lOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXG4gICAgdHJhbnNpdGlvbkVudGVyOiBSZWFjdC5Qcm9wVHlwZXMuYm9vbCxcbiAgICB0cmFuc2l0aW9uTGVhdmU6IFJlYWN0LlByb3BUeXBlcy5ib29sXG4gIH0sXG5cbiAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHJhbnNpdGlvbkVudGVyOiB0cnVlLFxuICAgICAgdHJhbnNpdGlvbkxlYXZlOiB0cnVlXG4gICAgfTtcbiAgfSxcblxuICBfd3JhcENoaWxkOiBmdW5jdGlvbihjaGlsZCkge1xuICAgIC8vIFdlIG5lZWQgdG8gcHJvdmlkZSB0aGlzIGNoaWxkRmFjdG9yeSBzbyB0aGF0XG4gICAgLy8gUmVhY3RDU1NUcmFuc2l0aW9uR3JvdXBDaGlsZCBjYW4gcmVjZWl2ZSB1cGRhdGVzIHRvIG5hbWUsIGVudGVyLCBhbmRcbiAgICAvLyBsZWF2ZSB3aGlsZSBpdCBpcyBsZWF2aW5nLlxuICAgIHJldHVybiBSZWFjdENTU1RyYW5zaXRpb25Hcm91cENoaWxkKFxuICAgICAge1xuICAgICAgICBuYW1lOiB0aGlzLnByb3BzLnRyYW5zaXRpb25OYW1lLFxuICAgICAgICBlbnRlcjogdGhpcy5wcm9wcy50cmFuc2l0aW9uRW50ZXIsXG4gICAgICAgIGxlYXZlOiB0aGlzLnByb3BzLnRyYW5zaXRpb25MZWF2ZVxuICAgICAgfSxcbiAgICAgIGNoaWxkXG4gICAgKTtcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZmVyUHJvcHNUbyhcbiAgICAgIFJlYWN0VHJhbnNpdGlvbkdyb3VwKFxuICAgICAgICB7Y2hpbGRGYWN0b3J5OiB0aGlzLl93cmFwQ2hpbGR9LFxuICAgICAgICB0aGlzLnByb3BzLmNoaWxkcmVuXG4gICAgICApXG4gICAgKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDU1NUcmFuc2l0aW9uR3JvdXA7XG4iLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENTU1RyYW5zaXRpb25Hcm91cENoaWxkXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoXCIuL1JlYWN0XCIpO1xuXG52YXIgQ1NTQ29yZSA9IHJlcXVpcmUoXCIuL0NTU0NvcmVcIik7XG52YXIgUmVhY3RUcmFuc2l0aW9uRXZlbnRzID0gcmVxdWlyZShcIi4vUmVhY3RUcmFuc2l0aW9uRXZlbnRzXCIpO1xuXG52YXIgb25seUNoaWxkID0gcmVxdWlyZShcIi4vb25seUNoaWxkXCIpO1xuXG4vLyBXZSBkb24ndCByZW1vdmUgdGhlIGVsZW1lbnQgZnJvbSB0aGUgRE9NIHVudGlsIHdlIHJlY2VpdmUgYW4gYW5pbWF0aW9uZW5kIG9yXG4vLyB0cmFuc2l0aW9uZW5kIGV2ZW50LiBJZiB0aGUgdXNlciBzY3Jld3MgdXAgYW5kIGZvcmdldHMgdG8gYWRkIGFuIGFuaW1hdGlvblxuLy8gdGhlaXIgbm9kZSB3aWxsIGJlIHN0dWNrIGluIHRoZSBET00gZm9yZXZlciwgc28gd2UgZGV0ZWN0IGlmIGFuIGFuaW1hdGlvblxuLy8gZG9lcyBub3Qgc3RhcnQgYW5kIGlmIGl0IGRvZXNuJ3QsIHdlIGp1c3QgY2FsbCB0aGUgZW5kIGxpc3RlbmVyIGltbWVkaWF0ZWx5LlxudmFyIFRJQ0sgPSAxNztcbnZhciBOT19FVkVOVF9USU1FT1VUID0gNTAwMDtcblxudmFyIG5vRXZlbnRMaXN0ZW5lciA9IG51bGw7XG5cblxuaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICBub0V2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbigpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICAndHJhbnNpdGlvbigpOiB0cmllZCB0byBwZXJmb3JtIGFuIGFuaW1hdGlvbiB3aXRob3V0ICcgK1xuICAgICAgJ2FuIGFuaW1hdGlvbmVuZCBvciB0cmFuc2l0aW9uZW5kIGV2ZW50IGFmdGVyIHRpbWVvdXQgKCcgK1xuICAgICAgTk9fRVZFTlRfVElNRU9VVCArICdtcykuIFlvdSBzaG91bGQgZWl0aGVyIGRpc2FibGUgdGhpcyAnICtcbiAgICAgICd0cmFuc2l0aW9uIGluIEpTIG9yIGFkZCBhIENTUyBhbmltYXRpb24vdHJhbnNpdGlvbi4nXG4gICAgKTtcbiAgfTtcbn1cblxudmFyIFJlYWN0Q1NTVHJhbnNpdGlvbkdyb3VwQ2hpbGQgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnUmVhY3RDU1NUcmFuc2l0aW9uR3JvdXBDaGlsZCcsXG5cbiAgdHJhbnNpdGlvbjogZnVuY3Rpb24oYW5pbWF0aW9uVHlwZSwgZmluaXNoQ2FsbGJhY2spIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuZ2V0RE9NTm9kZSgpO1xuICAgIHZhciBjbGFzc05hbWUgPSB0aGlzLnByb3BzLm5hbWUgKyAnLScgKyBhbmltYXRpb25UeXBlO1xuICAgIHZhciBhY3RpdmVDbGFzc05hbWUgPSBjbGFzc05hbWUgKyAnLWFjdGl2ZSc7XG4gICAgdmFyIG5vRXZlbnRUaW1lb3V0ID0gbnVsbDtcblxuICAgIHZhciBlbmRMaXN0ZW5lciA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgICBjbGVhclRpbWVvdXQobm9FdmVudFRpbWVvdXQpO1xuICAgICAgfVxuXG4gICAgICBDU1NDb3JlLnJlbW92ZUNsYXNzKG5vZGUsIGNsYXNzTmFtZSk7XG4gICAgICBDU1NDb3JlLnJlbW92ZUNsYXNzKG5vZGUsIGFjdGl2ZUNsYXNzTmFtZSk7XG5cbiAgICAgIFJlYWN0VHJhbnNpdGlvbkV2ZW50cy5yZW1vdmVFbmRFdmVudExpc3RlbmVyKG5vZGUsIGVuZExpc3RlbmVyKTtcblxuICAgICAgLy8gVXN1YWxseSB0aGlzIG9wdGlvbmFsIGNhbGxiYWNrIGlzIHVzZWQgZm9yIGluZm9ybWluZyBhbiBvd25lciBvZlxuICAgICAgLy8gYSBsZWF2ZSBhbmltYXRpb24gYW5kIHRlbGxpbmcgaXQgdG8gcmVtb3ZlIHRoZSBjaGlsZC5cbiAgICAgIGZpbmlzaENhbGxiYWNrICYmIGZpbmlzaENhbGxiYWNrKCk7XG4gICAgfTtcblxuICAgIFJlYWN0VHJhbnNpdGlvbkV2ZW50cy5hZGRFbmRFdmVudExpc3RlbmVyKG5vZGUsIGVuZExpc3RlbmVyKTtcblxuICAgIENTU0NvcmUuYWRkQ2xhc3Mobm9kZSwgY2xhc3NOYW1lKTtcblxuICAgIC8vIE5lZWQgdG8gZG8gdGhpcyB0byBhY3R1YWxseSB0cmlnZ2VyIGEgdHJhbnNpdGlvbi5cbiAgICB0aGlzLnF1ZXVlQ2xhc3MoYWN0aXZlQ2xhc3NOYW1lKTtcblxuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgIG5vRXZlbnRUaW1lb3V0ID0gc2V0VGltZW91dChub0V2ZW50TGlzdGVuZXIsIE5PX0VWRU5UX1RJTUVPVVQpO1xuICAgIH1cbiAgfSxcblxuICBxdWV1ZUNsYXNzOiBmdW5jdGlvbihjbGFzc05hbWUpIHtcbiAgICB0aGlzLmNsYXNzTmFtZVF1ZXVlLnB1c2goY2xhc3NOYW1lKTtcblxuICAgIGlmICghdGhpcy50aW1lb3V0KSB7XG4gICAgICB0aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMuZmx1c2hDbGFzc05hbWVRdWV1ZSwgVElDSyk7XG4gICAgfVxuICB9LFxuXG4gIGZsdXNoQ2xhc3NOYW1lUXVldWU6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmlzTW91bnRlZCgpKSB7XG4gICAgICB0aGlzLmNsYXNzTmFtZVF1ZXVlLmZvckVhY2goXG4gICAgICAgIENTU0NvcmUuYWRkQ2xhc3MuYmluZChDU1NDb3JlLCB0aGlzLmdldERPTU5vZGUoKSlcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuY2xhc3NOYW1lUXVldWUubGVuZ3RoID0gMDtcbiAgICB0aGlzLnRpbWVvdXQgPSBudWxsO1xuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxNb3VudDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jbGFzc05hbWVRdWV1ZSA9IFtdO1xuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50OiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy50aW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcbiAgICB9XG4gIH0sXG5cbiAgY29tcG9uZW50V2lsbEVudGVyOiBmdW5jdGlvbihkb25lKSB7XG4gICAgaWYgKHRoaXMucHJvcHMuZW50ZXIpIHtcbiAgICAgIHRoaXMudHJhbnNpdGlvbignZW50ZXInLCBkb25lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9uZSgpO1xuICAgIH1cbiAgfSxcblxuICBjb21wb25lbnRXaWxsTGVhdmU6IGZ1bmN0aW9uKGRvbmUpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5sZWF2ZSkge1xuICAgICAgdGhpcy50cmFuc2l0aW9uKCdsZWF2ZScsIGRvbmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb25lKCk7XG4gICAgfVxuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG9ubHlDaGlsZCh0aGlzLnByb3BzLmNoaWxkcmVuKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDU1NUcmFuc2l0aW9uR3JvdXBDaGlsZDtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENoaWxkcmVuXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoXCIuL1Bvb2xlZENsYXNzXCIpO1xuXG52YXIgdHJhdmVyc2VBbGxDaGlsZHJlbiA9IHJlcXVpcmUoXCIuL3RyYXZlcnNlQWxsQ2hpbGRyZW5cIik7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoXCIuL3dhcm5pbmdcIik7XG5cbnZhciB0d29Bcmd1bWVudFBvb2xlciA9IFBvb2xlZENsYXNzLnR3b0FyZ3VtZW50UG9vbGVyO1xudmFyIHRocmVlQXJndW1lbnRQb29sZXIgPSBQb29sZWRDbGFzcy50aHJlZUFyZ3VtZW50UG9vbGVyO1xuXG4vKipcbiAqIFBvb2xlZENsYXNzIHJlcHJlc2VudGluZyB0aGUgYm9va2tlZXBpbmcgYXNzb2NpYXRlZCB3aXRoIHBlcmZvcm1pbmcgYSBjaGlsZFxuICogdHJhdmVyc2FsLiBBbGxvd3MgYXZvaWRpbmcgYmluZGluZyBjYWxsYmFja3MuXG4gKlxuICogQGNvbnN0cnVjdG9yIEZvckVhY2hCb29rS2VlcGluZ1xuICogQHBhcmFtIHshZnVuY3Rpb259IGZvckVhY2hGdW5jdGlvbiBGdW5jdGlvbiB0byBwZXJmb3JtIHRyYXZlcnNhbCB3aXRoLlxuICogQHBhcmFtIHs/Kn0gZm9yRWFjaENvbnRleHQgQ29udGV4dCB0byBwZXJmb3JtIGNvbnRleHQgd2l0aC5cbiAqL1xuZnVuY3Rpb24gRm9yRWFjaEJvb2tLZWVwaW5nKGZvckVhY2hGdW5jdGlvbiwgZm9yRWFjaENvbnRleHQpIHtcbiAgdGhpcy5mb3JFYWNoRnVuY3Rpb24gPSBmb3JFYWNoRnVuY3Rpb247XG4gIHRoaXMuZm9yRWFjaENvbnRleHQgPSBmb3JFYWNoQ29udGV4dDtcbn1cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhGb3JFYWNoQm9va0tlZXBpbmcsIHR3b0FyZ3VtZW50UG9vbGVyKTtcblxuZnVuY3Rpb24gZm9yRWFjaFNpbmdsZUNoaWxkKHRyYXZlcnNlQ29udGV4dCwgY2hpbGQsIG5hbWUsIGkpIHtcbiAgdmFyIGZvckVhY2hCb29rS2VlcGluZyA9IHRyYXZlcnNlQ29udGV4dDtcbiAgZm9yRWFjaEJvb2tLZWVwaW5nLmZvckVhY2hGdW5jdGlvbi5jYWxsKFxuICAgIGZvckVhY2hCb29rS2VlcGluZy5mb3JFYWNoQ29udGV4dCwgY2hpbGQsIGkpO1xufVxuXG4vKipcbiAqIEl0ZXJhdGVzIHRocm91Z2ggY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFRoZSBwcm92aWRlZCBmb3JFYWNoRnVuYyhjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmb3JFYWNoRnVuYy5cbiAqIEBwYXJhbSB7Kn0gZm9yRWFjaENvbnRleHQgQ29udGV4dCBmb3IgZm9yRWFjaENvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaEZ1bmMsIGZvckVhY2hDb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG5cbiAgdmFyIHRyYXZlcnNlQ29udGV4dCA9XG4gICAgRm9yRWFjaEJvb2tLZWVwaW5nLmdldFBvb2xlZChmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpO1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoU2luZ2xlQ2hpbGQsIHRyYXZlcnNlQ29udGV4dCk7XG4gIEZvckVhY2hCb29rS2VlcGluZy5yZWxlYXNlKHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbi8qKlxuICogUG9vbGVkQ2xhc3MgcmVwcmVzZW50aW5nIHRoZSBib29ra2VlcGluZyBhc3NvY2lhdGVkIHdpdGggcGVyZm9ybWluZyBhIGNoaWxkXG4gKiBtYXBwaW5nLiBBbGxvd3MgYXZvaWRpbmcgYmluZGluZyBjYWxsYmFja3MuXG4gKlxuICogQGNvbnN0cnVjdG9yIE1hcEJvb2tLZWVwaW5nXG4gKiBAcGFyYW0geyEqfSBtYXBSZXN1bHQgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9yZGVyZWQgbWFwIG9mIHJlc3VsdHMuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gbWFwRnVuY3Rpb24gRnVuY3Rpb24gdG8gcGVyZm9ybSBtYXBwaW5nIHdpdGguXG4gKiBAcGFyYW0gez8qfSBtYXBDb250ZXh0IENvbnRleHQgdG8gcGVyZm9ybSBtYXBwaW5nIHdpdGguXG4gKi9cbmZ1bmN0aW9uIE1hcEJvb2tLZWVwaW5nKG1hcFJlc3VsdCwgbWFwRnVuY3Rpb24sIG1hcENvbnRleHQpIHtcbiAgdGhpcy5tYXBSZXN1bHQgPSBtYXBSZXN1bHQ7XG4gIHRoaXMubWFwRnVuY3Rpb24gPSBtYXBGdW5jdGlvbjtcbiAgdGhpcy5tYXBDb250ZXh0ID0gbWFwQ29udGV4dDtcbn1cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhNYXBCb29rS2VlcGluZywgdGhyZWVBcmd1bWVudFBvb2xlcik7XG5cbmZ1bmN0aW9uIG1hcFNpbmdsZUNoaWxkSW50b0NvbnRleHQodHJhdmVyc2VDb250ZXh0LCBjaGlsZCwgbmFtZSwgaSkge1xuICB2YXIgbWFwQm9va0tlZXBpbmcgPSB0cmF2ZXJzZUNvbnRleHQ7XG4gIHZhciBtYXBSZXN1bHQgPSBtYXBCb29rS2VlcGluZy5tYXBSZXN1bHQ7XG5cbiAgdmFyIGtleVVuaXF1ZSA9ICFtYXBSZXN1bHQuaGFzT3duUHJvcGVydHkobmFtZSk7XG4gIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKFxuICAgIGtleVVuaXF1ZSxcbiAgICAnUmVhY3RDaGlsZHJlbi5tYXAoLi4uKTogRW5jb3VudGVyZWQgdHdvIGNoaWxkcmVuIHdpdGggdGhlIHNhbWUga2V5LCAnICtcbiAgICAnYCVzYC4gQ2hpbGQga2V5cyBtdXN0IGJlIHVuaXF1ZTsgd2hlbiB0d28gY2hpbGRyZW4gc2hhcmUgYSBrZXksIG9ubHkgJyArXG4gICAgJ3RoZSBmaXJzdCBjaGlsZCB3aWxsIGJlIHVzZWQuJyxcbiAgICBuYW1lXG4gICkgOiBudWxsKTtcblxuICBpZiAoa2V5VW5pcXVlKSB7XG4gICAgdmFyIG1hcHBlZENoaWxkID1cbiAgICAgIG1hcEJvb2tLZWVwaW5nLm1hcEZ1bmN0aW9uLmNhbGwobWFwQm9va0tlZXBpbmcubWFwQ29udGV4dCwgY2hpbGQsIGkpO1xuICAgIG1hcFJlc3VsdFtuYW1lXSA9IG1hcHBlZENoaWxkO1xuICB9XG59XG5cbi8qKlxuICogTWFwcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogVGhlIHByb3ZpZGVkIG1hcEZ1bmN0aW9uKGNoaWxkLCBrZXksIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBUT0RPOiBUaGlzIG1heSBsaWtlbHkgYnJlYWsgYW55IGNhbGxzIHRvIGBSZWFjdENoaWxkcmVuLm1hcGAgdGhhdCB3ZXJlXG4gKiBwcmV2aW91c2x5IHJlbHlpbmcgb24gdGhlIGZhY3QgdGhhdCB3ZSBndWFyZGVkIGFnYWluc3QgbnVsbCBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gbWFwRnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IG1hcENvbnRleHQgQ29udGV4dCBmb3IgbWFwRnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCBjb250YWluaW5nIHRoZSBvcmRlcmVkIG1hcCBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuYywgY29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuXG4gIHZhciBtYXBSZXN1bHQgPSB7fTtcbiAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IE1hcEJvb2tLZWVwaW5nLmdldFBvb2xlZChtYXBSZXN1bHQsIGZ1bmMsIGNvbnRleHQpO1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBtYXBTaW5nbGVDaGlsZEludG9Db250ZXh0LCB0cmF2ZXJzZUNvbnRleHQpO1xuICBNYXBCb29rS2VlcGluZy5yZWxlYXNlKHRyYXZlcnNlQ29udGV4dCk7XG4gIHJldHVybiBtYXBSZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGZvckVhY2hTaW5nbGVDaGlsZER1bW15KHRyYXZlcnNlQ29udGV4dCwgY2hpbGQsIG5hbWUsIGkpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogQ291bnQgdGhlIG51bWJlciBvZiBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzXG4gKiBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuLlxuICovXG5mdW5jdGlvbiBjb3VudENoaWxkcmVuKGNoaWxkcmVuLCBjb250ZXh0KSB7XG4gIHJldHVybiB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoU2luZ2xlQ2hpbGREdW1teSwgbnVsbCk7XG59XG5cbnZhciBSZWFjdENoaWxkcmVuID0ge1xuICBmb3JFYWNoOiBmb3JFYWNoQ2hpbGRyZW4sXG4gIG1hcDogbWFwQ2hpbGRyZW4sXG4gIGNvdW50OiBjb3VudENoaWxkcmVuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q2hpbGRyZW47XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDb21wb25lbnRcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIFJlYWN0RGVzY3JpcHRvciA9IHJlcXVpcmUoXCIuL1JlYWN0RGVzY3JpcHRvclwiKTtcbnZhciBSZWFjdE93bmVyID0gcmVxdWlyZShcIi4vUmVhY3RPd25lclwiKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKFwiLi9SZWFjdFVwZGF0ZXNcIik7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG52YXIga2V5TWlycm9yID0gcmVxdWlyZShcIi4va2V5TWlycm9yXCIpO1xudmFyIG1lcmdlID0gcmVxdWlyZShcIi4vbWVyZ2VcIik7XG5cbi8qKlxuICogRXZlcnkgUmVhY3QgY29tcG9uZW50IGlzIGluIG9uZSBvZiB0aGVzZSBsaWZlIGN5Y2xlcy5cbiAqL1xudmFyIENvbXBvbmVudExpZmVDeWNsZSA9IGtleU1pcnJvcih7XG4gIC8qKlxuICAgKiBNb3VudGVkIGNvbXBvbmVudHMgaGF2ZSBhIERPTSBub2RlIHJlcHJlc2VudGF0aW9uIGFuZCBhcmUgY2FwYWJsZSBvZlxuICAgKiByZWNlaXZpbmcgbmV3IHByb3BzLlxuICAgKi9cbiAgTU9VTlRFRDogbnVsbCxcbiAgLyoqXG4gICAqIFVubW91bnRlZCBjb21wb25lbnRzIGFyZSBpbmFjdGl2ZSBhbmQgY2Fubm90IHJlY2VpdmUgbmV3IHByb3BzLlxuICAgKi9cbiAgVU5NT1VOVEVEOiBudWxsXG59KTtcblxudmFyIGluamVjdGVkID0gZmFsc2U7XG5cbi8qKlxuICogT3B0aW9uYWxseSBpbmplY3RhYmxlIGVudmlyb25tZW50IGRlcGVuZGVudCBjbGVhbnVwIGhvb2suIChzZXJ2ZXIgdnMuXG4gKiBicm93c2VyIGV0YykuIEV4YW1wbGU6IEEgYnJvd3NlciBzeXN0ZW0gY2FjaGVzIERPTSBub2RlcyBiYXNlZCBvbiBjb21wb25lbnRcbiAqIElEIGFuZCBtdXN0IHJlbW92ZSB0aGF0IGNhY2hlIGVudHJ5IHdoZW4gdGhpcyBpbnN0YW5jZSBpcyB1bm1vdW50ZWQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xudmFyIHVubW91bnRJREZyb21FbnZpcm9ubWVudCA9IG51bGw7XG5cbi8qKlxuICogVGhlIFwiaW1hZ2VcIiBvZiBhIGNvbXBvbmVudCB0cmVlLCBpcyB0aGUgcGxhdGZvcm0gc3BlY2lmaWMgKHR5cGljYWxseVxuICogc2VyaWFsaXplZCkgZGF0YSB0aGF0IHJlcHJlc2VudHMgYSB0cmVlIG9mIGxvd2VyIGxldmVsIFVJIGJ1aWxkaW5nIGJsb2Nrcy5cbiAqIE9uIHRoZSB3ZWIsIHRoaXMgXCJpbWFnZVwiIGlzIEhUTUwgbWFya3VwIHdoaWNoIGRlc2NyaWJlcyBhIGNvbnN0cnVjdGlvbiBvZlxuICogbG93IGxldmVsIGBkaXZgIGFuZCBgc3BhbmAgbm9kZXMuIE90aGVyIHBsYXRmb3JtcyBtYXkgaGF2ZSBkaWZmZXJlbnRcbiAqIGVuY29kaW5nIG9mIHRoaXMgXCJpbWFnZVwiLiBUaGlzIG11c3QgYmUgaW5qZWN0ZWQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xudmFyIG1vdW50SW1hZ2VJbnRvTm9kZSA9IG51bGw7XG5cbi8qKlxuICogQ29tcG9uZW50cyBhcmUgdGhlIGJhc2ljIHVuaXRzIG9mIGNvbXBvc2l0aW9uIGluIFJlYWN0LlxuICpcbiAqIEV2ZXJ5IGNvbXBvbmVudCBhY2NlcHRzIGEgc2V0IG9mIGtleWVkIGlucHV0IHBhcmFtZXRlcnMga25vd24gYXMgXCJwcm9wc1wiIHRoYXRcbiAqIGFyZSBpbml0aWFsaXplZCBieSB0aGUgY29uc3RydWN0b3IuIE9uY2UgYSBjb21wb25lbnQgaXMgbW91bnRlZCwgdGhlIHByb3BzXG4gKiBjYW4gYmUgbXV0YXRlZCB1c2luZyBgc2V0UHJvcHNgIG9yIGByZXBsYWNlUHJvcHNgLlxuICpcbiAqIEV2ZXJ5IGNvbXBvbmVudCBpcyBjYXBhYmxlIG9mIHRoZSBmb2xsb3dpbmcgb3BlcmF0aW9uczpcbiAqXG4gKiAgIGBtb3VudENvbXBvbmVudGBcbiAqICAgICBJbml0aWFsaXplcyB0aGUgY29tcG9uZW50LCByZW5kZXJzIG1hcmt1cCwgYW5kIHJlZ2lzdGVycyBldmVudCBsaXN0ZW5lcnMuXG4gKlxuICogICBgcmVjZWl2ZUNvbXBvbmVudGBcbiAqICAgICBVcGRhdGVzIHRoZSByZW5kZXJlZCBET00gbm9kZXMgdG8gbWF0Y2ggdGhlIGdpdmVuIGNvbXBvbmVudC5cbiAqXG4gKiAgIGB1bm1vdW50Q29tcG9uZW50YFxuICogICAgIFJlbGVhc2VzIGFueSByZXNvdXJjZXMgYWxsb2NhdGVkIGJ5IHRoaXMgY29tcG9uZW50LlxuICpcbiAqIENvbXBvbmVudHMgY2FuIGFsc28gYmUgXCJvd25lZFwiIGJ5IG90aGVyIGNvbXBvbmVudHMuIEJlaW5nIG93bmVkIGJ5IGFub3RoZXJcbiAqIGNvbXBvbmVudCBtZWFucyBiZWluZyBjb25zdHJ1Y3RlZCBieSB0aGF0IGNvbXBvbmVudC4gVGhpcyBpcyBkaWZmZXJlbnQgZnJvbVxuICogYmVpbmcgdGhlIGNoaWxkIG9mIGEgY29tcG9uZW50LCB3aGljaCBtZWFucyBoYXZpbmcgYSBET00gcmVwcmVzZW50YXRpb24gdGhhdFxuICogaXMgYSBjaGlsZCBvZiB0aGUgRE9NIHJlcHJlc2VudGF0aW9uIG9mIHRoYXQgY29tcG9uZW50LlxuICpcbiAqIEBjbGFzcyBSZWFjdENvbXBvbmVudFxuICovXG52YXIgUmVhY3RDb21wb25lbnQgPSB7XG5cbiAgaW5qZWN0aW9uOiB7XG4gICAgaW5qZWN0RW52aXJvbm1lbnQ6IGZ1bmN0aW9uKFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQpIHtcbiAgICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAgICFpbmplY3RlZCxcbiAgICAgICAgJ1JlYWN0Q29tcG9uZW50OiBpbmplY3RFbnZpcm9ubWVudCgpIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlLidcbiAgICAgICkgOiBpbnZhcmlhbnQoIWluamVjdGVkKSk7XG4gICAgICBtb3VudEltYWdlSW50b05vZGUgPSBSZWFjdENvbXBvbmVudEVudmlyb25tZW50Lm1vdW50SW1hZ2VJbnRvTm9kZTtcbiAgICAgIHVubW91bnRJREZyb21FbnZpcm9ubWVudCA9XG4gICAgICAgIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQudW5tb3VudElERnJvbUVudmlyb25tZW50O1xuICAgICAgUmVhY3RDb21wb25lbnQuQmFja2VuZElET3BlcmF0aW9ucyA9XG4gICAgICAgIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQuQmFja2VuZElET3BlcmF0aW9ucztcbiAgICAgIGluamVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgTGlmZUN5Y2xlOiBDb21wb25lbnRMaWZlQ3ljbGUsXG5cbiAgLyoqXG4gICAqIEluamVjdGVkIG1vZHVsZSB0aGF0IHByb3ZpZGVzIGFiaWxpdHkgdG8gbXV0YXRlIGluZGl2aWR1YWwgcHJvcGVydGllcy5cbiAgICogSW5qZWN0ZWQgaW50byB0aGUgYmFzZSBjbGFzcyBiZWNhdXNlIG1hbnkgZGlmZmVyZW50IHN1YmNsYXNzZXMgbmVlZCBhY2Nlc3NcbiAgICogdG8gdGhpcy5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBCYWNrZW5kSURPcGVyYXRpb25zOiBudWxsLFxuXG4gIC8qKlxuICAgKiBCYXNlIGZ1bmN0aW9uYWxpdHkgZm9yIGV2ZXJ5IFJlYWN0Q29tcG9uZW50IGNvbnN0cnVjdG9yLiBNaXhlZCBpbnRvIHRoZVxuICAgKiBgUmVhY3RDb21wb25lbnRgIHByb3RvdHlwZSwgYnV0IGV4cG9zZWQgc3RhdGljYWxseSBmb3IgZWFzeSBhY2Nlc3MuXG4gICAqXG4gICAqIEBsZW5kcyB7UmVhY3RDb21wb25lbnQucHJvdG90eXBlfVxuICAgKi9cbiAgTWl4aW46IHtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICogQGZpbmFsXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGlzTW91bnRlZDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbGlmZUN5Y2xlU3RhdGUgPT09IENvbXBvbmVudExpZmVDeWNsZS5NT1VOVEVEO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBwcm9wcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsUHJvcHMgU3Vic2V0IG9mIHRoZSBuZXh0IHByb3BzLlxuICAgICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgcHJvcHMgYXJlIHVwZGF0ZWQuXG4gICAgICogQGZpbmFsXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHNldFByb3BzOiBmdW5jdGlvbihwYXJ0aWFsUHJvcHMsIGNhbGxiYWNrKSB7XG4gICAgICAvLyBNZXJnZSB3aXRoIHRoZSBwZW5kaW5nIGRlc2NyaXB0b3IgaWYgaXQgZXhpc3RzLCBvdGhlcndpc2Ugd2l0aCBleGlzdGluZ1xuICAgICAgLy8gZGVzY3JpcHRvciBwcm9wcy5cbiAgICAgIHZhciBkZXNjcmlwdG9yID0gdGhpcy5fcGVuZGluZ0Rlc2NyaXB0b3IgfHwgdGhpcy5fZGVzY3JpcHRvcjtcbiAgICAgIHRoaXMucmVwbGFjZVByb3BzKFxuICAgICAgICBtZXJnZShkZXNjcmlwdG9yLnByb3BzLCBwYXJ0aWFsUHJvcHMpLFxuICAgICAgICBjYWxsYmFja1xuICAgICAgKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBwcm9wcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wcyBOZXcgcHJvcHMuXG4gICAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBwcm9wcyBhcmUgdXBkYXRlZC5cbiAgICAgKiBAZmluYWxcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgcmVwbGFjZVByb3BzOiBmdW5jdGlvbihwcm9wcywgY2FsbGJhY2spIHtcbiAgICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAgIHRoaXMuaXNNb3VudGVkKCksXG4gICAgICAgICdyZXBsYWNlUHJvcHMoLi4uKTogQ2FuIG9ubHkgdXBkYXRlIGEgbW91bnRlZCBjb21wb25lbnQuJ1xuICAgICAgKSA6IGludmFyaWFudCh0aGlzLmlzTW91bnRlZCgpKSk7XG4gICAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgICB0aGlzLl9tb3VudERlcHRoID09PSAwLFxuICAgICAgICAncmVwbGFjZVByb3BzKC4uLik6IFlvdSBjYWxsZWQgYHNldFByb3BzYCBvciBgcmVwbGFjZVByb3BzYCBvbiBhICcgK1xuICAgICAgICAnY29tcG9uZW50IHdpdGggYSBwYXJlbnQuIFRoaXMgaXMgYW4gYW50aS1wYXR0ZXJuIHNpbmNlIHByb3BzIHdpbGwgJyArXG4gICAgICAgICdnZXQgcmVhY3RpdmVseSB1cGRhdGVkIHdoZW4gcmVuZGVyZWQuIEluc3RlYWQsIGNoYW5nZSB0aGUgb3duZXJcXCdzICcgK1xuICAgICAgICAnYHJlbmRlcmAgbWV0aG9kIHRvIHBhc3MgdGhlIGNvcnJlY3QgdmFsdWUgYXMgcHJvcHMgdG8gdGhlIGNvbXBvbmVudCAnICtcbiAgICAgICAgJ3doZXJlIGl0IGlzIGNyZWF0ZWQuJ1xuICAgICAgKSA6IGludmFyaWFudCh0aGlzLl9tb3VudERlcHRoID09PSAwKSk7XG4gICAgICAvLyBUaGlzIGlzIGEgZGVvcHRpbWl6ZWQgcGF0aC4gV2Ugb3B0aW1pemUgZm9yIGFsd2F5cyBoYXZpbmcgYSBkZXNjcmlwdG9yLlxuICAgICAgLy8gVGhpcyBjcmVhdGVzIGFuIGV4dHJhIGludGVybmFsIGRlc2NyaXB0b3IuXG4gICAgICB0aGlzLl9wZW5kaW5nRGVzY3JpcHRvciA9IFJlYWN0RGVzY3JpcHRvci5jbG9uZUFuZFJlcGxhY2VQcm9wcyhcbiAgICAgICAgdGhpcy5fcGVuZGluZ0Rlc2NyaXB0b3IgfHwgdGhpcy5fZGVzY3JpcHRvcixcbiAgICAgICAgcHJvcHNcbiAgICAgICk7XG4gICAgICBSZWFjdFVwZGF0ZXMuZW5xdWV1ZVVwZGF0ZSh0aGlzLCBjYWxsYmFjayk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNjaGVkdWxlIGEgcGFydGlhbCB1cGRhdGUgdG8gdGhlIHByb3BzLiBPbmx5IHVzZWQgZm9yIGludGVybmFsIHRlc3RpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGlhbFByb3BzIFN1YnNldCBvZiB0aGUgbmV4dCBwcm9wcy5cbiAgICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHByb3BzIGFyZSB1cGRhdGVkLlxuICAgICAqIEBmaW5hbFxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9zZXRQcm9wc0ludGVybmFsOiBmdW5jdGlvbihwYXJ0aWFsUHJvcHMsIGNhbGxiYWNrKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgZGVvcHRpbWl6ZWQgcGF0aC4gV2Ugb3B0aW1pemUgZm9yIGFsd2F5cyBoYXZpbmcgYSBkZXNjcmlwdG9yLlxuICAgICAgLy8gVGhpcyBjcmVhdGVzIGFuIGV4dHJhIGludGVybmFsIGRlc2NyaXB0b3IuXG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHRoaXMuX3BlbmRpbmdEZXNjcmlwdG9yIHx8IHRoaXMuX2Rlc2NyaXB0b3I7XG4gICAgICB0aGlzLl9wZW5kaW5nRGVzY3JpcHRvciA9IFJlYWN0RGVzY3JpcHRvci5jbG9uZUFuZFJlcGxhY2VQcm9wcyhcbiAgICAgICAgZGVzY3JpcHRvcixcbiAgICAgICAgbWVyZ2UoZGVzY3JpcHRvci5wcm9wcywgcGFydGlhbFByb3BzKVxuICAgICAgKTtcbiAgICAgIFJlYWN0VXBkYXRlcy5lbnF1ZXVlVXBkYXRlKHRoaXMsIGNhbGxiYWNrKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQmFzZSBjb25zdHJ1Y3RvciBmb3IgYWxsIFJlYWN0IGNvbXBvbmVudHMuXG4gICAgICpcbiAgICAgKiBTdWJjbGFzc2VzIHRoYXQgb3ZlcnJpZGUgdGhpcyBtZXRob2Qgc2hvdWxkIG1ha2Ugc3VyZSB0byBpbnZva2VcbiAgICAgKiBgUmVhY3RDb21wb25lbnQuTWl4aW4uY29uc3RydWN0LmNhbGwodGhpcywgLi4uKWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0RGVzY3JpcHRvcn0gZGVzY3JpcHRvclxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNvbnN0cnVjdDogZnVuY3Rpb24oZGVzY3JpcHRvcikge1xuICAgICAgLy8gVGhpcyBpcyB0aGUgcHVibGljIGV4cG9zZWQgcHJvcHMgb2JqZWN0IGFmdGVyIGl0IGhhcyBiZWVuIHByb2Nlc3NlZFxuICAgICAgLy8gd2l0aCBkZWZhdWx0IHByb3BzLiBUaGUgZGVzY3JpcHRvcidzIHByb3BzIHJlcHJlc2VudHMgdGhlIHRydWUgaW50ZXJuYWxcbiAgICAgIC8vIHN0YXRlIG9mIHRoZSBwcm9wcy5cbiAgICAgIHRoaXMucHJvcHMgPSBkZXNjcmlwdG9yLnByb3BzO1xuICAgICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgY29tcG9uZW50LlxuICAgICAgLy8gVGhpcyBpcyBhY2Nlc3NpYmxlIHRocm91Z2ggdGhlIGRlc2NyaXB0b3IgYnV0IHdlIG1haW50YWluIGFuIGV4dHJhXG4gICAgICAvLyBmaWVsZCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIGRldnRvb2xzIGFuZCBhcyBhIHdheSB0byBtYWtlIGFuXG4gICAgICAvLyBpbmNyZW1lbnRhbCB1cGRhdGUuIFRPRE86IENvbnNpZGVyIGRlcHJlY2F0aW5nIHRoaXMgZmllbGQuXG4gICAgICB0aGlzLl9vd25lciA9IGRlc2NyaXB0b3IuX293bmVyO1xuXG4gICAgICAvLyBBbGwgY29tcG9uZW50cyBzdGFydCB1bm1vdW50ZWQuXG4gICAgICB0aGlzLl9saWZlQ3ljbGVTdGF0ZSA9IENvbXBvbmVudExpZmVDeWNsZS5VTk1PVU5URUQ7XG5cbiAgICAgIC8vIFNlZSBSZWFjdFVwZGF0ZXMuXG4gICAgICB0aGlzLl9wZW5kaW5nQ2FsbGJhY2tzID0gbnVsbDtcblxuICAgICAgLy8gV2Uga2VlcCB0aGUgb2xkIGRlc2NyaXB0b3IgYW5kIGEgcmVmZXJlbmNlIHRvIHRoZSBwZW5kaW5nIGRlc2NyaXB0b3JcbiAgICAgIC8vIHRvIHRyYWNrIHVwZGF0ZXMuXG4gICAgICB0aGlzLl9kZXNjcmlwdG9yID0gZGVzY3JpcHRvcjtcbiAgICAgIHRoaXMuX3BlbmRpbmdEZXNjcmlwdG9yID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIGNvbXBvbmVudCwgcmVuZGVycyBtYXJrdXAsIGFuZCByZWdpc3RlcnMgZXZlbnQgbGlzdGVuZXJzLlxuICAgICAqXG4gICAgICogTk9URTogVGhpcyBkb2VzIG5vdCBpbnNlcnQgYW55IG5vZGVzIGludG8gdGhlIERPTS5cbiAgICAgKlxuICAgICAqIFN1YmNsYXNzZXMgdGhhdCBvdmVycmlkZSB0aGlzIG1ldGhvZCBzaG91bGQgbWFrZSBzdXJlIHRvIGludm9rZVxuICAgICAqIGBSZWFjdENvbXBvbmVudC5NaXhpbi5tb3VudENvbXBvbmVudC5jYWxsKHRoaXMsIC4uLilgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJvb3RJRCBET00gSUQgb2YgdGhlIHJvb3Qgbm9kZS5cbiAgICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbW91bnREZXB0aCBudW1iZXIgb2YgY29tcG9uZW50cyBpbiB0aGUgb3duZXIgaGllcmFyY2h5LlxuICAgICAqIEByZXR1cm4gez9zdHJpbmd9IFJlbmRlcmVkIG1hcmt1cCB0byBiZSBpbnNlcnRlZCBpbnRvIHRoZSBET00uXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgbW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uKHJvb3RJRCwgdHJhbnNhY3Rpb24sIG1vdW50RGVwdGgpIHtcbiAgICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAgICF0aGlzLmlzTW91bnRlZCgpLFxuICAgICAgICAnbW91bnRDb21wb25lbnQoJXMsIC4uLik6IENhbiBvbmx5IG1vdW50IGFuIHVubW91bnRlZCBjb21wb25lbnQuICcgK1xuICAgICAgICAnTWFrZSBzdXJlIHRvIGF2b2lkIHN0b3JpbmcgY29tcG9uZW50cyBiZXR3ZWVuIHJlbmRlcnMgb3IgcmV1c2luZyBhICcgK1xuICAgICAgICAnc2luZ2xlIGNvbXBvbmVudCBpbnN0YW5jZSBpbiBtdWx0aXBsZSBwbGFjZXMuJyxcbiAgICAgICAgcm9vdElEXG4gICAgICApIDogaW52YXJpYW50KCF0aGlzLmlzTW91bnRlZCgpKSk7XG4gICAgICB2YXIgcHJvcHMgPSB0aGlzLl9kZXNjcmlwdG9yLnByb3BzO1xuICAgICAgaWYgKHByb3BzLnJlZiAhPSBudWxsKSB7XG4gICAgICAgIHZhciBvd25lciA9IHRoaXMuX2Rlc2NyaXB0b3IuX293bmVyO1xuICAgICAgICBSZWFjdE93bmVyLmFkZENvbXBvbmVudEFzUmVmVG8odGhpcywgcHJvcHMucmVmLCBvd25lcik7XG4gICAgICB9XG4gICAgICB0aGlzLl9yb290Tm9kZUlEID0gcm9vdElEO1xuICAgICAgdGhpcy5fbGlmZUN5Y2xlU3RhdGUgPSBDb21wb25lbnRMaWZlQ3ljbGUuTU9VTlRFRDtcbiAgICAgIHRoaXMuX21vdW50RGVwdGggPSBtb3VudERlcHRoO1xuICAgICAgLy8gRWZmZWN0aXZlbHk6IHJldHVybiAnJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVsZWFzZXMgYW55IHJlc291cmNlcyBhbGxvY2F0ZWQgYnkgYG1vdW50Q29tcG9uZW50YC5cbiAgICAgKlxuICAgICAqIE5PVEU6IFRoaXMgZG9lcyBub3QgcmVtb3ZlIGFueSBub2RlcyBmcm9tIHRoZSBET00uXG4gICAgICpcbiAgICAgKiBTdWJjbGFzc2VzIHRoYXQgb3ZlcnJpZGUgdGhpcyBtZXRob2Qgc2hvdWxkIG1ha2Ugc3VyZSB0byBpbnZva2VcbiAgICAgKiBgUmVhY3RDb21wb25lbnQuTWl4aW4udW5tb3VudENvbXBvbmVudC5jYWxsKHRoaXMpYC5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICAgdGhpcy5pc01vdW50ZWQoKSxcbiAgICAgICAgJ3VubW91bnRDb21wb25lbnQoKTogQ2FuIG9ubHkgdW5tb3VudCBhIG1vdW50ZWQgY29tcG9uZW50LidcbiAgICAgICkgOiBpbnZhcmlhbnQodGhpcy5pc01vdW50ZWQoKSkpO1xuICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgIGlmIChwcm9wcy5yZWYgIT0gbnVsbCkge1xuICAgICAgICBSZWFjdE93bmVyLnJlbW92ZUNvbXBvbmVudEFzUmVmRnJvbSh0aGlzLCBwcm9wcy5yZWYsIHRoaXMuX293bmVyKTtcbiAgICAgIH1cbiAgICAgIHVubW91bnRJREZyb21FbnZpcm9ubWVudCh0aGlzLl9yb290Tm9kZUlEKTtcbiAgICAgIHRoaXMuX3Jvb3ROb2RlSUQgPSBudWxsO1xuICAgICAgdGhpcy5fbGlmZUN5Y2xlU3RhdGUgPSBDb21wb25lbnRMaWZlQ3ljbGUuVU5NT1VOVEVEO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIG5ldyBpbnN0YW5jZSBvZiB0aGlzIGNvbXBvbmVudCwgdXBkYXRlcyB0aGUgcmVuZGVyZWQgRE9NIG5vZGVzXG4gICAgICogYXMgaWYgdGhhdCBpbnN0YW5jZSB3YXMgcmVuZGVyZWQgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIFN1YmNsYXNzZXMgdGhhdCBvdmVycmlkZSB0aGlzIG1ldGhvZCBzaG91bGQgbWFrZSBzdXJlIHRvIGludm9rZVxuICAgICAqIGBSZWFjdENvbXBvbmVudC5NaXhpbi5yZWNlaXZlQ29tcG9uZW50LmNhbGwodGhpcywgLi4uKWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dENvbXBvbmVudCBOZXh0IHNldCBvZiBwcm9wZXJ0aWVzLlxuICAgICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICByZWNlaXZlQ29tcG9uZW50OiBmdW5jdGlvbihuZXh0RGVzY3JpcHRvciwgdHJhbnNhY3Rpb24pIHtcbiAgICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAgIHRoaXMuaXNNb3VudGVkKCksXG4gICAgICAgICdyZWNlaXZlQ29tcG9uZW50KC4uLik6IENhbiBvbmx5IHVwZGF0ZSBhIG1vdW50ZWQgY29tcG9uZW50LidcbiAgICAgICkgOiBpbnZhcmlhbnQodGhpcy5pc01vdW50ZWQoKSkpO1xuICAgICAgdGhpcy5fcGVuZGluZ0Rlc2NyaXB0b3IgPSBuZXh0RGVzY3JpcHRvcjtcbiAgICAgIHRoaXMucGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5KHRyYW5zYWN0aW9uKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSWYgYF9wZW5kaW5nRGVzY3JpcHRvcmAgaXMgc2V0LCB1cGRhdGUgdGhlIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwZXJmb3JtVXBkYXRlSWZOZWNlc3Nhcnk6IGZ1bmN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgICBpZiAodGhpcy5fcGVuZGluZ0Rlc2NyaXB0b3IgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgcHJldkRlc2NyaXB0b3IgPSB0aGlzLl9kZXNjcmlwdG9yO1xuICAgICAgdmFyIG5leHREZXNjcmlwdG9yID0gdGhpcy5fcGVuZGluZ0Rlc2NyaXB0b3I7XG4gICAgICB0aGlzLl9kZXNjcmlwdG9yID0gbmV4dERlc2NyaXB0b3I7XG4gICAgICB0aGlzLnByb3BzID0gbmV4dERlc2NyaXB0b3IucHJvcHM7XG4gICAgICB0aGlzLl9vd25lciA9IG5leHREZXNjcmlwdG9yLl9vd25lcjtcbiAgICAgIHRoaXMuX3BlbmRpbmdEZXNjcmlwdG9yID0gbnVsbDtcbiAgICAgIHRoaXMudXBkYXRlQ29tcG9uZW50KHRyYW5zYWN0aW9uLCBwcmV2RGVzY3JpcHRvcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGNvbXBvbmVudCdzIGN1cnJlbnRseSBtb3VudGVkIHJlcHJlc2VudGF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwcmV2RGVzY3JpcHRvclxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24odHJhbnNhY3Rpb24sIHByZXZEZXNjcmlwdG9yKSB7XG4gICAgICB2YXIgbmV4dERlc2NyaXB0b3IgPSB0aGlzLl9kZXNjcmlwdG9yO1xuXG4gICAgICAvLyBJZiBlaXRoZXIgdGhlIG93bmVyIG9yIGEgYHJlZmAgaGFzIGNoYW5nZWQsIG1ha2Ugc3VyZSB0aGUgbmV3ZXN0IG93bmVyXG4gICAgICAvLyBoYXMgc3RvcmVkIGEgcmVmZXJlbmNlIHRvIGB0aGlzYCwgYW5kIHRoZSBwcmV2aW91cyBvd25lciAoaWYgZGlmZmVyZW50KVxuICAgICAgLy8gaGFzIGZvcmdvdHRlbiB0aGUgcmVmZXJlbmNlIHRvIGB0aGlzYC4gV2UgdXNlIHRoZSBkZXNjcmlwdG9yIGluc3RlYWRcbiAgICAgIC8vIG9mIHRoZSBwdWJsaWMgdGhpcy5wcm9wcyBiZWNhdXNlIHRoZSBwb3N0IHByb2Nlc3NpbmcgY2Fubm90IGRldGVybWluZVxuICAgICAgLy8gYSByZWYuIFRoZSByZWYgY29uY2VwdHVhbGx5IGxpdmVzIG9uIHRoZSBkZXNjcmlwdG9yLlxuXG4gICAgICAvLyBUT0RPOiBTaG91bGQgdGhpcyBldmVuIGJlIHBvc3NpYmxlPyBUaGUgb3duZXIgY2Fubm90IGNoYW5nZSBiZWNhdXNlXG4gICAgICAvLyBpdCdzIGZvcmJpZGRlbiBieSBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudC4gVGhlIHJlZiBjYW4gY2hhbmdlXG4gICAgICAvLyBpZiB5b3Ugc3dhcCB0aGUga2V5cyBvZiBidXQgbm90IHRoZSByZWZzLiBSZWNvbnNpZGVyIHdoZXJlIHRoaXMgY2hlY2tcbiAgICAgIC8vIGlzIG1hZGUuIEl0IHByb2JhYmx5IGJlbG9uZ3Mgd2hlcmUgdGhlIGtleSBjaGVja2luZyBhbmRcbiAgICAgIC8vIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQgaXMgZG9uZS5cblxuICAgICAgaWYgKG5leHREZXNjcmlwdG9yLl9vd25lciAhPT0gcHJldkRlc2NyaXB0b3IuX293bmVyIHx8XG4gICAgICAgICAgbmV4dERlc2NyaXB0b3IucHJvcHMucmVmICE9PSBwcmV2RGVzY3JpcHRvci5wcm9wcy5yZWYpIHtcbiAgICAgICAgaWYgKHByZXZEZXNjcmlwdG9yLnByb3BzLnJlZiAhPSBudWxsKSB7XG4gICAgICAgICAgUmVhY3RPd25lci5yZW1vdmVDb21wb25lbnRBc1JlZkZyb20oXG4gICAgICAgICAgICB0aGlzLCBwcmV2RGVzY3JpcHRvci5wcm9wcy5yZWYsIHByZXZEZXNjcmlwdG9yLl9vd25lclxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29ycmVjdCwgZXZlbiBpZiB0aGUgb3duZXIgaXMgdGhlIHNhbWUsIGFuZCBvbmx5IHRoZSByZWYgaGFzIGNoYW5nZWQuXG4gICAgICAgIGlmIChuZXh0RGVzY3JpcHRvci5wcm9wcy5yZWYgIT0gbnVsbCkge1xuICAgICAgICAgIFJlYWN0T3duZXIuYWRkQ29tcG9uZW50QXNSZWZUbyhcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBuZXh0RGVzY3JpcHRvci5wcm9wcy5yZWYsXG4gICAgICAgICAgICBuZXh0RGVzY3JpcHRvci5fb3duZXJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vdW50cyB0aGlzIGNvbXBvbmVudCBhbmQgaW5zZXJ0cyBpdCBpbnRvIHRoZSBET00uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcm9vdElEIERPTSBJRCBvZiB0aGUgcm9vdCBub2RlLlxuICAgICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIG1vdW50IGludG8uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzaG91bGRSZXVzZU1hcmt1cCBJZiB0cnVlLCBkbyBub3QgaW5zZXJ0IG1hcmt1cFxuICAgICAqIEBmaW5hbFxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqIEBzZWUge1JlYWN0TW91bnQucmVuZGVyQ29tcG9uZW50fVxuICAgICAqL1xuICAgIG1vdW50Q29tcG9uZW50SW50b05vZGU6IGZ1bmN0aW9uKHJvb3RJRCwgY29udGFpbmVyLCBzaG91bGRSZXVzZU1hcmt1cCkge1xuICAgICAgdmFyIHRyYW5zYWN0aW9uID0gUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24uZ2V0UG9vbGVkKCk7XG4gICAgICB0cmFuc2FjdGlvbi5wZXJmb3JtKFxuICAgICAgICB0aGlzLl9tb3VudENvbXBvbmVudEludG9Ob2RlLFxuICAgICAgICB0aGlzLFxuICAgICAgICByb290SUQsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICAgIHNob3VsZFJldXNlTWFya3VwXG4gICAgICApO1xuICAgICAgUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24ucmVsZWFzZSh0cmFuc2FjdGlvbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByb290SUQgRE9NIElEIG9mIHRoZSByb290IG5vZGUuXG4gICAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdG8gbW91bnQgaW50by5cbiAgICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzaG91bGRSZXVzZU1hcmt1cCBJZiB0cnVlLCBkbyBub3QgaW5zZXJ0IG1hcmt1cFxuICAgICAqIEBmaW5hbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21vdW50Q29tcG9uZW50SW50b05vZGU6IGZ1bmN0aW9uKFxuICAgICAgICByb290SUQsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICAgIHNob3VsZFJldXNlTWFya3VwKSB7XG4gICAgICB2YXIgbWFya3VwID0gdGhpcy5tb3VudENvbXBvbmVudChyb290SUQsIHRyYW5zYWN0aW9uLCAwKTtcbiAgICAgIG1vdW50SW1hZ2VJbnRvTm9kZShtYXJrdXAsIGNvbnRhaW5lciwgc2hvdWxkUmV1c2VNYXJrdXApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhpcyBjb21wb25lbnQgaXMgb3duZWQgYnkgdGhlIHN1cHBsaWVkIGBvd25lcmAgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gb3duZXIgQ29tcG9uZW50IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG93bmVyc2Agb3ducyB0aGlzIGNvbXBvbmVudC5cbiAgICAgKiBAZmluYWxcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBpc093bmVkQnk6IGZ1bmN0aW9uKG93bmVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb3duZXIgPT09IG93bmVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGFub3RoZXIgY29tcG9uZW50LCB0aGF0IHNoYXJlcyB0aGUgc2FtZSBvd25lciBhcyB0aGlzIG9uZSwgYnkgcmVmLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJlZiBvZiBhIHNpYmxpbmcgQ29tcG9uZW50LlxuICAgICAqIEByZXR1cm4gez9SZWFjdENvbXBvbmVudH0gdGhlIGFjdHVhbCBzaWJsaW5nIENvbXBvbmVudC5cbiAgICAgKiBAZmluYWxcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBnZXRTaWJsaW5nQnlSZWY6IGZ1bmN0aW9uKHJlZikge1xuICAgICAgdmFyIG93bmVyID0gdGhpcy5fb3duZXI7XG4gICAgICBpZiAoIW93bmVyIHx8ICFvd25lci5yZWZzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG93bmVyLnJlZnNbcmVmXTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDb21wb25lbnQ7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnRcbiAqL1xuXG4vKmpzbGludCBldmlsOiB0cnVlICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgUmVhY3RET01JRE9wZXJhdGlvbnMgPSByZXF1aXJlKFwiLi9SZWFjdERPTUlET3BlcmF0aW9uc1wiKTtcbnZhciBSZWFjdE1hcmt1cENoZWNrc3VtID0gcmVxdWlyZShcIi4vUmVhY3RNYXJrdXBDaGVja3N1bVwiKTtcbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZShcIi4vUmVhY3RNb3VudFwiKTtcbnZhciBSZWFjdFBlcmYgPSByZXF1aXJlKFwiLi9SZWFjdFBlcmZcIik7XG52YXIgUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbiA9IHJlcXVpcmUoXCIuL1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb25cIik7XG5cbnZhciBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIgPSByZXF1aXJlKFwiLi9nZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXJcIik7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xudmFyIHNldElubmVySFRNTCA9IHJlcXVpcmUoXCIuL3NldElubmVySFRNTFwiKTtcblxuXG52YXIgRUxFTUVOVF9OT0RFX1RZUEUgPSAxO1xudmFyIERPQ19OT0RFX1RZUEUgPSA5O1xuXG5cbi8qKlxuICogQWJzdHJhY3RzIGF3YXkgYWxsIGZ1bmN0aW9uYWxpdHkgb2YgYFJlYWN0Q29tcG9uZW50YCByZXF1aXJlcyBrbm93bGVkZ2Ugb2ZcbiAqIHRoZSBicm93c2VyIGNvbnRleHQuXG4gKi9cbnZhciBSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudCA9IHtcbiAgUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbjogUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbixcblxuICBCYWNrZW5kSURPcGVyYXRpb25zOiBSZWFjdERPTUlET3BlcmF0aW9ucyxcblxuICAvKipcbiAgICogSWYgYSBwYXJ0aWN1bGFyIGVudmlyb25tZW50IHJlcXVpcmVzIHRoYXQgc29tZSByZXNvdXJjZXMgYmUgY2xlYW5lZCB1cCxcbiAgICogc3BlY2lmeSB0aGlzIGluIHRoZSBpbmplY3RlZCBNaXhpbi4gSW4gdGhlIERPTSwgd2Ugd291bGQgbGlrZWx5IHdhbnQgdG9cbiAgICogcHVyZ2UgYW55IGNhY2hlZCBub2RlIElEIGxvb2t1cHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB1bm1vdW50SURGcm9tRW52aXJvbm1lbnQ6IGZ1bmN0aW9uKHJvb3ROb2RlSUQpIHtcbiAgICBSZWFjdE1vdW50LnB1cmdlSUQocm9vdE5vZGVJRCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgTWFya3VwIHN0cmluZyB0byBwbGFjZSBpbnRvIHRoZSBET00gRWxlbWVudC5cbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIEVsZW1lbnQgdG8gaW5zZXJ0IG1hcmt1cCBpbnRvLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZFJldXNlTWFya3VwIFNob3VsZCByZXVzZSB0aGUgZXhpc3RpbmcgbWFya3VwIGluIHRoZVxuICAgKiBjb250YWluZXIgaWYgcG9zc2libGUuXG4gICAqL1xuICBtb3VudEltYWdlSW50b05vZGU6IFJlYWN0UGVyZi5tZWFzdXJlKFxuICAgICdSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudCcsXG4gICAgJ21vdW50SW1hZ2VJbnRvTm9kZScsXG4gICAgZnVuY3Rpb24obWFya3VwLCBjb250YWluZXIsIHNob3VsZFJldXNlTWFya3VwKSB7XG4gICAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgICBjb250YWluZXIgJiYgKFxuICAgICAgICAgIGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFX1RZUEUgfHxcbiAgICAgICAgICAgIGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRVxuICAgICAgICApLFxuICAgICAgICAnbW91bnRDb21wb25lbnRJbnRvTm9kZSguLi4pOiBUYXJnZXQgY29udGFpbmVyIGlzIG5vdCB2YWxpZC4nXG4gICAgICApIDogaW52YXJpYW50KGNvbnRhaW5lciAmJiAoXG4gICAgICAgIGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFX1RZUEUgfHxcbiAgICAgICAgICBjb250YWluZXIubm9kZVR5cGUgPT09IERPQ19OT0RFX1RZUEVcbiAgICAgICkpKTtcblxuICAgICAgaWYgKHNob3VsZFJldXNlTWFya3VwKSB7XG4gICAgICAgIGlmIChSZWFjdE1hcmt1cENoZWNrc3VtLmNhblJldXNlTWFya3VwKFxuICAgICAgICAgIG1hcmt1cCxcbiAgICAgICAgICBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICAgICAgIGNvbnRhaW5lci5ub2RlVHlwZSAhPT0gRE9DX05PREVfVFlQRSxcbiAgICAgICAgICAgICdZb3VcXCdyZSB0cnlpbmcgdG8gcmVuZGVyIGEgY29tcG9uZW50IHRvIHRoZSBkb2N1bWVudCB1c2luZyAnICtcbiAgICAgICAgICAgICdzZXJ2ZXIgcmVuZGVyaW5nIGJ1dCB0aGUgY2hlY2tzdW0gd2FzIGludmFsaWQuIFRoaXMgdXN1YWxseSAnICtcbiAgICAgICAgICAgICdtZWFucyB5b3UgcmVuZGVyZWQgYSBkaWZmZXJlbnQgY29tcG9uZW50IHR5cGUgb3IgcHJvcHMgb24gJyArXG4gICAgICAgICAgICAndGhlIGNsaWVudCBmcm9tIHRoZSBvbmUgb24gdGhlIHNlcnZlciwgb3IgeW91ciByZW5kZXIoKSAnICtcbiAgICAgICAgICAgICdtZXRob2RzIGFyZSBpbXB1cmUuIFJlYWN0IGNhbm5vdCBoYW5kbGUgdGhpcyBjYXNlIGR1ZSB0byAnICtcbiAgICAgICAgICAgICdjcm9zcy1icm93c2VyIHF1aXJrcyBieSByZW5kZXJpbmcgYXQgdGhlIGRvY3VtZW50IHJvb3QuIFlvdSAnICtcbiAgICAgICAgICAgICdzaG91bGQgbG9vayBmb3IgZW52aXJvbm1lbnQgZGVwZW5kZW50IGNvZGUgaW4geW91ciBjb21wb25lbnRzICcgK1xuICAgICAgICAgICAgJ2FuZCBlbnN1cmUgdGhlIHByb3BzIGFyZSB0aGUgc2FtZSBjbGllbnQgYW5kIHNlcnZlciBzaWRlLidcbiAgICAgICAgICApIDogaW52YXJpYW50KGNvbnRhaW5lci5ub2RlVHlwZSAhPT0gRE9DX05PREVfVFlQRSkpO1xuXG4gICAgICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAnUmVhY3QgYXR0ZW1wdGVkIHRvIHVzZSByZXVzZSBtYXJrdXAgaW4gYSBjb250YWluZXIgYnV0IHRoZSAnICtcbiAgICAgICAgICAgICAgJ2NoZWNrc3VtIHdhcyBpbnZhbGlkLiBUaGlzIGdlbmVyYWxseSBtZWFucyB0aGF0IHlvdSBhcmUgJyArXG4gICAgICAgICAgICAgICd1c2luZyBzZXJ2ZXIgcmVuZGVyaW5nIGFuZCB0aGUgbWFya3VwIGdlbmVyYXRlZCBvbiB0aGUgJyArXG4gICAgICAgICAgICAgICdzZXJ2ZXIgd2FzIG5vdCB3aGF0IHRoZSBjbGllbnQgd2FzIGV4cGVjdGluZy4gUmVhY3QgaW5qZWN0ZWQgJyArXG4gICAgICAgICAgICAgICduZXcgbWFya3VwIHRvIGNvbXBlbnNhdGUgd2hpY2ggd29ya3MgYnV0IHlvdSBoYXZlIGxvc3QgbWFueSAnICtcbiAgICAgICAgICAgICAgJ29mIHRoZSBiZW5lZml0cyBvZiBzZXJ2ZXIgcmVuZGVyaW5nLiBJbnN0ZWFkLCBmaWd1cmUgb3V0ICcgK1xuICAgICAgICAgICAgICAnd2h5IHRoZSBtYXJrdXAgYmVpbmcgZ2VuZXJhdGVkIGlzIGRpZmZlcmVudCBvbiB0aGUgY2xpZW50ICcgK1xuICAgICAgICAgICAgICAnb3Igc2VydmVyLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAgIGNvbnRhaW5lci5ub2RlVHlwZSAhPT0gRE9DX05PREVfVFlQRSxcbiAgICAgICAgJ1lvdVxcJ3JlIHRyeWluZyB0byByZW5kZXIgYSBjb21wb25lbnQgdG8gdGhlIGRvY3VtZW50IGJ1dCAnICtcbiAgICAgICAgICAneW91IGRpZG5cXCd0IHVzZSBzZXJ2ZXIgcmVuZGVyaW5nLiBXZSBjYW5cXCd0IGRvIHRoaXMgJyArXG4gICAgICAgICAgJ3dpdGhvdXQgdXNpbmcgc2VydmVyIHJlbmRlcmluZyBkdWUgdG8gY3Jvc3MtYnJvd3NlciBxdWlya3MuICcgK1xuICAgICAgICAgICdTZWUgcmVuZGVyQ29tcG9uZW50VG9TdHJpbmcoKSBmb3Igc2VydmVyIHJlbmRlcmluZy4nXG4gICAgICApIDogaW52YXJpYW50KGNvbnRhaW5lci5ub2RlVHlwZSAhPT0gRE9DX05PREVfVFlQRSkpO1xuXG4gICAgICBzZXRJbm5lckhUTUwoY29udGFpbmVyLCBtYXJrdXApO1xuICAgIH1cbiAgKVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudDtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDb21wb25lbnRXaXRoUHVyZVJlbmRlck1peGluXG4qL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIHNoYWxsb3dFcXVhbCA9IHJlcXVpcmUoXCIuL3NoYWxsb3dFcXVhbFwiKTtcblxuLyoqXG4gKiBJZiB5b3VyIFJlYWN0IGNvbXBvbmVudCdzIHJlbmRlciBmdW5jdGlvbiBpcyBcInB1cmVcIiwgZS5nLiBpdCB3aWxsIHJlbmRlciB0aGVcbiAqIHNhbWUgcmVzdWx0IGdpdmVuIHRoZSBzYW1lIHByb3BzIGFuZCBzdGF0ZSwgcHJvdmlkZSB0aGlzIE1peGluIGZvciBhXG4gKiBjb25zaWRlcmFibGUgcGVyZm9ybWFuY2UgYm9vc3QuXG4gKlxuICogTW9zdCBSZWFjdCBjb21wb25lbnRzIGhhdmUgcHVyZSByZW5kZXIgZnVuY3Rpb25zLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICB2YXIgUmVhY3RDb21wb25lbnRXaXRoUHVyZVJlbmRlck1peGluID1cbiAqICAgICByZXF1aXJlKCdSZWFjdENvbXBvbmVudFdpdGhQdXJlUmVuZGVyTWl4aW4nKTtcbiAqICAgUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICogICAgIG1peGluczogW1JlYWN0Q29tcG9uZW50V2l0aFB1cmVSZW5kZXJNaXhpbl0sXG4gKlxuICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gKiAgICAgICByZXR1cm4gPGRpdiBjbGFzc05hbWU9e3RoaXMucHJvcHMuY2xhc3NOYW1lfT5mb288L2Rpdj47XG4gKiAgICAgfVxuICogICB9KTtcbiAqXG4gKiBOb3RlOiBUaGlzIG9ubHkgY2hlY2tzIHNoYWxsb3cgZXF1YWxpdHkgZm9yIHByb3BzIGFuZCBzdGF0ZS4gSWYgdGhlc2UgY29udGFpblxuICogY29tcGxleCBkYXRhIHN0cnVjdHVyZXMgdGhpcyBtaXhpbiBtYXkgaGF2ZSBmYWxzZS1uZWdhdGl2ZXMgZm9yIGRlZXBlclxuICogZGlmZmVyZW5jZXMuIE9ubHkgbWl4aW4gdG8gY29tcG9uZW50cyB3aGljaCBoYXZlIHNpbXBsZSBwcm9wcyBhbmQgc3RhdGUsIG9yXG4gKiB1c2UgYGZvcmNlVXBkYXRlKClgIHdoZW4geW91IGtub3cgZGVlcCBkYXRhIHN0cnVjdHVyZXMgaGF2ZSBjaGFuZ2VkLlxuICovXG52YXIgUmVhY3RDb21wb25lbnRXaXRoUHVyZVJlbmRlck1peGluID0ge1xuICBzaG91bGRDb21wb25lbnRVcGRhdGU6IGZ1bmN0aW9uKG5leHRQcm9wcywgbmV4dFN0YXRlKSB7XG4gICAgcmV0dXJuICFzaGFsbG93RXF1YWwodGhpcy5wcm9wcywgbmV4dFByb3BzKSB8fFxuICAgICAgICAgICAhc2hhbGxvd0VxdWFsKHRoaXMuc3RhdGUsIG5leHRTdGF0ZSk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDb21wb25lbnRXaXRoUHVyZVJlbmRlck1peGluO1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudFxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKFwiLi9SZWFjdENvbXBvbmVudFwiKTtcbnZhciBSZWFjdENvbnRleHQgPSByZXF1aXJlKFwiLi9SZWFjdENvbnRleHRcIik7XG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKFwiLi9SZWFjdEN1cnJlbnRPd25lclwiKTtcbnZhciBSZWFjdERlc2NyaXB0b3IgPSByZXF1aXJlKFwiLi9SZWFjdERlc2NyaXB0b3JcIik7XG52YXIgUmVhY3REZXNjcmlwdG9yVmFsaWRhdG9yID0gcmVxdWlyZShcIi4vUmVhY3REZXNjcmlwdG9yVmFsaWRhdG9yXCIpO1xudmFyIFJlYWN0RW1wdHlDb21wb25lbnQgPSByZXF1aXJlKFwiLi9SZWFjdEVtcHR5Q29tcG9uZW50XCIpO1xudmFyIFJlYWN0RXJyb3JVdGlscyA9IHJlcXVpcmUoXCIuL1JlYWN0RXJyb3JVdGlsc1wiKTtcbnZhciBSZWFjdE93bmVyID0gcmVxdWlyZShcIi4vUmVhY3RPd25lclwiKTtcbnZhciBSZWFjdFBlcmYgPSByZXF1aXJlKFwiLi9SZWFjdFBlcmZcIik7XG52YXIgUmVhY3RQcm9wVHJhbnNmZXJlciA9IHJlcXVpcmUoXCIuL1JlYWN0UHJvcFRyYW5zZmVyZXJcIik7XG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucyA9IHJlcXVpcmUoXCIuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbnNcIik7XG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSByZXF1aXJlKFwiLi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1wiKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKFwiLi9SZWFjdFVwZGF0ZXNcIik7XG5cbnZhciBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZShcIi4vaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudFwiKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG52YXIga2V5TWlycm9yID0gcmVxdWlyZShcIi4va2V5TWlycm9yXCIpO1xudmFyIG1lcmdlID0gcmVxdWlyZShcIi4vbWVyZ2VcIik7XG52YXIgbWl4SW50byA9IHJlcXVpcmUoXCIuL21peEludG9cIik7XG52YXIgbW9uaXRvckNvZGVVc2UgPSByZXF1aXJlKFwiLi9tb25pdG9yQ29kZVVzZVwiKTtcbnZhciBtYXBPYmplY3QgPSByZXF1aXJlKFwiLi9tYXBPYmplY3RcIik7XG52YXIgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKFwiLi9zaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudFwiKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZShcIi4vd2FybmluZ1wiKTtcblxuLyoqXG4gKiBQb2xpY2llcyB0aGF0IGRlc2NyaWJlIG1ldGhvZHMgaW4gYFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50SW50ZXJmYWNlYC5cbiAqL1xudmFyIFNwZWNQb2xpY3kgPSBrZXlNaXJyb3Ioe1xuICAvKipcbiAgICogVGhlc2UgbWV0aG9kcyBtYXkgYmUgZGVmaW5lZCBvbmx5IG9uY2UgYnkgdGhlIGNsYXNzIHNwZWNpZmljYXRpb24gb3IgbWl4aW4uXG4gICAqL1xuICBERUZJTkVfT05DRTogbnVsbCxcbiAgLyoqXG4gICAqIFRoZXNlIG1ldGhvZHMgbWF5IGJlIGRlZmluZWQgYnkgYm90aCB0aGUgY2xhc3Mgc3BlY2lmaWNhdGlvbiBhbmQgbWl4aW5zLlxuICAgKiBTdWJzZXF1ZW50IGRlZmluaXRpb25zIHdpbGwgYmUgY2hhaW5lZC4gVGhlc2UgbWV0aG9kcyBtdXN0IHJldHVybiB2b2lkLlxuICAgKi9cbiAgREVGSU5FX01BTlk6IG51bGwsXG4gIC8qKlxuICAgKiBUaGVzZSBtZXRob2RzIGFyZSBvdmVycmlkaW5nIHRoZSBiYXNlIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50IGNsYXNzLlxuICAgKi9cbiAgT1ZFUlJJREVfQkFTRTogbnVsbCxcbiAgLyoqXG4gICAqIFRoZXNlIG1ldGhvZHMgYXJlIHNpbWlsYXIgdG8gREVGSU5FX01BTlksIGV4Y2VwdCB3ZSBhc3N1bWUgdGhleSByZXR1cm5cbiAgICogb2JqZWN0cy4gV2UgdHJ5IHRvIG1lcmdlIHRoZSBrZXlzIG9mIHRoZSByZXR1cm4gdmFsdWVzIG9mIGFsbCB0aGUgbWl4ZWQgaW5cbiAgICogZnVuY3Rpb25zLiBJZiB0aGVyZSBpcyBhIGtleSBjb25mbGljdCB3ZSB0aHJvdy5cbiAgICovXG4gIERFRklORV9NQU5ZX01FUkdFRDogbnVsbFxufSk7XG5cblxudmFyIGluamVjdGVkTWl4aW5zID0gW107XG5cbi8qKlxuICogQ29tcG9zaXRlIGNvbXBvbmVudHMgYXJlIGhpZ2hlci1sZXZlbCBjb21wb25lbnRzIHRoYXQgY29tcG9zZSBvdGhlciBjb21wb3NpdGVcbiAqIG9yIG5hdGl2ZSBjb21wb25lbnRzLlxuICpcbiAqIFRvIGNyZWF0ZSBhIG5ldyB0eXBlIG9mIGBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudGAsIHBhc3MgYSBzcGVjaWZpY2F0aW9uIG9mXG4gKiB5b3VyIG5ldyBjbGFzcyB0byBgUmVhY3QuY3JlYXRlQ2xhc3NgLiBUaGUgb25seSByZXF1aXJlbWVudCBvZiB5b3VyIGNsYXNzXG4gKiBzcGVjaWZpY2F0aW9uIGlzIHRoYXQgeW91IGltcGxlbWVudCBhIGByZW5kZXJgIG1ldGhvZC5cbiAqXG4gKiAgIHZhciBNeUNvbXBvbmVudCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICogICAgICAgcmV0dXJuIDxkaXY+SGVsbG8gV29ybGQ8L2Rpdj47XG4gKiAgICAgfVxuICogICB9KTtcbiAqXG4gKiBUaGUgY2xhc3Mgc3BlY2lmaWNhdGlvbiBzdXBwb3J0cyBhIHNwZWNpZmljIHByb3RvY29sIG9mIG1ldGhvZHMgdGhhdCBoYXZlXG4gKiBzcGVjaWFsIG1lYW5pbmcgKGUuZy4gYHJlbmRlcmApLiBTZWUgYFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50SW50ZXJmYWNlYCBmb3JcbiAqIG1vcmUgdGhlIGNvbXByZWhlbnNpdmUgcHJvdG9jb2wuIEFueSBvdGhlciBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGluIHRoZVxuICogY2xhc3Mgc3BlY2lmaWNhdGlvbiB3aWxsIGF2YWlsYWJsZSBvbiB0aGUgcHJvdG90eXBlLlxuICpcbiAqIEBpbnRlcmZhY2UgUmVhY3RDb21wb3NpdGVDb21wb25lbnRJbnRlcmZhY2VcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RDb21wb3NpdGVDb21wb25lbnRJbnRlcmZhY2UgPSB7XG5cbiAgLyoqXG4gICAqIEFuIGFycmF5IG9mIE1peGluIG9iamVjdHMgdG8gaW5jbHVkZSB3aGVuIGRlZmluaW5nIHlvdXIgY29tcG9uZW50LlxuICAgKlxuICAgKiBAdHlwZSB7YXJyYXl9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgbWl4aW5zOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBBbiBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIHRoYXQgc2hvdWxkIGJlIGRlZmluZWQgb25cbiAgICogdGhlIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yIGluc3RlYWQgb2YgaXRzIHByb3RvdHlwZSAoc3RhdGljIG1ldGhvZHMpLlxuICAgKlxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIHN0YXRpY3M6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIERlZmluaXRpb24gb2YgcHJvcCB0eXBlcyBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAqXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgcHJvcFR5cGVzOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBEZWZpbml0aW9uIG9mIGNvbnRleHQgdHlwZXMgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgKlxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbnRleHRUeXBlczogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogRGVmaW5pdGlvbiBvZiBjb250ZXh0IHR5cGVzIHRoaXMgY29tcG9uZW50IHNldHMgZm9yIGl0cyBjaGlsZHJlbi5cbiAgICpcbiAgICogQHR5cGUge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjaGlsZENvbnRleHRUeXBlczogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvLyA9PT09IERlZmluaXRpb24gbWV0aG9kcyA9PT09XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuIFZhbHVlcyBpbiB0aGUgbWFwcGluZyB3aWxsIGJlIHNldCBvblxuICAgKiBgdGhpcy5wcm9wc2AgaWYgdGhhdCBwcm9wIGlzIG5vdCBzcGVjaWZpZWQgKGkuZS4gdXNpbmcgYW4gYGluYCBjaGVjaykuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGludm9rZWQgYmVmb3JlIGBnZXRJbml0aWFsU3RhdGVgIGFuZCB0aGVyZWZvcmUgY2Fubm90IHJlbHlcbiAgICogb24gYHRoaXMuc3RhdGVgIG9yIHVzZSBgdGhpcy5zZXRTdGF0ZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBnZXREZWZhdWx0UHJvcHM6IFNwZWNQb2xpY3kuREVGSU5FX01BTllfTUVSR0VELFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIG9uY2UgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC4gVGhlIHJldHVybiB2YWx1ZSB3aWxsIGJlIHVzZWRcbiAgICogYXMgdGhlIGluaXRpYWwgdmFsdWUgb2YgYHRoaXMuc3RhdGVgLlxuICAgKlxuICAgKiAgIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAqICAgICByZXR1cm4ge1xuICAgKiAgICAgICBpc09uOiBmYWxzZSxcbiAgICogICAgICAgZm9vQmF6OiBuZXcgQmF6Rm9vKClcbiAgICogICAgIH1cbiAgICogICB9XG4gICAqXG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBnZXRJbml0aWFsU3RhdGU6IFNwZWNQb2xpY3kuREVGSU5FX01BTllfTUVSR0VELFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgZ2V0Q2hpbGRDb250ZXh0OiBTcGVjUG9saWN5LkRFRklORV9NQU5ZX01FUkdFRCxcblxuICAvKipcbiAgICogVXNlcyBwcm9wcyBmcm9tIGB0aGlzLnByb3BzYCBhbmQgc3RhdGUgZnJvbSBgdGhpcy5zdGF0ZWAgdG8gcmVuZGVyIHRoZVxuICAgKiBzdHJ1Y3R1cmUgb2YgdGhlIGNvbXBvbmVudC5cbiAgICpcbiAgICogTm8gZ3VhcmFudGVlcyBhcmUgbWFkZSBhYm91dCB3aGVuIG9yIGhvdyBvZnRlbiB0aGlzIG1ldGhvZCBpcyBpbnZva2VkLCBzb1xuICAgKiBpdCBtdXN0IG5vdCBoYXZlIHNpZGUgZWZmZWN0cy5cbiAgICpcbiAgICogICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgKiAgICAgdmFyIG5hbWUgPSB0aGlzLnByb3BzLm5hbWU7XG4gICAqICAgICByZXR1cm4gPGRpdj5IZWxsbywge25hbWV9ITwvZGl2PjtcbiAgICogICB9XG4gICAqXG4gICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fVxuICAgKiBAbm9zaWRlZWZmZWN0c1xuICAgKiBAcmVxdWlyZWRcbiAgICovXG4gIHJlbmRlcjogU3BlY1BvbGljeS5ERUZJTkVfT05DRSxcblxuXG5cbiAgLy8gPT09PSBEZWxlZ2F0ZSBtZXRob2RzID09PT1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgaW5pdGlhbGx5IGNyZWF0ZWQgYW5kIGFib3V0IHRvIGJlIG1vdW50ZWQuXG4gICAqIFRoaXMgbWF5IGhhdmUgc2lkZSBlZmZlY3RzLCBidXQgYW55IGV4dGVybmFsIHN1YnNjcmlwdGlvbnMgb3IgZGF0YSBjcmVhdGVkXG4gICAqIGJ5IHRoaXMgbWV0aG9kIG11c3QgYmUgY2xlYW5lZCB1cCBpbiBgY29tcG9uZW50V2lsbFVubW91bnRgLlxuICAgKlxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudFdpbGxNb3VudDogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZCBhbmQgaGFzIGEgRE9NIHJlcHJlc2VudGF0aW9uLlxuICAgKiBIb3dldmVyLCB0aGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCB0aGUgRE9NIG5vZGUgaXMgaW4gdGhlIGRvY3VtZW50LlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBvcGVyYXRlIG9uIHRoZSBET00gd2hlbiB0aGUgY29tcG9uZW50IGhhc1xuICAgKiBiZWVuIG1vdW50ZWQgKGluaXRpYWxpemVkIGFuZCByZW5kZXJlZCkgZm9yIHRoZSBmaXJzdCB0aW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IHJvb3ROb2RlIERPTSBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgY29tcG9uZW50LlxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudERpZE1vdW50OiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIGJlZm9yZSB0aGUgY29tcG9uZW50IHJlY2VpdmVzIG5ldyBwcm9wcy5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gcmVhY3QgdG8gYSBwcm9wIHRyYW5zaXRpb24gYnkgdXBkYXRpbmcgdGhlXG4gICAqIHN0YXRlIHVzaW5nIGB0aGlzLnNldFN0YXRlYC4gQ3VycmVudCBwcm9wcyBhcmUgYWNjZXNzZWQgdmlhIGB0aGlzLnByb3BzYC5cbiAgICpcbiAgICogICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbihuZXh0UHJvcHMsIG5leHRDb250ZXh0KSB7XG4gICAqICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICogICAgICAgbGlrZXNJbmNyZWFzaW5nOiBuZXh0UHJvcHMubGlrZUNvdW50ID4gdGhpcy5wcm9wcy5saWtlQ291bnRcbiAgICogICAgIH0pO1xuICAgKiAgIH1cbiAgICpcbiAgICogTk9URTogVGhlcmUgaXMgbm8gZXF1aXZhbGVudCBgY29tcG9uZW50V2lsbFJlY2VpdmVTdGF0ZWAuIEFuIGluY29taW5nIHByb3BcbiAgICogdHJhbnNpdGlvbiBtYXkgY2F1c2UgYSBzdGF0ZSBjaGFuZ2UsIGJ1dCB0aGUgb3Bwb3NpdGUgaXMgbm90IHRydWUuIElmIHlvdVxuICAgKiBuZWVkIGl0LCB5b3UgYXJlIHByb2JhYmx5IGxvb2tpbmcgZm9yIGBjb21wb25lbnRXaWxsVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hpbGUgZGVjaWRpbmcgaWYgdGhlIGNvbXBvbmVudCBzaG91bGQgYmUgdXBkYXRlZCBhcyBhIHJlc3VsdCBvZlxuICAgKiByZWNlaXZpbmcgbmV3IHByb3BzLCBzdGF0ZSBhbmQvb3IgY29udGV4dC5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gYHJldHVybiBmYWxzZWAgd2hlbiB5b3UncmUgY2VydGFpbiB0aGF0IHRoZVxuICAgKiB0cmFuc2l0aW9uIHRvIHRoZSBuZXcgcHJvcHMvc3RhdGUvY29udGV4dCB3aWxsIG5vdCByZXF1aXJlIGEgY29tcG9uZW50XG4gICAqIHVwZGF0ZS5cbiAgICpcbiAgICogICBzaG91bGRDb21wb25lbnRVcGRhdGU6IGZ1bmN0aW9uKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCkge1xuICAgKiAgICAgcmV0dXJuICFlcXVhbChuZXh0UHJvcHMsIHRoaXMucHJvcHMpIHx8XG4gICAqICAgICAgICFlcXVhbChuZXh0U3RhdGUsIHRoaXMuc3RhdGUpIHx8XG4gICAqICAgICAgICFlcXVhbChuZXh0Q29udGV4dCwgdGhpcy5jb250ZXh0KTtcbiAgICogICB9XG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0U3RhdGVcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0Q29udGV4dFxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBjb21wb25lbnQgc2hvdWxkIHVwZGF0ZS5cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBzaG91bGRDb21wb25lbnRVcGRhdGU6IFNwZWNQb2xpY3kuREVGSU5FX09OQ0UsXG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGFib3V0IHRvIHVwZGF0ZSBkdWUgdG8gYSB0cmFuc2l0aW9uIGZyb21cbiAgICogYHRoaXMucHJvcHNgLCBgdGhpcy5zdGF0ZWAgYW5kIGB0aGlzLmNvbnRleHRgIHRvIGBuZXh0UHJvcHNgLCBgbmV4dFN0YXRlYFxuICAgKiBhbmQgYG5leHRDb250ZXh0YC5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gcGVyZm9ybSBwcmVwYXJhdGlvbiBiZWZvcmUgYW4gdXBkYXRlIG9jY3Vycy5cbiAgICpcbiAgICogTk9URTogWW91ICoqY2Fubm90KiogdXNlIGB0aGlzLnNldFN0YXRlKClgIGluIHRoaXMgbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dFN0YXRlXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dENvbnRleHRcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudFdpbGxVcGRhdGU6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50J3MgRE9NIHJlcHJlc2VudGF0aW9uIGhhcyBiZWVuIHVwZGF0ZWQuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIG9wZXJhdGUgb24gdGhlIERPTSB3aGVuIHRoZSBjb21wb25lbnQgaGFzXG4gICAqIGJlZW4gdXBkYXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHByZXZQcm9wc1xuICAgKiBAcGFyYW0gez9vYmplY3R9IHByZXZTdGF0ZVxuICAgKiBAcGFyYW0gez9vYmplY3R9IHByZXZDb250ZXh0XG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gcm9vdE5vZGUgRE9NIGVsZW1lbnQgcmVwcmVzZW50aW5nIHRoZSBjb21wb25lbnQuXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50RGlkVXBkYXRlOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBhYm91dCB0byBiZSByZW1vdmVkIGZyb20gaXRzIHBhcmVudCBhbmQgaGF2ZVxuICAgKiBpdHMgRE9NIHJlcHJlc2VudGF0aW9uIGRlc3Ryb3llZC5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gZGVhbGxvY2F0ZSBhbnkgZXh0ZXJuYWwgcmVzb3VyY2VzLlxuICAgKlxuICAgKiBOT1RFOiBUaGVyZSBpcyBubyBgY29tcG9uZW50RGlkVW5tb3VudGAgc2luY2UgeW91ciBjb21wb25lbnQgd2lsbCBoYXZlIGJlZW5cbiAgICogZGVzdHJveWVkIGJ5IHRoYXQgcG9pbnQuXG4gICAqXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50V2lsbFVubW91bnQ6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cblxuXG4gIC8vID09PT0gQWR2YW5jZWQgbWV0aG9kcyA9PT09XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGNvbXBvbmVudCdzIGN1cnJlbnRseSBtb3VudGVkIERPTSByZXByZXNlbnRhdGlvbi5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgdGhpcyBpbXBsZW1lbnRzIFJlYWN0J3MgcmVuZGVyaW5nIGFuZCByZWNvbmNpbGlhdGlvbiBhbGdvcml0aG0uXG4gICAqIFNvcGhpc3RpY2F0ZWQgY2xpZW50cyBtYXkgd2lzaCB0byBvdmVycmlkZSB0aGlzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAb3ZlcnJpZGFibGVcbiAgICovXG4gIHVwZGF0ZUNvbXBvbmVudDogU3BlY1BvbGljeS5PVkVSUklERV9CQVNFXG5cbn07XG5cbi8qKlxuICogTWFwcGluZyBmcm9tIGNsYXNzIHNwZWNpZmljYXRpb24ga2V5cyB0byBzcGVjaWFsIHByb2Nlc3NpbmcgZnVuY3Rpb25zLlxuICpcbiAqIEFsdGhvdWdoIHRoZXNlIGFyZSBkZWNsYXJlZCBsaWtlIGluc3RhbmNlIHByb3BlcnRpZXMgaW4gdGhlIHNwZWNpZmljYXRpb25cbiAqIHdoZW4gZGVmaW5pbmcgY2xhc3NlcyB1c2luZyBgUmVhY3QuY3JlYXRlQ2xhc3NgLCB0aGV5IGFyZSBhY3R1YWxseSBzdGF0aWNcbiAqIGFuZCBhcmUgYWNjZXNzaWJsZSBvbiB0aGUgY29uc3RydWN0b3IgaW5zdGVhZCBvZiB0aGUgcHJvdG90eXBlLiBEZXNwaXRlXG4gKiBiZWluZyBzdGF0aWMsIHRoZXkgbXVzdCBiZSBkZWZpbmVkIG91dHNpZGUgb2YgdGhlIFwic3RhdGljc1wiIGtleSB1bmRlclxuICogd2hpY2ggYWxsIG90aGVyIHN0YXRpYyBtZXRob2RzIGFyZSBkZWZpbmVkLlxuICovXG52YXIgUkVTRVJWRURfU1BFQ19LRVlTID0ge1xuICBkaXNwbGF5TmFtZTogZnVuY3Rpb24oQ29uc3RydWN0b3IsIGRpc3BsYXlOYW1lKSB7XG4gICAgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgfSxcbiAgbWl4aW5zOiBmdW5jdGlvbihDb25zdHJ1Y3RvciwgbWl4aW5zKSB7XG4gICAgaWYgKG1peGlucykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaXhpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbWl4U3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIG1peGluc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBjaGlsZENvbnRleHRUeXBlczogZnVuY3Rpb24oQ29uc3RydWN0b3IsIGNoaWxkQ29udGV4dFR5cGVzKSB7XG4gICAgdmFsaWRhdGVUeXBlRGVmKFxuICAgICAgQ29uc3RydWN0b3IsXG4gICAgICBjaGlsZENvbnRleHRUeXBlcyxcbiAgICAgIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMuY2hpbGRDb250ZXh0XG4gICAgKTtcbiAgICBDb25zdHJ1Y3Rvci5jaGlsZENvbnRleHRUeXBlcyA9IG1lcmdlKFxuICAgICAgQ29uc3RydWN0b3IuY2hpbGRDb250ZXh0VHlwZXMsXG4gICAgICBjaGlsZENvbnRleHRUeXBlc1xuICAgICk7XG4gIH0sXG4gIGNvbnRleHRUeXBlczogZnVuY3Rpb24oQ29uc3RydWN0b3IsIGNvbnRleHRUeXBlcykge1xuICAgIHZhbGlkYXRlVHlwZURlZihcbiAgICAgIENvbnN0cnVjdG9yLFxuICAgICAgY29udGV4dFR5cGVzLFxuICAgICAgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5jb250ZXh0XG4gICAgKTtcbiAgICBDb25zdHJ1Y3Rvci5jb250ZXh0VHlwZXMgPSBtZXJnZShDb25zdHJ1Y3Rvci5jb250ZXh0VHlwZXMsIGNvbnRleHRUeXBlcyk7XG4gIH0sXG4gIC8qKlxuICAgKiBTcGVjaWFsIGNhc2UgZ2V0RGVmYXVsdFByb3BzIHdoaWNoIHNob3VsZCBtb3ZlIGludG8gc3RhdGljcyBidXQgcmVxdWlyZXNcbiAgICogYXV0b21hdGljIG1lcmdpbmcuXG4gICAqL1xuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBnZXREZWZhdWx0UHJvcHMpIHtcbiAgICBpZiAoQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKSB7XG4gICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMgPSBjcmVhdGVNZXJnZWRSZXN1bHRGdW5jdGlvbihcbiAgICAgICAgQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzLFxuICAgICAgICBnZXREZWZhdWx0UHJvcHNcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcyA9IGdldERlZmF1bHRQcm9wcztcbiAgICB9XG4gIH0sXG4gIHByb3BUeXBlczogZnVuY3Rpb24oQ29uc3RydWN0b3IsIHByb3BUeXBlcykge1xuICAgIHZhbGlkYXRlVHlwZURlZihcbiAgICAgIENvbnN0cnVjdG9yLFxuICAgICAgcHJvcFR5cGVzLFxuICAgICAgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5wcm9wXG4gICAgKTtcbiAgICBDb25zdHJ1Y3Rvci5wcm9wVHlwZXMgPSBtZXJnZShDb25zdHJ1Y3Rvci5wcm9wVHlwZXMsIHByb3BUeXBlcyk7XG4gIH0sXG4gIHN0YXRpY3M6IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBzdGF0aWNzKSB7XG4gICAgbWl4U3RhdGljU3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHN0YXRpY3MpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oY29tcG9uZW50KSB7XG4gIHZhciBvd25lciA9IGNvbXBvbmVudC5fb3duZXIgfHwgbnVsbDtcbiAgaWYgKG93bmVyICYmIG93bmVyLmNvbnN0cnVjdG9yICYmIG93bmVyLmNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBvd25lci5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSArXG4gICAgICAnYC4nO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCB0eXBlRGVmLCBsb2NhdGlvbikge1xuICBmb3IgKHZhciBwcm9wTmFtZSBpbiB0eXBlRGVmKSB7XG4gICAgaWYgKHR5cGVEZWYuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgICB0eXBlb2YgdHlwZURlZltwcm9wTmFtZV0gPT0gJ2Z1bmN0aW9uJyxcbiAgICAgICAgJyVzOiAlcyB0eXBlIGAlc2AgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gJyArXG4gICAgICAgICdSZWFjdC5Qcm9wVHlwZXMuJyxcbiAgICAgICAgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JyxcbiAgICAgICAgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLFxuICAgICAgICBwcm9wTmFtZVxuICAgICAgKSA6IGludmFyaWFudCh0eXBlb2YgdHlwZURlZltwcm9wTmFtZV0gPT0gJ2Z1bmN0aW9uJykpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU1ldGhvZE92ZXJyaWRlKHByb3RvLCBuYW1lKSB7XG4gIHZhciBzcGVjUG9saWN5ID0gUmVhY3RDb21wb3NpdGVDb21wb25lbnRJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkobmFtZSkgP1xuICAgIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50SW50ZXJmYWNlW25hbWVdIDpcbiAgICBudWxsO1xuXG4gIC8vIERpc2FsbG93IG92ZXJyaWRpbmcgb2YgYmFzZSBjbGFzcyBtZXRob2RzIHVubGVzcyBleHBsaWNpdGx5IGFsbG93ZWQuXG4gIGlmIChSZWFjdENvbXBvc2l0ZUNvbXBvbmVudE1peGluLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgIHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuT1ZFUlJJREVfQkFTRSxcbiAgICAgICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudEludGVyZmFjZTogWW91IGFyZSBhdHRlbXB0aW5nIHRvIG92ZXJyaWRlICcgK1xuICAgICAgJ2Alc2AgZnJvbSB5b3VyIGNsYXNzIHNwZWNpZmljYXRpb24uIEVuc3VyZSB0aGF0IHlvdXIgbWV0aG9kIG5hbWVzICcgK1xuICAgICAgJ2RvIG5vdCBvdmVybGFwIHdpdGggUmVhY3QgbWV0aG9kcy4nLFxuICAgICAgbmFtZVxuICAgICkgOiBpbnZhcmlhbnQoc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5PVkVSUklERV9CQVNFKSk7XG4gIH1cblxuICAvLyBEaXNhbGxvdyBkZWZpbmluZyBtZXRob2RzIG1vcmUgdGhhbiBvbmNlIHVubGVzcyBleHBsaWNpdGx5IGFsbG93ZWQuXG4gIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICBzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5LkRFRklORV9NQU5ZIHx8XG4gICAgICBzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5LkRFRklORV9NQU5ZX01FUkdFRCxcbiAgICAgICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudEludGVyZmFjZTogWW91IGFyZSBhdHRlbXB0aW5nIHRvIGRlZmluZSAnICtcbiAgICAgICdgJXNgIG9uIHlvdXIgY29tcG9uZW50IG1vcmUgdGhhbiBvbmNlLiBUaGlzIGNvbmZsaWN0IG1heSBiZSBkdWUgJyArXG4gICAgICAndG8gYSBtaXhpbi4nLFxuICAgICAgbmFtZVxuICAgICkgOiBpbnZhcmlhbnQoc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5ERUZJTkVfTUFOWSB8fFxuICAgIHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuREVGSU5FX01BTllfTUVSR0VEKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVMaWZlQ3ljbGVPblJlcGxhY2VTdGF0ZShpbnN0YW5jZSkge1xuICB2YXIgY29tcG9zaXRlTGlmZUN5Y2xlU3RhdGUgPSBpbnN0YW5jZS5fY29tcG9zaXRlTGlmZUN5Y2xlU3RhdGU7XG4gIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgaW5zdGFuY2UuaXNNb3VudGVkKCkgfHxcbiAgICAgIGNvbXBvc2l0ZUxpZmVDeWNsZVN0YXRlID09PSBDb21wb3NpdGVMaWZlQ3ljbGUuTU9VTlRJTkcsXG4gICAgJ3JlcGxhY2VTdGF0ZSguLi4pOiBDYW4gb25seSB1cGRhdGUgYSBtb3VudGVkIG9yIG1vdW50aW5nIGNvbXBvbmVudC4nXG4gICkgOiBpbnZhcmlhbnQoaW5zdGFuY2UuaXNNb3VudGVkKCkgfHxcbiAgICBjb21wb3NpdGVMaWZlQ3ljbGVTdGF0ZSA9PT0gQ29tcG9zaXRlTGlmZUN5Y2xlLk1PVU5USU5HKSk7XG4gIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoY29tcG9zaXRlTGlmZUN5Y2xlU3RhdGUgIT09IENvbXBvc2l0ZUxpZmVDeWNsZS5SRUNFSVZJTkdfU1RBVEUsXG4gICAgJ3JlcGxhY2VTdGF0ZSguLi4pOiBDYW5ub3QgdXBkYXRlIGR1cmluZyBhbiBleGlzdGluZyBzdGF0ZSB0cmFuc2l0aW9uICcgK1xuICAgICcoc3VjaCBhcyB3aXRoaW4gYHJlbmRlcmApLiBUaGlzIGNvdWxkIHBvdGVudGlhbGx5IGNhdXNlIGFuIGluZmluaXRlICcgK1xuICAgICdsb29wIHNvIGl0IGlzIGZvcmJpZGRlbi4nXG4gICkgOiBpbnZhcmlhbnQoY29tcG9zaXRlTGlmZUN5Y2xlU3RhdGUgIT09IENvbXBvc2l0ZUxpZmVDeWNsZS5SRUNFSVZJTkdfU1RBVEUpKTtcbiAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChjb21wb3NpdGVMaWZlQ3ljbGVTdGF0ZSAhPT0gQ29tcG9zaXRlTGlmZUN5Y2xlLlVOTU9VTlRJTkcsXG4gICAgJ3JlcGxhY2VTdGF0ZSguLi4pOiBDYW5ub3QgdXBkYXRlIHdoaWxlIHVubW91bnRpbmcgY29tcG9uZW50LiBUaGlzICcgK1xuICAgICd1c3VhbGx5IG1lYW5zIHlvdSBjYWxsZWQgc2V0U3RhdGUoKSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LidcbiAgKSA6IGludmFyaWFudChjb21wb3NpdGVMaWZlQ3ljbGVTdGF0ZSAhPT0gQ29tcG9zaXRlTGlmZUN5Y2xlLlVOTU9VTlRJTkcpKTtcbn1cblxuLyoqXG4gKiBDdXN0b20gdmVyc2lvbiBvZiBgbWl4SW50b2Agd2hpY2ggaGFuZGxlcyBwb2xpY3kgdmFsaWRhdGlvbiBhbmQgcmVzZXJ2ZWRcbiAqIHNwZWNpZmljYXRpb24ga2V5cyB3aGVuIGJ1aWxkaW5nIGBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudGAgY2xhc3NzZXMuXG4gKi9cbmZ1bmN0aW9uIG1peFNwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzcGVjKSB7XG4gIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgIVJlYWN0RGVzY3JpcHRvci5pc1ZhbGlkRmFjdG9yeShzcGVjKSxcbiAgICAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQ6IFlvdVxcJ3JlIGF0dGVtcHRpbmcgdG8gJyArXG4gICAgJ3VzZSBhIGNvbXBvbmVudCBjbGFzcyBhcyBhIG1peGluLiBJbnN0ZWFkLCBqdXN0IHVzZSBhIHJlZ3VsYXIgb2JqZWN0LidcbiAgKSA6IGludmFyaWFudCghUmVhY3REZXNjcmlwdG9yLmlzVmFsaWRGYWN0b3J5KHNwZWMpKSk7XG4gIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgIVJlYWN0RGVzY3JpcHRvci5pc1ZhbGlkRGVzY3JpcHRvcihzcGVjKSxcbiAgICAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQ6IFlvdVxcJ3JlIGF0dGVtcHRpbmcgdG8gJyArXG4gICAgJ3VzZSBhIGNvbXBvbmVudCBhcyBhIG1peGluLiBJbnN0ZWFkLCBqdXN0IHVzZSBhIHJlZ3VsYXIgb2JqZWN0LidcbiAgKSA6IGludmFyaWFudCghUmVhY3REZXNjcmlwdG9yLmlzVmFsaWREZXNjcmlwdG9yKHNwZWMpKSk7XG5cbiAgdmFyIHByb3RvID0gQ29uc3RydWN0b3IucHJvdG90eXBlO1xuICBmb3IgKHZhciBuYW1lIGluIHNwZWMpIHtcbiAgICB2YXIgcHJvcGVydHkgPSBzcGVjW25hbWVdO1xuICAgIGlmICghc3BlYy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFsaWRhdGVNZXRob2RPdmVycmlkZShwcm90bywgbmFtZSk7XG5cbiAgICBpZiAoUkVTRVJWRURfU1BFQ19LRVlTLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBSRVNFUlZFRF9TUEVDX0tFWVNbbmFtZV0oQ29uc3RydWN0b3IsIHByb3BlcnR5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2V0dXAgbWV0aG9kcyBvbiBwcm90b3R5cGU6XG4gICAgICAvLyBUaGUgZm9sbG93aW5nIG1lbWJlciBtZXRob2RzIHNob3VsZCBub3QgYmUgYXV0b21hdGljYWxseSBib3VuZDpcbiAgICAgIC8vIDEuIEV4cGVjdGVkIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50IG1ldGhvZHMgKGluIHRoZSBcImludGVyZmFjZVwiKS5cbiAgICAgIC8vIDIuIE92ZXJyaWRkZW4gbWV0aG9kcyAodGhhdCB3ZXJlIG1peGVkIGluKS5cbiAgICAgIHZhciBpc0NvbXBvc2l0ZUNvbXBvbmVudE1ldGhvZCA9XG4gICAgICAgIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50SW50ZXJmYWNlLmhhc093blByb3BlcnR5KG5hbWUpO1xuICAgICAgdmFyIGlzQWxyZWFkeURlZmluZWQgPSBwcm90by5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbiAgICAgIHZhciBtYXJrZWREb250QmluZCA9IHByb3BlcnR5ICYmIHByb3BlcnR5Ll9fcmVhY3REb250QmluZDtcbiAgICAgIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIHByb3BlcnR5ID09PSAnZnVuY3Rpb24nO1xuICAgICAgdmFyIHNob3VsZEF1dG9CaW5kID1cbiAgICAgICAgaXNGdW5jdGlvbiAmJlxuICAgICAgICAhaXNDb21wb3NpdGVDb21wb25lbnRNZXRob2QgJiZcbiAgICAgICAgIWlzQWxyZWFkeURlZmluZWQgJiZcbiAgICAgICAgIW1hcmtlZERvbnRCaW5kO1xuXG4gICAgICBpZiAoc2hvdWxkQXV0b0JpbmQpIHtcbiAgICAgICAgaWYgKCFwcm90by5fX3JlYWN0QXV0b0JpbmRNYXApIHtcbiAgICAgICAgICBwcm90by5fX3JlYWN0QXV0b0JpbmRNYXAgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBwcm90by5fX3JlYWN0QXV0b0JpbmRNYXBbbmFtZV0gPSBwcm9wZXJ0eTtcbiAgICAgICAgcHJvdG9bbmFtZV0gPSBwcm9wZXJ0eTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc0FscmVhZHlEZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIHNwZWNQb2xpY3kgPSBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudEludGVyZmFjZVtuYW1lXTtcblxuICAgICAgICAgIC8vIFRoZXNlIGNhc2VzIHNob3VsZCBhbHJlYWR5IGJlIGNhdWdodCBieSB2YWxpZGF0ZU1ldGhvZE92ZXJyaWRlXG4gICAgICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICAgICAgIGlzQ29tcG9zaXRlQ29tcG9uZW50TWV0aG9kICYmIChcbiAgICAgICAgICAgICAgc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5ERUZJTkVfTUFOWV9NRVJHRUQgfHxcbiAgICAgICAgICAgICAgc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5ERUZJTkVfTUFOWVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudDogVW5leHBlY3RlZCBzcGVjIHBvbGljeSAlcyBmb3Iga2V5ICVzICcgK1xuICAgICAgICAgICAgJ3doZW4gbWl4aW5nIGluIGNvbXBvbmVudCBzcGVjcy4nLFxuICAgICAgICAgICAgc3BlY1BvbGljeSxcbiAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICApIDogaW52YXJpYW50KGlzQ29tcG9zaXRlQ29tcG9uZW50TWV0aG9kICYmIChcbiAgICAgICAgICAgIHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuREVGSU5FX01BTllfTUVSR0VEIHx8XG4gICAgICAgICAgICBzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5LkRFRklORV9NQU5ZXG4gICAgICAgICAgKSkpO1xuXG4gICAgICAgICAgLy8gRm9yIG1ldGhvZHMgd2hpY2ggYXJlIGRlZmluZWQgbW9yZSB0aGFuIG9uY2UsIGNhbGwgdGhlIGV4aXN0aW5nXG4gICAgICAgICAgLy8gbWV0aG9kcyBiZWZvcmUgY2FsbGluZyB0aGUgbmV3IHByb3BlcnR5LCBtZXJnaW5nIGlmIGFwcHJvcHJpYXRlLlxuICAgICAgICAgIGlmIChzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5LkRFRklORV9NQU5ZX01FUkdFRCkge1xuICAgICAgICAgICAgcHJvdG9bbmFtZV0gPSBjcmVhdGVNZXJnZWRSZXN1bHRGdW5jdGlvbihwcm90b1tuYW1lXSwgcHJvcGVydHkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5ERUZJTkVfTUFOWSkge1xuICAgICAgICAgICAgcHJvdG9bbmFtZV0gPSBjcmVhdGVDaGFpbmVkRnVuY3Rpb24ocHJvdG9bbmFtZV0sIHByb3BlcnR5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvdG9bbmFtZV0gPSBwcm9wZXJ0eTtcbiAgICAgICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAgICAgICAvLyBBZGQgdmVyYm9zZSBkaXNwbGF5TmFtZSB0byB0aGUgZnVuY3Rpb24sIHdoaWNoIGhlbHBzIHdoZW4gbG9va2luZ1xuICAgICAgICAgICAgLy8gYXQgcHJvZmlsaW5nIHRvb2xzLlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJyAmJiBzcGVjLmRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgICAgIHByb3RvW25hbWVdLmRpc3BsYXlOYW1lID0gc3BlYy5kaXNwbGF5TmFtZSArICdfJyArIG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1peFN0YXRpY1NwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzdGF0aWNzKSB7XG4gIGlmICghc3RhdGljcykge1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKHZhciBuYW1lIGluIHN0YXRpY3MpIHtcbiAgICB2YXIgcHJvcGVydHkgPSBzdGF0aWNzW25hbWVdO1xuICAgIGlmICghc3RhdGljcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGlzSW5oZXJpdGVkID0gbmFtZSBpbiBDb25zdHJ1Y3RvcjtcbiAgICB2YXIgcmVzdWx0ID0gcHJvcGVydHk7XG4gICAgaWYgKGlzSW5oZXJpdGVkKSB7XG4gICAgICB2YXIgZXhpc3RpbmdQcm9wZXJ0eSA9IENvbnN0cnVjdG9yW25hbWVdO1xuICAgICAgdmFyIGV4aXN0aW5nVHlwZSA9IHR5cGVvZiBleGlzdGluZ1Byb3BlcnR5O1xuICAgICAgdmFyIHByb3BlcnR5VHlwZSA9IHR5cGVvZiBwcm9wZXJ0eTtcbiAgICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAgIGV4aXN0aW5nVHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wZXJ0eVR5cGUgPT09ICdmdW5jdGlvbicsXG4gICAgICAgICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudDogWW91IGFyZSBhdHRlbXB0aW5nIHRvIGRlZmluZSAnICtcbiAgICAgICAgJ2Alc2Agb24geW91ciBjb21wb25lbnQgbW9yZSB0aGFuIG9uY2UsIGJ1dCB0aGF0IGlzIG9ubHkgc3VwcG9ydGVkICcgK1xuICAgICAgICAnZm9yIGZ1bmN0aW9ucywgd2hpY2ggYXJlIGNoYWluZWQgdG9nZXRoZXIuIFRoaXMgY29uZmxpY3QgbWF5IGJlICcgK1xuICAgICAgICAnZHVlIHRvIGEgbWl4aW4uJyxcbiAgICAgICAgbmFtZVxuICAgICAgKSA6IGludmFyaWFudChleGlzdGluZ1R5cGUgPT09ICdmdW5jdGlvbicgJiYgcHJvcGVydHlUeXBlID09PSAnZnVuY3Rpb24nKSk7XG4gICAgICByZXN1bHQgPSBjcmVhdGVDaGFpbmVkRnVuY3Rpb24oZXhpc3RpbmdQcm9wZXJ0eSwgcHJvcGVydHkpO1xuICAgIH1cbiAgICBDb25zdHJ1Y3RvcltuYW1lXSA9IHJlc3VsdDtcbiAgfVxufVxuXG4vKipcbiAqIE1lcmdlIHR3byBvYmplY3RzLCBidXQgdGhyb3cgaWYgYm90aCBjb250YWluIHRoZSBzYW1lIGtleS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb25lIFRoZSBmaXJzdCBvYmplY3QsIHdoaWNoIGlzIG11dGF0ZWQuXG4gKiBAcGFyYW0ge29iamVjdH0gdHdvIFRoZSBzZWNvbmQgb2JqZWN0XG4gKiBAcmV0dXJuIHtvYmplY3R9IG9uZSBhZnRlciBpdCBoYXMgYmVlbiBtdXRhdGVkIHRvIGNvbnRhaW4gZXZlcnl0aGluZyBpbiB0d28uXG4gKi9cbmZ1bmN0aW9uIG1lcmdlT2JqZWN0c1dpdGhOb0R1cGxpY2F0ZUtleXMob25lLCB0d28pIHtcbiAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICBvbmUgJiYgdHdvICYmIHR5cGVvZiBvbmUgPT09ICdvYmplY3QnICYmIHR5cGVvZiB0d28gPT09ICdvYmplY3QnLFxuICAgICdtZXJnZU9iamVjdHNXaXRoTm9EdXBsaWNhdGVLZXlzKCk6IENhbm5vdCBtZXJnZSBub24tb2JqZWN0cydcbiAgKSA6IGludmFyaWFudChvbmUgJiYgdHdvICYmIHR5cGVvZiBvbmUgPT09ICdvYmplY3QnICYmIHR5cGVvZiB0d28gPT09ICdvYmplY3QnKSk7XG5cbiAgbWFwT2JqZWN0KHR3bywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICBvbmVba2V5XSA9PT0gdW5kZWZpbmVkLFxuICAgICAgJ21lcmdlT2JqZWN0c1dpdGhOb0R1cGxpY2F0ZUtleXMoKTogJyArXG4gICAgICAnVHJpZWQgdG8gbWVyZ2UgdHdvIG9iamVjdHMgd2l0aCB0aGUgc2FtZSBrZXk6ICVzJyxcbiAgICAgIGtleVxuICAgICkgOiBpbnZhcmlhbnQob25lW2tleV0gPT09IHVuZGVmaW5lZCkpO1xuICAgIG9uZVtrZXldID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gb25lO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdHdvIGZ1bmN0aW9ucyBhbmQgbWVyZ2VzIHRoZWlyIHJldHVybiB2YWx1ZXMuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gb25lIEZ1bmN0aW9uIHRvIGludm9rZSBmaXJzdC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHR3byBGdW5jdGlvbiB0byBpbnZva2Ugc2Vjb25kLlxuICogQHJldHVybiB7ZnVuY3Rpb259IEZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgdHdvIGFyZ3VtZW50IGZ1bmN0aW9ucy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1lcmdlZFJlc3VsdEZ1bmN0aW9uKG9uZSwgdHdvKSB7XG4gIHJldHVybiBmdW5jdGlvbiBtZXJnZWRSZXN1bHQoKSB7XG4gICAgdmFyIGEgPSBvbmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB2YXIgYiA9IHR3by5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChhID09IG51bGwpIHtcbiAgICAgIHJldHVybiBiO1xuICAgIH0gZWxzZSBpZiAoYiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gYTtcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlT2JqZWN0c1dpdGhOb0R1cGxpY2F0ZUtleXMoYSwgYik7XG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0d28gZnVuY3Rpb25zIGFuZCBpZ25vcmVzIHRoZWlyIHJldHVybiB2YWxlcy5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbmUgRnVuY3Rpb24gdG8gaW52b2tlIGZpcnN0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gdHdvIEZ1bmN0aW9uIHRvIGludm9rZSBzZWNvbmQuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gRnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSB0d28gYXJndW1lbnQgZnVuY3Rpb25zLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKG9uZSwgdHdvKSB7XG4gIHJldHVybiBmdW5jdGlvbiBjaGFpbmVkRnVuY3Rpb24oKSB7XG4gICAgb25lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdHdvLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbi8qKlxuICogYFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50YCBtYWludGFpbnMgYW4gYXV4aWxpYXJ5IGxpZmUgY3ljbGUgc3RhdGUgaW5cbiAqIGB0aGlzLl9jb21wb3NpdGVMaWZlQ3ljbGVTdGF0ZWAgKHdoaWNoIGNhbiBiZSBudWxsKS5cbiAqXG4gKiBUaGlzIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBsaWZlIGN5Y2xlIHN0YXRlIG1haW50YWluZWQgYnkgYFJlYWN0Q29tcG9uZW50YCBpblxuICogYHRoaXMuX2xpZmVDeWNsZVN0YXRlYC4gVGhlIGZvbGxvd2luZyBkaWFncmFtIHNob3dzIGhvdyB0aGUgc3RhdGVzIG92ZXJsYXAgaW5cbiAqIHRpbWUuIFRoZXJlIGFyZSB0aW1lcyB3aGVuIHRoZSBDb21wb3NpdGVMaWZlQ3ljbGUgaXMgbnVsbCAtIGF0IHRob3NlIHRpbWVzIGl0XG4gKiBpcyBvbmx5IG1lYW5pbmdmdWwgdG8gbG9vayBhdCBDb21wb25lbnRMaWZlQ3ljbGUgYWxvbmUuXG4gKlxuICogVG9wIFJvdzogUmVhY3RDb21wb25lbnQuQ29tcG9uZW50TGlmZUN5Y2xlXG4gKiBMb3cgUm93OiBSZWFjdENvbXBvbmVudC5Db21wb3NpdGVMaWZlQ3ljbGVcbiAqXG4gKiArLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0rXG4gKiB8ICBVTiAgIHwgICAgICAgICAgICAgICAgICAgIE1PVU5URUQgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgVU4gICB8XG4gKiB8TU9VTlRFRHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IE1PVU5URUR8XG4gKiArLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0rXG4gKiB8ICAgICAgIF4tLS0tLS0tLSsgICArLS0tLS0tKyAgICstLS0tLS0rICAgKy0tLS0tLSsgICArLS0tLS0tLS1eICAgICAgICB8XG4gKiB8ICAgICAgIHwgICAgICAgIHwgICB8ICAgICAgfCAgIHwgICAgICB8ICAgfCAgICAgIHwgICB8ICAgICAgICB8ICAgICAgICB8XG4gKiB8ICAgIDAtLXxNT1VOVElOR3wtMC18UkVDRUlWfC0wLXxSRUNFSVZ8LTAtfFJFQ0VJVnwtMC18ICAgVU4gICB8LS0tPjAgICB8XG4gKiB8ICAgICAgIHwgICAgICAgIHwgICB8UFJPUFMgfCAgIHwgUFJPUFN8ICAgfCBTVEFURXwgICB8TU9VTlRJTkd8ICAgICAgICB8XG4gKiB8ICAgICAgIHwgICAgICAgIHwgICB8ICAgICAgfCAgIHwgICAgICB8ICAgfCAgICAgIHwgICB8ICAgICAgICB8ICAgICAgICB8XG4gKiB8ICAgICAgIHwgICAgICAgIHwgICB8ICAgICAgfCAgIHwgICAgICB8ICAgfCAgICAgIHwgICB8ICAgICAgICB8ICAgICAgICB8XG4gKiB8ICAgICAgICstLS0tLS0tLSsgICArLS0tLS0tKyAgICstLS0tLS0rICAgKy0tLS0tLSsgICArLS0tLS0tLS0rICAgICAgICB8XG4gKiB8ICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICB8XG4gKiArLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0rXG4gKi9cbnZhciBDb21wb3NpdGVMaWZlQ3ljbGUgPSBrZXlNaXJyb3Ioe1xuICAvKipcbiAgICogQ29tcG9uZW50cyBpbiB0aGUgcHJvY2VzcyBvZiBiZWluZyBtb3VudGVkIHJlc3BvbmQgdG8gc3RhdGUgY2hhbmdlc1xuICAgKiBkaWZmZXJlbnRseS5cbiAgICovXG4gIE1PVU5USU5HOiBudWxsLFxuICAvKipcbiAgICogQ29tcG9uZW50cyBpbiB0aGUgcHJvY2VzcyBvZiBiZWluZyB1bm1vdW50ZWQgYXJlIGd1YXJkZWQgYWdhaW5zdCBzdGF0ZVxuICAgKiBjaGFuZ2VzLlxuICAgKi9cbiAgVU5NT1VOVElORzogbnVsbCxcbiAgLyoqXG4gICAqIENvbXBvbmVudHMgdGhhdCBhcmUgbW91bnRlZCBhbmQgcmVjZWl2aW5nIG5ldyBwcm9wcyByZXNwb25kIHRvIHN0YXRlXG4gICAqIGNoYW5nZXMgZGlmZmVyZW50bHkuXG4gICAqL1xuICBSRUNFSVZJTkdfUFJPUFM6IG51bGwsXG4gIC8qKlxuICAgKiBDb21wb25lbnRzIHRoYXQgYXJlIG1vdW50ZWQgYW5kIHJlY2VpdmluZyBuZXcgc3RhdGUgYXJlIGd1YXJkZWQgYWdhaW5zdFxuICAgKiBhZGRpdGlvbmFsIHN0YXRlIGNoYW5nZXMuXG4gICAqL1xuICBSRUNFSVZJTkdfU1RBVEU6IG51bGxcbn0pO1xuXG4vKipcbiAqIEBsZW5kcyB7UmVhY3RDb21wb3NpdGVDb21wb25lbnQucHJvdG90eXBlfVxuICovXG52YXIgUmVhY3RDb21wb3NpdGVDb21wb25lbnRNaXhpbiA9IHtcblxuICAvKipcbiAgICogQmFzZSBjb25zdHJ1Y3RvciBmb3IgYWxsIGNvbXBvc2l0ZSBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3REZXNjcmlwdG9yfSBkZXNjcmlwdG9yXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdDogZnVuY3Rpb24oZGVzY3JpcHRvcikge1xuICAgIC8vIENoaWxkcmVuIGNhbiBiZSBlaXRoZXIgYW4gYXJyYXkgb3IgbW9yZSB0aGFuIG9uZSBhcmd1bWVudFxuICAgIFJlYWN0Q29tcG9uZW50Lk1peGluLmNvbnN0cnVjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIFJlYWN0T3duZXIuTWl4aW4uY29uc3RydWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB0aGlzLnN0YXRlID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nU3RhdGUgPSBudWxsO1xuXG4gICAgLy8gVGhpcyBpcyB0aGUgcHVibGljIHBvc3QtcHJvY2Vzc2VkIGNvbnRleHQuIFRoZSByZWFsIGNvbnRleHQgYW5kIHBlbmRpbmdcbiAgICAvLyBjb250ZXh0IGxpdmVzIG9uIHRoZSBkZXNjcmlwdG9yLlxuICAgIHRoaXMuY29udGV4dCA9IG51bGw7XG5cbiAgICB0aGlzLl9jb21wb3NpdGVMaWZlQ3ljbGVTdGF0ZSA9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBSZWFjdENvbXBvbmVudC5NaXhpbi5pc01vdW50ZWQuY2FsbCh0aGlzKSAmJlxuICAgICAgdGhpcy5fY29tcG9zaXRlTGlmZUN5Y2xlU3RhdGUgIT09IENvbXBvc2l0ZUxpZmVDeWNsZS5NT1VOVElORztcbiAgfSxcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGNvbXBvbmVudCwgcmVuZGVycyBtYXJrdXAsIGFuZCByZWdpc3RlcnMgZXZlbnQgbGlzdGVuZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcm9vdElEIERPTSBJRCBvZiB0aGUgcm9vdCBub2RlLlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1vdW50RGVwdGggbnVtYmVyIG9mIGNvbXBvbmVudHMgaW4gdGhlIG93bmVyIGhpZXJhcmNoeVxuICAgKiBAcmV0dXJuIHs/c3RyaW5nfSBSZW5kZXJlZCBtYXJrdXAgdG8gYmUgaW5zZXJ0ZWQgaW50byB0aGUgRE9NLlxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICBtb3VudENvbXBvbmVudDogUmVhY3RQZXJmLm1lYXN1cmUoXG4gICAgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JyxcbiAgICAnbW91bnRDb21wb25lbnQnLFxuICAgIGZ1bmN0aW9uKHJvb3RJRCwgdHJhbnNhY3Rpb24sIG1vdW50RGVwdGgpIHtcbiAgICAgIFJlYWN0Q29tcG9uZW50Lk1peGluLm1vdW50Q29tcG9uZW50LmNhbGwoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHJvb3RJRCxcbiAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICAgIG1vdW50RGVwdGhcbiAgICAgICk7XG4gICAgICB0aGlzLl9jb21wb3NpdGVMaWZlQ3ljbGVTdGF0ZSA9IENvbXBvc2l0ZUxpZmVDeWNsZS5NT1VOVElORztcblxuICAgICAgaWYgKHRoaXMuX19yZWFjdEF1dG9CaW5kTWFwKSB7XG4gICAgICAgIHRoaXMuX2JpbmRBdXRvQmluZE1ldGhvZHMoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb250ZXh0ID0gdGhpcy5fcHJvY2Vzc0NvbnRleHQodGhpcy5fZGVzY3JpcHRvci5fY29udGV4dCk7XG4gICAgICB0aGlzLnByb3BzID0gdGhpcy5fcHJvY2Vzc1Byb3BzKHRoaXMucHJvcHMpO1xuXG4gICAgICB0aGlzLnN0YXRlID0gdGhpcy5nZXRJbml0aWFsU3RhdGUgPyB0aGlzLmdldEluaXRpYWxTdGF0ZSgpIDogbnVsbDtcbiAgICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAgIHR5cGVvZiB0aGlzLnN0YXRlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheSh0aGlzLnN0YXRlKSxcbiAgICAgICAgJyVzLmdldEluaXRpYWxTdGF0ZSgpOiBtdXN0IHJldHVybiBhbiBvYmplY3Qgb3IgbnVsbCcsXG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50J1xuICAgICAgKSA6IGludmFyaWFudCh0eXBlb2YgdGhpcy5zdGF0ZSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodGhpcy5zdGF0ZSkpKTtcblxuICAgICAgdGhpcy5fcGVuZGluZ1N0YXRlID0gbnVsbDtcbiAgICAgIHRoaXMuX3BlbmRpbmdGb3JjZVVwZGF0ZSA9IGZhbHNlO1xuXG4gICAgICBpZiAodGhpcy5jb21wb25lbnRXaWxsTW91bnQpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgICAgICAgLy8gV2hlbiBtb3VudGluZywgY2FsbHMgdG8gYHNldFN0YXRlYCBieSBgY29tcG9uZW50V2lsbE1vdW50YCB3aWxsIHNldFxuICAgICAgICAvLyBgdGhpcy5fcGVuZGluZ1N0YXRlYCB3aXRob3V0IHRyaWdnZXJpbmcgYSByZS1yZW5kZXIuXG4gICAgICAgIGlmICh0aGlzLl9wZW5kaW5nU3RhdGUpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5fcGVuZGluZ1N0YXRlO1xuICAgICAgICAgIHRoaXMuX3BlbmRpbmdTdGF0ZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fcmVuZGVyZWRDb21wb25lbnQgPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KFxuICAgICAgICB0aGlzLl9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQoKVxuICAgICAgKTtcblxuICAgICAgLy8gRG9uZSB3aXRoIG1vdW50aW5nLCBgc2V0U3RhdGVgIHdpbGwgbm93IHRyaWdnZXIgVUkgY2hhbmdlcy5cbiAgICAgIHRoaXMuX2NvbXBvc2l0ZUxpZmVDeWNsZVN0YXRlID0gbnVsbDtcbiAgICAgIHZhciBtYXJrdXAgPSB0aGlzLl9yZW5kZXJlZENvbXBvbmVudC5tb3VudENvbXBvbmVudChcbiAgICAgICAgcm9vdElELFxuICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgbW91bnREZXB0aCArIDFcbiAgICAgICk7XG4gICAgICBpZiAodGhpcy5jb21wb25lbnREaWRNb3VudCkge1xuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHRoaXMuY29tcG9uZW50RGlkTW91bnQsIHRoaXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hcmt1cDtcbiAgICB9XG4gICksXG5cbiAgLyoqXG4gICAqIFJlbGVhc2VzIGFueSByZXNvdXJjZXMgYWxsb2NhdGVkIGJ5IGBtb3VudENvbXBvbmVudGAuXG4gICAqXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2NvbXBvc2l0ZUxpZmVDeWNsZVN0YXRlID0gQ29tcG9zaXRlTGlmZUN5Y2xlLlVOTU9VTlRJTkc7XG4gICAgaWYgKHRoaXMuY29tcG9uZW50V2lsbFVubW91bnQpIHtcbiAgICAgIHRoaXMuY29tcG9uZW50V2lsbFVubW91bnQoKTtcbiAgICB9XG4gICAgdGhpcy5fY29tcG9zaXRlTGlmZUN5Y2xlU3RhdGUgPSBudWxsO1xuXG4gICAgdGhpcy5fcmVuZGVyZWRDb21wb25lbnQudW5tb3VudENvbXBvbmVudCgpO1xuICAgIHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50ID0gbnVsbDtcblxuICAgIFJlYWN0Q29tcG9uZW50Lk1peGluLnVubW91bnRDb21wb25lbnQuY2FsbCh0aGlzKTtcblxuICAgIC8vIFNvbWUgZXhpc3RpbmcgY29tcG9uZW50cyByZWx5IG9uIHRoaXMucHJvcHMgZXZlbiBhZnRlciB0aGV5J3ZlIGJlZW5cbiAgICAvLyBkZXN0cm95ZWQgKGluIGV2ZW50IGhhbmRsZXJzKS5cbiAgICAvLyBUT0RPOiB0aGlzLnByb3BzID0gbnVsbDtcbiAgICAvLyBUT0RPOiB0aGlzLnN0YXRlID0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyBvciBgcmVwbGFjZVN0YXRlYCB0byBtdXRhdGVcbiAgICogc3RhdGUuIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAgICpcbiAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAgICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAgICpcbiAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgY2FsbHMgdG8gYHNldFN0YXRlYCB3aWxsIHJ1biBzeW5jaHJvbm91c2x5LFxuICAgKiBhcyB0aGV5IG1heSBldmVudHVhbGx5IGJlIGJhdGNoZWQgdG9nZXRoZXIuICBZb3UgY2FuIHByb3ZpZGUgYW4gb3B0aW9uYWxcbiAgICogY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGNhbGwgdG8gc2V0U3RhdGUgaXMgYWN0dWFsbHlcbiAgICogY29tcGxldGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBzdGF0ZS5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICAgKiBAZmluYWxcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgc2V0U3RhdGU6IGZ1bmN0aW9uKHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgdHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ29iamVjdCcgfHwgcGFydGlhbFN0YXRlID09IG51bGwsXG4gICAgICAnc2V0U3RhdGUoLi4uKTogdGFrZXMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcyB0byB1cGRhdGUuJ1xuICAgICkgOiBpbnZhcmlhbnQodHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ29iamVjdCcgfHwgcGFydGlhbFN0YXRlID09IG51bGwpKTtcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKXtcbiAgICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKFxuICAgICAgICBwYXJ0aWFsU3RhdGUgIT0gbnVsbCxcbiAgICAgICAgJ3NldFN0YXRlKC4uLik6IFlvdSBwYXNzZWQgYW4gdW5kZWZpbmVkIG9yIG51bGwgc3RhdGUgb2JqZWN0OyAnICtcbiAgICAgICAgJ2luc3RlYWQsIHVzZSBmb3JjZVVwZGF0ZSgpLidcbiAgICAgICkgOiBudWxsKTtcbiAgICB9XG4gICAgLy8gTWVyZ2Ugd2l0aCBgX3BlbmRpbmdTdGF0ZWAgaWYgaXQgZXhpc3RzLCBvdGhlcndpc2Ugd2l0aCBleGlzdGluZyBzdGF0ZS5cbiAgICB0aGlzLnJlcGxhY2VTdGF0ZShcbiAgICAgIG1lcmdlKHRoaXMuX3BlbmRpbmdTdGF0ZSB8fCB0aGlzLnN0YXRlLCBwYXJ0aWFsU3RhdGUpLFxuICAgICAgY2FsbGJhY2tcbiAgICApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgb3IgYHNldFN0YXRlYCB0byBtdXRhdGUgc3RhdGUuXG4gICAqIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAgICpcbiAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAgICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBsZXRlU3RhdGUgTmV4dCBzdGF0ZS5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICAgKiBAZmluYWxcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgcmVwbGFjZVN0YXRlOiBmdW5jdGlvbihjb21wbGV0ZVN0YXRlLCBjYWxsYmFjaykge1xuICAgIHZhbGlkYXRlTGlmZUN5Y2xlT25SZXBsYWNlU3RhdGUodGhpcyk7XG4gICAgdGhpcy5fcGVuZGluZ1N0YXRlID0gY29tcGxldGVTdGF0ZTtcbiAgICBpZiAodGhpcy5fY29tcG9zaXRlTGlmZUN5Y2xlU3RhdGUgIT09IENvbXBvc2l0ZUxpZmVDeWNsZS5NT1VOVElORykge1xuICAgICAgLy8gSWYgd2UncmUgaW4gYSBjb21wb25lbnRXaWxsTW91bnQgaGFuZGxlciwgZG9uJ3QgZW5xdWV1ZSBhIHJlcmVuZGVyXG4gICAgICAvLyBiZWNhdXNlIFJlYWN0VXBkYXRlcyBhc3N1bWVzIHdlJ3JlIGluIGEgYnJvd3NlciBjb250ZXh0ICh3aGljaCBpcyB3cm9uZ1xuICAgICAgLy8gZm9yIHNlcnZlciByZW5kZXJpbmcpIGFuZCB3ZSdyZSBhYm91dCB0byBkbyBhIHJlbmRlciBhbnl3YXkuXG4gICAgICAvLyBUT0RPOiBUaGUgY2FsbGJhY2sgaGVyZSBpcyBpZ25vcmVkIHdoZW4gc2V0U3RhdGUgaXMgY2FsbGVkIGZyb21cbiAgICAgIC8vIGNvbXBvbmVudFdpbGxNb3VudC4gRWl0aGVyIGZpeCBpdCBvciBkaXNhbGxvdyBkb2luZyBzbyBjb21wbGV0ZWx5IGluXG4gICAgICAvLyBmYXZvciBvZiBnZXRJbml0aWFsU3RhdGUuXG4gICAgICBSZWFjdFVwZGF0ZXMuZW5xdWV1ZVVwZGF0ZSh0aGlzLCBjYWxsYmFjayk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBGaWx0ZXJzIHRoZSBjb250ZXh0IG9iamVjdCB0byBvbmx5IGNvbnRhaW4ga2V5cyBzcGVjaWZpZWQgaW5cbiAgICogYGNvbnRleHRUeXBlc2AsIGFuZCBhc3NlcnRzIHRoYXQgdGhleSBhcmUgdmFsaWQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4gez9vYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcHJvY2Vzc0NvbnRleHQ6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICB2YXIgbWFza2VkQ29udGV4dCA9IG51bGw7XG4gICAgdmFyIGNvbnRleHRUeXBlcyA9IHRoaXMuY29uc3RydWN0b3IuY29udGV4dFR5cGVzO1xuICAgIGlmIChjb250ZXh0VHlwZXMpIHtcbiAgICAgIG1hc2tlZENvbnRleHQgPSB7fTtcbiAgICAgIGZvciAodmFyIGNvbnRleHROYW1lIGluIGNvbnRleHRUeXBlcykge1xuICAgICAgICBtYXNrZWRDb250ZXh0W2NvbnRleHROYW1lXSA9IGNvbnRleHRbY29udGV4dE5hbWVdO1xuICAgICAgfVxuICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgICB0aGlzLl9jaGVja1Byb3BUeXBlcyhcbiAgICAgICAgICBjb250ZXh0VHlwZXMsXG4gICAgICAgICAgbWFza2VkQ29udGV4dCxcbiAgICAgICAgICBSZWFjdFByb3BUeXBlTG9jYXRpb25zLmNvbnRleHRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hc2tlZENvbnRleHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjdXJyZW50Q29udGV4dFxuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcHJvY2Vzc0NoaWxkQ29udGV4dDogZnVuY3Rpb24oY3VycmVudENvbnRleHQpIHtcbiAgICB2YXIgY2hpbGRDb250ZXh0ID0gdGhpcy5nZXRDaGlsZENvbnRleHQgJiYgdGhpcy5nZXRDaGlsZENvbnRleHQoKTtcbiAgICB2YXIgZGlzcGxheU5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCc7XG4gICAgaWYgKGNoaWxkQ29udGV4dCkge1xuICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICAgdHlwZW9mIHRoaXMuY29uc3RydWN0b3IuY2hpbGRDb250ZXh0VHlwZXMgPT09ICdvYmplY3QnLFxuICAgICAgICAnJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGNoaWxkQ29udGV4dFR5cGVzIG11c3QgYmUgZGVmaW5lZCBpbiBvcmRlciB0byAnICtcbiAgICAgICAgJ3VzZSBnZXRDaGlsZENvbnRleHQoKS4nLFxuICAgICAgICBkaXNwbGF5TmFtZVxuICAgICAgKSA6IGludmFyaWFudCh0eXBlb2YgdGhpcy5jb25zdHJ1Y3Rvci5jaGlsZENvbnRleHRUeXBlcyA9PT0gJ29iamVjdCcpKTtcbiAgICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tQcm9wVHlwZXMoXG4gICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5jaGlsZENvbnRleHRUeXBlcyxcbiAgICAgICAgICBjaGlsZENvbnRleHQsXG4gICAgICAgICAgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5jaGlsZENvbnRleHRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIG5hbWUgaW4gY2hpbGRDb250ZXh0KSB7XG4gICAgICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAgICAgbmFtZSBpbiB0aGlzLmNvbnN0cnVjdG9yLmNoaWxkQ29udGV4dFR5cGVzLFxuICAgICAgICAgICclcy5nZXRDaGlsZENvbnRleHQoKToga2V5IFwiJXNcIiBpcyBub3QgZGVmaW5lZCBpbiBjaGlsZENvbnRleHRUeXBlcy4nLFxuICAgICAgICAgIGRpc3BsYXlOYW1lLFxuICAgICAgICAgIG5hbWVcbiAgICAgICAgKSA6IGludmFyaWFudChuYW1lIGluIHRoaXMuY29uc3RydWN0b3IuY2hpbGRDb250ZXh0VHlwZXMpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXJnZShjdXJyZW50Q29udGV4dCwgY2hpbGRDb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnRDb250ZXh0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBQcm9jZXNzZXMgcHJvcHMgYnkgc2V0dGluZyBkZWZhdWx0IHZhbHVlcyBmb3IgdW5zcGVjaWZpZWQgcHJvcHMgYW5kXG4gICAqIGFzc2VydGluZyB0aGF0IHRoZSBwcm9wcyBhcmUgdmFsaWQuIERvZXMgbm90IG11dGF0ZSBpdHMgYXJndW1lbnQ7IHJldHVybnNcbiAgICogYSBuZXcgcHJvcHMgb2JqZWN0IHdpdGggZGVmYXVsdHMgbWVyZ2VkIGluLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV3UHJvcHNcbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Byb2Nlc3NQcm9wczogZnVuY3Rpb24obmV3UHJvcHMpIHtcbiAgICB2YXIgZGVmYXVsdFByb3BzID0gdGhpcy5jb25zdHJ1Y3Rvci5kZWZhdWx0UHJvcHM7XG4gICAgdmFyIHByb3BzO1xuICAgIGlmIChkZWZhdWx0UHJvcHMpIHtcbiAgICAgIHByb3BzID0gbWVyZ2UobmV3UHJvcHMpO1xuICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvcHNbcHJvcE5hbWVdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcHJvcHMgPSBuZXdQcm9wcztcbiAgICB9XG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgdmFyIHByb3BUeXBlcyA9IHRoaXMuY29uc3RydWN0b3IucHJvcFR5cGVzO1xuICAgICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgICB0aGlzLl9jaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIHByb3BzLCBSZWFjdFByb3BUeXBlTG9jYXRpb25zLnByb3ApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcHM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFzc2VydCB0aGF0IHRoZSBwcm9wcyBhcmUgdmFsaWRcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHByb3BUeXBlcyBNYXAgb2YgcHJvcCBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NoZWNrUHJvcFR5cGVzOiBmdW5jdGlvbihwcm9wVHlwZXMsIHByb3BzLCBsb2NhdGlvbikge1xuICAgIC8vIFRPRE86IFN0b3AgdmFsaWRhdGluZyBwcm9wIHR5cGVzIGhlcmUgYW5kIG9ubHkgdXNlIHRoZSBkZXNjcmlwdG9yXG4gICAgLy8gdmFsaWRhdGlvbi5cbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IHRoaXMuY29uc3RydWN0b3IuZGlzcGxheU5hbWU7XG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gcHJvcFR5cGVzKSB7XG4gICAgICBpZiAocHJvcFR5cGVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3IgPVxuICAgICAgICAgIHByb3BUeXBlc1twcm9wTmFtZV0ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbik7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgLy8gV2UgbWF5IHdhbnQgdG8gZXh0ZW5kIHRoaXMgbG9naWMgZm9yIHNpbWlsYXIgZXJyb3JzIGluXG4gICAgICAgICAgLy8gcmVuZGVyQ29tcG9uZW50IGNhbGxzLCBzbyBJJ20gYWJzdHJhY3RpbmcgaXQgYXdheSBpbnRvXG4gICAgICAgICAgLy8gYSBmdW5jdGlvbiB0byBtaW5pbWl6ZSByZWZhY3RvcmluZyBpbiB0aGUgZnV0dXJlXG4gICAgICAgICAgdmFyIGFkZGVuZHVtID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKHRoaXMpO1xuICAgICAgICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKGZhbHNlLCBlcnJvci5tZXNzYWdlICsgYWRkZW5kdW0pIDogbnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIElmIGFueSBvZiBgX3BlbmRpbmdEZXNjcmlwdG9yYCwgYF9wZW5kaW5nU3RhdGVgLCBvciBgX3BlbmRpbmdGb3JjZVVwZGF0ZWBcbiAgICogaXMgc2V0LCB1cGRhdGUgdGhlIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeTogZnVuY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICB2YXIgY29tcG9zaXRlTGlmZUN5Y2xlU3RhdGUgPSB0aGlzLl9jb21wb3NpdGVMaWZlQ3ljbGVTdGF0ZTtcbiAgICAvLyBEbyBub3QgdHJpZ2dlciBhIHN0YXRlIHRyYW5zaXRpb24gaWYgd2UgYXJlIGluIHRoZSBtaWRkbGUgb2YgbW91bnRpbmcgb3JcbiAgICAvLyByZWNlaXZpbmcgcHJvcHMgYmVjYXVzZSBib3RoIG9mIHRob3NlIHdpbGwgYWxyZWFkeSBiZSBkb2luZyB0aGlzLlxuICAgIGlmIChjb21wb3NpdGVMaWZlQ3ljbGVTdGF0ZSA9PT0gQ29tcG9zaXRlTGlmZUN5Y2xlLk1PVU5USU5HIHx8XG4gICAgICAgIGNvbXBvc2l0ZUxpZmVDeWNsZVN0YXRlID09PSBDb21wb3NpdGVMaWZlQ3ljbGUuUkVDRUlWSU5HX1BST1BTKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3BlbmRpbmdEZXNjcmlwdG9yID09IG51bGwgJiZcbiAgICAgICAgdGhpcy5fcGVuZGluZ1N0YXRlID09IG51bGwgJiZcbiAgICAgICAgIXRoaXMuX3BlbmRpbmdGb3JjZVVwZGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0Q29udGV4dCA9IHRoaXMuY29udGV4dDtcbiAgICB2YXIgbmV4dFByb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgbmV4dERlc2NyaXB0b3IgPSB0aGlzLl9kZXNjcmlwdG9yO1xuICAgIGlmICh0aGlzLl9wZW5kaW5nRGVzY3JpcHRvciAhPSBudWxsKSB7XG4gICAgICBuZXh0RGVzY3JpcHRvciA9IHRoaXMuX3BlbmRpbmdEZXNjcmlwdG9yO1xuICAgICAgbmV4dENvbnRleHQgPSB0aGlzLl9wcm9jZXNzQ29udGV4dChuZXh0RGVzY3JpcHRvci5fY29udGV4dCk7XG4gICAgICBuZXh0UHJvcHMgPSB0aGlzLl9wcm9jZXNzUHJvcHMobmV4dERlc2NyaXB0b3IucHJvcHMpO1xuICAgICAgdGhpcy5fcGVuZGluZ0Rlc2NyaXB0b3IgPSBudWxsO1xuXG4gICAgICB0aGlzLl9jb21wb3NpdGVMaWZlQ3ljbGVTdGF0ZSA9IENvbXBvc2l0ZUxpZmVDeWNsZS5SRUNFSVZJTkdfUFJPUFM7XG4gICAgICBpZiAodGhpcy5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9jb21wb3NpdGVMaWZlQ3ljbGVTdGF0ZSA9IENvbXBvc2l0ZUxpZmVDeWNsZS5SRUNFSVZJTkdfU1RBVEU7XG5cbiAgICB2YXIgbmV4dFN0YXRlID0gdGhpcy5fcGVuZGluZ1N0YXRlIHx8IHRoaXMuc3RhdGU7XG4gICAgdGhpcy5fcGVuZGluZ1N0YXRlID0gbnVsbDtcblxuICAgIHRyeSB7XG4gICAgICB2YXIgc2hvdWxkVXBkYXRlID1cbiAgICAgICAgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlIHx8XG4gICAgICAgICF0aGlzLnNob3VsZENvbXBvbmVudFVwZGF0ZSB8fFxuICAgICAgICB0aGlzLnNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQpO1xuXG4gICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2hvdWxkVXBkYXRlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgKHRoaXMuY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgK1xuICAgICAgICAgICAgJy5zaG91bGRDb21wb25lbnRVcGRhdGUoKTogUmV0dXJuZWQgdW5kZWZpbmVkIGluc3RlYWQgb2YgYSAnICtcbiAgICAgICAgICAgICdib29sZWFuIHZhbHVlLiBNYWtlIHN1cmUgdG8gcmV0dXJuIHRydWUgb3IgZmFsc2UuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNob3VsZFVwZGF0ZSkge1xuICAgICAgICB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgLy8gV2lsbCBzZXQgYHRoaXMucHJvcHNgLCBgdGhpcy5zdGF0ZWAgYW5kIGB0aGlzLmNvbnRleHRgLlxuICAgICAgICB0aGlzLl9wZXJmb3JtQ29tcG9uZW50VXBkYXRlKFxuICAgICAgICAgIG5leHREZXNjcmlwdG9yLFxuICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICBuZXh0U3RhdGUsXG4gICAgICAgICAgbmV4dENvbnRleHQsXG4gICAgICAgICAgdHJhbnNhY3Rpb25cbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIGl0J3MgZGV0ZXJtaW5lZCB0aGF0IGEgY29tcG9uZW50IHNob3VsZCBub3QgdXBkYXRlLCB3ZSBzdGlsbCB3YW50XG4gICAgICAgIC8vIHRvIHNldCBwcm9wcyBhbmQgc3RhdGUuXG4gICAgICAgIHRoaXMuX2Rlc2NyaXB0b3IgPSBuZXh0RGVzY3JpcHRvcjtcbiAgICAgICAgdGhpcy5wcm9wcyA9IG5leHRQcm9wcztcbiAgICAgICAgdGhpcy5zdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gbmV4dENvbnRleHQ7XG5cbiAgICAgICAgLy8gT3duZXIgY2Fubm90IGNoYW5nZSBiZWNhdXNlIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50IGRvZXNuJ3QgYWxsb3dcbiAgICAgICAgLy8gaXQuIFRPRE86IFJlbW92ZSB0aGlzLl9vd25lciBjb21wbGV0ZWx5LlxuICAgICAgICB0aGlzLl9vd25lciA9IG5leHREZXNjcmlwdG9yLl9vd25lcjtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5fY29tcG9zaXRlTGlmZUN5Y2xlU3RhdGUgPSBudWxsO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTWVyZ2VzIG5ldyBwcm9wcyBhbmQgc3RhdGUsIG5vdGlmaWVzIGRlbGVnYXRlIG1ldGhvZHMgb2YgdXBkYXRlIGFuZFxuICAgKiBwZXJmb3JtcyB1cGRhdGUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3REZXNjcmlwdG9yfSBuZXh0RGVzY3JpcHRvciBOZXh0IGRlc2NyaXB0b3JcbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wcyBOZXh0IHB1YmxpYyBvYmplY3QgdG8gc2V0IGFzIHByb3BlcnRpZXMuXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dFN0YXRlIE5leHQgb2JqZWN0IHRvIHNldCBhcyBzdGF0ZS5cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0Q29udGV4dCBOZXh0IHB1YmxpYyBvYmplY3QgdG8gc2V0IGFzIGNvbnRleHQuXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wZXJmb3JtQ29tcG9uZW50VXBkYXRlOiBmdW5jdGlvbihcbiAgICBuZXh0RGVzY3JpcHRvcixcbiAgICBuZXh0UHJvcHMsXG4gICAgbmV4dFN0YXRlLFxuICAgIG5leHRDb250ZXh0LFxuICAgIHRyYW5zYWN0aW9uXG4gICkge1xuICAgIHZhciBwcmV2RGVzY3JpcHRvciA9IHRoaXMuX2Rlc2NyaXB0b3I7XG4gICAgdmFyIHByZXZQcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHByZXZTdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgdmFyIHByZXZDb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgaWYgKHRoaXMuY29tcG9uZW50V2lsbFVwZGF0ZSkge1xuICAgICAgdGhpcy5jb21wb25lbnRXaWxsVXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgfVxuXG4gICAgdGhpcy5fZGVzY3JpcHRvciA9IG5leHREZXNjcmlwdG9yO1xuICAgIHRoaXMucHJvcHMgPSBuZXh0UHJvcHM7XG4gICAgdGhpcy5zdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICB0aGlzLmNvbnRleHQgPSBuZXh0Q29udGV4dDtcblxuICAgIC8vIE93bmVyIGNhbm5vdCBjaGFuZ2UgYmVjYXVzZSBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCBkb2Vzbid0IGFsbG93XG4gICAgLy8gaXQuIFRPRE86IFJlbW92ZSB0aGlzLl9vd25lciBjb21wbGV0ZWx5LlxuICAgIHRoaXMuX293bmVyID0gbmV4dERlc2NyaXB0b3IuX293bmVyO1xuXG4gICAgdGhpcy51cGRhdGVDb21wb25lbnQoXG4gICAgICB0cmFuc2FjdGlvbixcbiAgICAgIHByZXZEZXNjcmlwdG9yXG4gICAgKTtcblxuICAgIGlmICh0aGlzLmNvbXBvbmVudERpZFVwZGF0ZSkge1xuICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShcbiAgICAgICAgdGhpcy5jb21wb25lbnREaWRVcGRhdGUuYmluZCh0aGlzLCBwcmV2UHJvcHMsIHByZXZTdGF0ZSwgcHJldkNvbnRleHQpLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH1cbiAgfSxcblxuICByZWNlaXZlQ29tcG9uZW50OiBmdW5jdGlvbihuZXh0RGVzY3JpcHRvciwgdHJhbnNhY3Rpb24pIHtcbiAgICBpZiAobmV4dERlc2NyaXB0b3IgPT09IHRoaXMuX2Rlc2NyaXB0b3IgJiZcbiAgICAgICAgbmV4dERlc2NyaXB0b3IuX293bmVyICE9IG51bGwpIHtcbiAgICAgIC8vIFNpbmNlIGRlc2NyaXB0b3JzIGFyZSBpbW11dGFibGUgYWZ0ZXIgdGhlIG93bmVyIGlzIHJlbmRlcmVkLFxuICAgICAgLy8gd2UgY2FuIGRvIGEgY2hlYXAgaWRlbnRpdHkgY29tcGFyZSBoZXJlIHRvIGRldGVybWluZSBpZiB0aGlzIGlzIGFcbiAgICAgIC8vIHN1cGVyZmx1b3VzIHJlY29uY2lsZS4gSXQncyBwb3NzaWJsZSBmb3Igc3RhdGUgdG8gYmUgbXV0YWJsZSBidXQgc3VjaFxuICAgICAgLy8gY2hhbmdlIHNob3VsZCB0cmlnZ2VyIGFuIHVwZGF0ZSBvZiB0aGUgb3duZXIgd2hpY2ggd291bGQgcmVjcmVhdGVcbiAgICAgIC8vIHRoZSBkZXNjcmlwdG9yLiBXZSBleHBsaWNpdGx5IGNoZWNrIGZvciB0aGUgZXhpc3RlbmNlIG9mIGFuIG93bmVyIHNpbmNlXG4gICAgICAvLyBpdCdzIHBvc3NpYmxlIGZvciBhIGRlc2NyaXB0b3IgY3JlYXRlZCBvdXRzaWRlIGEgY29tcG9zaXRlIHRvIGJlXG4gICAgICAvLyBkZWVwbHkgbXV0YXRlZCBhbmQgcmV1c2VkLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIFJlYWN0Q29tcG9uZW50Lk1peGluLnJlY2VpdmVDb21wb25lbnQuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICBuZXh0RGVzY3JpcHRvcixcbiAgICAgIHRyYW5zYWN0aW9uXG4gICAgKTtcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgY29tcG9uZW50J3MgY3VycmVudGx5IG1vdW50ZWQgRE9NIHJlcHJlc2VudGF0aW9uLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCB0aGlzIGltcGxlbWVudHMgUmVhY3QncyByZW5kZXJpbmcgYW5kIHJlY29uY2lsaWF0aW9uIGFsZ29yaXRobS5cbiAgICogU29waGlzdGljYXRlZCBjbGllbnRzIG1heSB3aXNoIHRvIG92ZXJyaWRlIHRoaXMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtSZWFjdERlc2NyaXB0b3J9IHByZXZEZXNjcmlwdG9yXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAb3ZlcnJpZGFibGVcbiAgICovXG4gIHVwZGF0ZUNvbXBvbmVudDogUmVhY3RQZXJmLm1lYXN1cmUoXG4gICAgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JyxcbiAgICAndXBkYXRlQ29tcG9uZW50JyxcbiAgICBmdW5jdGlvbih0cmFuc2FjdGlvbiwgcHJldlBhcmVudERlc2NyaXB0b3IpIHtcbiAgICAgIFJlYWN0Q29tcG9uZW50Lk1peGluLnVwZGF0ZUNvbXBvbmVudC5jYWxsKFxuICAgICAgICB0aGlzLFxuICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgcHJldlBhcmVudERlc2NyaXB0b3JcbiAgICAgICk7XG5cbiAgICAgIHZhciBwcmV2Q29tcG9uZW50SW5zdGFuY2UgPSB0aGlzLl9yZW5kZXJlZENvbXBvbmVudDtcbiAgICAgIHZhciBwcmV2RGVzY3JpcHRvciA9IHByZXZDb21wb25lbnRJbnN0YW5jZS5fZGVzY3JpcHRvcjtcbiAgICAgIHZhciBuZXh0RGVzY3JpcHRvciA9IHRoaXMuX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCgpO1xuICAgICAgaWYgKHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50KHByZXZEZXNjcmlwdG9yLCBuZXh0RGVzY3JpcHRvcikpIHtcbiAgICAgICAgcHJldkNvbXBvbmVudEluc3RhbmNlLnJlY2VpdmVDb21wb25lbnQobmV4dERlc2NyaXB0b3IsIHRyYW5zYWN0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoZXNlIHR3byBJRHMgYXJlIGFjdHVhbGx5IHRoZSBzYW1lISBCdXQgbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGF0LlxuICAgICAgICB2YXIgdGhpc0lEID0gdGhpcy5fcm9vdE5vZGVJRDtcbiAgICAgICAgdmFyIHByZXZDb21wb25lbnRJRCA9IHByZXZDb21wb25lbnRJbnN0YW5jZS5fcm9vdE5vZGVJRDtcbiAgICAgICAgcHJldkNvbXBvbmVudEluc3RhbmNlLnVubW91bnRDb21wb25lbnQoKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZWRDb21wb25lbnQgPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KG5leHREZXNjcmlwdG9yKTtcbiAgICAgICAgdmFyIG5leHRNYXJrdXAgPSB0aGlzLl9yZW5kZXJlZENvbXBvbmVudC5tb3VudENvbXBvbmVudChcbiAgICAgICAgICB0aGlzSUQsXG4gICAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICAgICAgdGhpcy5fbW91bnREZXB0aCArIDFcbiAgICAgICAgKTtcbiAgICAgICAgUmVhY3RDb21wb25lbnQuQmFja2VuZElET3BlcmF0aW9ucy5kYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cEJ5SUQoXG4gICAgICAgICAgcHJldkNvbXBvbmVudElELFxuICAgICAgICAgIG5leHRNYXJrdXBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICksXG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRVcGRhdGVDb21wb25lbnRgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciB1cGRhdGUgaXMgY29tcGxldGUuXG4gICAqIEBmaW5hbFxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBmb3JjZVVwZGF0ZTogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICB2YXIgY29tcG9zaXRlTGlmZUN5Y2xlU3RhdGUgPSB0aGlzLl9jb21wb3NpdGVMaWZlQ3ljbGVTdGF0ZTtcbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgdGhpcy5pc01vdW50ZWQoKSB8fFxuICAgICAgICBjb21wb3NpdGVMaWZlQ3ljbGVTdGF0ZSA9PT0gQ29tcG9zaXRlTGlmZUN5Y2xlLk1PVU5USU5HLFxuICAgICAgJ2ZvcmNlVXBkYXRlKC4uLik6IENhbiBvbmx5IGZvcmNlIGFuIHVwZGF0ZSBvbiBtb3VudGVkIG9yIG1vdW50aW5nICcgK1xuICAgICAgICAnY29tcG9uZW50cy4nXG4gICAgKSA6IGludmFyaWFudCh0aGlzLmlzTW91bnRlZCgpIHx8XG4gICAgICBjb21wb3NpdGVMaWZlQ3ljbGVTdGF0ZSA9PT0gQ29tcG9zaXRlTGlmZUN5Y2xlLk1PVU5USU5HKSk7XG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgIGNvbXBvc2l0ZUxpZmVDeWNsZVN0YXRlICE9PSBDb21wb3NpdGVMaWZlQ3ljbGUuUkVDRUlWSU5HX1NUQVRFICYmXG4gICAgICBjb21wb3NpdGVMaWZlQ3ljbGVTdGF0ZSAhPT0gQ29tcG9zaXRlTGlmZUN5Y2xlLlVOTU9VTlRJTkcsXG4gICAgICAnZm9yY2VVcGRhdGUoLi4uKTogQ2Fubm90IGZvcmNlIGFuIHVwZGF0ZSB3aGlsZSB1bm1vdW50aW5nIGNvbXBvbmVudCAnICtcbiAgICAgICdvciBkdXJpbmcgYW4gZXhpc3Rpbmcgc3RhdGUgdHJhbnNpdGlvbiAoc3VjaCBhcyB3aXRoaW4gYHJlbmRlcmApLidcbiAgICApIDogaW52YXJpYW50KGNvbXBvc2l0ZUxpZmVDeWNsZVN0YXRlICE9PSBDb21wb3NpdGVMaWZlQ3ljbGUuUkVDRUlWSU5HX1NUQVRFICYmXG4gICAgY29tcG9zaXRlTGlmZUN5Y2xlU3RhdGUgIT09IENvbXBvc2l0ZUxpZmVDeWNsZS5VTk1PVU5USU5HKSk7XG4gICAgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gdHJ1ZTtcbiAgICBSZWFjdFVwZGF0ZXMuZW5xdWV1ZVVwZGF0ZSh0aGlzLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50OiBSZWFjdFBlcmYubWVhc3VyZShcbiAgICAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnLFxuICAgICdfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50JyxcbiAgICBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZW5kZXJlZENvbXBvbmVudDtcbiAgICAgIHZhciBwcmV2aW91c0NvbnRleHQgPSBSZWFjdENvbnRleHQuY3VycmVudDtcbiAgICAgIFJlYWN0Q29udGV4dC5jdXJyZW50ID0gdGhpcy5fcHJvY2Vzc0NoaWxkQ29udGV4dChcbiAgICAgICAgdGhpcy5fZGVzY3JpcHRvci5fY29udGV4dFxuICAgICAgKTtcbiAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSB0aGlzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVuZGVyZWRDb21wb25lbnQgPSB0aGlzLnJlbmRlcigpO1xuICAgICAgICBpZiAocmVuZGVyZWRDb21wb25lbnQgPT09IG51bGwgfHwgcmVuZGVyZWRDb21wb25lbnQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmVuZGVyZWRDb21wb25lbnQgPSBSZWFjdEVtcHR5Q29tcG9uZW50LmdldEVtcHR5Q29tcG9uZW50KCk7XG4gICAgICAgICAgUmVhY3RFbXB0eUNvbXBvbmVudC5yZWdpc3Rlck51bGxDb21wb25lbnRJRCh0aGlzLl9yb290Tm9kZUlEKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBSZWFjdEVtcHR5Q29tcG9uZW50LmRlcmVnaXN0ZXJOdWxsQ29tcG9uZW50SUQodGhpcy5fcm9vdE5vZGVJRCk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q29udGV4dC5jdXJyZW50ID0gcHJldmlvdXNDb250ZXh0O1xuICAgICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAgIFJlYWN0RGVzY3JpcHRvci5pc1ZhbGlkRGVzY3JpcHRvcihyZW5kZXJlZENvbXBvbmVudCksXG4gICAgICAgICclcy5yZW5kZXIoKTogQSB2YWxpZCBSZWFjdENvbXBvbmVudCBtdXN0IGJlIHJldHVybmVkLiBZb3UgbWF5IGhhdmUgJyArXG4gICAgICAgICAgJ3JldHVybmVkIHVuZGVmaW5lZCwgYW4gYXJyYXkgb3Igc29tZSBvdGhlciBpbnZhbGlkIG9iamVjdC4nLFxuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCdcbiAgICAgICkgOiBpbnZhcmlhbnQoUmVhY3REZXNjcmlwdG9yLmlzVmFsaWREZXNjcmlwdG9yKHJlbmRlcmVkQ29tcG9uZW50KSkpO1xuICAgICAgcmV0dXJuIHJlbmRlcmVkQ29tcG9uZW50O1xuICAgIH1cbiAgKSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9iaW5kQXV0b0JpbmRNZXRob2RzOiBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBhdXRvQmluZEtleSBpbiB0aGlzLl9fcmVhY3RBdXRvQmluZE1hcCkge1xuICAgICAgaWYgKCF0aGlzLl9fcmVhY3RBdXRvQmluZE1hcC5oYXNPd25Qcm9wZXJ0eShhdXRvQmluZEtleSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgbWV0aG9kID0gdGhpcy5fX3JlYWN0QXV0b0JpbmRNYXBbYXV0b0JpbmRLZXldO1xuICAgICAgdGhpc1thdXRvQmluZEtleV0gPSB0aGlzLl9iaW5kQXV0b0JpbmRNZXRob2QoUmVhY3RFcnJvclV0aWxzLmd1YXJkKFxuICAgICAgICBtZXRob2QsXG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IuZGlzcGxheU5hbWUgKyAnLicgKyBhdXRvQmluZEtleVxuICAgICAgKSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBCaW5kcyBhIG1ldGhvZCB0byB0aGUgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBtZXRob2QgTWV0aG9kIHRvIGJlIGJvdW5kLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2JpbmRBdXRvQmluZE1ldGhvZDogZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgdmFyIGNvbXBvbmVudCA9IHRoaXM7XG4gICAgdmFyIGJvdW5kTWV0aG9kID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbWV0aG9kLmFwcGx5KGNvbXBvbmVudCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgIGJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZENvbnRleHQgPSBjb21wb25lbnQ7XG4gICAgICBib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRNZXRob2QgPSBtZXRob2Q7XG4gICAgICBib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRBcmd1bWVudHMgPSBudWxsO1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnQuY29uc3RydWN0b3IuZGlzcGxheU5hbWU7XG4gICAgICB2YXIgX2JpbmQgPSBib3VuZE1ldGhvZC5iaW5kO1xuICAgICAgYm91bmRNZXRob2QuYmluZCA9IGZ1bmN0aW9uKG5ld1RoaXMgKSB7dmFyIGFyZ3M9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpO1xuICAgICAgICAvLyBVc2VyIGlzIHRyeWluZyB0byBiaW5kKCkgYW4gYXV0b2JvdW5kIG1ldGhvZDsgd2UgZWZmZWN0aXZlbHkgd2lsbFxuICAgICAgICAvLyBpZ25vcmUgdGhlIHZhbHVlIG9mIFwidGhpc1wiIHRoYXQgdGhlIHVzZXIgaXMgdHJ5aW5nIHRvIHVzZSwgc29cbiAgICAgICAgLy8gbGV0J3Mgd2Fybi5cbiAgICAgICAgaWYgKG5ld1RoaXMgIT09IGNvbXBvbmVudCAmJiBuZXdUaGlzICE9PSBudWxsKSB7XG4gICAgICAgICAgbW9uaXRvckNvZGVVc2UoJ3JlYWN0X2JpbmRfd2FybmluZycsIHsgY29tcG9uZW50OiBjb21wb25lbnROYW1lIH0pO1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICdiaW5kKCk6IFJlYWN0IGNvbXBvbmVudCBtZXRob2RzIG1heSBvbmx5IGJlIGJvdW5kIHRvIHRoZSAnICtcbiAgICAgICAgICAgICdjb21wb25lbnQgaW5zdGFuY2UuIFNlZSAnICsgY29tcG9uZW50TmFtZVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgbW9uaXRvckNvZGVVc2UoJ3JlYWN0X2JpbmRfd2FybmluZycsIHsgY29tcG9uZW50OiBjb21wb25lbnROYW1lIH0pO1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICdiaW5kKCk6IFlvdSBhcmUgYmluZGluZyBhIGNvbXBvbmVudCBtZXRob2QgdG8gdGhlIGNvbXBvbmVudC4gJyArXG4gICAgICAgICAgICAnUmVhY3QgZG9lcyB0aGlzIGZvciB5b3UgYXV0b21hdGljYWxseSBpbiBhIGhpZ2gtcGVyZm9ybWFuY2UgJyArXG4gICAgICAgICAgICAnd2F5LCBzbyB5b3UgY2FuIHNhZmVseSByZW1vdmUgdGhpcyBjYWxsLiBTZWUgJyArIGNvbXBvbmVudE5hbWVcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiBib3VuZE1ldGhvZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVib3VuZE1ldGhvZCA9IF9iaW5kLmFwcGx5KGJvdW5kTWV0aG9kLCBhcmd1bWVudHMpO1xuICAgICAgICByZWJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZENvbnRleHQgPSBjb21wb25lbnQ7XG4gICAgICAgIHJlYm91bmRNZXRob2QuX19yZWFjdEJvdW5kTWV0aG9kID0gbWV0aG9kO1xuICAgICAgICByZWJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZEFyZ3VtZW50cyA9IGFyZ3M7XG4gICAgICAgIHJldHVybiByZWJvdW5kTWV0aG9kO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGJvdW5kTWV0aG9kO1xuICB9XG59O1xuXG52YXIgUmVhY3RDb21wb3NpdGVDb21wb25lbnRCYXNlID0gZnVuY3Rpb24oKSB7fTtcbm1peEludG8oUmVhY3RDb21wb3NpdGVDb21wb25lbnRCYXNlLCBSZWFjdENvbXBvbmVudC5NaXhpbik7XG5taXhJbnRvKFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50QmFzZSwgUmVhY3RPd25lci5NaXhpbik7XG5taXhJbnRvKFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50QmFzZSwgUmVhY3RQcm9wVHJhbnNmZXJlci5NaXhpbik7XG5taXhJbnRvKFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50QmFzZSwgUmVhY3RDb21wb3NpdGVDb21wb25lbnRNaXhpbik7XG5cbi8qKlxuICogTW9kdWxlIGZvciBjcmVhdGluZyBjb21wb3NpdGUgY29tcG9uZW50cy5cbiAqXG4gKiBAY2xhc3MgUmVhY3RDb21wb3NpdGVDb21wb25lbnRcbiAqIEBleHRlbmRzIFJlYWN0Q29tcG9uZW50XG4gKiBAZXh0ZW5kcyBSZWFjdE93bmVyXG4gKiBAZXh0ZW5kcyBSZWFjdFByb3BUcmFuc2ZlcmVyXG4gKi9cbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCA9IHtcblxuICBMaWZlQ3ljbGU6IENvbXBvc2l0ZUxpZmVDeWNsZSxcblxuICBCYXNlOiBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudEJhc2UsXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjb21wb3NpdGUgY29tcG9uZW50IGNsYXNzIGdpdmVuIGEgY2xhc3Mgc3BlY2lmaWNhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHNwZWMgQ2xhc3Mgc3BlY2lmaWNhdGlvbiAod2hpY2ggbXVzdCBkZWZpbmUgYHJlbmRlcmApLlxuICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gQ29tcG9uZW50IGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICAgKiBAcHVibGljXG4gICAqL1xuICBjcmVhdGVDbGFzczogZnVuY3Rpb24oc3BlYykge1xuICAgIHZhciBDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKHByb3BzLCBvd25lcikge1xuICAgICAgdGhpcy5jb25zdHJ1Y3QocHJvcHMsIG93bmVyKTtcbiAgICB9O1xuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IG5ldyBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudEJhc2UoKTtcbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvcjtcblxuICAgIGluamVjdGVkTWl4aW5zLmZvckVhY2goXG4gICAgICBtaXhTcGVjSW50b0NvbXBvbmVudC5iaW5kKG51bGwsIENvbnN0cnVjdG9yKVxuICAgICk7XG5cbiAgICBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3BlYyk7XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSBkZWZhdWx0UHJvcHMgcHJvcGVydHkgYWZ0ZXIgYWxsIG1peGlucyBoYXZlIGJlZW4gbWVyZ2VkXG4gICAgaWYgKENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcykge1xuICAgICAgQ29uc3RydWN0b3IuZGVmYXVsdFByb3BzID0gQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKCk7XG4gICAgfVxuXG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5yZW5kZXIsXG4gICAgICAnY3JlYXRlQ2xhc3MoLi4uKTogQ2xhc3Mgc3BlY2lmaWNhdGlvbiBtdXN0IGltcGxlbWVudCBhIGByZW5kZXJgIG1ldGhvZC4nXG4gICAgKSA6IGludmFyaWFudChDb25zdHJ1Y3Rvci5wcm90b3R5cGUucmVuZGVyKSk7XG5cbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICBpZiAoQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbXBvbmVudFNob3VsZFVwZGF0ZSkge1xuICAgICAgICBtb25pdG9yQ29kZVVzZShcbiAgICAgICAgICAncmVhY3RfY29tcG9uZW50X3Nob3VsZF91cGRhdGVfd2FybmluZycsXG4gICAgICAgICAgeyBjb21wb25lbnQ6IHNwZWMuZGlzcGxheU5hbWUgfVxuICAgICAgICApO1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgKHNwZWMuZGlzcGxheU5hbWUgfHwgJ0EgY29tcG9uZW50JykgKyAnIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArXG4gICAgICAgICAgJ2NvbXBvbmVudFNob3VsZFVwZGF0ZSgpLiBEaWQgeW91IG1lYW4gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk/ICcgK1xuICAgICAgICAgICdUaGUgbmFtZSBpcyBwaHJhc2VkIGFzIGEgcXVlc3Rpb24gYmVjYXVzZSB0aGUgZnVuY3Rpb24gaXMgJyArXG4gICAgICAgICAgJ2V4cGVjdGVkIHRvIHJldHVybiBhIHZhbHVlLidcbiAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVkdWNlIHRpbWUgc3BlbnQgZG9pbmcgbG9va3VwcyBieSBzZXR0aW5nIHRoZXNlIG9uIHRoZSBwcm90b3R5cGUuXG4gICAgZm9yICh2YXIgbWV0aG9kTmFtZSBpbiBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudEludGVyZmFjZSkge1xuICAgICAgaWYgKCFDb25zdHJ1Y3Rvci5wcm90b3R5cGVbbWV0aG9kTmFtZV0pIHtcbiAgICAgICAgQ29uc3RydWN0b3IucHJvdG90eXBlW21ldGhvZE5hbWVdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVzY3JpcHRvckZhY3RvcnkgPSBSZWFjdERlc2NyaXB0b3IuY3JlYXRlRmFjdG9yeShDb25zdHJ1Y3Rvcik7XG5cbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICByZXR1cm4gUmVhY3REZXNjcmlwdG9yVmFsaWRhdG9yLmNyZWF0ZUZhY3RvcnkoXG4gICAgICAgIGRlc2NyaXB0b3JGYWN0b3J5LFxuICAgICAgICBDb25zdHJ1Y3Rvci5wcm9wVHlwZXMsXG4gICAgICAgIENvbnN0cnVjdG9yLmNvbnRleHRUeXBlc1xuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVzY3JpcHRvckZhY3Rvcnk7XG4gIH0sXG5cbiAgaW5qZWN0aW9uOiB7XG4gICAgaW5qZWN0TWl4aW46IGZ1bmN0aW9uKG1peGluKSB7XG4gICAgICBpbmplY3RlZE1peGlucy5wdXNoKG1peGluKTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDb21wb3NpdGVDb21wb25lbnQ7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENvbnRleHRcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIG1lcmdlID0gcmVxdWlyZShcIi4vbWVyZ2VcIik7XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgY29udGV4dC5cbiAqXG4gKiBUaGUgY29udGV4dCBpcyBhdXRvbWF0aWNhbGx5IHBhc3NlZCBkb3duIHRoZSBjb21wb25lbnQgb3duZXJzaGlwIGhpZXJhcmNoeVxuICogYW5kIGlzIGFjY2Vzc2libGUgdmlhIGB0aGlzLmNvbnRleHRgIG9uIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50cy5cbiAqL1xudmFyIFJlYWN0Q29udGV4dCA9IHtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqL1xuICBjdXJyZW50OiB7fSxcblxuICAvKipcbiAgICogVGVtcG9yYXJpbHkgZXh0ZW5kcyB0aGUgY3VycmVudCBjb250ZXh0IHdoaWxlIGV4ZWN1dGluZyBzY29wZWRDYWxsYmFjay5cbiAgICpcbiAgICogQSB0eXBpY2FsIHVzZSBjYXNlIG1pZ2h0IGxvb2sgbGlrZVxuICAgKlxuICAgKiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICogICAgdmFyIGNoaWxkcmVuID0gUmVhY3RDb250ZXh0LndpdGhDb250ZXh0KHtmb286ICdmb28nfSAoKSA9PiAoXG4gICAqXG4gICAqICAgICkpO1xuICAgKiAgICByZXR1cm4gPGRpdj57Y2hpbGRyZW59PC9kaXY+O1xuICAgKiAgfVxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV3Q29udGV4dCBOZXcgY29udGV4dCB0byBtZXJnZSBpbnRvIHRoZSBleGlzdGluZyBjb250ZXh0XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IHNjb3BlZENhbGxiYWNrIENhbGxiYWNrIHRvIHJ1biB3aXRoIHRoZSBuZXcgY29udGV4dFxuICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudHxhcnJheTxSZWFjdENvbXBvbmVudD59XG4gICAqL1xuICB3aXRoQ29udGV4dDogZnVuY3Rpb24obmV3Q29udGV4dCwgc2NvcGVkQ2FsbGJhY2spIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIHZhciBwcmV2aW91c0NvbnRleHQgPSBSZWFjdENvbnRleHQuY3VycmVudDtcbiAgICBSZWFjdENvbnRleHQuY3VycmVudCA9IG1lcmdlKHByZXZpb3VzQ29udGV4dCwgbmV3Q29udGV4dCk7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IHNjb3BlZENhbGxiYWNrKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIFJlYWN0Q29udGV4dC5jdXJyZW50ID0gcHJldmlvdXNDb250ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDb250ZXh0O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q3VycmVudE93bmVyXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgb3duZXIuXG4gKlxuICogVGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIGNvbXBvbmVudCB3aG8gc2hvdWxkIG93biBhbnkgY29tcG9uZW50cyB0aGF0IGFyZVxuICogY3VycmVudGx5IGJlaW5nIGNvbnN0cnVjdGVkLlxuICpcbiAqIFRoZSBkZXB0aCBpbmRpY2F0ZSBob3cgbWFueSBjb21wb3NpdGUgY29tcG9uZW50cyBhcmUgYWJvdmUgdGhpcyByZW5kZXIgbGV2ZWwuXG4gKi9cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHtcblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEB0eXBlIHtSZWFjdENvbXBvbmVudH1cbiAgICovXG4gIGN1cnJlbnQ6IG51bGxcblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEN1cnJlbnRPd25lcjtcbiIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01cbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBSZWFjdERlc2NyaXB0b3IgPSByZXF1aXJlKFwiLi9SZWFjdERlc2NyaXB0b3JcIik7XG52YXIgUmVhY3REZXNjcmlwdG9yVmFsaWRhdG9yID0gcmVxdWlyZShcIi4vUmVhY3REZXNjcmlwdG9yVmFsaWRhdG9yXCIpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50ID0gcmVxdWlyZShcIi4vUmVhY3RET01Db21wb25lbnRcIik7XG5cbnZhciBtZXJnZUludG8gPSByZXF1aXJlKFwiLi9tZXJnZUludG9cIik7XG52YXIgbWFwT2JqZWN0ID0gcmVxdWlyZShcIi4vbWFwT2JqZWN0XCIpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgUmVhY3QgY2xhc3MgdGhhdCBpcyBpZGVtcG90ZW50IGFuZCBjYXBhYmxlIG9mIGNvbnRhaW5pbmcgb3RoZXJcbiAqIFJlYWN0IGNvbXBvbmVudHMuIEl0IGFjY2VwdHMgZXZlbnQgbGlzdGVuZXJzIGFuZCBET00gcHJvcGVydGllcyB0aGF0IGFyZVxuICogdmFsaWQgYWNjb3JkaW5nIHRvIGBET01Qcm9wZXJ0eWAuXG4gKlxuICogIC0gRXZlbnQgbGlzdGVuZXJzOiBgb25DbGlja2AsIGBvbk1vdXNlRG93bmAsIGV0Yy5cbiAqICAtIERPTSBwcm9wZXJ0aWVzOiBgY2xhc3NOYW1lYCwgYG5hbWVgLCBgdGl0bGVgLCBldGMuXG4gKlxuICogVGhlIGBzdHlsZWAgcHJvcGVydHkgZnVuY3Rpb25zIGRpZmZlcmVudGx5IGZyb20gdGhlIERPTSBBUEkuIEl0IGFjY2VwdHMgYW5cbiAqIG9iamVjdCBtYXBwaW5nIG9mIHN0eWxlIHByb3BlcnRpZXMgdG8gdmFsdWVzLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb21pdENsb3NlIFRydWUgaWYgdGhlIGNsb3NlIHRhZyBzaG91bGQgYmUgb21pdHRlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGFnIG5hbWUgKGUuZy4gYGRpdmApLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRE9NQ29tcG9uZW50Q2xhc3Mob21pdENsb3NlLCB0YWcpIHtcbiAgdmFyIENvbnN0cnVjdG9yID0gZnVuY3Rpb24oZGVzY3JpcHRvcikge1xuICAgIHRoaXMuY29uc3RydWN0KGRlc2NyaXB0b3IpO1xuICB9O1xuICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBuZXcgUmVhY3RET01Db21wb25lbnQodGFnLCBvbWl0Q2xvc2UpO1xuICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvcjtcbiAgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgPSB0YWc7XG5cbiAgdmFyIENvbnZlbmllbmNlQ29uc3RydWN0b3IgPSBSZWFjdERlc2NyaXB0b3IuY3JlYXRlRmFjdG9yeShDb25zdHJ1Y3Rvcik7XG5cbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgIHJldHVybiBSZWFjdERlc2NyaXB0b3JWYWxpZGF0b3IuY3JlYXRlRmFjdG9yeShcbiAgICAgIENvbnZlbmllbmNlQ29uc3RydWN0b3JcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIENvbnZlbmllbmNlQ29uc3RydWN0b3I7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcHBpbmcgZnJvbSBzdXBwb3J0ZWQgSFRNTCB0YWdzIHRvIGBSZWFjdERPTUNvbXBvbmVudGAgY2xhc3Nlcy5cbiAqIFRoaXMgaXMgYWxzbyBhY2Nlc3NpYmxlIHZpYSBgUmVhY3QuRE9NYC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbnZhciBSZWFjdERPTSA9IG1hcE9iamVjdCh7XG4gIGE6IGZhbHNlLFxuICBhYmJyOiBmYWxzZSxcbiAgYWRkcmVzczogZmFsc2UsXG4gIGFyZWE6IHRydWUsXG4gIGFydGljbGU6IGZhbHNlLFxuICBhc2lkZTogZmFsc2UsXG4gIGF1ZGlvOiBmYWxzZSxcbiAgYjogZmFsc2UsXG4gIGJhc2U6IHRydWUsXG4gIGJkaTogZmFsc2UsXG4gIGJkbzogZmFsc2UsXG4gIGJpZzogZmFsc2UsXG4gIGJsb2NrcXVvdGU6IGZhbHNlLFxuICBib2R5OiBmYWxzZSxcbiAgYnI6IHRydWUsXG4gIGJ1dHRvbjogZmFsc2UsXG4gIGNhbnZhczogZmFsc2UsXG4gIGNhcHRpb246IGZhbHNlLFxuICBjaXRlOiBmYWxzZSxcbiAgY29kZTogZmFsc2UsXG4gIGNvbDogdHJ1ZSxcbiAgY29sZ3JvdXA6IGZhbHNlLFxuICBkYXRhOiBmYWxzZSxcbiAgZGF0YWxpc3Q6IGZhbHNlLFxuICBkZDogZmFsc2UsXG4gIGRlbDogZmFsc2UsXG4gIGRldGFpbHM6IGZhbHNlLFxuICBkZm46IGZhbHNlLFxuICBkaXY6IGZhbHNlLFxuICBkbDogZmFsc2UsXG4gIGR0OiBmYWxzZSxcbiAgZW06IGZhbHNlLFxuICBlbWJlZDogdHJ1ZSxcbiAgZmllbGRzZXQ6IGZhbHNlLFxuICBmaWdjYXB0aW9uOiBmYWxzZSxcbiAgZmlndXJlOiBmYWxzZSxcbiAgZm9vdGVyOiBmYWxzZSxcbiAgZm9ybTogZmFsc2UsIC8vIE5PVEU6IEluamVjdGVkLCBzZWUgYFJlYWN0RE9NRm9ybWAuXG4gIGgxOiBmYWxzZSxcbiAgaDI6IGZhbHNlLFxuICBoMzogZmFsc2UsXG4gIGg0OiBmYWxzZSxcbiAgaDU6IGZhbHNlLFxuICBoNjogZmFsc2UsXG4gIGhlYWQ6IGZhbHNlLFxuICBoZWFkZXI6IGZhbHNlLFxuICBocjogdHJ1ZSxcbiAgaHRtbDogZmFsc2UsXG4gIGk6IGZhbHNlLFxuICBpZnJhbWU6IGZhbHNlLFxuICBpbWc6IHRydWUsXG4gIGlucHV0OiB0cnVlLFxuICBpbnM6IGZhbHNlLFxuICBrYmQ6IGZhbHNlLFxuICBrZXlnZW46IHRydWUsXG4gIGxhYmVsOiBmYWxzZSxcbiAgbGVnZW5kOiBmYWxzZSxcbiAgbGk6IGZhbHNlLFxuICBsaW5rOiB0cnVlLFxuICBtYWluOiBmYWxzZSxcbiAgbWFwOiBmYWxzZSxcbiAgbWFyazogZmFsc2UsXG4gIG1lbnU6IGZhbHNlLFxuICBtZW51aXRlbTogZmFsc2UsIC8vIE5PVEU6IENsb3NlIHRhZyBzaG91bGQgYmUgb21pdHRlZCwgYnV0IGNhdXNlcyBwcm9ibGVtcy5cbiAgbWV0YTogdHJ1ZSxcbiAgbWV0ZXI6IGZhbHNlLFxuICBuYXY6IGZhbHNlLFxuICBub3NjcmlwdDogZmFsc2UsXG4gIG9iamVjdDogZmFsc2UsXG4gIG9sOiBmYWxzZSxcbiAgb3B0Z3JvdXA6IGZhbHNlLFxuICBvcHRpb246IGZhbHNlLFxuICBvdXRwdXQ6IGZhbHNlLFxuICBwOiBmYWxzZSxcbiAgcGFyYW06IHRydWUsXG4gIHByZTogZmFsc2UsXG4gIHByb2dyZXNzOiBmYWxzZSxcbiAgcTogZmFsc2UsXG4gIHJwOiBmYWxzZSxcbiAgcnQ6IGZhbHNlLFxuICBydWJ5OiBmYWxzZSxcbiAgczogZmFsc2UsXG4gIHNhbXA6IGZhbHNlLFxuICBzY3JpcHQ6IGZhbHNlLFxuICBzZWN0aW9uOiBmYWxzZSxcbiAgc2VsZWN0OiBmYWxzZSxcbiAgc21hbGw6IGZhbHNlLFxuICBzb3VyY2U6IHRydWUsXG4gIHNwYW46IGZhbHNlLFxuICBzdHJvbmc6IGZhbHNlLFxuICBzdHlsZTogZmFsc2UsXG4gIHN1YjogZmFsc2UsXG4gIHN1bW1hcnk6IGZhbHNlLFxuICBzdXA6IGZhbHNlLFxuICB0YWJsZTogZmFsc2UsXG4gIHRib2R5OiBmYWxzZSxcbiAgdGQ6IGZhbHNlLFxuICB0ZXh0YXJlYTogZmFsc2UsIC8vIE5PVEU6IEluamVjdGVkLCBzZWUgYFJlYWN0RE9NVGV4dGFyZWFgLlxuICB0Zm9vdDogZmFsc2UsXG4gIHRoOiBmYWxzZSxcbiAgdGhlYWQ6IGZhbHNlLFxuICB0aW1lOiBmYWxzZSxcbiAgdGl0bGU6IGZhbHNlLFxuICB0cjogZmFsc2UsXG4gIHRyYWNrOiB0cnVlLFxuICB1OiBmYWxzZSxcbiAgdWw6IGZhbHNlLFxuICAndmFyJzogZmFsc2UsXG4gIHZpZGVvOiBmYWxzZSxcbiAgd2JyOiB0cnVlLFxuXG4gIC8vIFNWR1xuICBjaXJjbGU6IGZhbHNlLFxuICBkZWZzOiBmYWxzZSxcbiAgZWxsaXBzZTogZmFsc2UsXG4gIGc6IGZhbHNlLFxuICBsaW5lOiBmYWxzZSxcbiAgbGluZWFyR3JhZGllbnQ6IGZhbHNlLFxuICBtYXNrOiBmYWxzZSxcbiAgcGF0aDogZmFsc2UsXG4gIHBhdHRlcm46IGZhbHNlLFxuICBwb2x5Z29uOiBmYWxzZSxcbiAgcG9seWxpbmU6IGZhbHNlLFxuICByYWRpYWxHcmFkaWVudDogZmFsc2UsXG4gIHJlY3Q6IGZhbHNlLFxuICBzdG9wOiBmYWxzZSxcbiAgc3ZnOiBmYWxzZSxcbiAgdGV4dDogZmFsc2UsXG4gIHRzcGFuOiBmYWxzZVxufSwgY3JlYXRlRE9NQ29tcG9uZW50Q2xhc3MpO1xuXG52YXIgaW5qZWN0aW9uID0ge1xuICBpbmplY3RDb21wb25lbnRDbGFzc2VzOiBmdW5jdGlvbihjb21wb25lbnRDbGFzc2VzKSB7XG4gICAgbWVyZ2VJbnRvKFJlYWN0RE9NLCBjb21wb25lbnRDbGFzc2VzKTtcbiAgfVxufTtcblxuUmVhY3RET00uaW5qZWN0aW9uID0gaW5qZWN0aW9uO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01CdXR0b25cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIEF1dG9Gb2N1c01peGluID0gcmVxdWlyZShcIi4vQXV0b0ZvY3VzTWl4aW5cIik7XG52YXIgUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW4gPSByZXF1aXJlKFwiLi9SZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpblwiKTtcbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCA9IHJlcXVpcmUoXCIuL1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50XCIpO1xudmFyIFJlYWN0RE9NID0gcmVxdWlyZShcIi4vUmVhY3RET01cIik7XG5cbnZhciBrZXlNaXJyb3IgPSByZXF1aXJlKFwiLi9rZXlNaXJyb3JcIik7XG5cbi8vIFN0b3JlIGEgcmVmZXJlbmNlIHRvIHRoZSA8YnV0dG9uPiBgUmVhY3RET01Db21wb25lbnRgLlxudmFyIGJ1dHRvbiA9IFJlYWN0RE9NLmJ1dHRvbjtcblxudmFyIG1vdXNlTGlzdGVuZXJOYW1lcyA9IGtleU1pcnJvcih7XG4gIG9uQ2xpY2s6IHRydWUsXG4gIG9uRG91YmxlQ2xpY2s6IHRydWUsXG4gIG9uTW91c2VEb3duOiB0cnVlLFxuICBvbk1vdXNlTW92ZTogdHJ1ZSxcbiAgb25Nb3VzZVVwOiB0cnVlLFxuICBvbkNsaWNrQ2FwdHVyZTogdHJ1ZSxcbiAgb25Eb3VibGVDbGlja0NhcHR1cmU6IHRydWUsXG4gIG9uTW91c2VEb3duQ2FwdHVyZTogdHJ1ZSxcbiAgb25Nb3VzZU1vdmVDYXB0dXJlOiB0cnVlLFxuICBvbk1vdXNlVXBDYXB0dXJlOiB0cnVlXG59KTtcblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgPGJ1dHRvbj4gbmF0aXZlIGNvbXBvbmVudCB0aGF0IGRvZXMgbm90IHJlY2VpdmUgbW91c2UgZXZlbnRzXG4gKiB3aGVuIGBkaXNhYmxlZGAgaXMgc2V0LlxuICovXG52YXIgUmVhY3RET01CdXR0b24gPSBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnUmVhY3RET01CdXR0b24nLFxuXG4gIG1peGluczogW0F1dG9Gb2N1c01peGluLCBSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbl0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgcHJvcHMgPSB7fTtcblxuICAgIC8vIENvcHkgdGhlIHByb3BzOyBleGNlcHQgdGhlIG1vdXNlIGxpc3RlbmVycyBpZiB3ZSdyZSBkaXNhYmxlZFxuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLnByb3BzKSB7XG4gICAgICBpZiAodGhpcy5wcm9wcy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmXG4gICAgICAgICAgKCF0aGlzLnByb3BzLmRpc2FibGVkIHx8ICFtb3VzZUxpc3RlbmVyTmFtZXNba2V5XSkpIHtcbiAgICAgICAgcHJvcHNba2V5XSA9IHRoaXMucHJvcHNba2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYnV0dG9uKHByb3BzLCB0aGlzLnByb3BzLmNoaWxkcmVuKTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUJ1dHRvbjtcbiIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01Db21wb25lbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBDU1NQcm9wZXJ0eU9wZXJhdGlvbnMgPSByZXF1aXJlKFwiLi9DU1NQcm9wZXJ0eU9wZXJhdGlvbnNcIik7XG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKFwiLi9ET01Qcm9wZXJ0eVwiKTtcbnZhciBET01Qcm9wZXJ0eU9wZXJhdGlvbnMgPSByZXF1aXJlKFwiLi9ET01Qcm9wZXJ0eU9wZXJhdGlvbnNcIik7XG52YXIgUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW4gPSByZXF1aXJlKFwiLi9SZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpblwiKTtcbnZhciBSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoXCIuL1JlYWN0Q29tcG9uZW50XCIpO1xudmFyIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCIuL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlclwiKTtcbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZShcIi4vUmVhY3RNb3VudFwiKTtcbnZhciBSZWFjdE11bHRpQ2hpbGQgPSByZXF1aXJlKFwiLi9SZWFjdE11bHRpQ2hpbGRcIik7XG52YXIgUmVhY3RQZXJmID0gcmVxdWlyZShcIi4vUmVhY3RQZXJmXCIpO1xuXG52YXIgZXNjYXBlVGV4dEZvckJyb3dzZXIgPSByZXF1aXJlKFwiLi9lc2NhcGVUZXh0Rm9yQnJvd3NlclwiKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG52YXIga2V5T2YgPSByZXF1aXJlKFwiLi9rZXlPZlwiKTtcbnZhciBtZXJnZSA9IHJlcXVpcmUoXCIuL21lcmdlXCIpO1xudmFyIG1peEludG8gPSByZXF1aXJlKFwiLi9taXhJbnRvXCIpO1xuXG52YXIgZGVsZXRlTGlzdGVuZXIgPSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuZGVsZXRlTGlzdGVuZXI7XG52YXIgbGlzdGVuVG8gPSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIubGlzdGVuVG87XG52YXIgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMgPSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXM7XG5cbi8vIEZvciBxdWlja2x5IG1hdGNoaW5nIGNoaWxkcmVuIHR5cGUsIHRvIHRlc3QgaWYgY2FuIGJlIHRyZWF0ZWQgYXMgY29udGVudC5cbnZhciBDT05URU5UX1RZUEVTID0geydzdHJpbmcnOiB0cnVlLCAnbnVtYmVyJzogdHJ1ZX07XG5cbnZhciBTVFlMRSA9IGtleU9mKHtzdHlsZTogbnVsbH0pO1xuXG52YXIgRUxFTUVOVF9OT0RFX1RZUEUgPSAxO1xuXG4vKipcbiAqIEBwYXJhbSB7P29iamVjdH0gcHJvcHNcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0VmFsaWRQcm9wcyhwcm9wcykge1xuICBpZiAoIXByb3BzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIE5vdGUgdGhlIHVzZSBvZiBgPT1gIHdoaWNoIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWQuXG4gIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgcHJvcHMuY2hpbGRyZW4gPT0gbnVsbCB8fCBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PSBudWxsLFxuICAgICdDYW4gb25seSBzZXQgb25lIG9mIGBjaGlsZHJlbmAgb3IgYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nXG4gICkgOiBpbnZhcmlhbnQocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCB8fCBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PSBudWxsKSk7XG4gIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgcHJvcHMuc3R5bGUgPT0gbnVsbCB8fCB0eXBlb2YgcHJvcHMuc3R5bGUgPT09ICdvYmplY3QnLFxuICAgICdUaGUgYHN0eWxlYCBwcm9wIGV4cGVjdHMgYSBtYXBwaW5nIGZyb20gc3R5bGUgcHJvcGVydGllcyB0byB2YWx1ZXMsICcgK1xuICAgICdub3QgYSBzdHJpbmcuJ1xuICApIDogaW52YXJpYW50KHByb3BzLnN0eWxlID09IG51bGwgfHwgdHlwZW9mIHByb3BzLnN0eWxlID09PSAnb2JqZWN0JykpO1xufVxuXG5mdW5jdGlvbiBwdXRMaXN0ZW5lcihpZCwgcmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIsIHRyYW5zYWN0aW9uKSB7XG4gIHZhciBjb250YWluZXIgPSBSZWFjdE1vdW50LmZpbmRSZWFjdENvbnRhaW5lckZvcklEKGlkKTtcbiAgaWYgKGNvbnRhaW5lcikge1xuICAgIHZhciBkb2MgPSBjb250YWluZXIubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERV9UWVBFID9cbiAgICAgIGNvbnRhaW5lci5vd25lckRvY3VtZW50IDpcbiAgICAgIGNvbnRhaW5lcjtcbiAgICBsaXN0ZW5UbyhyZWdpc3RyYXRpb25OYW1lLCBkb2MpO1xuICB9XG4gIHRyYW5zYWN0aW9uLmdldFB1dExpc3RlbmVyUXVldWUoKS5lbnF1ZXVlUHV0TGlzdGVuZXIoXG4gICAgaWQsXG4gICAgcmVnaXN0cmF0aW9uTmFtZSxcbiAgICBsaXN0ZW5lclxuICApO1xufVxuXG5cbi8qKlxuICogQGNvbnN0cnVjdG9yIFJlYWN0RE9NQ29tcG9uZW50XG4gKiBAZXh0ZW5kcyBSZWFjdENvbXBvbmVudFxuICogQGV4dGVuZHMgUmVhY3RNdWx0aUNoaWxkXG4gKi9cbmZ1bmN0aW9uIFJlYWN0RE9NQ29tcG9uZW50KHRhZywgb21pdENsb3NlKSB7XG4gIHRoaXMuX3RhZ09wZW4gPSAnPCcgKyB0YWc7XG4gIHRoaXMuX3RhZ0Nsb3NlID0gb21pdENsb3NlID8gJycgOiAnPC8nICsgdGFnICsgJz4nO1xuICB0aGlzLnRhZ05hbWUgPSB0YWcudG9VcHBlckNhc2UoKTtcbn1cblxuUmVhY3RET01Db21wb25lbnQuTWl4aW4gPSB7XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyByb290IHRhZyBtYXJrdXAgdGhlbiByZWN1cnNlcy4gVGhpcyBtZXRob2QgaGFzIHNpZGUgZWZmZWN0cyBhbmRcbiAgICogaXMgbm90IGlkZW1wb3RlbnQuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcm9vdElEIFRoZSByb290IERPTSBJRCBmb3IgdGhpcyBub2RlLlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1vdW50RGVwdGggbnVtYmVyIG9mIGNvbXBvbmVudHMgaW4gdGhlIG93bmVyIGhpZXJhcmNoeVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBjb21wdXRlZCBtYXJrdXAuXG4gICAqL1xuICBtb3VudENvbXBvbmVudDogUmVhY3RQZXJmLm1lYXN1cmUoXG4gICAgJ1JlYWN0RE9NQ29tcG9uZW50JyxcbiAgICAnbW91bnRDb21wb25lbnQnLFxuICAgIGZ1bmN0aW9uKHJvb3RJRCwgdHJhbnNhY3Rpb24sIG1vdW50RGVwdGgpIHtcbiAgICAgIFJlYWN0Q29tcG9uZW50Lk1peGluLm1vdW50Q29tcG9uZW50LmNhbGwoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHJvb3RJRCxcbiAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICAgIG1vdW50RGVwdGhcbiAgICAgICk7XG4gICAgICBhc3NlcnRWYWxpZFByb3BzKHRoaXMucHJvcHMpO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgdGhpcy5fY3JlYXRlT3BlblRhZ01hcmt1cEFuZFB1dExpc3RlbmVycyh0cmFuc2FjdGlvbikgK1xuICAgICAgICB0aGlzLl9jcmVhdGVDb250ZW50TWFya3VwKHRyYW5zYWN0aW9uKSArXG4gICAgICAgIHRoaXMuX3RhZ0Nsb3NlXG4gICAgICApO1xuICAgIH1cbiAgKSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIHRoZSBvcGVuIHRhZyBhbmQgYWxsIGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGhhcyBzaWRlIGVmZmVjdHMgYmVjYXVzZSBldmVudHMgZ2V0IHJlZ2lzdGVyZWQuXG4gICAqXG4gICAqIEl0ZXJhdGluZyBvdmVyIG9iamVjdCBwcm9wZXJ0aWVzIGlzIGZhc3RlciB0aGFuIGl0ZXJhdGluZyBvdmVyIGFycmF5cy5cbiAgICogQHNlZSBodHRwOi8vanNwZXJmLmNvbS9vYmotdnMtYXJyLWl0ZXJhdGlvblxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHJldHVybiB7c3RyaW5nfSBNYXJrdXAgb2Ygb3BlbmluZyB0YWcuXG4gICAqL1xuICBfY3JlYXRlT3BlblRhZ01hcmt1cEFuZFB1dExpc3RlbmVyczogZnVuY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciByZXQgPSB0aGlzLl90YWdPcGVuO1xuXG4gICAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgICAgaWYgKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICBwdXRMaXN0ZW5lcih0aGlzLl9yb290Tm9kZUlELCBwcm9wS2V5LCBwcm9wVmFsdWUsIHRyYW5zYWN0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgICAgIGlmIChwcm9wVmFsdWUpIHtcbiAgICAgICAgICAgIHByb3BWYWx1ZSA9IHByb3BzLnN0eWxlID0gbWVyZ2UocHJvcHMuc3R5bGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwcm9wVmFsdWUgPSBDU1NQcm9wZXJ0eU9wZXJhdGlvbnMuY3JlYXRlTWFya3VwRm9yU3R5bGVzKHByb3BWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hcmt1cCA9XG4gICAgICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvclByb3BlcnR5KHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgIGlmIChtYXJrdXApIHtcbiAgICAgICAgICByZXQgKz0gJyAnICsgbWFya3VwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRm9yIHN0YXRpYyBwYWdlcywgbm8gbmVlZCB0byBwdXQgUmVhY3QgSUQgYW5kIGNoZWNrc3VtLiBTYXZlcyBsb3RzIG9mXG4gICAgLy8gYnl0ZXMuXG4gICAgaWYgKHRyYW5zYWN0aW9uLnJlbmRlclRvU3RhdGljTWFya3VwKSB7XG4gICAgICByZXR1cm4gcmV0ICsgJz4nO1xuICAgIH1cblxuICAgIHZhciBtYXJrdXBGb3JJRCA9IERPTVByb3BlcnR5T3BlcmF0aW9ucy5jcmVhdGVNYXJrdXBGb3JJRCh0aGlzLl9yb290Tm9kZUlEKTtcbiAgICByZXR1cm4gcmV0ICsgJyAnICsgbWFya3VwRm9ySUQgKyAnPic7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciB0aGUgY29udGVudCBiZXR3ZWVuIHRoZSB0YWdzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHJldHVybiB7c3RyaW5nfSBDb250ZW50IG1hcmt1cC5cbiAgICovXG4gIF9jcmVhdGVDb250ZW50TWFya3VwOiBmdW5jdGlvbih0cmFuc2FjdGlvbikge1xuICAgIC8vIEludGVudGlvbmFsIHVzZSBvZiAhPSB0byBhdm9pZCBjYXRjaGluZyB6ZXJvL2ZhbHNlLlxuICAgIHZhciBpbm5lckhUTUwgPSB0aGlzLnByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MO1xuICAgIGlmIChpbm5lckhUTUwgIT0gbnVsbCkge1xuICAgICAgaWYgKGlubmVySFRNTC5fX2h0bWwgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gaW5uZXJIVE1MLl9faHRtbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNvbnRlbnRUb1VzZSA9XG4gICAgICAgIENPTlRFTlRfVFlQRVNbdHlwZW9mIHRoaXMucHJvcHMuY2hpbGRyZW5dID8gdGhpcy5wcm9wcy5jaGlsZHJlbiA6IG51bGw7XG4gICAgICB2YXIgY2hpbGRyZW5Ub1VzZSA9IGNvbnRlbnRUb1VzZSAhPSBudWxsID8gbnVsbCA6IHRoaXMucHJvcHMuY2hpbGRyZW47XG4gICAgICBpZiAoY29udGVudFRvVXNlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGVzY2FwZVRleHRGb3JCcm93c2VyKGNvbnRlbnRUb1VzZSk7XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkcmVuVG9Vc2UgIT0gbnVsbCkge1xuICAgICAgICB2YXIgbW91bnRJbWFnZXMgPSB0aGlzLm1vdW50Q2hpbGRyZW4oXG4gICAgICAgICAgY2hpbGRyZW5Ub1VzZSxcbiAgICAgICAgICB0cmFuc2FjdGlvblxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gbW91bnRJbWFnZXMuam9pbignJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfSxcblxuICByZWNlaXZlQ29tcG9uZW50OiBmdW5jdGlvbihuZXh0RGVzY3JpcHRvciwgdHJhbnNhY3Rpb24pIHtcbiAgICBpZiAobmV4dERlc2NyaXB0b3IgPT09IHRoaXMuX2Rlc2NyaXB0b3IgJiZcbiAgICAgICAgbmV4dERlc2NyaXB0b3IuX293bmVyICE9IG51bGwpIHtcbiAgICAgIC8vIFNpbmNlIGRlc2NyaXB0b3JzIGFyZSBpbW11dGFibGUgYWZ0ZXIgdGhlIG93bmVyIGlzIHJlbmRlcmVkLFxuICAgICAgLy8gd2UgY2FuIGRvIGEgY2hlYXAgaWRlbnRpdHkgY29tcGFyZSBoZXJlIHRvIGRldGVybWluZSBpZiB0aGlzIGlzIGFcbiAgICAgIC8vIHN1cGVyZmx1b3VzIHJlY29uY2lsZS4gSXQncyBwb3NzaWJsZSBmb3Igc3RhdGUgdG8gYmUgbXV0YWJsZSBidXQgc3VjaFxuICAgICAgLy8gY2hhbmdlIHNob3VsZCB0cmlnZ2VyIGFuIHVwZGF0ZSBvZiB0aGUgb3duZXIgd2hpY2ggd291bGQgcmVjcmVhdGVcbiAgICAgIC8vIHRoZSBkZXNjcmlwdG9yLiBXZSBleHBsaWNpdGx5IGNoZWNrIGZvciB0aGUgZXhpc3RlbmNlIG9mIGFuIG93bmVyIHNpbmNlXG4gICAgICAvLyBpdCdzIHBvc3NpYmxlIGZvciBhIGRlc2NyaXB0b3IgY3JlYXRlZCBvdXRzaWRlIGEgY29tcG9zaXRlIHRvIGJlXG4gICAgICAvLyBkZWVwbHkgbXV0YXRlZCBhbmQgcmV1c2VkLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIFJlYWN0Q29tcG9uZW50Lk1peGluLnJlY2VpdmVDb21wb25lbnQuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICBuZXh0RGVzY3JpcHRvcixcbiAgICAgIHRyYW5zYWN0aW9uXG4gICAgKTtcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlcyBhIG5hdGl2ZSBET00gY29tcG9uZW50IGFmdGVyIGl0IGhhcyBhbHJlYWR5IGJlZW4gYWxsb2NhdGVkIGFuZFxuICAgKiBhdHRhY2hlZCB0byB0aGUgRE9NLiBSZWNvbmNpbGVzIHRoZSByb290IERPTSBub2RlLCB0aGVuIHJlY3Vyc2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7UmVhY3REZXNjcmlwdG9yfSBwcmV2RGVzY3JpcHRvclxuICAgKiBAaW50ZXJuYWxcbiAgICogQG92ZXJyaWRhYmxlXG4gICAqL1xuICB1cGRhdGVDb21wb25lbnQ6IFJlYWN0UGVyZi5tZWFzdXJlKFxuICAgICdSZWFjdERPTUNvbXBvbmVudCcsXG4gICAgJ3VwZGF0ZUNvbXBvbmVudCcsXG4gICAgZnVuY3Rpb24odHJhbnNhY3Rpb24sIHByZXZEZXNjcmlwdG9yKSB7XG4gICAgICBhc3NlcnRWYWxpZFByb3BzKHRoaXMuX2Rlc2NyaXB0b3IucHJvcHMpO1xuICAgICAgUmVhY3RDb21wb25lbnQuTWl4aW4udXBkYXRlQ29tcG9uZW50LmNhbGwoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICBwcmV2RGVzY3JpcHRvclxuICAgICAgKTtcbiAgICAgIHRoaXMuX3VwZGF0ZURPTVByb3BlcnRpZXMocHJldkRlc2NyaXB0b3IucHJvcHMsIHRyYW5zYWN0aW9uKTtcbiAgICAgIHRoaXMuX3VwZGF0ZURPTUNoaWxkcmVuKHByZXZEZXNjcmlwdG9yLnByb3BzLCB0cmFuc2FjdGlvbik7XG4gICAgfVxuICApLFxuXG4gIC8qKlxuICAgKiBSZWNvbmNpbGVzIHRoZSBwcm9wZXJ0aWVzIGJ5IGRldGVjdGluZyBkaWZmZXJlbmNlcyBpbiBwcm9wZXJ0eSB2YWx1ZXMgYW5kXG4gICAqIHVwZGF0aW5nIHRoZSBET00gYXMgbmVjZXNzYXJ5LiBUaGlzIGZ1bmN0aW9uIGlzIHByb2JhYmx5IHRoZSBzaW5nbGUgbW9zdFxuICAgKiBjcml0aWNhbCBwYXRoIGZvciBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24uXG4gICAqXG4gICAqIFRPRE86IEJlbmNobWFyayB3aGV0aGVyIGNoZWNraW5nIGZvciBjaGFuZ2VkIHZhbHVlcyBpbiBtZW1vcnkgYWN0dWFsbHlcbiAgICogICAgICAgaW1wcm92ZXMgcGVyZm9ybWFuY2UgKGVzcGVjaWFsbHkgc3RhdGljYWxseSBwb3NpdGlvbmVkIGVsZW1lbnRzKS5cbiAgICogVE9ETzogQmVuY2htYXJrIHRoZSBlZmZlY3RzIG9mIHB1dHRpbmcgdGhpcyBhdCB0aGUgdG9wIHNpbmNlIDk5JSBvZiBwcm9wc1xuICAgKiAgICAgICBkbyBub3QgY2hhbmdlIGZvciBhIGdpdmVuIHJlY29uY2lsaWF0aW9uLlxuICAgKiBUT0RPOiBCZW5jaG1hcmsgYXJlYXMgdGhhdCBjYW4gYmUgaW1wcm92ZWQgd2l0aCBjYWNoaW5nLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge29iamVjdH0gbGFzdFByb3BzXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICovXG4gIF91cGRhdGVET01Qcm9wZXJ0aWVzOiBmdW5jdGlvbihsYXN0UHJvcHMsIHRyYW5zYWN0aW9uKSB7XG4gICAgdmFyIG5leHRQcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHByb3BLZXk7XG4gICAgdmFyIHN0eWxlTmFtZTtcbiAgICB2YXIgc3R5bGVVcGRhdGVzO1xuICAgIGZvciAocHJvcEtleSBpbiBsYXN0UHJvcHMpIHtcbiAgICAgIGlmIChuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHxcbiAgICAgICAgICFsYXN0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgICAgdmFyIGxhc3RTdHlsZSA9IGxhc3RQcm9wc1twcm9wS2V5XTtcbiAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbGFzdFN0eWxlKSB7XG4gICAgICAgICAgaWYgKGxhc3RTdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSBzdHlsZVVwZGF0ZXMgfHwge307XG4gICAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICBkZWxldGVMaXN0ZW5lcih0aGlzLl9yb290Tm9kZUlELCBwcm9wS2V5KTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgRE9NUHJvcGVydHkuaXNTdGFuZGFyZE5hbWVbcHJvcEtleV0gfHxcbiAgICAgICAgICBET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShwcm9wS2V5KSkge1xuICAgICAgICBSZWFjdENvbXBvbmVudC5CYWNrZW5kSURPcGVyYXRpb25zLmRlbGV0ZVByb3BlcnR5QnlJRChcbiAgICAgICAgICB0aGlzLl9yb290Tm9kZUlELFxuICAgICAgICAgIHByb3BLZXlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChwcm9wS2V5IGluIG5leHRQcm9wcykge1xuICAgICAgdmFyIG5leHRQcm9wID0gbmV4dFByb3BzW3Byb3BLZXldO1xuICAgICAgdmFyIGxhc3RQcm9wID0gbGFzdFByb3BzW3Byb3BLZXldO1xuICAgICAgaWYgKCFuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgbmV4dFByb3AgPT09IGxhc3RQcm9wKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICAgIGlmIChuZXh0UHJvcCkge1xuICAgICAgICAgIG5leHRQcm9wID0gbmV4dFByb3BzLnN0eWxlID0gbWVyZ2UobmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0UHJvcCkge1xuICAgICAgICAgIC8vIFVuc2V0IHN0eWxlcyBvbiBgbGFzdFByb3BgIGJ1dCBub3Qgb24gYG5leHRQcm9wYC5cbiAgICAgICAgICBmb3IgKHN0eWxlTmFtZSBpbiBsYXN0UHJvcCkge1xuICAgICAgICAgICAgaWYgKGxhc3RQcm9wLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkgJiZcbiAgICAgICAgICAgICAgICAoIW5leHRQcm9wIHx8ICFuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSkge1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSBzdHlsZVVwZGF0ZXMgfHwge307XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFVwZGF0ZSBzdHlsZXMgdGhhdCBjaGFuZ2VkIHNpbmNlIGBsYXN0UHJvcGAuXG4gICAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbmV4dFByb3ApIHtcbiAgICAgICAgICAgIGlmIChuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpICYmXG4gICAgICAgICAgICAgICAgbGFzdFByb3Bbc3R5bGVOYW1lXSAhPT0gbmV4dFByb3Bbc3R5bGVOYW1lXSkge1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSBzdHlsZVVwZGF0ZXMgfHwge307XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gbmV4dFByb3Bbc3R5bGVOYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUmVsaWVzIG9uIGB1cGRhdGVTdHlsZXNCeUlEYCBub3QgbXV0YXRpbmcgYHN0eWxlVXBkYXRlc2AuXG4gICAgICAgICAgc3R5bGVVcGRhdGVzID0gbmV4dFByb3A7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgcHV0TGlzdGVuZXIodGhpcy5fcm9vdE5vZGVJRCwgcHJvcEtleSwgbmV4dFByb3AsIHRyYW5zYWN0aW9uKTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgRE9NUHJvcGVydHkuaXNTdGFuZGFyZE5hbWVbcHJvcEtleV0gfHxcbiAgICAgICAgICBET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShwcm9wS2V5KSkge1xuICAgICAgICBSZWFjdENvbXBvbmVudC5CYWNrZW5kSURPcGVyYXRpb25zLnVwZGF0ZVByb3BlcnR5QnlJRChcbiAgICAgICAgICB0aGlzLl9yb290Tm9kZUlELFxuICAgICAgICAgIHByb3BLZXksXG4gICAgICAgICAgbmV4dFByb3BcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0eWxlVXBkYXRlcykge1xuICAgICAgUmVhY3RDb21wb25lbnQuQmFja2VuZElET3BlcmF0aW9ucy51cGRhdGVTdHlsZXNCeUlEKFxuICAgICAgICB0aGlzLl9yb290Tm9kZUlELFxuICAgICAgICBzdHlsZVVwZGF0ZXNcbiAgICAgICk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZWNvbmNpbGVzIHRoZSBjaGlsZHJlbiB3aXRoIHRoZSB2YXJpb3VzIHByb3BlcnRpZXMgdGhhdCBhZmZlY3QgdGhlXG4gICAqIGNoaWxkcmVuIGNvbnRlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBsYXN0UHJvcHNcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKi9cbiAgX3VwZGF0ZURPTUNoaWxkcmVuOiBmdW5jdGlvbihsYXN0UHJvcHMsIHRyYW5zYWN0aW9uKSB7XG4gICAgdmFyIG5leHRQcm9wcyA9IHRoaXMucHJvcHM7XG5cbiAgICB2YXIgbGFzdENvbnRlbnQgPVxuICAgICAgQ09OVEVOVF9UWVBFU1t0eXBlb2YgbGFzdFByb3BzLmNoaWxkcmVuXSA/IGxhc3RQcm9wcy5jaGlsZHJlbiA6IG51bGw7XG4gICAgdmFyIG5leHRDb250ZW50ID1cbiAgICAgIENPTlRFTlRfVFlQRVNbdHlwZW9mIG5leHRQcm9wcy5jaGlsZHJlbl0gPyBuZXh0UHJvcHMuY2hpbGRyZW4gOiBudWxsO1xuXG4gICAgdmFyIGxhc3RIdG1sID1cbiAgICAgIGxhc3RQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAmJlxuICAgICAgbGFzdFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLl9faHRtbDtcbiAgICB2YXIgbmV4dEh0bWwgPVxuICAgICAgbmV4dFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICYmXG4gICAgICBuZXh0UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwuX19odG1sO1xuXG4gICAgLy8gTm90ZSB0aGUgdXNlIG9mIGAhPWAgd2hpY2ggY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZC5cbiAgICB2YXIgbGFzdENoaWxkcmVuID0gbGFzdENvbnRlbnQgIT0gbnVsbCA/IG51bGwgOiBsYXN0UHJvcHMuY2hpbGRyZW47XG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IG5leHRDb250ZW50ICE9IG51bGwgPyBudWxsIDogbmV4dFByb3BzLmNoaWxkcmVuO1xuXG4gICAgLy8gSWYgd2UncmUgc3dpdGNoaW5nIGZyb20gY2hpbGRyZW4gdG8gY29udGVudC9odG1sIG9yIHZpY2UgdmVyc2EsIHJlbW92ZVxuICAgIC8vIHRoZSBvbGQgY29udGVudFxuICAgIHZhciBsYXN0SGFzQ29udGVudE9ySHRtbCA9IGxhc3RDb250ZW50ICE9IG51bGwgfHwgbGFzdEh0bWwgIT0gbnVsbDtcbiAgICB2YXIgbmV4dEhhc0NvbnRlbnRPckh0bWwgPSBuZXh0Q29udGVudCAhPSBudWxsIHx8IG5leHRIdG1sICE9IG51bGw7XG4gICAgaWYgKGxhc3RDaGlsZHJlbiAhPSBudWxsICYmIG5leHRDaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgICB0aGlzLnVwZGF0ZUNoaWxkcmVuKG51bGwsIHRyYW5zYWN0aW9uKTtcbiAgICB9IGVsc2UgaWYgKGxhc3RIYXNDb250ZW50T3JIdG1sICYmICFuZXh0SGFzQ29udGVudE9ySHRtbCkge1xuICAgICAgdGhpcy51cGRhdGVUZXh0Q29udGVudCgnJyk7XG4gICAgfVxuXG4gICAgaWYgKG5leHRDb250ZW50ICE9IG51bGwpIHtcbiAgICAgIGlmIChsYXN0Q29udGVudCAhPT0gbmV4dENvbnRlbnQpIHtcbiAgICAgICAgdGhpcy51cGRhdGVUZXh0Q29udGVudCgnJyArIG5leHRDb250ZW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5leHRIdG1sICE9IG51bGwpIHtcbiAgICAgIGlmIChsYXN0SHRtbCAhPT0gbmV4dEh0bWwpIHtcbiAgICAgICAgUmVhY3RDb21wb25lbnQuQmFja2VuZElET3BlcmF0aW9ucy51cGRhdGVJbm5lckhUTUxCeUlEKFxuICAgICAgICAgIHRoaXMuX3Jvb3ROb2RlSUQsXG4gICAgICAgICAgbmV4dEh0bWxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5leHRDaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICB0aGlzLnVwZGF0ZUNoaWxkcmVuKG5leHRDaGlsZHJlbiwgdHJhbnNhY3Rpb24pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGVzdHJveXMgYWxsIGV2ZW50IHJlZ2lzdHJhdGlvbnMgZm9yIHRoaXMgaW5zdGFuY2UuIERvZXMgbm90IHJlbW92ZSBmcm9tXG4gICAqIHRoZSBET00uIFRoYXQgbXVzdCBiZSBkb25lIGJ5IHRoZSBwYXJlbnQuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy51bm1vdW50Q2hpbGRyZW4oKTtcbiAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuZGVsZXRlQWxsTGlzdGVuZXJzKHRoaXMuX3Jvb3ROb2RlSUQpO1xuICAgIFJlYWN0Q29tcG9uZW50Lk1peGluLnVubW91bnRDb21wb25lbnQuY2FsbCh0aGlzKTtcbiAgfVxuXG59O1xuXG5taXhJbnRvKFJlYWN0RE9NQ29tcG9uZW50LCBSZWFjdENvbXBvbmVudC5NaXhpbik7XG5taXhJbnRvKFJlYWN0RE9NQ29tcG9uZW50LCBSZWFjdERPTUNvbXBvbmVudC5NaXhpbik7XG5taXhJbnRvKFJlYWN0RE9NQ29tcG9uZW50LCBSZWFjdE11bHRpQ2hpbGQuTWl4aW4pO1xubWl4SW50byhSZWFjdERPTUNvbXBvbmVudCwgUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW4pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NQ29tcG9uZW50O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01Gb3JtXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoXCIuL0V2ZW50Q29uc3RhbnRzXCIpO1xudmFyIExvY2FsRXZlbnRUcmFwTWl4aW4gPSByZXF1aXJlKFwiLi9Mb2NhbEV2ZW50VHJhcE1peGluXCIpO1xudmFyIFJlYWN0QnJvd3NlckNvbXBvbmVudE1peGluID0gcmVxdWlyZShcIi4vUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW5cIik7XG52YXIgUmVhY3RDb21wb3NpdGVDb21wb25lbnQgPSByZXF1aXJlKFwiLi9SZWFjdENvbXBvc2l0ZUNvbXBvbmVudFwiKTtcbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoXCIuL1JlYWN0RE9NXCIpO1xuXG4vLyBTdG9yZSBhIHJlZmVyZW5jZSB0byB0aGUgPGZvcm0+IGBSZWFjdERPTUNvbXBvbmVudGAuXG52YXIgZm9ybSA9IFJlYWN0RE9NLmZvcm07XG5cbi8qKlxuICogU2luY2Ugb25TdWJtaXQgZG9lc24ndCBidWJibGUgT1IgY2FwdHVyZSBvbiB0aGUgdG9wIGxldmVsIGluIElFOCwgd2UgbmVlZFxuICogdG8gY2FwdHVyZSBpdCBvbiB0aGUgPGZvcm0+IGVsZW1lbnQgaXRzZWxmLiBUaGVyZSBhcmUgbG90cyBvZiBoYWNrcyB3ZSBjb3VsZFxuICogZG8gdG8gYWNjb21wbGlzaCB0aGlzLCBidXQgdGhlIG1vc3QgcmVsaWFibGUgaXMgdG8gbWFrZSA8Zm9ybT4gYVxuICogY29tcG9zaXRlIGNvbXBvbmVudCBhbmQgdXNlIGBjb21wb25lbnREaWRNb3VudGAgdG8gYXR0YWNoIHRoZSBldmVudCBoYW5kbGVycy5cbiAqL1xudmFyIFJlYWN0RE9NRm9ybSA9IFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50LmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdSZWFjdERPTUZvcm0nLFxuXG4gIG1peGluczogW1JlYWN0QnJvd3NlckNvbXBvbmVudE1peGluLCBMb2NhbEV2ZW50VHJhcE1peGluXSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIC8vIFRPRE86IEluc3RlYWQgb2YgdXNpbmcgYFJlYWN0RE9NYCBkaXJlY3RseSwgd2Ugc2hvdWxkIHVzZSBKU1guIEhvd2V2ZXIsXG4gICAgLy8gYGpzaGludGAgZmFpbHMgdG8gcGFyc2UgSlNYIHNvIGluIG9yZGVyIGZvciBsaW50aW5nIHRvIHdvcmsgaW4gdGhlIG9wZW5cbiAgICAvLyBzb3VyY2UgcmVwbywgd2UgbmVlZCB0byBqdXN0IHVzZSBgUmVhY3RET00uZm9ybWAuXG4gICAgcmV0dXJuIHRoaXMudHJhbnNmZXJQcm9wc1RvKGZvcm0obnVsbCwgdGhpcy5wcm9wcy5jaGlsZHJlbikpO1xuICB9LFxuXG4gIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnRyYXBCdWJibGVkRXZlbnQoRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcy50b3BSZXNldCwgJ3Jlc2V0Jyk7XG4gICAgdGhpcy50cmFwQnViYmxlZEV2ZW50KEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXMudG9wU3VibWl0LCAnc3VibWl0Jyk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NRm9ybTtcbiIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01JRE9wZXJhdGlvbnNcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuLypqc2xpbnQgZXZpbDogdHJ1ZSAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIENTU1Byb3BlcnR5T3BlcmF0aW9ucyA9IHJlcXVpcmUoXCIuL0NTU1Byb3BlcnR5T3BlcmF0aW9uc1wiKTtcbnZhciBET01DaGlsZHJlbk9wZXJhdGlvbnMgPSByZXF1aXJlKFwiLi9ET01DaGlsZHJlbk9wZXJhdGlvbnNcIik7XG52YXIgRE9NUHJvcGVydHlPcGVyYXRpb25zID0gcmVxdWlyZShcIi4vRE9NUHJvcGVydHlPcGVyYXRpb25zXCIpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKFwiLi9SZWFjdE1vdW50XCIpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoXCIuL1JlYWN0UGVyZlwiKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcbnZhciBzZXRJbm5lckhUTUwgPSByZXF1aXJlKFwiLi9zZXRJbm5lckhUTUxcIik7XG5cbi8qKlxuICogRXJyb3JzIGZvciBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIG5vdCBiZSB1cGRhdGVkIHdpdGggYHVwZGF0ZVByb3BlcnR5QnlJZCgpYC5cbiAqXG4gKiBAdHlwZSB7b2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xudmFyIElOVkFMSURfUFJPUEVSVFlfRVJST1JTID0ge1xuICBkYW5nZXJvdXNseVNldElubmVySFRNTDpcbiAgICAnYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBtdXN0IGJlIHNldCB1c2luZyBgdXBkYXRlSW5uZXJIVE1MQnlJRCgpYC4nLFxuICBzdHlsZTogJ2BzdHlsZWAgbXVzdCBiZSBzZXQgdXNpbmcgYHVwZGF0ZVN0eWxlc0J5SUQoKWAuJ1xufTtcblxuLyoqXG4gKiBPcGVyYXRpb25zIHVzZWQgdG8gcHJvY2VzcyB1cGRhdGVzIHRvIERPTSBub2Rlcy4gVGhpcyBpcyBtYWRlIGluamVjdGFibGUgdmlhXG4gKiBgUmVhY3RDb21wb25lbnQuQmFja2VuZElET3BlcmF0aW9uc2AuXG4gKi9cbnZhciBSZWFjdERPTUlET3BlcmF0aW9ucyA9IHtcblxuICAvKipcbiAgICogVXBkYXRlcyBhIERPTSBub2RlIHdpdGggbmV3IHByb3BlcnR5IHZhbHVlcy4gVGhpcyBzaG91bGQgb25seSBiZSB1c2VkIHRvXG4gICAqIHVwZGF0ZSBET00gcHJvcGVydGllcyBpbiBgRE9NUHJvcGVydHlgLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgb2YgdGhlIG5vZGUgdG8gdXBkYXRlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBBIHZhbGlkIHByb3BlcnR5IG5hbWUsIHNlZSBgRE9NUHJvcGVydHlgLlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIE5ldyB2YWx1ZSBvZiB0aGUgcHJvcGVydHkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdXBkYXRlUHJvcGVydHlCeUlEOiBSZWFjdFBlcmYubWVhc3VyZShcbiAgICAnUmVhY3RET01JRE9wZXJhdGlvbnMnLFxuICAgICd1cGRhdGVQcm9wZXJ0eUJ5SUQnLFxuICAgIGZ1bmN0aW9uKGlkLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgdmFyIG5vZGUgPSBSZWFjdE1vdW50LmdldE5vZGUoaWQpO1xuICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICAgIUlOVkFMSURfUFJPUEVSVFlfRVJST1JTLmhhc093blByb3BlcnR5KG5hbWUpLFxuICAgICAgICAndXBkYXRlUHJvcGVydHlCeUlEKC4uLik6ICVzJyxcbiAgICAgICAgSU5WQUxJRF9QUk9QRVJUWV9FUlJPUlNbbmFtZV1cbiAgICAgICkgOiBpbnZhcmlhbnQoIUlOVkFMSURfUFJPUEVSVFlfRVJST1JTLmhhc093blByb3BlcnR5KG5hbWUpKSk7XG5cbiAgICAgIC8vIElmIHdlJ3JlIHVwZGF0aW5nIHRvIG51bGwgb3IgdW5kZWZpbmVkLCB3ZSBzaG91bGQgcmVtb3ZlIHRoZSBwcm9wZXJ0eVxuICAgICAgLy8gZnJvbSB0aGUgRE9NIG5vZGUgaW5zdGVhZCBvZiBpbmFkdmVydGFudGx5IHNldHRpbmcgdG8gYSBzdHJpbmcuIFRoaXNcbiAgICAgIC8vIGJyaW5ncyB1cyBpbiBsaW5lIHdpdGggdGhlIHNhbWUgYmVoYXZpb3Igd2UgaGF2ZSBvbiBpbml0aWFsIHJlbmRlci5cbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5zZXRWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5kZWxldGVWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgKSxcblxuICAvKipcbiAgICogVXBkYXRlcyBhIERPTSBub2RlIHRvIHJlbW92ZSBhIHByb3BlcnR5LiBUaGlzIHNob3VsZCBvbmx5IGJlIHVzZWQgdG8gcmVtb3ZlXG4gICAqIERPTSBwcm9wZXJ0aWVzIGluIGBET01Qcm9wZXJ0eWAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiB0aGUgbm9kZSB0byB1cGRhdGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEEgcHJvcGVydHkgbmFtZSB0byByZW1vdmUsIHNlZSBgRE9NUHJvcGVydHlgLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGRlbGV0ZVByb3BlcnR5QnlJRDogUmVhY3RQZXJmLm1lYXN1cmUoXG4gICAgJ1JlYWN0RE9NSURPcGVyYXRpb25zJyxcbiAgICAnZGVsZXRlUHJvcGVydHlCeUlEJyxcbiAgICBmdW5jdGlvbihpZCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBub2RlID0gUmVhY3RNb3VudC5nZXROb2RlKGlkKTtcbiAgICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAgICFJTlZBTElEX1BST1BFUlRZX0VSUk9SUy5oYXNPd25Qcm9wZXJ0eShuYW1lKSxcbiAgICAgICAgJ3VwZGF0ZVByb3BlcnR5QnlJRCguLi4pOiAlcycsXG4gICAgICAgIElOVkFMSURfUFJPUEVSVFlfRVJST1JTW25hbWVdXG4gICAgICApIDogaW52YXJpYW50KCFJTlZBTElEX1BST1BFUlRZX0VSUk9SUy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkpO1xuICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLmRlbGV0ZVZhbHVlRm9yUHJvcGVydHkobm9kZSwgbmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgKSxcblxuICAvKipcbiAgICogVXBkYXRlcyBhIERPTSBub2RlIHdpdGggbmV3IHN0eWxlIHZhbHVlcy4gSWYgYSB2YWx1ZSBpcyBzcGVjaWZpZWQgYXMgJycsXG4gICAqIHRoZSBjb3JyZXNwb25kaW5nIHN0eWxlIHByb3BlcnR5IHdpbGwgYmUgdW5zZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiB0aGUgbm9kZSB0byB1cGRhdGUuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzdHlsZXMgTWFwcGluZyBmcm9tIHN0eWxlcyB0byB2YWx1ZXMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdXBkYXRlU3R5bGVzQnlJRDogUmVhY3RQZXJmLm1lYXN1cmUoXG4gICAgJ1JlYWN0RE9NSURPcGVyYXRpb25zJyxcbiAgICAndXBkYXRlU3R5bGVzQnlJRCcsXG4gICAgZnVuY3Rpb24oaWQsIHN0eWxlcykge1xuICAgICAgdmFyIG5vZGUgPSBSZWFjdE1vdW50LmdldE5vZGUoaWQpO1xuICAgICAgQ1NTUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yU3R5bGVzKG5vZGUsIHN0eWxlcyk7XG4gICAgfVxuICApLFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgRE9NIG5vZGUncyBpbm5lckhUTUwuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiB0aGUgbm9kZSB0byB1cGRhdGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBodG1sIEFuIEhUTUwgc3RyaW5nLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVwZGF0ZUlubmVySFRNTEJ5SUQ6IFJlYWN0UGVyZi5tZWFzdXJlKFxuICAgICdSZWFjdERPTUlET3BlcmF0aW9ucycsXG4gICAgJ3VwZGF0ZUlubmVySFRNTEJ5SUQnLFxuICAgIGZ1bmN0aW9uKGlkLCBodG1sKSB7XG4gICAgICB2YXIgbm9kZSA9IFJlYWN0TW91bnQuZ2V0Tm9kZShpZCk7XG4gICAgICBzZXRJbm5lckhUTUwobm9kZSwgaHRtbCk7XG4gICAgfVxuICApLFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgRE9NIG5vZGUncyB0ZXh0IGNvbnRlbnQgc2V0IGJ5IGBwcm9wcy5jb250ZW50YC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIElEIG9mIHRoZSBub2RlIHRvIHVwZGF0ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnQgVGV4dCBjb250ZW50LlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVwZGF0ZVRleHRDb250ZW50QnlJRDogUmVhY3RQZXJmLm1lYXN1cmUoXG4gICAgJ1JlYWN0RE9NSURPcGVyYXRpb25zJyxcbiAgICAndXBkYXRlVGV4dENvbnRlbnRCeUlEJyxcbiAgICBmdW5jdGlvbihpZCwgY29udGVudCkge1xuICAgICAgdmFyIG5vZGUgPSBSZWFjdE1vdW50LmdldE5vZGUoaWQpO1xuICAgICAgRE9NQ2hpbGRyZW5PcGVyYXRpb25zLnVwZGF0ZVRleHRDb250ZW50KG5vZGUsIGNvbnRlbnQpO1xuICAgIH1cbiAgKSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYSBET00gbm9kZSB0aGF0IGV4aXN0cyBpbiB0aGUgZG9jdW1lbnQgd2l0aCBtYXJrdXAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiBjaGlsZCB0byBiZSByZXBsYWNlZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBEYW5nZXJvdXMgbWFya3VwIHRvIGluamVjdCBpbiBwbGFjZSBvZiBjaGlsZC5cbiAgICogQGludGVybmFsXG4gICAqIEBzZWUge0Rhbmdlci5kYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cH1cbiAgICovXG4gIGRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRDogUmVhY3RQZXJmLm1lYXN1cmUoXG4gICAgJ1JlYWN0RE9NSURPcGVyYXRpb25zJyxcbiAgICAnZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXBCeUlEJyxcbiAgICBmdW5jdGlvbihpZCwgbWFya3VwKSB7XG4gICAgICB2YXIgbm9kZSA9IFJlYWN0TW91bnQuZ2V0Tm9kZShpZCk7XG4gICAgICBET01DaGlsZHJlbk9wZXJhdGlvbnMuZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAobm9kZSwgbWFya3VwKTtcbiAgICB9XG4gICksXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYSBjb21wb25lbnQncyBjaGlsZHJlbiBieSBwcm9jZXNzaW5nIGEgc2VyaWVzIG9mIHVwZGF0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7YXJyYXk8b2JqZWN0Pn0gdXBkYXRlcyBMaXN0IG9mIHVwZGF0ZSBjb25maWd1cmF0aW9ucy5cbiAgICogQHBhcmFtIHthcnJheTxzdHJpbmc+fSBtYXJrdXAgTGlzdCBvZiBtYXJrdXAgc3RyaW5ncy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBkYW5nZXJvdXNseVByb2Nlc3NDaGlsZHJlblVwZGF0ZXM6IFJlYWN0UGVyZi5tZWFzdXJlKFxuICAgICdSZWFjdERPTUlET3BlcmF0aW9ucycsXG4gICAgJ2Rhbmdlcm91c2x5UHJvY2Vzc0NoaWxkcmVuVXBkYXRlcycsXG4gICAgZnVuY3Rpb24odXBkYXRlcywgbWFya3VwKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVwZGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdXBkYXRlc1tpXS5wYXJlbnROb2RlID0gUmVhY3RNb3VudC5nZXROb2RlKHVwZGF0ZXNbaV0ucGFyZW50SUQpO1xuICAgICAgfVxuICAgICAgRE9NQ2hpbGRyZW5PcGVyYXRpb25zLnByb2Nlc3NVcGRhdGVzKHVwZGF0ZXMsIG1hcmt1cCk7XG4gICAgfVxuICApXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NSURPcGVyYXRpb25zO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01JbWdcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZShcIi4vRXZlbnRDb25zdGFudHNcIik7XG52YXIgTG9jYWxFdmVudFRyYXBNaXhpbiA9IHJlcXVpcmUoXCIuL0xvY2FsRXZlbnRUcmFwTWl4aW5cIik7XG52YXIgUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW4gPSByZXF1aXJlKFwiLi9SZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpblwiKTtcbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCA9IHJlcXVpcmUoXCIuL1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50XCIpO1xudmFyIFJlYWN0RE9NID0gcmVxdWlyZShcIi4vUmVhY3RET01cIik7XG5cbi8vIFN0b3JlIGEgcmVmZXJlbmNlIHRvIHRoZSA8aW1nPiBgUmVhY3RET01Db21wb25lbnRgLlxudmFyIGltZyA9IFJlYWN0RE9NLmltZztcblxuLyoqXG4gKiBTaW5jZSBvbkxvYWQgZG9lc24ndCBidWJibGUgT1IgY2FwdHVyZSBvbiB0aGUgdG9wIGxldmVsIGluIElFOCwgd2UgbmVlZCB0b1xuICogY2FwdHVyZSBpdCBvbiB0aGUgPGltZz4gZWxlbWVudCBpdHNlbGYuIFRoZXJlIGFyZSBsb3RzIG9mIGhhY2tzIHdlIGNvdWxkIGRvXG4gKiB0byBhY2NvbXBsaXNoIHRoaXMsIGJ1dCB0aGUgbW9zdCByZWxpYWJsZSBpcyB0byBtYWtlIDxpbWc+IGEgY29tcG9zaXRlXG4gKiBjb21wb25lbnQgYW5kIHVzZSBgY29tcG9uZW50RGlkTW91bnRgIHRvIGF0dGFjaCB0aGUgZXZlbnQgaGFuZGxlcnMuXG4gKi9cbnZhciBSZWFjdERPTUltZyA9IFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50LmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdSZWFjdERPTUltZycsXG4gIHRhZ05hbWU6ICdJTUcnLFxuXG4gIG1peGluczogW1JlYWN0QnJvd3NlckNvbXBvbmVudE1peGluLCBMb2NhbEV2ZW50VHJhcE1peGluXSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBpbWcodGhpcy5wcm9wcyk7XG4gIH0sXG5cbiAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudHJhcEJ1YmJsZWRFdmVudChFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzLnRvcExvYWQsICdsb2FkJyk7XG4gICAgdGhpcy50cmFwQnViYmxlZEV2ZW50KEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXMudG9wRXJyb3IsICdlcnJvcicpO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUltZztcbiIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01JbnB1dFxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgQXV0b0ZvY3VzTWl4aW4gPSByZXF1aXJlKFwiLi9BdXRvRm9jdXNNaXhpblwiKTtcbnZhciBET01Qcm9wZXJ0eU9wZXJhdGlvbnMgPSByZXF1aXJlKFwiLi9ET01Qcm9wZXJ0eU9wZXJhdGlvbnNcIik7XG52YXIgTGlua2VkVmFsdWVVdGlscyA9IHJlcXVpcmUoXCIuL0xpbmtlZFZhbHVlVXRpbHNcIik7XG52YXIgUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW4gPSByZXF1aXJlKFwiLi9SZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpblwiKTtcbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCA9IHJlcXVpcmUoXCIuL1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50XCIpO1xudmFyIFJlYWN0RE9NID0gcmVxdWlyZShcIi4vUmVhY3RET01cIik7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoXCIuL1JlYWN0TW91bnRcIik7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG52YXIgbWVyZ2UgPSByZXF1aXJlKFwiLi9tZXJnZVwiKTtcblxuLy8gU3RvcmUgYSByZWZlcmVuY2UgdG8gdGhlIDxpbnB1dD4gYFJlYWN0RE9NQ29tcG9uZW50YC5cbnZhciBpbnB1dCA9IFJlYWN0RE9NLmlucHV0O1xuXG52YXIgaW5zdGFuY2VzQnlSZWFjdElEID0ge307XG5cbi8qKlxuICogSW1wbGVtZW50cyBhbiA8aW5wdXQ+IG5hdGl2ZSBjb21wb25lbnQgdGhhdCBhbGxvd3Mgc2V0dGluZyB0aGVzZSBvcHRpb25hbFxuICogcHJvcHM6IGBjaGVja2VkYCwgYHZhbHVlYCwgYGRlZmF1bHRDaGVja2VkYCwgYW5kIGBkZWZhdWx0VmFsdWVgLlxuICpcbiAqIElmIGBjaGVja2VkYCBvciBgdmFsdWVgIGFyZSBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zXG4gKiB0aGF0IGFmZmVjdCB0aGUgY2hlY2tlZCBzdGF0ZSBvciB2YWx1ZSB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC5cbiAqXG4gKiBJZiB0aGV5IGFyZSBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgbm90XG4gKiB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuIEluc3RlYWQsIHRoZSBwcm9wcyBtdXN0IGNoYW5nZSBpbiBvcmRlciBmb3JcbiAqIHRoZSByZW5kZXJlZCBlbGVtZW50IHRvIGJlIHVwZGF0ZWQuXG4gKlxuICogVGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBiZSBpbml0aWFsaXplZCBhcyB1bmNoZWNrZWQgKG9yIGBkZWZhdWx0Q2hlY2tlZGApXG4gKiB3aXRoIGFuIGVtcHR5IHZhbHVlIChvciBgZGVmYXVsdFZhbHVlYCkuXG4gKlxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEyL1dELWh0bWw1LTIwMTIxMDI1L3RoZS1pbnB1dC1lbGVtZW50Lmh0bWxcbiAqL1xudmFyIFJlYWN0RE9NSW5wdXQgPSBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnUmVhY3RET01JbnB1dCcsXG5cbiAgbWl4aW5zOiBbQXV0b0ZvY3VzTWl4aW4sIExpbmtlZFZhbHVlVXRpbHMuTWl4aW4sIFJlYWN0QnJvd3NlckNvbXBvbmVudE1peGluXSxcblxuICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBkZWZhdWx0VmFsdWUgPSB0aGlzLnByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICByZXR1cm4ge1xuICAgICAgY2hlY2tlZDogdGhpcy5wcm9wcy5kZWZhdWx0Q2hlY2tlZCB8fCBmYWxzZSxcbiAgICAgIHZhbHVlOiBkZWZhdWx0VmFsdWUgIT0gbnVsbCA/IGRlZmF1bHRWYWx1ZSA6IG51bGxcbiAgICB9O1xuICB9LFxuXG4gIHNob3VsZENvbXBvbmVudFVwZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgLy8gRGVmZXIgYW55IHVwZGF0ZXMgdG8gdGhpcyBjb21wb25lbnQgZHVyaW5nIHRoZSBgb25DaGFuZ2VgIGhhbmRsZXIuXG4gICAgcmV0dXJuICF0aGlzLl9pc0NoYW5naW5nO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgLy8gQ2xvbmUgYHRoaXMucHJvcHNgIHNvIHdlIGRvbid0IG11dGF0ZSB0aGUgaW5wdXQuXG4gICAgdmFyIHByb3BzID0gbWVyZ2UodGhpcy5wcm9wcyk7XG5cbiAgICBwcm9wcy5kZWZhdWx0Q2hlY2tlZCA9IG51bGw7XG4gICAgcHJvcHMuZGVmYXVsdFZhbHVlID0gbnVsbDtcblxuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUodGhpcyk7XG4gICAgcHJvcHMudmFsdWUgPSB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiB0aGlzLnN0YXRlLnZhbHVlO1xuXG4gICAgdmFyIGNoZWNrZWQgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldENoZWNrZWQodGhpcyk7XG4gICAgcHJvcHMuY2hlY2tlZCA9IGNoZWNrZWQgIT0gbnVsbCA/IGNoZWNrZWQgOiB0aGlzLnN0YXRlLmNoZWNrZWQ7XG5cbiAgICBwcm9wcy5vbkNoYW5nZSA9IHRoaXMuX2hhbmRsZUNoYW5nZTtcblxuICAgIHJldHVybiBpbnB1dChwcm9wcywgdGhpcy5wcm9wcy5jaGlsZHJlbik7XG4gIH0sXG5cbiAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpZCA9IFJlYWN0TW91bnQuZ2V0SUQodGhpcy5nZXRET01Ob2RlKCkpO1xuICAgIGluc3RhbmNlc0J5UmVhY3RJRFtpZF0gPSB0aGlzO1xuICB9LFxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgcm9vdE5vZGUgPSB0aGlzLmdldERPTU5vZGUoKTtcbiAgICB2YXIgaWQgPSBSZWFjdE1vdW50LmdldElEKHJvb3ROb2RlKTtcbiAgICBkZWxldGUgaW5zdGFuY2VzQnlSZWFjdElEW2lkXTtcbiAgfSxcblxuICBjb21wb25lbnREaWRVcGRhdGU6IGZ1bmN0aW9uKHByZXZQcm9wcywgcHJldlN0YXRlLCBwcmV2Q29udGV4dCkge1xuICAgIHZhciByb290Tm9kZSA9IHRoaXMuZ2V0RE9NTm9kZSgpO1xuICAgIGlmICh0aGlzLnByb3BzLmNoZWNrZWQgIT0gbnVsbCkge1xuICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yUHJvcGVydHkoXG4gICAgICAgIHJvb3ROb2RlLFxuICAgICAgICAnY2hlY2tlZCcsXG4gICAgICAgIHRoaXMucHJvcHMuY2hlY2tlZCB8fCBmYWxzZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHRoaXMpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAvLyBDYXN0IGB2YWx1ZWAgdG8gYSBzdHJpbmcgdG8gZW5zdXJlIHRoZSB2YWx1ZSBpcyBzZXQgY29ycmVjdGx5LiBXaGlsZVxuICAgICAgLy8gYnJvd3NlcnMgdHlwaWNhbGx5IGRvIHRoaXMgYXMgbmVjZXNzYXJ5LCBqc2RvbSBkb2Vzbid0LlxuICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yUHJvcGVydHkocm9vdE5vZGUsICd2YWx1ZScsICcnICsgdmFsdWUpO1xuICAgIH1cbiAgfSxcblxuICBfaGFuZGxlQ2hhbmdlOiBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciByZXR1cm5WYWx1ZTtcbiAgICB2YXIgb25DaGFuZ2UgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldE9uQ2hhbmdlKHRoaXMpO1xuICAgIGlmIChvbkNoYW5nZSkge1xuICAgICAgdGhpcy5faXNDaGFuZ2luZyA9IHRydWU7XG4gICAgICByZXR1cm5WYWx1ZSA9IG9uQ2hhbmdlLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgdGhpcy5faXNDaGFuZ2luZyA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGNoZWNrZWQ6IGV2ZW50LnRhcmdldC5jaGVja2VkLFxuICAgICAgdmFsdWU6IGV2ZW50LnRhcmdldC52YWx1ZVxuICAgIH0pO1xuXG4gICAgdmFyIG5hbWUgPSB0aGlzLnByb3BzLm5hbWU7XG4gICAgaWYgKHRoaXMucHJvcHMudHlwZSA9PT0gJ3JhZGlvJyAmJiBuYW1lICE9IG51bGwpIHtcbiAgICAgIHZhciByb290Tm9kZSA9IHRoaXMuZ2V0RE9NTm9kZSgpO1xuICAgICAgdmFyIHF1ZXJ5Um9vdCA9IHJvb3ROb2RlO1xuXG4gICAgICB3aGlsZSAocXVlcnlSb290LnBhcmVudE5vZGUpIHtcbiAgICAgICAgcXVlcnlSb290ID0gcXVlcnlSb290LnBhcmVudE5vZGU7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGByb290Tm9kZS5mb3JtYCB3YXMgbm9uLW51bGwsIHRoZW4gd2UgY291bGQgdHJ5IGBmb3JtLmVsZW1lbnRzYCxcbiAgICAgIC8vIGJ1dCB0aGF0IHNvbWV0aW1lcyBiZWhhdmVzIHN0cmFuZ2VseSBpbiBJRTguIFdlIGNvdWxkIGFsc28gdHJ5IHVzaW5nXG4gICAgICAvLyBgZm9ybS5nZXRFbGVtZW50c0J5TmFtZWAsIGJ1dCB0aGF0IHdpbGwgb25seSByZXR1cm4gZGlyZWN0IGNoaWxkcmVuXG4gICAgICAvLyBhbmQgd29uJ3QgaW5jbHVkZSBpbnB1dHMgdGhhdCB1c2UgdGhlIEhUTUw1IGBmb3JtPWAgYXR0cmlidXRlLiBTaW5jZVxuICAgICAgLy8gdGhlIGlucHV0IG1pZ2h0IG5vdCBldmVuIGJlIGluIGEgZm9ybSwgbGV0J3MganVzdCB1c2UgdGhlIGdsb2JhbFxuICAgICAgLy8gYHF1ZXJ5U2VsZWN0b3JBbGxgIHRvIGVuc3VyZSB3ZSBkb24ndCBtaXNzIGFueXRoaW5nLlxuICAgICAgdmFyIGdyb3VwID0gcXVlcnlSb290LnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgICdpbnB1dFtuYW1lPScgKyBKU09OLnN0cmluZ2lmeSgnJyArIG5hbWUpICsgJ11bdHlwZT1cInJhZGlvXCJdJyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBncm91cExlbiA9IGdyb3VwLmxlbmd0aDsgaSA8IGdyb3VwTGVuOyBpKyspIHtcbiAgICAgICAgdmFyIG90aGVyTm9kZSA9IGdyb3VwW2ldO1xuICAgICAgICBpZiAob3RoZXJOb2RlID09PSByb290Tm9kZSB8fFxuICAgICAgICAgICAgb3RoZXJOb2RlLmZvcm0gIT09IHJvb3ROb2RlLmZvcm0pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3RoZXJJRCA9IFJlYWN0TW91bnQuZ2V0SUQob3RoZXJOb2RlKTtcbiAgICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICAgICBvdGhlcklELFxuICAgICAgICAgICdSZWFjdERPTUlucHV0OiBNaXhpbmcgUmVhY3QgYW5kIG5vbi1SZWFjdCByYWRpbyBpbnB1dHMgd2l0aCB0aGUgJyArXG4gICAgICAgICAgJ3NhbWUgYG5hbWVgIGlzIG5vdCBzdXBwb3J0ZWQuJ1xuICAgICAgICApIDogaW52YXJpYW50KG90aGVySUQpKTtcbiAgICAgICAgdmFyIG90aGVySW5zdGFuY2UgPSBpbnN0YW5jZXNCeVJlYWN0SURbb3RoZXJJRF07XG4gICAgICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAgICAgb3RoZXJJbnN0YW5jZSxcbiAgICAgICAgICAnUmVhY3RET01JbnB1dDogVW5rbm93biByYWRpbyBidXR0b24gSUQgJXMuJyxcbiAgICAgICAgICBvdGhlcklEXG4gICAgICAgICkgOiBpbnZhcmlhbnQob3RoZXJJbnN0YW5jZSkpO1xuICAgICAgICAvLyBJbiBzb21lIGNhc2VzLCB0aGlzIHdpbGwgYWN0dWFsbHkgY2hhbmdlIHRoZSBgY2hlY2tlZGAgc3RhdGUgdmFsdWUuXG4gICAgICAgIC8vIEluIG90aGVyIGNhc2VzLCB0aGVyZSdzIG5vIGNoYW5nZSBidXQgdGhpcyBmb3JjZXMgYSByZWNvbmNpbGUgdXBvblxuICAgICAgICAvLyB3aGljaCBjb21wb25lbnREaWRVcGRhdGUgd2lsbCByZXNldCB0aGUgRE9NIHByb3BlcnR5IHRvIHdoYXRldmVyIGl0XG4gICAgICAgIC8vIHNob3VsZCBiZS5cbiAgICAgICAgb3RoZXJJbnN0YW5jZS5zZXRTdGF0ZSh7XG4gICAgICAgICAgY2hlY2tlZDogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NSW5wdXQ7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01PcHRpb25cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIFJlYWN0QnJvd3NlckNvbXBvbmVudE1peGluID0gcmVxdWlyZShcIi4vUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW5cIik7XG52YXIgUmVhY3RDb21wb3NpdGVDb21wb25lbnQgPSByZXF1aXJlKFwiLi9SZWFjdENvbXBvc2l0ZUNvbXBvbmVudFwiKTtcbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoXCIuL1JlYWN0RE9NXCIpO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoXCIuL3dhcm5pbmdcIik7XG5cbi8vIFN0b3JlIGEgcmVmZXJlbmNlIHRvIHRoZSA8b3B0aW9uPiBgUmVhY3RET01Db21wb25lbnRgLlxudmFyIG9wdGlvbiA9IFJlYWN0RE9NLm9wdGlvbjtcblxuLyoqXG4gKiBJbXBsZW1lbnRzIGFuIDxvcHRpb24+IG5hdGl2ZSBjb21wb25lbnQgdGhhdCB3YXJucyB3aGVuIGBzZWxlY3RlZGAgaXMgc2V0LlxuICovXG52YXIgUmVhY3RET01PcHRpb24gPSBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnUmVhY3RET01PcHRpb24nLFxuXG4gIG1peGluczogW1JlYWN0QnJvd3NlckNvbXBvbmVudE1peGluXSxcblxuICBjb21wb25lbnRXaWxsTW91bnQ6IGZ1bmN0aW9uKCkge1xuICAgIC8vIFRPRE8gKHl1bmdzdGVycyk6IFJlbW92ZSBzdXBwb3J0IGZvciBgc2VsZWN0ZWRgIGluIDxvcHRpb24+LlxuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKFxuICAgICAgICB0aGlzLnByb3BzLnNlbGVjdGVkID09IG51bGwsXG4gICAgICAgICdVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgb24gPHNlbGVjdD4gaW5zdGVhZCBvZiAnICtcbiAgICAgICAgJ3NldHRpbmcgYHNlbGVjdGVkYCBvbiA8b3B0aW9uPi4nXG4gICAgICApIDogbnVsbCk7XG4gICAgfVxuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG9wdGlvbih0aGlzLnByb3BzLCB0aGlzLnByb3BzLmNoaWxkcmVuKTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTU9wdGlvbjtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NU2VsZWN0XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBBdXRvRm9jdXNNaXhpbiA9IHJlcXVpcmUoXCIuL0F1dG9Gb2N1c01peGluXCIpO1xudmFyIExpbmtlZFZhbHVlVXRpbHMgPSByZXF1aXJlKFwiLi9MaW5rZWRWYWx1ZVV0aWxzXCIpO1xudmFyIFJlYWN0QnJvd3NlckNvbXBvbmVudE1peGluID0gcmVxdWlyZShcIi4vUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW5cIik7XG52YXIgUmVhY3RDb21wb3NpdGVDb21wb25lbnQgPSByZXF1aXJlKFwiLi9SZWFjdENvbXBvc2l0ZUNvbXBvbmVudFwiKTtcbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoXCIuL1JlYWN0RE9NXCIpO1xuXG52YXIgbWVyZ2UgPSByZXF1aXJlKFwiLi9tZXJnZVwiKTtcblxuLy8gU3RvcmUgYSByZWZlcmVuY2UgdG8gdGhlIDxzZWxlY3Q+IGBSZWFjdERPTUNvbXBvbmVudGAuXG52YXIgc2VsZWN0ID0gUmVhY3RET00uc2VsZWN0O1xuXG4vKipcbiAqIFZhbGlkYXRpb24gZnVuY3Rpb24gZm9yIGB2YWx1ZWAgYW5kIGBkZWZhdWx0VmFsdWVgLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2VsZWN0VmFsdWVUeXBlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHByb3BzLm11bHRpcGxlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAgICAgIChcIlRoZSBgXCIgKyBwcm9wTmFtZSArIFwiYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYW4gYXJyYXkgaWYgXCIpICtcbiAgICAgICAgKFwiYG11bHRpcGxlYCBpcyB0cnVlLlwiKVxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICAgICAgKFwiVGhlIGBcIiArIHByb3BOYW1lICsgXCJgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhIHNjYWxhciBcIikgK1xuICAgICAgICAoXCJ2YWx1ZSBpZiBgbXVsdGlwbGVgIGlzIGZhbHNlLlwiKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJZiBgdmFsdWVgIGlzIHN1cHBsaWVkLCB1cGRhdGVzIDxvcHRpb24+IGVsZW1lbnRzIG9uIG1vdW50IGFuZCB1cGRhdGUuXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnQgSW5zdGFuY2Ugb2YgUmVhY3RET01TZWxlY3RcbiAqIEBwYXJhbSB7Pyp9IHByb3BWYWx1ZSBGb3IgdW5jb250cm9sbGVkIGNvbXBvbmVudHMsIG51bGwvdW5kZWZpbmVkLiBGb3JcbiAqIGNvbnRyb2xsZWQgY29tcG9uZW50cywgYSBzdHJpbmcgKG9yIHdpdGggYG11bHRpcGxlYCwgYSBsaXN0IG9mIHN0cmluZ3MpLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdXBkYXRlT3B0aW9ucyhjb21wb25lbnQsIHByb3BWYWx1ZSkge1xuICB2YXIgbXVsdGlwbGUgPSBjb21wb25lbnQucHJvcHMubXVsdGlwbGU7XG4gIHZhciB2YWx1ZSA9IHByb3BWYWx1ZSAhPSBudWxsID8gcHJvcFZhbHVlIDogY29tcG9uZW50LnN0YXRlLnZhbHVlO1xuICB2YXIgb3B0aW9ucyA9IGNvbXBvbmVudC5nZXRET01Ob2RlKCkub3B0aW9ucztcbiAgdmFyIHNlbGVjdGVkVmFsdWUsIGksIGw7XG4gIGlmIChtdWx0aXBsZSkge1xuICAgIHNlbGVjdGVkVmFsdWUgPSB7fTtcbiAgICBmb3IgKGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICBzZWxlY3RlZFZhbHVlWycnICsgdmFsdWVbaV1dID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2VsZWN0ZWRWYWx1ZSA9ICcnICsgdmFsdWU7XG4gIH1cbiAgZm9yIChpID0gMCwgbCA9IG9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIHNlbGVjdGVkID0gbXVsdGlwbGUgP1xuICAgICAgc2VsZWN0ZWRWYWx1ZS5oYXNPd25Qcm9wZXJ0eShvcHRpb25zW2ldLnZhbHVlKSA6XG4gICAgICBvcHRpb25zW2ldLnZhbHVlID09PSBzZWxlY3RlZFZhbHVlO1xuXG4gICAgaWYgKHNlbGVjdGVkICE9PSBvcHRpb25zW2ldLnNlbGVjdGVkKSB7XG4gICAgICBvcHRpb25zW2ldLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhIDxzZWxlY3Q+IG5hdGl2ZSBjb21wb25lbnQgdGhhdCBhbGxvd3Mgb3B0aW9uYWxseSBzZXR0aW5nIHRoZVxuICogcHJvcHMgYHZhbHVlYCBhbmQgYGRlZmF1bHRWYWx1ZWAuIElmIGBtdWx0aXBsZWAgaXMgZmFsc2UsIHRoZSBwcm9wIG11c3QgYmUgYVxuICogc3RyaW5nLiBJZiBgbXVsdGlwbGVgIGlzIHRydWUsIHRoZSBwcm9wIG11c3QgYmUgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnMgdGhhdCBjaGFuZ2UgdGhlXG4gKiBzZWxlY3RlZCBvcHRpb24gd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIHJlbmRlcmVkIG9wdGlvbnMuXG4gKlxuICogSWYgaXQgaXMgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgb3B0aW9ucyB3aWxsIG5vdFxuICogdXBkYXRlIGluIHJlc3BvbnNlIHRvIHVzZXIgYWN0aW9ucy4gSW5zdGVhZCwgdGhlIGB2YWx1ZWAgcHJvcCBtdXN0IGNoYW5nZSBpblxuICogb3JkZXIgZm9yIHRoZSByZW5kZXJlZCBvcHRpb25zIHRvIHVwZGF0ZS5cbiAqXG4gKiBJZiBgZGVmYXVsdFZhbHVlYCBpcyBwcm92aWRlZCwgYW55IG9wdGlvbnMgd2l0aCB0aGUgc3VwcGxpZWQgdmFsdWVzIHdpbGwgYmVcbiAqIHNlbGVjdGVkLlxuICovXG52YXIgUmVhY3RET01TZWxlY3QgPSBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnUmVhY3RET01TZWxlY3QnLFxuXG4gIG1peGluczogW0F1dG9Gb2N1c01peGluLCBMaW5rZWRWYWx1ZVV0aWxzLk1peGluLCBSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbl0sXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgZGVmYXVsdFZhbHVlOiBzZWxlY3RWYWx1ZVR5cGUsXG4gICAgdmFsdWU6IHNlbGVjdFZhbHVlVHlwZVxuICB9LFxuXG4gIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHt2YWx1ZTogdGhpcy5wcm9wcy5kZWZhdWx0VmFsdWUgfHwgKHRoaXMucHJvcHMubXVsdGlwbGUgPyBbXSA6ICcnKX07XG4gIH0sXG5cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogZnVuY3Rpb24obmV4dFByb3BzKSB7XG4gICAgaWYgKCF0aGlzLnByb3BzLm11bHRpcGxlICYmIG5leHRQcm9wcy5tdWx0aXBsZSkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7dmFsdWU6IFt0aGlzLnN0YXRlLnZhbHVlXX0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5wcm9wcy5tdWx0aXBsZSAmJiAhbmV4dFByb3BzLm11bHRpcGxlKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHt2YWx1ZTogdGhpcy5zdGF0ZS52YWx1ZVswXX0pO1xuICAgIH1cbiAgfSxcblxuICBzaG91bGRDb21wb25lbnRVcGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgIC8vIERlZmVyIGFueSB1cGRhdGVzIHRvIHRoaXMgY29tcG9uZW50IGR1cmluZyB0aGUgYG9uQ2hhbmdlYCBoYW5kbGVyLlxuICAgIHJldHVybiAhdGhpcy5faXNDaGFuZ2luZztcbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIC8vIENsb25lIGB0aGlzLnByb3BzYCBzbyB3ZSBkb24ndCBtdXRhdGUgdGhlIGlucHV0LlxuICAgIHZhciBwcm9wcyA9IG1lcmdlKHRoaXMucHJvcHMpO1xuXG4gICAgcHJvcHMub25DaGFuZ2UgPSB0aGlzLl9oYW5kbGVDaGFuZ2U7XG4gICAgcHJvcHMudmFsdWUgPSBudWxsO1xuXG4gICAgcmV0dXJuIHNlbGVjdChwcm9wcywgdGhpcy5wcm9wcy5jaGlsZHJlbik7XG4gIH0sXG5cbiAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uKCkge1xuICAgIHVwZGF0ZU9wdGlvbnModGhpcywgTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZSh0aGlzKSk7XG4gIH0sXG5cbiAgY29tcG9uZW50RGlkVXBkYXRlOiBmdW5jdGlvbihwcmV2UHJvcHMpIHtcbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHRoaXMpO1xuICAgIHZhciBwcmV2TXVsdGlwbGUgPSAhIXByZXZQcm9wcy5tdWx0aXBsZTtcbiAgICB2YXIgbXVsdGlwbGUgPSAhIXRoaXMucHJvcHMubXVsdGlwbGU7XG4gICAgaWYgKHZhbHVlICE9IG51bGwgfHwgcHJldk11bHRpcGxlICE9PSBtdWx0aXBsZSkge1xuICAgICAgdXBkYXRlT3B0aW9ucyh0aGlzLCB2YWx1ZSk7XG4gICAgfVxuICB9LFxuXG4gIF9oYW5kbGVDaGFuZ2U6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIHJldHVyblZhbHVlO1xuICAgIHZhciBvbkNoYW5nZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0T25DaGFuZ2UodGhpcyk7XG4gICAgaWYgKG9uQ2hhbmdlKSB7XG4gICAgICB0aGlzLl9pc0NoYW5naW5nID0gdHJ1ZTtcbiAgICAgIHJldHVyblZhbHVlID0gb25DaGFuZ2UuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICB0aGlzLl9pc0NoYW5naW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHNlbGVjdGVkVmFsdWU7XG4gICAgaWYgKHRoaXMucHJvcHMubXVsdGlwbGUpIHtcbiAgICAgIHNlbGVjdGVkVmFsdWUgPSBbXTtcbiAgICAgIHZhciBvcHRpb25zID0gZXZlbnQudGFyZ2V0Lm9wdGlvbnM7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChvcHRpb25zW2ldLnNlbGVjdGVkKSB7XG4gICAgICAgICAgc2VsZWN0ZWRWYWx1ZS5wdXNoKG9wdGlvbnNbaV0udmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGVjdGVkVmFsdWUgPSBldmVudC50YXJnZXQudmFsdWU7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7dmFsdWU6IHNlbGVjdGVkVmFsdWV9KTtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01TZWxlY3Q7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01TZWxlY3Rpb25cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZShcIi4vRXhlY3V0aW9uRW52aXJvbm1lbnRcIik7XG5cbnZhciBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0ID0gcmVxdWlyZShcIi4vZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldFwiKTtcbnZhciBnZXRUZXh0Q29udGVudEFjY2Vzc29yID0gcmVxdWlyZShcIi4vZ2V0VGV4dENvbnRlbnRBY2Nlc3NvclwiKTtcblxuLyoqXG4gKiBXaGlsZSBgaXNDb2xsYXBzZWRgIGlzIGF2YWlsYWJsZSBvbiB0aGUgU2VsZWN0aW9uIG9iamVjdCBhbmQgYGNvbGxhcHNlZGBcbiAqIGlzIGF2YWlsYWJsZSBvbiB0aGUgUmFuZ2Ugb2JqZWN0LCBJRTExIHNvbWV0aW1lcyBnZXRzIHRoZW0gd3JvbmcuXG4gKiBJZiB0aGUgYW5jaG9yL2ZvY3VzIG5vZGVzIGFuZCBvZmZzZXRzIGFyZSB0aGUgc2FtZSwgdGhlIHJhbmdlIGlzIGNvbGxhcHNlZC5cbiAqL1xuZnVuY3Rpb24gaXNDb2xsYXBzZWQoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KSB7XG4gIHJldHVybiBhbmNob3JOb2RlID09PSBmb2N1c05vZGUgJiYgYW5jaG9yT2Zmc2V0ID09PSBmb2N1c09mZnNldDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGFwcHJvcHJpYXRlIGFuY2hvciBhbmQgZm9jdXMgbm9kZS9vZmZzZXQgcGFpcnMgZm9yIElFLlxuICpcbiAqIFRoZSBjYXRjaCBoZXJlIGlzIHRoYXQgSUUncyBzZWxlY3Rpb24gQVBJIGRvZXNuJ3QgcHJvdmlkZSBpbmZvcm1hdGlvblxuICogYWJvdXQgd2hldGhlciB0aGUgc2VsZWN0aW9uIGlzIGZvcndhcmQgb3IgYmFja3dhcmQsIHNvIHdlIGhhdmUgdG9cbiAqIGJlaGF2ZSBhcyB0aG91Z2ggaXQncyBhbHdheXMgZm9yd2FyZC5cbiAqXG4gKiBJRSB0ZXh0IGRpZmZlcnMgZnJvbSBtb2Rlcm4gc2VsZWN0aW9uIGluIHRoYXQgaXQgYmVoYXZlcyBhcyB0aG91Z2hcbiAqIGJsb2NrIGVsZW1lbnRzIGVuZCB3aXRoIGEgbmV3IGxpbmUuIFRoaXMgbWVhbnMgY2hhcmFjdGVyIG9mZnNldHMgd2lsbFxuICogZGlmZmVyIGJldHdlZW4gdGhlIHR3byBBUElzLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRJRU9mZnNldHMobm9kZSkge1xuICB2YXIgc2VsZWN0aW9uID0gZG9jdW1lbnQuc2VsZWN0aW9uO1xuICB2YXIgc2VsZWN0ZWRSYW5nZSA9IHNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICB2YXIgc2VsZWN0ZWRMZW5ndGggPSBzZWxlY3RlZFJhbmdlLnRleHQubGVuZ3RoO1xuXG4gIC8vIER1cGxpY2F0ZSBzZWxlY3Rpb24gc28gd2UgY2FuIG1vdmUgcmFuZ2Ugd2l0aG91dCBicmVha2luZyB1c2VyIHNlbGVjdGlvbi5cbiAgdmFyIGZyb21TdGFydCA9IHNlbGVjdGVkUmFuZ2UuZHVwbGljYXRlKCk7XG4gIGZyb21TdGFydC5tb3ZlVG9FbGVtZW50VGV4dChub2RlKTtcbiAgZnJvbVN0YXJ0LnNldEVuZFBvaW50KCdFbmRUb1N0YXJ0Jywgc2VsZWN0ZWRSYW5nZSk7XG5cbiAgdmFyIHN0YXJ0T2Zmc2V0ID0gZnJvbVN0YXJ0LnRleHQubGVuZ3RoO1xuICB2YXIgZW5kT2Zmc2V0ID0gc3RhcnRPZmZzZXQgKyBzZWxlY3RlZExlbmd0aDtcblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBzdGFydE9mZnNldCxcbiAgICBlbmQ6IGVuZE9mZnNldFxuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHJldHVybiB7P29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0TW9kZXJuT2Zmc2V0cyhub2RlKSB7XG4gIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgaWYgKHNlbGVjdGlvbi5yYW5nZUNvdW50ID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3JOb2RlO1xuICB2YXIgYW5jaG9yT2Zmc2V0ID0gc2VsZWN0aW9uLmFuY2hvck9mZnNldDtcbiAgdmFyIGZvY3VzTm9kZSA9IHNlbGVjdGlvbi5mb2N1c05vZGU7XG4gIHZhciBmb2N1c09mZnNldCA9IHNlbGVjdGlvbi5mb2N1c09mZnNldDtcblxuICB2YXIgY3VycmVudFJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG5cbiAgLy8gSWYgdGhlIG5vZGUgYW5kIG9mZnNldCB2YWx1ZXMgYXJlIHRoZSBzYW1lLCB0aGUgc2VsZWN0aW9uIGlzIGNvbGxhcHNlZC5cbiAgLy8gYFNlbGVjdGlvbi5pc0NvbGxhcHNlZGAgaXMgYXZhaWxhYmxlIG5hdGl2ZWx5LCBidXQgSUUgc29tZXRpbWVzIGdldHNcbiAgLy8gdGhpcyB2YWx1ZSB3cm9uZy5cbiAgdmFyIGlzU2VsZWN0aW9uQ29sbGFwc2VkID0gaXNDb2xsYXBzZWQoXG4gICAgc2VsZWN0aW9uLmFuY2hvck5vZGUsXG4gICAgc2VsZWN0aW9uLmFuY2hvck9mZnNldCxcbiAgICBzZWxlY3Rpb24uZm9jdXNOb2RlLFxuICAgIHNlbGVjdGlvbi5mb2N1c09mZnNldFxuICApO1xuXG4gIHZhciByYW5nZUxlbmd0aCA9IGlzU2VsZWN0aW9uQ29sbGFwc2VkID8gMCA6IGN1cnJlbnRSYW5nZS50b1N0cmluZygpLmxlbmd0aDtcblxuICB2YXIgdGVtcFJhbmdlID0gY3VycmVudFJhbmdlLmNsb25lUmFuZ2UoKTtcbiAgdGVtcFJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyhub2RlKTtcbiAgdGVtcFJhbmdlLnNldEVuZChjdXJyZW50UmFuZ2Uuc3RhcnRDb250YWluZXIsIGN1cnJlbnRSYW5nZS5zdGFydE9mZnNldCk7XG5cbiAgdmFyIGlzVGVtcFJhbmdlQ29sbGFwc2VkID0gaXNDb2xsYXBzZWQoXG4gICAgdGVtcFJhbmdlLnN0YXJ0Q29udGFpbmVyLFxuICAgIHRlbXBSYW5nZS5zdGFydE9mZnNldCxcbiAgICB0ZW1wUmFuZ2UuZW5kQ29udGFpbmVyLFxuICAgIHRlbXBSYW5nZS5lbmRPZmZzZXRcbiAgKTtcblxuICB2YXIgc3RhcnQgPSBpc1RlbXBSYW5nZUNvbGxhcHNlZCA/IDAgOiB0ZW1wUmFuZ2UudG9TdHJpbmcoKS5sZW5ndGg7XG4gIHZhciBlbmQgPSBzdGFydCArIHJhbmdlTGVuZ3RoO1xuXG4gIC8vIERldGVjdCB3aGV0aGVyIHRoZSBzZWxlY3Rpb24gaXMgYmFja3dhcmQuXG4gIHZhciBkZXRlY3Rpb25SYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gIGRldGVjdGlvblJhbmdlLnNldFN0YXJ0KGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCk7XG4gIGRldGVjdGlvblJhbmdlLnNldEVuZChmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KTtcbiAgdmFyIGlzQmFja3dhcmQgPSBkZXRlY3Rpb25SYW5nZS5jb2xsYXBzZWQ7XG4gIGRldGVjdGlvblJhbmdlLmRldGFjaCgpO1xuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IGlzQmFja3dhcmQgPyBlbmQgOiBzdGFydCxcbiAgICBlbmQ6IGlzQmFja3dhcmQgPyBzdGFydCA6IGVuZFxuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtvYmplY3R9IG9mZnNldHNcbiAqL1xuZnVuY3Rpb24gc2V0SUVPZmZzZXRzKG5vZGUsIG9mZnNldHMpIHtcbiAgdmFyIHJhbmdlID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCkuZHVwbGljYXRlKCk7XG4gIHZhciBzdGFydCwgZW5kO1xuXG4gIGlmICh0eXBlb2Ygb2Zmc2V0cy5lbmQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgc3RhcnQgPSBvZmZzZXRzLnN0YXJ0O1xuICAgIGVuZCA9IHN0YXJ0O1xuICB9IGVsc2UgaWYgKG9mZnNldHMuc3RhcnQgPiBvZmZzZXRzLmVuZCkge1xuICAgIHN0YXJ0ID0gb2Zmc2V0cy5lbmQ7XG4gICAgZW5kID0gb2Zmc2V0cy5zdGFydDtcbiAgfSBlbHNlIHtcbiAgICBzdGFydCA9IG9mZnNldHMuc3RhcnQ7XG4gICAgZW5kID0gb2Zmc2V0cy5lbmQ7XG4gIH1cblxuICByYW5nZS5tb3ZlVG9FbGVtZW50VGV4dChub2RlKTtcbiAgcmFuZ2UubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCBzdGFydCk7XG4gIHJhbmdlLnNldEVuZFBvaW50KCdFbmRUb1N0YXJ0JywgcmFuZ2UpO1xuICByYW5nZS5tb3ZlRW5kKCdjaGFyYWN0ZXInLCBlbmQgLSBzdGFydCk7XG4gIHJhbmdlLnNlbGVjdCgpO1xufVxuXG4vKipcbiAqIEluIG1vZGVybiBub24tSUUgYnJvd3NlcnMsIHdlIGNhbiBzdXBwb3J0IGJvdGggZm9yd2FyZCBhbmQgYmFja3dhcmRcbiAqIHNlbGVjdGlvbnMuXG4gKlxuICogTm90ZTogSUUxMCsgc3VwcG9ydHMgdGhlIFNlbGVjdGlvbiBvYmplY3QsIGJ1dCBpdCBkb2VzIG5vdCBzdXBwb3J0XG4gKiB0aGUgYGV4dGVuZGAgbWV0aG9kLCB3aGljaCBtZWFucyB0aGF0IGV2ZW4gaW4gbW9kZXJuIElFLCBpdCdzIG5vdCBwb3NzaWJsZVxuICogdG8gcHJvZ3JhbWF0aWNhbGx5IGNyZWF0ZSBhIGJhY2t3YXJkIHNlbGVjdGlvbi4gVGh1cywgZm9yIGFsbCBJRVxuICogdmVyc2lvbnMsIHdlIHVzZSB0aGUgb2xkIElFIEFQSSB0byBjcmVhdGUgb3VyIHNlbGVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gb2Zmc2V0c1xuICovXG5mdW5jdGlvbiBzZXRNb2Rlcm5PZmZzZXRzKG5vZGUsIG9mZnNldHMpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcblxuICB2YXIgbGVuZ3RoID0gbm9kZVtnZXRUZXh0Q29udGVudEFjY2Vzc29yKCldLmxlbmd0aDtcbiAgdmFyIHN0YXJ0ID0gTWF0aC5taW4ob2Zmc2V0cy5zdGFydCwgbGVuZ3RoKTtcbiAgdmFyIGVuZCA9IHR5cGVvZiBvZmZzZXRzLmVuZCA9PT0gJ3VuZGVmaW5lZCcgP1xuICAgICAgICAgICAgc3RhcnQgOiBNYXRoLm1pbihvZmZzZXRzLmVuZCwgbGVuZ3RoKTtcblxuICAvLyBJRSAxMSB1c2VzIG1vZGVybiBzZWxlY3Rpb24sIGJ1dCBkb2Vzbid0IHN1cHBvcnQgdGhlIGV4dGVuZCBtZXRob2QuXG4gIC8vIEZsaXAgYmFja3dhcmQgc2VsZWN0aW9ucywgc28gd2UgY2FuIHNldCB3aXRoIGEgc2luZ2xlIHJhbmdlLlxuICBpZiAoIXNlbGVjdGlvbi5leHRlbmQgJiYgc3RhcnQgPiBlbmQpIHtcbiAgICB2YXIgdGVtcCA9IGVuZDtcbiAgICBlbmQgPSBzdGFydDtcbiAgICBzdGFydCA9IHRlbXA7XG4gIH1cblxuICB2YXIgc3RhcnRNYXJrZXIgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KG5vZGUsIHN0YXJ0KTtcbiAgdmFyIGVuZE1hcmtlciA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQobm9kZSwgZW5kKTtcblxuICBpZiAoc3RhcnRNYXJrZXIgJiYgZW5kTWFya2VyKSB7XG4gICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICByYW5nZS5zZXRTdGFydChzdGFydE1hcmtlci5ub2RlLCBzdGFydE1hcmtlci5vZmZzZXQpO1xuICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcblxuICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgIHNlbGVjdGlvbi5leHRlbmQoZW5kTWFya2VyLm5vZGUsIGVuZE1hcmtlci5vZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZS5zZXRFbmQoZW5kTWFya2VyLm5vZGUsIGVuZE1hcmtlci5vZmZzZXQpO1xuICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICB9XG5cbiAgICByYW5nZS5kZXRhY2goKTtcbiAgfVxufVxuXG52YXIgdXNlSUVPZmZzZXRzID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmIGRvY3VtZW50LnNlbGVjdGlvbjtcblxudmFyIFJlYWN0RE9NU2VsZWN0aW9uID0ge1xuICAvKipcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gICAqL1xuICBnZXRPZmZzZXRzOiB1c2VJRU9mZnNldHMgPyBnZXRJRU9mZnNldHMgOiBnZXRNb2Rlcm5PZmZzZXRzLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAgICogQHBhcmFtIHtvYmplY3R9IG9mZnNldHNcbiAgICovXG4gIHNldE9mZnNldHM6IHVzZUlFT2Zmc2V0cyA/IHNldElFT2Zmc2V0cyA6IHNldE1vZGVybk9mZnNldHNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01TZWxlY3Rpb247XG4iLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NVGV4dGFyZWFcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIEF1dG9Gb2N1c01peGluID0gcmVxdWlyZShcIi4vQXV0b0ZvY3VzTWl4aW5cIik7XG52YXIgRE9NUHJvcGVydHlPcGVyYXRpb25zID0gcmVxdWlyZShcIi4vRE9NUHJvcGVydHlPcGVyYXRpb25zXCIpO1xudmFyIExpbmtlZFZhbHVlVXRpbHMgPSByZXF1aXJlKFwiLi9MaW5rZWRWYWx1ZVV0aWxzXCIpO1xudmFyIFJlYWN0QnJvd3NlckNvbXBvbmVudE1peGluID0gcmVxdWlyZShcIi4vUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW5cIik7XG52YXIgUmVhY3RDb21wb3NpdGVDb21wb25lbnQgPSByZXF1aXJlKFwiLi9SZWFjdENvbXBvc2l0ZUNvbXBvbmVudFwiKTtcbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoXCIuL1JlYWN0RE9NXCIpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xudmFyIG1lcmdlID0gcmVxdWlyZShcIi4vbWVyZ2VcIik7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZShcIi4vd2FybmluZ1wiKTtcblxuLy8gU3RvcmUgYSByZWZlcmVuY2UgdG8gdGhlIDx0ZXh0YXJlYT4gYFJlYWN0RE9NQ29tcG9uZW50YC5cbnZhciB0ZXh0YXJlYSA9IFJlYWN0RE9NLnRleHRhcmVhO1xuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8dGV4dGFyZWE+IG5hdGl2ZSBjb21wb25lbnQgdGhhdCBhbGxvd3Mgc2V0dGluZyBgdmFsdWVgLCBhbmRcbiAqIGBkZWZhdWx0VmFsdWVgLiBUaGlzIGRpZmZlcnMgZnJvbSB0aGUgdHJhZGl0aW9uYWwgRE9NIEFQSSBiZWNhdXNlIHZhbHVlIGlzXG4gKiB1c3VhbGx5IHNldCBhcyBQQ0RBVEEgY2hpbGRyZW4uXG4gKlxuICogSWYgYHZhbHVlYCBpcyBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zIHRoYXQgYWZmZWN0IHRoZVxuICogdmFsdWUgd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuXG4gKlxuICogSWYgYHZhbHVlYCBpcyBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGxcbiAqIG5vdCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuIEluc3RlYWQsIHRoZSBgdmFsdWVgIHByb3AgbXVzdCBjaGFuZ2UgaW5cbiAqIG9yZGVyIGZvciB0aGUgcmVuZGVyZWQgZWxlbWVudCB0byBiZSB1cGRhdGVkLlxuICpcbiAqIFRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgYmUgaW5pdGlhbGl6ZWQgd2l0aCBhbiBlbXB0eSB2YWx1ZSwgdGhlIHByb3BcbiAqIGBkZWZhdWx0VmFsdWVgIGlmIHNwZWNpZmllZCwgb3IgdGhlIGNoaWxkcmVuIGNvbnRlbnQgKGRlcHJlY2F0ZWQpLlxuICovXG52YXIgUmVhY3RET01UZXh0YXJlYSA9IFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50LmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdSZWFjdERPTVRleHRhcmVhJyxcblxuICBtaXhpbnM6IFtBdXRvRm9jdXNNaXhpbiwgTGlua2VkVmFsdWVVdGlscy5NaXhpbiwgUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW5dLFxuXG4gIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRlZmF1bHRWYWx1ZSA9IHRoaXMucHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgIC8vIFRPRE8gKHl1bmdzdGVycyk6IFJlbW92ZSBzdXBwb3J0IGZvciBjaGlsZHJlbiBjb250ZW50IGluIDx0ZXh0YXJlYT4uXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICBpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyhcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAnVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIGluc3RlYWQgb2Ygc2V0dGluZyAnICtcbiAgICAgICAgICAnY2hpbGRyZW4gb24gPHRleHRhcmVhPi4nXG4gICAgICAgICkgOiBudWxsKTtcbiAgICAgIH1cbiAgICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAgIGRlZmF1bHRWYWx1ZSA9PSBudWxsLFxuICAgICAgICAnSWYgeW91IHN1cHBseSBgZGVmYXVsdFZhbHVlYCBvbiBhIDx0ZXh0YXJlYT4sIGRvIG5vdCBwYXNzIGNoaWxkcmVuLidcbiAgICAgICkgOiBpbnZhcmlhbnQoZGVmYXVsdFZhbHVlID09IG51bGwpKTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgICAgIGNoaWxkcmVuLmxlbmd0aCA8PSAxLFxuICAgICAgICAgICc8dGV4dGFyZWE+IGNhbiBvbmx5IGhhdmUgYXQgbW9zdCBvbmUgY2hpbGQuJ1xuICAgICAgICApIDogaW52YXJpYW50KGNoaWxkcmVuLmxlbmd0aCA8PSAxKSk7XG4gICAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW5bMF07XG4gICAgICB9XG5cbiAgICAgIGRlZmF1bHRWYWx1ZSA9ICcnICsgY2hpbGRyZW47XG4gICAgfVxuICAgIGlmIChkZWZhdWx0VmFsdWUgPT0gbnVsbCkge1xuICAgICAgZGVmYXVsdFZhbHVlID0gJyc7XG4gICAgfVxuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUodGhpcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIFdlIHNhdmUgdGhlIGluaXRpYWwgdmFsdWUgc28gdGhhdCBgUmVhY3RET01Db21wb25lbnRgIGRvZXNuJ3QgdXBkYXRlXG4gICAgICAvLyBgdGV4dENvbnRlbnRgICh1bm5lY2Vzc2FyeSBzaW5jZSB3ZSB1cGRhdGUgdmFsdWUpLlxuICAgICAgLy8gVGhlIGluaXRpYWwgdmFsdWUgY2FuIGJlIGEgYm9vbGVhbiBvciBvYmplY3Qgc28gdGhhdCdzIHdoeSBpdCdzXG4gICAgICAvLyBmb3JjZWQgdG8gYmUgYSBzdHJpbmcuXG4gICAgICBpbml0aWFsVmFsdWU6ICcnICsgKHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IGRlZmF1bHRWYWx1ZSlcbiAgICB9O1xuICB9LFxuXG4gIHNob3VsZENvbXBvbmVudFVwZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgLy8gRGVmZXIgYW55IHVwZGF0ZXMgdG8gdGhpcyBjb21wb25lbnQgZHVyaW5nIHRoZSBgb25DaGFuZ2VgIGhhbmRsZXIuXG4gICAgcmV0dXJuICF0aGlzLl9pc0NoYW5naW5nO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgLy8gQ2xvbmUgYHRoaXMucHJvcHNgIHNvIHdlIGRvbid0IG11dGF0ZSB0aGUgaW5wdXQuXG4gICAgdmFyIHByb3BzID0gbWVyZ2UodGhpcy5wcm9wcyk7XG5cbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT0gbnVsbCxcbiAgICAgICdgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIGRvZXMgbm90IG1ha2Ugc2Vuc2Ugb24gPHRleHRhcmVhPi4nXG4gICAgKSA6IGludmFyaWFudChwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PSBudWxsKSk7XG5cbiAgICBwcm9wcy5kZWZhdWx0VmFsdWUgPSBudWxsO1xuICAgIHByb3BzLnZhbHVlID0gbnVsbDtcbiAgICBwcm9wcy5vbkNoYW5nZSA9IHRoaXMuX2hhbmRsZUNoYW5nZTtcblxuICAgIC8vIEFsd2F5cyBzZXQgY2hpbGRyZW4gdG8gdGhlIHNhbWUgdGhpbmcuIEluIElFOSwgdGhlIHNlbGVjdGlvbiByYW5nZSB3aWxsXG4gICAgLy8gZ2V0IHJlc2V0IGlmIGB0ZXh0Q29udGVudGAgaXMgbXV0YXRlZC5cbiAgICByZXR1cm4gdGV4dGFyZWEocHJvcHMsIHRoaXMuc3RhdGUuaW5pdGlhbFZhbHVlKTtcbiAgfSxcblxuICBjb21wb25lbnREaWRVcGRhdGU6IGZ1bmN0aW9uKHByZXZQcm9wcywgcHJldlN0YXRlLCBwcmV2Q29udGV4dCkge1xuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUodGhpcyk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIHZhciByb290Tm9kZSA9IHRoaXMuZ2V0RE9NTm9kZSgpO1xuICAgICAgLy8gQ2FzdCBgdmFsdWVgIHRvIGEgc3RyaW5nIHRvIGVuc3VyZSB0aGUgdmFsdWUgaXMgc2V0IGNvcnJlY3RseS4gV2hpbGVcbiAgICAgIC8vIGJyb3dzZXJzIHR5cGljYWxseSBkbyB0aGlzIGFzIG5lY2Vzc2FyeSwganNkb20gZG9lc24ndC5cbiAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5zZXRWYWx1ZUZvclByb3BlcnR5KHJvb3ROb2RlLCAndmFsdWUnLCAnJyArIHZhbHVlKTtcbiAgICB9XG4gIH0sXG5cbiAgX2hhbmRsZUNoYW5nZTogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgcmV0dXJuVmFsdWU7XG4gICAgdmFyIG9uQ2hhbmdlID0gTGlua2VkVmFsdWVVdGlscy5nZXRPbkNoYW5nZSh0aGlzKTtcbiAgICBpZiAob25DaGFuZ2UpIHtcbiAgICAgIHRoaXMuX2lzQ2hhbmdpbmcgPSB0cnVlO1xuICAgICAgcmV0dXJuVmFsdWUgPSBvbkNoYW5nZS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgIHRoaXMuX2lzQ2hhbmdpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5zZXRTdGF0ZSh7dmFsdWU6IGV2ZW50LnRhcmdldC52YWx1ZX0pO1xuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVRleHRhcmVhO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZShcIi4vUmVhY3RVcGRhdGVzXCIpO1xudmFyIFRyYW5zYWN0aW9uID0gcmVxdWlyZShcIi4vVHJhbnNhY3Rpb25cIik7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZShcIi4vZW1wdHlGdW5jdGlvblwiKTtcbnZhciBtaXhJbnRvID0gcmVxdWlyZShcIi4vbWl4SW50b1wiKTtcblxudmFyIFJFU0VUX0JBVENIRURfVVBEQVRFUyA9IHtcbiAgaW5pdGlhbGl6ZTogZW1wdHlGdW5jdGlvbixcbiAgY2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXMgPSBmYWxzZTtcbiAgfVxufTtcblxudmFyIEZMVVNIX0JBVENIRURfVVBEQVRFUyA9IHtcbiAgaW5pdGlhbGl6ZTogZW1wdHlGdW5jdGlvbixcbiAgY2xvc2U6IFJlYWN0VXBkYXRlcy5mbHVzaEJhdGNoZWRVcGRhdGVzLmJpbmQoUmVhY3RVcGRhdGVzKVxufTtcblxudmFyIFRSQU5TQUNUSU9OX1dSQVBQRVJTID0gW0ZMVVNIX0JBVENIRURfVVBEQVRFUywgUkVTRVRfQkFUQ0hFRF9VUERBVEVTXTtcblxuZnVuY3Rpb24gUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneVRyYW5zYWN0aW9uKCkge1xuICB0aGlzLnJlaW5pdGlhbGl6ZVRyYW5zYWN0aW9uKCk7XG59XG5cbm1peEludG8oUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneVRyYW5zYWN0aW9uLCBUcmFuc2FjdGlvbi5NaXhpbik7XG5taXhJbnRvKFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3lUcmFuc2FjdGlvbiwge1xuICBnZXRUcmFuc2FjdGlvbldyYXBwZXJzOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gVFJBTlNBQ1RJT05fV1JBUFBFUlM7XG4gIH1cbn0pO1xuXG52YXIgdHJhbnNhY3Rpb24gPSBuZXcgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneVRyYW5zYWN0aW9uKCk7XG5cbnZhciBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5ID0ge1xuICBpc0JhdGNoaW5nVXBkYXRlczogZmFsc2UsXG5cbiAgLyoqXG4gICAqIENhbGwgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGluIGEgY29udGV4dCB3aXRoaW4gd2hpY2ggY2FsbHMgdG8gYHNldFN0YXRlYFxuICAgKiBhbmQgZnJpZW5kcyBhcmUgYmF0Y2hlZCBzdWNoIHRoYXQgY29tcG9uZW50cyBhcmVuJ3QgdXBkYXRlZCB1bm5lY2Vzc2FyaWx5LlxuICAgKi9cbiAgYmF0Y2hlZFVwZGF0ZXM6IGZ1bmN0aW9uKGNhbGxiYWNrLCBhLCBiKSB7XG4gICAgdmFyIGFscmVhZHlCYXRjaGluZ1VwZGF0ZXMgPSBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzO1xuXG4gICAgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcyA9IHRydWU7XG5cbiAgICAvLyBUaGUgY29kZSBpcyB3cml0dGVuIHRoaXMgd2F5IHRvIGF2b2lkIGV4dHJhIGFsbG9jYXRpb25zXG4gICAgaWYgKGFscmVhZHlCYXRjaGluZ1VwZGF0ZXMpIHtcbiAgICAgIGNhbGxiYWNrKGEsIGIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2FjdGlvbi5wZXJmb3JtKGNhbGxiYWNrLCBudWxsLCBhLCBiKTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneTtcbiIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3REZWZhdWx0SW5qZWN0aW9uXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luID0gcmVxdWlyZShcIi4vQmVmb3JlSW5wdXRFdmVudFBsdWdpblwiKTtcbnZhciBDaGFuZ2VFdmVudFBsdWdpbiA9IHJlcXVpcmUoXCIuL0NoYW5nZUV2ZW50UGx1Z2luXCIpO1xudmFyIENsaWVudFJlYWN0Um9vdEluZGV4ID0gcmVxdWlyZShcIi4vQ2xpZW50UmVhY3RSb290SW5kZXhcIik7XG52YXIgQ29tcG9zaXRpb25FdmVudFBsdWdpbiA9IHJlcXVpcmUoXCIuL0NvbXBvc2l0aW9uRXZlbnRQbHVnaW5cIik7XG52YXIgRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXIgPSByZXF1aXJlKFwiLi9EZWZhdWx0RXZlbnRQbHVnaW5PcmRlclwiKTtcbnZhciBFbnRlckxlYXZlRXZlbnRQbHVnaW4gPSByZXF1aXJlKFwiLi9FbnRlckxlYXZlRXZlbnRQbHVnaW5cIik7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKFwiLi9FeGVjdXRpb25FbnZpcm9ubWVudFwiKTtcbnZhciBIVE1MRE9NUHJvcGVydHlDb25maWcgPSByZXF1aXJlKFwiLi9IVE1MRE9NUHJvcGVydHlDb25maWdcIik7XG52YXIgTW9iaWxlU2FmYXJpQ2xpY2tFdmVudFBsdWdpbiA9IHJlcXVpcmUoXCIuL01vYmlsZVNhZmFyaUNsaWNrRXZlbnRQbHVnaW5cIik7XG52YXIgUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW4gPSByZXF1aXJlKFwiLi9SZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpblwiKTtcbnZhciBSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudCA9XG4gIHJlcXVpcmUoXCIuL1JlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50XCIpO1xudmFyIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kgPSByZXF1aXJlKFwiLi9SZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5XCIpO1xudmFyIFJlYWN0RE9NID0gcmVxdWlyZShcIi4vUmVhY3RET01cIik7XG52YXIgUmVhY3RET01CdXR0b24gPSByZXF1aXJlKFwiLi9SZWFjdERPTUJ1dHRvblwiKTtcbnZhciBSZWFjdERPTUZvcm0gPSByZXF1aXJlKFwiLi9SZWFjdERPTUZvcm1cIik7XG52YXIgUmVhY3RET01JbWcgPSByZXF1aXJlKFwiLi9SZWFjdERPTUltZ1wiKTtcbnZhciBSZWFjdERPTUlucHV0ID0gcmVxdWlyZShcIi4vUmVhY3RET01JbnB1dFwiKTtcbnZhciBSZWFjdERPTU9wdGlvbiA9IHJlcXVpcmUoXCIuL1JlYWN0RE9NT3B0aW9uXCIpO1xudmFyIFJlYWN0RE9NU2VsZWN0ID0gcmVxdWlyZShcIi4vUmVhY3RET01TZWxlY3RcIik7XG52YXIgUmVhY3RET01UZXh0YXJlYSA9IHJlcXVpcmUoXCIuL1JlYWN0RE9NVGV4dGFyZWFcIik7XG52YXIgUmVhY3RFdmVudExpc3RlbmVyID0gcmVxdWlyZShcIi4vUmVhY3RFdmVudExpc3RlbmVyXCIpO1xudmFyIFJlYWN0SW5qZWN0aW9uID0gcmVxdWlyZShcIi4vUmVhY3RJbmplY3Rpb25cIik7XG52YXIgUmVhY3RJbnN0YW5jZUhhbmRsZXMgPSByZXF1aXJlKFwiLi9SZWFjdEluc3RhbmNlSGFuZGxlc1wiKTtcbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZShcIi4vUmVhY3RNb3VudFwiKTtcbnZhciBTZWxlY3RFdmVudFBsdWdpbiA9IHJlcXVpcmUoXCIuL1NlbGVjdEV2ZW50UGx1Z2luXCIpO1xudmFyIFNlcnZlclJlYWN0Um9vdEluZGV4ID0gcmVxdWlyZShcIi4vU2VydmVyUmVhY3RSb290SW5kZXhcIik7XG52YXIgU2ltcGxlRXZlbnRQbHVnaW4gPSByZXF1aXJlKFwiLi9TaW1wbGVFdmVudFBsdWdpblwiKTtcbnZhciBTVkdET01Qcm9wZXJ0eUNvbmZpZyA9IHJlcXVpcmUoXCIuL1NWR0RPTVByb3BlcnR5Q29uZmlnXCIpO1xuXG52YXIgY3JlYXRlRnVsbFBhZ2VDb21wb25lbnQgPSByZXF1aXJlKFwiLi9jcmVhdGVGdWxsUGFnZUNvbXBvbmVudFwiKTtcblxuZnVuY3Rpb24gaW5qZWN0KCkge1xuICBSZWFjdEluamVjdGlvbi5FdmVudEVtaXR0ZXIuaW5qZWN0UmVhY3RFdmVudExpc3RlbmVyKFxuICAgIFJlYWN0RXZlbnRMaXN0ZW5lclxuICApO1xuXG4gIC8qKlxuICAgKiBJbmplY3QgbW9kdWxlcyBmb3IgcmVzb2x2aW5nIERPTSBoaWVyYXJjaHkgYW5kIHBsdWdpbiBvcmRlcmluZy5cbiAgICovXG4gIFJlYWN0SW5qZWN0aW9uLkV2ZW50UGx1Z2luSHViLmluamVjdEV2ZW50UGx1Z2luT3JkZXIoRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXIpO1xuICBSZWFjdEluamVjdGlvbi5FdmVudFBsdWdpbkh1Yi5pbmplY3RJbnN0YW5jZUhhbmRsZShSZWFjdEluc3RhbmNlSGFuZGxlcyk7XG4gIFJlYWN0SW5qZWN0aW9uLkV2ZW50UGx1Z2luSHViLmluamVjdE1vdW50KFJlYWN0TW91bnQpO1xuXG4gIC8qKlxuICAgKiBTb21lIGltcG9ydGFudCBldmVudCBwbHVnaW5zIGluY2x1ZGVkIGJ5IGRlZmF1bHQgKHdpdGhvdXQgaGF2aW5nIHRvIHJlcXVpcmVcbiAgICogdGhlbSkuXG4gICAqL1xuICBSZWFjdEluamVjdGlvbi5FdmVudFBsdWdpbkh1Yi5pbmplY3RFdmVudFBsdWdpbnNCeU5hbWUoe1xuICAgIFNpbXBsZUV2ZW50UGx1Z2luOiBTaW1wbGVFdmVudFBsdWdpbixcbiAgICBFbnRlckxlYXZlRXZlbnRQbHVnaW46IEVudGVyTGVhdmVFdmVudFBsdWdpbixcbiAgICBDaGFuZ2VFdmVudFBsdWdpbjogQ2hhbmdlRXZlbnRQbHVnaW4sXG4gICAgQ29tcG9zaXRpb25FdmVudFBsdWdpbjogQ29tcG9zaXRpb25FdmVudFBsdWdpbixcbiAgICBNb2JpbGVTYWZhcmlDbGlja0V2ZW50UGx1Z2luOiBNb2JpbGVTYWZhcmlDbGlja0V2ZW50UGx1Z2luLFxuICAgIFNlbGVjdEV2ZW50UGx1Z2luOiBTZWxlY3RFdmVudFBsdWdpbixcbiAgICBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luOiBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luXG4gIH0pO1xuXG4gIFJlYWN0SW5qZWN0aW9uLkRPTS5pbmplY3RDb21wb25lbnRDbGFzc2VzKHtcbiAgICBidXR0b246IFJlYWN0RE9NQnV0dG9uLFxuICAgIGZvcm06IFJlYWN0RE9NRm9ybSxcbiAgICBpbWc6IFJlYWN0RE9NSW1nLFxuICAgIGlucHV0OiBSZWFjdERPTUlucHV0LFxuICAgIG9wdGlvbjogUmVhY3RET01PcHRpb24sXG4gICAgc2VsZWN0OiBSZWFjdERPTVNlbGVjdCxcbiAgICB0ZXh0YXJlYTogUmVhY3RET01UZXh0YXJlYSxcblxuICAgIGh0bWw6IGNyZWF0ZUZ1bGxQYWdlQ29tcG9uZW50KFJlYWN0RE9NLmh0bWwpLFxuICAgIGhlYWQ6IGNyZWF0ZUZ1bGxQYWdlQ29tcG9uZW50KFJlYWN0RE9NLmhlYWQpLFxuICAgIGJvZHk6IGNyZWF0ZUZ1bGxQYWdlQ29tcG9uZW50KFJlYWN0RE9NLmJvZHkpXG4gIH0pO1xuXG4gIC8vIFRoaXMgbmVlZHMgdG8gaGFwcGVuIGFmdGVyIGNyZWF0ZUZ1bGxQYWdlQ29tcG9uZW50KCkgb3RoZXJ3aXNlIHRoZSBtaXhpblxuICAvLyBnZXRzIGRvdWJsZSBpbmplY3RlZC5cbiAgUmVhY3RJbmplY3Rpb24uQ29tcG9zaXRlQ29tcG9uZW50LmluamVjdE1peGluKFJlYWN0QnJvd3NlckNvbXBvbmVudE1peGluKTtcblxuICBSZWFjdEluamVjdGlvbi5ET01Qcm9wZXJ0eS5pbmplY3RET01Qcm9wZXJ0eUNvbmZpZyhIVE1MRE9NUHJvcGVydHlDb25maWcpO1xuICBSZWFjdEluamVjdGlvbi5ET01Qcm9wZXJ0eS5pbmplY3RET01Qcm9wZXJ0eUNvbmZpZyhTVkdET01Qcm9wZXJ0eUNvbmZpZyk7XG5cbiAgUmVhY3RJbmplY3Rpb24uRW1wdHlDb21wb25lbnQuaW5qZWN0RW1wdHlDb21wb25lbnQoUmVhY3RET00ubm9zY3JpcHQpO1xuXG4gIFJlYWN0SW5qZWN0aW9uLlVwZGF0ZXMuaW5qZWN0UmVjb25jaWxlVHJhbnNhY3Rpb24oXG4gICAgUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvblxuICApO1xuICBSZWFjdEluamVjdGlvbi5VcGRhdGVzLmluamVjdEJhdGNoaW5nU3RyYXRlZ3koXG4gICAgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneVxuICApO1xuXG4gIFJlYWN0SW5qZWN0aW9uLlJvb3RJbmRleC5pbmplY3RDcmVhdGVSZWFjdFJvb3RJbmRleChcbiAgICBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gP1xuICAgICAgQ2xpZW50UmVhY3RSb290SW5kZXguY3JlYXRlUmVhY3RSb290SW5kZXggOlxuICAgICAgU2VydmVyUmVhY3RSb290SW5kZXguY3JlYXRlUmVhY3RSb290SW5kZXhcbiAgKTtcblxuICBSZWFjdEluamVjdGlvbi5Db21wb25lbnQuaW5qZWN0RW52aXJvbm1lbnQoUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQpO1xuXG4gIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICB2YXIgdXJsID0gKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiB3aW5kb3cubG9jYXRpb24uaHJlZikgfHwgJyc7XG4gICAgaWYgKCgvWz8mXXJlYWN0X3BlcmZcXGIvKS50ZXN0KHVybCkpIHtcbiAgICAgIHZhciBSZWFjdERlZmF1bHRQZXJmID0gcmVxdWlyZShcIi4vUmVhY3REZWZhdWx0UGVyZlwiKTtcbiAgICAgIFJlYWN0RGVmYXVsdFBlcmYuc3RhcnQoKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGluamVjdDogaW5qZWN0XG59O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3REZWZhdWx0UGVyZlxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZShcIi4vRE9NUHJvcGVydHlcIik7XG52YXIgUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzID0gcmVxdWlyZShcIi4vUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzXCIpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKFwiLi9SZWFjdE1vdW50XCIpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoXCIuL1JlYWN0UGVyZlwiKTtcblxudmFyIHBlcmZvcm1hbmNlTm93ID0gcmVxdWlyZShcIi4vcGVyZm9ybWFuY2VOb3dcIik7XG5cbmZ1bmN0aW9uIHJvdW5kRmxvYXQodmFsKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKHZhbCAqIDEwMCkgLyAxMDA7XG59XG5cbmZ1bmN0aW9uIGFkZFZhbHVlKG9iaiwga2V5LCB2YWwpIHtcbiAgb2JqW2tleV0gPSAob2JqW2tleV0gfHwgMCkgKyB2YWw7XG59XG5cbnZhciBSZWFjdERlZmF1bHRQZXJmID0ge1xuICBfYWxsTWVhc3VyZW1lbnRzOiBbXSwgLy8gbGFzdCBpdGVtIGluIHRoZSBsaXN0IGlzIHRoZSBjdXJyZW50IG9uZVxuICBfbW91bnRTdGFjazogWzBdLFxuICBfaW5qZWN0ZWQ6IGZhbHNlLFxuXG4gIHN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIVJlYWN0RGVmYXVsdFBlcmYuX2luamVjdGVkKSB7XG4gICAgICBSZWFjdFBlcmYuaW5qZWN0aW9uLmluamVjdE1lYXN1cmUoUmVhY3REZWZhdWx0UGVyZi5tZWFzdXJlKTtcbiAgICB9XG5cbiAgICBSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHMubGVuZ3RoID0gMDtcbiAgICBSZWFjdFBlcmYuZW5hYmxlTWVhc3VyZSA9IHRydWU7XG4gIH0sXG5cbiAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgUmVhY3RQZXJmLmVuYWJsZU1lYXN1cmUgPSBmYWxzZTtcbiAgfSxcblxuICBnZXRMYXN0TWVhc3VyZW1lbnRzOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzO1xuICB9LFxuXG4gIHByaW50RXhjbHVzaXZlOiBmdW5jdGlvbihtZWFzdXJlbWVudHMpIHtcbiAgICBtZWFzdXJlbWVudHMgPSBtZWFzdXJlbWVudHMgfHwgUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzO1xuICAgIHZhciBzdW1tYXJ5ID0gUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzLmdldEV4Y2x1c2l2ZVN1bW1hcnkobWVhc3VyZW1lbnRzKTtcbiAgICBjb25zb2xlLnRhYmxlKHN1bW1hcnkubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICdDb21wb25lbnQgY2xhc3MgbmFtZSc6IGl0ZW0uY29tcG9uZW50TmFtZSxcbiAgICAgICAgJ1RvdGFsIGluY2x1c2l2ZSB0aW1lIChtcyknOiByb3VuZEZsb2F0KGl0ZW0uaW5jbHVzaXZlKSxcbiAgICAgICAgJ0V4Y2x1c2l2ZSBtb3VudCB0aW1lIChtcyknOiByb3VuZEZsb2F0KGl0ZW0uZXhjbHVzaXZlKSxcbiAgICAgICAgJ0V4Y2x1c2l2ZSByZW5kZXIgdGltZSAobXMpJzogcm91bmRGbG9hdChpdGVtLnJlbmRlciksXG4gICAgICAgICdNb3VudCB0aW1lIHBlciBpbnN0YW5jZSAobXMpJzogcm91bmRGbG9hdChpdGVtLmV4Y2x1c2l2ZSAvIGl0ZW0uY291bnQpLFxuICAgICAgICAnUmVuZGVyIHRpbWUgcGVyIGluc3RhbmNlIChtcyknOiByb3VuZEZsb2F0KGl0ZW0ucmVuZGVyIC8gaXRlbS5jb3VudCksXG4gICAgICAgICdJbnN0YW5jZXMnOiBpdGVtLmNvdW50XG4gICAgICB9O1xuICAgIH0pKTtcbiAgICAvLyBUT0RPOiBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMuZ2V0VG90YWxUaW1lKCkgZG9lcyBub3QgcmV0dXJuIHRoZSBjb3JyZWN0XG4gICAgLy8gbnVtYmVyLlxuICB9LFxuXG4gIHByaW50SW5jbHVzaXZlOiBmdW5jdGlvbihtZWFzdXJlbWVudHMpIHtcbiAgICBtZWFzdXJlbWVudHMgPSBtZWFzdXJlbWVudHMgfHwgUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzO1xuICAgIHZhciBzdW1tYXJ5ID0gUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzLmdldEluY2x1c2l2ZVN1bW1hcnkobWVhc3VyZW1lbnRzKTtcbiAgICBjb25zb2xlLnRhYmxlKHN1bW1hcnkubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICdPd25lciA+IGNvbXBvbmVudCc6IGl0ZW0uY29tcG9uZW50TmFtZSxcbiAgICAgICAgJ0luY2x1c2l2ZSB0aW1lIChtcyknOiByb3VuZEZsb2F0KGl0ZW0udGltZSksXG4gICAgICAgICdJbnN0YW5jZXMnOiBpdGVtLmNvdW50XG4gICAgICB9O1xuICAgIH0pKTtcbiAgICBjb25zb2xlLmxvZyhcbiAgICAgICdUb3RhbCB0aW1lOicsXG4gICAgICBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMuZ2V0VG90YWxUaW1lKG1lYXN1cmVtZW50cykudG9GaXhlZCgyKSArICcgbXMnXG4gICAgKTtcbiAgfSxcblxuICBwcmludFdhc3RlZDogZnVuY3Rpb24obWVhc3VyZW1lbnRzKSB7XG4gICAgbWVhc3VyZW1lbnRzID0gbWVhc3VyZW1lbnRzIHx8IFJlYWN0RGVmYXVsdFBlcmYuX2FsbE1lYXN1cmVtZW50cztcbiAgICB2YXIgc3VtbWFyeSA9IFJlYWN0RGVmYXVsdFBlcmZBbmFseXNpcy5nZXRJbmNsdXNpdmVTdW1tYXJ5KFxuICAgICAgbWVhc3VyZW1lbnRzLFxuICAgICAgdHJ1ZVxuICAgICk7XG4gICAgY29uc29sZS50YWJsZShzdW1tYXJ5Lm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnT3duZXIgPiBjb21wb25lbnQnOiBpdGVtLmNvbXBvbmVudE5hbWUsXG4gICAgICAgICdXYXN0ZWQgdGltZSAobXMpJzogaXRlbS50aW1lLFxuICAgICAgICAnSW5zdGFuY2VzJzogaXRlbS5jb3VudFxuICAgICAgfTtcbiAgICB9KSk7XG4gICAgY29uc29sZS5sb2coXG4gICAgICAnVG90YWwgdGltZTonLFxuICAgICAgUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzLmdldFRvdGFsVGltZShtZWFzdXJlbWVudHMpLnRvRml4ZWQoMikgKyAnIG1zJ1xuICAgICk7XG4gIH0sXG5cbiAgcHJpbnRET006IGZ1bmN0aW9uKG1lYXN1cmVtZW50cykge1xuICAgIG1lYXN1cmVtZW50cyA9IG1lYXN1cmVtZW50cyB8fCBSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHM7XG4gICAgdmFyIHN1bW1hcnkgPSBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMuZ2V0RE9NU3VtbWFyeShtZWFzdXJlbWVudHMpO1xuICAgIGNvbnNvbGUudGFibGUoc3VtbWFyeS5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgcmVzdWx0W0RPTVByb3BlcnR5LklEX0FUVFJJQlVURV9OQU1FXSA9IGl0ZW0uaWQ7XG4gICAgICByZXN1bHRbJ3R5cGUnXSA9IGl0ZW0udHlwZTtcbiAgICAgIHJlc3VsdFsnYXJncyddID0gSlNPTi5zdHJpbmdpZnkoaXRlbS5hcmdzKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSkpO1xuICAgIGNvbnNvbGUubG9nKFxuICAgICAgJ1RvdGFsIHRpbWU6JyxcbiAgICAgIFJlYWN0RGVmYXVsdFBlcmZBbmFseXNpcy5nZXRUb3RhbFRpbWUobWVhc3VyZW1lbnRzKS50b0ZpeGVkKDIpICsgJyBtcydcbiAgICApO1xuICB9LFxuXG4gIF9yZWNvcmRXcml0ZTogZnVuY3Rpb24oaWQsIGZuTmFtZSwgdG90YWxUaW1lLCBhcmdzKSB7XG4gICAgLy8gVE9ETzogdG90YWxUaW1lIGlzbid0IHRoYXQgdXNlZnVsIHNpbmNlIGl0IGRvZXNuJ3QgY291bnQgcGFpbnRzL3JlZmxvd3NcbiAgICB2YXIgd3JpdGVzID1cbiAgICAgIFJlYWN0RGVmYXVsdFBlcmZcbiAgICAgICAgLl9hbGxNZWFzdXJlbWVudHNbUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzLmxlbmd0aCAtIDFdXG4gICAgICAgIC53cml0ZXM7XG4gICAgd3JpdGVzW2lkXSA9IHdyaXRlc1tpZF0gfHwgW107XG4gICAgd3JpdGVzW2lkXS5wdXNoKHtcbiAgICAgIHR5cGU6IGZuTmFtZSxcbiAgICAgIHRpbWU6IHRvdGFsVGltZSxcbiAgICAgIGFyZ3M6IGFyZ3NcbiAgICB9KTtcbiAgfSxcblxuICBtZWFzdXJlOiBmdW5jdGlvbihtb2R1bGVOYW1lLCBmbk5hbWUsIGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7dmFyIGFyZ3M9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDApO1xuICAgICAgdmFyIHRvdGFsVGltZTtcbiAgICAgIHZhciBydjtcbiAgICAgIHZhciBzdGFydDtcblxuICAgICAgaWYgKGZuTmFtZSA9PT0gJ19yZW5kZXJOZXdSb290Q29tcG9uZW50JyB8fFxuICAgICAgICAgIGZuTmFtZSA9PT0gJ2ZsdXNoQmF0Y2hlZFVwZGF0ZXMnKSB7XG4gICAgICAgIC8vIEEgXCJtZWFzdXJlbWVudFwiIGlzIGEgc2V0IG9mIG1ldHJpY3MgcmVjb3JkZWQgZm9yIGVhY2ggZmx1c2guIFdlIHdhbnRcbiAgICAgICAgLy8gdG8gZ3JvdXAgdGhlIG1ldHJpY3MgZm9yIGEgZ2l2ZW4gZmx1c2ggdG9nZXRoZXIgc28gd2UgY2FuIGxvb2sgYXQgdGhlXG4gICAgICAgIC8vIGNvbXBvbmVudHMgdGhhdCByZW5kZXJlZCBhbmQgdGhlIERPTSBvcGVyYXRpb25zIHRoYXQgYWN0dWFsbHlcbiAgICAgICAgLy8gaGFwcGVuZWQgdG8gZGV0ZXJtaW5lIHRoZSBhbW91bnQgb2YgXCJ3YXN0ZWQgd29ya1wiIHBlcmZvcm1lZC5cbiAgICAgICAgUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzLnB1c2goe1xuICAgICAgICAgIGV4Y2x1c2l2ZToge30sXG4gICAgICAgICAgaW5jbHVzaXZlOiB7fSxcbiAgICAgICAgICByZW5kZXI6IHt9LFxuICAgICAgICAgIGNvdW50czoge30sXG4gICAgICAgICAgd3JpdGVzOiB7fSxcbiAgICAgICAgICBkaXNwbGF5TmFtZXM6IHt9LFxuICAgICAgICAgIHRvdGFsVGltZTogMFxuICAgICAgICB9KTtcbiAgICAgICAgc3RhcnQgPSBwZXJmb3JtYW5jZU5vdygpO1xuICAgICAgICBydiA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIFJlYWN0RGVmYXVsdFBlcmYuX2FsbE1lYXN1cmVtZW50c1tcbiAgICAgICAgICBSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHMubGVuZ3RoIC0gMVxuICAgICAgICBdLnRvdGFsVGltZSA9IHBlcmZvcm1hbmNlTm93KCkgLSBzdGFydDtcbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgfSBlbHNlIGlmIChtb2R1bGVOYW1lID09PSAnUmVhY3RET01JRE9wZXJhdGlvbnMnIHx8XG4gICAgICAgIG1vZHVsZU5hbWUgPT09ICdSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudCcpIHtcbiAgICAgICAgc3RhcnQgPSBwZXJmb3JtYW5jZU5vdygpO1xuICAgICAgICBydiA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIHRvdGFsVGltZSA9IHBlcmZvcm1hbmNlTm93KCkgLSBzdGFydDtcblxuICAgICAgICBpZiAoZm5OYW1lID09PSAnbW91bnRJbWFnZUludG9Ob2RlJykge1xuICAgICAgICAgIHZhciBtb3VudElEID0gUmVhY3RNb3VudC5nZXRJRChhcmdzWzFdKTtcbiAgICAgICAgICBSZWFjdERlZmF1bHRQZXJmLl9yZWNvcmRXcml0ZShtb3VudElELCBmbk5hbWUsIHRvdGFsVGltZSwgYXJnc1swXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZm5OYW1lID09PSAnZGFuZ2Vyb3VzbHlQcm9jZXNzQ2hpbGRyZW5VcGRhdGVzJykge1xuICAgICAgICAgIC8vIHNwZWNpYWwgZm9ybWF0XG4gICAgICAgICAgYXJnc1swXS5mb3JFYWNoKGZ1bmN0aW9uKHVwZGF0ZSkge1xuICAgICAgICAgICAgdmFyIHdyaXRlQXJncyA9IHt9O1xuICAgICAgICAgICAgaWYgKHVwZGF0ZS5mcm9tSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgd3JpdGVBcmdzLmZyb21JbmRleCA9IHVwZGF0ZS5mcm9tSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXBkYXRlLnRvSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgd3JpdGVBcmdzLnRvSW5kZXggPSB1cGRhdGUudG9JbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1cGRhdGUudGV4dENvbnRlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgd3JpdGVBcmdzLnRleHRDb250ZW50ID0gdXBkYXRlLnRleHRDb250ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVwZGF0ZS5tYXJrdXBJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB3cml0ZUFyZ3MubWFya3VwID0gYXJnc1sxXVt1cGRhdGUubWFya3VwSW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUmVhY3REZWZhdWx0UGVyZi5fcmVjb3JkV3JpdGUoXG4gICAgICAgICAgICAgIHVwZGF0ZS5wYXJlbnRJRCxcbiAgICAgICAgICAgICAgdXBkYXRlLnR5cGUsXG4gICAgICAgICAgICAgIHRvdGFsVGltZSxcbiAgICAgICAgICAgICAgd3JpdGVBcmdzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGJhc2ljIGZvcm1hdFxuICAgICAgICAgIFJlYWN0RGVmYXVsdFBlcmYuX3JlY29yZFdyaXRlKFxuICAgICAgICAgICAgYXJnc1swXSxcbiAgICAgICAgICAgIGZuTmFtZSxcbiAgICAgICAgICAgIHRvdGFsVGltZSxcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MsIDEpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnY7XG4gICAgICB9IGVsc2UgaWYgKG1vZHVsZU5hbWUgPT09ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcgJiYgKFxuICAgICAgICBmbk5hbWUgPT09ICdtb3VudENvbXBvbmVudCcgfHxcbiAgICAgICAgZm5OYW1lID09PSAndXBkYXRlQ29tcG9uZW50JyB8fCAvLyBUT0RPOiByZWNlaXZlQ29tcG9uZW50KCk/XG4gICAgICAgIGZuTmFtZSA9PT0gJ19yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQnKSkge1xuXG4gICAgICAgIHZhciByb290Tm9kZUlEID0gZm5OYW1lID09PSAnbW91bnRDb21wb25lbnQnID9cbiAgICAgICAgICBhcmdzWzBdIDpcbiAgICAgICAgICB0aGlzLl9yb290Tm9kZUlEO1xuICAgICAgICB2YXIgaXNSZW5kZXIgPSBmbk5hbWUgPT09ICdfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50JztcbiAgICAgICAgdmFyIGlzTW91bnQgPSBmbk5hbWUgPT09ICdtb3VudENvbXBvbmVudCc7XG5cbiAgICAgICAgdmFyIG1vdW50U3RhY2sgPSBSZWFjdERlZmF1bHRQZXJmLl9tb3VudFN0YWNrO1xuICAgICAgICB2YXIgZW50cnkgPSBSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHNbXG4gICAgICAgICAgUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzLmxlbmd0aCAtIDFcbiAgICAgICAgXTtcblxuICAgICAgICBpZiAoaXNSZW5kZXIpIHtcbiAgICAgICAgICBhZGRWYWx1ZShlbnRyeS5jb3VudHMsIHJvb3ROb2RlSUQsIDEpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTW91bnQpIHtcbiAgICAgICAgICBtb3VudFN0YWNrLnB1c2goMCk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydCA9IHBlcmZvcm1hbmNlTm93KCk7XG4gICAgICAgIHJ2ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgdG90YWxUaW1lID0gcGVyZm9ybWFuY2VOb3coKSAtIHN0YXJ0O1xuXG4gICAgICAgIGlmIChpc1JlbmRlcikge1xuICAgICAgICAgIGFkZFZhbHVlKGVudHJ5LnJlbmRlciwgcm9vdE5vZGVJRCwgdG90YWxUaW1lKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc01vdW50KSB7XG4gICAgICAgICAgdmFyIHN1Yk1vdW50VGltZSA9IG1vdW50U3RhY2sucG9wKCk7XG4gICAgICAgICAgbW91bnRTdGFja1ttb3VudFN0YWNrLmxlbmd0aCAtIDFdICs9IHRvdGFsVGltZTtcbiAgICAgICAgICBhZGRWYWx1ZShlbnRyeS5leGNsdXNpdmUsIHJvb3ROb2RlSUQsIHRvdGFsVGltZSAtIHN1Yk1vdW50VGltZSk7XG4gICAgICAgICAgYWRkVmFsdWUoZW50cnkuaW5jbHVzaXZlLCByb290Tm9kZUlELCB0b3RhbFRpbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZFZhbHVlKGVudHJ5LmluY2x1c2l2ZSwgcm9vdE5vZGVJRCwgdG90YWxUaW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVudHJ5LmRpc3BsYXlOYW1lc1tyb290Tm9kZUlEXSA9IHtcbiAgICAgICAgICBjdXJyZW50OiB0aGlzLmNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lLFxuICAgICAgICAgIG93bmVyOiB0aGlzLl9vd25lciA/IHRoaXMuX293bmVyLmNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIDogJzxyb290PidcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gcnY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RGVmYXVsdFBlcmY7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzXG4gKi9cblxudmFyIG1lcmdlID0gcmVxdWlyZShcIi4vbWVyZ2VcIik7XG5cbi8vIERvbid0IHRyeSB0byBzYXZlIHVzZXJzIGxlc3MgdGhhbiAxLjJtcyAoYSBudW1iZXIgSSBtYWRlIHVwKVxudmFyIERPTlRfQ0FSRV9USFJFU0hPTEQgPSAxLjI7XG52YXIgRE9NX09QRVJBVElPTl9UWVBFUyA9IHtcbiAgJ21vdW50SW1hZ2VJbnRvTm9kZSc6ICdzZXQgaW5uZXJIVE1MJyxcbiAgSU5TRVJUX01BUktVUDogJ3NldCBpbm5lckhUTUwnLFxuICBNT1ZFX0VYSVNUSU5HOiAnbW92ZScsXG4gIFJFTU9WRV9OT0RFOiAncmVtb3ZlJyxcbiAgVEVYVF9DT05URU5UOiAnc2V0IHRleHRDb250ZW50JyxcbiAgJ3VwZGF0ZVByb3BlcnR5QnlJRCc6ICd1cGRhdGUgYXR0cmlidXRlJyxcbiAgJ2RlbGV0ZVByb3BlcnR5QnlJRCc6ICdkZWxldGUgYXR0cmlidXRlJyxcbiAgJ3VwZGF0ZVN0eWxlc0J5SUQnOiAndXBkYXRlIHN0eWxlcycsXG4gICd1cGRhdGVJbm5lckhUTUxCeUlEJzogJ3NldCBpbm5lckhUTUwnLFxuICAnZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXBCeUlEJzogJ3JlcGxhY2UnXG59O1xuXG5mdW5jdGlvbiBnZXRUb3RhbFRpbWUobWVhc3VyZW1lbnRzKSB7XG4gIC8vIFRPRE86IHJldHVybiBudW1iZXIgb2YgRE9NIG9wcz8gY291bGQgYmUgbWlzbGVhZGluZy5cbiAgLy8gVE9ETzogbWVhc3VyZSBkcm9wcGVkIGZyYW1lcyBhZnRlciByZWNvbmNpbGU/XG4gIC8vIFRPRE86IGxvZyB0b3RhbCB0aW1lIG9mIGVhY2ggcmVjb25jaWxlIGFuZCB0aGUgdG9wLWxldmVsIGNvbXBvbmVudFxuICAvLyBjbGFzcyB0aGF0IHRyaWdnZXJlZCBpdC5cbiAgdmFyIHRvdGFsVGltZSA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWVhc3VyZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG1lYXN1cmVtZW50ID0gbWVhc3VyZW1lbnRzW2ldO1xuICAgIHRvdGFsVGltZSArPSBtZWFzdXJlbWVudC50b3RhbFRpbWU7XG4gIH1cbiAgcmV0dXJuIHRvdGFsVGltZTtcbn1cblxuZnVuY3Rpb24gZ2V0RE9NU3VtbWFyeShtZWFzdXJlbWVudHMpIHtcbiAgdmFyIGl0ZW1zID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWVhc3VyZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG1lYXN1cmVtZW50ID0gbWVhc3VyZW1lbnRzW2ldO1xuICAgIHZhciBpZDtcblxuICAgIGZvciAoaWQgaW4gbWVhc3VyZW1lbnQud3JpdGVzKSB7XG4gICAgICBtZWFzdXJlbWVudC53cml0ZXNbaWRdLmZvckVhY2goZnVuY3Rpb24od3JpdGUpIHtcbiAgICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgIHR5cGU6IERPTV9PUEVSQVRJT05fVFlQRVNbd3JpdGUudHlwZV0gfHwgd3JpdGUudHlwZSxcbiAgICAgICAgICBhcmdzOiB3cml0ZS5hcmdzXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBpdGVtcztcbn1cblxuZnVuY3Rpb24gZ2V0RXhjbHVzaXZlU3VtbWFyeShtZWFzdXJlbWVudHMpIHtcbiAgdmFyIGNhbmRpZGF0ZXMgPSB7fTtcbiAgdmFyIGRpc3BsYXlOYW1lO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWVhc3VyZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG1lYXN1cmVtZW50ID0gbWVhc3VyZW1lbnRzW2ldO1xuICAgIHZhciBhbGxJRHMgPSBtZXJnZShtZWFzdXJlbWVudC5leGNsdXNpdmUsIG1lYXN1cmVtZW50LmluY2x1c2l2ZSk7XG5cbiAgICBmb3IgKHZhciBpZCBpbiBhbGxJRHMpIHtcbiAgICAgIGRpc3BsYXlOYW1lID0gbWVhc3VyZW1lbnQuZGlzcGxheU5hbWVzW2lkXS5jdXJyZW50O1xuXG4gICAgICBjYW5kaWRhdGVzW2Rpc3BsYXlOYW1lXSA9IGNhbmRpZGF0ZXNbZGlzcGxheU5hbWVdIHx8IHtcbiAgICAgICAgY29tcG9uZW50TmFtZTogZGlzcGxheU5hbWUsXG4gICAgICAgIGluY2x1c2l2ZTogMCxcbiAgICAgICAgZXhjbHVzaXZlOiAwLFxuICAgICAgICByZW5kZXI6IDAsXG4gICAgICAgIGNvdW50OiAwXG4gICAgICB9O1xuICAgICAgaWYgKG1lYXN1cmVtZW50LnJlbmRlcltpZF0pIHtcbiAgICAgICAgY2FuZGlkYXRlc1tkaXNwbGF5TmFtZV0ucmVuZGVyICs9IG1lYXN1cmVtZW50LnJlbmRlcltpZF07XG4gICAgICB9XG4gICAgICBpZiAobWVhc3VyZW1lbnQuZXhjbHVzaXZlW2lkXSkge1xuICAgICAgICBjYW5kaWRhdGVzW2Rpc3BsYXlOYW1lXS5leGNsdXNpdmUgKz0gbWVhc3VyZW1lbnQuZXhjbHVzaXZlW2lkXTtcbiAgICAgIH1cbiAgICAgIGlmIChtZWFzdXJlbWVudC5pbmNsdXNpdmVbaWRdKSB7XG4gICAgICAgIGNhbmRpZGF0ZXNbZGlzcGxheU5hbWVdLmluY2x1c2l2ZSArPSBtZWFzdXJlbWVudC5pbmNsdXNpdmVbaWRdO1xuICAgICAgfVxuICAgICAgaWYgKG1lYXN1cmVtZW50LmNvdW50c1tpZF0pIHtcbiAgICAgICAgY2FuZGlkYXRlc1tkaXNwbGF5TmFtZV0uY291bnQgKz0gbWVhc3VyZW1lbnQuY291bnRzW2lkXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBOb3cgbWFrZSBhIHNvcnRlZCBhcnJheSB3aXRoIHRoZSByZXN1bHRzLlxuICB2YXIgYXJyID0gW107XG4gIGZvciAoZGlzcGxheU5hbWUgaW4gY2FuZGlkYXRlcykge1xuICAgIGlmIChjYW5kaWRhdGVzW2Rpc3BsYXlOYW1lXS5leGNsdXNpdmUgPj0gRE9OVF9DQVJFX1RIUkVTSE9MRCkge1xuICAgICAgYXJyLnB1c2goY2FuZGlkYXRlc1tkaXNwbGF5TmFtZV0pO1xuICAgIH1cbiAgfVxuXG4gIGFyci5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gYi5leGNsdXNpdmUgLSBhLmV4Y2x1c2l2ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGFycjtcbn1cblxuZnVuY3Rpb24gZ2V0SW5jbHVzaXZlU3VtbWFyeShtZWFzdXJlbWVudHMsIG9ubHlDbGVhbikge1xuICB2YXIgY2FuZGlkYXRlcyA9IHt9O1xuICB2YXIgaW5jbHVzaXZlS2V5O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWVhc3VyZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG1lYXN1cmVtZW50ID0gbWVhc3VyZW1lbnRzW2ldO1xuICAgIHZhciBhbGxJRHMgPSBtZXJnZShtZWFzdXJlbWVudC5leGNsdXNpdmUsIG1lYXN1cmVtZW50LmluY2x1c2l2ZSk7XG4gICAgdmFyIGNsZWFuQ29tcG9uZW50cztcblxuICAgIGlmIChvbmx5Q2xlYW4pIHtcbiAgICAgIGNsZWFuQ29tcG9uZW50cyA9IGdldFVuY2hhbmdlZENvbXBvbmVudHMobWVhc3VyZW1lbnQpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGlkIGluIGFsbElEcykge1xuICAgICAgaWYgKG9ubHlDbGVhbiAmJiAhY2xlYW5Db21wb25lbnRzW2lkXSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gbWVhc3VyZW1lbnQuZGlzcGxheU5hbWVzW2lkXTtcblxuICAgICAgLy8gSW5jbHVzaXZlIHRpbWUgaXMgbm90IHVzZWZ1bCBmb3IgbWFueSBjb21wb25lbnRzIHdpdGhvdXQga25vd2luZyB3aGVyZVxuICAgICAgLy8gdGhleSBhcmUgaW5zdGFudGlhdGVkLiBTbyB3ZSBhZ2dyZWdhdGUgaW5jbHVzaXZlIHRpbWUgd2l0aCBib3RoIHRoZVxuICAgICAgLy8gb3duZXIgYW5kIGN1cnJlbnQgZGlzcGxheU5hbWUgYXMgdGhlIGtleS5cbiAgICAgIGluY2x1c2l2ZUtleSA9IGRpc3BsYXlOYW1lLm93bmVyICsgJyA+ICcgKyBkaXNwbGF5TmFtZS5jdXJyZW50O1xuXG4gICAgICBjYW5kaWRhdGVzW2luY2x1c2l2ZUtleV0gPSBjYW5kaWRhdGVzW2luY2x1c2l2ZUtleV0gfHwge1xuICAgICAgICBjb21wb25lbnROYW1lOiBpbmNsdXNpdmVLZXksXG4gICAgICAgIHRpbWU6IDAsXG4gICAgICAgIGNvdW50OiAwXG4gICAgICB9O1xuXG4gICAgICBpZiAobWVhc3VyZW1lbnQuaW5jbHVzaXZlW2lkXSkge1xuICAgICAgICBjYW5kaWRhdGVzW2luY2x1c2l2ZUtleV0udGltZSArPSBtZWFzdXJlbWVudC5pbmNsdXNpdmVbaWRdO1xuICAgICAgfVxuICAgICAgaWYgKG1lYXN1cmVtZW50LmNvdW50c1tpZF0pIHtcbiAgICAgICAgY2FuZGlkYXRlc1tpbmNsdXNpdmVLZXldLmNvdW50ICs9IG1lYXN1cmVtZW50LmNvdW50c1tpZF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gTm93IG1ha2UgYSBzb3J0ZWQgYXJyYXkgd2l0aCB0aGUgcmVzdWx0cy5cbiAgdmFyIGFyciA9IFtdO1xuICBmb3IgKGluY2x1c2l2ZUtleSBpbiBjYW5kaWRhdGVzKSB7XG4gICAgaWYgKGNhbmRpZGF0ZXNbaW5jbHVzaXZlS2V5XS50aW1lID49IERPTlRfQ0FSRV9USFJFU0hPTEQpIHtcbiAgICAgIGFyci5wdXNoKGNhbmRpZGF0ZXNbaW5jbHVzaXZlS2V5XSk7XG4gICAgfVxuICB9XG5cbiAgYXJyLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBiLnRpbWUgLSBhLnRpbWU7XG4gIH0pO1xuXG4gIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uIGdldFVuY2hhbmdlZENvbXBvbmVudHMobWVhc3VyZW1lbnQpIHtcbiAgLy8gRm9yIGEgZ2l2ZW4gcmVjb25jaWxlLCBsb29rIGF0IHdoaWNoIGNvbXBvbmVudHMgZGlkIG5vdCBhY3R1YWxseVxuICAvLyByZW5kZXIgYW55dGhpbmcgdG8gdGhlIERPTSBhbmQgcmV0dXJuIGEgbWFwcGluZyBvZiB0aGVpciBJRCB0b1xuICAvLyB0aGUgYW1vdW50IG9mIHRpbWUgaXQgdG9vayB0byByZW5kZXIgdGhlIGVudGlyZSBzdWJ0cmVlLlxuICB2YXIgY2xlYW5Db21wb25lbnRzID0ge307XG4gIHZhciBkaXJ0eUxlYWZJRHMgPSBPYmplY3Qua2V5cyhtZWFzdXJlbWVudC53cml0ZXMpO1xuICB2YXIgYWxsSURzID0gbWVyZ2UobWVhc3VyZW1lbnQuZXhjbHVzaXZlLCBtZWFzdXJlbWVudC5pbmNsdXNpdmUpO1xuXG4gIGZvciAodmFyIGlkIGluIGFsbElEcykge1xuICAgIHZhciBpc0RpcnR5ID0gZmFsc2U7XG4gICAgLy8gRm9yIGVhY2ggY29tcG9uZW50IHRoYXQgcmVuZGVyZWQsIHNlZSBpZiBhIGNvbXBvbmVudCB0aGF0IHRyaWdnZXJkXG4gICAgLy8gYSBET00gb3AgaXMgaW4gaXRzIHN1YnRyZWUuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJ0eUxlYWZJRHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChkaXJ0eUxlYWZJRHNbaV0uaW5kZXhPZihpZCkgPT09IDApIHtcbiAgICAgICAgaXNEaXJ0eSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWlzRGlydHkgJiYgbWVhc3VyZW1lbnQuY291bnRzW2lkXSA+IDApIHtcbiAgICAgIGNsZWFuQ29tcG9uZW50c1tpZF0gPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2xlYW5Db21wb25lbnRzO1xufVxuXG52YXIgUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzID0ge1xuICBnZXRFeGNsdXNpdmVTdW1tYXJ5OiBnZXRFeGNsdXNpdmVTdW1tYXJ5LFxuICBnZXRJbmNsdXNpdmVTdW1tYXJ5OiBnZXRJbmNsdXNpdmVTdW1tYXJ5LFxuICBnZXRET01TdW1tYXJ5OiBnZXRET01TdW1tYXJ5LFxuICBnZXRUb3RhbFRpbWU6IGdldFRvdGFsVGltZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXM7XG4iLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERlc2NyaXB0b3JcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIFJlYWN0Q29udGV4dCA9IHJlcXVpcmUoXCIuL1JlYWN0Q29udGV4dFwiKTtcbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoXCIuL1JlYWN0Q3VycmVudE93bmVyXCIpO1xuXG52YXIgbWVyZ2UgPSByZXF1aXJlKFwiLi9tZXJnZVwiKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZShcIi4vd2FybmluZ1wiKTtcblxuLyoqXG4gKiBXYXJuIGZvciBtdXRhdGlvbnMuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKi9cbmZ1bmN0aW9uIGRlZmluZVdhcm5pbmdQcm9wZXJ0eShvYmplY3QsIGtleSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcblxuICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuX3N0b3JlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3N0b3JlW2tleV07XG4gICAgfSxcblxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgJ0RvblxcJ3Qgc2V0IHRoZSAnICsga2V5ICsgJyBwcm9wZXJ0eSBvZiB0aGUgY29tcG9uZW50LiAnICtcbiAgICAgICAgJ011dGF0ZSB0aGUgZXhpc3RpbmcgcHJvcHMgb2JqZWN0IGluc3RlYWQuJ1xuICAgICAgKSA6IG51bGwpO1xuICAgICAgdGhpcy5fc3RvcmVba2V5XSA9IHZhbHVlO1xuICAgIH1cblxuICB9KTtcbn1cblxuLyoqXG4gKiBUaGlzIGlzIHVwZGF0ZWQgdG8gdHJ1ZSBpZiB0aGUgbWVtYnJhbmUgaXMgc3VjY2Vzc2Z1bGx5IGNyZWF0ZWQuXG4gKi9cbnZhciB1c2VNdXRhdGlvbk1lbWJyYW5lID0gZmFsc2U7XG5cbi8qKlxuICogV2FybiBmb3IgbXV0YXRpb25zLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtvYmplY3R9IGRlc2NyaXB0b3JcbiAqL1xuZnVuY3Rpb24gZGVmaW5lTXV0YXRpb25NZW1icmFuZShwcm90b3R5cGUpIHtcbiAgdHJ5IHtcbiAgICB2YXIgcHNldWRvRnJvemVuUHJvcGVydGllcyA9IHtcbiAgICAgIHByb3BzOiB0cnVlXG4gICAgfTtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHNldWRvRnJvemVuUHJvcGVydGllcykge1xuICAgICAgZGVmaW5lV2FybmluZ1Byb3BlcnR5KHByb3RvdHlwZSwga2V5KTtcbiAgICB9XG4gICAgdXNlTXV0YXRpb25NZW1icmFuZSA9IHRydWU7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICAvLyBJRSB3aWxsIGZhaWwgb24gZGVmaW5lUHJvcGVydHlcbiAgfVxufVxuXG4vKipcbiAqIFRyYW5zZmVyIHN0YXRpYyBwcm9wZXJ0aWVzIGZyb20gdGhlIHNvdXJjZSB0byB0aGUgdGFyZ2V0LiBGdW5jdGlvbnMgYXJlXG4gKiByZWJvdW5kIHRvIGhhdmUgdGhpcyByZWZsZWN0IHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKi9cbmZ1bmN0aW9uIHByb3h5U3RhdGljTWV0aG9kcyh0YXJnZXQsIHNvdXJjZSkge1xuICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICB2YXIgdmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIGJvdW5kID0gdmFsdWUuYmluZChzb3VyY2UpO1xuICAgICAgICAvLyBDb3B5IGFueSBwcm9wZXJ0aWVzIGRlZmluZWQgb24gdGhlIGZ1bmN0aW9uLCBzdWNoIGFzIGBpc1JlcXVpcmVkYCBvblxuICAgICAgICAvLyBhIFByb3BUeXBlcyB2YWxpZGF0b3IuIChtZXJnZUludG8gcmVmdXNlcyB0byB3b3JrIG9uIGZ1bmN0aW9ucy4pXG4gICAgICAgIGZvciAodmFyIGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICBpZiAodmFsdWUuaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgIGJvdW5kW2tdID0gdmFsdWVba107XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRhcmdldFtrZXldID0gYm91bmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEJhc2UgY29uc3RydWN0b3IgZm9yIGFsbCBSZWFjdCBkZXNjcmlwdG9ycy4gVGhpcyBpcyBvbmx5IHVzZWQgdG8gbWFrZSB0aGlzXG4gKiB3b3JrIHdpdGggYSBkeW5hbWljIGluc3RhbmNlb2YgY2hlY2suIE5vdGhpbmcgc2hvdWxkIGxpdmUgb24gdGhpcyBwcm90b3R5cGUuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0RGVzY3JpcHRvciA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgZGVmaW5lTXV0YXRpb25NZW1icmFuZShSZWFjdERlc2NyaXB0b3IucHJvdG90eXBlKTtcbn1cblxuUmVhY3REZXNjcmlwdG9yLmNyZWF0ZUZhY3RvcnkgPSBmdW5jdGlvbih0eXBlKSB7XG5cbiAgdmFyIGRlc2NyaXB0b3JQcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFJlYWN0RGVzY3JpcHRvci5wcm90b3R5cGUpO1xuXG4gIHZhciBmYWN0b3J5ID0gZnVuY3Rpb24ocHJvcHMsIGNoaWxkcmVuKSB7XG4gICAgLy8gRm9yIGNvbnNpc3RlbmN5IHdlIGN1cnJlbnRseSBhbGxvY2F0ZSBhIG5ldyBvYmplY3QgZm9yIGV2ZXJ5IGRlc2NyaXB0b3IuXG4gICAgLy8gVGhpcyBwcm90ZWN0cyB0aGUgZGVzY3JpcHRvciBmcm9tIGJlaW5nIG11dGF0ZWQgYnkgdGhlIG9yaWdpbmFsIHByb3BzXG4gICAgLy8gb2JqZWN0IGJlaW5nIG11dGF0ZWQuIEl0IGFsc28gcHJvdGVjdHMgdGhlIG9yaWdpbmFsIHByb3BzIG9iamVjdCBmcm9tXG4gICAgLy8gYmVpbmcgbXV0YXRlZCBieSBjaGlsZHJlbiBhcmd1bWVudHMgYW5kIGRlZmF1bHQgcHJvcHMuIFRoaXMgYmVoYXZpb3JcbiAgICAvLyBjb21lcyB3aXRoIGEgcGVyZm9ybWFuY2UgY29zdCBhbmQgY291bGQgYmUgZGVwcmVjYXRlZCBpbiB0aGUgZnV0dXJlLlxuICAgIC8vIEl0IGNvdWxkIGFsc28gYmUgb3B0aW1pemVkIHdpdGggYSBzbWFydGVyIEpTWCB0cmFuc2Zvcm0uXG4gICAgaWYgKHByb3BzID09IG51bGwpIHtcbiAgICAgIHByb3BzID0ge307XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcHJvcHMgPT09ICdvYmplY3QnKSB7XG4gICAgICBwcm9wcyA9IG1lcmdlKHByb3BzKTtcbiAgICB9XG5cbiAgICAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gICAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG4gICAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG4gICAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAxXTtcbiAgICAgIH1cbiAgICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSBkZXNjcmlwdG9yIG9iamVjdFxuICAgIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmNyZWF0ZShkZXNjcmlwdG9yUHJvdG90eXBlKTtcblxuICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGRlc2NyaXB0b3IuXG4gICAgZGVzY3JpcHRvci5fb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuXG4gICAgLy8gVE9ETzogRGVwcmVjYXRlIHdpdGhDb250ZXh0LCBhbmQgdGhlbiB0aGUgY29udGV4dCBiZWNvbWVzIGFjY2Vzc2libGVcbiAgICAvLyB0aHJvdWdoIHRoZSBvd25lci5cbiAgICBkZXNjcmlwdG9yLl9jb250ZXh0ID0gUmVhY3RDb250ZXh0LmN1cnJlbnQ7XG5cbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGFuZCBwcm9wcyBhcmUgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgdGhlbSBvblxuICAgICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgICAgZGVzY3JpcHRvci5fc3RvcmUgPSB7IHZhbGlkYXRlZDogZmFsc2UsIHByb3BzOiBwcm9wcyB9O1xuXG4gICAgICAvLyBXZSdyZSBub3QgYWxsb3dlZCB0byBzZXQgcHJvcHMgZGlyZWN0bHkgb24gdGhlIG9iamVjdCBzbyB3ZSBlYXJseVxuICAgICAgLy8gcmV0dXJuIGFuZCByZWx5IG9uIHRoZSBwcm90b3R5cGUgbWVtYnJhbmUgdG8gZm9yd2FyZCB0byB0aGUgYmFja2luZ1xuICAgICAgLy8gc3RvcmUuXG4gICAgICBpZiAodXNlTXV0YXRpb25NZW1icmFuZSkge1xuICAgICAgICBPYmplY3QuZnJlZXplKGRlc2NyaXB0b3IpO1xuICAgICAgICByZXR1cm4gZGVzY3JpcHRvcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkZXNjcmlwdG9yLnByb3BzID0gcHJvcHM7XG4gICAgcmV0dXJuIGRlc2NyaXB0b3I7XG4gIH07XG5cbiAgLy8gQ3VycmVudGx5IHdlIGV4cG9zZSB0aGUgcHJvdG90eXBlIG9mIHRoZSBkZXNjcmlwdG9yIHNvIHRoYXRcbiAgLy8gPEZvbyAvPiBpbnN0YW5jZW9mIEZvbyB3b3Jrcy4gVGhpcyBpcyBjb250cm92ZXJzaWFsIHBhdHRlcm4uXG4gIGZhY3RvcnkucHJvdG90eXBlID0gZGVzY3JpcHRvclByb3RvdHlwZTtcblxuICAvLyBFeHBvc2UgdGhlIHR5cGUgb24gdGhlIGZhY3RvcnkgYW5kIHRoZSBwcm90b3R5cGUgc28gdGhhdCBpdCBjYW4gYmVcbiAgLy8gZWFzaWx5IGFjY2Vzc2VkIG9uIGRlc2NyaXB0b3JzLiBFLmcuIDxGb28gLz4udHlwZSA9PT0gRm9vLnR5cGUgYW5kIGZvclxuICAvLyBzdGF0aWMgbWV0aG9kcyBsaWtlIDxGb28gLz4udHlwZS5zdGF0aWNNZXRob2QoKTtcbiAgLy8gVGhpcyBzaG91bGQgbm90IGJlIG5hbWVkIGNvbnN0cnVjdG9yIHNpbmNlIHRoaXMgbWF5IG5vdCBiZSB0aGUgZnVuY3Rpb25cbiAgLy8gdGhhdCBjcmVhdGVkIHRoZSBkZXNjcmlwdG9yLCBhbmQgaXQgbWF5IG5vdCBldmVuIGJlIGEgY29uc3RydWN0b3IuXG4gIGZhY3RvcnkudHlwZSA9IHR5cGU7XG4gIGRlc2NyaXB0b3JQcm90b3R5cGUudHlwZSA9IHR5cGU7XG5cbiAgcHJveHlTdGF0aWNNZXRob2RzKGZhY3RvcnksIHR5cGUpO1xuXG4gIC8vIEV4cG9zZSBhIHVuaXF1ZSBjb25zdHJ1Y3RvciBvbiB0aGUgcHJvdG90eXBlIGlzIHRoYXQgdGhpcyB3b3JrcyB3aXRoIHR5cGVcbiAgLy8gc3lzdGVtcyB0aGF0IGNvbXBhcmUgY29uc3RydWN0b3IgcHJvcGVydGllczogPEZvbyAvPi5jb25zdHJ1Y3RvciA9PT0gRm9vXG4gIC8vIFRoaXMgbWF5IGJlIGNvbnRyb3ZlcnNpYWwgc2luY2UgaXQgcmVxdWlyZXMgYSBrbm93biBmYWN0b3J5IGZ1bmN0aW9uLlxuICBkZXNjcmlwdG9yUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gZmFjdG9yeTtcblxuICByZXR1cm4gZmFjdG9yeTtcblxufTtcblxuUmVhY3REZXNjcmlwdG9yLmNsb25lQW5kUmVwbGFjZVByb3BzID0gZnVuY3Rpb24ob2xkRGVzY3JpcHRvciwgbmV3UHJvcHMpIHtcbiAgdmFyIG5ld0Rlc2NyaXB0b3IgPSBPYmplY3QuY3JlYXRlKG9sZERlc2NyaXB0b3IuY29uc3RydWN0b3IucHJvdG90eXBlKTtcbiAgLy8gSXQncyBpbXBvcnRhbnQgdGhhdCB0aGlzIHByb3BlcnR5IG9yZGVyIG1hdGNoZXMgdGhlIGhpZGRlbiBjbGFzcyBvZiB0aGVcbiAgLy8gb3JpZ2luYWwgZGVzY3JpcHRvciB0byBtYWludGFpbiBwZXJmLlxuICBuZXdEZXNjcmlwdG9yLl9vd25lciA9IG9sZERlc2NyaXB0b3IuX293bmVyO1xuICBuZXdEZXNjcmlwdG9yLl9jb250ZXh0ID0gb2xkRGVzY3JpcHRvci5fY29udGV4dDtcblxuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgbmV3RGVzY3JpcHRvci5fc3RvcmUgPSB7XG4gICAgICB2YWxpZGF0ZWQ6IG9sZERlc2NyaXB0b3IuX3N0b3JlLnZhbGlkYXRlZCxcbiAgICAgIHByb3BzOiBuZXdQcm9wc1xuICAgIH07XG4gICAgaWYgKHVzZU11dGF0aW9uTWVtYnJhbmUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUobmV3RGVzY3JpcHRvcik7XG4gICAgICByZXR1cm4gbmV3RGVzY3JpcHRvcjtcbiAgICB9XG4gIH1cblxuICBuZXdEZXNjcmlwdG9yLnByb3BzID0gbmV3UHJvcHM7XG4gIHJldHVybiBuZXdEZXNjcmlwdG9yO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBpcyBhIHZhbGlkIGRlc2NyaXB0b3IgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHsqfVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqIEBwdWJsaWNcbiAqL1xuUmVhY3REZXNjcmlwdG9yLmlzVmFsaWRGYWN0b3J5ID0gZnVuY3Rpb24oZmFjdG9yeSkge1xuICByZXR1cm4gdHlwZW9mIGZhY3RvcnkgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgIGZhY3RvcnkucHJvdG90eXBlIGluc3RhbmNlb2YgUmVhY3REZXNjcmlwdG9yO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIHZhbGlkIGNvbXBvbmVudC5cbiAqIEBmaW5hbFxuICovXG5SZWFjdERlc2NyaXB0b3IuaXNWYWxpZERlc2NyaXB0b3IgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIFJlYWN0RGVzY3JpcHRvcjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3REZXNjcmlwdG9yO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RGVzY3JpcHRvclZhbGlkYXRvclxuICovXG5cbi8qKlxuICogUmVhY3REZXNjcmlwdG9yVmFsaWRhdG9yIHByb3ZpZGVzIGEgd3JhcHBlciBhcm91bmQgYSBkZXNjcmlwdG9yIGZhY3RvcnlcbiAqIHdoaWNoIHZhbGlkYXRlcyB0aGUgcHJvcHMgcGFzc2VkIHRvIHRoZSBkZXNjcmlwdG9yLiBUaGlzIGlzIGludGVuZGVkIHRvIGJlXG4gKiB1c2VkIG9ubHkgaW4gREVWIGFuZCBjb3VsZCBiZSByZXBsYWNlZCBieSBhIHN0YXRpYyB0eXBlIGNoZWNrZXIgZm9yIGxhbmd1YWdlc1xuICogdGhhdCBzdXBwb3J0IGl0LlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgUmVhY3REZXNjcmlwdG9yID0gcmVxdWlyZShcIi4vUmVhY3REZXNjcmlwdG9yXCIpO1xudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMgPSByZXF1aXJlKFwiLi9SZWFjdFByb3BUeXBlTG9jYXRpb25zXCIpO1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZShcIi4vUmVhY3RDdXJyZW50T3duZXJcIik7XG5cbnZhciBtb25pdG9yQ29kZVVzZSA9IHJlcXVpcmUoXCIuL21vbml0b3JDb2RlVXNlXCIpO1xuXG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHtcbiAgJ3JlYWN0X2tleV93YXJuaW5nJzoge30sXG4gICdyZWFjdF9udW1lcmljX2tleV93YXJuaW5nJzoge31cbn07XG52YXIgb3duZXJIYXNNb25pdG9yZWRPYmplY3RNYXAgPSB7fTtcblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuXG52YXIgTlVNRVJJQ19QUk9QRVJUWV9SRUdFWCA9IC9eXFxkKyQvO1xuXG4vKipcbiAqIEdldHMgdGhlIGN1cnJlbnQgb3duZXIncyBkaXNwbGF5TmFtZSBmb3IgdXNlIGluIHdhcm5pbmdzLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHJldHVybiB7P3N0cmluZ30gRGlzcGxheSBuYW1lIG9yIHVuZGVmaW5lZFxuICovXG5mdW5jdGlvbiBnZXRDdXJyZW50T3duZXJEaXNwbGF5TmFtZSgpIHtcbiAgdmFyIGN1cnJlbnQgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICByZXR1cm4gY3VycmVudCAmJiBjdXJyZW50LmNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBXYXJuIGlmIHRoZSBjb21wb25lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgY29tcG9uZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY29tcG9uZW50IENvbXBvbmVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGNvbXBvbmVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoY29tcG9uZW50LCBwYXJlbnRUeXBlKSB7XG4gIGlmIChjb21wb25lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBjb21wb25lbnQucHJvcHMua2V5ICE9IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29tcG9uZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuXG4gIHdhcm5BbmRNb25pdG9yRm9yS2V5VXNlKFxuICAgICdyZWFjdF9rZXlfd2FybmluZycsXG4gICAgJ0VhY2ggY2hpbGQgaW4gYW4gYXJyYXkgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicsXG4gICAgY29tcG9uZW50LFxuICAgIHBhcmVudFR5cGVcbiAgKTtcbn1cblxuLyoqXG4gKiBXYXJuIGlmIHRoZSBrZXkgaXMgYmVpbmcgZGVmaW5lZCBhcyBhbiBvYmplY3QgcHJvcGVydHkgYnV0IGhhcyBhbiBpbmNvcnJlY3RcbiAqIHZhbHVlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgUHJvcGVydHkgbmFtZSBvZiB0aGUga2V5LlxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY29tcG9uZW50IENvbXBvbmVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGNvbXBvbmVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydHlLZXkobmFtZSwgY29tcG9uZW50LCBwYXJlbnRUeXBlKSB7XG4gIGlmICghTlVNRVJJQ19QUk9QRVJUWV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdhcm5BbmRNb25pdG9yRm9yS2V5VXNlKFxuICAgICdyZWFjdF9udW1lcmljX2tleV93YXJuaW5nJyxcbiAgICAnQ2hpbGQgb2JqZWN0cyBzaG91bGQgaGF2ZSBub24tbnVtZXJpYyBrZXlzIHNvIG9yZGVyaW5nIGlzIHByZXNlcnZlZC4nLFxuICAgIGNvbXBvbmVudCxcbiAgICBwYXJlbnRUeXBlXG4gICk7XG59XG5cbi8qKlxuICogU2hhcmVkIHdhcm5pbmcgYW5kIG1vbml0b3JpbmcgY29kZSBmb3IgdGhlIGtleSB3YXJuaW5ncy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7c3RyaW5nfSB3YXJuaW5nSUQgVGhlIGlkIHVzZWQgd2hlbiBsb2dnaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgVGhlIGJhc2Ugd2FybmluZyB0aGF0IGdldHMgb3V0cHV0LlxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY29tcG9uZW50IENvbXBvbmVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGNvbXBvbmVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIHdhcm5BbmRNb25pdG9yRm9yS2V5VXNlKHdhcm5pbmdJRCwgbWVzc2FnZSwgY29tcG9uZW50LCBwYXJlbnRUeXBlKSB7XG4gIHZhciBvd25lck5hbWUgPSBnZXRDdXJyZW50T3duZXJEaXNwbGF5TmFtZSgpO1xuICB2YXIgcGFyZW50TmFtZSA9IHBhcmVudFR5cGUuZGlzcGxheU5hbWU7XG5cbiAgdmFyIHVzZU5hbWUgPSBvd25lck5hbWUgfHwgcGFyZW50TmFtZTtcbiAgdmFyIG1lbW9pemVyID0gb3duZXJIYXNLZXlVc2VXYXJuaW5nW3dhcm5pbmdJRF07XG4gIGlmIChtZW1vaXplci5oYXNPd25Qcm9wZXJ0eSh1c2VOYW1lKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBtZW1vaXplclt1c2VOYW1lXSA9IHRydWU7XG5cbiAgbWVzc2FnZSArPSBvd25lck5hbWUgP1xuICAgIChcIiBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBcIiArIG93bmVyTmFtZSArIFwiLlwiKSA6XG4gICAgKFwiIENoZWNrIHRoZSByZW5kZXJDb21wb25lbnQgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnROYW1lICsgXCI+LlwiKTtcblxuICAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cbiAgdmFyIGNoaWxkT3duZXJOYW1lID0gbnVsbDtcbiAgaWYgKGNvbXBvbmVudC5fb3duZXIgJiYgY29tcG9uZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIC8vIE5hbWUgb2YgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgIGNoaWxkT3duZXJOYW1lID0gY29tcG9uZW50Ll9vd25lci5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZTtcblxuICAgIG1lc3NhZ2UgKz0gKFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgY2hpbGRPd25lck5hbWUgKyBcIi5cIik7XG4gIH1cblxuICBtZXNzYWdlICs9ICcgU2VlIGh0dHA6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJztcbiAgbW9uaXRvckNvZGVVc2Uod2FybmluZ0lELCB7XG4gICAgY29tcG9uZW50OiB1c2VOYW1lLFxuICAgIGNvbXBvbmVudE93bmVyOiBjaGlsZE93bmVyTmFtZVxuICB9KTtcbiAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xufVxuXG4vKipcbiAqIExvZyB0aGF0IHdlJ3JlIHVzaW5nIGFuIG9iamVjdCBtYXAuIFdlJ3JlIGNvbnNpZGVyaW5nIGRlcHJlY2F0aW5nIHRoaXNcbiAqIGZlYXR1cmUgYW5kIHJlcGxhY2UgaXQgd2l0aCBwcm9wZXIgTWFwIGFuZCBJbW11dGFibGVNYXAgZGF0YSBzdHJ1Y3R1cmVzLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBtb25pdG9yVXNlT2ZPYmplY3RNYXAoKSB7XG4gIHZhciBjdXJyZW50TmFtZSA9IGdldEN1cnJlbnRPd25lckRpc3BsYXlOYW1lKCkgfHwgJyc7XG4gIGlmIChvd25lckhhc01vbml0b3JlZE9iamVjdE1hcC5oYXNPd25Qcm9wZXJ0eShjdXJyZW50TmFtZSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgb3duZXJIYXNNb25pdG9yZWRPYmplY3RNYXBbY3VycmVudE5hbWVdID0gdHJ1ZTtcbiAgbW9uaXRvckNvZGVVc2UoJ3JlYWN0X29iamVjdF9tYXBfY2hpbGRyZW4nKTtcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBjb21wb25lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0geyp9IGNvbXBvbmVudCBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBjb21wb25lbnQncyBwYXJlbnQncyB0eXBlLlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMoY29tcG9uZW50LCBwYXJlbnRUeXBlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNvbXBvbmVudCkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbXBvbmVudC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gY29tcG9uZW50W2ldO1xuICAgICAgaWYgKFJlYWN0RGVzY3JpcHRvci5pc1ZhbGlkRGVzY3JpcHRvcihjaGlsZCkpIHtcbiAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKFJlYWN0RGVzY3JpcHRvci5pc1ZhbGlkRGVzY3JpcHRvcihjb21wb25lbnQpKSB7XG4gICAgLy8gVGhpcyBjb21wb25lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgIGNvbXBvbmVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChjb21wb25lbnQgJiYgdHlwZW9mIGNvbXBvbmVudCA9PT0gJ29iamVjdCcpIHtcbiAgICBtb25pdG9yVXNlT2ZPYmplY3RNYXAoKTtcbiAgICBmb3IgKHZhciBuYW1lIGluIGNvbXBvbmVudCkge1xuICAgICAgdmFsaWRhdGVQcm9wZXJ0eUtleShuYW1lLCBjb21wb25lbnRbbmFtZV0sIHBhcmVudFR5cGUpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBwcm9wcyBhcmUgdmFsaWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50TmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICogQHBhcmFtIHtvYmplY3R9IHByb3BUeXBlcyBNYXAgb2YgcHJvcCBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyhjb21wb25lbnROYW1lLCBwcm9wVHlwZXMsIHByb3BzLCBsb2NhdGlvbikge1xuICBmb3IgKHZhciBwcm9wTmFtZSBpbiBwcm9wVHlwZXMpIHtcbiAgICBpZiAocHJvcFR5cGVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgdmFyIGVycm9yO1xuICAgICAgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbiAgICAgIHRyeSB7XG4gICAgICAgIGVycm9yID0gcHJvcFR5cGVzW3Byb3BOYW1lXShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uKTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIGVycm9yID0gZXg7XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgLy8gVGhpcyB3aWxsIHNvb24gdXNlIHRoZSB3YXJuaW5nIG1vZHVsZVxuICAgICAgICBtb25pdG9yQ29kZVVzZShcbiAgICAgICAgICAncmVhY3RfZmFpbGVkX2Rlc2NyaXB0b3JfdHlwZV9jaGVjaycsXG4gICAgICAgICAgeyBtZXNzYWdlOiBlcnJvci5tZXNzYWdlIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0RGVzY3JpcHRvclZhbGlkYXRvciA9IHtcblxuICAvKipcbiAgICogV3JhcHMgYSBkZXNjcmlwdG9yIGZhY3RvcnkgZnVuY3Rpb24gaW4gYW5vdGhlciBmdW5jdGlvbiB3aGljaCB2YWxpZGF0ZXNcbiAgICogdGhlIHByb3BzIGFuZCBjb250ZXh0IG9mIHRoZSBkZXNjcmlwdG9yIGFuZCB3YXJucyBhYm91dCBhbnkgZmFpbGVkIHR5cGVcbiAgICogY2hlY2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmYWN0b3J5IFRoZSBvcmlnaW5hbCBkZXNjcmlwdG9yIGZhY3RvcnlcbiAgICogQHBhcmFtIHtvYmplY3Q/fSBwcm9wVHlwZXMgQSBwcm9wIHR5cGUgZGVmaW5pdGlvbiBzZXRcbiAgICogQHBhcmFtIHtvYmplY3Q/fSBjb250ZXh0VHlwZXMgQSBjb250ZXh0IHR5cGUgZGVmaW5pdGlvbiBzZXRcbiAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgY29tcG9uZW50IGRlc2NyaXB0b3IsIHdoaWNoIG1heSBiZSBpbnZhbGlkLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY3JlYXRlRmFjdG9yeTogZnVuY3Rpb24oZmFjdG9yeSwgcHJvcFR5cGVzLCBjb250ZXh0VHlwZXMpIHtcbiAgICB2YXIgdmFsaWRhdGVkRmFjdG9yeSA9IGZ1bmN0aW9uKHByb3BzLCBjaGlsZHJlbikge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBmYWN0b3J5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgZGVzY3JpcHRvci50eXBlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5hbWUgPSBkZXNjcmlwdG9yLnR5cGUuZGlzcGxheU5hbWU7XG4gICAgICBpZiAocHJvcFR5cGVzKSB7XG4gICAgICAgIGNoZWNrUHJvcFR5cGVzKFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgcHJvcFR5cGVzLFxuICAgICAgICAgIGRlc2NyaXB0b3IucHJvcHMsXG4gICAgICAgICAgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5wcm9wXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoY29udGV4dFR5cGVzKSB7XG4gICAgICAgIGNoZWNrUHJvcFR5cGVzKFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgY29udGV4dFR5cGVzLFxuICAgICAgICAgIGRlc2NyaXB0b3IuX2NvbnRleHQsXG4gICAgICAgICAgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5jb250ZXh0XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVzY3JpcHRvcjtcbiAgICB9O1xuXG4gICAgdmFsaWRhdGVkRmFjdG9yeS5wcm90b3R5cGUgPSBmYWN0b3J5LnByb3RvdHlwZTtcbiAgICB2YWxpZGF0ZWRGYWN0b3J5LnR5cGUgPSBmYWN0b3J5LnR5cGU7XG5cbiAgICAvLyBDb3B5IHN0YXRpYyBwcm9wZXJ0aWVzXG4gICAgZm9yICh2YXIga2V5IGluIGZhY3RvcnkpIHtcbiAgICAgIGlmIChmYWN0b3J5Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgdmFsaWRhdGVkRmFjdG9yeVtrZXldID0gZmFjdG9yeVtrZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWxpZGF0ZWRGYWN0b3J5O1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3REZXNjcmlwdG9yVmFsaWRhdG9yO1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RFbXB0eUNvbXBvbmVudFxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xuXG52YXIgY29tcG9uZW50O1xuLy8gVGhpcyByZWdpc3RyeSBrZWVwcyB0cmFjayBvZiB0aGUgUmVhY3QgSURzIG9mIHRoZSBjb21wb25lbnRzIHRoYXQgcmVuZGVyZWQgdG9cbi8vIGBudWxsYCAoaW4gcmVhbGl0eSBhIHBsYWNlaG9sZGVyIHN1Y2ggYXMgYG5vc2NyaXB0YClcbnZhciBudWxsQ29tcG9uZW50SWRzUmVnaXN0cnkgPSB7fTtcblxudmFyIFJlYWN0RW1wdHlDb21wb25lbnRJbmplY3Rpb24gPSB7XG4gIGluamVjdEVtcHR5Q29tcG9uZW50OiBmdW5jdGlvbihlbXB0eUNvbXBvbmVudCkge1xuICAgIGNvbXBvbmVudCA9IGVtcHR5Q29tcG9uZW50O1xuICB9XG59O1xuXG4vKipcbiAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnQgVGhlIGluamVjdGVkIGVtcHR5IGNvbXBvbmVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0RW1wdHlDb21wb25lbnQoKSB7XG4gIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgY29tcG9uZW50LFxuICAgICdUcnlpbmcgdG8gcmV0dXJuIG51bGwgZnJvbSBhIHJlbmRlciwgYnV0IG5vIG51bGwgcGxhY2Vob2xkZXIgY29tcG9uZW50ICcgK1xuICAgICd3YXMgaW5qZWN0ZWQuJ1xuICApIDogaW52YXJpYW50KGNvbXBvbmVudCkpO1xuICByZXR1cm4gY29tcG9uZW50KCk7XG59XG5cbi8qKlxuICogTWFyayB0aGUgY29tcG9uZW50IGFzIGhhdmluZyByZW5kZXJlZCB0byBudWxsLlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIENvbXBvbmVudCdzIGBfcm9vdE5vZGVJRGAuXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyTnVsbENvbXBvbmVudElEKGlkKSB7XG4gIG51bGxDb21wb25lbnRJZHNSZWdpc3RyeVtpZF0gPSB0cnVlO1xufVxuXG4vKipcbiAqIFVubWFyayB0aGUgY29tcG9uZW50IGFzIGhhdmluZyByZW5kZXJlZCB0byBudWxsOiBpdCByZW5kZXJzIHRvIHNvbWV0aGluZyBub3cuXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgQ29tcG9uZW50J3MgYF9yb290Tm9kZUlEYC5cbiAqL1xuZnVuY3Rpb24gZGVyZWdpc3Rlck51bGxDb21wb25lbnRJRChpZCkge1xuICBkZWxldGUgbnVsbENvbXBvbmVudElkc1JlZ2lzdHJ5W2lkXTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgQ29tcG9uZW50J3MgYF9yb290Tm9kZUlEYC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGNvbXBvbmVudCBpcyByZW5kZXJlZCB0byBudWxsLlxuICovXG5mdW5jdGlvbiBpc051bGxDb21wb25lbnRJRChpZCkge1xuICByZXR1cm4gbnVsbENvbXBvbmVudElkc1JlZ2lzdHJ5W2lkXTtcbn1cblxudmFyIFJlYWN0RW1wdHlDb21wb25lbnQgPSB7XG4gIGRlcmVnaXN0ZXJOdWxsQ29tcG9uZW50SUQ6IGRlcmVnaXN0ZXJOdWxsQ29tcG9uZW50SUQsXG4gIGdldEVtcHR5Q29tcG9uZW50OiBnZXRFbXB0eUNvbXBvbmVudCxcbiAgaW5qZWN0aW9uOiBSZWFjdEVtcHR5Q29tcG9uZW50SW5qZWN0aW9uLFxuICBpc051bGxDb21wb25lbnRJRDogaXNOdWxsQ29tcG9uZW50SUQsXG4gIHJlZ2lzdGVyTnVsbENvbXBvbmVudElEOiByZWdpc3Rlck51bGxDb21wb25lbnRJRFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEVtcHR5Q29tcG9uZW50O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RFcnJvclV0aWxzXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgUmVhY3RFcnJvclV0aWxzID0ge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIGd1YXJkZWQgdmVyc2lvbiBvZiBhIGZ1bmN0aW9uLiBUaGlzIGlzIHN1cHBvc2VkIHRvIG1ha2UgZGVidWdnaW5nXG4gICAqIG9mIGV2ZW50IGhhbmRsZXJzIGVhc2llci4gVG8gYWlkIGRlYnVnZ2luZyB3aXRoIHRoZSBicm93c2VyJ3MgZGVidWdnZXIsXG4gICAqIHRoaXMgY3VycmVudGx5IHNpbXBseSByZXR1cm5zIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuYyBGdW5jdGlvbiB0byBiZSBleGVjdXRlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZ3VhcmRcbiAgICogQHJldHVybiB7ZnVuY3Rpb259XG4gICAqL1xuICBndWFyZDogZnVuY3Rpb24oZnVuYywgbmFtZSkge1xuICAgIHJldHVybiBmdW5jO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RXJyb3JVdGlscztcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEV2ZW50RW1pdHRlck1peGluXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoXCIuL0V2ZW50UGx1Z2luSHViXCIpO1xuXG5mdW5jdGlvbiBydW5FdmVudFF1ZXVlSW5CYXRjaChldmVudHMpIHtcbiAgRXZlbnRQbHVnaW5IdWIuZW5xdWV1ZUV2ZW50cyhldmVudHMpO1xuICBFdmVudFBsdWdpbkh1Yi5wcm9jZXNzRXZlbnRRdWV1ZSgpO1xufVxuXG52YXIgUmVhY3RFdmVudEVtaXR0ZXJNaXhpbiA9IHtcblxuICAvKipcbiAgICogU3RyZWFtcyBhIGZpcmVkIHRvcC1sZXZlbCBldmVudCB0byBgRXZlbnRQbHVnaW5IdWJgIHdoZXJlIHBsdWdpbnMgaGF2ZSB0aGVcbiAgICogb3Bwb3J0dW5pdHkgdG8gY3JlYXRlIGBSZWFjdEV2ZW50YHMgdG8gYmUgZGlzcGF0Y2hlZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge29iamVjdH0gdG9wTGV2ZWxUYXJnZXQgVGhlIGxpc3RlbmluZyBjb21wb25lbnQgcm9vdCBub2RlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUYXJnZXRJRCBJRCBvZiBgdG9wTGV2ZWxUYXJnZXRgLlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGVudmlyb25tZW50IGV2ZW50LlxuICAgKi9cbiAgaGFuZGxlVG9wTGV2ZWw6IGZ1bmN0aW9uKFxuICAgICAgdG9wTGV2ZWxUeXBlLFxuICAgICAgdG9wTGV2ZWxUYXJnZXQsXG4gICAgICB0b3BMZXZlbFRhcmdldElELFxuICAgICAgbmF0aXZlRXZlbnQpIHtcbiAgICB2YXIgZXZlbnRzID0gRXZlbnRQbHVnaW5IdWIuZXh0cmFjdEV2ZW50cyhcbiAgICAgIHRvcExldmVsVHlwZSxcbiAgICAgIHRvcExldmVsVGFyZ2V0LFxuICAgICAgdG9wTGV2ZWxUYXJnZXRJRCxcbiAgICAgIG5hdGl2ZUV2ZW50XG4gICAgKTtcblxuICAgIHJ1bkV2ZW50UXVldWVJbkJhdGNoKGV2ZW50cyk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFdmVudEVtaXR0ZXJNaXhpbjtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEV2ZW50TGlzdGVuZXJcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBFdmVudExpc3RlbmVyID0gcmVxdWlyZShcIi4vRXZlbnRMaXN0ZW5lclwiKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoXCIuL0V4ZWN1dGlvbkVudmlyb25tZW50XCIpO1xudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZShcIi4vUG9vbGVkQ2xhc3NcIik7XG52YXIgUmVhY3RJbnN0YW5jZUhhbmRsZXMgPSByZXF1aXJlKFwiLi9SZWFjdEluc3RhbmNlSGFuZGxlc1wiKTtcbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZShcIi4vUmVhY3RNb3VudFwiKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKFwiLi9SZWFjdFVwZGF0ZXNcIik7XG5cbnZhciBnZXRFdmVudFRhcmdldCA9IHJlcXVpcmUoXCIuL2dldEV2ZW50VGFyZ2V0XCIpO1xudmFyIGdldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uID0gcmVxdWlyZShcIi4vZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb25cIik7XG52YXIgbWl4SW50byA9IHJlcXVpcmUoXCIuL21peEludG9cIik7XG5cbi8qKlxuICogRmluZHMgdGhlIHBhcmVudCBSZWFjdCBjb21wb25lbnQgb2YgYG5vZGVgLlxuICpcbiAqIEBwYXJhbSB7Kn0gbm9kZVxuICogQHJldHVybiB7P0RPTUV2ZW50VGFyZ2V0fSBQYXJlbnQgY29udGFpbmVyLCBvciBgbnVsbGAgaWYgdGhlIHNwZWNpZmllZCBub2RlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIG5vdCBuZXN0ZWQuXG4gKi9cbmZ1bmN0aW9uIGZpbmRQYXJlbnQobm9kZSkge1xuICAvLyBUT0RPOiBJdCBtYXkgYmUgYSBnb29kIGlkZWEgdG8gY2FjaGUgdGhpcyB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IERPTVxuICAvLyB0cmF2ZXJzYWwsIGJ1dCBjYWNoaW5nIGlzIGRpZmZpY3VsdCB0byBkbyBjb3JyZWN0bHkgd2l0aG91dCB1c2luZyBhXG4gIC8vIG11dGF0aW9uIG9ic2VydmVyIHRvIGxpc3RlbiBmb3IgYWxsIERPTSBjaGFuZ2VzLlxuICB2YXIgbm9kZUlEID0gUmVhY3RNb3VudC5nZXRJRChub2RlKTtcbiAgdmFyIHJvb3RJRCA9IFJlYWN0SW5zdGFuY2VIYW5kbGVzLmdldFJlYWN0Um9vdElERnJvbU5vZGVJRChub2RlSUQpO1xuICB2YXIgY29udGFpbmVyID0gUmVhY3RNb3VudC5maW5kUmVhY3RDb250YWluZXJGb3JJRChyb290SUQpO1xuICB2YXIgcGFyZW50ID0gUmVhY3RNb3VudC5nZXRGaXJzdFJlYWN0RE9NKGNvbnRhaW5lcik7XG4gIHJldHVybiBwYXJlbnQ7XG59XG5cbi8vIFVzZWQgdG8gc3RvcmUgYW5jZXN0b3IgaGllcmFyY2h5IGluIHRvcCBsZXZlbCBjYWxsYmFja1xuZnVuY3Rpb24gVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgdGhpcy50b3BMZXZlbFR5cGUgPSB0b3BMZXZlbFR5cGU7XG4gIHRoaXMubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgdGhpcy5hbmNlc3RvcnMgPSBbXTtcbn1cbm1peEludG8oVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nLCB7XG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudG9wTGV2ZWxUeXBlID0gbnVsbDtcbiAgICB0aGlzLm5hdGl2ZUV2ZW50ID0gbnVsbDtcbiAgICB0aGlzLmFuY2VzdG9ycy5sZW5ndGggPSAwO1xuICB9XG59KTtcblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhcbiAgVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nLFxuICBQb29sZWRDbGFzcy50d29Bcmd1bWVudFBvb2xlclxuKTtcblxuZnVuY3Rpb24gaGFuZGxlVG9wTGV2ZWxJbXBsKGJvb2tLZWVwaW5nKSB7XG4gIHZhciB0b3BMZXZlbFRhcmdldCA9IFJlYWN0TW91bnQuZ2V0Rmlyc3RSZWFjdERPTShcbiAgICBnZXRFdmVudFRhcmdldChib29rS2VlcGluZy5uYXRpdmVFdmVudClcbiAgKSB8fCB3aW5kb3c7XG5cbiAgLy8gTG9vcCB0aHJvdWdoIHRoZSBoaWVyYXJjaHksIGluIGNhc2UgdGhlcmUncyBhbnkgbmVzdGVkIGNvbXBvbmVudHMuXG4gIC8vIEl0J3MgaW1wb3J0YW50IHRoYXQgd2UgYnVpbGQgdGhlIGFycmF5IG9mIGFuY2VzdG9ycyBiZWZvcmUgY2FsbGluZyBhbnlcbiAgLy8gZXZlbnQgaGFuZGxlcnMsIGJlY2F1c2UgZXZlbnQgaGFuZGxlcnMgY2FuIG1vZGlmeSB0aGUgRE9NLCBsZWFkaW5nIHRvXG4gIC8vIGluY29uc2lzdGVuY2llcyB3aXRoIFJlYWN0TW91bnQncyBub2RlIGNhY2hlLiBTZWUgIzExMDUuXG4gIHZhciBhbmNlc3RvciA9IHRvcExldmVsVGFyZ2V0O1xuICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICBib29rS2VlcGluZy5hbmNlc3RvcnMucHVzaChhbmNlc3Rvcik7XG4gICAgYW5jZXN0b3IgPSBmaW5kUGFyZW50KGFuY2VzdG9yKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gYm9va0tlZXBpbmcuYW5jZXN0b3JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHRvcExldmVsVGFyZ2V0ID0gYm9va0tlZXBpbmcuYW5jZXN0b3JzW2ldO1xuICAgIHZhciB0b3BMZXZlbFRhcmdldElEID0gUmVhY3RNb3VudC5nZXRJRCh0b3BMZXZlbFRhcmdldCkgfHwgJyc7XG4gICAgUmVhY3RFdmVudExpc3RlbmVyLl9oYW5kbGVUb3BMZXZlbChcbiAgICAgIGJvb2tLZWVwaW5nLnRvcExldmVsVHlwZSxcbiAgICAgIHRvcExldmVsVGFyZ2V0LFxuICAgICAgdG9wTGV2ZWxUYXJnZXRJRCxcbiAgICAgIGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50XG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzY3JvbGxWYWx1ZU1vbml0b3IoY2IpIHtcbiAgdmFyIHNjcm9sbFBvc2l0aW9uID0gZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24od2luZG93KTtcbiAgY2Ioc2Nyb2xsUG9zaXRpb24pO1xufVxuXG52YXIgUmVhY3RFdmVudExpc3RlbmVyID0ge1xuICBfZW5hYmxlZDogdHJ1ZSxcbiAgX2hhbmRsZVRvcExldmVsOiBudWxsLFxuXG4gIFdJTkRPV19IQU5ETEU6IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IHdpbmRvdyA6IG51bGwsXG5cbiAgc2V0SGFuZGxlVG9wTGV2ZWw6IGZ1bmN0aW9uKGhhbmRsZVRvcExldmVsKSB7XG4gICAgUmVhY3RFdmVudExpc3RlbmVyLl9oYW5kbGVUb3BMZXZlbCA9IGhhbmRsZVRvcExldmVsO1xuICB9LFxuXG4gIHNldEVuYWJsZWQ6IGZ1bmN0aW9uKGVuYWJsZWQpIHtcbiAgICBSZWFjdEV2ZW50TGlzdGVuZXIuX2VuYWJsZWQgPSAhIWVuYWJsZWQ7XG4gIH0sXG5cbiAgaXNFbmFibGVkOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gUmVhY3RFdmVudExpc3RlbmVyLl9lbmFibGVkO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIFRyYXBzIHRvcC1sZXZlbCBldmVudHMgYnkgdXNpbmcgZXZlbnQgYnViYmxpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJCYXNlTmFtZSBFdmVudCBuYW1lIChlLmcuIFwiY2xpY2tcIikuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBoYW5kbGUgRWxlbWVudCBvbiB3aGljaCB0byBhdHRhY2ggbGlzdGVuZXIuXG4gICAqIEByZXR1cm4ge29iamVjdH0gQW4gb2JqZWN0IHdpdGggYSByZW1vdmUgZnVuY3Rpb24gd2hpY2ggd2lsbCBmb3JjZWZ1bGx5XG4gICAqICAgICAgICAgICAgICAgICAgcmVtb3ZlIHRoZSBsaXN0ZW5lci5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB0cmFwQnViYmxlZEV2ZW50OiBmdW5jdGlvbih0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBoYW5kbGU7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBFdmVudExpc3RlbmVyLmxpc3RlbihcbiAgICAgIGVsZW1lbnQsXG4gICAgICBoYW5kbGVyQmFzZU5hbWUsXG4gICAgICBSZWFjdEV2ZW50TGlzdGVuZXIuZGlzcGF0Y2hFdmVudC5iaW5kKG51bGwsIHRvcExldmVsVHlwZSlcbiAgICApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmFwcyBhIHRvcC1sZXZlbCBldmVudCBieSB1c2luZyBldmVudCBjYXB0dXJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJCYXNlTmFtZSBFdmVudCBuYW1lIChlLmcuIFwiY2xpY2tcIikuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBoYW5kbGUgRWxlbWVudCBvbiB3aGljaCB0byBhdHRhY2ggbGlzdGVuZXIuXG4gICAqIEByZXR1cm4ge29iamVjdH0gQW4gb2JqZWN0IHdpdGggYSByZW1vdmUgZnVuY3Rpb24gd2hpY2ggd2lsbCBmb3JjZWZ1bGx5XG4gICAqICAgICAgICAgICAgICAgICAgcmVtb3ZlIHRoZSBsaXN0ZW5lci5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB0cmFwQ2FwdHVyZWRFdmVudDogZnVuY3Rpb24odG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGhhbmRsZSkge1xuICAgIHZhciBlbGVtZW50ID0gaGFuZGxlO1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gRXZlbnRMaXN0ZW5lci5jYXB0dXJlKFxuICAgICAgZWxlbWVudCxcbiAgICAgIGhhbmRsZXJCYXNlTmFtZSxcbiAgICAgIFJlYWN0RXZlbnRMaXN0ZW5lci5kaXNwYXRjaEV2ZW50LmJpbmQobnVsbCwgdG9wTGV2ZWxUeXBlKVxuICAgICk7XG4gIH0sXG5cbiAgbW9uaXRvclNjcm9sbFZhbHVlOiBmdW5jdGlvbihyZWZyZXNoKSB7XG4gICAgdmFyIGNhbGxiYWNrID0gc2Nyb2xsVmFsdWVNb25pdG9yLmJpbmQobnVsbCwgcmVmcmVzaCk7XG4gICAgRXZlbnRMaXN0ZW5lci5saXN0ZW4od2luZG93LCAnc2Nyb2xsJywgY2FsbGJhY2spO1xuICAgIEV2ZW50TGlzdGVuZXIubGlzdGVuKHdpbmRvdywgJ3Jlc2l6ZScsIGNhbGxiYWNrKTtcbiAgfSxcblxuICBkaXNwYXRjaEV2ZW50OiBmdW5jdGlvbih0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gICAgaWYgKCFSZWFjdEV2ZW50TGlzdGVuZXIuX2VuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYm9va0tlZXBpbmcgPSBUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcuZ2V0UG9vbGVkKFxuICAgICAgdG9wTGV2ZWxUeXBlLFxuICAgICAgbmF0aXZlRXZlbnRcbiAgICApO1xuICAgIHRyeSB7XG4gICAgICAvLyBFdmVudCBxdWV1ZSBiZWluZyBwcm9jZXNzZWQgaW4gdGhlIHNhbWUgY3ljbGUgYWxsb3dzXG4gICAgICAvLyBgcHJldmVudERlZmF1bHRgLlxuICAgICAgUmVhY3RVcGRhdGVzLmJhdGNoZWRVcGRhdGVzKGhhbmRsZVRvcExldmVsSW1wbCwgYm9va0tlZXBpbmcpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcucmVsZWFzZShib29rS2VlcGluZyk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RXZlbnRMaXN0ZW5lcjtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEluamVjdGlvblxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKFwiLi9ET01Qcm9wZXJ0eVwiKTtcbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoXCIuL0V2ZW50UGx1Z2luSHViXCIpO1xudmFyIFJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZShcIi4vUmVhY3RDb21wb25lbnRcIik7XG52YXIgUmVhY3RDb21wb3NpdGVDb21wb25lbnQgPSByZXF1aXJlKFwiLi9SZWFjdENvbXBvc2l0ZUNvbXBvbmVudFwiKTtcbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoXCIuL1JlYWN0RE9NXCIpO1xudmFyIFJlYWN0RW1wdHlDb21wb25lbnQgPSByZXF1aXJlKFwiLi9SZWFjdEVtcHR5Q29tcG9uZW50XCIpO1xudmFyIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCIuL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlclwiKTtcbnZhciBSZWFjdFBlcmYgPSByZXF1aXJlKFwiLi9SZWFjdFBlcmZcIik7XG52YXIgUmVhY3RSb290SW5kZXggPSByZXF1aXJlKFwiLi9SZWFjdFJvb3RJbmRleFwiKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKFwiLi9SZWFjdFVwZGF0ZXNcIik7XG5cbnZhciBSZWFjdEluamVjdGlvbiA9IHtcbiAgQ29tcG9uZW50OiBSZWFjdENvbXBvbmVudC5pbmplY3Rpb24sXG4gIENvbXBvc2l0ZUNvbXBvbmVudDogUmVhY3RDb21wb3NpdGVDb21wb25lbnQuaW5qZWN0aW9uLFxuICBET01Qcm9wZXJ0eTogRE9NUHJvcGVydHkuaW5qZWN0aW9uLFxuICBFbXB0eUNvbXBvbmVudDogUmVhY3RFbXB0eUNvbXBvbmVudC5pbmplY3Rpb24sXG4gIEV2ZW50UGx1Z2luSHViOiBFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24sXG4gIERPTTogUmVhY3RET00uaW5qZWN0aW9uLFxuICBFdmVudEVtaXR0ZXI6IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5pbmplY3Rpb24sXG4gIFBlcmY6IFJlYWN0UGVyZi5pbmplY3Rpb24sXG4gIFJvb3RJbmRleDogUmVhY3RSb290SW5kZXguaW5qZWN0aW9uLFxuICBVcGRhdGVzOiBSZWFjdFVwZGF0ZXMuaW5qZWN0aW9uXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SW5qZWN0aW9uO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0SW5wdXRTZWxlY3Rpb25cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIFJlYWN0RE9NU2VsZWN0aW9uID0gcmVxdWlyZShcIi4vUmVhY3RET01TZWxlY3Rpb25cIik7XG5cbnZhciBjb250YWluc05vZGUgPSByZXF1aXJlKFwiLi9jb250YWluc05vZGVcIik7XG52YXIgZm9jdXNOb2RlID0gcmVxdWlyZShcIi4vZm9jdXNOb2RlXCIpO1xudmFyIGdldEFjdGl2ZUVsZW1lbnQgPSByZXF1aXJlKFwiLi9nZXRBY3RpdmVFbGVtZW50XCIpO1xuXG5mdW5jdGlvbiBpc0luRG9jdW1lbnQobm9kZSkge1xuICByZXR1cm4gY29udGFpbnNOb2RlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgbm9kZSk7XG59XG5cbi8qKlxuICogQFJlYWN0SW5wdXRTZWxlY3Rpb246IFJlYWN0IGlucHV0IHNlbGVjdGlvbiBtb2R1bGUuIEJhc2VkIG9uIFNlbGVjdGlvbi5qcyxcbiAqIGJ1dCBtb2RpZmllZCB0byBiZSBzdWl0YWJsZSBmb3IgcmVhY3QgYW5kIGhhcyBhIGNvdXBsZSBvZiBidWcgZml4ZXMgKGRvZXNuJ3RcbiAqIGFzc3VtZSBidXR0b25zIGhhdmUgcmFuZ2Ugc2VsZWN0aW9ucyBhbGxvd2VkKS5cbiAqIElucHV0IHNlbGVjdGlvbiBtb2R1bGUgZm9yIFJlYWN0LlxuICovXG52YXIgUmVhY3RJbnB1dFNlbGVjdGlvbiA9IHtcblxuICBoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXM6IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICByZXR1cm4gZWxlbSAmJiAoXG4gICAgICAoZWxlbS5ub2RlTmFtZSA9PT0gJ0lOUFVUJyAmJiBlbGVtLnR5cGUgPT09ICd0ZXh0JykgfHxcbiAgICAgIGVsZW0ubm9kZU5hbWUgPT09ICdURVhUQVJFQScgfHxcbiAgICAgIGVsZW0uY29udGVudEVkaXRhYmxlID09PSAndHJ1ZSdcbiAgICApO1xuICB9LFxuXG4gIGdldFNlbGVjdGlvbkluZm9ybWF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZm9jdXNlZEVsZW0gPSBnZXRBY3RpdmVFbGVtZW50KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvY3VzZWRFbGVtOiBmb2N1c2VkRWxlbSxcbiAgICAgIHNlbGVjdGlvblJhbmdlOlxuICAgICAgICAgIFJlYWN0SW5wdXRTZWxlY3Rpb24uaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKGZvY3VzZWRFbGVtKSA/XG4gICAgICAgICAgUmVhY3RJbnB1dFNlbGVjdGlvbi5nZXRTZWxlY3Rpb24oZm9jdXNlZEVsZW0pIDpcbiAgICAgICAgICBudWxsXG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogQHJlc3RvcmVTZWxlY3Rpb246IElmIGFueSBzZWxlY3Rpb24gaW5mb3JtYXRpb24gd2FzIHBvdGVudGlhbGx5IGxvc3QsXG4gICAqIHJlc3RvcmUgaXQuIFRoaXMgaXMgdXNlZnVsIHdoZW4gcGVyZm9ybWluZyBvcGVyYXRpb25zIHRoYXQgY291bGQgcmVtb3ZlIGRvbVxuICAgKiBub2RlcyBhbmQgcGxhY2UgdGhlbSBiYWNrIGluLCByZXN1bHRpbmcgaW4gZm9jdXMgYmVpbmcgbG9zdC5cbiAgICovXG4gIHJlc3RvcmVTZWxlY3Rpb246IGZ1bmN0aW9uKHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24pIHtcbiAgICB2YXIgY3VyRm9jdXNlZEVsZW0gPSBnZXRBY3RpdmVFbGVtZW50KCk7XG4gICAgdmFyIHByaW9yRm9jdXNlZEVsZW0gPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLmZvY3VzZWRFbGVtO1xuICAgIHZhciBwcmlvclNlbGVjdGlvblJhbmdlID0gcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5zZWxlY3Rpb25SYW5nZTtcbiAgICBpZiAoY3VyRm9jdXNlZEVsZW0gIT09IHByaW9yRm9jdXNlZEVsZW0gJiZcbiAgICAgICAgaXNJbkRvY3VtZW50KHByaW9yRm9jdXNlZEVsZW0pKSB7XG4gICAgICBpZiAoUmVhY3RJbnB1dFNlbGVjdGlvbi5oYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMocHJpb3JGb2N1c2VkRWxlbSkpIHtcbiAgICAgICAgUmVhY3RJbnB1dFNlbGVjdGlvbi5zZXRTZWxlY3Rpb24oXG4gICAgICAgICAgcHJpb3JGb2N1c2VkRWxlbSxcbiAgICAgICAgICBwcmlvclNlbGVjdGlvblJhbmdlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBmb2N1c05vZGUocHJpb3JGb2N1c2VkRWxlbSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAZ2V0U2VsZWN0aW9uOiBHZXRzIHRoZSBzZWxlY3Rpb24gYm91bmRzIG9mIGEgZm9jdXNlZCB0ZXh0YXJlYSwgaW5wdXQgb3JcbiAgICogY29udGVudEVkaXRhYmxlIG5vZGUuXG4gICAqIC1AaW5wdXQ6IExvb2sgdXAgc2VsZWN0aW9uIGJvdW5kcyBvZiB0aGlzIGlucHV0XG4gICAqIC1AcmV0dXJuIHtzdGFydDogc2VsZWN0aW9uU3RhcnQsIGVuZDogc2VsZWN0aW9uRW5kfVxuICAgKi9cbiAgZ2V0U2VsZWN0aW9uOiBmdW5jdGlvbihpbnB1dCkge1xuICAgIHZhciBzZWxlY3Rpb247XG5cbiAgICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgICAgLy8gTW9kZXJuIGJyb3dzZXIgd2l0aCBpbnB1dCBvciB0ZXh0YXJlYS5cbiAgICAgIHNlbGVjdGlvbiA9IHtcbiAgICAgICAgc3RhcnQ6IGlucHV0LnNlbGVjdGlvblN0YXJ0LFxuICAgICAgICBlbmQ6IGlucHV0LnNlbGVjdGlvbkVuZFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50LnNlbGVjdGlvbiAmJiBpbnB1dC5ub2RlTmFtZSA9PT0gJ0lOUFVUJykge1xuICAgICAgLy8gSUU4IGlucHV0LlxuICAgICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAvLyBUaGVyZSBjYW4gb25seSBiZSBvbmUgc2VsZWN0aW9uIHBlciBkb2N1bWVudCBpbiBJRSwgc28gaXQgbXVzdFxuICAgICAgLy8gYmUgaW4gb3VyIGVsZW1lbnQuXG4gICAgICBpZiAocmFuZ2UucGFyZW50RWxlbWVudCgpID09PSBpbnB1dCkge1xuICAgICAgICBzZWxlY3Rpb24gPSB7XG4gICAgICAgICAgc3RhcnQ6IC1yYW5nZS5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIC1pbnB1dC52YWx1ZS5sZW5ndGgpLFxuICAgICAgICAgIGVuZDogLXJhbmdlLm1vdmVFbmQoJ2NoYXJhY3RlcicsIC1pbnB1dC52YWx1ZS5sZW5ndGgpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENvbnRlbnQgZWRpdGFibGUgb3Igb2xkIElFIHRleHRhcmVhLlxuICAgICAgc2VsZWN0aW9uID0gUmVhY3RET01TZWxlY3Rpb24uZ2V0T2Zmc2V0cyhpbnB1dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGVjdGlvbiB8fCB7c3RhcnQ6IDAsIGVuZDogMH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBzZXRTZWxlY3Rpb246IFNldHMgdGhlIHNlbGVjdGlvbiBib3VuZHMgb2YgYSB0ZXh0YXJlYSBvciBpbnB1dCBhbmQgZm9jdXNlc1xuICAgKiB0aGUgaW5wdXQuXG4gICAqIC1AaW5wdXQgICAgIFNldCBzZWxlY3Rpb24gYm91bmRzIG9mIHRoaXMgaW5wdXQgb3IgdGV4dGFyZWFcbiAgICogLUBvZmZzZXRzICAgT2JqZWN0IG9mIHNhbWUgZm9ybSB0aGF0IGlzIHJldHVybmVkIGZyb20gZ2V0KlxuICAgKi9cbiAgc2V0U2VsZWN0aW9uOiBmdW5jdGlvbihpbnB1dCwgb2Zmc2V0cykge1xuICAgIHZhciBzdGFydCA9IG9mZnNldHMuc3RhcnQ7XG4gICAgdmFyIGVuZCA9IG9mZnNldHMuZW5kO1xuICAgIGlmICh0eXBlb2YgZW5kID09PSAndW5kZWZpbmVkJykge1xuICAgICAgZW5kID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gaW5wdXQpIHtcbiAgICAgIGlucHV0LnNlbGVjdGlvblN0YXJ0ID0gc3RhcnQ7XG4gICAgICBpbnB1dC5zZWxlY3Rpb25FbmQgPSBNYXRoLm1pbihlbmQsIGlucHV0LnZhbHVlLmxlbmd0aCk7XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudC5zZWxlY3Rpb24gJiYgaW5wdXQubm9kZU5hbWUgPT09ICdJTlBVVCcpIHtcbiAgICAgIHZhciByYW5nZSA9IGlucHV0LmNyZWF0ZVRleHRSYW5nZSgpO1xuICAgICAgcmFuZ2UuY29sbGFwc2UodHJ1ZSk7XG4gICAgICByYW5nZS5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIHN0YXJ0KTtcbiAgICAgIHJhbmdlLm1vdmVFbmQoJ2NoYXJhY3RlcicsIGVuZCAtIHN0YXJ0KTtcbiAgICAgIHJhbmdlLnNlbGVjdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERPTVNlbGVjdGlvbi5zZXRPZmZzZXRzKGlucHV0LCBvZmZzZXRzKTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RJbnB1dFNlbGVjdGlvbjtcbiIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RJbnN0YW5jZUhhbmRsZXNcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBSZWFjdFJvb3RJbmRleCA9IHJlcXVpcmUoXCIuL1JlYWN0Um9vdEluZGV4XCIpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xuXG52YXIgU0VQQVJBVE9SID0gJy4nO1xudmFyIFNFUEFSQVRPUl9MRU5HVEggPSBTRVBBUkFUT1IubGVuZ3RoO1xuXG4vKipcbiAqIE1heGltdW0gZGVwdGggb2YgdHJhdmVyc2FscyBiZWZvcmUgd2UgY29uc2lkZXIgdGhlIHBvc3NpYmlsaXR5IG9mIGEgYmFkIElELlxuICovXG52YXIgTUFYX1RSRUVfREVQVEggPSAxMDA7XG5cbi8qKlxuICogQ3JlYXRlcyBhIERPTSBJRCBwcmVmaXggdG8gdXNlIHdoZW4gbW91bnRpbmcgUmVhY3QgY29tcG9uZW50cy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggQSB1bmlxdWUgaW50ZWdlclxuICogQHJldHVybiB7c3RyaW5nfSBSZWFjdCByb290IElELlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldFJlYWN0Um9vdElEU3RyaW5nKGluZGV4KSB7XG4gIHJldHVybiBTRVBBUkFUT1IgKyBpbmRleC50b1N0cmluZygzNik7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgY2hhcmFjdGVyIGluIHRoZSBzdXBwbGllZCBJRCBpcyBhIHNlcGFyYXRvciBvciB0aGUgZW5kLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBBIFJlYWN0IERPTSBJRC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBvZiB0aGUgY2hhcmFjdGVyIHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgY2hhcmFjdGVyIGlzIGEgc2VwYXJhdG9yIG9yIGVuZCBvZiB0aGUgSUQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpc0JvdW5kYXJ5KGlkLCBpbmRleCkge1xuICByZXR1cm4gaWQuY2hhckF0KGluZGV4KSA9PT0gU0VQQVJBVE9SIHx8IGluZGV4ID09PSBpZC5sZW5ndGg7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBzdXBwbGllZCBzdHJpbmcgaXMgYSB2YWxpZCBSZWFjdCBET00gSUQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIEEgUmVhY3QgRE9NIElELCBtYXliZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHN0cmluZyBpcyBhIHZhbGlkIFJlYWN0IERPTSBJRC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRJRChpZCkge1xuICByZXR1cm4gaWQgPT09ICcnIHx8IChcbiAgICBpZC5jaGFyQXQoMCkgPT09IFNFUEFSQVRPUiAmJiBpZC5jaGFyQXQoaWQubGVuZ3RoIC0gMSkgIT09IFNFUEFSQVRPUlxuICApO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZmlyc3QgSUQgaXMgYW4gYW5jZXN0b3Igb2Ygb3IgZXF1YWwgdG8gdGhlIHNlY29uZCBJRC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYW5jZXN0b3JJRFxuICogQHBhcmFtIHtzdHJpbmd9IGRlc2NlbmRhbnRJRFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgYW5jZXN0b3JJRGAgaXMgYW4gYW5jZXN0b3Igb2YgYGRlc2NlbmRhbnRJRGAuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gaXNBbmNlc3RvcklET2YoYW5jZXN0b3JJRCwgZGVzY2VuZGFudElEKSB7XG4gIHJldHVybiAoXG4gICAgZGVzY2VuZGFudElELmluZGV4T2YoYW5jZXN0b3JJRCkgPT09IDAgJiZcbiAgICBpc0JvdW5kYXJ5KGRlc2NlbmRhbnRJRCwgYW5jZXN0b3JJRC5sZW5ndGgpXG4gICk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgcGFyZW50IElEIG9mIHRoZSBzdXBwbGllZCBSZWFjdCBET00gSUQsIGBpZGAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIElEIG9mIGEgY29tcG9uZW50LlxuICogQHJldHVybiB7c3RyaW5nfSBJRCBvZiB0aGUgcGFyZW50LCBvciBhbiBlbXB0eSBzdHJpbmcuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRQYXJlbnRJRChpZCkge1xuICByZXR1cm4gaWQgPyBpZC5zdWJzdHIoMCwgaWQubGFzdEluZGV4T2YoU0VQQVJBVE9SKSkgOiAnJztcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBuZXh0IERPTSBJRCBvbiB0aGUgdHJlZSBwYXRoIGZyb20gdGhlIHN1cHBsaWVkIGBhbmNlc3RvcklEYCB0byB0aGVcbiAqIHN1cHBsaWVkIGBkZXN0aW5hdGlvbklEYC4gSWYgdGhleSBhcmUgZXF1YWwsIHRoZSBJRCBpcyByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYW5jZXN0b3JJRCBJRCBvZiBhbiBhbmNlc3RvciBub2RlIG9mIGBkZXN0aW5hdGlvbklEYC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkZXN0aW5hdGlvbklEIElEIG9mIHRoZSBkZXN0aW5hdGlvbiBub2RlLlxuICogQHJldHVybiB7c3RyaW5nfSBOZXh0IElEIG9uIHRoZSBwYXRoIGZyb20gYGFuY2VzdG9ySURgIHRvIGBkZXN0aW5hdGlvbklEYC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldE5leHREZXNjZW5kYW50SUQoYW5jZXN0b3JJRCwgZGVzdGluYXRpb25JRCkge1xuICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgIGlzVmFsaWRJRChhbmNlc3RvcklEKSAmJiBpc1ZhbGlkSUQoZGVzdGluYXRpb25JRCksXG4gICAgJ2dldE5leHREZXNjZW5kYW50SUQoJXMsICVzKTogUmVjZWl2ZWQgYW4gaW52YWxpZCBSZWFjdCBET00gSUQuJyxcbiAgICBhbmNlc3RvcklELFxuICAgIGRlc3RpbmF0aW9uSURcbiAgKSA6IGludmFyaWFudChpc1ZhbGlkSUQoYW5jZXN0b3JJRCkgJiYgaXNWYWxpZElEKGRlc3RpbmF0aW9uSUQpKSk7XG4gIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgaXNBbmNlc3RvcklET2YoYW5jZXN0b3JJRCwgZGVzdGluYXRpb25JRCksXG4gICAgJ2dldE5leHREZXNjZW5kYW50SUQoLi4uKTogUmVhY3QgaGFzIG1hZGUgYW4gaW52YWxpZCBhc3N1bXB0aW9uIGFib3V0ICcgK1xuICAgICd0aGUgRE9NIGhpZXJhcmNoeS4gRXhwZWN0ZWQgYCVzYCB0byBiZSBhbiBhbmNlc3RvciBvZiBgJXNgLicsXG4gICAgYW5jZXN0b3JJRCxcbiAgICBkZXN0aW5hdGlvbklEXG4gICkgOiBpbnZhcmlhbnQoaXNBbmNlc3RvcklET2YoYW5jZXN0b3JJRCwgZGVzdGluYXRpb25JRCkpKTtcbiAgaWYgKGFuY2VzdG9ySUQgPT09IGRlc3RpbmF0aW9uSUQpIHtcbiAgICByZXR1cm4gYW5jZXN0b3JJRDtcbiAgfVxuICAvLyBTa2lwIG92ZXIgdGhlIGFuY2VzdG9yIGFuZCB0aGUgaW1tZWRpYXRlIHNlcGFyYXRvci4gVHJhdmVyc2UgdW50aWwgd2UgaGl0XG4gIC8vIGFub3RoZXIgc2VwYXJhdG9yIG9yIHdlIHJlYWNoIHRoZSBlbmQgb2YgYGRlc3RpbmF0aW9uSURgLlxuICB2YXIgc3RhcnQgPSBhbmNlc3RvcklELmxlbmd0aCArIFNFUEFSQVRPUl9MRU5HVEg7XG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGRlc3RpbmF0aW9uSUQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaXNCb3VuZGFyeShkZXN0aW5hdGlvbklELCBpKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZXN0aW5hdGlvbklELnN1YnN0cigwLCBpKTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBuZWFyZXN0IGNvbW1vbiBhbmNlc3RvciBJRCBvZiB0d28gSURzLlxuICpcbiAqIFVzaW5nIHRoaXMgSUQgc2NoZW1lLCB0aGUgbmVhcmVzdCBjb21tb24gYW5jZXN0b3IgSUQgaXMgdGhlIGxvbmdlc3QgY29tbW9uXG4gKiBwcmVmaXggb2YgdGhlIHR3byBJRHMgdGhhdCBpbW1lZGlhdGVseSBwcmVjZWRlZCBhIFwibWFya2VyXCIgaW4gYm90aCBzdHJpbmdzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBvbmVJRFxuICogQHBhcmFtIHtzdHJpbmd9IHR3b0lEXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5lYXJlc3QgY29tbW9uIGFuY2VzdG9yIElELCBvciB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vbmUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRGaXJzdENvbW1vbkFuY2VzdG9ySUQob25lSUQsIHR3b0lEKSB7XG4gIHZhciBtaW5MZW5ndGggPSBNYXRoLm1pbihvbmVJRC5sZW5ndGgsIHR3b0lELmxlbmd0aCk7XG4gIGlmIChtaW5MZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgdmFyIGxhc3RDb21tb25NYXJrZXJJbmRleCA9IDA7XG4gIC8vIFVzZSBgPD1gIHRvIHRyYXZlcnNlIHVudGlsIHRoZSBcIkVPTFwiIG9mIHRoZSBzaG9ydGVyIHN0cmluZy5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPD0gbWluTGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaXNCb3VuZGFyeShvbmVJRCwgaSkgJiYgaXNCb3VuZGFyeSh0d29JRCwgaSkpIHtcbiAgICAgIGxhc3RDb21tb25NYXJrZXJJbmRleCA9IGk7XG4gICAgfSBlbHNlIGlmIChvbmVJRC5jaGFyQXQoaSkgIT09IHR3b0lELmNoYXJBdChpKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHZhciBsb25nZXN0Q29tbW9uSUQgPSBvbmVJRC5zdWJzdHIoMCwgbGFzdENvbW1vbk1hcmtlckluZGV4KTtcbiAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICBpc1ZhbGlkSUQobG9uZ2VzdENvbW1vbklEKSxcbiAgICAnZ2V0Rmlyc3RDb21tb25BbmNlc3RvcklEKCVzLCAlcyk6IEV4cGVjdGVkIGEgdmFsaWQgUmVhY3QgRE9NIElEOiAlcycsXG4gICAgb25lSUQsXG4gICAgdHdvSUQsXG4gICAgbG9uZ2VzdENvbW1vbklEXG4gICkgOiBpbnZhcmlhbnQoaXNWYWxpZElEKGxvbmdlc3RDb21tb25JRCkpKTtcbiAgcmV0dXJuIGxvbmdlc3RDb21tb25JRDtcbn1cblxuLyoqXG4gKiBUcmF2ZXJzZXMgdGhlIHBhcmVudCBwYXRoIGJldHdlZW4gdHdvIElEcyAoZWl0aGVyIHVwIG9yIGRvd24pLiBUaGUgSURzIG11c3RcbiAqIG5vdCBiZSB0aGUgc2FtZSwgYW5kIHRoZXJlIG11c3QgZXhpc3QgYSBwYXJlbnQgcGF0aCBiZXR3ZWVuIHRoZW0uIElmIHRoZVxuICogY2FsbGJhY2sgcmV0dXJucyBgZmFsc2VgLCB0cmF2ZXJzYWwgaXMgc3RvcHBlZC5cbiAqXG4gKiBAcGFyYW0gez9zdHJpbmd9IHN0YXJ0IElEIGF0IHdoaWNoIHRvIHN0YXJ0IHRyYXZlcnNhbC5cbiAqIEBwYXJhbSB7P3N0cmluZ30gc3RvcCBJRCBhdCB3aGljaCB0byBlbmQgdHJhdmVyc2FsLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2IgQ2FsbGJhY2sgdG8gaW52b2tlIGVhY2ggSUQgd2l0aC5cbiAqIEBwYXJhbSB7P2Jvb2xlYW59IHNraXBGaXJzdCBXaGV0aGVyIG9yIG5vdCB0byBza2lwIHRoZSBmaXJzdCBub2RlLlxuICogQHBhcmFtIHs/Ym9vbGVhbn0gc2tpcExhc3QgV2hldGhlciBvciBub3QgdG8gc2tpcCB0aGUgbGFzdCBub2RlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VQYXJlbnRQYXRoKHN0YXJ0LCBzdG9wLCBjYiwgYXJnLCBza2lwRmlyc3QsIHNraXBMYXN0KSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgJyc7XG4gIHN0b3AgPSBzdG9wIHx8ICcnO1xuICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgIHN0YXJ0ICE9PSBzdG9wLFxuICAgICd0cmF2ZXJzZVBhcmVudFBhdGgoLi4uKTogQ2Fubm90IHRyYXZlcnNlIGZyb20gYW5kIHRvIHRoZSBzYW1lIElELCBgJXNgLicsXG4gICAgc3RhcnRcbiAgKSA6IGludmFyaWFudChzdGFydCAhPT0gc3RvcCkpO1xuICB2YXIgdHJhdmVyc2VVcCA9IGlzQW5jZXN0b3JJRE9mKHN0b3AsIHN0YXJ0KTtcbiAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICB0cmF2ZXJzZVVwIHx8IGlzQW5jZXN0b3JJRE9mKHN0YXJ0LCBzdG9wKSxcbiAgICAndHJhdmVyc2VQYXJlbnRQYXRoKCVzLCAlcywgLi4uKTogQ2Fubm90IHRyYXZlcnNlIGZyb20gdHdvIElEcyB0aGF0IGRvICcgK1xuICAgICdub3QgaGF2ZSBhIHBhcmVudCBwYXRoLicsXG4gICAgc3RhcnQsXG4gICAgc3RvcFxuICApIDogaW52YXJpYW50KHRyYXZlcnNlVXAgfHwgaXNBbmNlc3RvcklET2Yoc3RhcnQsIHN0b3ApKSk7XG4gIC8vIFRyYXZlcnNlIGZyb20gYHN0YXJ0YCB0byBgc3RvcGAgb25lIGRlcHRoIGF0IGEgdGltZS5cbiAgdmFyIGRlcHRoID0gMDtcbiAgdmFyIHRyYXZlcnNlID0gdHJhdmVyc2VVcCA/IGdldFBhcmVudElEIDogZ2V0TmV4dERlc2NlbmRhbnRJRDtcbiAgZm9yICh2YXIgaWQgPSBzdGFydDsgLyogdW50aWwgYnJlYWsgKi87IGlkID0gdHJhdmVyc2UoaWQsIHN0b3ApKSB7XG4gICAgdmFyIHJldDtcbiAgICBpZiAoKCFza2lwRmlyc3QgfHwgaWQgIT09IHN0YXJ0KSAmJiAoIXNraXBMYXN0IHx8IGlkICE9PSBzdG9wKSkge1xuICAgICAgcmV0ID0gY2IoaWQsIHRyYXZlcnNlVXAsIGFyZyk7XG4gICAgfVxuICAgIGlmIChyZXQgPT09IGZhbHNlIHx8IGlkID09PSBzdG9wKSB7XG4gICAgICAvLyBPbmx5IGJyZWFrIC8vYWZ0ZXIvLyB2aXNpdGluZyBgc3RvcGAuXG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgIGRlcHRoKysgPCBNQVhfVFJFRV9ERVBUSCxcbiAgICAgICd0cmF2ZXJzZVBhcmVudFBhdGgoJXMsICVzLCAuLi4pOiBEZXRlY3RlZCBhbiBpbmZpbml0ZSBsb29wIHdoaWxlICcgK1xuICAgICAgJ3RyYXZlcnNpbmcgdGhlIFJlYWN0IERPTSBJRCB0cmVlLiBUaGlzIG1heSBiZSBkdWUgdG8gbWFsZm9ybWVkIElEczogJXMnLFxuICAgICAgc3RhcnQsIHN0b3BcbiAgICApIDogaW52YXJpYW50KGRlcHRoKysgPCBNQVhfVFJFRV9ERVBUSCkpO1xuICB9XG59XG5cbi8qKlxuICogTWFuYWdlcyB0aGUgSURzIGFzc2lnbmVkIHRvIERPTSByZXByZXNlbnRhdGlvbnMgb2YgUmVhY3QgY29tcG9uZW50cy4gVGhpc1xuICogdXNlcyBhIHNwZWNpZmljIHNjaGVtZSBpbiBvcmRlciB0byB0cmF2ZXJzZSB0aGUgRE9NIGVmZmljaWVudGx5IChlLmcuIGluXG4gKiBvcmRlciB0byBzaW11bGF0ZSBldmVudHMpLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RJbnN0YW5jZUhhbmRsZXMgPSB7XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBSZWFjdCByb290IElEXG4gICAqIEByZXR1cm4ge3N0cmluZ30gQSBSZWFjdCByb290IElELlxuICAgKi9cbiAgY3JlYXRlUmVhY3RSb290SUQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBnZXRSZWFjdFJvb3RJRFN0cmluZyhSZWFjdFJvb3RJbmRleC5jcmVhdGVSZWFjdFJvb3RJbmRleCgpKTtcbiAgfSxcblxuICAvKipcbiAgICogQ29uc3RydWN0cyBhIFJlYWN0IElEIGJ5IGpvaW5pbmcgYSByb290IElEIHdpdGggYSBuYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcm9vdElEIFJvb3QgSUQgb2YgYSBwYXJlbnQgY29tcG9uZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBBIGNvbXBvbmVudCdzIG5hbWUgKGFzIGZsYXR0ZW5lZCBjaGlsZHJlbikuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gQSBSZWFjdCBJRC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBjcmVhdGVSZWFjdElEOiBmdW5jdGlvbihyb290SUQsIG5hbWUpIHtcbiAgICByZXR1cm4gcm9vdElEICsgbmFtZTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyB0aGUgRE9NIElEIG9mIHRoZSBSZWFjdCBjb21wb25lbnQgdGhhdCBpcyB0aGUgcm9vdCBvZiB0aGUgdHJlZSB0aGF0XG4gICAqIGNvbnRhaW5zIHRoZSBSZWFjdCBjb21wb25lbnQgd2l0aCB0aGUgc3VwcGxpZWQgRE9NIElELlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgRE9NIElEIG9mIGEgUmVhY3QgY29tcG9uZW50LlxuICAgKiBAcmV0dXJuIHs/c3RyaW5nfSBET00gSUQgb2YgdGhlIFJlYWN0IGNvbXBvbmVudCB0aGF0IGlzIHRoZSByb290LlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldFJlYWN0Um9vdElERnJvbU5vZGVJRDogZnVuY3Rpb24oaWQpIHtcbiAgICBpZiAoaWQgJiYgaWQuY2hhckF0KDApID09PSBTRVBBUkFUT1IgJiYgaWQubGVuZ3RoID4gMSkge1xuICAgICAgdmFyIGluZGV4ID0gaWQuaW5kZXhPZihTRVBBUkFUT1IsIDEpO1xuICAgICAgcmV0dXJuIGluZGV4ID4gLTEgPyBpZC5zdWJzdHIoMCwgaW5kZXgpIDogaWQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmF2ZXJzZXMgdGhlIElEIGhpZXJhcmNoeSBhbmQgaW52b2tlcyB0aGUgc3VwcGxpZWQgYGNiYCBvbiBhbnkgSURzIHRoYXRcbiAgICogc2hvdWxkIHdvdWxkIHJlY2VpdmUgYSBgbW91c2VFbnRlcmAgb3IgYG1vdXNlTGVhdmVgIGV2ZW50LlxuICAgKlxuICAgKiBOT1RFOiBEb2VzIG5vdCBpbnZva2UgdGhlIGNhbGxiYWNrIG9uIHRoZSBuZWFyZXN0IGNvbW1vbiBhbmNlc3RvciBiZWNhdXNlXG4gICAqIG5vdGhpbmcgXCJlbnRlcmVkXCIgb3IgXCJsZWZ0XCIgdGhhdCBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGVhdmVJRCBJRCBiZWluZyBsZWZ0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZW50ZXJJRCBJRCBiZWluZyBlbnRlcmVkLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYiBDYWxsYmFjayB0byBpbnZva2Ugb24gZWFjaCBlbnRlcmVkL2xlZnQgSUQuXG4gICAqIEBwYXJhbSB7Kn0gdXBBcmcgQXJndW1lbnQgdG8gaW52b2tlIHRoZSBjYWxsYmFjayB3aXRoIG9uIGxlZnQgSURzLlxuICAgKiBAcGFyYW0geyp9IGRvd25BcmcgQXJndW1lbnQgdG8gaW52b2tlIHRoZSBjYWxsYmFjayB3aXRoIG9uIGVudGVyZWQgSURzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHRyYXZlcnNlRW50ZXJMZWF2ZTogZnVuY3Rpb24obGVhdmVJRCwgZW50ZXJJRCwgY2IsIHVwQXJnLCBkb3duQXJnKSB7XG4gICAgdmFyIGFuY2VzdG9ySUQgPSBnZXRGaXJzdENvbW1vbkFuY2VzdG9ySUQobGVhdmVJRCwgZW50ZXJJRCk7XG4gICAgaWYgKGFuY2VzdG9ySUQgIT09IGxlYXZlSUQpIHtcbiAgICAgIHRyYXZlcnNlUGFyZW50UGF0aChsZWF2ZUlELCBhbmNlc3RvcklELCBjYiwgdXBBcmcsIGZhbHNlLCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKGFuY2VzdG9ySUQgIT09IGVudGVySUQpIHtcbiAgICAgIHRyYXZlcnNlUGFyZW50UGF0aChhbmNlc3RvcklELCBlbnRlcklELCBjYiwgZG93bkFyZywgdHJ1ZSwgZmFsc2UpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU2ltdWxhdGVzIHRoZSB0cmF2ZXJzYWwgb2YgYSB0d28tcGhhc2UsIGNhcHR1cmUvYnViYmxlIGV2ZW50IGRpc3BhdGNoLlxuICAgKlxuICAgKiBOT1RFOiBUaGlzIHRyYXZlcnNhbCBoYXBwZW5zIG9uIElEcyB3aXRob3V0IHRvdWNoaW5nIHRoZSBET00uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXRJRCBJRCBvZiB0aGUgdGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiIENhbGxiYWNrIHRvIGludm9rZS5cbiAgICogQHBhcmFtIHsqfSBhcmcgQXJndW1lbnQgdG8gaW52b2tlIHRoZSBjYWxsYmFjayB3aXRoLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHRyYXZlcnNlVHdvUGhhc2U6IGZ1bmN0aW9uKHRhcmdldElELCBjYiwgYXJnKSB7XG4gICAgaWYgKHRhcmdldElEKSB7XG4gICAgICB0cmF2ZXJzZVBhcmVudFBhdGgoJycsIHRhcmdldElELCBjYiwgYXJnLCB0cnVlLCBmYWxzZSk7XG4gICAgICB0cmF2ZXJzZVBhcmVudFBhdGgodGFyZ2V0SUQsICcnLCBjYiwgYXJnLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBUcmF2ZXJzZSBhIG5vZGUgSUQsIGNhbGxpbmcgdGhlIHN1cHBsaWVkIGBjYmAgZm9yIGVhY2ggYW5jZXN0b3IgSUQuIEZvclxuICAgKiBleGFtcGxlLCBwYXNzaW5nIGAuMC4kcm93LTAuMWAgd291bGQgcmVzdWx0IGluIGBjYmAgZ2V0dGluZyBjYWxsZWRcbiAgICogd2l0aCBgLjBgLCBgLjAuJHJvdy0wYCwgYW5kIGAuMC4kcm93LTAuMWAuXG4gICAqXG4gICAqIE5PVEU6IFRoaXMgdHJhdmVyc2FsIGhhcHBlbnMgb24gSURzIHdpdGhvdXQgdG91Y2hpbmcgdGhlIERPTS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldElEIElEIG9mIHRoZSB0YXJnZXQgbm9kZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2IgQ2FsbGJhY2sgdG8gaW52b2tlLlxuICAgKiBAcGFyYW0geyp9IGFyZyBBcmd1bWVudCB0byBpbnZva2UgdGhlIGNhbGxiYWNrIHdpdGguXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdHJhdmVyc2VBbmNlc3RvcnM6IGZ1bmN0aW9uKHRhcmdldElELCBjYiwgYXJnKSB7XG4gICAgdHJhdmVyc2VQYXJlbnRQYXRoKCcnLCB0YXJnZXRJRCwgY2IsIGFyZywgdHJ1ZSwgZmFsc2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFeHBvc2VkIGZvciB1bml0IHRlc3RpbmcuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0Rmlyc3RDb21tb25BbmNlc3RvcklEOiBnZXRGaXJzdENvbW1vbkFuY2VzdG9ySUQsXG5cbiAgLyoqXG4gICAqIEV4cG9zZWQgZm9yIHVuaXQgdGVzdGluZy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXROZXh0RGVzY2VuZGFudElEOiBnZXROZXh0RGVzY2VuZGFudElELFxuXG4gIGlzQW5jZXN0b3JJRE9mOiBpc0FuY2VzdG9ySURPZixcblxuICBTRVBBUkFUT1I6IFNFUEFSQVRPUlxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SW5zdGFuY2VIYW5kbGVzO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RMaW5rXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFJlYWN0TGluayBlbmNhcHN1bGF0ZXMgYSBjb21tb24gcGF0dGVybiBpbiB3aGljaCBhIGNvbXBvbmVudCB3YW50cyB0byBtb2RpZnlcbiAqIGEgcHJvcCByZWNlaXZlZCBmcm9tIGl0cyBwYXJlbnQuIFJlYWN0TGluayBhbGxvd3MgdGhlIHBhcmVudCB0byBwYXNzIGRvd24gYVxuICogdmFsdWUgY291cGxlZCB3aXRoIGEgY2FsbGJhY2sgdGhhdCwgd2hlbiBpbnZva2VkLCBleHByZXNzZXMgYW4gaW50ZW50IHRvXG4gKiBtb2RpZnkgdGhhdCB2YWx1ZS4gRm9yIGV4YW1wbGU6XG4gKlxuICogUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICogICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uKCkge1xuICogICAgIHJldHVybiB7dmFsdWU6ICcnfTtcbiAqICAgfSxcbiAqICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAqICAgICB2YXIgdmFsdWVMaW5rID0gbmV3IFJlYWN0TGluayh0aGlzLnN0YXRlLnZhbHVlLCB0aGlzLl9oYW5kbGVWYWx1ZUNoYW5nZSk7XG4gKiAgICAgcmV0dXJuIDxpbnB1dCB2YWx1ZUxpbms9e3ZhbHVlTGlua30gLz47XG4gKiAgIH0sXG4gKiAgIHRoaXMuX2hhbmRsZVZhbHVlQ2hhbmdlOiBmdW5jdGlvbihuZXdWYWx1ZSkge1xuICogICAgIHRoaXMuc2V0U3RhdGUoe3ZhbHVlOiBuZXdWYWx1ZX0pO1xuICogICB9XG4gKiB9KTtcbiAqXG4gKiBXZSBoYXZlIHByb3ZpZGVkIHNvbWUgc3VnYXJ5IG1peGlucyB0byBtYWtlIHRoZSBjcmVhdGlvbiBhbmRcbiAqIGNvbnN1bXB0aW9uIG9mIFJlYWN0TGluayBlYXNpZXI7IHNlZSBMaW5rZWRWYWx1ZVV0aWxzIGFuZCBMaW5rZWRTdGF0ZU1peGluLlxuICovXG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoXCIuL1JlYWN0XCIpO1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgY3VycmVudCB2YWx1ZSBvZiB0aGUgbGlua1xuICogQHBhcmFtIHtmdW5jdGlvbn0gcmVxdWVzdENoYW5nZSBjYWxsYmFjayB0byByZXF1ZXN0IGEgY2hhbmdlXG4gKi9cbmZ1bmN0aW9uIFJlYWN0TGluayh2YWx1ZSwgcmVxdWVzdENoYW5nZSkge1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIHRoaXMucmVxdWVzdENoYW5nZSA9IHJlcXVlc3RDaGFuZ2U7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIFByb3BUeXBlIHRoYXQgZW5mb3JjZXMgdGhlIFJlYWN0TGluayBBUEkgYW5kIG9wdGlvbmFsbHkgY2hlY2tzIHRoZVxuICogdHlwZSBvZiB0aGUgdmFsdWUgYmVpbmcgcGFzc2VkIGluc2lkZSB0aGUgbGluay4gRXhhbXBsZTpcbiAqXG4gKiBNeUNvbXBvbmVudC5wcm9wVHlwZXMgPSB7XG4gKiAgIHRhYkluZGV4TGluazogUmVhY3RMaW5rLlByb3BUeXBlcy5saW5rKFJlYWN0LlByb3BUeXBlcy5udW1iZXIpXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUxpbmtUeXBlQ2hlY2tlcihsaW5rVHlwZSkge1xuICB2YXIgc2hhcGVzID0ge1xuICAgIHZhbHVlOiB0eXBlb2YgbGlua1R5cGUgPT09ICd1bmRlZmluZWQnID9cbiAgICAgIFJlYWN0LlByb3BUeXBlcy5hbnkuaXNSZXF1aXJlZCA6XG4gICAgICBsaW5rVHlwZS5pc1JlcXVpcmVkLFxuICAgIHJlcXVlc3RDaGFuZ2U6IFJlYWN0LlByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbiAgfTtcbiAgcmV0dXJuIFJlYWN0LlByb3BUeXBlcy5zaGFwZShzaGFwZXMpO1xufVxuXG5SZWFjdExpbmsuUHJvcFR5cGVzID0ge1xuICBsaW5rOiBjcmVhdGVMaW5rVHlwZUNoZWNrZXJcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RMaW5rO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0TWFya3VwQ2hlY2tzdW1cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGFkbGVyMzIgPSByZXF1aXJlKFwiLi9hZGxlcjMyXCIpO1xuXG52YXIgUmVhY3RNYXJrdXBDaGVja3N1bSA9IHtcbiAgQ0hFQ0tTVU1fQVRUUl9OQU1FOiAnZGF0YS1yZWFjdC1jaGVja3N1bScsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgTWFya3VwIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IE1hcmt1cCBzdHJpbmcgd2l0aCBjaGVja3N1bSBhdHRyaWJ1dGUgYXR0YWNoZWRcbiAgICovXG4gIGFkZENoZWNrc3VtVG9NYXJrdXA6IGZ1bmN0aW9uKG1hcmt1cCkge1xuICAgIHZhciBjaGVja3N1bSA9IGFkbGVyMzIobWFya3VwKTtcbiAgICByZXR1cm4gbWFya3VwLnJlcGxhY2UoXG4gICAgICAnPicsXG4gICAgICAnICcgKyBSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSArICc9XCInICsgY2hlY2tzdW0gKyAnXCI+J1xuICAgICk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgdG8gdXNlXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gZWxlbWVudCByb290IFJlYWN0IGVsZW1lbnRcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgb3Igbm90IHRoZSBtYXJrdXAgaXMgdGhlIHNhbWVcbiAgICovXG4gIGNhblJldXNlTWFya3VwOiBmdW5jdGlvbihtYXJrdXAsIGVsZW1lbnQpIHtcbiAgICB2YXIgZXhpc3RpbmdDaGVja3N1bSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFxuICAgICAgUmVhY3RNYXJrdXBDaGVja3N1bS5DSEVDS1NVTV9BVFRSX05BTUVcbiAgICApO1xuICAgIGV4aXN0aW5nQ2hlY2tzdW0gPSBleGlzdGluZ0NoZWNrc3VtICYmIHBhcnNlSW50KGV4aXN0aW5nQ2hlY2tzdW0sIDEwKTtcbiAgICB2YXIgbWFya3VwQ2hlY2tzdW0gPSBhZGxlcjMyKG1hcmt1cCk7XG4gICAgcmV0dXJuIG1hcmt1cENoZWNrc3VtID09PSBleGlzdGluZ0NoZWNrc3VtO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0TWFya3VwQ2hlY2tzdW07XG4iLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0TW91bnRcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZShcIi4vRE9NUHJvcGVydHlcIik7XG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcIi4vUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyXCIpO1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZShcIi4vUmVhY3RDdXJyZW50T3duZXJcIik7XG52YXIgUmVhY3REZXNjcmlwdG9yID0gcmVxdWlyZShcIi4vUmVhY3REZXNjcmlwdG9yXCIpO1xudmFyIFJlYWN0SW5zdGFuY2VIYW5kbGVzID0gcmVxdWlyZShcIi4vUmVhY3RJbnN0YW5jZUhhbmRsZXNcIik7XG52YXIgUmVhY3RQZXJmID0gcmVxdWlyZShcIi4vUmVhY3RQZXJmXCIpO1xuXG52YXIgY29udGFpbnNOb2RlID0gcmVxdWlyZShcIi4vY29udGFpbnNOb2RlXCIpO1xudmFyIGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lciA9IHJlcXVpcmUoXCIuL2dldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lclwiKTtcbnZhciBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZShcIi4vaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudFwiKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG52YXIgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKFwiLi9zaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudFwiKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZShcIi4vd2FybmluZ1wiKTtcblxudmFyIFNFUEFSQVRPUiA9IFJlYWN0SW5zdGFuY2VIYW5kbGVzLlNFUEFSQVRPUjtcblxudmFyIEFUVFJfTkFNRSA9IERPTVByb3BlcnR5LklEX0FUVFJJQlVURV9OQU1FO1xudmFyIG5vZGVDYWNoZSA9IHt9O1xuXG52YXIgRUxFTUVOVF9OT0RFX1RZUEUgPSAxO1xudmFyIERPQ19OT0RFX1RZUEUgPSA5O1xuXG4vKiogTWFwcGluZyBmcm9tIHJlYWN0Um9vdElEIHRvIFJlYWN0IGNvbXBvbmVudCBpbnN0YW5jZS4gKi9cbnZhciBpbnN0YW5jZXNCeVJlYWN0Um9vdElEID0ge307XG5cbi8qKiBNYXBwaW5nIGZyb20gcmVhY3RSb290SUQgdG8gYGNvbnRhaW5lcmAgbm9kZXMuICovXG52YXIgY29udGFpbmVyc0J5UmVhY3RSb290SUQgPSB7fTtcblxuaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAvKiogX19ERVZfXy1vbmx5IG1hcHBpbmcgZnJvbSByZWFjdFJvb3RJRCB0byByb290IGVsZW1lbnRzLiAqL1xuICB2YXIgcm9vdEVsZW1lbnRzQnlSZWFjdFJvb3RJRCA9IHt9O1xufVxuXG4vLyBVc2VkIHRvIHN0b3JlIGJyZWFkdGgtZmlyc3Qgc2VhcmNoIHN0YXRlIGluIGZpbmRDb21wb25lbnRSb290LlxudmFyIGZpbmRDb21wb25lbnRSb290UmV1c2FibGVBcnJheSA9IFtdO1xuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRoYXQgbWF5IGNvbnRhaW4gYSBSZWFjdCBjb21wb25lbnQuXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBBIFwicmVhY3RSb290XCIgSUQsIGlmIGEgUmVhY3QgY29tcG9uZW50IGlzIHJlbmRlcmVkLlxuICovXG5mdW5jdGlvbiBnZXRSZWFjdFJvb3RJRChjb250YWluZXIpIHtcbiAgdmFyIHJvb3RFbGVtZW50ID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gIHJldHVybiByb290RWxlbWVudCAmJiBSZWFjdE1vdW50LmdldElEKHJvb3RFbGVtZW50KTtcbn1cblxuLyoqXG4gKiBBY2Nlc3Npbmcgbm9kZVtBVFRSX05BTUVdIG9yIGNhbGxpbmcgZ2V0QXR0cmlidXRlKEFUVFJfTkFNRSkgb24gYSBmb3JtXG4gKiBlbGVtZW50IGNhbiByZXR1cm4gaXRzIGNvbnRyb2wgd2hvc2UgbmFtZSBvciBJRCBlcXVhbHMgQVRUUl9OQU1FLiBBbGxcbiAqIERPTSBub2RlcyBzdXBwb3J0IGBnZXRBdHRyaWJ1dGVOb2RlYCBidXQgdGhpcyBjYW4gYWxzbyBnZXQgY2FsbGVkIG9uXG4gKiBvdGhlciBvYmplY3RzIHNvIGp1c3QgcmV0dXJuICcnIGlmIHdlJ3JlIGdpdmVuIHNvbWV0aGluZyBvdGhlciB0aGFuIGFcbiAqIERPTSBub2RlIChzdWNoIGFzIHdpbmRvdykuXG4gKlxuICogQHBhcmFtIHs/RE9NRWxlbWVudHxET01XaW5kb3d8RE9NRG9jdW1lbnR8RE9NVGV4dE5vZGV9IG5vZGUgRE9NIG5vZGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IElEIG9mIHRoZSBzdXBwbGllZCBgZG9tTm9kZWAuXG4gKi9cbmZ1bmN0aW9uIGdldElEKG5vZGUpIHtcbiAgdmFyIGlkID0gaW50ZXJuYWxHZXRJRChub2RlKTtcbiAgaWYgKGlkKSB7XG4gICAgaWYgKG5vZGVDYWNoZS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgIHZhciBjYWNoZWQgPSBub2RlQ2FjaGVbaWRdO1xuICAgICAgaWYgKGNhY2hlZCAhPT0gbm9kZSkge1xuICAgICAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgICAgICFpc1ZhbGlkKGNhY2hlZCwgaWQpLFxuICAgICAgICAgICdSZWFjdE1vdW50OiBUd28gdmFsaWQgYnV0IHVuZXF1YWwgbm9kZXMgd2l0aCB0aGUgc2FtZSBgJXNgOiAlcycsXG4gICAgICAgICAgQVRUUl9OQU1FLCBpZFxuICAgICAgICApIDogaW52YXJpYW50KCFpc1ZhbGlkKGNhY2hlZCwgaWQpKSk7XG5cbiAgICAgICAgbm9kZUNhY2hlW2lkXSA9IG5vZGU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGVDYWNoZVtpZF0gPSBub2RlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpZDtcbn1cblxuZnVuY3Rpb24gaW50ZXJuYWxHZXRJRChub2RlKSB7XG4gIC8vIElmIG5vZGUgaXMgc29tZXRoaW5nIGxpa2UgYSB3aW5kb3csIGRvY3VtZW50LCBvciB0ZXh0IG5vZGUsIG5vbmUgb2ZcbiAgLy8gd2hpY2ggc3VwcG9ydCBhdHRyaWJ1dGVzIG9yIGEgLmdldEF0dHJpYnV0ZSBtZXRob2QsIGdyYWNlZnVsbHkgcmV0dXJuXG4gIC8vIHRoZSBlbXB0eSBzdHJpbmcsIGFzIGlmIHRoZSBhdHRyaWJ1dGUgd2VyZSBtaXNzaW5nLlxuICByZXR1cm4gbm9kZSAmJiBub2RlLmdldEF0dHJpYnV0ZSAmJiBub2RlLmdldEF0dHJpYnV0ZShBVFRSX05BTUUpIHx8ICcnO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIFJlYWN0LXNwZWNpZmljIElEIG9mIHRoZSBnaXZlbiBub2RlLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZSBUaGUgRE9NIG5vZGUgd2hvc2UgSUQgd2lsbCBiZSBzZXQuXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIHZhbHVlIG9mIHRoZSBJRCBhdHRyaWJ1dGUuXG4gKi9cbmZ1bmN0aW9uIHNldElEKG5vZGUsIGlkKSB7XG4gIHZhciBvbGRJRCA9IGludGVybmFsR2V0SUQobm9kZSk7XG4gIGlmIChvbGRJRCAhPT0gaWQpIHtcbiAgICBkZWxldGUgbm9kZUNhY2hlW29sZElEXTtcbiAgfVxuICBub2RlLnNldEF0dHJpYnV0ZShBVFRSX05BTUUsIGlkKTtcbiAgbm9kZUNhY2hlW2lkXSA9IG5vZGU7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIG5vZGUgd2l0aCB0aGUgc3VwcGxpZWQgUmVhY3QtZ2VuZXJhdGVkIERPTSBJRC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgQSBSZWFjdC1nZW5lcmF0ZWQgRE9NIElELlxuICogQHJldHVybiB7RE9NRWxlbWVudH0gRE9NIG5vZGUgd2l0aCB0aGUgc3VwcGxlZCBgaWRgLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldE5vZGUoaWQpIHtcbiAgaWYgKCFub2RlQ2FjaGUuaGFzT3duUHJvcGVydHkoaWQpIHx8ICFpc1ZhbGlkKG5vZGVDYWNoZVtpZF0sIGlkKSkge1xuICAgIG5vZGVDYWNoZVtpZF0gPSBSZWFjdE1vdW50LmZpbmRSZWFjdE5vZGVCeUlEKGlkKTtcbiAgfVxuICByZXR1cm4gbm9kZUNhY2hlW2lkXTtcbn1cblxuLyoqXG4gKiBBIG5vZGUgaXMgXCJ2YWxpZFwiIGlmIGl0IGlzIGNvbnRhaW5lZCBieSBhIGN1cnJlbnRseSBtb3VudGVkIGNvbnRhaW5lci5cbiAqXG4gKiBUaGlzIG1lYW5zIHRoYXQgdGhlIG5vZGUgZG9lcyBub3QgaGF2ZSB0byBiZSBjb250YWluZWQgYnkgYSBkb2N1bWVudCBpblxuICogb3JkZXIgdG8gYmUgY29uc2lkZXJlZCB2YWxpZC5cbiAqXG4gKiBAcGFyYW0gez9ET01FbGVtZW50fSBub2RlIFRoZSBjYW5kaWRhdGUgRE9NIG5vZGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIGV4cGVjdGVkIElEIG9mIHRoZSBub2RlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgbm9kZSBpcyBjb250YWluZWQgYnkgYSBtb3VudGVkIGNvbnRhaW5lci5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZChub2RlLCBpZCkge1xuICBpZiAobm9kZSkge1xuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICBpbnRlcm5hbEdldElEKG5vZGUpID09PSBpZCxcbiAgICAgICdSZWFjdE1vdW50OiBVbmV4cGVjdGVkIG1vZGlmaWNhdGlvbiBvZiBgJXNgJyxcbiAgICAgIEFUVFJfTkFNRVxuICAgICkgOiBpbnZhcmlhbnQoaW50ZXJuYWxHZXRJRChub2RlKSA9PT0gaWQpKTtcblxuICAgIHZhciBjb250YWluZXIgPSBSZWFjdE1vdW50LmZpbmRSZWFjdENvbnRhaW5lckZvcklEKGlkKTtcbiAgICBpZiAoY29udGFpbmVyICYmIGNvbnRhaW5zTm9kZShjb250YWluZXIsIG5vZGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ2F1c2VzIHRoZSBjYWNoZSB0byBmb3JnZXQgYWJvdXQgb25lIFJlYWN0LXNwZWNpZmljIElELlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgSUQgdG8gZm9yZ2V0LlxuICovXG5mdW5jdGlvbiBwdXJnZUlEKGlkKSB7XG4gIGRlbGV0ZSBub2RlQ2FjaGVbaWRdO1xufVxuXG52YXIgZGVlcGVzdE5vZGVTb0ZhciA9IG51bGw7XG5mdW5jdGlvbiBmaW5kRGVlcGVzdENhY2hlZEFuY2VzdG9ySW1wbChhbmNlc3RvcklEKSB7XG4gIHZhciBhbmNlc3RvciA9IG5vZGVDYWNoZVthbmNlc3RvcklEXTtcbiAgaWYgKGFuY2VzdG9yICYmIGlzVmFsaWQoYW5jZXN0b3IsIGFuY2VzdG9ySUQpKSB7XG4gICAgZGVlcGVzdE5vZGVTb0ZhciA9IGFuY2VzdG9yO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgbm9kZSBpc24ndCBwb3B1bGF0ZWQgaW4gdGhlIGNhY2hlLCBzbyBwcmVzdW1hYmx5IG5vbmUgb2YgaXRzXG4gICAgLy8gZGVzY2VuZGFudHMgYXJlLiBCcmVhayBvdXQgb2YgdGhlIGxvb3AuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBkZWVwZXN0IGNhY2hlZCBub2RlIHdob3NlIElEIGlzIGEgcHJlZml4IG9mIGB0YXJnZXRJRGAuXG4gKi9cbmZ1bmN0aW9uIGZpbmREZWVwZXN0Q2FjaGVkQW5jZXN0b3IodGFyZ2V0SUQpIHtcbiAgZGVlcGVzdE5vZGVTb0ZhciA9IG51bGw7XG4gIFJlYWN0SW5zdGFuY2VIYW5kbGVzLnRyYXZlcnNlQW5jZXN0b3JzKFxuICAgIHRhcmdldElELFxuICAgIGZpbmREZWVwZXN0Q2FjaGVkQW5jZXN0b3JJbXBsXG4gICk7XG5cbiAgdmFyIGZvdW5kTm9kZSA9IGRlZXBlc3ROb2RlU29GYXI7XG4gIGRlZXBlc3ROb2RlU29GYXIgPSBudWxsO1xuICByZXR1cm4gZm91bmROb2RlO1xufVxuXG4vKipcbiAqIE1vdW50aW5nIGlzIHRoZSBwcm9jZXNzIG9mIGluaXRpYWxpemluZyBhIFJlYWN0IGNvbXBvbmVudCBieSBjcmVhdGluZ3MgaXRzXG4gKiByZXByZXNlbnRhdGl2ZSBET00gZWxlbWVudHMgYW5kIGluc2VydGluZyB0aGVtIGludG8gYSBzdXBwbGllZCBgY29udGFpbmVyYC5cbiAqIEFueSBwcmlvciBjb250ZW50IGluc2lkZSBgY29udGFpbmVyYCBpcyBkZXN0cm95ZWQgaW4gdGhlIHByb2Nlc3MuXG4gKlxuICogICBSZWFjdE1vdW50LnJlbmRlckNvbXBvbmVudChcbiAqICAgICBjb21wb25lbnQsXG4gKiAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbnRhaW5lcicpXG4gKiAgICk7XG4gKlxuICogICA8ZGl2IGlkPVwiY29udGFpbmVyXCI+ICAgICAgICAgICAgICAgICAgIDwtLSBTdXBwbGllZCBgY29udGFpbmVyYC5cbiAqICAgICA8ZGl2IGRhdGEtcmVhY3RpZD1cIi4zXCI+ICAgICAgICAgICAgICA8LS0gUmVuZGVyZWQgcmVhY3RSb290IG9mIFJlYWN0XG4gKiAgICAgICAvLyAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuXG4gKiAgICAgPC9kaXY+XG4gKiAgIDwvZGl2PlxuICpcbiAqIEluc2lkZSBvZiBgY29udGFpbmVyYCwgdGhlIGZpcnN0IGVsZW1lbnQgcmVuZGVyZWQgaXMgdGhlIFwicmVhY3RSb290XCIuXG4gKi9cbnZhciBSZWFjdE1vdW50ID0ge1xuICAvKiogRXhwb3NlZCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzICoqL1xuICBfaW5zdGFuY2VzQnlSZWFjdFJvb3RJRDogaW5zdGFuY2VzQnlSZWFjdFJvb3RJRCxcblxuICAvKipcbiAgICogVGhpcyBpcyBhIGhvb2sgcHJvdmlkZWQgdG8gc3VwcG9ydCByZW5kZXJpbmcgUmVhY3QgY29tcG9uZW50cyB3aGlsZVxuICAgKiBlbnN1cmluZyB0aGF0IHRoZSBhcHBhcmVudCBzY3JvbGwgcG9zaXRpb24gb2YgaXRzIGBjb250YWluZXJgIGRvZXMgbm90XG4gICAqIGNoYW5nZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgVGhlIGBjb250YWluZXJgIGJlaW5nIHJlbmRlcmVkIGludG8uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IHJlbmRlckNhbGxiYWNrIFRoaXMgbXVzdCBiZSBjYWxsZWQgb25jZSB0byBkbyB0aGUgcmVuZGVyLlxuICAgKi9cbiAgc2Nyb2xsTW9uaXRvcjogZnVuY3Rpb24oY29udGFpbmVyLCByZW5kZXJDYWxsYmFjaykge1xuICAgIHJlbmRlckNhbGxiYWNrKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRha2UgYSBjb21wb25lbnQgdGhhdCdzIGFscmVhZHkgbW91bnRlZCBpbnRvIHRoZSBET00gYW5kIHJlcGxhY2UgaXRzIHByb3BzXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IHByZXZDb21wb25lbnQgY29tcG9uZW50IGluc3RhbmNlIGFscmVhZHkgaW4gdGhlIERPTVxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBuZXh0Q29tcG9uZW50IGNvbXBvbmVudCBpbnN0YW5jZSB0byByZW5kZXJcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgY29udGFpbmVyIHRvIHJlbmRlciBpbnRvXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbiB0cmlnZ2VyZWQgb24gY29tcGxldGlvblxuICAgKi9cbiAgX3VwZGF0ZVJvb3RDb21wb25lbnQ6IGZ1bmN0aW9uKFxuICAgICAgcHJldkNvbXBvbmVudCxcbiAgICAgIG5leHRDb21wb25lbnQsXG4gICAgICBjb250YWluZXIsXG4gICAgICBjYWxsYmFjaykge1xuICAgIHZhciBuZXh0UHJvcHMgPSBuZXh0Q29tcG9uZW50LnByb3BzO1xuICAgIFJlYWN0TW91bnQuc2Nyb2xsTW9uaXRvcihjb250YWluZXIsIGZ1bmN0aW9uKCkge1xuICAgICAgcHJldkNvbXBvbmVudC5yZXBsYWNlUHJvcHMobmV4dFByb3BzLCBjYWxsYmFjayk7XG4gICAgfSk7XG5cbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAvLyBSZWNvcmQgdGhlIHJvb3QgZWxlbWVudCBpbiBjYXNlIGl0IGxhdGVyIGdldHMgdHJhbnNwbGFudGVkLlxuICAgICAgcm9vdEVsZW1lbnRzQnlSZWFjdFJvb3RJRFtnZXRSZWFjdFJvb3RJRChjb250YWluZXIpXSA9XG4gICAgICAgIGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBwcmV2Q29tcG9uZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGNvbXBvbmVudCBpbnRvIHRoZSBpbnN0YW5jZSBtYXAgYW5kIHN0YXJ0cyBzY3JvbGwgdmFsdWVcbiAgICogbW9uaXRvcmluZ1xuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBuZXh0Q29tcG9uZW50IGNvbXBvbmVudCBpbnN0YW5jZSB0byByZW5kZXJcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgY29udGFpbmVyIHRvIHJlbmRlciBpbnRvXG4gICAqIEByZXR1cm4ge3N0cmluZ30gcmVhY3RSb290IElEIHByZWZpeFxuICAgKi9cbiAgX3JlZ2lzdGVyQ29tcG9uZW50OiBmdW5jdGlvbihuZXh0Q29tcG9uZW50LCBjb250YWluZXIpIHtcbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgY29udGFpbmVyICYmIChcbiAgICAgICAgY29udGFpbmVyLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREVfVFlQRSB8fFxuICAgICAgICBjb250YWluZXIubm9kZVR5cGUgPT09IERPQ19OT0RFX1RZUEVcbiAgICAgICksXG4gICAgICAnX3JlZ2lzdGVyQ29tcG9uZW50KC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJ1xuICAgICkgOiBpbnZhcmlhbnQoY29udGFpbmVyICYmIChcbiAgICAgIGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFX1RZUEUgfHxcbiAgICAgIGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRVxuICAgICkpKTtcblxuICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5lbnN1cmVTY3JvbGxWYWx1ZU1vbml0b3JpbmcoKTtcblxuICAgIHZhciByZWFjdFJvb3RJRCA9IFJlYWN0TW91bnQucmVnaXN0ZXJDb250YWluZXIoY29udGFpbmVyKTtcbiAgICBpbnN0YW5jZXNCeVJlYWN0Um9vdElEW3JlYWN0Um9vdElEXSA9IG5leHRDb21wb25lbnQ7XG4gICAgcmV0dXJuIHJlYWN0Um9vdElEO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXIgYSBuZXcgY29tcG9uZW50IGludG8gdGhlIERPTS5cbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gbmV4dENvbXBvbmVudCBjb21wb25lbnQgaW5zdGFuY2UgdG8gcmVuZGVyXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIGNvbnRhaW5lciB0byByZW5kZXIgaW50b1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZFJldXNlTWFya3VwIGlmIHdlIHNob3VsZCBza2lwIHRoZSBtYXJrdXAgaW5zZXJ0aW9uXG4gICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fSBuZXh0Q29tcG9uZW50XG4gICAqL1xuICBfcmVuZGVyTmV3Um9vdENvbXBvbmVudDogUmVhY3RQZXJmLm1lYXN1cmUoXG4gICAgJ1JlYWN0TW91bnQnLFxuICAgICdfcmVuZGVyTmV3Um9vdENvbXBvbmVudCcsXG4gICAgZnVuY3Rpb24oXG4gICAgICAgIG5leHRDb21wb25lbnQsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgc2hvdWxkUmV1c2VNYXJrdXApIHtcbiAgICAgIC8vIFZhcmlvdXMgcGFydHMgb2Ygb3VyIGNvZGUgKHN1Y2ggYXMgUmVhY3RDb21wb3NpdGVDb21wb25lbnQnc1xuICAgICAgLy8gX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCkgYXNzdW1lIHRoYXQgY2FsbHMgdG8gcmVuZGVyIGFyZW4ndCBuZXN0ZWQ7XG4gICAgICAvLyB2ZXJpZnkgdGhhdCB0aGF0J3MgdGhlIGNhc2UuXG4gICAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyhcbiAgICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9PSBudWxsLFxuICAgICAgICAnX3JlbmRlck5ld1Jvb3RDb21wb25lbnQoKTogUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiAnICtcbiAgICAgICAgJ29mIHByb3BzIGFuZCBzdGF0ZTsgdHJpZ2dlcmluZyBuZXN0ZWQgY29tcG9uZW50IHVwZGF0ZXMgZnJvbSAnICtcbiAgICAgICAgJ3JlbmRlciBpcyBub3QgYWxsb3dlZC4gSWYgbmVjZXNzYXJ5LCB0cmlnZ2VyIG5lc3RlZCB1cGRhdGVzIGluICcgK1xuICAgICAgICAnY29tcG9uZW50RGlkVXBkYXRlLidcbiAgICAgICkgOiBudWxsKTtcblxuICAgICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChuZXh0Q29tcG9uZW50KTtcbiAgICAgIHZhciByZWFjdFJvb3RJRCA9IFJlYWN0TW91bnQuX3JlZ2lzdGVyQ29tcG9uZW50KFxuICAgICAgICBjb21wb25lbnRJbnN0YW5jZSxcbiAgICAgICAgY29udGFpbmVyXG4gICAgICApO1xuICAgICAgY29tcG9uZW50SW5zdGFuY2UubW91bnRDb21wb25lbnRJbnRvTm9kZShcbiAgICAgICAgcmVhY3RSb290SUQsXG4gICAgICAgIGNvbnRhaW5lcixcbiAgICAgICAgc2hvdWxkUmV1c2VNYXJrdXBcbiAgICAgICk7XG5cbiAgICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgICAgLy8gUmVjb3JkIHRoZSByb290IGVsZW1lbnQgaW4gY2FzZSBpdCBsYXRlciBnZXRzIHRyYW5zcGxhbnRlZC5cbiAgICAgICAgcm9vdEVsZW1lbnRzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF0gPVxuICAgICAgICAgIGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29tcG9uZW50SW5zdGFuY2U7XG4gICAgfVxuICApLFxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgUmVhY3QgY29tcG9uZW50IGludG8gdGhlIERPTSBpbiB0aGUgc3VwcGxpZWQgYGNvbnRhaW5lcmAuXG4gICAqXG4gICAqIElmIHRoZSBSZWFjdCBjb21wb25lbnQgd2FzIHByZXZpb3VzbHkgcmVuZGVyZWQgaW50byBgY29udGFpbmVyYCwgdGhpcyB3aWxsXG4gICAqIHBlcmZvcm0gYW4gdXBkYXRlIG9uIGl0IGFuZCBvbmx5IG11dGF0ZSB0aGUgRE9NIGFzIG5lY2Vzc2FyeSB0byByZWZsZWN0IHRoZVxuICAgKiBsYXRlc3QgUmVhY3QgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0RGVzY3JpcHRvcn0gbmV4dERlc2NyaXB0b3IgQ29tcG9uZW50IGRlc2NyaXB0b3IgdG8gcmVuZGVyLlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byByZW5kZXIgaW50by5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uIHRyaWdnZXJlZCBvbiBjb21wbGV0aW9uXG4gICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fSBDb21wb25lbnQgaW5zdGFuY2UgcmVuZGVyZWQgaW4gYGNvbnRhaW5lcmAuXG4gICAqL1xuICByZW5kZXJDb21wb25lbnQ6IGZ1bmN0aW9uKG5leHREZXNjcmlwdG9yLCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgIFJlYWN0RGVzY3JpcHRvci5pc1ZhbGlkRGVzY3JpcHRvcihuZXh0RGVzY3JpcHRvciksXG4gICAgICAncmVuZGVyQ29tcG9uZW50KCk6IEludmFsaWQgY29tcG9uZW50IGRlc2NyaXB0b3IuJXMnLFxuICAgICAgKFxuICAgICAgICBSZWFjdERlc2NyaXB0b3IuaXNWYWxpZEZhY3RvcnkobmV4dERlc2NyaXB0b3IpID9cbiAgICAgICAgICAnIEluc3RlYWQgb2YgcGFzc2luZyBhIGNvbXBvbmVudCBjbGFzcywgbWFrZSBzdXJlIHRvIGluc3RhbnRpYXRlICcgK1xuICAgICAgICAgICdpdCBmaXJzdCBieSBjYWxsaW5nIGl0IHdpdGggcHJvcHMuJyA6XG4gICAgICAgIC8vIENoZWNrIGlmIGl0IHF1YWNrcyBsaWtlIGEgZGVzY3JpcHRvclxuICAgICAgICB0eXBlb2YgbmV4dERlc2NyaXB0b3IucHJvcHMgIT09IFwidW5kZWZpbmVkXCIgP1xuICAgICAgICAgICcgVGhpcyBtYXkgYmUgY2F1c2VkIGJ5IHVuaW50ZW50aW9uYWxseSBsb2FkaW5nIHR3byBpbmRlcGVuZGVudCAnICtcbiAgICAgICAgICAnY29waWVzIG9mIFJlYWN0LicgOlxuICAgICAgICAgICcnXG4gICAgICApXG4gICAgKSA6IGludmFyaWFudChSZWFjdERlc2NyaXB0b3IuaXNWYWxpZERlc2NyaXB0b3IobmV4dERlc2NyaXB0b3IpKSk7XG5cbiAgICB2YXIgcHJldkNvbXBvbmVudCA9IGluc3RhbmNlc0J5UmVhY3RSb290SURbZ2V0UmVhY3RSb290SUQoY29udGFpbmVyKV07XG5cbiAgICBpZiAocHJldkNvbXBvbmVudCkge1xuICAgICAgdmFyIHByZXZEZXNjcmlwdG9yID0gcHJldkNvbXBvbmVudC5fZGVzY3JpcHRvcjtcbiAgICAgIGlmIChzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudChwcmV2RGVzY3JpcHRvciwgbmV4dERlc2NyaXB0b3IpKSB7XG4gICAgICAgIHJldHVybiBSZWFjdE1vdW50Ll91cGRhdGVSb290Q29tcG9uZW50KFxuICAgICAgICAgIHByZXZDb21wb25lbnQsXG4gICAgICAgICAgbmV4dERlc2NyaXB0b3IsXG4gICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBSZWFjdE1vdW50LnVubW91bnRDb21wb25lbnRBdE5vZGUoY29udGFpbmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVhY3RSb290RWxlbWVudCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgIHZhciBjb250YWluZXJIYXNSZWFjdE1hcmt1cCA9XG4gICAgICByZWFjdFJvb3RFbGVtZW50ICYmIFJlYWN0TW91bnQuaXNSZW5kZXJlZEJ5UmVhY3QocmVhY3RSb290RWxlbWVudCk7XG5cbiAgICB2YXIgc2hvdWxkUmV1c2VNYXJrdXAgPSBjb250YWluZXJIYXNSZWFjdE1hcmt1cCAmJiAhcHJldkNvbXBvbmVudDtcblxuICAgIHZhciBjb21wb25lbnQgPSBSZWFjdE1vdW50Ll9yZW5kZXJOZXdSb290Q29tcG9uZW50KFxuICAgICAgbmV4dERlc2NyaXB0b3IsXG4gICAgICBjb250YWluZXIsXG4gICAgICBzaG91bGRSZXVzZU1hcmt1cFxuICAgICk7XG4gICAgY2FsbGJhY2sgJiYgY2FsbGJhY2suY2FsbChjb21wb25lbnQpO1xuICAgIHJldHVybiBjb21wb25lbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBjb21wb25lbnQgaW5zdGFuY2Ugb2YgYGNvbnN0cnVjdG9yYCB3aXRoIGBpbml0aWFsUHJvcHNgIGFuZFxuICAgKiByZW5kZXJzIGl0IGludG8gdGhlIHN1cHBsaWVkIGBjb250YWluZXJgLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb25zdHJ1Y3RvciBSZWFjdCBjb21wb25lbnQgY29uc3RydWN0b3IuXG4gICAqIEBwYXJhbSB7P29iamVjdH0gcHJvcHMgSW5pdGlhbCBwcm9wcyBvZiB0aGUgY29tcG9uZW50IGluc3RhbmNlLlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byByZW5kZXIgaW50by5cbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IENvbXBvbmVudCBpbnN0YW5jZSByZW5kZXJlZCBpbiBgY29udGFpbmVyYC5cbiAgICovXG4gIGNvbnN0cnVjdEFuZFJlbmRlckNvbXBvbmVudDogZnVuY3Rpb24oY29uc3RydWN0b3IsIHByb3BzLCBjb250YWluZXIpIHtcbiAgICByZXR1cm4gUmVhY3RNb3VudC5yZW5kZXJDb21wb25lbnQoY29uc3RydWN0b3IocHJvcHMpLCBjb250YWluZXIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgY29tcG9uZW50IGluc3RhbmNlIG9mIGBjb25zdHJ1Y3RvcmAgd2l0aCBgaW5pdGlhbFByb3BzYCBhbmRcbiAgICogcmVuZGVycyBpdCBpbnRvIGEgY29udGFpbmVyIG5vZGUgaWRlbnRpZmllZCBieSBzdXBwbGllZCBgaWRgLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb21wb25lbnRDb25zdHJ1Y3RvciBSZWFjdCBjb21wb25lbnQgY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBwcm9wcyBJbml0aWFsIHByb3BzIG9mIHRoZSBjb21wb25lbnQgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiB0aGUgRE9NIGVsZW1lbnQgdG8gcmVuZGVyIGludG8uXG4gICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fSBDb21wb25lbnQgaW5zdGFuY2UgcmVuZGVyZWQgaW4gdGhlIGNvbnRhaW5lciBub2RlLlxuICAgKi9cbiAgY29uc3RydWN0QW5kUmVuZGVyQ29tcG9uZW50QnlJRDogZnVuY3Rpb24oY29uc3RydWN0b3IsIHByb3BzLCBpZCkge1xuICAgIHZhciBkb21Ob2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICBkb21Ob2RlLFxuICAgICAgJ1RyaWVkIHRvIGdldCBlbGVtZW50IHdpdGggaWQgb2YgXCIlc1wiIGJ1dCBpdCBpcyBub3QgcHJlc2VudCBvbiB0aGUgcGFnZS4nLFxuICAgICAgaWRcbiAgICApIDogaW52YXJpYW50KGRvbU5vZGUpKTtcbiAgICByZXR1cm4gUmVhY3RNb3VudC5jb25zdHJ1Y3RBbmRSZW5kZXJDb21wb25lbnQoY29uc3RydWN0b3IsIHByb3BzLCBkb21Ob2RlKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgY29udGFpbmVyIG5vZGUgaW50byB3aGljaCBSZWFjdCBjb21wb25lbnRzIHdpbGwgYmUgcmVuZGVyZWQuXG4gICAqIFRoaXMgYWxzbyBjcmVhdGVzIHRoZSBcInJlYWN0Um9vdFwiIElEIHRoYXQgd2lsbCBiZSBhc3NpZ25lZCB0byB0aGUgZWxlbWVudFxuICAgKiByZW5kZXJlZCB3aXRoaW4uXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIHJlZ2lzdGVyIGFzIGEgY29udGFpbmVyLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBcInJlYWN0Um9vdFwiIElEIG9mIGVsZW1lbnRzIHJlbmRlcmVkIHdpdGhpbi5cbiAgICovXG4gIHJlZ2lzdGVyQ29udGFpbmVyOiBmdW5jdGlvbihjb250YWluZXIpIHtcbiAgICB2YXIgcmVhY3RSb290SUQgPSBnZXRSZWFjdFJvb3RJRChjb250YWluZXIpO1xuICAgIGlmIChyZWFjdFJvb3RJRCkge1xuICAgICAgLy8gSWYgb25lIGV4aXN0cywgbWFrZSBzdXJlIGl0IGlzIGEgdmFsaWQgXCJyZWFjdFJvb3RcIiBJRC5cbiAgICAgIHJlYWN0Um9vdElEID0gUmVhY3RJbnN0YW5jZUhhbmRsZXMuZ2V0UmVhY3RSb290SURGcm9tTm9kZUlEKHJlYWN0Um9vdElEKTtcbiAgICB9XG4gICAgaWYgKCFyZWFjdFJvb3RJRCkge1xuICAgICAgLy8gTm8gdmFsaWQgXCJyZWFjdFJvb3RcIiBJRCBmb3VuZCwgY3JlYXRlIG9uZS5cbiAgICAgIHJlYWN0Um9vdElEID0gUmVhY3RJbnN0YW5jZUhhbmRsZXMuY3JlYXRlUmVhY3RSb290SUQoKTtcbiAgICB9XG4gICAgY29udGFpbmVyc0J5UmVhY3RSb290SURbcmVhY3RSb290SURdID0gY29udGFpbmVyO1xuICAgIHJldHVybiByZWFjdFJvb3RJRDtcbiAgfSxcblxuICAvKipcbiAgICogVW5tb3VudHMgYW5kIGRlc3Ryb3lzIHRoZSBSZWFjdCBjb21wb25lbnQgcmVuZGVyZWQgaW4gdGhlIGBjb250YWluZXJgLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCBjb250YWluaW5nIGEgUmVhY3QgY29tcG9uZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGEgY29tcG9uZW50IHdhcyBmb3VuZCBpbiBhbmQgdW5tb3VudGVkIGZyb21cbiAgICogICAgICAgICAgICAgICAgICAgYGNvbnRhaW5lcmBcbiAgICovXG4gIHVubW91bnRDb21wb25lbnRBdE5vZGU6IGZ1bmN0aW9uKGNvbnRhaW5lcikge1xuICAgIC8vIFZhcmlvdXMgcGFydHMgb2Ygb3VyIGNvZGUgKHN1Y2ggYXMgUmVhY3RDb21wb3NpdGVDb21wb25lbnQnc1xuICAgIC8vIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQpIGFzc3VtZSB0aGF0IGNhbGxzIHRvIHJlbmRlciBhcmVuJ3QgbmVzdGVkO1xuICAgIC8vIHZlcmlmeSB0aGF0IHRoYXQncyB0aGUgY2FzZS4gKFN0cmljdGx5IHNwZWFraW5nLCB1bm1vdW50aW5nIHdvbid0IGNhdXNlIGFcbiAgICAvLyByZW5kZXIgYnV0IHdlIHN0aWxsIGRvbid0IGV4cGVjdCB0byBiZSBpbiBhIHJlbmRlciBjYWxsIGhlcmUuKVxuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyB3YXJuaW5nKFxuICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9PSBudWxsLFxuICAgICAgJ3VubW91bnRDb21wb25lbnRBdE5vZGUoKTogUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiAnICtcbiAgICAgICdwcm9wcyBhbmQgc3RhdGU7IHRyaWdnZXJpbmcgbmVzdGVkIGNvbXBvbmVudCB1cGRhdGVzIGZyb20gcmVuZGVyIGlzICcgK1xuICAgICAgJ25vdCBhbGxvd2VkLiBJZiBuZWNlc3NhcnksIHRyaWdnZXIgbmVzdGVkIHVwZGF0ZXMgaW4gJyArXG4gICAgICAnY29tcG9uZW50RGlkVXBkYXRlLidcbiAgICApIDogbnVsbCk7XG5cbiAgICB2YXIgcmVhY3RSb290SUQgPSBnZXRSZWFjdFJvb3RJRChjb250YWluZXIpO1xuICAgIHZhciBjb21wb25lbnQgPSBpbnN0YW5jZXNCeVJlYWN0Um9vdElEW3JlYWN0Um9vdElEXTtcbiAgICBpZiAoIWNvbXBvbmVudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBSZWFjdE1vdW50LnVubW91bnRDb21wb25lbnRGcm9tTm9kZShjb21wb25lbnQsIGNvbnRhaW5lcik7XG4gICAgZGVsZXRlIGluc3RhbmNlc0J5UmVhY3RSb290SURbcmVhY3RSb290SURdO1xuICAgIGRlbGV0ZSBjb250YWluZXJzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF07XG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgZGVsZXRlIHJvb3RFbGVtZW50c0J5UmVhY3RSb290SURbcmVhY3RSb290SURdO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogVW5tb3VudHMgYSBjb21wb25lbnQgYW5kIHJlbW92ZXMgaXQgZnJvbSB0aGUgRE9NLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBpbnN0YW5jZSBSZWFjdCBjb21wb25lbnQgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIHVubW91bnQgZnJvbS5cbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAc2VlIHtSZWFjdE1vdW50LnVubW91bnRDb21wb25lbnRBdE5vZGV9XG4gICAqL1xuICB1bm1vdW50Q29tcG9uZW50RnJvbU5vZGU6IGZ1bmN0aW9uKGluc3RhbmNlLCBjb250YWluZXIpIHtcbiAgICBpbnN0YW5jZS51bm1vdW50Q29tcG9uZW50KCk7XG5cbiAgICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NfTk9ERV9UWVBFKSB7XG4gICAgICBjb250YWluZXIgPSBjb250YWluZXIuZG9jdW1lbnRFbGVtZW50O1xuICAgIH1cblxuICAgIC8vIGh0dHA6Ly9qc3BlcmYuY29tL2VtcHR5aW5nLWEtbm9kZVxuICAgIHdoaWxlIChjb250YWluZXIubGFzdENoaWxkKSB7XG4gICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoY29udGFpbmVyLmxhc3RDaGlsZCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBGaW5kcyB0aGUgY29udGFpbmVyIERPTSBlbGVtZW50IHRoYXQgY29udGFpbnMgUmVhY3QgY29tcG9uZW50IHRvIHdoaWNoIHRoZVxuICAgKiBzdXBwbGllZCBET00gYGlkYCBiZWxvbmdzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIElEIG9mIGFuIGVsZW1lbnQgcmVuZGVyZWQgYnkgYSBSZWFjdCBjb21wb25lbnQuXG4gICAqIEByZXR1cm4gez9ET01FbGVtZW50fSBET00gZWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSBgaWRgLlxuICAgKi9cbiAgZmluZFJlYWN0Q29udGFpbmVyRm9ySUQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgdmFyIHJlYWN0Um9vdElEID0gUmVhY3RJbnN0YW5jZUhhbmRsZXMuZ2V0UmVhY3RSb290SURGcm9tTm9kZUlEKGlkKTtcbiAgICB2YXIgY29udGFpbmVyID0gY29udGFpbmVyc0J5UmVhY3RSb290SURbcmVhY3RSb290SURdO1xuXG4gICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgdmFyIHJvb3RFbGVtZW50ID0gcm9vdEVsZW1lbnRzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF07XG4gICAgICBpZiAocm9vdEVsZW1lbnQgJiYgcm9vdEVsZW1lbnQucGFyZW50Tm9kZSAhPT0gY29udGFpbmVyKSB7XG4gICAgICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAgICAgLy8gQ2FsbCBpbnRlcm5hbEdldElEIGhlcmUgYmVjYXVzZSBnZXRJRCBjYWxscyBpc1ZhbGlkIHdoaWNoIGNhbGxzXG4gICAgICAgICAgLy8gZmluZFJlYWN0Q29udGFpbmVyRm9ySUQgKHRoaXMgZnVuY3Rpb24pLlxuICAgICAgICAgIGludGVybmFsR2V0SUQocm9vdEVsZW1lbnQpID09PSByZWFjdFJvb3RJRCxcbiAgICAgICAgICAnUmVhY3RNb3VudDogUm9vdCBlbGVtZW50IElEIGRpZmZlcmVkIGZyb20gcmVhY3RSb290SUQuJ1xuICAgICAgICApIDogaW52YXJpYW50KC8vIENhbGwgaW50ZXJuYWxHZXRJRCBoZXJlIGJlY2F1c2UgZ2V0SUQgY2FsbHMgaXNWYWxpZCB3aGljaCBjYWxsc1xuICAgICAgICAvLyBmaW5kUmVhY3RDb250YWluZXJGb3JJRCAodGhpcyBmdW5jdGlvbikuXG4gICAgICAgIGludGVybmFsR2V0SUQocm9vdEVsZW1lbnQpID09PSByZWFjdFJvb3RJRCkpO1xuXG4gICAgICAgIHZhciBjb250YWluZXJDaGlsZCA9IGNvbnRhaW5lci5maXJzdENoaWxkO1xuICAgICAgICBpZiAoY29udGFpbmVyQ2hpbGQgJiZcbiAgICAgICAgICAgIHJlYWN0Um9vdElEID09PSBpbnRlcm5hbEdldElEKGNvbnRhaW5lckNoaWxkKSkge1xuICAgICAgICAgIC8vIElmIHRoZSBjb250YWluZXIgaGFzIGEgbmV3IGNoaWxkIHdpdGggdGhlIHNhbWUgSUQgYXMgdGhlIG9sZFxuICAgICAgICAgIC8vIHJvb3QgZWxlbWVudCwgdGhlbiByb290RWxlbWVudHNCeVJlYWN0Um9vdElEW3JlYWN0Um9vdElEXSBpc1xuICAgICAgICAgIC8vIGp1c3Qgc3RhbGUgYW5kIG5lZWRzIHRvIGJlIHVwZGF0ZWQuIFRoZSBjYXNlIHRoYXQgZGVzZXJ2ZXMgYVxuICAgICAgICAgIC8vIHdhcm5pbmcgaXMgd2hlbiB0aGUgY29udGFpbmVyIGlzIGVtcHR5LlxuICAgICAgICAgIHJvb3RFbGVtZW50c0J5UmVhY3RSb290SURbcmVhY3RSb290SURdID0gY29udGFpbmVyQ2hpbGQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgJ1JlYWN0TW91bnQ6IFJvb3QgZWxlbWVudCBoYXMgYmVlbiByZW1vdmVkIGZyb20gaXRzIG9yaWdpbmFsICcgK1xuICAgICAgICAgICAgJ2NvbnRhaW5lci4gTmV3IGNvbnRhaW5lcjonLCByb290RWxlbWVudC5wYXJlbnROb2RlXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjb250YWluZXI7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbmRzIGFuIGVsZW1lbnQgcmVuZGVyZWQgYnkgUmVhY3Qgd2l0aCB0aGUgc3VwcGxpZWQgSUQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiBhIERPTSBub2RlIGluIHRoZSBSZWFjdCBjb21wb25lbnQuXG4gICAqIEByZXR1cm4ge0RPTUVsZW1lbnR9IFJvb3QgRE9NIG5vZGUgb2YgdGhlIFJlYWN0IGNvbXBvbmVudC5cbiAgICovXG4gIGZpbmRSZWFjdE5vZGVCeUlEOiBmdW5jdGlvbihpZCkge1xuICAgIHZhciByZWFjdFJvb3QgPSBSZWFjdE1vdW50LmZpbmRSZWFjdENvbnRhaW5lckZvcklEKGlkKTtcbiAgICByZXR1cm4gUmVhY3RNb3VudC5maW5kQ29tcG9uZW50Um9vdChyZWFjdFJvb3QsIGlkKTtcbiAgfSxcblxuICAvKipcbiAgICogVHJ1ZSBpZiB0aGUgc3VwcGxpZWQgYG5vZGVgIGlzIHJlbmRlcmVkIGJ5IFJlYWN0LlxuICAgKlxuICAgKiBAcGFyYW0geyp9IG5vZGUgRE9NIEVsZW1lbnQgdG8gY2hlY2suXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIERPTSBFbGVtZW50IGFwcGVhcnMgdG8gYmUgcmVuZGVyZWQgYnkgUmVhY3QuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgaXNSZW5kZXJlZEJ5UmVhY3Q6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gMSkge1xuICAgICAgLy8gTm90IGEgRE9NRWxlbWVudCwgdGhlcmVmb3JlIG5vdCBhIFJlYWN0IGNvbXBvbmVudFxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgaWQgPSBSZWFjdE1vdW50LmdldElEKG5vZGUpO1xuICAgIHJldHVybiBpZCA/IGlkLmNoYXJBdCgwKSA9PT0gU0VQQVJBVE9SIDogZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyYXZlcnNlcyB1cCB0aGUgYW5jZXN0b3JzIG9mIHRoZSBzdXBwbGllZCBub2RlIHRvIGZpbmQgYSBub2RlIHRoYXQgaXMgYVxuICAgKiBET00gcmVwcmVzZW50YXRpb24gb2YgYSBSZWFjdCBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gbm9kZVxuICAgKiBAcmV0dXJuIHs/RE9NRXZlbnRUYXJnZXR9XG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0Rmlyc3RSZWFjdERPTTogZnVuY3Rpb24obm9kZSkge1xuICAgIHZhciBjdXJyZW50ID0gbm9kZTtcbiAgICB3aGlsZSAoY3VycmVudCAmJiBjdXJyZW50LnBhcmVudE5vZGUgIT09IGN1cnJlbnQpIHtcbiAgICAgIGlmIChSZWFjdE1vdW50LmlzUmVuZGVyZWRCeVJlYWN0KGN1cnJlbnQpKSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgfVxuICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbmRzIGEgbm9kZSB3aXRoIHRoZSBzdXBwbGllZCBgdGFyZ2V0SURgIGluc2lkZSBvZiB0aGUgc3VwcGxpZWRcbiAgICogYGFuY2VzdG9yTm9kZWAuICBFeHBsb2l0cyB0aGUgSUQgbmFtaW5nIHNjaGVtZSB0byBwZXJmb3JtIHRoZSBzZWFyY2hcbiAgICogcXVpY2tseS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gYW5jZXN0b3JOb2RlIFNlYXJjaCBmcm9tIHRoaXMgcm9vdC5cbiAgICogQHBhcmFybSB7c3RyaW5nfSB0YXJnZXRJRCBJRCBvZiB0aGUgRE9NIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb21wb25lbnQuXG4gICAqIEByZXR1cm4ge0RPTUV2ZW50VGFyZ2V0fSBET00gbm9kZSB3aXRoIHRoZSBzdXBwbGllZCBgdGFyZ2V0SURgLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGZpbmRDb21wb25lbnRSb290OiBmdW5jdGlvbihhbmNlc3Rvck5vZGUsIHRhcmdldElEKSB7XG4gICAgdmFyIGZpcnN0Q2hpbGRyZW4gPSBmaW5kQ29tcG9uZW50Um9vdFJldXNhYmxlQXJyYXk7XG4gICAgdmFyIGNoaWxkSW5kZXggPSAwO1xuXG4gICAgdmFyIGRlZXBlc3RBbmNlc3RvciA9IGZpbmREZWVwZXN0Q2FjaGVkQW5jZXN0b3IodGFyZ2V0SUQpIHx8IGFuY2VzdG9yTm9kZTtcblxuICAgIGZpcnN0Q2hpbGRyZW5bMF0gPSBkZWVwZXN0QW5jZXN0b3IuZmlyc3RDaGlsZDtcbiAgICBmaXJzdENoaWxkcmVuLmxlbmd0aCA9IDE7XG5cbiAgICB3aGlsZSAoY2hpbGRJbmRleCA8IGZpcnN0Q2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICB2YXIgY2hpbGQgPSBmaXJzdENoaWxkcmVuW2NoaWxkSW5kZXgrK107XG4gICAgICB2YXIgdGFyZ2V0Q2hpbGQ7XG5cbiAgICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICB2YXIgY2hpbGRJRCA9IFJlYWN0TW91bnQuZ2V0SUQoY2hpbGQpO1xuICAgICAgICBpZiAoY2hpbGRJRCkge1xuICAgICAgICAgIC8vIEV2ZW4gaWYgd2UgZmluZCB0aGUgbm9kZSB3ZSdyZSBsb29raW5nIGZvciwgd2UgZmluaXNoIGxvb3BpbmdcbiAgICAgICAgICAvLyB0aHJvdWdoIGl0cyBzaWJsaW5ncyB0byBlbnN1cmUgdGhleSdyZSBjYWNoZWQgc28gdGhhdCB3ZSBkb24ndCBoYXZlXG4gICAgICAgICAgLy8gdG8gcmV2aXNpdCB0aGlzIG5vZGUgYWdhaW4uIE90aGVyd2lzZSwgd2UgbWFrZSBuXjIgY2FsbHMgdG8gZ2V0SURcbiAgICAgICAgICAvLyB3aGVuIHZpc2l0aW5nIHRoZSBtYW55IGNoaWxkcmVuIG9mIGEgc2luZ2xlIG5vZGUgaW4gb3JkZXIuXG5cbiAgICAgICAgICBpZiAodGFyZ2V0SUQgPT09IGNoaWxkSUQpIHtcbiAgICAgICAgICAgIHRhcmdldENoaWxkID0gY2hpbGQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChSZWFjdEluc3RhbmNlSGFuZGxlcy5pc0FuY2VzdG9ySURPZihjaGlsZElELCB0YXJnZXRJRCkpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGZpbmQgYSBjaGlsZCB3aG9zZSBJRCBpcyBhbiBhbmNlc3RvciBvZiB0aGUgZ2l2ZW4gSUQsXG4gICAgICAgICAgICAvLyB0aGVuIHdlIGNhbiBiZSBzdXJlIHRoYXQgd2Ugb25seSB3YW50IHRvIHNlYXJjaCB0aGUgc3VidHJlZVxuICAgICAgICAgICAgLy8gcm9vdGVkIGF0IHRoaXMgY2hpbGQsIHNvIHdlIGNhbiB0aHJvdyBvdXQgdGhlIHJlc3Qgb2YgdGhlXG4gICAgICAgICAgICAvLyBzZWFyY2ggc3RhdGUuXG4gICAgICAgICAgICBmaXJzdENoaWxkcmVuLmxlbmd0aCA9IGNoaWxkSW5kZXggPSAwO1xuICAgICAgICAgICAgZmlyc3RDaGlsZHJlbi5wdXNoKGNoaWxkLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIHRoaXMgY2hpbGQgaGFkIG5vIElELCB0aGVuIHRoZXJlJ3MgYSBjaGFuY2UgdGhhdCBpdCB3YXNcbiAgICAgICAgICAvLyBpbmplY3RlZCBhdXRvbWF0aWNhbGx5IGJ5IHRoZSBicm93c2VyLCBhcyB3aGVuIGEgYDx0YWJsZT5gXG4gICAgICAgICAgLy8gZWxlbWVudCBzcHJvdXRzIGFuIGV4dHJhIGA8dGJvZHk+YCBjaGlsZCBhcyBhIHNpZGUgZWZmZWN0IG9mXG4gICAgICAgICAgLy8gYC5pbm5lckhUTUxgIHBhcnNpbmcuIE9wdGltaXN0aWNhbGx5IGNvbnRpbnVlIGRvd24gdGhpc1xuICAgICAgICAgIC8vIGJyYW5jaCwgYnV0IG5vdCBiZWZvcmUgZXhhbWluaW5nIHRoZSBvdGhlciBzaWJsaW5ncy5cbiAgICAgICAgICBmaXJzdENoaWxkcmVuLnB1c2goY2hpbGQuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgfVxuXG4gICAgICBpZiAodGFyZ2V0Q2hpbGQpIHtcbiAgICAgICAgLy8gRW1wdHlpbmcgZmlyc3RDaGlsZHJlbi9maW5kQ29tcG9uZW50Um9vdFJldXNhYmxlQXJyYXkgaXNcbiAgICAgICAgLy8gbm90IG5lY2Vzc2FyeSBmb3IgY29ycmVjdG5lc3MsIGJ1dCBpdCBoZWxwcyB0aGUgR0MgcmVjbGFpbVxuICAgICAgICAvLyBhbnkgbm9kZXMgdGhhdCB3ZXJlIGxlZnQgYXQgdGhlIGVuZCBvZiB0aGUgc2VhcmNoLlxuICAgICAgICBmaXJzdENoaWxkcmVuLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldENoaWxkO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZpcnN0Q2hpbGRyZW4ubGVuZ3RoID0gMDtcblxuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICBmYWxzZSxcbiAgICAgICdmaW5kQ29tcG9uZW50Um9vdCguLi4sICVzKTogVW5hYmxlIHRvIGZpbmQgZWxlbWVudC4gVGhpcyBwcm9iYWJseSAnICtcbiAgICAgICdtZWFucyB0aGUgRE9NIHdhcyB1bmV4cGVjdGVkbHkgbXV0YXRlZCAoZS5nLiwgYnkgdGhlIGJyb3dzZXIpLCAnICtcbiAgICAgICd1c3VhbGx5IGR1ZSB0byBmb3JnZXR0aW5nIGEgPHRib2R5PiB3aGVuIHVzaW5nIHRhYmxlcywgbmVzdGluZyA8cD4gJyArXG4gICAgICAnb3IgPGE+IHRhZ3MsIG9yIHVzaW5nIG5vbi1TVkcgZWxlbWVudHMgaW4gYW4gPHN2Zz4gcGFyZW50LiBUcnkgJyArXG4gICAgICAnaW5zcGVjdGluZyB0aGUgY2hpbGQgbm9kZXMgb2YgdGhlIGVsZW1lbnQgd2l0aCBSZWFjdCBJRCBgJXNgLicsXG4gICAgICB0YXJnZXRJRCxcbiAgICAgIFJlYWN0TW91bnQuZ2V0SUQoYW5jZXN0b3JOb2RlKVxuICAgICkgOiBpbnZhcmlhbnQoZmFsc2UpKTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBSZWFjdCBJRCB1dGlsaXRpZXMuXG4gICAqL1xuXG4gIGdldFJlYWN0Um9vdElEOiBnZXRSZWFjdFJvb3RJRCxcblxuICBnZXRJRDogZ2V0SUQsXG5cbiAgc2V0SUQ6IHNldElELFxuXG4gIGdldE5vZGU6IGdldE5vZGUsXG5cbiAgcHVyZ2VJRDogcHVyZ2VJRFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE1vdW50O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RNdWx0aUNoaWxkXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKFwiLi9SZWFjdENvbXBvbmVudFwiKTtcbnZhciBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcyA9IHJlcXVpcmUoXCIuL1JlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzXCIpO1xuXG52YXIgZmxhdHRlbkNoaWxkcmVuID0gcmVxdWlyZShcIi4vZmxhdHRlbkNoaWxkcmVuXCIpO1xudmFyIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKFwiLi9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50XCIpO1xudmFyIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZShcIi4vc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnRcIik7XG5cbi8qKlxuICogVXBkYXRpbmcgY2hpbGRyZW4gb2YgYSBjb21wb25lbnQgbWF5IHRyaWdnZXIgcmVjdXJzaXZlIHVwZGF0ZXMuIFRoZSBkZXB0aCBpc1xuICogdXNlZCB0byBiYXRjaCByZWN1cnNpdmUgdXBkYXRlcyB0byByZW5kZXIgbWFya3VwIG1vcmUgZWZmaWNpZW50bHkuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciB1cGRhdGVEZXB0aCA9IDA7XG5cbi8qKlxuICogUXVldWUgb2YgdXBkYXRlIGNvbmZpZ3VyYXRpb24gb2JqZWN0cy5cbiAqXG4gKiBFYWNoIG9iamVjdCBoYXMgYSBgdHlwZWAgcHJvcGVydHkgdGhhdCBpcyBpbiBgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXNgLlxuICpcbiAqIEB0eXBlIHthcnJheTxvYmplY3Q+fVxuICogQHByaXZhdGVcbiAqL1xudmFyIHVwZGF0ZVF1ZXVlID0gW107XG5cbi8qKlxuICogUXVldWUgb2YgbWFya3VwIHRvIGJlIHJlbmRlcmVkLlxuICpcbiAqIEB0eXBlIHthcnJheTxzdHJpbmc+fVxuICogQHByaXZhdGVcbiAqL1xudmFyIG1hcmt1cFF1ZXVlID0gW107XG5cbi8qKlxuICogRW5xdWV1ZXMgbWFya3VwIHRvIGJlIHJlbmRlcmVkIGFuZCBpbnNlcnRlZCBhdCBhIHN1cHBsaWVkIGluZGV4LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJlbnRJRCBJRCBvZiB0aGUgcGFyZW50IGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgTWFya3VwIHRoYXQgcmVuZGVycyBpbnRvIGFuIGVsZW1lbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdG9JbmRleCBEZXN0aW5hdGlvbiBpbmRleC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVucXVldWVNYXJrdXAocGFyZW50SUQsIG1hcmt1cCwgdG9JbmRleCkge1xuICAvLyBOT1RFOiBOdWxsIHZhbHVlcyByZWR1Y2UgaGlkZGVuIGNsYXNzZXMuXG4gIHVwZGF0ZVF1ZXVlLnB1c2goe1xuICAgIHBhcmVudElEOiBwYXJlbnRJRCxcbiAgICBwYXJlbnROb2RlOiBudWxsLFxuICAgIHR5cGU6IFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLklOU0VSVF9NQVJLVVAsXG4gICAgbWFya3VwSW5kZXg6IG1hcmt1cFF1ZXVlLnB1c2gobWFya3VwKSAtIDEsXG4gICAgdGV4dENvbnRlbnQ6IG51bGwsXG4gICAgZnJvbUluZGV4OiBudWxsLFxuICAgIHRvSW5kZXg6IHRvSW5kZXhcbiAgfSk7XG59XG5cbi8qKlxuICogRW5xdWV1ZXMgbW92aW5nIGFuIGV4aXN0aW5nIGVsZW1lbnQgdG8gYW5vdGhlciBpbmRleC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyZW50SUQgSUQgb2YgdGhlIHBhcmVudCBjb21wb25lbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFNvdXJjZSBpbmRleCBvZiB0aGUgZXhpc3RpbmcgZWxlbWVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b0luZGV4IERlc3RpbmF0aW9uIGluZGV4IG9mIHRoZSBlbGVtZW50LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW5xdWV1ZU1vdmUocGFyZW50SUQsIGZyb21JbmRleCwgdG9JbmRleCkge1xuICAvLyBOT1RFOiBOdWxsIHZhbHVlcyByZWR1Y2UgaGlkZGVuIGNsYXNzZXMuXG4gIHVwZGF0ZVF1ZXVlLnB1c2goe1xuICAgIHBhcmVudElEOiBwYXJlbnRJRCxcbiAgICBwYXJlbnROb2RlOiBudWxsLFxuICAgIHR5cGU6IFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLk1PVkVfRVhJU1RJTkcsXG4gICAgbWFya3VwSW5kZXg6IG51bGwsXG4gICAgdGV4dENvbnRlbnQ6IG51bGwsXG4gICAgZnJvbUluZGV4OiBmcm9tSW5kZXgsXG4gICAgdG9JbmRleDogdG9JbmRleFxuICB9KTtcbn1cblxuLyoqXG4gKiBFbnF1ZXVlcyByZW1vdmluZyBhbiBlbGVtZW50IGF0IGFuIGluZGV4LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJlbnRJRCBJRCBvZiB0aGUgcGFyZW50IGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggSW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gcmVtb3ZlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW5xdWV1ZVJlbW92ZShwYXJlbnRJRCwgZnJvbUluZGV4KSB7XG4gIC8vIE5PVEU6IE51bGwgdmFsdWVzIHJlZHVjZSBoaWRkZW4gY2xhc3Nlcy5cbiAgdXBkYXRlUXVldWUucHVzaCh7XG4gICAgcGFyZW50SUQ6IHBhcmVudElELFxuICAgIHBhcmVudE5vZGU6IG51bGwsXG4gICAgdHlwZTogUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuUkVNT1ZFX05PREUsXG4gICAgbWFya3VwSW5kZXg6IG51bGwsXG4gICAgdGV4dENvbnRlbnQ6IG51bGwsXG4gICAgZnJvbUluZGV4OiBmcm9tSW5kZXgsXG4gICAgdG9JbmRleDogbnVsbFxuICB9KTtcbn1cblxuLyoqXG4gKiBFbnF1ZXVlcyBzZXR0aW5nIHRoZSB0ZXh0IGNvbnRlbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmVudElEIElEIG9mIHRoZSBwYXJlbnQgY29tcG9uZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRDb250ZW50IFRleHQgY29udGVudCB0byBzZXQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbnF1ZXVlVGV4dENvbnRlbnQocGFyZW50SUQsIHRleHRDb250ZW50KSB7XG4gIC8vIE5PVEU6IE51bGwgdmFsdWVzIHJlZHVjZSBoaWRkZW4gY2xhc3Nlcy5cbiAgdXBkYXRlUXVldWUucHVzaCh7XG4gICAgcGFyZW50SUQ6IHBhcmVudElELFxuICAgIHBhcmVudE5vZGU6IG51bGwsXG4gICAgdHlwZTogUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuVEVYVF9DT05URU5ULFxuICAgIG1hcmt1cEluZGV4OiBudWxsLFxuICAgIHRleHRDb250ZW50OiB0ZXh0Q29udGVudCxcbiAgICBmcm9tSW5kZXg6IG51bGwsXG4gICAgdG9JbmRleDogbnVsbFxuICB9KTtcbn1cblxuLyoqXG4gKiBQcm9jZXNzZXMgYW55IGVucXVldWVkIHVwZGF0ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHJvY2Vzc1F1ZXVlKCkge1xuICBpZiAodXBkYXRlUXVldWUubGVuZ3RoKSB7XG4gICAgUmVhY3RDb21wb25lbnQuQmFja2VuZElET3BlcmF0aW9ucy5kYW5nZXJvdXNseVByb2Nlc3NDaGlsZHJlblVwZGF0ZXMoXG4gICAgICB1cGRhdGVRdWV1ZSxcbiAgICAgIG1hcmt1cFF1ZXVlXG4gICAgKTtcbiAgICBjbGVhclF1ZXVlKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDbGVhcnMgYW55IGVucXVldWVkIHVwZGF0ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2xlYXJRdWV1ZSgpIHtcbiAgdXBkYXRlUXVldWUubGVuZ3RoID0gMDtcbiAgbWFya3VwUXVldWUubGVuZ3RoID0gMDtcbn1cblxuLyoqXG4gKiBSZWFjdE11bHRpQ2hpbGQgYXJlIGNhcGFibGUgb2YgcmVjb25jaWxpbmcgbXVsdGlwbGUgY2hpbGRyZW4uXG4gKlxuICogQGNsYXNzIFJlYWN0TXVsdGlDaGlsZFxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdE11bHRpQ2hpbGQgPSB7XG5cbiAgLyoqXG4gICAqIFByb3ZpZGVzIGNvbW1vbiBmdW5jdGlvbmFsaXR5IGZvciBjb21wb25lbnRzIHRoYXQgbXVzdCByZWNvbmNpbGUgbXVsdGlwbGVcbiAgICogY2hpbGRyZW4uIFRoaXMgaXMgdXNlZCBieSBgUmVhY3RET01Db21wb25lbnRgIHRvIG1vdW50LCB1cGRhdGUsIGFuZFxuICAgKiB1bm1vdW50IGNoaWxkIGNvbXBvbmVudHMuXG4gICAqXG4gICAqIEBsZW5kcyB7UmVhY3RNdWx0aUNoaWxkLnByb3RvdHlwZX1cbiAgICovXG4gIE1peGluOiB7XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBcIm1vdW50IGltYWdlXCIgZm9yIGVhY2ggb2YgdGhlIHN1cHBsaWVkIGNoaWxkcmVuLiBJbiB0aGUgY2FzZVxuICAgICAqIG9mIGBSZWFjdERPTUNvbXBvbmVudGAsIGEgbW91bnQgaW1hZ2UgaXMgYSBzdHJpbmcgb2YgbWFya3VwLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXN0ZWRDaGlsZHJlbiBOZXN0ZWQgY2hpbGQgbWFwcy5cbiAgICAgKiBAcmV0dXJuIHthcnJheX0gQW4gYXJyYXkgb2YgbW91bnRlZCByZXByZXNlbnRhdGlvbnMuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgbW91bnRDaGlsZHJlbjogZnVuY3Rpb24obmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBmbGF0dGVuQ2hpbGRyZW4obmVzdGVkQ2hpbGRyZW4pO1xuICAgICAgdmFyIG1vdW50SW1hZ2VzID0gW107XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgdGhpcy5fcmVuZGVyZWRDaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBjaGlsZHJlbikge1xuICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltuYW1lXTtcbiAgICAgICAgaWYgKGNoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgLy8gVGhlIHJlbmRlcmVkIGNoaWxkcmVuIG11c3QgYmUgdHVybmVkIGludG8gaW5zdGFuY2VzIGFzIHRoZXkncmVcbiAgICAgICAgICAvLyBtb3VudGVkLlxuICAgICAgICAgIHZhciBjaGlsZEluc3RhbmNlID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChjaGlsZCk7XG4gICAgICAgICAgY2hpbGRyZW5bbmFtZV0gPSBjaGlsZEluc3RhbmNlO1xuICAgICAgICAgIC8vIElubGluZWQgZm9yIHBlcmZvcm1hbmNlLCBzZWUgYFJlYWN0SW5zdGFuY2VIYW5kbGVzLmNyZWF0ZVJlYWN0SURgLlxuICAgICAgICAgIHZhciByb290SUQgPSB0aGlzLl9yb290Tm9kZUlEICsgbmFtZTtcbiAgICAgICAgICB2YXIgbW91bnRJbWFnZSA9IGNoaWxkSW5zdGFuY2UubW91bnRDb21wb25lbnQoXG4gICAgICAgICAgICByb290SUQsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgICAgIHRoaXMuX21vdW50RGVwdGggKyAxXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjaGlsZEluc3RhbmNlLl9tb3VudEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgbW91bnRJbWFnZXMucHVzaChtb3VudEltYWdlKTtcbiAgICAgICAgICBpbmRleCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbW91bnRJbWFnZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIGFueSByZW5kZXJlZCBjaGlsZHJlbiB3aXRoIGEgdGV4dCBjb250ZW50IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXh0Q29udGVudCBTdHJpbmcgb2YgY29udGVudC5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB1cGRhdGVUZXh0Q29udGVudDogZnVuY3Rpb24obmV4dENvbnRlbnQpIHtcbiAgICAgIHVwZGF0ZURlcHRoKys7XG4gICAgICB2YXIgZXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW47XG4gICAgICAgIC8vIFJlbW92ZSBhbnkgcmVuZGVyZWQgY2hpbGRyZW4uXG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gcHJldkNoaWxkcmVuKSB7XG4gICAgICAgICAgaWYgKHByZXZDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5fdW5tb3VudENoaWxkQnlOYW1lKHByZXZDaGlsZHJlbltuYW1lXSwgbmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFNldCBuZXcgdGV4dCBjb250ZW50LlxuICAgICAgICB0aGlzLnNldFRleHRDb250ZW50KG5leHRDb250ZW50KTtcbiAgICAgICAgZXJyb3JUaHJvd24gPSBmYWxzZTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHVwZGF0ZURlcHRoLS07XG4gICAgICAgIGlmICghdXBkYXRlRGVwdGgpIHtcbiAgICAgICAgICBlcnJvclRocm93biA/IGNsZWFyUXVldWUoKSA6IHByb2Nlc3NRdWV1ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHJlbmRlcmVkIGNoaWxkcmVuIHdpdGggbmV3IGNoaWxkcmVuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0TmVzdGVkQ2hpbGRyZW4gTmVzdGVkIGNoaWxkIG1hcHMuXG4gICAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHVwZGF0ZUNoaWxkcmVuOiBmdW5jdGlvbihuZXh0TmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uKSB7XG4gICAgICB1cGRhdGVEZXB0aCsrO1xuICAgICAgdmFyIGVycm9yVGhyb3duID0gdHJ1ZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUNoaWxkcmVuKG5leHROZXN0ZWRDaGlsZHJlbiwgdHJhbnNhY3Rpb24pO1xuICAgICAgICBlcnJvclRocm93biA9IGZhbHNlO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdXBkYXRlRGVwdGgtLTtcbiAgICAgICAgaWYgKCF1cGRhdGVEZXB0aCkge1xuICAgICAgICAgIGVycm9yVGhyb3duID8gY2xlYXJRdWV1ZSgpIDogcHJvY2Vzc1F1ZXVlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW1wcm92ZSBwZXJmb3JtYW5jZSBieSBpc29sYXRpbmcgdGhpcyBob3QgY29kZSBwYXRoIGZyb20gdGhlIHRyeS9jYXRjaFxuICAgICAqIGJsb2NrIGluIGB1cGRhdGVDaGlsZHJlbmAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHROZXN0ZWRDaGlsZHJlbiBOZXN0ZWQgY2hpbGQgbWFwcy5cbiAgICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAgICogQGZpbmFsXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF91cGRhdGVDaGlsZHJlbjogZnVuY3Rpb24obmV4dE5lc3RlZENoaWxkcmVuLCB0cmFuc2FjdGlvbikge1xuICAgICAgdmFyIG5leHRDaGlsZHJlbiA9IGZsYXR0ZW5DaGlsZHJlbihuZXh0TmVzdGVkQ2hpbGRyZW4pO1xuICAgICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW47XG4gICAgICBpZiAoIW5leHRDaGlsZHJlbiAmJiAhcHJldkNoaWxkcmVuKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBuYW1lO1xuICAgICAgLy8gYG5leHRJbmRleGAgd2lsbCBpbmNyZW1lbnQgZm9yIGVhY2ggY2hpbGQgaW4gYG5leHRDaGlsZHJlbmAsIGJ1dFxuICAgICAgLy8gYGxhc3RJbmRleGAgd2lsbCBiZSB0aGUgbGFzdCBpbmRleCB2aXNpdGVkIGluIGBwcmV2Q2hpbGRyZW5gLlxuICAgICAgdmFyIGxhc3RJbmRleCA9IDA7XG4gICAgICB2YXIgbmV4dEluZGV4ID0gMDtcbiAgICAgIGZvciAobmFtZSBpbiBuZXh0Q2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKCFuZXh0Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJldkNoaWxkID0gcHJldkNoaWxkcmVuICYmIHByZXZDaGlsZHJlbltuYW1lXTtcbiAgICAgICAgdmFyIHByZXZEZXNjcmlwdG9yID0gcHJldkNoaWxkICYmIHByZXZDaGlsZC5fZGVzY3JpcHRvcjtcbiAgICAgICAgdmFyIG5leHREZXNjcmlwdG9yID0gbmV4dENoaWxkcmVuW25hbWVdO1xuICAgICAgICBpZiAoc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQocHJldkRlc2NyaXB0b3IsIG5leHREZXNjcmlwdG9yKSkge1xuICAgICAgICAgIHRoaXMubW92ZUNoaWxkKHByZXZDaGlsZCwgbmV4dEluZGV4LCBsYXN0SW5kZXgpO1xuICAgICAgICAgIGxhc3RJbmRleCA9IE1hdGgubWF4KHByZXZDaGlsZC5fbW91bnRJbmRleCwgbGFzdEluZGV4KTtcbiAgICAgICAgICBwcmV2Q2hpbGQucmVjZWl2ZUNvbXBvbmVudChuZXh0RGVzY3JpcHRvciwgdHJhbnNhY3Rpb24pO1xuICAgICAgICAgIHByZXZDaGlsZC5fbW91bnRJbmRleCA9IG5leHRJbmRleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocHJldkNoaWxkKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgYGxhc3RJbmRleGAgYmVmb3JlIGBfbW91bnRJbmRleGAgZ2V0cyB1bnNldCBieSB1bm1vdW50aW5nLlxuICAgICAgICAgICAgbGFzdEluZGV4ID0gTWF0aC5tYXgocHJldkNoaWxkLl9tb3VudEluZGV4LCBsYXN0SW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5fdW5tb3VudENoaWxkQnlOYW1lKHByZXZDaGlsZCwgbmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFRoZSBjaGlsZCBtdXN0IGJlIGluc3RhbnRpYXRlZCBiZWZvcmUgaXQncyBtb3VudGVkLlxuICAgICAgICAgIHZhciBuZXh0Q2hpbGRJbnN0YW5jZSA9IGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQobmV4dERlc2NyaXB0b3IpO1xuICAgICAgICAgIHRoaXMuX21vdW50Q2hpbGRCeU5hbWVBdEluZGV4KFxuICAgICAgICAgICAgbmV4dENoaWxkSW5zdGFuY2UsIG5hbWUsIG5leHRJbmRleCwgdHJhbnNhY3Rpb25cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIG5leHRJbmRleCsrO1xuICAgICAgfVxuICAgICAgLy8gUmVtb3ZlIGNoaWxkcmVuIHRoYXQgYXJlIG5vIGxvbmdlciBwcmVzZW50LlxuICAgICAgZm9yIChuYW1lIGluIHByZXZDaGlsZHJlbikge1xuICAgICAgICBpZiAocHJldkNoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpICYmXG4gICAgICAgICAgICAhKG5leHRDaGlsZHJlbiAmJiBuZXh0Q2hpbGRyZW5bbmFtZV0pKSB7XG4gICAgICAgICAgdGhpcy5fdW5tb3VudENoaWxkQnlOYW1lKHByZXZDaGlsZHJlbltuYW1lXSwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVW5tb3VudHMgYWxsIHJlbmRlcmVkIGNoaWxkcmVuLiBUaGlzIHNob3VsZCBiZSB1c2VkIHRvIGNsZWFuIHVwIGNoaWxkcmVuXG4gICAgICogd2hlbiB0aGlzIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB1bm1vdW50Q2hpbGRyZW46IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlbmRlcmVkQ2hpbGRyZW4gPSB0aGlzLl9yZW5kZXJlZENoaWxkcmVuO1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiByZW5kZXJlZENoaWxkcmVuKSB7XG4gICAgICAgIHZhciByZW5kZXJlZENoaWxkID0gcmVuZGVyZWRDaGlsZHJlbltuYW1lXTtcbiAgICAgICAgLy8gVE9ETzogV2hlbiBpcyB0aGlzIG5vdCB0cnVlP1xuICAgICAgICBpZiAocmVuZGVyZWRDaGlsZC51bm1vdW50Q29tcG9uZW50KSB7XG4gICAgICAgICAgcmVuZGVyZWRDaGlsZC51bm1vdW50Q29tcG9uZW50KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW4gPSBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhIGNoaWxkIGNvbXBvbmVudCB0byB0aGUgc3VwcGxpZWQgaW5kZXguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDb21wb25lbnQgdG8gbW92ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9JbmRleCBEZXN0aW5hdGlvbiBpbmRleCBvZiB0aGUgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGFzdEluZGV4IExhc3QgaW5kZXggdmlzaXRlZCBvZiB0aGUgc2libGluZ3Mgb2YgYGNoaWxkYC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgbW92ZUNoaWxkOiBmdW5jdGlvbihjaGlsZCwgdG9JbmRleCwgbGFzdEluZGV4KSB7XG4gICAgICAvLyBJZiB0aGUgaW5kZXggb2YgYGNoaWxkYCBpcyBsZXNzIHRoYW4gYGxhc3RJbmRleGAsIHRoZW4gaXQgbmVlZHMgdG9cbiAgICAgIC8vIGJlIG1vdmVkLiBPdGhlcndpc2UsIHdlIGRvIG5vdCBuZWVkIHRvIG1vdmUgaXQgYmVjYXVzZSBhIGNoaWxkIHdpbGwgYmVcbiAgICAgIC8vIGluc2VydGVkIG9yIG1vdmVkIGJlZm9yZSBgY2hpbGRgLlxuICAgICAgaWYgKGNoaWxkLl9tb3VudEluZGV4IDwgbGFzdEluZGV4KSB7XG4gICAgICAgIGVucXVldWVNb3ZlKHRoaXMuX3Jvb3ROb2RlSUQsIGNoaWxkLl9tb3VudEluZGV4LCB0b0luZGV4KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNoaWxkIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNoaWxkIENvbXBvbmVudCB0byBjcmVhdGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1vdW50SW1hZ2UgTWFya3VwIHRvIGluc2VydC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY3JlYXRlQ2hpbGQ6IGZ1bmN0aW9uKGNoaWxkLCBtb3VudEltYWdlKSB7XG4gICAgICBlbnF1ZXVlTWFya3VwKHRoaXMuX3Jvb3ROb2RlSUQsIG1vdW50SW1hZ2UsIGNoaWxkLl9tb3VudEluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIGNoaWxkIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNoaWxkIENoaWxkIHRvIHJlbW92ZS5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcmVtb3ZlQ2hpbGQ6IGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICBlbnF1ZXVlUmVtb3ZlKHRoaXMuX3Jvb3ROb2RlSUQsIGNoaWxkLl9tb3VudEluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGlzIHRleHQgY29udGVudCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dENvbnRlbnQgVGV4dCBjb250ZW50IHRvIHNldC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2V0VGV4dENvbnRlbnQ6IGZ1bmN0aW9uKHRleHRDb250ZW50KSB7XG4gICAgICBlbnF1ZXVlVGV4dENvbnRlbnQodGhpcy5fcm9vdE5vZGVJRCwgdGV4dENvbnRlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3VudHMgYSBjaGlsZCB3aXRoIHRoZSBzdXBwbGllZCBuYW1lLlxuICAgICAqXG4gICAgICogTk9URTogVGhpcyBpcyBwYXJ0IG9mIGB1cGRhdGVDaGlsZHJlbmAgYW5kIGlzIGhlcmUgZm9yIHJlYWRhYmlsaXR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY2hpbGQgQ29tcG9uZW50IHRvIG1vdW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIGNoaWxkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBhdCB3aGljaCB0byBpbnNlcnQgdGhlIGNoaWxkLlxuICAgICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tb3VudENoaWxkQnlOYW1lQXRJbmRleDogZnVuY3Rpb24oY2hpbGQsIG5hbWUsIGluZGV4LCB0cmFuc2FjdGlvbikge1xuICAgICAgLy8gSW5saW5lZCBmb3IgcGVyZm9ybWFuY2UsIHNlZSBgUmVhY3RJbnN0YW5jZUhhbmRsZXMuY3JlYXRlUmVhY3RJRGAuXG4gICAgICB2YXIgcm9vdElEID0gdGhpcy5fcm9vdE5vZGVJRCArIG5hbWU7XG4gICAgICB2YXIgbW91bnRJbWFnZSA9IGNoaWxkLm1vdW50Q29tcG9uZW50KFxuICAgICAgICByb290SUQsXG4gICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICB0aGlzLl9tb3VudERlcHRoICsgMVxuICAgICAgKTtcbiAgICAgIGNoaWxkLl9tb3VudEluZGV4ID0gaW5kZXg7XG4gICAgICB0aGlzLmNyZWF0ZUNoaWxkKGNoaWxkLCBtb3VudEltYWdlKTtcbiAgICAgIHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW4gPSB0aGlzLl9yZW5kZXJlZENoaWxkcmVuIHx8IHt9O1xuICAgICAgdGhpcy5fcmVuZGVyZWRDaGlsZHJlbltuYW1lXSA9IGNoaWxkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVbm1vdW50cyBhIHJlbmRlcmVkIGNoaWxkIGJ5IG5hbWUuXG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGlzIGlzIHBhcnQgb2YgYHVwZGF0ZUNoaWxkcmVuYCBhbmQgaXMgaGVyZSBmb3IgcmVhZGFiaWxpdHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDb21wb25lbnQgdG8gdW5tb3VudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSBjaGlsZCBpbiBgdGhpcy5fcmVuZGVyZWRDaGlsZHJlbmAuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdW5tb3VudENoaWxkQnlOYW1lOiBmdW5jdGlvbihjaGlsZCwgbmFtZSkge1xuICAgICAgdGhpcy5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgICBjaGlsZC5fbW91bnRJbmRleCA9IG51bGw7XG4gICAgICBjaGlsZC51bm1vdW50Q29tcG9uZW50KCk7XG4gICAgICBkZWxldGUgdGhpcy5fcmVuZGVyZWRDaGlsZHJlbltuYW1lXTtcbiAgICB9XG5cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0TXVsdGlDaGlsZDtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlc1xuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIga2V5TWlycm9yID0gcmVxdWlyZShcIi4va2V5TWlycm9yXCIpO1xuXG4vKipcbiAqIFdoZW4gYSBjb21wb25lbnQncyBjaGlsZHJlbiBhcmUgdXBkYXRlZCwgYSBzZXJpZXMgb2YgdXBkYXRlIGNvbmZpZ3VyYXRpb25cbiAqIG9iamVjdHMgYXJlIGNyZWF0ZWQgaW4gb3JkZXIgdG8gYmF0Y2ggYW5kIHNlcmlhbGl6ZSB0aGUgcmVxdWlyZWQgY2hhbmdlcy5cbiAqXG4gKiBFbnVtZXJhdGVzIGFsbCB0aGUgcG9zc2libGUgdHlwZXMgb2YgdXBkYXRlIGNvbmZpZ3VyYXRpb25zLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMgPSBrZXlNaXJyb3Ioe1xuICBJTlNFUlRfTUFSS1VQOiBudWxsLFxuICBNT1ZFX0VYSVNUSU5HOiBudWxsLFxuICBSRU1PVkVfTk9ERTogbnVsbCxcbiAgVEVYVF9DT05URU5UOiBudWxsXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcztcbiIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RPd25lclxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKFwiLi9lbXB0eU9iamVjdFwiKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbi8qKlxuICogUmVhY3RPd25lcnMgYXJlIGNhcGFibGUgb2Ygc3RvcmluZyByZWZlcmVuY2VzIHRvIG93bmVkIGNvbXBvbmVudHMuXG4gKlxuICogQWxsIGNvbXBvbmVudHMgYXJlIGNhcGFibGUgb2YgLy9iZWluZy8vIHJlZmVyZW5jZWQgYnkgb3duZXIgY29tcG9uZW50cywgYnV0XG4gKiBvbmx5IFJlYWN0T3duZXIgY29tcG9uZW50cyBhcmUgY2FwYWJsZSBvZiAvL3JlZmVyZW5jaW5nLy8gb3duZWQgY29tcG9uZW50cy5cbiAqIFRoZSBuYW1lZCByZWZlcmVuY2UgaXMga25vd24gYXMgYSBcInJlZlwiLlxuICpcbiAqIFJlZnMgYXJlIGF2YWlsYWJsZSB3aGVuIG1vdW50ZWQgYW5kIHVwZGF0ZWQgZHVyaW5nIHJlY29uY2lsaWF0aW9uLlxuICpcbiAqICAgdmFyIE15Q29tcG9uZW50ID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gKiAgICAgICByZXR1cm4gKFxuICogICAgICAgICA8ZGl2IG9uQ2xpY2s9e3RoaXMuaGFuZGxlQ2xpY2t9PlxuICogICAgICAgICAgIDxDdXN0b21Db21wb25lbnQgcmVmPVwiY3VzdG9tXCIgLz5cbiAqICAgICAgICAgPC9kaXY+XG4gKiAgICAgICApO1xuICogICAgIH0sXG4gKiAgICAgaGFuZGxlQ2xpY2s6IGZ1bmN0aW9uKCkge1xuICogICAgICAgdGhpcy5yZWZzLmN1c3RvbS5oYW5kbGVDbGljaygpO1xuICogICAgIH0sXG4gKiAgICAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uKCkge1xuICogICAgICAgdGhpcy5yZWZzLmN1c3RvbS5pbml0aWFsaXplKCk7XG4gKiAgICAgfVxuICogICB9KTtcbiAqXG4gKiBSZWZzIHNob3VsZCByYXJlbHkgYmUgdXNlZC4gV2hlbiByZWZzIGFyZSB1c2VkLCB0aGV5IHNob3VsZCBvbmx5IGJlIGRvbmUgdG9cbiAqIGNvbnRyb2wgZGF0YSB0aGF0IGlzIG5vdCBoYW5kbGVkIGJ5IFJlYWN0J3MgZGF0YSBmbG93LlxuICpcbiAqIEBjbGFzcyBSZWFjdE93bmVyXG4gKi9cbnZhciBSZWFjdE93bmVyID0ge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgdmFsaWQgb3duZXIuXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNWYWxpZE93bmVyOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gISEoXG4gICAgICBvYmplY3QgJiZcbiAgICAgIHR5cGVvZiBvYmplY3QuYXR0YWNoUmVmID09PSAnZnVuY3Rpb24nICYmXG4gICAgICB0eXBlb2Ygb2JqZWN0LmRldGFjaFJlZiA9PT0gJ2Z1bmN0aW9uJ1xuICAgICk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFkZHMgYSBjb21wb25lbnQgYnkgcmVmIHRvIGFuIG93bmVyIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY29tcG9uZW50IENvbXBvbmVudCB0byByZWZlcmVuY2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWYgTmFtZSBieSB3aGljaCB0byByZWZlciB0byB0aGUgY29tcG9uZW50LlxuICAgKiBAcGFyYW0ge1JlYWN0T3duZXJ9IG93bmVyIENvbXBvbmVudCBvbiB3aGljaCB0byByZWNvcmQgdGhlIHJlZi5cbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgYWRkQ29tcG9uZW50QXNSZWZUbzogZnVuY3Rpb24oY29tcG9uZW50LCByZWYsIG93bmVyKSB7XG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgIFJlYWN0T3duZXIuaXNWYWxpZE93bmVyKG93bmVyKSxcbiAgICAgICdhZGRDb21wb25lbnRBc1JlZlRvKC4uLik6IE9ubHkgYSBSZWFjdE93bmVyIGNhbiBoYXZlIHJlZnMuIFRoaXMgJyArXG4gICAgICAndXN1YWxseSBtZWFucyB0aGF0IHlvdVxcJ3JlIHRyeWluZyB0byBhZGQgYSByZWYgdG8gYSBjb21wb25lbnQgdGhhdCAnICtcbiAgICAgICdkb2VzblxcJ3QgaGF2ZSBhbiBvd25lciAodGhhdCBpcywgd2FzIG5vdCBjcmVhdGVkIGluc2lkZSBvZiBhbm90aGVyICcgK1xuICAgICAgJ2NvbXBvbmVudFxcJ3MgYHJlbmRlcmAgbWV0aG9kKS4gVHJ5IHJlbmRlcmluZyB0aGlzIGNvbXBvbmVudCBpbnNpZGUgb2YgJyArXG4gICAgICAnYSBuZXcgdG9wLWxldmVsIGNvbXBvbmVudCB3aGljaCB3aWxsIGhvbGQgdGhlIHJlZi4nXG4gICAgKSA6IGludmFyaWFudChSZWFjdE93bmVyLmlzVmFsaWRPd25lcihvd25lcikpKTtcbiAgICBvd25lci5hdHRhY2hSZWYocmVmLCBjb21wb25lbnQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgY29tcG9uZW50IGJ5IHJlZiBmcm9tIGFuIG93bmVyIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY29tcG9uZW50IENvbXBvbmVudCB0byBkZXJlZmVyZW5jZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZiBOYW1lIG9mIHRoZSByZWYgdG8gcmVtb3ZlLlxuICAgKiBAcGFyYW0ge1JlYWN0T3duZXJ9IG93bmVyIENvbXBvbmVudCBvbiB3aGljaCB0aGUgcmVmIGlzIHJlY29yZGVkLlxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICByZW1vdmVDb21wb25lbnRBc1JlZkZyb206IGZ1bmN0aW9uKGNvbXBvbmVudCwgcmVmLCBvd25lcikge1xuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICBSZWFjdE93bmVyLmlzVmFsaWRPd25lcihvd25lciksXG4gICAgICAncmVtb3ZlQ29tcG9uZW50QXNSZWZGcm9tKC4uLik6IE9ubHkgYSBSZWFjdE93bmVyIGNhbiBoYXZlIHJlZnMuIFRoaXMgJyArXG4gICAgICAndXN1YWxseSBtZWFucyB0aGF0IHlvdVxcJ3JlIHRyeWluZyB0byByZW1vdmUgYSByZWYgdG8gYSBjb21wb25lbnQgdGhhdCAnICtcbiAgICAgICdkb2VzblxcJ3QgaGF2ZSBhbiBvd25lciAodGhhdCBpcywgd2FzIG5vdCBjcmVhdGVkIGluc2lkZSBvZiBhbm90aGVyICcgK1xuICAgICAgJ2NvbXBvbmVudFxcJ3MgYHJlbmRlcmAgbWV0aG9kKS4gVHJ5IHJlbmRlcmluZyB0aGlzIGNvbXBvbmVudCBpbnNpZGUgb2YgJyArXG4gICAgICAnYSBuZXcgdG9wLWxldmVsIGNvbXBvbmVudCB3aGljaCB3aWxsIGhvbGQgdGhlIHJlZi4nXG4gICAgKSA6IGludmFyaWFudChSZWFjdE93bmVyLmlzVmFsaWRPd25lcihvd25lcikpKTtcbiAgICAvLyBDaGVjayB0aGF0IGBjb21wb25lbnRgIGlzIHN0aWxsIHRoZSBjdXJyZW50IHJlZiBiZWNhdXNlIHdlIGRvIG5vdCB3YW50IHRvXG4gICAgLy8gZGV0YWNoIHRoZSByZWYgaWYgYW5vdGhlciBjb21wb25lbnQgc3RvbGUgaXQuXG4gICAgaWYgKG93bmVyLnJlZnNbcmVmXSA9PT0gY29tcG9uZW50KSB7XG4gICAgICBvd25lci5kZXRhY2hSZWYocmVmKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEEgUmVhY3RDb21wb25lbnQgbXVzdCBtaXggdGhpcyBpbiB0byBoYXZlIHJlZnMuXG4gICAqXG4gICAqIEBsZW5kcyB7UmVhY3RPd25lci5wcm90b3R5cGV9XG4gICAqL1xuICBNaXhpbjoge1xuXG4gICAgY29uc3RydWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBMYXppbHkgYWxsb2NhdGVzIHRoZSByZWZzIG9iamVjdCBhbmQgc3RvcmVzIGBjb21wb25lbnRgIGFzIGByZWZgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJlZiBSZWZlcmVuY2UgbmFtZS5cbiAgICAgKiBAcGFyYW0ge2NvbXBvbmVudH0gY29tcG9uZW50IENvbXBvbmVudCB0byBzdG9yZSBhcyBgcmVmYC5cbiAgICAgKiBAZmluYWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGF0dGFjaFJlZjogZnVuY3Rpb24ocmVmLCBjb21wb25lbnQpIHtcbiAgICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAgIGNvbXBvbmVudC5pc093bmVkQnkodGhpcyksXG4gICAgICAgICdhdHRhY2hSZWYoJXMsIC4uLik6IE9ubHkgYSBjb21wb25lbnRcXCdzIG93bmVyIGNhbiBzdG9yZSBhIHJlZiB0byBpdC4nLFxuICAgICAgICByZWZcbiAgICAgICkgOiBpbnZhcmlhbnQoY29tcG9uZW50LmlzT3duZWRCeSh0aGlzKSkpO1xuICAgICAgdmFyIHJlZnMgPSB0aGlzLnJlZnMgPT09IGVtcHR5T2JqZWN0ID8gKHRoaXMucmVmcyA9IHt9KSA6IHRoaXMucmVmcztcbiAgICAgIHJlZnNbcmVmXSA9IGNvbXBvbmVudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGV0YWNoZXMgYSByZWZlcmVuY2UgbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZWYgTmFtZSB0byBkZXJlZmVyZW5jZS5cbiAgICAgKiBAZmluYWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGRldGFjaFJlZjogZnVuY3Rpb24ocmVmKSB7XG4gICAgICBkZWxldGUgdGhpcy5yZWZzW3JlZl07XG4gICAgfVxuXG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE93bmVyO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UGVyZlxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBSZWFjdFBlcmYgaXMgYSBnZW5lcmFsIEFPUCBzeXN0ZW0gZGVzaWduZWQgdG8gbWVhc3VyZSBwZXJmb3JtYW5jZS4gVGhpc1xuICogbW9kdWxlIG9ubHkgaGFzIHRoZSBob29rczogc2VlIFJlYWN0RGVmYXVsdFBlcmYgZm9yIHRoZSBhbmFseXNpcyB0b29sLlxuICovXG52YXIgUmVhY3RQZXJmID0ge1xuICAvKipcbiAgICogQm9vbGVhbiB0byBlbmFibGUvZGlzYWJsZSBtZWFzdXJlbWVudC4gU2V0IHRvIGZhbHNlIGJ5IGRlZmF1bHQgdG8gcHJldmVudFxuICAgKiBhY2NpZGVudGFsIGxvZ2dpbmcgYW5kIHBlcmYgbG9zcy5cbiAgICovXG4gIGVuYWJsZU1lYXN1cmU6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBIb2xkcyBvbnRvIHRoZSBtZWFzdXJlIGZ1bmN0aW9uIGluIHVzZS4gQnkgZGVmYXVsdCwgZG9uJ3QgbWVhc3VyZVxuICAgKiBhbnl0aGluZywgYnV0IHdlJ2xsIG92ZXJyaWRlIHRoaXMgaWYgd2UgaW5qZWN0IGEgbWVhc3VyZSBmdW5jdGlvbi5cbiAgICovXG4gIHN0b3JlZE1lYXN1cmU6IF9ub01lYXN1cmUsXG5cbiAgLyoqXG4gICAqIFVzZSB0aGlzIHRvIHdyYXAgbWV0aG9kcyB5b3Ugd2FudCB0byBtZWFzdXJlLiBaZXJvIG92ZXJoZWFkIGluIHByb2R1Y3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvYmpOYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmbk5hbWVcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuY1xuICAgKiBAcmV0dXJuIHtmdW5jdGlvbn1cbiAgICovXG4gIG1lYXN1cmU6IGZ1bmN0aW9uKG9iak5hbWUsIGZuTmFtZSwgZnVuYykge1xuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgIHZhciBtZWFzdXJlZEZ1bmMgPSBudWxsO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoUmVhY3RQZXJmLmVuYWJsZU1lYXN1cmUpIHtcbiAgICAgICAgICBpZiAoIW1lYXN1cmVkRnVuYykge1xuICAgICAgICAgICAgbWVhc3VyZWRGdW5jID0gUmVhY3RQZXJmLnN0b3JlZE1lYXN1cmUob2JqTmFtZSwgZm5OYW1lLCBmdW5jKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1lYXN1cmVkRnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZnVuYztcbiAgfSxcblxuICBpbmplY3Rpb246IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBtZWFzdXJlXG4gICAgICovXG4gICAgaW5qZWN0TWVhc3VyZTogZnVuY3Rpb24obWVhc3VyZSkge1xuICAgICAgUmVhY3RQZXJmLnN0b3JlZE1lYXN1cmUgPSBtZWFzdXJlO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBTaW1wbHkgcGFzc2VzIHRocm91Z2ggdGhlIG1lYXN1cmVkIGZ1bmN0aW9uLCB3aXRob3V0IG1lYXN1cmluZyBpdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gb2JqTmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IGZuTmFtZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuY1xuICogQHJldHVybiB7ZnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIF9ub01lYXN1cmUob2JqTmFtZSwgZm5OYW1lLCBmdW5jKSB7XG4gIHJldHVybiBmdW5jO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UGVyZjtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFByb3BUcmFuc2ZlcmVyXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZShcIi4vZW1wdHlGdW5jdGlvblwiKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG52YXIgam9pbkNsYXNzZXMgPSByZXF1aXJlKFwiLi9qb2luQ2xhc3Nlc1wiKTtcbnZhciBtZXJnZSA9IHJlcXVpcmUoXCIuL21lcmdlXCIpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSB0cmFuc2ZlciBzdHJhdGVneSB0aGF0IHdpbGwgbWVyZ2UgcHJvcCB2YWx1ZXMgdXNpbmcgdGhlIHN1cHBsaWVkXG4gKiBgbWVyZ2VTdHJhdGVneWAuIElmIGEgcHJvcCB3YXMgcHJldmlvdXNseSB1bnNldCwgdGhpcyBqdXN0IHNldHMgaXQuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gbWVyZ2VTdHJhdGVneVxuICogQHJldHVybiB7ZnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zZmVyU3RyYXRlZ3kobWVyZ2VTdHJhdGVneSkge1xuICByZXR1cm4gZnVuY3Rpb24ocHJvcHMsIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoIXByb3BzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHByb3BzW2tleV0gPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvcHNba2V5XSA9IG1lcmdlU3RyYXRlZ3kocHJvcHNba2V5XSwgdmFsdWUpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIHRyYW5zZmVyU3RyYXRlZ3lNZXJnZSA9IGNyZWF0ZVRyYW5zZmVyU3RyYXRlZ3koZnVuY3Rpb24oYSwgYikge1xuICAvLyBgbWVyZ2VgIG92ZXJyaWRlcyB0aGUgZmlyc3Qgb2JqZWN0J3MgKGBwcm9wc1trZXldYCBhYm92ZSkga2V5cyB1c2luZyB0aGVcbiAgLy8gc2Vjb25kIG9iamVjdCdzIChgdmFsdWVgKSBrZXlzLiBBbiBvYmplY3QncyBzdHlsZSdzIGV4aXN0aW5nIGBwcm9wQWAgd291bGRcbiAgLy8gZ2V0IG92ZXJyaWRkZW4uIEZsaXAgdGhlIG9yZGVyIGhlcmUuXG4gIHJldHVybiBtZXJnZShiLCBhKTtcbn0pO1xuXG4vKipcbiAqIFRyYW5zZmVyIHN0cmF0ZWdpZXMgZGljdGF0ZSBob3cgcHJvcHMgYXJlIHRyYW5zZmVycmVkIGJ5IGB0cmFuc2ZlclByb3BzVG9gLlxuICogTk9URTogaWYgeW91IGFkZCBhbnkgbW9yZSBleGNlcHRpb25zIHRvIHRoaXMgbGlzdCB5b3Ugc2hvdWxkIGJlIHN1cmUgdG9cbiAqIHVwZGF0ZSBgY2xvbmVXaXRoUHJvcHMoKWAgYWNjb3JkaW5nbHkuXG4gKi9cbnZhciBUcmFuc2ZlclN0cmF0ZWdpZXMgPSB7XG4gIC8qKlxuICAgKiBOZXZlciB0cmFuc2ZlciBgY2hpbGRyZW5gLlxuICAgKi9cbiAgY2hpbGRyZW46IGVtcHR5RnVuY3Rpb24sXG4gIC8qKlxuICAgKiBUcmFuc2ZlciB0aGUgYGNsYXNzTmFtZWAgcHJvcCBieSBtZXJnaW5nIHRoZW0uXG4gICAqL1xuICBjbGFzc05hbWU6IGNyZWF0ZVRyYW5zZmVyU3RyYXRlZ3koam9pbkNsYXNzZXMpLFxuICAvKipcbiAgICogTmV2ZXIgdHJhbnNmZXIgdGhlIGBrZXlgIHByb3AuXG4gICAqL1xuICBrZXk6IGVtcHR5RnVuY3Rpb24sXG4gIC8qKlxuICAgKiBOZXZlciB0cmFuc2ZlciB0aGUgYHJlZmAgcHJvcC5cbiAgICovXG4gIHJlZjogZW1wdHlGdW5jdGlvbixcbiAgLyoqXG4gICAqIFRyYW5zZmVyIHRoZSBgc3R5bGVgIHByb3AgKHdoaWNoIGlzIGFuIG9iamVjdCkgYnkgbWVyZ2luZyB0aGVtLlxuICAgKi9cbiAgc3R5bGU6IHRyYW5zZmVyU3RyYXRlZ3lNZXJnZVxufTtcblxuLyoqXG4gKiBNdXRhdGVzIHRoZSBmaXJzdCBhcmd1bWVudCBieSB0cmFuc2ZlcnJpbmcgdGhlIHByb3BlcnRpZXMgZnJvbSB0aGUgc2Vjb25kXG4gKiBhcmd1bWVudC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7b2JqZWN0fSBuZXdQcm9wc1xuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiB0cmFuc2ZlckludG8ocHJvcHMsIG5ld1Byb3BzKSB7XG4gIGZvciAodmFyIHRoaXNLZXkgaW4gbmV3UHJvcHMpIHtcbiAgICBpZiAoIW5ld1Byb3BzLmhhc093blByb3BlcnR5KHRoaXNLZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgdHJhbnNmZXJTdHJhdGVneSA9IFRyYW5zZmVyU3RyYXRlZ2llc1t0aGlzS2V5XTtcblxuICAgIGlmICh0cmFuc2ZlclN0cmF0ZWd5ICYmIFRyYW5zZmVyU3RyYXRlZ2llcy5oYXNPd25Qcm9wZXJ0eSh0aGlzS2V5KSkge1xuICAgICAgdHJhbnNmZXJTdHJhdGVneShwcm9wcywgdGhpc0tleSwgbmV3UHJvcHNbdGhpc0tleV0pO1xuICAgIH0gZWxzZSBpZiAoIXByb3BzLmhhc093blByb3BlcnR5KHRoaXNLZXkpKSB7XG4gICAgICBwcm9wc1t0aGlzS2V5XSA9IG5ld1Byb3BzW3RoaXNLZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcHJvcHM7XG59XG5cbi8qKlxuICogUmVhY3RQcm9wVHJhbnNmZXJlciBhcmUgY2FwYWJsZSBvZiB0cmFuc2ZlcnJpbmcgcHJvcHMgdG8gYW5vdGhlciBjb21wb25lbnRcbiAqIHVzaW5nIGEgYHRyYW5zZmVyUHJvcHNUb2AgbWV0aG9kLlxuICpcbiAqIEBjbGFzcyBSZWFjdFByb3BUcmFuc2ZlcmVyXG4gKi9cbnZhciBSZWFjdFByb3BUcmFuc2ZlcmVyID0ge1xuXG4gIFRyYW5zZmVyU3RyYXRlZ2llczogVHJhbnNmZXJTdHJhdGVnaWVzLFxuXG4gIC8qKlxuICAgKiBNZXJnZSB0d28gcHJvcHMgb2JqZWN0cyB1c2luZyBUcmFuc2ZlclN0cmF0ZWdpZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvbGRQcm9wcyBvcmlnaW5hbCBwcm9wcyAodGhleSB0YWtlIHByZWNlZGVuY2UpXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXdQcm9wcyBuZXcgcHJvcHMgdG8gbWVyZ2UgaW5cbiAgICogQHJldHVybiB7b2JqZWN0fSBhIG5ldyBvYmplY3QgY29udGFpbmluZyBib3RoIHNldHMgb2YgcHJvcHMgbWVyZ2VkLlxuICAgKi9cbiAgbWVyZ2VQcm9wczogZnVuY3Rpb24ob2xkUHJvcHMsIG5ld1Byb3BzKSB7XG4gICAgcmV0dXJuIHRyYW5zZmVySW50byhtZXJnZShvbGRQcm9wcyksIG5ld1Byb3BzKTtcbiAgfSxcblxuICAvKipcbiAgICogQGxlbmRzIHtSZWFjdFByb3BUcmFuc2ZlcmVyLnByb3RvdHlwZX1cbiAgICovXG4gIE1peGluOiB7XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2ZlciBwcm9wcyBmcm9tIHRoaXMgY29tcG9uZW50IHRvIGEgdGFyZ2V0IGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIFByb3BzIHRoYXQgZG8gbm90IGhhdmUgYW4gZXhwbGljaXQgdHJhbnNmZXIgc3RyYXRlZ3kgd2lsbCBiZSB0cmFuc2ZlcnJlZFxuICAgICAqIG9ubHkgaWYgdGhlIHRhcmdldCBjb21wb25lbnQgZG9lcyBub3QgYWxyZWFkeSBoYXZlIHRoZSBwcm9wIHNldC5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgdXN1YWxseSB1c2VkIHRvIHBhc3MgZG93biBwcm9wcyB0byBhIHJldHVybmVkIHJvb3QgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdERlc2NyaXB0b3J9IGRlc2NyaXB0b3IgQ29tcG9uZW50IHJlY2VpdmluZyB0aGUgcHJvcGVydGllcy5cbiAgICAgKiBAcmV0dXJuIHtSZWFjdERlc2NyaXB0b3J9IFRoZSBzdXBwbGllZCBgY29tcG9uZW50YC5cbiAgICAgKiBAZmluYWxcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdHJhbnNmZXJQcm9wc1RvOiBmdW5jdGlvbihkZXNjcmlwdG9yKSB7XG4gICAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgICBkZXNjcmlwdG9yLl9vd25lciA9PT0gdGhpcyxcbiAgICAgICAgJyVzOiBZb3UgY2FuXFwndCBjYWxsIHRyYW5zZmVyUHJvcHNUbygpIG9uIGEgY29tcG9uZW50IHRoYXQgeW91ICcgK1xuICAgICAgICAnZG9uXFwndCBvd24sICVzLiBUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGFyZSBjYWxsaW5nICcgK1xuICAgICAgICAndHJhbnNmZXJQcm9wc1RvKCkgb24gYSBjb21wb25lbnQgcGFzc2VkIGluIGFzIHByb3BzIG9yIGNoaWxkcmVuLicsXG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IuZGlzcGxheU5hbWUsXG4gICAgICAgIGRlc2NyaXB0b3IudHlwZS5kaXNwbGF5TmFtZVxuICAgICAgKSA6IGludmFyaWFudChkZXNjcmlwdG9yLl9vd25lciA9PT0gdGhpcykpO1xuXG4gICAgICAvLyBCZWNhdXNlIGRlc2NyaXB0b3JzIGFyZSBpbW11dGFibGUgd2UgaGF2ZSB0byBtZXJnZSBpbnRvIHRoZSBleGlzdGluZ1xuICAgICAgLy8gcHJvcHMgb2JqZWN0IHJhdGhlciB0aGFuIGNsb25lIGl0LlxuICAgICAgdHJhbnNmZXJJbnRvKGRlc2NyaXB0b3IucHJvcHMsIHRoaXMucHJvcHMpO1xuXG4gICAgICByZXR1cm4gZGVzY3JpcHRvcjtcbiAgICB9XG5cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUcmFuc2ZlcmVyO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHt9O1xuXG5pZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0ge1xuICAgIHByb3A6ICdwcm9wJyxcbiAgICBjb250ZXh0OiAnY29udGV4dCcsXG4gICAgY2hpbGRDb250ZXh0OiAnY2hpbGQgY29udGV4dCdcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcztcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnNcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGtleU1pcnJvciA9IHJlcXVpcmUoXCIuL2tleU1pcnJvclwiKTtcblxudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMgPSBrZXlNaXJyb3Ioe1xuICBwcm9wOiBudWxsLFxuICBjb250ZXh0OiBudWxsLFxuICBjaGlsZENvbnRleHQ6IG51bGxcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbnM7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RQcm9wVHlwZXNcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIFJlYWN0RGVzY3JpcHRvciA9IHJlcXVpcmUoXCIuL1JlYWN0RGVzY3JpcHRvclwiKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHJlcXVpcmUoXCIuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzXCIpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoXCIuL2VtcHR5RnVuY3Rpb25cIik7XG5cbi8qKlxuICogQ29sbGVjdGlvbiBvZiBtZXRob2RzIHRoYXQgYWxsb3cgZGVjbGFyYXRpb24gYW5kIHZhbGlkYXRpb24gb2YgcHJvcHMgdGhhdCBhcmVcbiAqIHN1cHBsaWVkIHRvIFJlYWN0IGNvbXBvbmVudHMuIEV4YW1wbGUgdXNhZ2U6XG4gKlxuICogICB2YXIgUHJvcHMgPSByZXF1aXJlKCdSZWFjdFByb3BUeXBlcycpO1xuICogICB2YXIgTXlBcnRpY2xlID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICogICAgIHByb3BUeXBlczoge1xuICogICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIHByb3AgbmFtZWQgXCJkZXNjcmlwdGlvblwiLlxuICogICAgICAgZGVzY3JpcHRpb246IFByb3BzLnN0cmluZyxcbiAqXG4gKiAgICAgICAvLyBBIHJlcXVpcmVkIGVudW0gcHJvcCBuYW1lZCBcImNhdGVnb3J5XCIuXG4gKiAgICAgICBjYXRlZ29yeTogUHJvcHMub25lT2YoWydOZXdzJywnUGhvdG9zJ10pLmlzUmVxdWlyZWQsXG4gKlxuICogICAgICAgLy8gQSBwcm9wIG5hbWVkIFwiZGlhbG9nXCIgdGhhdCByZXF1aXJlcyBhbiBpbnN0YW5jZSBvZiBEaWFsb2cuXG4gKiAgICAgICBkaWFsb2c6IFByb3BzLmluc3RhbmNlT2YoRGlhbG9nKS5pc1JlcXVpcmVkXG4gKiAgICAgfSxcbiAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkgeyAuLi4gfVxuICogICB9KTtcbiAqXG4gKiBBIG1vcmUgZm9ybWFsIHNwZWNpZmljYXRpb24gb2YgaG93IHRoZXNlIG1ldGhvZHMgYXJlIHVzZWQ6XG4gKlxuICogICB0eXBlIDo9IGFycmF5fGJvb2x8ZnVuY3xvYmplY3R8bnVtYmVyfHN0cmluZ3xvbmVPZihbLi4uXSl8aW5zdGFuY2VPZiguLi4pXG4gKiAgIGRlY2wgOj0gUmVhY3RQcm9wVHlwZXMue3R5cGV9KC5pc1JlcXVpcmVkKT9cbiAqXG4gKiBFYWNoIGFuZCBldmVyeSBkZWNsYXJhdGlvbiBwcm9kdWNlcyBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgc2lnbmF0dXJlLiBUaGlzXG4gKiBhbGxvd3MgdGhlIGNyZWF0aW9uIG9mIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9ucy4gRm9yIGV4YW1wbGU6XG4gKlxuICogIHZhciBNeUxpbmsgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gKiAgICBwcm9wVHlwZXM6IHtcbiAqICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIG9yIFVSSSBwcm9wIG5hbWVkIFwiaHJlZlwiLlxuICogICAgICBocmVmOiBmdW5jdGlvbihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAqICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICogICAgICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgcHJvcFZhbHVlICE9PSAnc3RyaW5nJyAmJlxuICogICAgICAgICAgICAhKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFVSSSkpIHtcbiAqICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gKiAgICAgICAgICAgICdFeHBlY3RlZCBhIHN0cmluZyBvciBhbiBVUkkgZm9yICcgKyBwcm9wTmFtZSArICcgaW4gJyArXG4gKiAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAqICAgICAgICAgICk7XG4gKiAgICAgICAgfVxuICogICAgICB9XG4gKiAgICB9LFxuICogICAgcmVuZGVyOiBmdW5jdGlvbigpIHsuLi59XG4gKiAgfSk7XG4gKlxuICogQGludGVybmFsXG4gKi9cblxudmFyIEFOT05ZTU9VUyA9ICc8PGFub255bW91cz4+JztcblxudmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICBhcnJheTogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2FycmF5JyksXG4gIGJvb2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdib29sZWFuJyksXG4gIGZ1bmM6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdmdW5jdGlvbicpLFxuICBudW1iZXI6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdudW1iZXInKSxcbiAgb2JqZWN0OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignb2JqZWN0JyksXG4gIHN0cmluZzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N0cmluZycpLFxuXG4gIGFueTogY3JlYXRlQW55VHlwZUNoZWNrZXIoKSxcbiAgYXJyYXlPZjogY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyLFxuICBjb21wb25lbnQ6IGNyZWF0ZUNvbXBvbmVudFR5cGVDaGVja2VyKCksXG4gIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXG4gIG9iamVjdE9mOiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyLFxuICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxuICBvbmVPZlR5cGU6IGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIsXG4gIHJlbmRlcmFibGU6IGNyZWF0ZVJlbmRlcmFibGVUeXBlQ2hlY2tlcigpLFxuICBzaGFwZTogY3JlYXRlU2hhcGVUeXBlQ2hlY2tlclxufTtcblxuZnVuY3Rpb24gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpIHtcbiAgZnVuY3Rpb24gY2hlY2tUeXBlKGlzUmVxdWlyZWQsIHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24pIHtcbiAgICBjb21wb25lbnROYW1lID0gY29tcG9uZW50TmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgaWYgKGlzUmVxdWlyZWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICAgICAgICAoXCJSZXF1aXJlZCBcIiArIGxvY2F0aW9uTmFtZSArIFwiIGBcIiArIHByb3BOYW1lICsgXCJgIHdhcyBub3Qgc3BlY2lmaWVkIGluIFwiKStcbiAgICAgICAgICAoXCJgXCIgKyBjb21wb25lbnROYW1lICsgXCJgLlwiKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbik7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNoYWluZWRDaGVja1R5cGUgPSBjaGVja1R5cGUuYmluZChudWxsLCBmYWxzZSk7XG4gIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gIHJldHVybiBjaGFpbmVkQ2hlY2tUeXBlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbikge1xuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIC8vIGBwcm9wVmFsdWVgIGJlaW5nIGluc3RhbmNlIG9mLCBzYXksIGRhdGUvcmVnZXhwLCBwYXNzIHRoZSAnb2JqZWN0J1xuICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG4gICAgICAvLyAnb2YgdHlwZSBgb2JqZWN0YCcuXG4gICAgICB2YXIgcHJlY2lzZVR5cGUgPSBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpO1xuXG4gICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgICAgICAoXCJJbnZhbGlkIFwiICsgbG9jYXRpb25OYW1lICsgXCIgYFwiICsgcHJvcE5hbWUgKyBcImAgb2YgdHlwZSBgXCIgKyBwcmVjaXNlVHlwZSArIFwiYCBcIikgK1xuICAgICAgICAoXCJzdXBwbGllZCB0byBgXCIgKyBjb21wb25lbnROYW1lICsgXCJgLCBleHBlY3RlZCBgXCIgKyBleHBlY3RlZFR5cGUgKyBcImAuXCIpXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpIHtcbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnMoKSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uKSB7XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgICAgICAoXCJJbnZhbGlkIFwiICsgbG9jYXRpb25OYW1lICsgXCIgYFwiICsgcHJvcE5hbWUgKyBcImAgb2YgdHlwZSBcIikgK1xuICAgICAgICAoXCJgXCIgKyBwcm9wVHlwZSArIFwiYCBzdXBwbGllZCB0byBgXCIgKyBjb21wb25lbnROYW1lICsgXCJgLCBleHBlY3RlZCBhbiBhcnJheS5cIilcbiAgICAgICk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uKTtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50VHlwZUNoZWNrZXIoKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24pIHtcbiAgICBpZiAoIVJlYWN0RGVzY3JpcHRvci5pc1ZhbGlkRGVzY3JpcHRvcihwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICAgICAgKFwiSW52YWxpZCBcIiArIGxvY2F0aW9uTmFtZSArIFwiIGBcIiArIHByb3BOYW1lICsgXCJgIHN1cHBsaWVkIHRvIFwiKSArXG4gICAgICAgIChcImBcIiArIGNvbXBvbmVudE5hbWUgKyBcImAsIGV4cGVjdGVkIGEgUmVhY3QgY29tcG9uZW50LlwiKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcihleHBlY3RlZENsYXNzKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24pIHtcbiAgICBpZiAoIShwcm9wc1twcm9wTmFtZV0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIHZhciBleHBlY3RlZENsYXNzTmFtZSA9IGV4cGVjdGVkQ2xhc3MubmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgICAgICAoXCJJbnZhbGlkIFwiICsgbG9jYXRpb25OYW1lICsgXCIgYFwiICsgcHJvcE5hbWUgKyBcImAgc3VwcGxpZWQgdG8gXCIpICtcbiAgICAgICAgKFwiYFwiICsgY29tcG9uZW50TmFtZSArIFwiYCwgZXhwZWN0ZWQgaW5zdGFuY2Ugb2YgYFwiICsgZXhwZWN0ZWRDbGFzc05hbWUgKyBcImAuXCIpXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIoZXhwZWN0ZWRWYWx1ZXMpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbikge1xuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gZXhwZWN0ZWRWYWx1ZXNbaV0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgdmFyIHZhbHVlc1N0cmluZyA9IEpTT04uc3RyaW5naWZ5KGV4cGVjdGVkVmFsdWVzKTtcbiAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgICAgKFwiSW52YWxpZCBcIiArIGxvY2F0aW9uTmFtZSArIFwiIGBcIiArIHByb3BOYW1lICsgXCJgIG9mIHZhbHVlIGBcIiArIHByb3BWYWx1ZSArIFwiYCBcIikgK1xuICAgICAgKFwic3VwcGxpZWQgdG8gYFwiICsgY29tcG9uZW50TmFtZSArIFwiYCwgZXhwZWN0ZWQgb25lIG9mIFwiICsgdmFsdWVzU3RyaW5nICsgXCIuXCIpXG4gICAgKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24pIHtcbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAgICAgIChcIkludmFsaWQgXCIgKyBsb2NhdGlvbk5hbWUgKyBcIiBgXCIgKyBwcm9wTmFtZSArIFwiYCBvZiB0eXBlIFwiKSArXG4gICAgICAgIChcImBcIiArIHByb3BUeXBlICsgXCJgIHN1cHBsaWVkIHRvIGBcIiArIGNvbXBvbmVudE5hbWUgKyBcImAsIGV4cGVjdGVkIGFuIG9iamVjdC5cIilcbiAgICAgICk7XG4gICAgfVxuICAgIGZvciAodmFyIGtleSBpbiBwcm9wVmFsdWUpIHtcbiAgICAgIGlmIChwcm9wVmFsdWUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24pO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVVbmlvblR5cGVDaGVja2VyKGFycmF5T2ZUeXBlQ2hlY2tlcnMpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgaWYgKGNoZWNrZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbikgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgICAgKFwiSW52YWxpZCBcIiArIGxvY2F0aW9uTmFtZSArIFwiIGBcIiArIHByb3BOYW1lICsgXCJgIHN1cHBsaWVkIHRvIFwiKSArXG4gICAgICAoXCJgXCIgKyBjb21wb25lbnROYW1lICsgXCJgLlwiKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUmVuZGVyYWJsZVR5cGVDaGVja2VyKCkge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uKSB7XG4gICAgaWYgKCFpc1JlbmRlcmFibGUocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAgICAgIChcIkludmFsaWQgXCIgKyBsb2NhdGlvbk5hbWUgKyBcIiBgXCIgKyBwcm9wTmFtZSArIFwiYCBzdXBwbGllZCB0byBcIikgK1xuICAgICAgICAoXCJgXCIgKyBjb21wb25lbnROYW1lICsgXCJgLCBleHBlY3RlZCBhIHJlbmRlcmFibGUgcHJvcC5cIilcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uKSB7XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgICAgICAoXCJJbnZhbGlkIFwiICsgbG9jYXRpb25OYW1lICsgXCIgYFwiICsgcHJvcE5hbWUgKyBcImAgb2YgdHlwZSBgXCIgKyBwcm9wVHlwZSArIFwiYCBcIikgK1xuICAgICAgICAoXCJzdXBwbGllZCB0byBgXCIgKyBjb21wb25lbnROYW1lICsgXCJgLCBleHBlY3RlZCBgb2JqZWN0YC5cIilcbiAgICAgICk7XG4gICAgfVxuICAgIGZvciAodmFyIGtleSBpbiBzaGFwZVR5cGVzKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uKTtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSwgJ2V4cGVjdGVkIGBvYmplY3RgJyk7XG59XG5cbmZ1bmN0aW9uIGlzUmVuZGVyYWJsZShwcm9wVmFsdWUpIHtcbiAgc3dpdGNoKHR5cGVvZiBwcm9wVmFsdWUpIHtcbiAgICAvLyBUT0RPOiB0aGlzIHdhcyBwcm9iYWJseSB3cml0dGVuIHdpdGggdGhlIGFzc3VtcHRpb24gdGhhdCB3ZSdyZSBub3RcbiAgICAvLyByZXR1cm5pbmcgYHRoaXMucHJvcHMuY29tcG9uZW50YCBkaXJlY3RseSBmcm9tIGByZW5kZXJgLiBUaGlzIGlzXG4gICAgLy8gY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQgYnV0IHdlIHNob3VsZCwgdG8gbWFrZSBpdCBjb25zaXN0ZW50LlxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuICFwcm9wVmFsdWU7XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHByb3BWYWx1ZS5ldmVyeShpc1JlbmRlcmFibGUpO1xuICAgICAgfVxuICAgICAgaWYgKFJlYWN0RGVzY3JpcHRvci5pc1ZhbGlkRGVzY3JpcHRvcihwcm9wVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgayBpbiBwcm9wVmFsdWUpIHtcbiAgICAgICAgaWYgKCFpc1JlbmRlcmFibGUocHJvcFZhbHVlW2tdKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vLyBFcXVpdmFsZW50IG9mIGB0eXBlb2ZgIGJ1dCB3aXRoIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGFycmF5IGFuZCByZWdleHAuXG5mdW5jdGlvbiBnZXRQcm9wVHlwZShwcm9wVmFsdWUpIHtcbiAgdmFyIHByb3BUeXBlID0gdHlwZW9mIHByb3BWYWx1ZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgIHJldHVybiAnYXJyYXknO1xuICB9XG4gIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAvLyBPbGQgd2Via2l0cyAoYXQgbGVhc3QgdW50aWwgQW5kcm9pZCA0LjApIHJldHVybiAnZnVuY3Rpb24nIHJhdGhlciB0aGFuXG4gICAgLy8gJ29iamVjdCcgZm9yIHR5cGVvZiBhIFJlZ0V4cC4gV2UnbGwgbm9ybWFsaXplIHRoaXMgaGVyZSBzbyB0aGF0IC9ibGEvXG4gICAgLy8gcGFzc2VzIFByb3BUeXBlcy5vYmplY3QuXG4gICAgcmV0dXJuICdvYmplY3QnO1xuICB9XG4gIHJldHVybiBwcm9wVHlwZTtcbn1cblxuLy8gVGhpcyBoYW5kbGVzIG1vcmUgdHlwZXMgdGhhbiBgZ2V0UHJvcFR5cGVgLiBPbmx5IHVzZWQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuLy8gU2VlIGBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcmAuXG5mdW5jdGlvbiBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpIHtcbiAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgaWYgKHByb3BUeXBlID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICByZXR1cm4gJ2RhdGUnO1xuICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICByZXR1cm4gJ3JlZ2V4cCc7XG4gICAgfVxuICB9XG4gIHJldHVybiBwcm9wVHlwZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlcztcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFB1dExpc3RlbmVyUXVldWVcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZShcIi4vUG9vbGVkQ2xhc3NcIik7XG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcIi4vUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyXCIpO1xuXG52YXIgbWl4SW50byA9IHJlcXVpcmUoXCIuL21peEludG9cIik7XG5cbmZ1bmN0aW9uIFJlYWN0UHV0TGlzdGVuZXJRdWV1ZSgpIHtcbiAgdGhpcy5saXN0ZW5lcnNUb1B1dCA9IFtdO1xufVxuXG5taXhJbnRvKFJlYWN0UHV0TGlzdGVuZXJRdWV1ZSwge1xuICBlbnF1ZXVlUHV0TGlzdGVuZXI6IGZ1bmN0aW9uKHJvb3ROb2RlSUQsIHByb3BLZXksIHByb3BWYWx1ZSkge1xuICAgIHRoaXMubGlzdGVuZXJzVG9QdXQucHVzaCh7XG4gICAgICByb290Tm9kZUlEOiByb290Tm9kZUlELFxuICAgICAgcHJvcEtleTogcHJvcEtleSxcbiAgICAgIHByb3BWYWx1ZTogcHJvcFZhbHVlXG4gICAgfSk7XG4gIH0sXG5cbiAgcHV0TGlzdGVuZXJzOiBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGlzdGVuZXJzVG9QdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBsaXN0ZW5lclRvUHV0ID0gdGhpcy5saXN0ZW5lcnNUb1B1dFtpXTtcbiAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5wdXRMaXN0ZW5lcihcbiAgICAgICAgbGlzdGVuZXJUb1B1dC5yb290Tm9kZUlELFxuICAgICAgICBsaXN0ZW5lclRvUHV0LnByb3BLZXksXG4gICAgICAgIGxpc3RlbmVyVG9QdXQucHJvcFZhbHVlXG4gICAgICApO1xuICAgIH1cbiAgfSxcblxuICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5saXN0ZW5lcnNUb1B1dC5sZW5ndGggPSAwO1xuICB9LFxuXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVzZXQoKTtcbiAgfVxufSk7XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhSZWFjdFB1dExpc3RlbmVyUXVldWUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHV0TGlzdGVuZXJRdWV1ZTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgQ2FsbGJhY2tRdWV1ZSA9IHJlcXVpcmUoXCIuL0NhbGxiYWNrUXVldWVcIik7XG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKFwiLi9Qb29sZWRDbGFzc1wiKTtcbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSByZXF1aXJlKFwiLi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJcIik7XG52YXIgUmVhY3RJbnB1dFNlbGVjdGlvbiA9IHJlcXVpcmUoXCIuL1JlYWN0SW5wdXRTZWxlY3Rpb25cIik7XG52YXIgUmVhY3RQdXRMaXN0ZW5lclF1ZXVlID0gcmVxdWlyZShcIi4vUmVhY3RQdXRMaXN0ZW5lclF1ZXVlXCIpO1xudmFyIFRyYW5zYWN0aW9uID0gcmVxdWlyZShcIi4vVHJhbnNhY3Rpb25cIik7XG5cbnZhciBtaXhJbnRvID0gcmVxdWlyZShcIi4vbWl4SW50b1wiKTtcblxuLyoqXG4gKiBFbnN1cmVzIHRoYXQsIHdoZW4gcG9zc2libGUsIHRoZSBzZWxlY3Rpb24gcmFuZ2UgKGN1cnJlbnRseSBzZWxlY3RlZCB0ZXh0XG4gKiBpbnB1dCkgaXMgbm90IGRpc3R1cmJlZCBieSBwZXJmb3JtaW5nIHRoZSB0cmFuc2FjdGlvbi5cbiAqL1xudmFyIFNFTEVDVElPTl9SRVNUT1JBVElPTiA9IHtcbiAgLyoqXG4gICAqIEByZXR1cm4ge1NlbGVjdGlvbn0gU2VsZWN0aW9uIGluZm9ybWF0aW9uLlxuICAgKi9cbiAgaW5pdGlhbGl6ZTogUmVhY3RJbnB1dFNlbGVjdGlvbi5nZXRTZWxlY3Rpb25JbmZvcm1hdGlvbixcbiAgLyoqXG4gICAqIEBwYXJhbSB7U2VsZWN0aW9ufSBzZWwgU2VsZWN0aW9uIGluZm9ybWF0aW9uIHJldHVybmVkIGZyb20gYGluaXRpYWxpemVgLlxuICAgKi9cbiAgY2xvc2U6IFJlYWN0SW5wdXRTZWxlY3Rpb24ucmVzdG9yZVNlbGVjdGlvblxufTtcblxuLyoqXG4gKiBTdXBwcmVzc2VzIGV2ZW50cyAoYmx1ci9mb2N1cykgdGhhdCBjb3VsZCBiZSBpbmFkdmVydGVudGx5IGRpc3BhdGNoZWQgZHVlIHRvXG4gKiBoaWdoIGxldmVsIERPTSBtYW5pcHVsYXRpb25zIChsaWtlIHRlbXBvcmFyaWx5IHJlbW92aW5nIGEgdGV4dCBpbnB1dCBmcm9tIHRoZVxuICogRE9NKS5cbiAqL1xudmFyIEVWRU5UX1NVUFBSRVNTSU9OID0ge1xuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIGVuYWJsZWQgc3RhdHVzIG9mIGBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJgIGJlZm9yZVxuICAgKiB0aGUgcmVjb25jaWxpYXRpb24uXG4gICAqL1xuICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY3VycmVudGx5RW5hYmxlZCA9IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5pc0VuYWJsZWQoKTtcbiAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuc2V0RW5hYmxlZChmYWxzZSk7XG4gICAgcmV0dXJuIGN1cnJlbnRseUVuYWJsZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcHJldmlvdXNseUVuYWJsZWQgRW5hYmxlZCBzdGF0dXMgb2ZcbiAgICogICBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBiZWZvcmUgdGhlIHJlY29uY2lsaWF0aW9uIG9jY3VyZWQuIGBjbG9zZWBcbiAgICogICByZXN0b3JlcyB0aGUgcHJldmlvdXMgdmFsdWUuXG4gICAqL1xuICBjbG9zZTogZnVuY3Rpb24ocHJldmlvdXNseUVuYWJsZWQpIHtcbiAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuc2V0RW5hYmxlZChwcmV2aW91c2x5RW5hYmxlZCk7XG4gIH1cbn07XG5cbi8qKlxuICogUHJvdmlkZXMgYSBxdWV1ZSBmb3IgY29sbGVjdGluZyBgY29tcG9uZW50RGlkTW91bnRgIGFuZFxuICogYGNvbXBvbmVudERpZFVwZGF0ZWAgY2FsbGJhY2tzIGR1cmluZyB0aGUgdGhlIHRyYW5zYWN0aW9uLlxuICovXG52YXIgT05fRE9NX1JFQURZX1FVRVVFSU5HID0ge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGludGVybmFsIGBvbkRPTVJlYWR5YCBxdWV1ZS5cbiAgICovXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVhY3RNb3VudFJlYWR5LnJlc2V0KCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFmdGVyIERPTSBpcyBmbHVzaGVkLCBpbnZva2UgYWxsIHJlZ2lzdGVyZWQgYG9uRE9NUmVhZHlgIGNhbGxiYWNrcy5cbiAgICovXG4gIGNsb3NlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlYWN0TW91bnRSZWFkeS5ub3RpZnlBbGwoKTtcbiAgfVxufTtcblxudmFyIFBVVF9MSVNURU5FUl9RVUVVRUlORyA9IHtcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5wdXRMaXN0ZW5lclF1ZXVlLnJlc2V0KCk7XG4gIH0sXG5cbiAgY2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucHV0TGlzdGVuZXJRdWV1ZS5wdXRMaXN0ZW5lcnMoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBFeGVjdXRlZCB3aXRoaW4gdGhlIHNjb3BlIG9mIHRoZSBgVHJhbnNhY3Rpb25gIGluc3RhbmNlLiBDb25zaWRlciB0aGVzZSBhc1xuICogYmVpbmcgbWVtYmVyIG1ldGhvZHMsIGJ1dCB3aXRoIGFuIGltcGxpZWQgb3JkZXJpbmcgd2hpbGUgYmVpbmcgaXNvbGF0ZWQgZnJvbVxuICogZWFjaCBvdGhlci5cbiAqL1xudmFyIFRSQU5TQUNUSU9OX1dSQVBQRVJTID0gW1xuICBQVVRfTElTVEVORVJfUVVFVUVJTkcsXG4gIFNFTEVDVElPTl9SRVNUT1JBVElPTixcbiAgRVZFTlRfU1VQUFJFU1NJT04sXG4gIE9OX0RPTV9SRUFEWV9RVUVVRUlOR1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHk6XG4gKiAtIFRoZSBvcmRlciB0aGF0IHRoZXNlIGFyZSBsaXN0ZWQgaW4gdGhlIHRyYW5zYWN0aW9uIGlzIGNyaXRpY2FsOlxuICogLSBTdXBwcmVzc2VzIGV2ZW50cy5cbiAqIC0gUmVzdG9yZXMgc2VsZWN0aW9uIHJhbmdlLlxuICpcbiAqIEZ1dHVyZTpcbiAqIC0gUmVzdG9yZSBkb2N1bWVudC9vdmVyZmxvdyBzY3JvbGwgcG9zaXRpb25zIHRoYXQgd2VyZSB1bmludGVudGlvbmFsbHlcbiAqICAgbW9kaWZpZWQgdmlhIERPTSBpbnNlcnRpb25zIGFib3ZlIHRoZSB0b3Agdmlld3BvcnQgYm91bmRhcnkuXG4gKiAtIEltcGxlbWVudC9pbnRlZ3JhdGUgd2l0aCBjdXN0b21pemVkIGNvbnN0cmFpbnQgYmFzZWQgbGF5b3V0IHN5c3RlbSBhbmQga2VlcFxuICogICB0cmFjayBvZiB3aGljaCBkaW1lbnNpb25zIG11c3QgYmUgcmVtZWFzdXJlZC5cbiAqXG4gKiBAY2xhc3MgUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvblxuICovXG5mdW5jdGlvbiBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uKCkge1xuICB0aGlzLnJlaW5pdGlhbGl6ZVRyYW5zYWN0aW9uKCk7XG4gIC8vIE9ubHkgc2VydmVyLXNpZGUgcmVuZGVyaW5nIHJlYWxseSBuZWVkcyB0aGlzIG9wdGlvbiAoc2VlXG4gIC8vIGBSZWFjdFNlcnZlclJlbmRlcmluZ2ApLCBidXQgc2VydmVyLXNpZGUgdXNlc1xuICAvLyBgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbmAgaW5zdGVhZC4gVGhpcyBvcHRpb24gaXMgaGVyZSBzbyB0aGF0IGl0J3NcbiAgLy8gYWNjZXNzaWJsZSBhbmQgZGVmYXVsdHMgdG8gZmFsc2Ugd2hlbiBgUmVhY3RET01Db21wb25lbnRgIGFuZFxuICAvLyBgUmVhY3RUZXh0Q29tcG9uZW50YCBjaGVja3MgaXQgaW4gYG1vdW50Q29tcG9uZW50YC5gXG4gIHRoaXMucmVuZGVyVG9TdGF0aWNNYXJrdXAgPSBmYWxzZTtcbiAgdGhpcy5yZWFjdE1vdW50UmVhZHkgPSBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZChudWxsKTtcbiAgdGhpcy5wdXRMaXN0ZW5lclF1ZXVlID0gUmVhY3RQdXRMaXN0ZW5lclF1ZXVlLmdldFBvb2xlZCgpO1xufVxuXG52YXIgTWl4aW4gPSB7XG4gIC8qKlxuICAgKiBAc2VlIFRyYW5zYWN0aW9uXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAZmluYWxcbiAgICogQHJldHVybiB7YXJyYXk8b2JqZWN0Pn0gTGlzdCBvZiBvcGVyYXRpb24gd3JhcCBwcm9jZWVkdXJlcy5cbiAgICogICBUT0RPOiBjb252ZXJ0IHRvIGFycmF5PFRyYW5zYWN0aW9uV3JhcHBlcj5cbiAgICovXG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBUUkFOU0FDVElPTl9XUkFQUEVSUztcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgcXVldWUgdG8gY29sbGVjdCBgb25ET01SZWFkeWAgY2FsbGJhY2tzIHdpdGguXG4gICAqL1xuICBnZXRSZWFjdE1vdW50UmVhZHk6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJlYWN0TW91bnRSZWFkeTtcbiAgfSxcblxuICBnZXRQdXRMaXN0ZW5lclF1ZXVlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wdXRMaXN0ZW5lclF1ZXVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciB0aGlzLCBhbmQgd2lsbCBpbnZva2UgdGhpcyBiZWZvcmUgYWxsb3dpbmcgdGhpc1xuICAgKiBpbnN0YW5jZSB0byBiZSByZXN1c2VkLlxuICAgKi9cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24oKSB7XG4gICAgQ2FsbGJhY2tRdWV1ZS5yZWxlYXNlKHRoaXMucmVhY3RNb3VudFJlYWR5KTtcbiAgICB0aGlzLnJlYWN0TW91bnRSZWFkeSA9IG51bGw7XG5cbiAgICBSZWFjdFB1dExpc3RlbmVyUXVldWUucmVsZWFzZSh0aGlzLnB1dExpc3RlbmVyUXVldWUpO1xuICAgIHRoaXMucHV0TGlzdGVuZXJRdWV1ZSA9IG51bGw7XG4gIH1cbn07XG5cblxubWl4SW50byhSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLCBUcmFuc2FjdGlvbi5NaXhpbik7XG5taXhJbnRvKFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24sIE1peGluKTtcblxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb247XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RSb290SW5kZXhcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBSZWFjdFJvb3RJbmRleEluamVjdGlvbiA9IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IF9jcmVhdGVSZWFjdFJvb3RJbmRleFxuICAgKi9cbiAgaW5qZWN0Q3JlYXRlUmVhY3RSb290SW5kZXg6IGZ1bmN0aW9uKF9jcmVhdGVSZWFjdFJvb3RJbmRleCkge1xuICAgIFJlYWN0Um9vdEluZGV4LmNyZWF0ZVJlYWN0Um9vdEluZGV4ID0gX2NyZWF0ZVJlYWN0Um9vdEluZGV4O1xuICB9XG59O1xuXG52YXIgUmVhY3RSb290SW5kZXggPSB7XG4gIGNyZWF0ZVJlYWN0Um9vdEluZGV4OiBudWxsLFxuICBpbmplY3Rpb246IFJlYWN0Um9vdEluZGV4SW5qZWN0aW9uXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Um9vdEluZGV4O1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBSZWFjdERlc2NyaXB0b3IgPSByZXF1aXJlKFwiLi9SZWFjdERlc2NyaXB0b3JcIik7XG52YXIgUmVhY3RJbnN0YW5jZUhhbmRsZXMgPSByZXF1aXJlKFwiLi9SZWFjdEluc3RhbmNlSGFuZGxlc1wiKTtcbnZhciBSZWFjdE1hcmt1cENoZWNrc3VtID0gcmVxdWlyZShcIi4vUmVhY3RNYXJrdXBDaGVja3N1bVwiKTtcbnZhciBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uID1cbiAgcmVxdWlyZShcIi4vUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvblwiKTtcblxudmFyIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKFwiLi9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50XCIpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcblxuLyoqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnRcbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIEhUTUwgbWFya3VwXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckNvbXBvbmVudFRvU3RyaW5nKGNvbXBvbmVudCkge1xuICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgIFJlYWN0RGVzY3JpcHRvci5pc1ZhbGlkRGVzY3JpcHRvcihjb21wb25lbnQpLFxuICAgICdyZW5kZXJDb21wb25lbnRUb1N0cmluZygpOiBZb3UgbXVzdCBwYXNzIGEgdmFsaWQgUmVhY3RDb21wb25lbnQuJ1xuICApIDogaW52YXJpYW50KFJlYWN0RGVzY3JpcHRvci5pc1ZhbGlkRGVzY3JpcHRvcihjb21wb25lbnQpKSk7XG5cbiAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAhKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJyksXG4gICAgJ3JlbmRlckNvbXBvbmVudFRvU3RyaW5nKCk6IFRoaXMgZnVuY3Rpb24gYmVjYW1lIHN5bmNocm9ub3VzIGFuZCBub3cgJyArXG4gICAgJ3JldHVybnMgdGhlIGdlbmVyYXRlZCBtYXJrdXAuIFBsZWFzZSByZW1vdmUgdGhlIHNlY29uZCBwYXJhbWV0ZXIuJ1xuICApIDogaW52YXJpYW50KCEoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSkpO1xuXG4gIHZhciB0cmFuc2FjdGlvbjtcbiAgdHJ5IHtcbiAgICB2YXIgaWQgPSBSZWFjdEluc3RhbmNlSGFuZGxlcy5jcmVhdGVSZWFjdFJvb3RJRCgpO1xuICAgIHRyYW5zYWN0aW9uID0gUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbi5nZXRQb29sZWQoZmFsc2UpO1xuXG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uLnBlcmZvcm0oZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KGNvbXBvbmVudCk7XG4gICAgICB2YXIgbWFya3VwID0gY29tcG9uZW50SW5zdGFuY2UubW91bnRDb21wb25lbnQoaWQsIHRyYW5zYWN0aW9uLCAwKTtcbiAgICAgIHJldHVybiBSZWFjdE1hcmt1cENoZWNrc3VtLmFkZENoZWNrc3VtVG9NYXJrdXAobWFya3VwKTtcbiAgICB9LCBudWxsKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uLnJlbGVhc2UodHJhbnNhY3Rpb24pO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY29tcG9uZW50XG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBIVE1MIG1hcmt1cCwgd2l0aG91dCB0aGUgZXh0cmEgUmVhY3QgSUQgYW5kIGNoZWNrc3VtXG4qIChmb3IgZ2VuZXJhdGluZyBzdGF0aWMgcGFnZXMpXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckNvbXBvbmVudFRvU3RhdGljTWFya3VwKGNvbXBvbmVudCkge1xuICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgIFJlYWN0RGVzY3JpcHRvci5pc1ZhbGlkRGVzY3JpcHRvcihjb21wb25lbnQpLFxuICAgICdyZW5kZXJDb21wb25lbnRUb1N0YXRpY01hcmt1cCgpOiBZb3UgbXVzdCBwYXNzIGEgdmFsaWQgUmVhY3RDb21wb25lbnQuJ1xuICApIDogaW52YXJpYW50KFJlYWN0RGVzY3JpcHRvci5pc1ZhbGlkRGVzY3JpcHRvcihjb21wb25lbnQpKSk7XG5cbiAgdmFyIHRyYW5zYWN0aW9uO1xuICB0cnkge1xuICAgIHZhciBpZCA9IFJlYWN0SW5zdGFuY2VIYW5kbGVzLmNyZWF0ZVJlYWN0Um9vdElEKCk7XG4gICAgdHJhbnNhY3Rpb24gPSBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uLmdldFBvb2xlZCh0cnVlKTtcblxuICAgIHJldHVybiB0cmFuc2FjdGlvbi5wZXJmb3JtKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChjb21wb25lbnQpO1xuICAgICAgcmV0dXJuIGNvbXBvbmVudEluc3RhbmNlLm1vdW50Q29tcG9uZW50KGlkLCB0cmFuc2FjdGlvbiwgMCk7XG4gICAgfSwgbnVsbCk7XG4gIH0gZmluYWxseSB7XG4gICAgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbi5yZWxlYXNlKHRyYW5zYWN0aW9uKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcmVuZGVyQ29tcG9uZW50VG9TdHJpbmc6IHJlbmRlckNvbXBvbmVudFRvU3RyaW5nLFxuICByZW5kZXJDb21wb25lbnRUb1N0YXRpY01hcmt1cDogcmVuZGVyQ29tcG9uZW50VG9TdGF0aWNNYXJrdXBcbn07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvblxuICogQHR5cGVjaGVja3NcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZShcIi4vUG9vbGVkQ2xhc3NcIik7XG52YXIgQ2FsbGJhY2tRdWV1ZSA9IHJlcXVpcmUoXCIuL0NhbGxiYWNrUXVldWVcIik7XG52YXIgUmVhY3RQdXRMaXN0ZW5lclF1ZXVlID0gcmVxdWlyZShcIi4vUmVhY3RQdXRMaXN0ZW5lclF1ZXVlXCIpO1xudmFyIFRyYW5zYWN0aW9uID0gcmVxdWlyZShcIi4vVHJhbnNhY3Rpb25cIik7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZShcIi4vZW1wdHlGdW5jdGlvblwiKTtcbnZhciBtaXhJbnRvID0gcmVxdWlyZShcIi4vbWl4SW50b1wiKTtcblxuLyoqXG4gKiBQcm92aWRlcyBhIGBDYWxsYmFja1F1ZXVlYCBxdWV1ZSBmb3IgY29sbGVjdGluZyBgb25ET01SZWFkeWAgY2FsbGJhY2tzXG4gKiBkdXJpbmcgdGhlIHBlcmZvcm1pbmcgb2YgdGhlIHRyYW5zYWN0aW9uLlxuICovXG52YXIgT05fRE9NX1JFQURZX1FVRVVFSU5HID0ge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGludGVybmFsIGBvbkRPTVJlYWR5YCBxdWV1ZS5cbiAgICovXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVhY3RNb3VudFJlYWR5LnJlc2V0KCk7XG4gIH0sXG5cbiAgY2xvc2U6IGVtcHR5RnVuY3Rpb25cbn07XG5cbnZhciBQVVRfTElTVEVORVJfUVVFVUVJTkcgPSB7XG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucHV0TGlzdGVuZXJRdWV1ZS5yZXNldCgpO1xuICB9LFxuXG4gIGNsb3NlOiBlbXB0eUZ1bmN0aW9uXG59O1xuXG4vKipcbiAqIEV4ZWN1dGVkIHdpdGhpbiB0aGUgc2NvcGUgb2YgdGhlIGBUcmFuc2FjdGlvbmAgaW5zdGFuY2UuIENvbnNpZGVyIHRoZXNlIGFzXG4gKiBiZWluZyBtZW1iZXIgbWV0aG9kcywgYnV0IHdpdGggYW4gaW1wbGllZCBvcmRlcmluZyB3aGlsZSBiZWluZyBpc29sYXRlZCBmcm9tXG4gKiBlYWNoIG90aGVyLlxuICovXG52YXIgVFJBTlNBQ1RJT05fV1JBUFBFUlMgPSBbXG4gIFBVVF9MSVNURU5FUl9RVUVVRUlORyxcbiAgT05fRE9NX1JFQURZX1FVRVVFSU5HXG5dO1xuXG4vKipcbiAqIEBjbGFzcyBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHJlbmRlclRvU3RhdGljTWFya3VwXG4gKi9cbmZ1bmN0aW9uIFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24ocmVuZGVyVG9TdGF0aWNNYXJrdXApIHtcbiAgdGhpcy5yZWluaXRpYWxpemVUcmFuc2FjdGlvbigpO1xuICB0aGlzLnJlbmRlclRvU3RhdGljTWFya3VwID0gcmVuZGVyVG9TdGF0aWNNYXJrdXA7XG4gIHRoaXMucmVhY3RNb3VudFJlYWR5ID0gQ2FsbGJhY2tRdWV1ZS5nZXRQb29sZWQobnVsbCk7XG4gIHRoaXMucHV0TGlzdGVuZXJRdWV1ZSA9IFJlYWN0UHV0TGlzdGVuZXJRdWV1ZS5nZXRQb29sZWQoKTtcbn1cblxudmFyIE1peGluID0ge1xuICAvKipcbiAgICogQHNlZSBUcmFuc2FjdGlvblxuICAgKiBAYWJzdHJhY3RcbiAgICogQGZpbmFsXG4gICAqIEByZXR1cm4ge2FycmF5fSBFbXB0eSBsaXN0IG9mIG9wZXJhdGlvbiB3cmFwIHByb2NlZWR1cmVzLlxuICAgKi9cbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFRSQU5TQUNUSU9OX1dSQVBQRVJTO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBxdWV1ZSB0byBjb2xsZWN0IGBvbkRPTVJlYWR5YCBjYWxsYmFja3Mgd2l0aC5cbiAgICovXG4gIGdldFJlYWN0TW91bnRSZWFkeTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhY3RNb3VudFJlYWR5O1xuICB9LFxuXG4gIGdldFB1dExpc3RlbmVyUXVldWU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnB1dExpc3RlbmVyUXVldWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGBQb29sZWRDbGFzc2AgbG9va3MgZm9yIHRoaXMsIGFuZCB3aWxsIGludm9rZSB0aGlzIGJlZm9yZSBhbGxvd2luZyB0aGlzXG4gICAqIGluc3RhbmNlIHRvIGJlIHJlc3VzZWQuXG4gICAqL1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbigpIHtcbiAgICBDYWxsYmFja1F1ZXVlLnJlbGVhc2UodGhpcy5yZWFjdE1vdW50UmVhZHkpO1xuICAgIHRoaXMucmVhY3RNb3VudFJlYWR5ID0gbnVsbDtcblxuICAgIFJlYWN0UHV0TGlzdGVuZXJRdWV1ZS5yZWxlYXNlKHRoaXMucHV0TGlzdGVuZXJRdWV1ZSk7XG4gICAgdGhpcy5wdXRMaXN0ZW5lclF1ZXVlID0gbnVsbDtcbiAgfVxufTtcblxuXG5taXhJbnRvKFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24sIFRyYW5zYWN0aW9uLk1peGluKTtcbm1peEludG8oUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbiwgTWl4aW4pO1xuXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbik7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbjtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFN0YXRlU2V0dGVyc1xuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgUmVhY3RTdGF0ZVNldHRlcnMgPSB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBjYWxscyB0aGUgcHJvdmlkZWQgZnVuY3Rpb24sIGFuZCB1c2VzIHRoZSByZXN1bHRcbiAgICogb2YgdGhhdCB0byBzZXQgdGhlIGNvbXBvbmVudCdzIHN0YXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50fSBjb21wb25lbnRcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuY1JldHVybmluZ1N0YXRlIFJldHVybmVkIGNhbGxiYWNrIHVzZXMgdGhpcyB0b1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0ZXJtaW5lIGhvdyB0byB1cGRhdGUgc3RhdGUuXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9ufSBjYWxsYmFjayB0aGF0IHdoZW4gaW52b2tlZCB1c2VzIGZ1bmNSZXR1cm5pbmdTdGF0ZSB0b1xuICAgKiAgICAgICAgICAgICAgICAgICAgZGV0ZXJtaW5lZCB0aGUgb2JqZWN0IGxpdGVyYWwgdG8gc2V0U3RhdGUuXG4gICAqL1xuICBjcmVhdGVTdGF0ZVNldHRlcjogZnVuY3Rpb24oY29tcG9uZW50LCBmdW5jUmV0dXJuaW5nU3RhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYSwgYiwgYywgZCwgZSwgZikge1xuICAgICAgdmFyIHBhcnRpYWxTdGF0ZSA9IGZ1bmNSZXR1cm5pbmdTdGF0ZS5jYWxsKGNvbXBvbmVudCwgYSwgYiwgYywgZCwgZSwgZik7XG4gICAgICBpZiAocGFydGlhbFN0YXRlKSB7XG4gICAgICAgIGNvbXBvbmVudC5zZXRTdGF0ZShwYXJ0aWFsU3RhdGUpO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzaW5nbGUtYXJndW1lbnQgY2FsbGJhY2sgdGhhdCBjYW4gYmUgdXNlZCB0byB1cGRhdGUgYSBzaW5nbGVcbiAgICoga2V5IGluIHRoZSBjb21wb25lbnQncyBzdGF0ZS5cbiAgICpcbiAgICogTm90ZTogdGhpcyBpcyBtZW1vaXplZCBmdW5jdGlvbiwgd2hpY2ggbWFrZXMgaXQgaW5leHBlbnNpdmUgdG8gY2FsbC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvc2l0ZUNvbXBvbmVudH0gY29tcG9uZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBpbiB0aGUgc3RhdGUgdGhhdCB5b3Ugc2hvdWxkIHVwZGF0ZS5cbiAgICogQHJldHVybiB7ZnVuY3Rpb259IGNhbGxiYWNrIG9mIDEgYXJndW1lbnQgd2hpY2ggY2FsbHMgc2V0U3RhdGUoKSB3aXRoXG4gICAqICAgICAgICAgICAgICAgICAgICB0aGUgcHJvdmlkZWQga2V5TmFtZSBhbmQgY2FsbGJhY2sgYXJndW1lbnQuXG4gICAqL1xuICBjcmVhdGVTdGF0ZUtleVNldHRlcjogZnVuY3Rpb24oY29tcG9uZW50LCBrZXkpIHtcbiAgICAvLyBNZW1vaXplIHRoZSBzZXR0ZXJzLlxuICAgIHZhciBjYWNoZSA9IGNvbXBvbmVudC5fX2tleVNldHRlcnMgfHwgKGNvbXBvbmVudC5fX2tleVNldHRlcnMgPSB7fSk7XG4gICAgcmV0dXJuIGNhY2hlW2tleV0gfHwgKGNhY2hlW2tleV0gPSBjcmVhdGVTdGF0ZUtleVNldHRlcihjb21wb25lbnQsIGtleSkpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVTdGF0ZUtleVNldHRlcihjb21wb25lbnQsIGtleSkge1xuICAvLyBQYXJ0aWFsIHN0YXRlIGlzIGFsbG9jYXRlZCBvdXRzaWRlIG9mIHRoZSBmdW5jdGlvbiBjbG9zdXJlIHNvIGl0IGNhbiBiZVxuICAvLyByZXVzZWQgd2l0aCBldmVyeSBjYWxsLCBhdm9pZGluZyBtZW1vcnkgYWxsb2NhdGlvbiB3aGVuIHRoaXMgZnVuY3Rpb25cbiAgLy8gaXMgY2FsbGVkLlxuICB2YXIgcGFydGlhbFN0YXRlID0ge307XG4gIHJldHVybiBmdW5jdGlvbiBzdGF0ZUtleVNldHRlcih2YWx1ZSkge1xuICAgIHBhcnRpYWxTdGF0ZVtrZXldID0gdmFsdWU7XG4gICAgY29tcG9uZW50LnNldFN0YXRlKHBhcnRpYWxTdGF0ZSk7XG4gIH07XG59XG5cblJlYWN0U3RhdGVTZXR0ZXJzLk1peGluID0ge1xuICAvKipcbiAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgY2FsbHMgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLCBhbmQgdXNlcyB0aGUgcmVzdWx0XG4gICAqIG9mIHRoYXQgdG8gc2V0IHRoZSBjb21wb25lbnQncyBzdGF0ZS5cbiAgICpcbiAgICogRm9yIGV4YW1wbGUsIHRoZXNlIHN0YXRlbWVudHMgYXJlIGVxdWl2YWxlbnQ6XG4gICAqXG4gICAqICAgdGhpcy5zZXRTdGF0ZSh7eDogMX0pO1xuICAgKiAgIHRoaXMuY3JlYXRlU3RhdGVTZXR0ZXIoZnVuY3Rpb24oeFZhbHVlKSB7XG4gICAqICAgICByZXR1cm4ge3g6IHhWYWx1ZX07XG4gICAqICAgfSkoMSk7XG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmNSZXR1cm5pbmdTdGF0ZSBSZXR1cm5lZCBjYWxsYmFjayB1c2VzIHRoaXMgdG9cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGVybWluZSBob3cgdG8gdXBkYXRlIHN0YXRlLlxuICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gY2FsbGJhY2sgdGhhdCB3aGVuIGludm9rZWQgdXNlcyBmdW5jUmV0dXJuaW5nU3RhdGUgdG9cbiAgICogICAgICAgICAgICAgICAgICAgIGRldGVybWluZWQgdGhlIG9iamVjdCBsaXRlcmFsIHRvIHNldFN0YXRlLlxuICAgKi9cbiAgY3JlYXRlU3RhdGVTZXR0ZXI6IGZ1bmN0aW9uKGZ1bmNSZXR1cm5pbmdTdGF0ZSkge1xuICAgIHJldHVybiBSZWFjdFN0YXRlU2V0dGVycy5jcmVhdGVTdGF0ZVNldHRlcih0aGlzLCBmdW5jUmV0dXJuaW5nU3RhdGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc2luZ2xlLWFyZ3VtZW50IGNhbGxiYWNrIHRoYXQgY2FuIGJlIHVzZWQgdG8gdXBkYXRlIGEgc2luZ2xlXG4gICAqIGtleSBpbiB0aGUgY29tcG9uZW50J3Mgc3RhdGUuXG4gICAqXG4gICAqIEZvciBleGFtcGxlLCB0aGVzZSBzdGF0ZW1lbnRzIGFyZSBlcXVpdmFsZW50OlxuICAgKlxuICAgKiAgIHRoaXMuc2V0U3RhdGUoe3g6IDF9KTtcbiAgICogICB0aGlzLmNyZWF0ZVN0YXRlS2V5U2V0dGVyKCd4JykoMSk7XG4gICAqXG4gICAqIE5vdGU6IHRoaXMgaXMgbWVtb2l6ZWQgZnVuY3Rpb24sIHdoaWNoIG1ha2VzIGl0IGluZXhwZW5zaXZlIHRvIGNhbGwuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBpbiB0aGUgc3RhdGUgdGhhdCB5b3Ugc2hvdWxkIHVwZGF0ZS5cbiAgICogQHJldHVybiB7ZnVuY3Rpb259IGNhbGxiYWNrIG9mIDEgYXJndW1lbnQgd2hpY2ggY2FsbHMgc2V0U3RhdGUoKSB3aXRoXG4gICAqICAgICAgICAgICAgICAgICAgICB0aGUgcHJvdmlkZWQga2V5TmFtZSBhbmQgY2FsbGJhY2sgYXJndW1lbnQuXG4gICAqL1xuICBjcmVhdGVTdGF0ZUtleVNldHRlcjogZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIFJlYWN0U3RhdGVTZXR0ZXJzLmNyZWF0ZVN0YXRlS2V5U2V0dGVyKHRoaXMsIGtleSk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RTdGF0ZVNldHRlcnM7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RUZXN0VXRpbHNcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZShcIi4vRXZlbnRDb25zdGFudHNcIik7XG52YXIgRXZlbnRQbHVnaW5IdWIgPSByZXF1aXJlKFwiLi9FdmVudFBsdWdpbkh1YlwiKTtcbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZShcIi4vRXZlbnRQcm9wYWdhdG9yc1wiKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoXCIuL1JlYWN0XCIpO1xudmFyIFJlYWN0RGVzY3JpcHRvciA9IHJlcXVpcmUoXCIuL1JlYWN0RGVzY3JpcHRvclwiKTtcbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoXCIuL1JlYWN0RE9NXCIpO1xudmFyIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCIuL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlclwiKTtcbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZShcIi4vUmVhY3RNb3VudFwiKTtcbnZhciBSZWFjdFRleHRDb21wb25lbnQgPSByZXF1aXJlKFwiLi9SZWFjdFRleHRDb21wb25lbnRcIik7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZShcIi4vUmVhY3RVcGRhdGVzXCIpO1xudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZShcIi4vU3ludGhldGljRXZlbnRcIik7XG5cbnZhciBtZXJnZUludG8gPSByZXF1aXJlKFwiLi9tZXJnZUludG9cIik7XG52YXIgY29weVByb3BlcnRpZXMgPSByZXF1aXJlKFwiLi9jb3B5UHJvcGVydGllc1wiKTtcblxudmFyIHRvcExldmVsVHlwZXMgPSBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuXG5mdW5jdGlvbiBFdmVudChzdWZmaXgpIHt9XG5cbi8qKlxuICogQGNsYXNzIFJlYWN0VGVzdFV0aWxzXG4gKi9cblxuLyoqXG4gKiBUb2RvOiBTdXBwb3J0IHRoZSBlbnRpcmUgRE9NLnNjcnkgcXVlcnkgc3ludGF4LiBGb3Igbm93LCB0aGVzZSBzaW1wbGVcbiAqIHV0aWxpdGllcyB3aWxsIHN1ZmZpY2UgZm9yIHRlc3RpbmcgcHVycG9zZXMuXG4gKiBAbGVuZHMgUmVhY3RUZXN0VXRpbHNcbiAqL1xudmFyIFJlYWN0VGVzdFV0aWxzID0ge1xuICByZW5kZXJJbnRvRG9jdW1lbnQ6IGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIC8vIE5vbmUgb2Ygb3VyIHRlc3RzIGFjdHVhbGx5IHJlcXVpcmUgYXR0YWNoaW5nIHRoZSBjb250YWluZXIgdG8gdGhlXG4gICAgLy8gRE9NLCBhbmQgZG9pbmcgc28gY3JlYXRlcyBhIG1lc3MgdGhhdCB3ZSByZWx5IG9uIHRlc3QgaXNvbGF0aW9uIHRvXG4gICAgLy8gY2xlYW4gdXAsIHNvIHdlJ3JlIGdvaW5nIHRvIHN0b3AgaG9ub3JpbmcgdGhlIG5hbWUgb2YgdGhpcyBtZXRob2RcbiAgICAvLyAoYW5kIHByb2JhYmx5IHJlbmFtZSBpdCBldmVudHVhbGx5KSBpZiBubyBwcm9ibGVtcyBhcmlzZS5cbiAgICAvLyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICByZXR1cm4gUmVhY3QucmVuZGVyQ29tcG9uZW50KGluc3RhbmNlLCBkaXYpO1xuICB9LFxuXG4gIGlzRGVzY3JpcHRvcjogZnVuY3Rpb24oZGVzY3JpcHRvcikge1xuICAgIHJldHVybiBSZWFjdERlc2NyaXB0b3IuaXNWYWxpZERlc2NyaXB0b3IoZGVzY3JpcHRvcik7XG4gIH0sXG5cbiAgaXNEZXNjcmlwdG9yT2ZUeXBlOiBmdW5jdGlvbihpbnN0LCBjb252ZW5pZW5jZUNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIFJlYWN0RGVzY3JpcHRvci5pc1ZhbGlkRGVzY3JpcHRvcihpbnN0KSAmJlxuICAgICAgaW5zdC50eXBlID09PSBjb252ZW5pZW5jZUNvbnN0cnVjdG9yLnR5cGVcbiAgICApO1xuICB9LFxuXG4gIGlzRE9NQ29tcG9uZW50OiBmdW5jdGlvbihpbnN0KSB7XG4gICAgcmV0dXJuICEhKGluc3QgJiYgaW5zdC5tb3VudENvbXBvbmVudCAmJiBpbnN0LnRhZ05hbWUpO1xuICB9LFxuXG4gIGlzRE9NQ29tcG9uZW50RGVzY3JpcHRvcjogZnVuY3Rpb24oaW5zdCkge1xuICAgIHJldHVybiAhIShpbnN0ICYmXG4gICAgICAgICAgICAgIFJlYWN0RGVzY3JpcHRvci5pc1ZhbGlkRGVzY3JpcHRvcihpbnN0KSAmJlxuICAgICAgICAgICAgICAhIWluc3QudGFnTmFtZSk7XG4gIH0sXG5cbiAgaXNDb21wb3NpdGVDb21wb25lbnQ6IGZ1bmN0aW9uKGluc3QpIHtcbiAgICByZXR1cm4gdHlwZW9mIGluc3QucmVuZGVyID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgIHR5cGVvZiBpbnN0LnNldFN0YXRlID09PSAnZnVuY3Rpb24nO1xuICB9LFxuXG4gIGlzQ29tcG9zaXRlQ29tcG9uZW50V2l0aFR5cGU6IGZ1bmN0aW9uKGluc3QsIHR5cGUpIHtcbiAgICByZXR1cm4gISEoUmVhY3RUZXN0VXRpbHMuaXNDb21wb3NpdGVDb21wb25lbnQoaW5zdCkgJiZcbiAgICAgICAgICAgICAoaW5zdC5jb25zdHJ1Y3RvciA9PT0gdHlwZS50eXBlKSk7XG4gIH0sXG5cbiAgaXNDb21wb3NpdGVDb21wb25lbnREZXNjcmlwdG9yOiBmdW5jdGlvbihpbnN0KSB7XG4gICAgaWYgKCFSZWFjdERlc2NyaXB0b3IuaXNWYWxpZERlc2NyaXB0b3IoaW5zdCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gV2UgY2hlY2sgdGhlIHByb3RvdHlwZSBvZiB0aGUgdHlwZSB0aGF0IHdpbGwgZ2V0IG1vdW50ZWQsIG5vdCB0aGVcbiAgICAvLyBpbnN0YW5jZSBpdHNlbGYuIFRoaXMgaXMgYSBmdXR1cmUgcHJvb2Ygd2F5IG9mIGR1Y2sgdHlwaW5nLlxuICAgIHZhciBwcm90b3R5cGUgPSBpbnN0LnR5cGUucHJvdG90eXBlO1xuICAgIHJldHVybiAoXG4gICAgICB0eXBlb2YgcHJvdG90eXBlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgdHlwZW9mIHByb3RvdHlwZS5zZXRTdGF0ZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICk7XG4gIH0sXG5cbiAgaXNDb21wb3NpdGVDb21wb25lbnREZXNjcmlwdG9yV2l0aFR5cGU6IGZ1bmN0aW9uKGluc3QsIHR5cGUpIHtcbiAgICByZXR1cm4gISEoUmVhY3RUZXN0VXRpbHMuaXNDb21wb3NpdGVDb21wb25lbnREZXNjcmlwdG9yKGluc3QpICYmXG4gICAgICAgICAgICAgKGluc3QuY29uc3RydWN0b3IgPT09IHR5cGUpKTtcbiAgfSxcblxuICBpc1RleHRDb21wb25lbnQ6IGZ1bmN0aW9uKGluc3QpIHtcbiAgICByZXR1cm4gaW5zdCBpbnN0YW5jZW9mIFJlYWN0VGV4dENvbXBvbmVudC50eXBlO1xuICB9LFxuXG4gIGZpbmRBbGxJblJlbmRlcmVkVHJlZTogZnVuY3Rpb24oaW5zdCwgdGVzdCkge1xuICAgIGlmICghaW5zdCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICB2YXIgcmV0ID0gdGVzdChpbnN0KSA/IFtpbnN0XSA6IFtdO1xuICAgIGlmIChSZWFjdFRlc3RVdGlscy5pc0RPTUNvbXBvbmVudChpbnN0KSkge1xuICAgICAgdmFyIHJlbmRlcmVkQ2hpbGRyZW4gPSBpbnN0Ll9yZW5kZXJlZENoaWxkcmVuO1xuICAgICAgdmFyIGtleTtcbiAgICAgIGZvciAoa2V5IGluIHJlbmRlcmVkQ2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKCFyZW5kZXJlZENoaWxkcmVuLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXQgPSByZXQuY29uY2F0KFxuICAgICAgICAgIFJlYWN0VGVzdFV0aWxzLmZpbmRBbGxJblJlbmRlcmVkVHJlZShyZW5kZXJlZENoaWxkcmVuW2tleV0sIHRlc3QpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChSZWFjdFRlc3RVdGlscy5pc0NvbXBvc2l0ZUNvbXBvbmVudChpbnN0KSkge1xuICAgICAgcmV0ID0gcmV0LmNvbmNhdChcbiAgICAgICAgUmVhY3RUZXN0VXRpbHMuZmluZEFsbEluUmVuZGVyZWRUcmVlKGluc3QuX3JlbmRlcmVkQ29tcG9uZW50LCB0ZXN0KVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfSxcblxuICAvKipcbiAgICogRmluZHMgYWxsIGluc3RhbmNlIG9mIGNvbXBvbmVudHMgaW4gdGhlIHJlbmRlcmVkIHRyZWUgdGhhdCBhcmUgRE9NXG4gICAqIGNvbXBvbmVudHMgd2l0aCB0aGUgY2xhc3MgbmFtZSBtYXRjaGluZyBgY2xhc3NOYW1lYC5cbiAgICogQHJldHVybiBhbiBhcnJheSBvZiBhbGwgdGhlIG1hdGNoZXMuXG4gICAqL1xuICBzY3J5UmVuZGVyZWRET01Db21wb25lbnRzV2l0aENsYXNzOiBmdW5jdGlvbihyb290LCBjbGFzc05hbWUpIHtcbiAgICByZXR1cm4gUmVhY3RUZXN0VXRpbHMuZmluZEFsbEluUmVuZGVyZWRUcmVlKHJvb3QsIGZ1bmN0aW9uKGluc3QpIHtcbiAgICAgIHZhciBpbnN0Q2xhc3NOYW1lID0gaW5zdC5wcm9wcy5jbGFzc05hbWU7XG4gICAgICByZXR1cm4gUmVhY3RUZXN0VXRpbHMuaXNET01Db21wb25lbnQoaW5zdCkgJiYgKFxuICAgICAgICBpbnN0Q2xhc3NOYW1lICYmXG4gICAgICAgICgnICcgKyBpbnN0Q2xhc3NOYW1lICsgJyAnKS5pbmRleE9mKCcgJyArIGNsYXNzTmFtZSArICcgJykgIT09IC0xXG4gICAgICApO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBMaWtlIHNjcnlSZW5kZXJlZERPTUNvbXBvbmVudHNXaXRoQ2xhc3MgYnV0IGV4cGVjdHMgdGhlcmUgdG8gYmUgb25lIHJlc3VsdCxcbiAgICogYW5kIHJldHVybnMgdGhhdCBvbmUgcmVzdWx0LCBvciB0aHJvd3MgZXhjZXB0aW9uIGlmIHRoZXJlIGlzIGFueSBvdGhlclxuICAgKiBudW1iZXIgb2YgbWF0Y2hlcyBiZXNpZGVzIG9uZS5cbiAgICogQHJldHVybiB7IVJlYWN0RE9NQ29tcG9uZW50fSBUaGUgb25lIG1hdGNoLlxuICAgKi9cbiAgZmluZFJlbmRlcmVkRE9NQ29tcG9uZW50V2l0aENsYXNzOiBmdW5jdGlvbihyb290LCBjbGFzc05hbWUpIHtcbiAgICB2YXIgYWxsID1cbiAgICAgIFJlYWN0VGVzdFV0aWxzLnNjcnlSZW5kZXJlZERPTUNvbXBvbmVudHNXaXRoQ2xhc3Mocm9vdCwgY2xhc3NOYW1lKTtcbiAgICBpZiAoYWxsLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEaWQgbm90IGZpbmQgZXhhY3RseSBvbmUgbWF0Y2ggZm9yIGNsYXNzOicgKyBjbGFzc05hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gYWxsWzBdO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIEZpbmRzIGFsbCBpbnN0YW5jZSBvZiBjb21wb25lbnRzIGluIHRoZSByZW5kZXJlZCB0cmVlIHRoYXQgYXJlIERPTVxuICAgKiBjb21wb25lbnRzIHdpdGggdGhlIHRhZyBuYW1lIG1hdGNoaW5nIGB0YWdOYW1lYC5cbiAgICogQHJldHVybiBhbiBhcnJheSBvZiBhbGwgdGhlIG1hdGNoZXMuXG4gICAqL1xuICBzY3J5UmVuZGVyZWRET01Db21wb25lbnRzV2l0aFRhZzogZnVuY3Rpb24ocm9vdCwgdGFnTmFtZSkge1xuICAgIHJldHVybiBSZWFjdFRlc3RVdGlscy5maW5kQWxsSW5SZW5kZXJlZFRyZWUocm9vdCwgZnVuY3Rpb24oaW5zdCkge1xuICAgICAgcmV0dXJuIFJlYWN0VGVzdFV0aWxzLmlzRE9NQ29tcG9uZW50KGluc3QpICYmXG4gICAgICAgICAgICBpbnN0LnRhZ05hbWUgPT09IHRhZ05hbWUudG9VcHBlckNhc2UoKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogTGlrZSBzY3J5UmVuZGVyZWRET01Db21wb25lbnRzV2l0aFRhZyBidXQgZXhwZWN0cyB0aGVyZSB0byBiZSBvbmUgcmVzdWx0LFxuICAgKiBhbmQgcmV0dXJucyB0aGF0IG9uZSByZXN1bHQsIG9yIHRocm93cyBleGNlcHRpb24gaWYgdGhlcmUgaXMgYW55IG90aGVyXG4gICAqIG51bWJlciBvZiBtYXRjaGVzIGJlc2lkZXMgb25lLlxuICAgKiBAcmV0dXJuIHshUmVhY3RET01Db21wb25lbnR9IFRoZSBvbmUgbWF0Y2guXG4gICAqL1xuICBmaW5kUmVuZGVyZWRET01Db21wb25lbnRXaXRoVGFnOiBmdW5jdGlvbihyb290LCB0YWdOYW1lKSB7XG4gICAgdmFyIGFsbCA9IFJlYWN0VGVzdFV0aWxzLnNjcnlSZW5kZXJlZERPTUNvbXBvbmVudHNXaXRoVGFnKHJvb3QsIHRhZ05hbWUpO1xuICAgIGlmIChhbGwubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RpZCBub3QgZmluZCBleGFjdGx5IG9uZSBtYXRjaCBmb3IgdGFnOicgKyB0YWdOYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIGFsbFswXTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBGaW5kcyBhbGwgaW5zdGFuY2VzIG9mIGNvbXBvbmVudHMgd2l0aCB0eXBlIGVxdWFsIHRvIGBjb21wb25lbnRUeXBlYC5cbiAgICogQHJldHVybiBhbiBhcnJheSBvZiBhbGwgdGhlIG1hdGNoZXMuXG4gICAqL1xuICBzY3J5UmVuZGVyZWRDb21wb25lbnRzV2l0aFR5cGU6IGZ1bmN0aW9uKHJvb3QsIGNvbXBvbmVudFR5cGUpIHtcbiAgICByZXR1cm4gUmVhY3RUZXN0VXRpbHMuZmluZEFsbEluUmVuZGVyZWRUcmVlKHJvb3QsIGZ1bmN0aW9uKGluc3QpIHtcbiAgICAgIHJldHVybiBSZWFjdFRlc3RVdGlscy5pc0NvbXBvc2l0ZUNvbXBvbmVudFdpdGhUeXBlKFxuICAgICAgICBpbnN0LFxuICAgICAgICBjb21wb25lbnRUeXBlXG4gICAgICApO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTYW1lIGFzIGBzY3J5UmVuZGVyZWRDb21wb25lbnRzV2l0aFR5cGVgIGJ1dCBleHBlY3RzIHRoZXJlIHRvIGJlIG9uZSByZXN1bHRcbiAgICogYW5kIHJldHVybnMgdGhhdCBvbmUgcmVzdWx0LCBvciB0aHJvd3MgZXhjZXB0aW9uIGlmIHRoZXJlIGlzIGFueSBvdGhlclxuICAgKiBudW1iZXIgb2YgbWF0Y2hlcyBiZXNpZGVzIG9uZS5cbiAgICogQHJldHVybiB7IVJlYWN0Q29tcG9uZW50fSBUaGUgb25lIG1hdGNoLlxuICAgKi9cbiAgZmluZFJlbmRlcmVkQ29tcG9uZW50V2l0aFR5cGU6IGZ1bmN0aW9uKHJvb3QsIGNvbXBvbmVudFR5cGUpIHtcbiAgICB2YXIgYWxsID0gUmVhY3RUZXN0VXRpbHMuc2NyeVJlbmRlcmVkQ29tcG9uZW50c1dpdGhUeXBlKFxuICAgICAgcm9vdCxcbiAgICAgIGNvbXBvbmVudFR5cGVcbiAgICApO1xuICAgIGlmIChhbGwubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdEaWQgbm90IGZpbmQgZXhhY3RseSBvbmUgbWF0Y2ggZm9yIGNvbXBvbmVudFR5cGU6JyArIGNvbXBvbmVudFR5cGVcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBhbGxbMF07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFBhc3MgYSBtb2NrZWQgY29tcG9uZW50IG1vZHVsZSB0byB0aGlzIG1ldGhvZCB0byBhdWdtZW50IGl0IHdpdGhcbiAgICogdXNlZnVsIG1ldGhvZHMgdGhhdCBhbGxvdyBpdCB0byBiZSB1c2VkIGFzIGEgZHVtbXkgUmVhY3QgY29tcG9uZW50LlxuICAgKiBJbnN0ZWFkIG9mIHJlbmRlcmluZyBhcyB1c3VhbCwgdGhlIGNvbXBvbmVudCB3aWxsIGJlY29tZSBhIHNpbXBsZVxuICAgKiA8ZGl2PiBjb250YWluaW5nIGFueSBwcm92aWRlZCBjaGlsZHJlbi5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG1vZHVsZSB0aGUgbW9jayBmdW5jdGlvbiBvYmplY3QgZXhwb3J0ZWQgZnJvbSBhXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlIHRoYXQgZGVmaW5lcyB0aGUgY29tcG9uZW50IHRvIGJlIG1vY2tlZFxuICAgKiBAcGFyYW0gez9zdHJpbmd9IG1vY2tUYWdOYW1lIG9wdGlvbmFsIGR1bW15IHJvb3QgdGFnIG5hbWUgdG8gcmV0dXJuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSByZW5kZXIgbWV0aG9kIChvdmVycmlkZXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGUubW9ja1RhZ05hbWUgaWYgcHJvdmlkZWQpXG4gICAqIEByZXR1cm4ge29iamVjdH0gdGhlIFJlYWN0VGVzdFV0aWxzIG9iamVjdCAoZm9yIGNoYWluaW5nKVxuICAgKi9cbiAgbW9ja0NvbXBvbmVudDogZnVuY3Rpb24obW9kdWxlLCBtb2NrVGFnTmFtZSkge1xuICAgIHZhciBDb252ZW5pZW5jZUNvbnN0cnVjdG9yID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1vY2tUYWdOYW1lID0gbW9ja1RhZ05hbWUgfHwgbW9kdWxlLm1vY2tUYWdOYW1lIHx8IFwiZGl2XCI7XG4gICAgICAgIHJldHVybiBSZWFjdERPTVttb2NrVGFnTmFtZV0obnVsbCwgdGhpcy5wcm9wcy5jaGlsZHJlbik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb3B5UHJvcGVydGllcyhtb2R1bGUsIENvbnZlbmllbmNlQ29uc3RydWN0b3IpO1xuICAgIG1vZHVsZS5tb2NrSW1wbGVtZW50YXRpb24oQ29udmVuaWVuY2VDb25zdHJ1Y3Rvcik7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogU2ltdWxhdGVzIGEgdG9wIGxldmVsIGV2ZW50IGJlaW5nIGRpc3BhdGNoZWQgZnJvbSBhIHJhdyBldmVudCB0aGF0IG9jY3VyZWRcbiAgICogb24gYW4gYEVsZW1lbnRgIG5vZGUuXG4gICAqIEBwYXJhbSB0b3BMZXZlbFR5cGUge09iamVjdH0gQSB0eXBlIGZyb20gYEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXNgXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IG5vZGUgVGhlIGRvbSB0byBzaW11bGF0ZSBhbiBldmVudCBvY2N1cnJpbmcgb24uXG4gICAqIEBwYXJhbSB7P0V2ZW50fSBmYWtlTmF0aXZlRXZlbnQgRmFrZSBuYXRpdmUgZXZlbnQgdG8gdXNlIGluIFN5bnRoZXRpY0V2ZW50LlxuICAgKi9cbiAgc2ltdWxhdGVOYXRpdmVFdmVudE9uTm9kZTogZnVuY3Rpb24odG9wTGV2ZWxUeXBlLCBub2RlLCBmYWtlTmF0aXZlRXZlbnQpIHtcbiAgICBmYWtlTmF0aXZlRXZlbnQudGFyZ2V0ID0gbm9kZTtcbiAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLmRpc3BhdGNoRXZlbnQoXG4gICAgICB0b3BMZXZlbFR5cGUsXG4gICAgICBmYWtlTmF0aXZlRXZlbnRcbiAgICApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTaW11bGF0ZXMgYSB0b3AgbGV2ZWwgZXZlbnQgYmVpbmcgZGlzcGF0Y2hlZCBmcm9tIGEgcmF3IGV2ZW50IHRoYXQgb2NjdXJlZFxuICAgKiBvbiB0aGUgYFJlYWN0RE9NQ29tcG9uZW50YCBgY29tcGAuXG4gICAqIEBwYXJhbSB0b3BMZXZlbFR5cGUge09iamVjdH0gQSB0eXBlIGZyb20gYEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXNgLlxuICAgKiBAcGFyYW0gY29tcCB7IVJlYWN0RE9NQ29tcG9uZW50fVxuICAgKiBAcGFyYW0gez9FdmVudH0gZmFrZU5hdGl2ZUV2ZW50IEZha2UgbmF0aXZlIGV2ZW50IHRvIHVzZSBpbiBTeW50aGV0aWNFdmVudC5cbiAgICovXG4gIHNpbXVsYXRlTmF0aXZlRXZlbnRPbkRPTUNvbXBvbmVudDogZnVuY3Rpb24oXG4gICAgICB0b3BMZXZlbFR5cGUsXG4gICAgICBjb21wLFxuICAgICAgZmFrZU5hdGl2ZUV2ZW50KSB7XG4gICAgUmVhY3RUZXN0VXRpbHMuc2ltdWxhdGVOYXRpdmVFdmVudE9uTm9kZShcbiAgICAgIHRvcExldmVsVHlwZSxcbiAgICAgIGNvbXAuZ2V0RE9NTm9kZSgpLFxuICAgICAgZmFrZU5hdGl2ZUV2ZW50XG4gICAgKTtcbiAgfSxcblxuICBuYXRpdmVUb3VjaERhdGE6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG91Y2hlczogW1xuICAgICAgICB7cGFnZVg6IHgsIHBhZ2VZOiB5fVxuICAgICAgXVxuICAgIH07XG4gIH0sXG5cbiAgU2ltdWxhdGU6IG51bGwsXG4gIFNpbXVsYXRlTmF0aXZlOiB7fVxufTtcblxuLyoqXG4gKiBFeHBvcnRzOlxuICpcbiAqIC0gYFJlYWN0VGVzdFV0aWxzLlNpbXVsYXRlLmNsaWNrKEVsZW1lbnQvUmVhY3RET01Db21wb25lbnQpYFxuICogLSBgUmVhY3RUZXN0VXRpbHMuU2ltdWxhdGUubW91c2VNb3ZlKEVsZW1lbnQvUmVhY3RET01Db21wb25lbnQpYFxuICogLSBgUmVhY3RUZXN0VXRpbHMuU2ltdWxhdGUuY2hhbmdlKEVsZW1lbnQvUmVhY3RET01Db21wb25lbnQpYFxuICogLSAuLi4gKEFsbCBrZXlzIGZyb20gZXZlbnQgcGx1Z2luIGBldmVudFR5cGVzYCBvYmplY3RzKVxuICovXG5mdW5jdGlvbiBtYWtlU2ltdWxhdG9yKGV2ZW50VHlwZSkge1xuICByZXR1cm4gZnVuY3Rpb24oZG9tQ29tcG9uZW50T3JOb2RlLCBldmVudERhdGEpIHtcbiAgICB2YXIgbm9kZTtcbiAgICBpZiAoUmVhY3RUZXN0VXRpbHMuaXNET01Db21wb25lbnQoZG9tQ29tcG9uZW50T3JOb2RlKSkge1xuICAgICAgbm9kZSA9IGRvbUNvbXBvbmVudE9yTm9kZS5nZXRET01Ob2RlKCk7XG4gICAgfSBlbHNlIGlmIChkb21Db21wb25lbnRPck5vZGUudGFnTmFtZSkge1xuICAgICAgbm9kZSA9IGRvbUNvbXBvbmVudE9yTm9kZTtcbiAgICB9XG5cbiAgICB2YXIgZmFrZU5hdGl2ZUV2ZW50ID0gbmV3IEV2ZW50KCk7XG4gICAgZmFrZU5hdGl2ZUV2ZW50LnRhcmdldCA9IG5vZGU7XG4gICAgLy8gV2UgZG9uJ3QgdXNlIFN5bnRoZXRpY0V2ZW50LmdldFBvb2xlZCBpbiBvcmRlciB0byBub3QgaGF2ZSB0byB3b3JyeSBhYm91dFxuICAgIC8vIHByb3Blcmx5IGRlc3Ryb3lpbmcgYW55IHByb3BlcnRpZXMgYXNzaWduZWQgZnJvbSBgZXZlbnREYXRhYCB1cG9uIHJlbGVhc2VcbiAgICB2YXIgZXZlbnQgPSBuZXcgU3ludGhldGljRXZlbnQoXG4gICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzW2V2ZW50VHlwZV0sXG4gICAgICBSZWFjdE1vdW50LmdldElEKG5vZGUpLFxuICAgICAgZmFrZU5hdGl2ZUV2ZW50XG4gICAgKTtcbiAgICBtZXJnZUludG8oZXZlbnQsIGV2ZW50RGF0YSk7XG4gICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcblxuICAgIFJlYWN0VXBkYXRlcy5iYXRjaGVkVXBkYXRlcyhmdW5jdGlvbigpIHtcbiAgICAgIEV2ZW50UGx1Z2luSHViLmVucXVldWVFdmVudHMoZXZlbnQpO1xuICAgICAgRXZlbnRQbHVnaW5IdWIucHJvY2Vzc0V2ZW50UXVldWUoKTtcbiAgICB9KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYnVpbGRTaW11bGF0b3JzKCkge1xuICBSZWFjdFRlc3RVdGlscy5TaW11bGF0ZSA9IHt9O1xuXG4gIHZhciBldmVudFR5cGU7XG4gIGZvciAoZXZlbnRUeXBlIGluIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5ldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFFbGVtZW50IHx8IFJlYWN0RE9NQ29tcG9uZW50fSBkb21Db21wb25lbnRPck5vZGVcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IGV2ZW50RGF0YSBGYWtlIGV2ZW50IGRhdGEgdG8gdXNlIGluIFN5bnRoZXRpY0V2ZW50LlxuICAgICAqL1xuICAgIFJlYWN0VGVzdFV0aWxzLlNpbXVsYXRlW2V2ZW50VHlwZV0gPSBtYWtlU2ltdWxhdG9yKGV2ZW50VHlwZSk7XG4gIH1cbn1cblxuLy8gUmVidWlsZCBSZWFjdFRlc3RVdGlscy5TaW11bGF0ZSB3aGVuZXZlciBldmVudCBwbHVnaW5zIGFyZSBpbmplY3RlZFxudmFyIG9sZEluamVjdEV2ZW50UGx1Z2luT3JkZXIgPSBFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5PcmRlcjtcbkV2ZW50UGx1Z2luSHViLmluamVjdGlvbi5pbmplY3RFdmVudFBsdWdpbk9yZGVyID0gZnVuY3Rpb24oKSB7XG4gIG9sZEluamVjdEV2ZW50UGx1Z2luT3JkZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgYnVpbGRTaW11bGF0b3JzKCk7XG59O1xudmFyIG9sZEluamVjdEV2ZW50UGx1Z2lucyA9IEV2ZW50UGx1Z2luSHViLmluamVjdGlvbi5pbmplY3RFdmVudFBsdWdpbnNCeU5hbWU7XG5FdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lID0gZnVuY3Rpb24oKSB7XG4gIG9sZEluamVjdEV2ZW50UGx1Z2lucy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICBidWlsZFNpbXVsYXRvcnMoKTtcbn07XG5cbmJ1aWxkU2ltdWxhdG9ycygpO1xuXG4vKipcbiAqIEV4cG9ydHM6XG4gKlxuICogLSBgUmVhY3RUZXN0VXRpbHMuU2ltdWxhdGVOYXRpdmUuY2xpY2soRWxlbWVudC9SZWFjdERPTUNvbXBvbmVudClgXG4gKiAtIGBSZWFjdFRlc3RVdGlscy5TaW11bGF0ZU5hdGl2ZS5tb3VzZU1vdmUoRWxlbWVudC9SZWFjdERPTUNvbXBvbmVudClgXG4gKiAtIGBSZWFjdFRlc3RVdGlscy5TaW11bGF0ZU5hdGl2ZS5tb3VzZUluL1JlYWN0RE9NQ29tcG9uZW50KWBcbiAqIC0gYFJlYWN0VGVzdFV0aWxzLlNpbXVsYXRlTmF0aXZlLm1vdXNlT3V0KEVsZW1lbnQvUmVhY3RET01Db21wb25lbnQpYFxuICogLSAuLi4gKEFsbCBrZXlzIGZyb20gYEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXNgKVxuICpcbiAqIE5vdGU6IFRvcCBsZXZlbCBldmVudCB0eXBlcyBhcmUgYSBzdWJzZXQgb2YgdGhlIGVudGlyZSBzZXQgb2YgaGFuZGxlciB0eXBlc1xuICogKHdoaWNoIGluY2x1ZGUgYSBicm9hZGVyIHNldCBvZiBcInN5bnRoZXRpY1wiIGV2ZW50cykuIEZvciBleGFtcGxlLCBvbkRyYWdEb25lXG4gKiBpcyBhIHN5bnRoZXRpYyBldmVudC4gRXhjZXB0IHdoZW4gdGVzdGluZyBhbiBldmVudCBwbHVnaW4gb3IgUmVhY3QncyBldmVudFxuICogaGFuZGxpbmcgY29kZSBzcGVjaWZpY2FsbHksIHlvdSBwcm9iYWJseSB3YW50IHRvIHVzZSBSZWFjdFRlc3RVdGlscy5TaW11bGF0ZVxuICogdG8gZGlzcGF0Y2ggc3ludGhldGljIGV2ZW50cy5cbiAqL1xuXG5mdW5jdGlvbiBtYWtlTmF0aXZlU2ltdWxhdG9yKGV2ZW50VHlwZSkge1xuICByZXR1cm4gZnVuY3Rpb24oZG9tQ29tcG9uZW50T3JOb2RlLCBuYXRpdmVFdmVudERhdGEpIHtcbiAgICB2YXIgZmFrZU5hdGl2ZUV2ZW50ID0gbmV3IEV2ZW50KGV2ZW50VHlwZSk7XG4gICAgbWVyZ2VJbnRvKGZha2VOYXRpdmVFdmVudCwgbmF0aXZlRXZlbnREYXRhKTtcbiAgICBpZiAoUmVhY3RUZXN0VXRpbHMuaXNET01Db21wb25lbnQoZG9tQ29tcG9uZW50T3JOb2RlKSkge1xuICAgICAgUmVhY3RUZXN0VXRpbHMuc2ltdWxhdGVOYXRpdmVFdmVudE9uRE9NQ29tcG9uZW50KFxuICAgICAgICBldmVudFR5cGUsXG4gICAgICAgIGRvbUNvbXBvbmVudE9yTm9kZSxcbiAgICAgICAgZmFrZU5hdGl2ZUV2ZW50XG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoISFkb21Db21wb25lbnRPck5vZGUudGFnTmFtZSkge1xuICAgICAgLy8gV2lsbCBhbGxvdyBvbiBhY3R1YWwgZG9tIG5vZGVzLlxuICAgICAgUmVhY3RUZXN0VXRpbHMuc2ltdWxhdGVOYXRpdmVFdmVudE9uTm9kZShcbiAgICAgICAgZXZlbnRUeXBlLFxuICAgICAgICBkb21Db21wb25lbnRPck5vZGUsXG4gICAgICAgIGZha2VOYXRpdmVFdmVudFxuICAgICAgKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBldmVudFR5cGU7XG5mb3IgKGV2ZW50VHlwZSBpbiB0b3BMZXZlbFR5cGVzKSB7XG4gIC8vIEV2ZW50IHR5cGUgaXMgc3RvcmVkIGFzICd0b3BDbGljaycgLSB3ZSB0cmFuc2Zvcm0gdGhhdCB0byAnY2xpY2snXG4gIHZhciBjb252ZW5pZW5jZU5hbWUgPSBldmVudFR5cGUuaW5kZXhPZigndG9wJykgPT09IDAgP1xuICAgIGV2ZW50VHlwZS5jaGFyQXQoMykudG9Mb3dlckNhc2UoKSArIGV2ZW50VHlwZS5zdWJzdHIoNCkgOiBldmVudFR5cGU7XG4gIC8qKlxuICAgKiBAcGFyYW0geyFFbGVtZW50IHx8IFJlYWN0RE9NQ29tcG9uZW50fSBkb21Db21wb25lbnRPck5vZGVcbiAgICogQHBhcmFtIHs/RXZlbnR9IG5hdGl2ZUV2ZW50RGF0YSBGYWtlIG5hdGl2ZSBldmVudCB0byB1c2UgaW4gU3ludGhldGljRXZlbnQuXG4gICAqL1xuICBSZWFjdFRlc3RVdGlscy5TaW11bGF0ZU5hdGl2ZVtjb252ZW5pZW5jZU5hbWVdID1cbiAgICBtYWtlTmF0aXZlU2ltdWxhdG9yKGV2ZW50VHlwZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RUZXN0VXRpbHM7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RUZXh0Q29tcG9uZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgRE9NUHJvcGVydHlPcGVyYXRpb25zID0gcmVxdWlyZShcIi4vRE9NUHJvcGVydHlPcGVyYXRpb25zXCIpO1xudmFyIFJlYWN0QnJvd3NlckNvbXBvbmVudE1peGluID0gcmVxdWlyZShcIi4vUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW5cIik7XG52YXIgUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKFwiLi9SZWFjdENvbXBvbmVudFwiKTtcbnZhciBSZWFjdERlc2NyaXB0b3IgPSByZXF1aXJlKFwiLi9SZWFjdERlc2NyaXB0b3JcIik7XG5cbnZhciBlc2NhcGVUZXh0Rm9yQnJvd3NlciA9IHJlcXVpcmUoXCIuL2VzY2FwZVRleHRGb3JCcm93c2VyXCIpO1xudmFyIG1peEludG8gPSByZXF1aXJlKFwiLi9taXhJbnRvXCIpO1xuXG4vKipcbiAqIFRleHQgbm9kZXMgdmlvbGF0ZSBhIGNvdXBsZSBhc3N1bXB0aW9ucyB0aGF0IFJlYWN0IG1ha2VzIGFib3V0IGNvbXBvbmVudHM6XG4gKlxuICogIC0gV2hlbiBtb3VudGluZyB0ZXh0IGludG8gdGhlIERPTSwgYWRqYWNlbnQgdGV4dCBub2RlcyBhcmUgbWVyZ2VkLlxuICogIC0gVGV4dCBub2RlcyBjYW5ub3QgYmUgYXNzaWduZWQgYSBSZWFjdCByb290IElELlxuICpcbiAqIFRoaXMgY29tcG9uZW50IGlzIHVzZWQgdG8gd3JhcCBzdHJpbmdzIGluIGVsZW1lbnRzIHNvIHRoYXQgdGhleSBjYW4gdW5kZXJnb1xuICogdGhlIHNhbWUgcmVjb25jaWxpYXRpb24gdGhhdCBpcyBhcHBsaWVkIHRvIGVsZW1lbnRzLlxuICpcbiAqIFRPRE86IEludmVzdGlnYXRlIHJlcHJlc2VudGluZyBSZWFjdCBjb21wb25lbnRzIGluIHRoZSBET00gd2l0aCB0ZXh0IG5vZGVzLlxuICpcbiAqIEBjbGFzcyBSZWFjdFRleHRDb21wb25lbnRcbiAqIEBleHRlbmRzIFJlYWN0Q29tcG9uZW50XG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0VGV4dENvbXBvbmVudCA9IGZ1bmN0aW9uKGRlc2NyaXB0b3IpIHtcbiAgdGhpcy5jb25zdHJ1Y3QoZGVzY3JpcHRvcik7XG59O1xuXG5taXhJbnRvKFJlYWN0VGV4dENvbXBvbmVudCwgUmVhY3RDb21wb25lbnQuTWl4aW4pO1xubWl4SW50byhSZWFjdFRleHRDb21wb25lbnQsIFJlYWN0QnJvd3NlckNvbXBvbmVudE1peGluKTtcbm1peEludG8oUmVhY3RUZXh0Q29tcG9uZW50LCB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIG1hcmt1cCBmb3IgdGhpcyB0ZXh0IG5vZGUuIFRoaXMgbm9kZSBpcyBub3QgaW50ZW5kZWQgdG8gaGF2ZVxuICAgKiBhbnkgZmVhdHVyZXMgYmVzaWRlcyBjb250YWluaW5nIHRleHQgY29udGVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJvb3RJRCBET00gSUQgb2YgdGhlIHJvb3Qgbm9kZS5cbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtb3VudERlcHRoIG51bWJlciBvZiBjb21wb25lbnRzIGluIHRoZSBvd25lciBoaWVyYXJjaHlcbiAgICogQHJldHVybiB7c3RyaW5nfSBNYXJrdXAgZm9yIHRoaXMgdGV4dCBub2RlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbihyb290SUQsIHRyYW5zYWN0aW9uLCBtb3VudERlcHRoKSB7XG4gICAgUmVhY3RDb21wb25lbnQuTWl4aW4ubW91bnRDb21wb25lbnQuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICByb290SUQsXG4gICAgICB0cmFuc2FjdGlvbixcbiAgICAgIG1vdW50RGVwdGhcbiAgICApO1xuXG4gICAgdmFyIGVzY2FwZWRUZXh0ID0gZXNjYXBlVGV4dEZvckJyb3dzZXIodGhpcy5wcm9wcyk7XG5cbiAgICBpZiAodHJhbnNhY3Rpb24ucmVuZGVyVG9TdGF0aWNNYXJrdXApIHtcbiAgICAgIC8vIE5vcm1hbGx5IHdlJ2Qgd3JhcCB0aGlzIGluIGEgYHNwYW5gIGZvciB0aGUgcmVhc29ucyBzdGF0ZWQgYWJvdmUsIGJ1dFxuICAgICAgLy8gc2luY2UgdGhpcyBpcyBhIHNpdHVhdGlvbiB3aGVyZSBSZWFjdCB3b24ndCB0YWtlIG92ZXIgKHN0YXRpYyBwYWdlcyksXG4gICAgICAvLyB3ZSBjYW4gc2ltcGx5IHJldHVybiB0aGUgdGV4dCBhcyBpdCBpcy5cbiAgICAgIHJldHVybiBlc2NhcGVkVGV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgJzxzcGFuICcgKyBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuY3JlYXRlTWFya3VwRm9ySUQocm9vdElEKSArICc+JyArXG4gICAgICAgIGVzY2FwZWRUZXh0ICtcbiAgICAgICc8L3NwYW4+J1xuICAgICk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhpcyBjb21wb25lbnQgYnkgdXBkYXRpbmcgdGhlIHRleHQgY29udGVudC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHRDb21wb25lbnQgQ29udGFpbnMgdGhlIG5leHQgdGV4dCBjb250ZW50LlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24obmV4dENvbXBvbmVudCwgdHJhbnNhY3Rpb24pIHtcbiAgICB2YXIgbmV4dFByb3BzID0gbmV4dENvbXBvbmVudC5wcm9wcztcbiAgICBpZiAobmV4dFByb3BzICE9PSB0aGlzLnByb3BzKSB7XG4gICAgICB0aGlzLnByb3BzID0gbmV4dFByb3BzO1xuICAgICAgUmVhY3RDb21wb25lbnQuQmFja2VuZElET3BlcmF0aW9ucy51cGRhdGVUZXh0Q29udGVudEJ5SUQoXG4gICAgICAgIHRoaXMuX3Jvb3ROb2RlSUQsXG4gICAgICAgIG5leHRQcm9wc1xuICAgICAgKTtcbiAgICB9XG4gIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3REZXNjcmlwdG9yLmNyZWF0ZUZhY3RvcnkoUmVhY3RUZXh0Q29tcG9uZW50KTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RUcmFuc2l0aW9uQ2hpbGRNYXBwaW5nXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBSZWFjdENoaWxkcmVuID0gcmVxdWlyZShcIi4vUmVhY3RDaGlsZHJlblwiKTtcblxudmFyIFJlYWN0VHJhbnNpdGlvbkNoaWxkTWFwcGluZyA9IHtcbiAgLyoqXG4gICAqIEdpdmVuIGB0aGlzLnByb3BzLmNoaWxkcmVuYCwgcmV0dXJuIGFuIG9iamVjdCBtYXBwaW5nIGtleSB0byBjaGlsZC4gSnVzdFxuICAgKiBzaW1wbGUgc3ludGFjdGljIHN1Z2FyIGFyb3VuZCBSZWFjdENoaWxkcmVuLm1hcCgpLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGNoaWxkcmVuIGB0aGlzLnByb3BzLmNoaWxkcmVuYFxuICAgKiBAcmV0dXJuIHtvYmplY3R9IE1hcHBpbmcgb2Yga2V5IHRvIGNoaWxkXG4gICAqL1xuICBnZXRDaGlsZE1hcHBpbmc6IGZ1bmN0aW9uKGNoaWxkcmVuKSB7XG4gICAgcmV0dXJuIFJlYWN0Q2hpbGRyZW4ubWFwKGNoaWxkcmVuLCBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXaGVuIHlvdSdyZSBhZGRpbmcgb3IgcmVtb3ZpbmcgY2hpbGRyZW4gc29tZSBtYXkgYmUgYWRkZWQgb3IgcmVtb3ZlZCBpbiB0aGVcbiAgICogc2FtZSByZW5kZXIgcGFzcy4gV2Ugd2FudCBvdCBzaG93ICpib3RoKiBzaW5jZSB3ZSB3YW50IHRvIHNpbXVsdGFuZW91c2x5XG4gICAqIGFuaW1hdGUgZWxlbWVudHMgaW4gYW5kIG91dC4gVGhpcyBmdW5jdGlvbiB0YWtlcyBhIHByZXZpb3VzIHNldCBvZiBrZXlzXG4gICAqIGFuZCBhIG5ldyBzZXQgb2Yga2V5cyBhbmQgbWVyZ2VzIHRoZW0gd2l0aCBpdHMgYmVzdCBndWVzcyBvZiB0aGUgY29ycmVjdFxuICAgKiBvcmRlcmluZy4gSW4gdGhlIGZ1dHVyZSB3ZSBtYXkgZXhwb3NlIHNvbWUgb2YgdGhlIHV0aWxpdGllcyBpblxuICAgKiBSZWFjdE11bHRpQ2hpbGQgdG8gbWFrZSB0aGlzIGVhc3ksIGJ1dCBmb3Igbm93IFJlYWN0IGl0c2VsZiBkb2VzIG5vdFxuICAgKiBkaXJlY3RseSBoYXZlIHRoaXMgY29uY2VwdCBvZiB0aGUgdW5pb24gb2YgcHJldkNoaWxkcmVuIGFuZCBuZXh0Q2hpbGRyZW5cbiAgICogc28gd2UgaW1wbGVtZW50IGl0IGhlcmUuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcmV2IHByZXYgY2hpbGRyZW4gYXMgcmV0dXJuZWQgZnJvbVxuICAgKiBgUmVhY3RUcmFuc2l0aW9uQ2hpbGRNYXBwaW5nLmdldENoaWxkTWFwcGluZygpYC5cbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHQgbmV4dCBjaGlsZHJlbiBhcyByZXR1cm5lZCBmcm9tXG4gICAqIGBSZWFjdFRyYW5zaXRpb25DaGlsZE1hcHBpbmcuZ2V0Q2hpbGRNYXBwaW5nKClgLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IGEga2V5IHNldCB0aGF0IGNvbnRhaW5zIGFsbCBrZXlzIGluIGBwcmV2YCBhbmQgYWxsIGtleXNcbiAgICogaW4gYG5leHRgIGluIGEgcmVhc29uYWJsZSBvcmRlci5cbiAgICovXG4gIG1lcmdlQ2hpbGRNYXBwaW5nczogZnVuY3Rpb24ocHJldiwgbmV4dCkge1xuICAgIHByZXYgPSBwcmV2IHx8IHt9O1xuICAgIG5leHQgPSBuZXh0IHx8IHt9O1xuXG4gICAgZnVuY3Rpb24gZ2V0VmFsdWVGb3JLZXkoa2V5KSB7XG4gICAgICBpZiAobmV4dC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHJldHVybiBuZXh0W2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcHJldltrZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZvciBlYWNoIGtleSBvZiBgbmV4dGAsIHRoZSBsaXN0IG9mIGtleXMgdG8gaW5zZXJ0IGJlZm9yZSB0aGF0IGtleSBpblxuICAgIC8vIHRoZSBjb21iaW5lZCBsaXN0XG4gICAgdmFyIG5leHRLZXlzUGVuZGluZyA9IHt9O1xuXG4gICAgdmFyIHBlbmRpbmdLZXlzID0gW107XG4gICAgZm9yICh2YXIgcHJldktleSBpbiBwcmV2KSB7XG4gICAgICBpZiAobmV4dC5oYXNPd25Qcm9wZXJ0eShwcmV2S2V5KSkge1xuICAgICAgICBpZiAocGVuZGluZ0tleXMubGVuZ3RoKSB7XG4gICAgICAgICAgbmV4dEtleXNQZW5kaW5nW3ByZXZLZXldID0gcGVuZGluZ0tleXM7XG4gICAgICAgICAgcGVuZGluZ0tleXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVuZGluZ0tleXMucHVzaChwcmV2S2V5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgY2hpbGRNYXBwaW5nID0ge307XG4gICAgZm9yICh2YXIgbmV4dEtleSBpbiBuZXh0KSB7XG4gICAgICBpZiAobmV4dEtleXNQZW5kaW5nLmhhc093blByb3BlcnR5KG5leHRLZXkpKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuZXh0S2V5c1BlbmRpbmdbbmV4dEtleV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcGVuZGluZ05leHRLZXkgPSBuZXh0S2V5c1BlbmRpbmdbbmV4dEtleV1baV07XG4gICAgICAgICAgY2hpbGRNYXBwaW5nW25leHRLZXlzUGVuZGluZ1tuZXh0S2V5XVtpXV0gPSBnZXRWYWx1ZUZvcktleShcbiAgICAgICAgICAgIHBlbmRpbmdOZXh0S2V5XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hpbGRNYXBwaW5nW25leHRLZXldID0gZ2V0VmFsdWVGb3JLZXkobmV4dEtleSk7XG4gICAgfVxuXG4gICAgLy8gRmluYWxseSwgYWRkIHRoZSBrZXlzIHdoaWNoIGRpZG4ndCBhcHBlYXIgYmVmb3JlIGFueSBrZXkgaW4gYG5leHRgXG4gICAgZm9yIChpID0gMDsgaSA8IHBlbmRpbmdLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZE1hcHBpbmdbcGVuZGluZ0tleXNbaV1dID0gZ2V0VmFsdWVGb3JLZXkocGVuZGluZ0tleXNbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiBjaGlsZE1hcHBpbmc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RUcmFuc2l0aW9uQ2hpbGRNYXBwaW5nO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0VHJhbnNpdGlvbkV2ZW50c1xuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKFwiLi9FeGVjdXRpb25FbnZpcm9ubWVudFwiKTtcblxuLyoqXG4gKiBFVkVOVF9OQU1FX01BUCBpcyB1c2VkIHRvIGRldGVybWluZSB3aGljaCBldmVudCBmaXJlZCB3aGVuIGFcbiAqIHRyYW5zaXRpb24vYW5pbWF0aW9uIGVuZHMsIGJhc2VkIG9uIHRoZSBzdHlsZSBwcm9wZXJ0eSB1c2VkIHRvXG4gKiBkZWZpbmUgdGhhdCBldmVudC5cbiAqL1xudmFyIEVWRU5UX05BTUVfTUFQID0ge1xuICB0cmFuc2l0aW9uZW5kOiB7XG4gICAgJ3RyYW5zaXRpb24nOiAndHJhbnNpdGlvbmVuZCcsXG4gICAgJ1dlYmtpdFRyYW5zaXRpb24nOiAnd2Via2l0VHJhbnNpdGlvbkVuZCcsXG4gICAgJ01velRyYW5zaXRpb24nOiAnbW96VHJhbnNpdGlvbkVuZCcsXG4gICAgJ09UcmFuc2l0aW9uJzogJ29UcmFuc2l0aW9uRW5kJyxcbiAgICAnbXNUcmFuc2l0aW9uJzogJ01TVHJhbnNpdGlvbkVuZCdcbiAgfSxcblxuICBhbmltYXRpb25lbmQ6IHtcbiAgICAnYW5pbWF0aW9uJzogJ2FuaW1hdGlvbmVuZCcsXG4gICAgJ1dlYmtpdEFuaW1hdGlvbic6ICd3ZWJraXRBbmltYXRpb25FbmQnLFxuICAgICdNb3pBbmltYXRpb24nOiAnbW96QW5pbWF0aW9uRW5kJyxcbiAgICAnT0FuaW1hdGlvbic6ICdvQW5pbWF0aW9uRW5kJyxcbiAgICAnbXNBbmltYXRpb24nOiAnTVNBbmltYXRpb25FbmQnXG4gIH1cbn07XG5cbnZhciBlbmRFdmVudHMgPSBbXTtcblxuZnVuY3Rpb24gZGV0ZWN0RXZlbnRzKCkge1xuICB2YXIgdGVzdEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHZhciBzdHlsZSA9IHRlc3RFbC5zdHlsZTtcblxuICAvLyBPbiBzb21lIHBsYXRmb3JtcywgaW4gcGFydGljdWxhciBzb21lIHJlbGVhc2VzIG9mIEFuZHJvaWQgNC54LFxuICAvLyB0aGUgdW4tcHJlZml4ZWQgXCJhbmltYXRpb25cIiBhbmQgXCJ0cmFuc2l0aW9uXCIgcHJvcGVydGllcyBhcmUgZGVmaW5lZCBvbiB0aGVcbiAgLy8gc3R5bGUgb2JqZWN0IGJ1dCB0aGUgZXZlbnRzIHRoYXQgZmlyZSB3aWxsIHN0aWxsIGJlIHByZWZpeGVkLCBzbyB3ZSBuZWVkXG4gIC8vIHRvIGNoZWNrIGlmIHRoZSB1bi1wcmVmaXhlZCBldmVudHMgYXJlIHVzZWFibGUsIGFuZCBpZiBub3QgcmVtb3ZlIHRoZW1cbiAgLy8gZnJvbSB0aGUgbWFwXG4gIGlmICghKCdBbmltYXRpb25FdmVudCcgaW4gd2luZG93KSkge1xuICAgIGRlbGV0ZSBFVkVOVF9OQU1FX01BUC5hbmltYXRpb25lbmQuYW5pbWF0aW9uO1xuICB9XG5cbiAgaWYgKCEoJ1RyYW5zaXRpb25FdmVudCcgaW4gd2luZG93KSkge1xuICAgIGRlbGV0ZSBFVkVOVF9OQU1FX01BUC50cmFuc2l0aW9uZW5kLnRyYW5zaXRpb247XG4gIH1cblxuICBmb3IgKHZhciBiYXNlRXZlbnROYW1lIGluIEVWRU5UX05BTUVfTUFQKSB7XG4gICAgdmFyIGJhc2VFdmVudHMgPSBFVkVOVF9OQU1FX01BUFtiYXNlRXZlbnROYW1lXTtcbiAgICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gYmFzZUV2ZW50cykge1xuICAgICAgaWYgKHN0eWxlTmFtZSBpbiBzdHlsZSkge1xuICAgICAgICBlbmRFdmVudHMucHVzaChiYXNlRXZlbnRzW3N0eWxlTmFtZV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICBkZXRlY3RFdmVudHMoKTtcbn1cblxuLy8gV2UgdXNlIHRoZSByYXcge2FkZHxyZW1vdmV9RXZlbnRMaXN0ZW5lcigpIGNhbGwgYmVjYXVzZSBFdmVudExpc3RlbmVyXG4vLyBkb2VzIG5vdCBrbm93IGhvdyB0byByZW1vdmUgZXZlbnQgbGlzdGVuZXJzIGFuZCB3ZSByZWFsbHkgc2hvdWxkXG4vLyBjbGVhbiB1cC4gQWxzbywgdGhlc2UgZXZlbnRzIGFyZSBub3QgdHJpZ2dlcmVkIGluIG9sZGVyIGJyb3dzZXJzXG4vLyBzbyB3ZSBzaG91bGQgYmUgQS1PSyBoZXJlLlxuXG5mdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKG5vZGUsIGV2ZW50TmFtZSwgZXZlbnRMaXN0ZW5lcikge1xuICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBldmVudExpc3RlbmVyLCBmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIobm9kZSwgZXZlbnROYW1lLCBldmVudExpc3RlbmVyKSB7XG4gIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGV2ZW50TGlzdGVuZXIsIGZhbHNlKTtcbn1cblxudmFyIFJlYWN0VHJhbnNpdGlvbkV2ZW50cyA9IHtcbiAgYWRkRW5kRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24obm9kZSwgZXZlbnRMaXN0ZW5lcikge1xuICAgIGlmIChlbmRFdmVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBJZiBDU1MgdHJhbnNpdGlvbnMgYXJlIG5vdCBzdXBwb3J0ZWQsIHRyaWdnZXIgYW4gXCJlbmQgYW5pbWF0aW9uXCJcbiAgICAgIC8vIGV2ZW50IGltbWVkaWF0ZWx5LlxuICAgICAgd2luZG93LnNldFRpbWVvdXQoZXZlbnRMaXN0ZW5lciwgMCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVuZEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVuZEV2ZW50KSB7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKG5vZGUsIGVuZEV2ZW50LCBldmVudExpc3RlbmVyKTtcbiAgICB9KTtcbiAgfSxcblxuICByZW1vdmVFbmRFdmVudExpc3RlbmVyOiBmdW5jdGlvbihub2RlLCBldmVudExpc3RlbmVyKSB7XG4gICAgaWYgKGVuZEV2ZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZW5kRXZlbnRzLmZvckVhY2goZnVuY3Rpb24oZW5kRXZlbnQpIHtcbiAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIobm9kZSwgZW5kRXZlbnQsIGV2ZW50TGlzdGVuZXIpO1xuICAgIH0pO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0VHJhbnNpdGlvbkV2ZW50cztcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFRyYW5zaXRpb25Hcm91cFxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKFwiLi9SZWFjdFwiKTtcbnZhciBSZWFjdFRyYW5zaXRpb25DaGlsZE1hcHBpbmcgPSByZXF1aXJlKFwiLi9SZWFjdFRyYW5zaXRpb25DaGlsZE1hcHBpbmdcIik7XG5cbnZhciBjbG9uZVdpdGhQcm9wcyA9IHJlcXVpcmUoXCIuL2Nsb25lV2l0aFByb3BzXCIpO1xudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKFwiLi9lbXB0eUZ1bmN0aW9uXCIpO1xudmFyIG1lcmdlID0gcmVxdWlyZShcIi4vbWVyZ2VcIik7XG5cbnZhciBSZWFjdFRyYW5zaXRpb25Hcm91cCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdSZWFjdFRyYW5zaXRpb25Hcm91cCcsXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgY29tcG9uZW50OiBSZWFjdC5Qcm9wVHlwZXMuZnVuYyxcbiAgICBjaGlsZEZhY3Rvcnk6IFJlYWN0LlByb3BUeXBlcy5mdW5jXG4gIH0sXG5cbiAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcG9uZW50OiBSZWFjdC5ET00uc3BhbixcbiAgICAgIGNoaWxkRmFjdG9yeTogZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50XG4gICAgfTtcbiAgfSxcblxuICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjaGlsZHJlbjogUmVhY3RUcmFuc2l0aW9uQ2hpbGRNYXBwaW5nLmdldENoaWxkTWFwcGluZyh0aGlzLnByb3BzLmNoaWxkcmVuKVxuICAgIH07XG4gIH0sXG5cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogZnVuY3Rpb24obmV4dFByb3BzKSB7XG4gICAgdmFyIG5leHRDaGlsZE1hcHBpbmcgPSBSZWFjdFRyYW5zaXRpb25DaGlsZE1hcHBpbmcuZ2V0Q2hpbGRNYXBwaW5nKFxuICAgICAgbmV4dFByb3BzLmNoaWxkcmVuXG4gICAgKTtcbiAgICB2YXIgcHJldkNoaWxkTWFwcGluZyA9IHRoaXMuc3RhdGUuY2hpbGRyZW47XG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGNoaWxkcmVuOiBSZWFjdFRyYW5zaXRpb25DaGlsZE1hcHBpbmcubWVyZ2VDaGlsZE1hcHBpbmdzKFxuICAgICAgICBwcmV2Q2hpbGRNYXBwaW5nLFxuICAgICAgICBuZXh0Q2hpbGRNYXBwaW5nXG4gICAgICApXG4gICAgfSk7XG5cbiAgICB2YXIga2V5O1xuXG4gICAgZm9yIChrZXkgaW4gbmV4dENoaWxkTWFwcGluZykge1xuICAgICAgdmFyIGhhc1ByZXYgPSBwcmV2Q2hpbGRNYXBwaW5nICYmIHByZXZDaGlsZE1hcHBpbmcuaGFzT3duUHJvcGVydHkoa2V5KTtcbiAgICAgIGlmIChuZXh0Q2hpbGRNYXBwaW5nW2tleV0gJiYgIWhhc1ByZXYgJiZcbiAgICAgICAgICAhdGhpcy5jdXJyZW50bHlUcmFuc2l0aW9uaW5nS2V5c1trZXldKSB7XG4gICAgICAgIHRoaXMua2V5c1RvRW50ZXIucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoa2V5IGluIHByZXZDaGlsZE1hcHBpbmcpIHtcbiAgICAgIHZhciBoYXNOZXh0ID0gbmV4dENoaWxkTWFwcGluZyAmJiBuZXh0Q2hpbGRNYXBwaW5nLmhhc093blByb3BlcnR5KGtleSk7XG4gICAgICBpZiAocHJldkNoaWxkTWFwcGluZ1trZXldICYmICFoYXNOZXh0ICYmXG4gICAgICAgICAgIXRoaXMuY3VycmVudGx5VHJhbnNpdGlvbmluZ0tleXNba2V5XSkge1xuICAgICAgICB0aGlzLmtleXNUb0xlYXZlLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB3ZSB3YW50IHRvIHNvbWVkYXkgY2hlY2sgZm9yIHJlb3JkZXJpbmcsIHdlIGNvdWxkIGRvIGl0IGhlcmUuXG4gIH0sXG5cbiAgY29tcG9uZW50V2lsbE1vdW50OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmN1cnJlbnRseVRyYW5zaXRpb25pbmdLZXlzID0ge307XG4gICAgdGhpcy5rZXlzVG9FbnRlciA9IFtdO1xuICAgIHRoaXMua2V5c1RvTGVhdmUgPSBbXTtcbiAgfSxcblxuICBjb21wb25lbnREaWRVcGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBrZXlzVG9FbnRlciA9IHRoaXMua2V5c1RvRW50ZXI7XG4gICAgdGhpcy5rZXlzVG9FbnRlciA9IFtdO1xuICAgIGtleXNUb0VudGVyLmZvckVhY2godGhpcy5wZXJmb3JtRW50ZXIpO1xuXG4gICAgdmFyIGtleXNUb0xlYXZlID0gdGhpcy5rZXlzVG9MZWF2ZTtcbiAgICB0aGlzLmtleXNUb0xlYXZlID0gW107XG4gICAga2V5c1RvTGVhdmUuZm9yRWFjaCh0aGlzLnBlcmZvcm1MZWF2ZSk7XG4gIH0sXG5cbiAgcGVyZm9ybUVudGVyOiBmdW5jdGlvbihrZXkpIHtcbiAgICB0aGlzLmN1cnJlbnRseVRyYW5zaXRpb25pbmdLZXlzW2tleV0gPSB0cnVlO1xuXG4gICAgdmFyIGNvbXBvbmVudCA9IHRoaXMucmVmc1trZXldO1xuXG4gICAgaWYgKGNvbXBvbmVudC5jb21wb25lbnRXaWxsRW50ZXIpIHtcbiAgICAgIGNvbXBvbmVudC5jb21wb25lbnRXaWxsRW50ZXIoXG4gICAgICAgIHRoaXMuX2hhbmRsZURvbmVFbnRlcmluZy5iaW5kKHRoaXMsIGtleSlcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2hhbmRsZURvbmVFbnRlcmluZyhrZXkpO1xuICAgIH1cbiAgfSxcblxuICBfaGFuZGxlRG9uZUVudGVyaW5nOiBmdW5jdGlvbihrZXkpIHtcbiAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5yZWZzW2tleV07XG4gICAgaWYgKGNvbXBvbmVudC5jb21wb25lbnREaWRFbnRlcikge1xuICAgICAgY29tcG9uZW50LmNvbXBvbmVudERpZEVudGVyKCk7XG4gICAgfVxuXG4gICAgZGVsZXRlIHRoaXMuY3VycmVudGx5VHJhbnNpdGlvbmluZ0tleXNba2V5XTtcblxuICAgIHZhciBjdXJyZW50Q2hpbGRNYXBwaW5nID0gUmVhY3RUcmFuc2l0aW9uQ2hpbGRNYXBwaW5nLmdldENoaWxkTWFwcGluZyhcbiAgICAgIHRoaXMucHJvcHMuY2hpbGRyZW5cbiAgICApO1xuXG4gICAgaWYgKCFjdXJyZW50Q2hpbGRNYXBwaW5nIHx8ICFjdXJyZW50Q2hpbGRNYXBwaW5nLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIC8vIFRoaXMgd2FzIHJlbW92ZWQgYmVmb3JlIGl0IGhhZCBmdWxseSBlbnRlcmVkLiBSZW1vdmUgaXQuXG4gICAgICB0aGlzLnBlcmZvcm1MZWF2ZShrZXkpO1xuICAgIH1cbiAgfSxcblxuICBwZXJmb3JtTGVhdmU6IGZ1bmN0aW9uKGtleSkge1xuICAgIHRoaXMuY3VycmVudGx5VHJhbnNpdGlvbmluZ0tleXNba2V5XSA9IHRydWU7XG5cbiAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5yZWZzW2tleV07XG4gICAgaWYgKGNvbXBvbmVudC5jb21wb25lbnRXaWxsTGVhdmUpIHtcbiAgICAgIGNvbXBvbmVudC5jb21wb25lbnRXaWxsTGVhdmUodGhpcy5faGFuZGxlRG9uZUxlYXZpbmcuYmluZCh0aGlzLCBrZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgaXMgc29tZXdoYXQgZGFuZ2Vyb3VzIGIvYyBpdCBjYWxscyBzZXRTdGF0ZSgpXG4gICAgICAvLyBhZ2FpbiwgZWZmZWN0aXZlbHkgbXV0YXRpbmcgdGhlIGNvbXBvbmVudCBiZWZvcmUgYWxsIHRoZSB3b3JrXG4gICAgICAvLyBpcyBkb25lLlxuICAgICAgdGhpcy5faGFuZGxlRG9uZUxlYXZpbmcoa2V5KTtcbiAgICB9XG4gIH0sXG5cbiAgX2hhbmRsZURvbmVMZWF2aW5nOiBmdW5jdGlvbihrZXkpIHtcbiAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5yZWZzW2tleV07XG5cbiAgICBpZiAoY29tcG9uZW50LmNvbXBvbmVudERpZExlYXZlKSB7XG4gICAgICBjb21wb25lbnQuY29tcG9uZW50RGlkTGVhdmUoKTtcbiAgICB9XG5cbiAgICBkZWxldGUgdGhpcy5jdXJyZW50bHlUcmFuc2l0aW9uaW5nS2V5c1trZXldO1xuXG4gICAgdmFyIGN1cnJlbnRDaGlsZE1hcHBpbmcgPSBSZWFjdFRyYW5zaXRpb25DaGlsZE1hcHBpbmcuZ2V0Q2hpbGRNYXBwaW5nKFxuICAgICAgdGhpcy5wcm9wcy5jaGlsZHJlblxuICAgICk7XG5cbiAgICBpZiAoY3VycmVudENoaWxkTWFwcGluZyAmJiBjdXJyZW50Q2hpbGRNYXBwaW5nLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIC8vIFRoaXMgZW50ZXJlZCBhZ2FpbiBiZWZvcmUgaXQgZnVsbHkgbGVmdC4gQWRkIGl0IGFnYWluLlxuICAgICAgdGhpcy5wZXJmb3JtRW50ZXIoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG5ld0NoaWxkcmVuID0gbWVyZ2UodGhpcy5zdGF0ZS5jaGlsZHJlbik7XG4gICAgICBkZWxldGUgbmV3Q2hpbGRyZW5ba2V5XTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe2NoaWxkcmVuOiBuZXdDaGlsZHJlbn0pO1xuICAgIH1cbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIC8vIFRPRE86IHdlIGNvdWxkIGdldCByaWQgb2YgdGhlIG5lZWQgZm9yIHRoZSB3cmFwcGVyIG5vZGVcbiAgICAvLyBieSBjbG9uaW5nIGEgc2luZ2xlIGNoaWxkXG4gICAgdmFyIGNoaWxkcmVuVG9SZW5kZXIgPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5zdGF0ZS5jaGlsZHJlbikge1xuICAgICAgdmFyIGNoaWxkID0gdGhpcy5zdGF0ZS5jaGlsZHJlbltrZXldO1xuICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgIC8vIFlvdSBtYXkgbmVlZCB0byBhcHBseSByZWFjdGl2ZSB1cGRhdGVzIHRvIGEgY2hpbGQgYXMgaXQgaXMgbGVhdmluZy5cbiAgICAgICAgLy8gVGhlIG5vcm1hbCBSZWFjdCB3YXkgdG8gZG8gaXQgd29uJ3Qgd29yayBzaW5jZSB0aGUgY2hpbGQgd2lsbCBoYXZlXG4gICAgICAgIC8vIGFscmVhZHkgYmVlbiByZW1vdmVkLiBJbiBjYXNlIHlvdSBuZWVkIHRoaXMgYmVoYXZpb3IgeW91IGNhbiBwcm92aWRlXG4gICAgICAgIC8vIGEgY2hpbGRGYWN0b3J5IGZ1bmN0aW9uIHRvIHdyYXAgZXZlcnkgY2hpbGQsIGV2ZW4gdGhlIG9uZXMgdGhhdCBhcmVcbiAgICAgICAgLy8gbGVhdmluZy5cbiAgICAgICAgY2hpbGRyZW5Ub1JlbmRlcltrZXldID0gY2xvbmVXaXRoUHJvcHMoXG4gICAgICAgICAgdGhpcy5wcm9wcy5jaGlsZEZhY3RvcnkoY2hpbGQpLFxuICAgICAgICAgIHtyZWY6IGtleX1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmZXJQcm9wc1RvKHRoaXMucHJvcHMuY29tcG9uZW50KG51bGwsIGNoaWxkcmVuVG9SZW5kZXIpKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RUcmFuc2l0aW9uR3JvdXA7XG4iLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0VXBkYXRlc1xuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgQ2FsbGJhY2tRdWV1ZSA9IHJlcXVpcmUoXCIuL0NhbGxiYWNrUXVldWVcIik7XG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKFwiLi9Qb29sZWRDbGFzc1wiKTtcbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoXCIuL1JlYWN0Q3VycmVudE93bmVyXCIpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoXCIuL1JlYWN0UGVyZlwiKTtcbnZhciBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoXCIuL1RyYW5zYWN0aW9uXCIpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xudmFyIG1peEludG8gPSByZXF1aXJlKFwiLi9taXhJbnRvXCIpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKFwiLi93YXJuaW5nXCIpO1xuXG52YXIgZGlydHlDb21wb25lbnRzID0gW107XG5cbnZhciBiYXRjaGluZ1N0cmF0ZWd5ID0gbnVsbDtcblxuZnVuY3Rpb24gZW5zdXJlSW5qZWN0ZWQoKSB7XG4gIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24gJiYgYmF0Y2hpbmdTdHJhdGVneSxcbiAgICAnUmVhY3RVcGRhdGVzOiBtdXN0IGluamVjdCBhIHJlY29uY2lsZSB0cmFuc2FjdGlvbiBjbGFzcyBhbmQgYmF0Y2hpbmcgJyArXG4gICAgJ3N0cmF0ZWd5J1xuICApIDogaW52YXJpYW50KFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uICYmIGJhdGNoaW5nU3RyYXRlZ3kpKTtcbn1cblxudmFyIE5FU1RFRF9VUERBVEVTID0ge1xuICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmRpcnR5Q29tcG9uZW50c0xlbmd0aCA9IGRpcnR5Q29tcG9uZW50cy5sZW5ndGg7XG4gIH0sXG4gIGNsb3NlOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGggIT09IGRpcnR5Q29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIEFkZGl0aW9uYWwgdXBkYXRlcyB3ZXJlIGVucXVldWVkIGJ5IGNvbXBvbmVudERpZFVwZGF0ZSBoYW5kbGVycyBvclxuICAgICAgLy8gc2ltaWxhcjsgYmVmb3JlIG91ciBvd24gVVBEQVRFX1FVRVVFSU5HIHdyYXBwZXIgY2xvc2VzLCB3ZSB3YW50IHRvIHJ1blxuICAgICAgLy8gdGhlc2UgbmV3IHVwZGF0ZXMgc28gdGhhdCBpZiBBJ3MgY29tcG9uZW50RGlkVXBkYXRlIGNhbGxzIHNldFN0YXRlIG9uXG4gICAgICAvLyBCLCBCIHdpbGwgdXBkYXRlIGJlZm9yZSB0aGUgY2FsbGJhY2sgQSdzIHVwZGF0ZXIgcHJvdmlkZWQgd2hlbiBjYWxsaW5nXG4gICAgICAvLyBzZXRTdGF0ZS5cbiAgICAgIGRpcnR5Q29tcG9uZW50cy5zcGxpY2UoMCwgdGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGgpO1xuICAgICAgZmx1c2hCYXRjaGVkVXBkYXRlcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoID0gMDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBVUERBVEVfUVVFVUVJTkcgPSB7XG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY2FsbGJhY2tRdWV1ZS5yZXNldCgpO1xuICB9LFxuICBjbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jYWxsYmFja1F1ZXVlLm5vdGlmeUFsbCgpO1xuICB9XG59O1xuXG52YXIgVFJBTlNBQ1RJT05fV1JBUFBFUlMgPSBbTkVTVEVEX1VQREFURVMsIFVQREFURV9RVUVVRUlOR107XG5cbmZ1bmN0aW9uIFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24oKSB7XG4gIHRoaXMucmVpbml0aWFsaXplVHJhbnNhY3Rpb24oKTtcbiAgdGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGggPSBudWxsO1xuICB0aGlzLmNhbGxiYWNrUXVldWUgPSBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZChudWxsKTtcbiAgdGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbiA9XG4gICAgUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24uZ2V0UG9vbGVkKCk7XG59XG5cbm1peEludG8oUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbiwgVHJhbnNhY3Rpb24uTWl4aW4pO1xubWl4SW50byhSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uLCB7XG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBUUkFOU0FDVElPTl9XUkFQUEVSUztcbiAgfSxcblxuICBkZXN0cnVjdG9yOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmRpcnR5Q29tcG9uZW50c0xlbmd0aCA9IG51bGw7XG4gICAgQ2FsbGJhY2tRdWV1ZS5yZWxlYXNlKHRoaXMuY2FsbGJhY2tRdWV1ZSk7XG4gICAgdGhpcy5jYWxsYmFja1F1ZXVlID0gbnVsbDtcbiAgICBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5yZWxlYXNlKHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24pO1xuICAgIHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24gPSBudWxsO1xuICB9LFxuXG4gIHBlcmZvcm06IGZ1bmN0aW9uKG1ldGhvZCwgc2NvcGUsIGEpIHtcbiAgICAvLyBFc3NlbnRpYWxseSBjYWxscyBgdGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbi5wZXJmb3JtKG1ldGhvZCwgc2NvcGUsIGEpYFxuICAgIC8vIHdpdGggdGhpcyB0cmFuc2FjdGlvbidzIHdyYXBwZXJzIGFyb3VuZCBpdC5cbiAgICByZXR1cm4gVHJhbnNhY3Rpb24uTWl4aW4ucGVyZm9ybS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgIHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24ucGVyZm9ybSxcbiAgICAgIHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24sXG4gICAgICBtZXRob2QsXG4gICAgICBzY29wZSxcbiAgICAgIGFcbiAgICApO1xuICB9XG59KTtcblxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24pO1xuXG5mdW5jdGlvbiBiYXRjaGVkVXBkYXRlcyhjYWxsYmFjaywgYSwgYikge1xuICBlbnN1cmVJbmplY3RlZCgpO1xuICBiYXRjaGluZ1N0cmF0ZWd5LmJhdGNoZWRVcGRhdGVzKGNhbGxiYWNrLCBhLCBiKTtcbn1cblxuLyoqXG4gKiBBcnJheSBjb21wYXJhdG9yIGZvciBSZWFjdENvbXBvbmVudHMgYnkgb3duZXIgZGVwdGhcbiAqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjMSBmaXJzdCBjb21wb25lbnQgeW91J3JlIGNvbXBhcmluZ1xuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gYzIgc2Vjb25kIGNvbXBvbmVudCB5b3UncmUgY29tcGFyaW5nXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFJldHVybiB2YWx1ZSB1c2FibGUgYnkgQXJyYXkucHJvdG90eXBlLnNvcnQoKS5cbiAqL1xuZnVuY3Rpb24gbW91bnREZXB0aENvbXBhcmF0b3IoYzEsIGMyKSB7XG4gIHJldHVybiBjMS5fbW91bnREZXB0aCAtIGMyLl9tb3VudERlcHRoO1xufVxuXG5mdW5jdGlvbiBydW5CYXRjaGVkVXBkYXRlcyh0cmFuc2FjdGlvbikge1xuICB2YXIgbGVuID0gdHJhbnNhY3Rpb24uZGlydHlDb21wb25lbnRzTGVuZ3RoO1xuICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgIGxlbiA9PT0gZGlydHlDb21wb25lbnRzLmxlbmd0aCxcbiAgICAnRXhwZWN0ZWQgZmx1c2ggdHJhbnNhY3Rpb25cXCdzIHN0b3JlZCBkaXJ0eS1jb21wb25lbnRzIGxlbmd0aCAoJXMpIHRvICcgK1xuICAgICdtYXRjaCBkaXJ0eS1jb21wb25lbnRzIGFycmF5IGxlbmd0aCAoJXMpLicsXG4gICAgbGVuLFxuICAgIGRpcnR5Q29tcG9uZW50cy5sZW5ndGhcbiAgKSA6IGludmFyaWFudChsZW4gPT09IGRpcnR5Q29tcG9uZW50cy5sZW5ndGgpKTtcblxuICAvLyBTaW5jZSByZWNvbmNpbGluZyBhIGNvbXBvbmVudCBoaWdoZXIgaW4gdGhlIG93bmVyIGhpZXJhcmNoeSB1c3VhbGx5IChub3RcbiAgLy8gYWx3YXlzIC0tIHNlZSBzaG91bGRDb21wb25lbnRVcGRhdGUoKSkgd2lsbCByZWNvbmNpbGUgY2hpbGRyZW4sIHJlY29uY2lsZVxuICAvLyB0aGVtIGJlZm9yZSB0aGVpciBjaGlsZHJlbiBieSBzb3J0aW5nIHRoZSBhcnJheS5cbiAgZGlydHlDb21wb25lbnRzLnNvcnQobW91bnREZXB0aENvbXBhcmF0b3IpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAvLyBJZiBhIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQgYmVmb3JlIHBlbmRpbmcgY2hhbmdlcyBhcHBseSwgaWdub3JlIHRoZW1cbiAgICAvLyBUT0RPOiBRdWV1ZSB1bm1vdW50cyBpbiB0aGUgc2FtZSBsaXN0IHRvIGF2b2lkIHRoaXMgaGFwcGVuaW5nIGF0IGFsbFxuICAgIHZhciBjb21wb25lbnQgPSBkaXJ0eUNvbXBvbmVudHNbaV07XG4gICAgaWYgKGNvbXBvbmVudC5pc01vdW50ZWQoKSkge1xuICAgICAgLy8gSWYgcGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5IGhhcHBlbnMgdG8gZW5xdWV1ZSBhbnkgbmV3IHVwZGF0ZXMsIHdlXG4gICAgICAvLyBzaG91bGRuJ3QgZXhlY3V0ZSB0aGUgY2FsbGJhY2tzIHVudGlsIHRoZSBuZXh0IHJlbmRlciBoYXBwZW5zLCBzb1xuICAgICAgLy8gc3Rhc2ggdGhlIGNhbGxiYWNrcyBmaXJzdFxuICAgICAgdmFyIGNhbGxiYWNrcyA9IGNvbXBvbmVudC5fcGVuZGluZ0NhbGxiYWNrcztcbiAgICAgIGNvbXBvbmVudC5fcGVuZGluZ0NhbGxiYWNrcyA9IG51bGw7XG4gICAgICBjb21wb25lbnQucGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5KHRyYW5zYWN0aW9uLnJlY29uY2lsZVRyYW5zYWN0aW9uKTtcblxuICAgICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNhbGxiYWNrcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHRyYW5zYWN0aW9uLmNhbGxiYWNrUXVldWUuZW5xdWV1ZShcbiAgICAgICAgICAgIGNhbGxiYWNrc1tqXSxcbiAgICAgICAgICAgIGNvbXBvbmVudFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGZsdXNoQmF0Y2hlZFVwZGF0ZXMgPSBSZWFjdFBlcmYubWVhc3VyZShcbiAgJ1JlYWN0VXBkYXRlcycsXG4gICdmbHVzaEJhdGNoZWRVcGRhdGVzJyxcbiAgZnVuY3Rpb24oKSB7XG4gICAgLy8gUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbidzIHdyYXBwZXJzIHdpbGwgY2xlYXIgdGhlIGRpcnR5Q29tcG9uZW50c1xuICAgIC8vIGFycmF5IGFuZCBwZXJmb3JtIGFueSB1cGRhdGVzIGVucXVldWVkIGJ5IG1vdW50LXJlYWR5IGhhbmRsZXJzIChpLmUuLFxuICAgIC8vIGNvbXBvbmVudERpZFVwZGF0ZSkgYnV0IHdlIG5lZWQgdG8gY2hlY2sgaGVyZSB0b28gaW4gb3JkZXIgdG8gY2F0Y2hcbiAgICAvLyB1cGRhdGVzIGVucXVldWVkIGJ5IHNldFN0YXRlIGNhbGxiYWNrcy5cbiAgICB3aGlsZSAoZGlydHlDb21wb25lbnRzLmxlbmd0aCkge1xuICAgICAgdmFyIHRyYW5zYWN0aW9uID0gUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbi5nZXRQb29sZWQoKTtcbiAgICAgIHRyYW5zYWN0aW9uLnBlcmZvcm0ocnVuQmF0Y2hlZFVwZGF0ZXMsIG51bGwsIHRyYW5zYWN0aW9uKTtcbiAgICAgIFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24ucmVsZWFzZSh0cmFuc2FjdGlvbik7XG4gICAgfVxuICB9XG4pO1xuXG4vKipcbiAqIE1hcmsgYSBjb21wb25lbnQgYXMgbmVlZGluZyBhIHJlcmVuZGVyLCBhZGRpbmcgYW4gb3B0aW9uYWwgY2FsbGJhY2sgdG8gYVxuICogbGlzdCBvZiBmdW5jdGlvbnMgd2hpY2ggd2lsbCBiZSBleGVjdXRlZCBvbmNlIHRoZSByZXJlbmRlciBvY2N1cnMuXG4gKi9cbmZ1bmN0aW9uIGVucXVldWVVcGRhdGUoY29tcG9uZW50LCBjYWxsYmFjaykge1xuICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICFjYWxsYmFjayB8fCB0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIixcbiAgICAnZW5xdWV1ZVVwZGF0ZSguLi4pOiBZb3UgY2FsbGVkIGBzZXRQcm9wc2AsIGByZXBsYWNlUHJvcHNgLCAnICtcbiAgICAnYHNldFN0YXRlYCwgYHJlcGxhY2VTdGF0ZWAsIG9yIGBmb3JjZVVwZGF0ZWAgd2l0aCBhIGNhbGxiYWNrIHRoYXQgJyArXG4gICAgJ2lzblxcJ3QgY2FsbGFibGUuJ1xuICApIDogaW52YXJpYW50KCFjYWxsYmFjayB8fCB0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikpO1xuICBlbnN1cmVJbmplY3RlZCgpO1xuXG4gIC8vIFZhcmlvdXMgcGFydHMgb2Ygb3VyIGNvZGUgKHN1Y2ggYXMgUmVhY3RDb21wb3NpdGVDb21wb25lbnQnc1xuICAvLyBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KSBhc3N1bWUgdGhhdCBjYWxscyB0byByZW5kZXIgYXJlbid0IG5lc3RlZDtcbiAgLy8gdmVyaWZ5IHRoYXQgdGhhdCdzIHRoZSBjYXNlLiAoVGhpcyBpcyBjYWxsZWQgYnkgZWFjaCB0b3AtbGV2ZWwgdXBkYXRlXG4gIC8vIGZ1bmN0aW9uLCBsaWtlIHNldFByb3BzLCBzZXRTdGF0ZSwgZm9yY2VVcGRhdGUsIGV0Yy47IGNyZWF0aW9uIGFuZFxuICAvLyBkZXN0cnVjdGlvbiBvZiB0b3AtbGV2ZWwgY29tcG9uZW50cyBpcyBndWFyZGVkIGluIFJlYWN0TW91bnQuKVxuICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybmluZyhcbiAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID09IG51bGwsXG4gICAgJ2VucXVldWVVcGRhdGUoKTogUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyAnICtcbiAgICAnYW5kIHN0YXRlOyB0cmlnZ2VyaW5nIG5lc3RlZCBjb21wb25lbnQgdXBkYXRlcyBmcm9tIHJlbmRlciBpcyBub3QgJyArXG4gICAgJ2FsbG93ZWQuIElmIG5lY2Vzc2FyeSwgdHJpZ2dlciBuZXN0ZWQgdXBkYXRlcyBpbiAnICtcbiAgICAnY29tcG9uZW50RGlkVXBkYXRlLidcbiAgKSA6IG51bGwpO1xuXG4gIGlmICghYmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcykge1xuICAgIGJhdGNoaW5nU3RyYXRlZ3kuYmF0Y2hlZFVwZGF0ZXMoZW5xdWV1ZVVwZGF0ZSwgY29tcG9uZW50LCBjYWxsYmFjayk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZGlydHlDb21wb25lbnRzLnB1c2goY29tcG9uZW50KTtcblxuICBpZiAoY2FsbGJhY2spIHtcbiAgICBpZiAoY29tcG9uZW50Ll9wZW5kaW5nQ2FsbGJhY2tzKSB7XG4gICAgICBjb21wb25lbnQuX3BlbmRpbmdDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBvbmVudC5fcGVuZGluZ0NhbGxiYWNrcyA9IFtjYWxsYmFja107XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdFVwZGF0ZXNJbmplY3Rpb24gPSB7XG4gIGluamVjdFJlY29uY2lsZVRyYW5zYWN0aW9uOiBmdW5jdGlvbihSZWNvbmNpbGVUcmFuc2FjdGlvbikge1xuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICBSZWNvbmNpbGVUcmFuc2FjdGlvbixcbiAgICAgICdSZWFjdFVwZGF0ZXM6IG11c3QgcHJvdmlkZSBhIHJlY29uY2lsZSB0cmFuc2FjdGlvbiBjbGFzcydcbiAgICApIDogaW52YXJpYW50KFJlY29uY2lsZVRyYW5zYWN0aW9uKSk7XG4gICAgUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24gPSBSZWNvbmNpbGVUcmFuc2FjdGlvbjtcbiAgfSxcblxuICBpbmplY3RCYXRjaGluZ1N0cmF0ZWd5OiBmdW5jdGlvbihfYmF0Y2hpbmdTdHJhdGVneSkge1xuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICBfYmF0Y2hpbmdTdHJhdGVneSxcbiAgICAgICdSZWFjdFVwZGF0ZXM6IG11c3QgcHJvdmlkZSBhIGJhdGNoaW5nIHN0cmF0ZWd5J1xuICAgICkgOiBpbnZhcmlhbnQoX2JhdGNoaW5nU3RyYXRlZ3kpKTtcbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgdHlwZW9mIF9iYXRjaGluZ1N0cmF0ZWd5LmJhdGNoZWRVcGRhdGVzID09PSAnZnVuY3Rpb24nLFxuICAgICAgJ1JlYWN0VXBkYXRlczogbXVzdCBwcm92aWRlIGEgYmF0Y2hlZFVwZGF0ZXMoKSBmdW5jdGlvbidcbiAgICApIDogaW52YXJpYW50KHR5cGVvZiBfYmF0Y2hpbmdTdHJhdGVneS5iYXRjaGVkVXBkYXRlcyA9PT0gJ2Z1bmN0aW9uJykpO1xuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICB0eXBlb2YgX2JhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXMgPT09ICdib29sZWFuJyxcbiAgICAgICdSZWFjdFVwZGF0ZXM6IG11c3QgcHJvdmlkZSBhbiBpc0JhdGNoaW5nVXBkYXRlcyBib29sZWFuIGF0dHJpYnV0ZSdcbiAgICApIDogaW52YXJpYW50KHR5cGVvZiBfYmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcyA9PT0gJ2Jvb2xlYW4nKSk7XG4gICAgYmF0Y2hpbmdTdHJhdGVneSA9IF9iYXRjaGluZ1N0cmF0ZWd5O1xuICB9XG59O1xuXG52YXIgUmVhY3RVcGRhdGVzID0ge1xuICAvKipcbiAgICogUmVhY3QgcmVmZXJlbmNlcyBgUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbmAgdXNpbmcgdGhpcyBwcm9wZXJ0eSBpbiBvcmRlclxuICAgKiB0byBhbGxvdyBkZXBlbmRlbmN5IGluamVjdGlvbi5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uOiBudWxsLFxuXG4gIGJhdGNoZWRVcGRhdGVzOiBiYXRjaGVkVXBkYXRlcyxcbiAgZW5xdWV1ZVVwZGF0ZTogZW5xdWV1ZVVwZGF0ZSxcbiAgZmx1c2hCYXRjaGVkVXBkYXRlczogZmx1c2hCYXRjaGVkVXBkYXRlcyxcbiAgaW5qZWN0aW9uOiBSZWFjdFVwZGF0ZXNJbmplY3Rpb25cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RVcGRhdGVzO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0V2l0aEFkZG9uc1xuICovXG5cbi8qKlxuICogVGhpcyBtb2R1bGUgZXhpc3RzIHB1cmVseSBpbiB0aGUgb3BlbiBzb3VyY2UgcHJvamVjdCwgYW5kIGlzIG1lYW50IGFzIGEgd2F5XG4gKiB0byBjcmVhdGUgYSBzZXBhcmF0ZSBzdGFuZGFsb25lIGJ1aWxkIG9mIFJlYWN0LiBUaGlzIGJ1aWxkIGhhcyBcImFkZG9uc1wiLCBvclxuICogZnVuY3Rpb25hbGl0eSB3ZSd2ZSBidWlsdCBhbmQgdGhpbmsgbWlnaHQgYmUgdXNlZnVsIGJ1dCBkb2Vzbid0IGhhdmUgYSBnb29kXG4gKiBwbGFjZSB0byBsaXZlIGluc2lkZSBSZWFjdCBjb3JlLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgTGlua2VkU3RhdGVNaXhpbiA9IHJlcXVpcmUoXCIuL0xpbmtlZFN0YXRlTWl4aW5cIik7XG52YXIgUmVhY3QgPSByZXF1aXJlKFwiLi9SZWFjdFwiKTtcbnZhciBSZWFjdENvbXBvbmVudFdpdGhQdXJlUmVuZGVyTWl4aW4gPVxuICByZXF1aXJlKFwiLi9SZWFjdENvbXBvbmVudFdpdGhQdXJlUmVuZGVyTWl4aW5cIik7XG52YXIgUmVhY3RDU1NUcmFuc2l0aW9uR3JvdXAgPSByZXF1aXJlKFwiLi9SZWFjdENTU1RyYW5zaXRpb25Hcm91cFwiKTtcbnZhciBSZWFjdFRyYW5zaXRpb25Hcm91cCA9IHJlcXVpcmUoXCIuL1JlYWN0VHJhbnNpdGlvbkdyb3VwXCIpO1xuXG52YXIgY3ggPSByZXF1aXJlKFwiLi9jeFwiKTtcbnZhciBjbG9uZVdpdGhQcm9wcyA9IHJlcXVpcmUoXCIuL2Nsb25lV2l0aFByb3BzXCIpO1xudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIuL3VwZGF0ZVwiKTtcblxuUmVhY3QuYWRkb25zID0ge1xuICBDU1NUcmFuc2l0aW9uR3JvdXA6IFJlYWN0Q1NTVHJhbnNpdGlvbkdyb3VwLFxuICBMaW5rZWRTdGF0ZU1peGluOiBMaW5rZWRTdGF0ZU1peGluLFxuICBQdXJlUmVuZGVyTWl4aW46IFJlYWN0Q29tcG9uZW50V2l0aFB1cmVSZW5kZXJNaXhpbixcbiAgVHJhbnNpdGlvbkdyb3VwOiBSZWFjdFRyYW5zaXRpb25Hcm91cCxcblxuICBjbGFzc1NldDogY3gsXG4gIGNsb25lV2l0aFByb3BzOiBjbG9uZVdpdGhQcm9wcyxcbiAgdXBkYXRlOiB1cGRhdGVcbn07XG5cbmlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgUmVhY3QuYWRkb25zLlBlcmYgPSByZXF1aXJlKFwiLi9SZWFjdERlZmF1bHRQZXJmXCIpO1xuICBSZWFjdC5hZGRvbnMuVGVzdFV0aWxzID0gcmVxdWlyZShcIi4vUmVhY3RUZXN0VXRpbHNcIik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3Q7XG5cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFNWR0RPTVByb3BlcnR5Q29uZmlnXG4gKi9cblxuLypqc2xpbnQgYml0d2lzZTogdHJ1ZSovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKFwiLi9ET01Qcm9wZXJ0eVwiKTtcblxudmFyIE1VU1RfVVNFX0FUVFJJQlVURSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5NVVNUX1VTRV9BVFRSSUJVVEU7XG5cbnZhciBTVkdET01Qcm9wZXJ0eUNvbmZpZyA9IHtcbiAgUHJvcGVydGllczoge1xuICAgIGN4OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgY3k6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBkOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZHg6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBkeTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZpbGw6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBmaWxsT3BhY2l0eTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZvbnRGYW1pbHk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBmb250U2l6ZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZ4OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZnk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBncmFkaWVudFRyYW5zZm9ybTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGdyYWRpZW50VW5pdHM6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBtYXJrZXJFbmQ6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBtYXJrZXJNaWQ6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBtYXJrZXJTdGFydDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIG9mZnNldDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIG9wYWNpdHk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBwYXR0ZXJuQ29udGVudFVuaXRzOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgcGF0dGVyblVuaXRzOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgcG9pbnRzOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgcHJlc2VydmVBc3BlY3RSYXRpbzogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHI6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICByeDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHJ5OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgc3ByZWFkTWV0aG9kOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgc3RvcENvbG9yOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgc3RvcE9wYWNpdHk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBzdHJva2U6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBzdHJva2VEYXNoYXJyYXk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBzdHJva2VMaW5lY2FwOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgc3Ryb2tlT3BhY2l0eTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHN0cm9rZVdpZHRoOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgdGV4dEFuY2hvcjogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHRyYW5zZm9ybTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHZlcnNpb246IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB2aWV3Qm94OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeDE6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4MjogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHg6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB5MTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHkyOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeTogTVVTVF9VU0VfQVRUUklCVVRFXG4gIH0sXG4gIERPTUF0dHJpYnV0ZU5hbWVzOiB7XG4gICAgZmlsbE9wYWNpdHk6ICdmaWxsLW9wYWNpdHknLFxuICAgIGZvbnRGYW1pbHk6ICdmb250LWZhbWlseScsXG4gICAgZm9udFNpemU6ICdmb250LXNpemUnLFxuICAgIGdyYWRpZW50VHJhbnNmb3JtOiAnZ3JhZGllbnRUcmFuc2Zvcm0nLFxuICAgIGdyYWRpZW50VW5pdHM6ICdncmFkaWVudFVuaXRzJyxcbiAgICBtYXJrZXJFbmQ6ICdtYXJrZXItZW5kJyxcbiAgICBtYXJrZXJNaWQ6ICdtYXJrZXItbWlkJyxcbiAgICBtYXJrZXJTdGFydDogJ21hcmtlci1zdGFydCcsXG4gICAgcGF0dGVybkNvbnRlbnRVbml0czogJ3BhdHRlcm5Db250ZW50VW5pdHMnLFxuICAgIHBhdHRlcm5Vbml0czogJ3BhdHRlcm5Vbml0cycsXG4gICAgcHJlc2VydmVBc3BlY3RSYXRpbzogJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLFxuICAgIHNwcmVhZE1ldGhvZDogJ3NwcmVhZE1ldGhvZCcsXG4gICAgc3RvcENvbG9yOiAnc3RvcC1jb2xvcicsXG4gICAgc3RvcE9wYWNpdHk6ICdzdG9wLW9wYWNpdHknLFxuICAgIHN0cm9rZURhc2hhcnJheTogJ3N0cm9rZS1kYXNoYXJyYXknLFxuICAgIHN0cm9rZUxpbmVjYXA6ICdzdHJva2UtbGluZWNhcCcsXG4gICAgc3Ryb2tlT3BhY2l0eTogJ3N0cm9rZS1vcGFjaXR5JyxcbiAgICBzdHJva2VXaWR0aDogJ3N0cm9rZS13aWR0aCcsXG4gICAgdGV4dEFuY2hvcjogJ3RleHQtYW5jaG9yJyxcbiAgICB2aWV3Qm94OiAndmlld0JveCdcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTVkdET01Qcm9wZXJ0eUNvbmZpZztcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTZWxlY3RFdmVudFBsdWdpblxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKFwiLi9FdmVudENvbnN0YW50c1wiKTtcbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZShcIi4vRXZlbnRQcm9wYWdhdG9yc1wiKTtcbnZhciBSZWFjdElucHV0U2VsZWN0aW9uID0gcmVxdWlyZShcIi4vUmVhY3RJbnB1dFNlbGVjdGlvblwiKTtcbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoXCIuL1N5bnRoZXRpY0V2ZW50XCIpO1xuXG52YXIgZ2V0QWN0aXZlRWxlbWVudCA9IHJlcXVpcmUoXCIuL2dldEFjdGl2ZUVsZW1lbnRcIik7XG52YXIgaXNUZXh0SW5wdXRFbGVtZW50ID0gcmVxdWlyZShcIi4vaXNUZXh0SW5wdXRFbGVtZW50XCIpO1xudmFyIGtleU9mID0gcmVxdWlyZShcIi4va2V5T2ZcIik7XG52YXIgc2hhbGxvd0VxdWFsID0gcmVxdWlyZShcIi4vc2hhbGxvd0VxdWFsXCIpO1xuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG5cbnZhciBldmVudFR5cGVzID0ge1xuICBzZWxlY3Q6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2Yoe29uU2VsZWN0OiBudWxsfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2Yoe29uU2VsZWN0Q2FwdHVyZTogbnVsbH0pXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFtcbiAgICAgIHRvcExldmVsVHlwZXMudG9wQmx1cixcbiAgICAgIHRvcExldmVsVHlwZXMudG9wQ29udGV4dE1lbnUsXG4gICAgICB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzLFxuICAgICAgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duLFxuICAgICAgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd24sXG4gICAgICB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlVXAsXG4gICAgICB0b3BMZXZlbFR5cGVzLnRvcFNlbGVjdGlvbkNoYW5nZVxuICAgIF1cbiAgfVxufTtcblxudmFyIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRJRCA9IG51bGw7XG52YXIgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG52YXIgbW91c2VEb3duID0gZmFsc2U7XG5cbi8qKlxuICogR2V0IGFuIG9iamVjdCB3aGljaCBpcyBhIHVuaXF1ZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gKlxuICogVGhlIHJldHVybiB2YWx1ZSB3aWxsIG5vdCBiZSBjb25zaXN0ZW50IGFjcm9zcyBub2RlcyBvciBicm93c2VycywgYnV0XG4gKiB0d28gaWRlbnRpY2FsIHNlbGVjdGlvbnMgb24gdGhlIHNhbWUgbm9kZSB3aWxsIHJldHVybiBpZGVudGljYWwgb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb24obm9kZSkge1xuICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBub2RlICYmXG4gICAgICBSZWFjdElucHV0U2VsZWN0aW9uLmhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhub2RlKSkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogbm9kZS5zZWxlY3Rpb25TdGFydCxcbiAgICAgIGVuZDogbm9kZS5zZWxlY3Rpb25FbmRcbiAgICB9O1xuICB9IGVsc2UgaWYgKGRvY3VtZW50LnNlbGVjdGlvbikge1xuICAgIHZhciByYW5nZSA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgIHJldHVybiB7XG4gICAgICBwYXJlbnRFbGVtZW50OiByYW5nZS5wYXJlbnRFbGVtZW50KCksXG4gICAgICB0ZXh0OiByYW5nZS50ZXh0LFxuICAgICAgdG9wOiByYW5nZS5ib3VuZGluZ1RvcCxcbiAgICAgIGxlZnQ6IHJhbmdlLmJvdW5kaW5nTGVmdFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICByZXR1cm4ge1xuICAgICAgYW5jaG9yTm9kZTogc2VsZWN0aW9uLmFuY2hvck5vZGUsXG4gICAgICBhbmNob3JPZmZzZXQ6IHNlbGVjdGlvbi5hbmNob3JPZmZzZXQsXG4gICAgICBmb2N1c05vZGU6IHNlbGVjdGlvbi5mb2N1c05vZGUsXG4gICAgICBmb2N1c09mZnNldDogc2VsZWN0aW9uLmZvY3VzT2Zmc2V0XG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFBvbGwgc2VsZWN0aW9uIHRvIHNlZSB3aGV0aGVyIGl0J3MgY2hhbmdlZC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4gez9TeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQpIHtcbiAgLy8gRW5zdXJlIHdlIGhhdmUgdGhlIHJpZ2h0IGVsZW1lbnQsIGFuZCB0aGF0IHRoZSB1c2VyIGlzIG5vdCBkcmFnZ2luZyBhXG4gIC8vIHNlbGVjdGlvbiAodGhpcyBtYXRjaGVzIG5hdGl2ZSBgc2VsZWN0YCBldmVudCBiZWhhdmlvcikuIEluIEhUTUw1LCBzZWxlY3RcbiAgLy8gZmlyZXMgb25seSBvbiBpbnB1dCBhbmQgdGV4dGFyZWEgdGh1cyBpZiB0aGVyZSdzIG5vIGZvY3VzZWQgZWxlbWVudCB3ZVxuICAvLyB3b24ndCBkaXNwYXRjaC5cbiAgaWYgKG1vdXNlRG93biB8fFxuICAgICAgYWN0aXZlRWxlbWVudCA9PSBudWxsIHx8XG4gICAgICBhY3RpdmVFbGVtZW50ICE9IGdldEFjdGl2ZUVsZW1lbnQoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIE9ubHkgZmlyZSB3aGVuIHNlbGVjdGlvbiBoYXMgYWN0dWFsbHkgY2hhbmdlZC5cbiAgdmFyIGN1cnJlbnRTZWxlY3Rpb24gPSBnZXRTZWxlY3Rpb24oYWN0aXZlRWxlbWVudCk7XG4gIGlmICghbGFzdFNlbGVjdGlvbiB8fCAhc2hhbGxvd0VxdWFsKGxhc3RTZWxlY3Rpb24sIGN1cnJlbnRTZWxlY3Rpb24pKSB7XG4gICAgbGFzdFNlbGVjdGlvbiA9IGN1cnJlbnRTZWxlY3Rpb247XG5cbiAgICB2YXIgc3ludGhldGljRXZlbnQgPSBTeW50aGV0aWNFdmVudC5nZXRQb29sZWQoXG4gICAgICBldmVudFR5cGVzLnNlbGVjdCxcbiAgICAgIGFjdGl2ZUVsZW1lbnRJRCxcbiAgICAgIG5hdGl2ZUV2ZW50XG4gICAgKTtcblxuICAgIHN5bnRoZXRpY0V2ZW50LnR5cGUgPSAnc2VsZWN0JztcbiAgICBzeW50aGV0aWNFdmVudC50YXJnZXQgPSBhY3RpdmVFbGVtZW50O1xuXG4gICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKHN5bnRoZXRpY0V2ZW50KTtcblxuICAgIHJldHVybiBzeW50aGV0aWNFdmVudDtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uU2VsZWN0YCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgc2VsZWN0IGV2ZW50c1xuICogYWNyb3NzIGZvcm0gZWxlbWVudHMuXG4gKlxuICogU3VwcG9ydGVkIGVsZW1lbnRzIGFyZTpcbiAqIC0gaW5wdXQgKHNlZSBgaXNUZXh0SW5wdXRFbGVtZW50YClcbiAqIC0gdGV4dGFyZWFcbiAqIC0gY29udGVudEVkaXRhYmxlXG4gKlxuICogVGhpcyBkaWZmZXJzIGZyb20gbmF0aXZlIGJyb3dzZXIgaW1wbGVtZW50YXRpb25zIGluIHRoZSBmb2xsb3dpbmcgd2F5czpcbiAqIC0gRmlyZXMgb24gY29udGVudEVkaXRhYmxlIGZpZWxkcyBhcyB3ZWxsIGFzIGlucHV0cy5cbiAqIC0gRmlyZXMgZm9yIGNvbGxhcHNlZCBzZWxlY3Rpb24uXG4gKiAtIEZpcmVzIGFmdGVyIHVzZXIgaW5wdXQuXG4gKi9cbnZhciBTZWxlY3RFdmVudFBsdWdpbiA9IHtcblxuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRvcExldmVsVGFyZ2V0IFRoZSBsaXN0ZW5pbmcgY29tcG9uZW50IHJvb3Qgbm9kZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVGFyZ2V0SUQgSUQgb2YgYHRvcExldmVsVGFyZ2V0YC5cbiAgICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICAgKiBAcmV0dXJuIHsqfSBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAgICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuZXh0cmFjdEV2ZW50c31cbiAgICovXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uKFxuICAgICAgdG9wTGV2ZWxUeXBlLFxuICAgICAgdG9wTGV2ZWxUYXJnZXQsXG4gICAgICB0b3BMZXZlbFRhcmdldElELFxuICAgICAgbmF0aXZlRXZlbnQpIHtcblxuICAgIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgICAvLyBUcmFjayB0aGUgaW5wdXQgbm9kZSB0aGF0IGhhcyBmb2N1cy5cbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BGb2N1czpcbiAgICAgICAgaWYgKGlzVGV4dElucHV0RWxlbWVudCh0b3BMZXZlbFRhcmdldCkgfHxcbiAgICAgICAgICAgIHRvcExldmVsVGFyZ2V0LmNvbnRlbnRFZGl0YWJsZSA9PT0gJ3RydWUnKSB7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudCA9IHRvcExldmVsVGFyZ2V0O1xuICAgICAgICAgIGFjdGl2ZUVsZW1lbnRJRCA9IHRvcExldmVsVGFyZ2V0SUQ7XG4gICAgICAgICAgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQmx1cjpcbiAgICAgICAgYWN0aXZlRWxlbWVudCA9IG51bGw7XG4gICAgICAgIGFjdGl2ZUVsZW1lbnRJRCA9IG51bGw7XG4gICAgICAgIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICBicmVhaztcblxuICAgICAgLy8gRG9uJ3QgZmlyZSB0aGUgZXZlbnQgd2hpbGUgdGhlIHVzZXIgaXMgZHJhZ2dpbmcuIFRoaXMgbWF0Y2hlcyB0aGVcbiAgICAgIC8vIHNlbWFudGljcyBvZiB0aGUgbmF0aXZlIHNlbGVjdCBldmVudC5cbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd246XG4gICAgICAgIG1vdXNlRG93biA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvbnRleHRNZW51OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlVXA6XG4gICAgICAgIG1vdXNlRG93biA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQpO1xuXG4gICAgICAvLyBDaHJvbWUgYW5kIElFIGZpcmUgbm9uLXN0YW5kYXJkIGV2ZW50IHdoZW4gc2VsZWN0aW9uIGlzIGNoYW5nZWQgKGFuZFxuICAgICAgLy8gc29tZXRpbWVzIHdoZW4gaXQgaGFzbid0KS5cbiAgICAgIC8vIEZpcmVmb3ggZG9lc24ndCBzdXBwb3J0IHNlbGVjdGlvbmNoYW5nZSwgc28gY2hlY2sgc2VsZWN0aW9uIHN0YXR1c1xuICAgICAgLy8gYWZ0ZXIgZWFjaCBrZXkgZW50cnkuIFRoZSBzZWxlY3Rpb24gY2hhbmdlcyBhZnRlciBrZXlkb3duIGFuZCBiZWZvcmVcbiAgICAgIC8vIGtleXVwLCBidXQgd2UgY2hlY2sgb24ga2V5ZG93biBhcyB3ZWxsIGluIHRoZSBjYXNlIG9mIGhvbGRpbmcgZG93biBhXG4gICAgICAvLyBrZXksIHdoZW4gbXVsdGlwbGUga2V5ZG93biBldmVudHMgYXJlIGZpcmVkIGJ1dCBvbmx5IG9uZSBrZXl1cCBpcy5cbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BTZWxlY3Rpb25DaGFuZ2U6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5RG93bjpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlVcDpcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50KTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2VsZWN0RXZlbnRQbHVnaW47XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU2VydmVyUmVhY3RSb290SW5kZXhcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogU2l6ZSBvZiB0aGUgcmVhY3RSb290IElEIHNwYWNlLiBXZSBnZW5lcmF0ZSByYW5kb20gbnVtYmVycyBmb3IgUmVhY3Qgcm9vdFxuICogSURzIGFuZCBpZiB0aGVyZSdzIGEgY29sbGlzaW9uIHRoZSBldmVudHMgYW5kIERPTSB1cGRhdGUgc3lzdGVtIHdpbGxcbiAqIGdldCBjb25mdXNlZC4gSW4gdGhlIGZ1dHVyZSB3ZSBuZWVkIGEgd2F5IHRvIGdlbmVyYXRlIEdVSURzIGJ1dCBmb3JcbiAqIG5vdyB0aGlzIHdpbGwgd29yayBvbiBhIHNtYWxsZXIgc2NhbGUuXG4gKi9cbnZhciBHTE9CQUxfTU9VTlRfUE9JTlRfTUFYID0gTWF0aC5wb3coMiwgNTMpO1xuXG52YXIgU2VydmVyUmVhY3RSb290SW5kZXggPSB7XG4gIGNyZWF0ZVJlYWN0Um9vdEluZGV4OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKE1hdGgucmFuZG9tKCkgKiBHTE9CQUxfTU9VTlRfUE9JTlRfTUFYKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXJ2ZXJSZWFjdFJvb3RJbmRleDtcbiIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU2ltcGxlRXZlbnRQbHVnaW5cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZShcIi4vRXZlbnRDb25zdGFudHNcIik7XG52YXIgRXZlbnRQbHVnaW5VdGlscyA9IHJlcXVpcmUoXCIuL0V2ZW50UGx1Z2luVXRpbHNcIik7XG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHJlcXVpcmUoXCIuL0V2ZW50UHJvcGFnYXRvcnNcIik7XG52YXIgU3ludGhldGljQ2xpcGJvYXJkRXZlbnQgPSByZXF1aXJlKFwiLi9TeW50aGV0aWNDbGlwYm9hcmRFdmVudFwiKTtcbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoXCIuL1N5bnRoZXRpY0V2ZW50XCIpO1xudmFyIFN5bnRoZXRpY0ZvY3VzRXZlbnQgPSByZXF1aXJlKFwiLi9TeW50aGV0aWNGb2N1c0V2ZW50XCIpO1xudmFyIFN5bnRoZXRpY0tleWJvYXJkRXZlbnQgPSByZXF1aXJlKFwiLi9TeW50aGV0aWNLZXlib2FyZEV2ZW50XCIpO1xudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSByZXF1aXJlKFwiLi9TeW50aGV0aWNNb3VzZUV2ZW50XCIpO1xudmFyIFN5bnRoZXRpY0RyYWdFdmVudCA9IHJlcXVpcmUoXCIuL1N5bnRoZXRpY0RyYWdFdmVudFwiKTtcbnZhciBTeW50aGV0aWNUb3VjaEV2ZW50ID0gcmVxdWlyZShcIi4vU3ludGhldGljVG91Y2hFdmVudFwiKTtcbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gcmVxdWlyZShcIi4vU3ludGhldGljVUlFdmVudFwiKTtcbnZhciBTeW50aGV0aWNXaGVlbEV2ZW50ID0gcmVxdWlyZShcIi4vU3ludGhldGljV2hlZWxFdmVudFwiKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcbnZhciBrZXlPZiA9IHJlcXVpcmUoXCIuL2tleU9mXCIpO1xuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG5cbnZhciBldmVudFR5cGVzID0ge1xuICBibHVyOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHtvbkJsdXI6IHRydWV9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7b25CbHVyQ2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBjbGljazoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7b25DbGljazogdHJ1ZX0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHtvbkNsaWNrQ2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBjb250ZXh0TWVudToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7b25Db250ZXh0TWVudTogdHJ1ZX0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHtvbkNvbnRleHRNZW51Q2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBjb3B5OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHtvbkNvcHk6IHRydWV9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7b25Db3B5Q2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBjdXQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2Yoe29uQ3V0OiB0cnVlfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2Yoe29uQ3V0Q2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBkb3VibGVDbGljazoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7b25Eb3VibGVDbGljazogdHJ1ZX0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHtvbkRvdWJsZUNsaWNrQ2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBkcmFnOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHtvbkRyYWc6IHRydWV9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7b25EcmFnQ2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBkcmFnRW5kOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHtvbkRyYWdFbmQ6IHRydWV9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7b25EcmFnRW5kQ2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBkcmFnRW50ZXI6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2Yoe29uRHJhZ0VudGVyOiB0cnVlfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2Yoe29uRHJhZ0VudGVyQ2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBkcmFnRXhpdDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7b25EcmFnRXhpdDogdHJ1ZX0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHtvbkRyYWdFeGl0Q2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBkcmFnTGVhdmU6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2Yoe29uRHJhZ0xlYXZlOiB0cnVlfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2Yoe29uRHJhZ0xlYXZlQ2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBkcmFnT3Zlcjoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7b25EcmFnT3ZlcjogdHJ1ZX0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHtvbkRyYWdPdmVyQ2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBkcmFnU3RhcnQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2Yoe29uRHJhZ1N0YXJ0OiB0cnVlfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2Yoe29uRHJhZ1N0YXJ0Q2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBkcm9wOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHtvbkRyb3A6IHRydWV9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7b25Ecm9wQ2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBmb2N1czoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7b25Gb2N1czogdHJ1ZX0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHtvbkZvY3VzQ2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBpbnB1dDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7b25JbnB1dDogdHJ1ZX0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHtvbklucHV0Q2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBrZXlEb3duOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHtvbktleURvd246IHRydWV9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7b25LZXlEb3duQ2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBrZXlQcmVzczoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7b25LZXlQcmVzczogdHJ1ZX0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHtvbktleVByZXNzQ2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBrZXlVcDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7b25LZXlVcDogdHJ1ZX0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHtvbktleVVwQ2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBsb2FkOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHtvbkxvYWQ6IHRydWV9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7b25Mb2FkQ2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBlcnJvcjoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7b25FcnJvcjogdHJ1ZX0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHtvbkVycm9yQ2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICAvLyBOb3RlOiBXZSBkbyBub3QgYWxsb3cgbGlzdGVuaW5nIHRvIG1vdXNlT3ZlciBldmVudHMuIEluc3RlYWQsIHVzZSB0aGVcbiAgLy8gb25Nb3VzZUVudGVyL29uTW91c2VMZWF2ZSBjcmVhdGVkIGJ5IGBFbnRlckxlYXZlRXZlbnRQbHVnaW5gLlxuICBtb3VzZURvd246IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2Yoe29uTW91c2VEb3duOiB0cnVlfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2Yoe29uTW91c2VEb3duQ2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBtb3VzZU1vdmU6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2Yoe29uTW91c2VNb3ZlOiB0cnVlfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2Yoe29uTW91c2VNb3ZlQ2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBtb3VzZU91dDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7b25Nb3VzZU91dDogdHJ1ZX0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHtvbk1vdXNlT3V0Q2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBtb3VzZU92ZXI6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2Yoe29uTW91c2VPdmVyOiB0cnVlfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2Yoe29uTW91c2VPdmVyQ2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBtb3VzZVVwOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHtvbk1vdXNlVXA6IHRydWV9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7b25Nb3VzZVVwQ2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBwYXN0ZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7b25QYXN0ZTogdHJ1ZX0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHtvblBhc3RlQ2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICByZXNldDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7b25SZXNldDogdHJ1ZX0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHtvblJlc2V0Q2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBzY3JvbGw6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2Yoe29uU2Nyb2xsOiB0cnVlfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2Yoe29uU2Nyb2xsQ2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICBzdWJtaXQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2Yoe29uU3VibWl0OiB0cnVlfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2Yoe29uU3VibWl0Q2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICB0b3VjaENhbmNlbDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7b25Ub3VjaENhbmNlbDogdHJ1ZX0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHtvblRvdWNoQ2FuY2VsQ2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICB0b3VjaEVuZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7b25Ub3VjaEVuZDogdHJ1ZX0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHtvblRvdWNoRW5kQ2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICB0b3VjaE1vdmU6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2Yoe29uVG91Y2hNb3ZlOiB0cnVlfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2Yoe29uVG91Y2hNb3ZlQ2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICB0b3VjaFN0YXJ0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHtvblRvdWNoU3RhcnQ6IHRydWV9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7b25Ub3VjaFN0YXJ0Q2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9LFxuICB3aGVlbDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7b25XaGVlbDogdHJ1ZX0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHtvbldoZWVsQ2FwdHVyZTogdHJ1ZX0pXG4gICAgfVxuICB9XG59O1xuXG52YXIgdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnID0ge1xuICB0b3BCbHVyOiAgICAgICAgZXZlbnRUeXBlcy5ibHVyLFxuICB0b3BDbGljazogICAgICAgZXZlbnRUeXBlcy5jbGljayxcbiAgdG9wQ29udGV4dE1lbnU6IGV2ZW50VHlwZXMuY29udGV4dE1lbnUsXG4gIHRvcENvcHk6ICAgICAgICBldmVudFR5cGVzLmNvcHksXG4gIHRvcEN1dDogICAgICAgICBldmVudFR5cGVzLmN1dCxcbiAgdG9wRG91YmxlQ2xpY2s6IGV2ZW50VHlwZXMuZG91YmxlQ2xpY2ssXG4gIHRvcERyYWc6ICAgICAgICBldmVudFR5cGVzLmRyYWcsXG4gIHRvcERyYWdFbmQ6ICAgICBldmVudFR5cGVzLmRyYWdFbmQsXG4gIHRvcERyYWdFbnRlcjogICBldmVudFR5cGVzLmRyYWdFbnRlcixcbiAgdG9wRHJhZ0V4aXQ6ICAgIGV2ZW50VHlwZXMuZHJhZ0V4aXQsXG4gIHRvcERyYWdMZWF2ZTogICBldmVudFR5cGVzLmRyYWdMZWF2ZSxcbiAgdG9wRHJhZ092ZXI6ICAgIGV2ZW50VHlwZXMuZHJhZ092ZXIsXG4gIHRvcERyYWdTdGFydDogICBldmVudFR5cGVzLmRyYWdTdGFydCxcbiAgdG9wRHJvcDogICAgICAgIGV2ZW50VHlwZXMuZHJvcCxcbiAgdG9wRXJyb3I6ICAgICAgIGV2ZW50VHlwZXMuZXJyb3IsXG4gIHRvcEZvY3VzOiAgICAgICBldmVudFR5cGVzLmZvY3VzLFxuICB0b3BJbnB1dDogICAgICAgZXZlbnRUeXBlcy5pbnB1dCxcbiAgdG9wS2V5RG93bjogICAgIGV2ZW50VHlwZXMua2V5RG93bixcbiAgdG9wS2V5UHJlc3M6ICAgIGV2ZW50VHlwZXMua2V5UHJlc3MsXG4gIHRvcEtleVVwOiAgICAgICBldmVudFR5cGVzLmtleVVwLFxuICB0b3BMb2FkOiAgICAgICAgZXZlbnRUeXBlcy5sb2FkLFxuICB0b3BNb3VzZURvd246ICAgZXZlbnRUeXBlcy5tb3VzZURvd24sXG4gIHRvcE1vdXNlTW92ZTogICBldmVudFR5cGVzLm1vdXNlTW92ZSxcbiAgdG9wTW91c2VPdXQ6ICAgIGV2ZW50VHlwZXMubW91c2VPdXQsXG4gIHRvcE1vdXNlT3ZlcjogICBldmVudFR5cGVzLm1vdXNlT3ZlcixcbiAgdG9wTW91c2VVcDogICAgIGV2ZW50VHlwZXMubW91c2VVcCxcbiAgdG9wUGFzdGU6ICAgICAgIGV2ZW50VHlwZXMucGFzdGUsXG4gIHRvcFJlc2V0OiAgICAgICBldmVudFR5cGVzLnJlc2V0LFxuICB0b3BTY3JvbGw6ICAgICAgZXZlbnRUeXBlcy5zY3JvbGwsXG4gIHRvcFN1Ym1pdDogICAgICBldmVudFR5cGVzLnN1Ym1pdCxcbiAgdG9wVG91Y2hDYW5jZWw6IGV2ZW50VHlwZXMudG91Y2hDYW5jZWwsXG4gIHRvcFRvdWNoRW5kOiAgICBldmVudFR5cGVzLnRvdWNoRW5kLFxuICB0b3BUb3VjaE1vdmU6ICAgZXZlbnRUeXBlcy50b3VjaE1vdmUsXG4gIHRvcFRvdWNoU3RhcnQ6ICBldmVudFR5cGVzLnRvdWNoU3RhcnQsXG4gIHRvcFdoZWVsOiAgICAgICBldmVudFR5cGVzLndoZWVsXG59O1xuXG5mb3IgKHZhciB0b3BMZXZlbFR5cGUgaW4gdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnKSB7XG4gIHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZ1t0b3BMZXZlbFR5cGVdLmRlcGVuZGVuY2llcyA9IFt0b3BMZXZlbFR5cGVdO1xufVxuXG52YXIgU2ltcGxlRXZlbnRQbHVnaW4gPSB7XG5cbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICAvKipcbiAgICogU2FtZSBhcyB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiwgZXhjZXB0IGNhbmNlbHMgdGhlIGV2ZW50IHdoZW4gcmV0dXJuXG4gICAqIHZhbHVlIGlzIGZhbHNlLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gRXZlbnQgdG8gYmUgZGlzcGF0Y2hlZC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gQXBwbGljYXRpb24tbGV2ZWwgY2FsbGJhY2suXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkb21JRCBET00gSUQgdG8gcGFzcyB0byB0aGUgY2FsbGJhY2suXG4gICAqL1xuICBleGVjdXRlRGlzcGF0Y2g6IGZ1bmN0aW9uKGV2ZW50LCBsaXN0ZW5lciwgZG9tSUQpIHtcbiAgICB2YXIgcmV0dXJuVmFsdWUgPSBFdmVudFBsdWdpblV0aWxzLmV4ZWN1dGVEaXNwYXRjaChldmVudCwgbGlzdGVuZXIsIGRvbUlEKTtcbiAgICBpZiAocmV0dXJuVmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRvcExldmVsVGFyZ2V0IFRoZSBsaXN0ZW5pbmcgY29tcG9uZW50IHJvb3Qgbm9kZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVGFyZ2V0SUQgSUQgb2YgYHRvcExldmVsVGFyZ2V0YC5cbiAgICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICAgKiBAcmV0dXJuIHsqfSBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAgICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuZXh0cmFjdEV2ZW50c31cbiAgICovXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uKFxuICAgICAgdG9wTGV2ZWxUeXBlLFxuICAgICAgdG9wTGV2ZWxUYXJnZXQsXG4gICAgICB0b3BMZXZlbFRhcmdldElELFxuICAgICAgbmF0aXZlRXZlbnQpIHtcbiAgICB2YXIgZGlzcGF0Y2hDb25maWcgPSB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWdbdG9wTGV2ZWxUeXBlXTtcbiAgICBpZiAoIWRpc3BhdGNoQ29uZmlnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIEV2ZW50Q29uc3RydWN0b3I7XG4gICAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BJbnB1dDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BMb2FkOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEVycm9yOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFJlc2V0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFN1Ym1pdDpcbiAgICAgICAgLy8gSFRNTCBFdmVudHNcbiAgICAgICAgLy8gQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9pbmRleC5odG1sI2V2ZW50cy0wXG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3M6XG4gICAgICAgIC8vIEZpcmVGb3ggY3JlYXRlcyBhIGtleXByZXNzIGV2ZW50IGZvciBmdW5jdGlvbiBrZXlzIHRvby4gVGhpcyByZW1vdmVzXG4gICAgICAgIC8vIHRoZSB1bndhbnRlZCBrZXlwcmVzcyBldmVudHMuXG4gICAgICAgIGlmIChuYXRpdmVFdmVudC5jaGFyQ29kZSA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleVVwOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljS2V5Ym9hcmRFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQmx1cjpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BGb2N1czpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0ZvY3VzRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENsaWNrOlxuICAgICAgICAvLyBGaXJlZm94IGNyZWF0ZXMgYSBjbGljayBldmVudCBvbiByaWdodCBtb3VzZSBjbGlja3MuIFRoaXMgcmVtb3ZlcyB0aGVcbiAgICAgICAgLy8gdW53YW50ZWQgY2xpY2sgZXZlbnRzLlxuICAgICAgICBpZiAobmF0aXZlRXZlbnQuYnV0dG9uID09PSAyKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvbnRleHRNZW51OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERvdWJsZUNsaWNrOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93bjpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU1vdmU6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VPdXQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VPdmVyOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlVXA6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNNb3VzZUV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcmFnOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWdFbmQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJhZ0VudGVyOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWdFeGl0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWdMZWF2ZTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcmFnT3ZlcjpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcmFnU3RhcnQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJvcDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0RyYWdFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVG91Y2hDYW5jZWw6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVG91Y2hFbmQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVG91Y2hNb3ZlOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFRvdWNoU3RhcnQ6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNUb3VjaEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BTY3JvbGw6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNVSUV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BXaGVlbDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1doZWVsRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvcHk6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ3V0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFBhc3RlOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljQ2xpcGJvYXJkRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgRXZlbnRDb25zdHJ1Y3RvcixcbiAgICAgICdTaW1wbGVFdmVudFBsdWdpbjogVW5oYW5kbGVkIGV2ZW50IHR5cGUsIGAlc2AuJyxcbiAgICAgIHRvcExldmVsVHlwZVxuICAgICkgOiBpbnZhcmlhbnQoRXZlbnRDb25zdHJ1Y3RvcikpO1xuICAgIHZhciBldmVudCA9IEV2ZW50Q29uc3RydWN0b3IuZ2V0UG9vbGVkKFxuICAgICAgZGlzcGF0Y2hDb25maWcsXG4gICAgICB0b3BMZXZlbFRhcmdldElELFxuICAgICAgbmF0aXZlRXZlbnRcbiAgICApO1xuICAgIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2ltcGxlRXZlbnRQbHVnaW47XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNDbGlwYm9hcmRFdmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZShcIi4vU3ludGhldGljRXZlbnRcIik7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jbGlwYm9hcmQtYXBpcy9cbiAqL1xudmFyIENsaXBib2FyZEV2ZW50SW50ZXJmYWNlID0ge1xuICBjbGlwYm9hcmREYXRhOiBmdW5jdGlvbihldmVudCkge1xuICAgIHJldHVybiAoXG4gICAgICAnY2xpcGJvYXJkRGF0YScgaW4gZXZlbnQgP1xuICAgICAgICBldmVudC5jbGlwYm9hcmREYXRhIDpcbiAgICAgICAgd2luZG93LmNsaXBib2FyZERhdGFcbiAgICApO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNDbGlwYm9hcmRFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50KSB7XG4gIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCk7XG59XG5cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNDbGlwYm9hcmRFdmVudCwgQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50O1xuXG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljQ29tcG9zaXRpb25FdmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZShcIi4vU3ludGhldGljRXZlbnRcIik7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1jb21wb3NpdGlvbmV2ZW50c1xuICovXG52YXIgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSA9IHtcbiAgZGF0YTogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljQ29tcG9zaXRpb25FdmVudChcbiAgZGlzcGF0Y2hDb25maWcsXG4gIGRpc3BhdGNoTWFya2VyLFxuICBuYXRpdmVFdmVudCkge1xuICBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQpO1xufVxuXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MoXG4gIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQsXG4gIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2Vcbik7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljQ29tcG9zaXRpb25FdmVudDtcblxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY0RyYWdFdmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSByZXF1aXJlKFwiLi9TeW50aGV0aWNNb3VzZUV2ZW50XCIpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRHJhZ0V2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIERyYWdFdmVudEludGVyZmFjZSA9IHtcbiAgZGF0YVRyYW5zZmVyOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNEcmFnRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCkge1xuICBTeW50aGV0aWNNb3VzZUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCk7XG59XG5cblN5bnRoZXRpY01vdXNlRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0RyYWdFdmVudCwgRHJhZ0V2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNEcmFnRXZlbnQ7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljRXZlbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoXCIuL1Bvb2xlZENsYXNzXCIpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoXCIuL2VtcHR5RnVuY3Rpb25cIik7XG52YXIgZ2V0RXZlbnRUYXJnZXQgPSByZXF1aXJlKFwiLi9nZXRFdmVudFRhcmdldFwiKTtcbnZhciBtZXJnZSA9IHJlcXVpcmUoXCIuL21lcmdlXCIpO1xudmFyIG1lcmdlSW50byA9IHJlcXVpcmUoXCIuL21lcmdlSW50b1wiKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIEV2ZW50SW50ZXJmYWNlID0ge1xuICB0eXBlOiBudWxsLFxuICB0YXJnZXQ6IGdldEV2ZW50VGFyZ2V0LFxuICAvLyBjdXJyZW50VGFyZ2V0IGlzIHNldCB3aGVuIGRpc3BhdGNoaW5nOyBubyB1c2UgaW4gY29weWluZyBpdCBoZXJlXG4gIGN1cnJlbnRUYXJnZXQ6IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsLFxuICBldmVudFBoYXNlOiBudWxsLFxuICBidWJibGVzOiBudWxsLFxuICBjYW5jZWxhYmxlOiBudWxsLFxuICB0aW1lU3RhbXA6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpO1xuICB9LFxuICBkZWZhdWx0UHJldmVudGVkOiBudWxsLFxuICBpc1RydXN0ZWQ6IG51bGxcbn07XG5cbi8qKlxuICogU3ludGhldGljIGV2ZW50cyBhcmUgZGlzcGF0Y2hlZCBieSBldmVudCBwbHVnaW5zLCB0eXBpY2FsbHkgaW4gcmVzcG9uc2UgdG8gYVxuICogdG9wLWxldmVsIGV2ZW50IGRlbGVnYXRpb24gaGFuZGxlci5cbiAqXG4gKiBUaGVzZSBzeXN0ZW1zIHNob3VsZCBnZW5lcmFsbHkgdXNlIHBvb2xpbmcgdG8gcmVkdWNlIHRoZSBmcmVxdWVuY3kgb2YgZ2FyYmFnZVxuICogY29sbGVjdGlvbi4gVGhlIHN5c3RlbSBzaG91bGQgY2hlY2sgYGlzUGVyc2lzdGVudGAgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlXG4gKiBldmVudCBzaG91bGQgYmUgcmVsZWFzZWQgaW50byB0aGUgcG9vbCBhZnRlciBiZWluZyBkaXNwYXRjaGVkLiBVc2VycyB0aGF0XG4gKiBuZWVkIGEgcGVyc2lzdGVkIGV2ZW50IHNob3VsZCBpbnZva2UgYHBlcnNpc3RgLlxuICpcbiAqIFN5bnRoZXRpYyBldmVudHMgKGFuZCBzdWJjbGFzc2VzKSBpbXBsZW1lbnQgdGhlIERPTSBMZXZlbCAzIEV2ZW50cyBBUEkgYnlcbiAqIG5vcm1hbGl6aW5nIGJyb3dzZXIgcXVpcmtzLiBTdWJjbGFzc2VzIGRvIG5vdCBuZWNlc3NhcmlseSBoYXZlIHRvIGltcGxlbWVudCBhXG4gKiBET00gaW50ZXJmYWNlOyBjdXN0b20gYXBwbGljYXRpb24tc3BlY2lmaWMgZXZlbnRzIGNhbiBhbHNvIHN1YmNsYXNzIHRoaXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50KSB7XG4gIHRoaXMuZGlzcGF0Y2hDb25maWcgPSBkaXNwYXRjaENvbmZpZztcbiAgdGhpcy5kaXNwYXRjaE1hcmtlciA9IGRpc3BhdGNoTWFya2VyO1xuICB0aGlzLm5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQ7XG5cbiAgdmFyIEludGVyZmFjZSA9IHRoaXMuY29uc3RydWN0b3IuSW50ZXJmYWNlO1xuICBmb3IgKHZhciBwcm9wTmFtZSBpbiBJbnRlcmZhY2UpIHtcbiAgICBpZiAoIUludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgbm9ybWFsaXplID0gSW50ZXJmYWNlW3Byb3BOYW1lXTtcbiAgICBpZiAobm9ybWFsaXplKSB7XG4gICAgICB0aGlzW3Byb3BOYW1lXSA9IG5vcm1hbGl6ZShuYXRpdmVFdmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNbcHJvcE5hbWVdID0gbmF0aXZlRXZlbnRbcHJvcE5hbWVdO1xuICAgIH1cbiAgfVxuXG4gIHZhciBkZWZhdWx0UHJldmVudGVkID0gbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCAhPSBudWxsID9cbiAgICBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkIDpcbiAgICBuYXRpdmVFdmVudC5yZXR1cm5WYWx1ZSA9PT0gZmFsc2U7XG4gIGlmIChkZWZhdWx0UHJldmVudGVkKSB7XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZTtcbiAgfVxuICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlO1xufVxuXG5tZXJnZUludG8oU3ludGhldGljRXZlbnQucHJvdG90eXBlLCB7XG5cbiAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgdmFyIGV2ZW50ID0gdGhpcy5uYXRpdmVFdmVudDtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCA/IGV2ZW50LnByZXZlbnREZWZhdWx0KCkgOiBldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0sXG5cbiAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbiA/IGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpIDogZXZlbnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdlIHJlbGVhc2UgYWxsIGRpc3BhdGNoZWQgYFN5bnRoZXRpY0V2ZW50YHMgYWZ0ZXIgZWFjaCBldmVudCBsb29wLCBhZGRpbmdcbiAgICogdGhlbSBiYWNrIGludG8gdGhlIHBvb2wuIFRoaXMgYWxsb3dzIGEgd2F5IHRvIGhvbGQgb250byBhIHJlZmVyZW5jZSB0aGF0XG4gICAqIHdvbid0IGJlIGFkZGVkIGJhY2sgaW50byB0aGUgcG9vbC5cbiAgICovXG4gIHBlcnNpc3Q6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaXNQZXJzaXN0ZW50ID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhpcyBzaG91bGQgbm90IGJlIHJlbGVhc2VkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc1BlcnNpc3RlbnQ6IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZSxcblxuICAvKipcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgYGRlc3RydWN0b3JgIG9uIGVhY2ggaW5zdGFuY2UgaXQgcmVsZWFzZXMuXG4gICAqL1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgSW50ZXJmYWNlID0gdGhpcy5jb25zdHJ1Y3Rvci5JbnRlcmZhY2U7XG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gSW50ZXJmYWNlKSB7XG4gICAgICB0aGlzW3Byb3BOYW1lXSA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuZGlzcGF0Y2hDb25maWcgPSBudWxsO1xuICAgIHRoaXMuZGlzcGF0Y2hNYXJrZXIgPSBudWxsO1xuICAgIHRoaXMubmF0aXZlRXZlbnQgPSBudWxsO1xuICB9XG5cbn0pO1xuXG5TeW50aGV0aWNFdmVudC5JbnRlcmZhY2UgPSBFdmVudEludGVyZmFjZTtcblxuLyoqXG4gKiBIZWxwZXIgdG8gcmVkdWNlIGJvaWxlcnBsYXRlIHdoZW4gY3JlYXRpbmcgc3ViY2xhc3Nlcy5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBDbGFzc1xuICogQHBhcmFtIHs/b2JqZWN0fSBJbnRlcmZhY2VcbiAqL1xuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzID0gZnVuY3Rpb24oQ2xhc3MsIEludGVyZmFjZSkge1xuICB2YXIgU3VwZXIgPSB0aGlzO1xuXG4gIHZhciBwcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN1cGVyLnByb3RvdHlwZSk7XG4gIG1lcmdlSW50byhwcm90b3R5cGUsIENsYXNzLnByb3RvdHlwZSk7XG4gIENsYXNzLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2xhc3M7XG5cbiAgQ2xhc3MuSW50ZXJmYWNlID0gbWVyZ2UoU3VwZXIuSW50ZXJmYWNlLCBJbnRlcmZhY2UpO1xuICBDbGFzcy5hdWdtZW50Q2xhc3MgPSBTdXBlci5hdWdtZW50Q2xhc3M7XG5cbiAgUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKENsYXNzLCBQb29sZWRDbGFzcy50aHJlZUFyZ3VtZW50UG9vbGVyKTtcbn07XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhTeW50aGV0aWNFdmVudCwgUG9vbGVkQ2xhc3MudGhyZWVBcmd1bWVudFBvb2xlcik7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljRXZlbnQ7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljRm9jdXNFdmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSByZXF1aXJlKFwiLi9TeW50aGV0aWNVSUV2ZW50XCIpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRm9jdXNFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBGb2N1c0V2ZW50SW50ZXJmYWNlID0ge1xuICByZWxhdGVkVGFyZ2V0OiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNGb2N1c0V2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQpIHtcbiAgU3ludGhldGljVUlFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNGb2N1c0V2ZW50LCBGb2N1c0V2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNGb2N1c0V2ZW50O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMyBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNJbnB1dEV2ZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKFwiLi9TeW50aGV0aWNFdmVudFwiKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMTMxMTA1XG4gKiAgICAgIC8jZXZlbnRzLWlucHV0ZXZlbnRzXG4gKi9cbnZhciBJbnB1dEV2ZW50SW50ZXJmYWNlID0ge1xuICBkYXRhOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNJbnB1dEV2ZW50KFxuICBkaXNwYXRjaENvbmZpZyxcbiAgZGlzcGF0Y2hNYXJrZXIsXG4gIG5hdGl2ZUV2ZW50KSB7XG4gIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCk7XG59XG5cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyhcbiAgU3ludGhldGljSW5wdXRFdmVudCxcbiAgSW5wdXRFdmVudEludGVyZmFjZVxuKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNJbnB1dEV2ZW50O1xuXG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljS2V5Ym9hcmRFdmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSByZXF1aXJlKFwiLi9TeW50aGV0aWNVSUV2ZW50XCIpO1xuXG52YXIgZ2V0RXZlbnRLZXkgPSByZXF1aXJlKFwiLi9nZXRFdmVudEtleVwiKTtcbnZhciBnZXRFdmVudE1vZGlmaWVyU3RhdGUgPSByZXF1aXJlKFwiLi9nZXRFdmVudE1vZGlmaWVyU3RhdGVcIik7XG5cbi8qKlxuICogQGludGVyZmFjZSBLZXlib2FyZEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIEtleWJvYXJkRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGtleTogZ2V0RXZlbnRLZXksXG4gIGxvY2F0aW9uOiBudWxsLFxuICBjdHJsS2V5OiBudWxsLFxuICBzaGlmdEtleTogbnVsbCxcbiAgYWx0S2V5OiBudWxsLFxuICBtZXRhS2V5OiBudWxsLFxuICByZXBlYXQ6IG51bGwsXG4gIGxvY2FsZTogbnVsbCxcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlLFxuICAvLyBMZWdhY3kgSW50ZXJmYWNlXG4gIGNoYXJDb2RlOiBmdW5jdGlvbihldmVudCkge1xuICAgIC8vIGBjaGFyQ29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleVByZXNzIGV2ZW50IGFuZCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHRoZSBhY3R1YWwgcHJpbnRhYmxlIGNoYXJhY3Rlci5cblxuICAgIC8vIEtleVByZXNzIGlzIGRlcHJlY2F0ZWQgYnV0IGl0cyByZXBsYWNlbWVudCBpcyBub3QgeWV0IGZpbmFsIGFuZCBub3RcbiAgICAvLyBpbXBsZW1lbnRlZCBpbiBhbnkgbWFqb3IgYnJvd3Nlci5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgICAgLy8gSUU4IGRvZXMgbm90IGltcGxlbWVudCBcImNoYXJDb2RlXCIsIGJ1dCBcImtleUNvZGVcIiBoYXMgdGhlIGNvcnJlY3QgdmFsdWUuXG4gICAgICByZXR1cm4gJ2NoYXJDb2RlJyBpbiBldmVudCA/IGV2ZW50LmNoYXJDb2RlIDogZXZlbnQua2V5Q29kZTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIGtleUNvZGU6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgLy8gYGtleUNvZGVgIGlzIHRoZSByZXN1bHQgb2YgYSBLZXlEb3duL1VwIGV2ZW50IGFuZCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHBoeXNpY2FsIGtleWJvYXJkIGtleS5cblxuICAgIC8vIFRoZSBhY3R1YWwgbWVhbmluZyBvZiB0aGUgdmFsdWUgZGVwZW5kcyBvbiB0aGUgdXNlcnMnIGtleWJvYXJkIGxheW91dFxuICAgIC8vIHdoaWNoIGNhbm5vdCBiZSBkZXRlY3RlZC4gQXNzdW1pbmcgdGhhdCBpdCBpcyBhIFVTIGtleWJvYXJkIGxheW91dFxuICAgIC8vIHByb3ZpZGVzIGEgc3VycHJpc2luZ2x5IGFjY3VyYXRlIG1hcHBpbmcgZm9yIFVTIGFuZCBFdXJvcGVhbiB1c2Vycy5cbiAgICAvLyBEdWUgdG8gdGhpcywgaXQgaXMgbGVmdCB0byB0aGUgdXNlciB0byBpbXBsZW1lbnQgYXQgdGhpcyB0aW1lLlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5ZG93bicgfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgcmV0dXJuIGV2ZW50LmtleUNvZGU7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LFxuICB3aGljaDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAvLyBgd2hpY2hgIGlzIGFuIGFsaWFzIGZvciBlaXRoZXIgYGtleUNvZGVgIG9yIGBjaGFyQ29kZWAgZGVwZW5kaW5nIG9uIHRoZVxuICAgIC8vIHR5cGUgb2YgdGhlIGV2ZW50LiBUaGVyZSBpcyBubyBuZWVkIHRvIGRldGVybWluZSB0aGUgdHlwZSBvZiB0aGUgZXZlbnRcbiAgICAvLyBhcyBga2V5Q29kZWAgYW5kIGBjaGFyQ29kZWAgYXJlIGVpdGhlciBhbGlhc2VkIG9yIGRlZmF1bHQgdG8gemVyby5cbiAgICByZXR1cm4gZXZlbnQua2V5Q29kZSB8fCBldmVudC5jaGFyQ29kZTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljS2V5Ym9hcmRFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50KSB7XG4gIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50KTtcbn1cblxuU3ludGhldGljVUlFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljS2V5Ym9hcmRFdmVudCwgS2V5Ym9hcmRFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljS2V5Ym9hcmRFdmVudDtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNNb3VzZUV2ZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoXCIuL1N5bnRoZXRpY1VJRXZlbnRcIik7XG52YXIgVmlld3BvcnRNZXRyaWNzID0gcmVxdWlyZShcIi4vVmlld3BvcnRNZXRyaWNzXCIpO1xuXG52YXIgZ2V0RXZlbnRNb2RpZmllclN0YXRlID0gcmVxdWlyZShcIi4vZ2V0RXZlbnRNb2RpZmllclN0YXRlXCIpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgTW91c2VFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBNb3VzZUV2ZW50SW50ZXJmYWNlID0ge1xuICBzY3JlZW5YOiBudWxsLFxuICBzY3JlZW5ZOiBudWxsLFxuICBjbGllbnRYOiBudWxsLFxuICBjbGllbnRZOiBudWxsLFxuICBjdHJsS2V5OiBudWxsLFxuICBzaGlmdEtleTogbnVsbCxcbiAgYWx0S2V5OiBudWxsLFxuICBtZXRhS2V5OiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIGJ1dHRvbjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAvLyBXZWJraXQsIEZpcmVmb3gsIElFOStcbiAgICAvLyB3aGljaDogIDEgMiAzXG4gICAgLy8gYnV0dG9uOiAwIDEgMiAoc3RhbmRhcmQpXG4gICAgdmFyIGJ1dHRvbiA9IGV2ZW50LmJ1dHRvbjtcbiAgICBpZiAoJ3doaWNoJyBpbiBldmVudCkge1xuICAgICAgcmV0dXJuIGJ1dHRvbjtcbiAgICB9XG4gICAgLy8gSUU8OVxuICAgIC8vIHdoaWNoOiAgdW5kZWZpbmVkXG4gICAgLy8gYnV0dG9uOiAwIDAgMFxuICAgIC8vIGJ1dHRvbjogMSA0IDIgKG9ubW91c2V1cClcbiAgICByZXR1cm4gYnV0dG9uID09PSAyID8gMiA6IGJ1dHRvbiA9PT0gNCA/IDEgOiAwO1xuICB9LFxuICBidXR0b25zOiBudWxsLFxuICByZWxhdGVkVGFyZ2V0OiBmdW5jdGlvbihldmVudCkge1xuICAgIHJldHVybiBldmVudC5yZWxhdGVkVGFyZ2V0IHx8IChcbiAgICAgIGV2ZW50LmZyb21FbGVtZW50ID09PSBldmVudC5zcmNFbGVtZW50ID9cbiAgICAgICAgZXZlbnQudG9FbGVtZW50IDpcbiAgICAgICAgZXZlbnQuZnJvbUVsZW1lbnRcbiAgICApO1xuICB9LFxuICAvLyBcIlByb3ByaWV0YXJ5XCIgSW50ZXJmYWNlLlxuICBwYWdlWDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICByZXR1cm4gJ3BhZ2VYJyBpbiBldmVudCA/XG4gICAgICBldmVudC5wYWdlWCA6XG4gICAgICBldmVudC5jbGllbnRYICsgVmlld3BvcnRNZXRyaWNzLmN1cnJlbnRTY3JvbGxMZWZ0O1xuICB9LFxuICBwYWdlWTogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICByZXR1cm4gJ3BhZ2VZJyBpbiBldmVudCA/XG4gICAgICBldmVudC5wYWdlWSA6XG4gICAgICBldmVudC5jbGllbnRZICsgVmlld3BvcnRNZXRyaWNzLmN1cnJlbnRTY3JvbGxUb3A7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY01vdXNlRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCkge1xuICBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY01vdXNlRXZlbnQsIE1vdXNlRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY01vdXNlRXZlbnQ7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljVG91Y2hFdmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSByZXF1aXJlKFwiLi9TeW50aGV0aWNVSUV2ZW50XCIpO1xuXG52YXIgZ2V0RXZlbnRNb2RpZmllclN0YXRlID0gcmVxdWlyZShcIi4vZ2V0RXZlbnRNb2RpZmllclN0YXRlXCIpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgVG91Y2hFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi90b3VjaC1ldmVudHMvXG4gKi9cbnZhciBUb3VjaEV2ZW50SW50ZXJmYWNlID0ge1xuICB0b3VjaGVzOiBudWxsLFxuICB0YXJnZXRUb3VjaGVzOiBudWxsLFxuICBjaGFuZ2VkVG91Y2hlczogbnVsbCxcbiAgYWx0S2V5OiBudWxsLFxuICBtZXRhS2V5OiBudWxsLFxuICBjdHJsS2V5OiBudWxsLFxuICBzaGlmdEtleTogbnVsbCxcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNUb3VjaEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQpIHtcbiAgU3ludGhldGljVUlFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNUb3VjaEV2ZW50LCBUb3VjaEV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNUb3VjaEV2ZW50O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY1VJRXZlbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoXCIuL1N5bnRoZXRpY0V2ZW50XCIpO1xuXG52YXIgZ2V0RXZlbnRUYXJnZXQgPSByZXF1aXJlKFwiLi9nZXRFdmVudFRhcmdldFwiKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIFVJRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgVUlFdmVudEludGVyZmFjZSA9IHtcbiAgdmlldzogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudmlldykge1xuICAgICAgcmV0dXJuIGV2ZW50LnZpZXc7XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGV2ZW50KTtcbiAgICBpZiAodGFyZ2V0ICE9IG51bGwgJiYgdGFyZ2V0LndpbmRvdyA9PT0gdGFyZ2V0KSB7XG4gICAgICAvLyB0YXJnZXQgaXMgYSB3aW5kb3cgb2JqZWN0XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIHZhciBkb2MgPSB0YXJnZXQub3duZXJEb2N1bWVudDtcbiAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSBgb3duZXJEb2N1bWVudGAgaXMgc29tZXRpbWVzIHVuZGVmaW5lZCBpbiBJRTguXG4gICAgaWYgKGRvYykge1xuICAgICAgcmV0dXJuIGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gd2luZG93O1xuICAgIH1cbiAgfSxcbiAgZGV0YWlsOiBmdW5jdGlvbihldmVudCkge1xuICAgIHJldHVybiBldmVudC5kZXRhaWwgfHwgMDtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1VJRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCkge1xuICBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQpO1xufVxuXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljVUlFdmVudCwgVUlFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljVUlFdmVudDtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNXaGVlbEV2ZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgU3ludGhldGljTW91c2VFdmVudCA9IHJlcXVpcmUoXCIuL1N5bnRoZXRpY01vdXNlRXZlbnRcIik7XG5cbi8qKlxuICogQGludGVyZmFjZSBXaGVlbEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIFdoZWVsRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRlbHRhWDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICByZXR1cm4gKFxuICAgICAgJ2RlbHRhWCcgaW4gZXZlbnQgPyBldmVudC5kZWx0YVggOlxuICAgICAgLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFYYCBmb3IgV2Via2l0IGFuZCBub3JtYWxpemUgKHJpZ2h0IGlzIHBvc2l0aXZlKS5cbiAgICAgICd3aGVlbERlbHRhWCcgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YVggOiAwXG4gICAgKTtcbiAgfSxcbiAgZGVsdGFZOiBmdW5jdGlvbihldmVudCkge1xuICAgIHJldHVybiAoXG4gICAgICAnZGVsdGFZJyBpbiBldmVudCA/IGV2ZW50LmRlbHRhWSA6XG4gICAgICAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YVlgIGZvciBXZWJraXQgYW5kIG5vcm1hbGl6ZSAoZG93biBpcyBwb3NpdGl2ZSkuXG4gICAgICAnd2hlZWxEZWx0YVknIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGFZIDpcbiAgICAgIC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhYCBmb3IgSUU8OSBhbmQgbm9ybWFsaXplIChkb3duIGlzIHBvc2l0aXZlKS5cbiAgICAgICd3aGVlbERlbHRhJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhIDogMFxuICAgICk7XG4gIH0sXG4gIGRlbHRhWjogbnVsbCxcblxuICAvLyBCcm93c2VycyB3aXRob3V0IFwiZGVsdGFNb2RlXCIgaXMgcmVwb3J0aW5nIGluIHJhdyB3aGVlbCBkZWx0YSB3aGVyZSBvbmVcbiAgLy8gbm90Y2ggb24gdGhlIHNjcm9sbCBpcyBhbHdheXMgKy8tIDEyMCwgcm91Z2hseSBlcXVpdmFsZW50IHRvIHBpeGVscy5cbiAgLy8gQSBnb29kIGFwcHJveGltYXRpb24gb2YgRE9NX0RFTFRBX0xJTkUgKDEpIGlzIDUlIG9mIHZpZXdwb3J0IHNpemUgb3JcbiAgLy8gfjQwIHBpeGVscywgZm9yIERPTV9ERUxUQV9TQ1JFRU4gKDIpIGl0IGlzIDg3LjUlIG9mIHZpZXdwb3J0IHNpemUuXG4gIGRlbHRhTW9kZTogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljTW91c2VFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljV2hlZWxFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50KSB7XG4gIFN5bnRoZXRpY01vdXNlRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50KTtcbn1cblxuU3ludGhldGljTW91c2VFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljV2hlZWxFdmVudCwgV2hlZWxFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljV2hlZWxFdmVudDtcbiIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgVHJhbnNhY3Rpb25cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcblxuLyoqXG4gKiBgVHJhbnNhY3Rpb25gIGNyZWF0ZXMgYSBibGFjayBib3ggdGhhdCBpcyBhYmxlIHRvIHdyYXAgYW55IG1ldGhvZCBzdWNoIHRoYXRcbiAqIGNlcnRhaW4gaW52YXJpYW50cyBhcmUgbWFpbnRhaW5lZCBiZWZvcmUgYW5kIGFmdGVyIHRoZSBtZXRob2QgaXMgaW52b2tlZFxuICogKEV2ZW4gaWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biB3aGlsZSBpbnZva2luZyB0aGUgd3JhcHBlZCBtZXRob2QpLiBXaG9ldmVyXG4gKiBpbnN0YW50aWF0ZXMgYSB0cmFuc2FjdGlvbiBjYW4gcHJvdmlkZSBlbmZvcmNlcnMgb2YgdGhlIGludmFyaWFudHMgYXRcbiAqIGNyZWF0aW9uIHRpbWUuIFRoZSBgVHJhbnNhY3Rpb25gIGNsYXNzIGl0c2VsZiB3aWxsIHN1cHBseSBvbmUgYWRkaXRpb25hbFxuICogYXV0b21hdGljIGludmFyaWFudCBmb3IgeW91IC0gdGhlIGludmFyaWFudCB0aGF0IGFueSB0cmFuc2FjdGlvbiBpbnN0YW5jZVxuICogc2hvdWxkIG5vdCBiZSBydW4gd2hpbGUgaXQgaXMgYWxyZWFkeSBiZWluZyBydW4uIFlvdSB3b3VsZCB0eXBpY2FsbHkgY3JlYXRlIGFcbiAqIHNpbmdsZSBpbnN0YW5jZSBvZiBhIGBUcmFuc2FjdGlvbmAgZm9yIHJldXNlIG11bHRpcGxlIHRpbWVzLCB0aGF0IHBvdGVudGlhbGx5XG4gKiBpcyB1c2VkIHRvIHdyYXAgc2V2ZXJhbCBkaWZmZXJlbnQgbWV0aG9kcy4gV3JhcHBlcnMgYXJlIGV4dHJlbWVseSBzaW1wbGUgLVxuICogdGhleSBvbmx5IHJlcXVpcmUgaW1wbGVtZW50aW5nIHR3byBtZXRob2RzLlxuICpcbiAqIDxwcmU+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgd3JhcHBlcnMgKGluamVjdGVkIGF0IGNyZWF0aW9uIHRpbWUpXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAgICAgICAgK1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS18LS0tLS0tLS0tLS0tLS0rXG4gKiAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgdiAgICAgICAgfCAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICAgICArLS0tLS0tLS0tLS0tLS0tKyAgIHwgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgKy0tfCAgICB3cmFwcGVyMSAgIHwtLS18LS0tLSsgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHwgICstLS0tLS0tLS0tLS0tLS0rICAgdiAgICB8ICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB8ICAgICAgICAgICstLS0tLS0tLS0tLS0tKyAgfCAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgICAgKy0tLS18ICAgd3JhcHBlcjIgIHwtLS0tLS0tLSsgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHwgICAgIHwgICAgKy0tLS0tLS0tLS0tLS0rICB8ICAgICB8ICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB8ICAgICB8ICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgdiAgICAgdiAgICAgICAgICAgICAgICAgICAgIHYgICAgIHYgICB8IHdyYXBwZXJcbiAqICAgICAgICAgICAgICAgICAgICB8ICstLS0rICstLS0rICAgKy0tLS0tLS0tLSsgICArLS0tKyArLS0tKyB8IGludmFyaWFudHNcbiAqIHBlcmZvcm0oYW55TWV0aG9kKSB8IHwgICB8IHwgICB8ICAgfCAgICAgICAgIHwgICB8ICAgfCB8ICAgfCB8IG1haW50YWluZWRcbiAqICstLS0tLS0tLS0tLS0tLS0tLT58LXwtLS18LXwtLS18LS0+fGFueU1ldGhvZHwtLS18LS0tfC18LS0tfC18LS0tLS0tLS0+XG4gKiAgICAgICAgICAgICAgICAgICAgfCB8ICAgfCB8ICAgfCAgIHwgICAgICAgICB8ICAgfCAgIHwgfCAgIHwgfFxuICogICAgICAgICAgICAgICAgICAgIHwgfCAgIHwgfCAgIHwgICB8ICAgICAgICAgfCAgIHwgICB8IHwgICB8IHxcbiAqICAgICAgICAgICAgICAgICAgICB8IHwgICB8IHwgICB8ICAgfCAgICAgICAgIHwgICB8ICAgfCB8ICAgfCB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCArLS0tKyArLS0tKyAgICstLS0tLS0tLS0rICAgKy0tLSsgKy0tLSsgfFxuICogICAgICAgICAgICAgICAgICAgIHwgIGluaXRpYWxpemUgICAgICAgICAgICAgICAgICAgIGNsb3NlICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gKiA8L3ByZT5cbiAqXG4gKiBVc2UgY2FzZXM6XG4gKiAtIFByZXNlcnZpbmcgdGhlIGlucHV0IHNlbGVjdGlvbiByYW5nZXMgYmVmb3JlL2FmdGVyIHJlY29uY2lsaWF0aW9uLlxuICogICBSZXN0b3Jpbmcgc2VsZWN0aW9uIGV2ZW4gaW4gdGhlIGV2ZW50IG9mIGFuIHVuZXhwZWN0ZWQgZXJyb3IuXG4gKiAtIERlYWN0aXZhdGluZyBldmVudHMgd2hpbGUgcmVhcnJhbmdpbmcgdGhlIERPTSwgcHJldmVudGluZyBibHVycy9mb2N1c2VzLFxuICogICB3aGlsZSBndWFyYW50ZWVpbmcgdGhhdCBhZnRlcndhcmRzLCB0aGUgZXZlbnQgc3lzdGVtIGlzIHJlYWN0aXZhdGVkLlxuICogLSBGbHVzaGluZyBhIHF1ZXVlIG9mIGNvbGxlY3RlZCBET00gbXV0YXRpb25zIHRvIHRoZSBtYWluIFVJIHRocmVhZCBhZnRlciBhXG4gKiAgIHJlY29uY2lsaWF0aW9uIHRha2VzIHBsYWNlIGluIGEgd29ya2VyIHRocmVhZC5cbiAqIC0gSW52b2tpbmcgYW55IGNvbGxlY3RlZCBgY29tcG9uZW50RGlkVXBkYXRlYCBjYWxsYmFja3MgYWZ0ZXIgcmVuZGVyaW5nIG5ld1xuICogICBjb250ZW50LlxuICogLSAoRnV0dXJlIHVzZSBjYXNlKTogV3JhcHBpbmcgcGFydGljdWxhciBmbHVzaGVzIG9mIHRoZSBgUmVhY3RXb3JrZXJgIHF1ZXVlXG4gKiAgIHRvIHByZXNlcnZlIHRoZSBgc2Nyb2xsVG9wYCAoYW4gYXV0b21hdGljIHNjcm9sbCBhd2FyZSBET00pLlxuICogLSAoRnV0dXJlIHVzZSBjYXNlKTogTGF5b3V0IGNhbGN1bGF0aW9ucyBiZWZvcmUgYW5kIGFmdGVyIERPTSB1cGF0ZXMuXG4gKlxuICogVHJhbnNhY3Rpb25hbCBwbHVnaW4gQVBJOlxuICogLSBBIG1vZHVsZSB0aGF0IGhhcyBhbiBgaW5pdGlhbGl6ZWAgbWV0aG9kIHRoYXQgcmV0dXJucyBhbnkgcHJlY29tcHV0YXRpb24uXG4gKiAtIGFuZCBhIGBjbG9zZWAgbWV0aG9kIHRoYXQgYWNjZXB0cyB0aGUgcHJlY29tcHV0YXRpb24uIGBjbG9zZWAgaXMgaW52b2tlZFxuICogICB3aGVuIHRoZSB3cmFwcGVkIHByb2Nlc3MgaXMgY29tcGxldGVkLCBvciBoYXMgZmFpbGVkLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8VHJhbnNhY3Rpb25hbFdyYXBwZXI+fSB0cmFuc2FjdGlvbldyYXBwZXIgV3JhcHBlciBtb2R1bGVzXG4gKiB0aGF0IGltcGxlbWVudCBgaW5pdGlhbGl6ZWAgYW5kIGBjbG9zZWAuXG4gKiBAcmV0dXJuIHtUcmFuc2FjdGlvbn0gU2luZ2xlIHRyYW5zYWN0aW9uIGZvciByZXVzZSBpbiB0aHJlYWQuXG4gKlxuICogQGNsYXNzIFRyYW5zYWN0aW9uXG4gKi9cbnZhciBNaXhpbiA9IHtcbiAgLyoqXG4gICAqIFNldHMgdXAgdGhpcyBpbnN0YW5jZSBzbyB0aGF0IGl0IGlzIHByZXBhcmVkIGZvciBjb2xsZWN0aW5nIG1ldHJpY3MuIERvZXNcbiAgICogc28gc3VjaCB0aGF0IHRoaXMgc2V0dXAgbWV0aG9kIG1heSBiZSB1c2VkIG9uIGFuIGluc3RhbmNlIHRoYXQgaXMgYWxyZWFkeVxuICAgKiBpbml0aWFsaXplZCwgaW4gYSB3YXkgdGhhdCBkb2VzIG5vdCBjb25zdW1lIGFkZGl0aW9uYWwgbWVtb3J5IHVwb24gcmV1c2UuXG4gICAqIFRoYXQgY2FuIGJlIHVzZWZ1bCBpZiB5b3UgZGVjaWRlIHRvIG1ha2UgeW91ciBzdWJjbGFzcyBvZiB0aGlzIG1peGluIGFcbiAgICogXCJQb29sZWRDbGFzc1wiLlxuICAgKi9cbiAgcmVpbml0aWFsaXplVHJhbnNhY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudHJhbnNhY3Rpb25XcmFwcGVycyA9IHRoaXMuZ2V0VHJhbnNhY3Rpb25XcmFwcGVycygpO1xuICAgIGlmICghdGhpcy53cmFwcGVySW5pdERhdGEpIHtcbiAgICAgIHRoaXMud3JhcHBlckluaXREYXRhID0gW107XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud3JhcHBlckluaXREYXRhLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIHRoaXMuX2lzSW5UcmFuc2FjdGlvbiA9IGZhbHNlO1xuICB9LFxuXG4gIF9pc0luVHJhbnNhY3Rpb246IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHJldHVybiB7QXJyYXk8VHJhbnNhY3Rpb25XcmFwcGVyPn0gQXJyYXkgb2YgdHJhbnNhY3Rpb24gd3JhcHBlcnMuXG4gICAqL1xuICBnZXRUcmFuc2FjdGlvbldyYXBwZXJzOiBudWxsLFxuXG4gIGlzSW5UcmFuc2FjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICEhdGhpcy5faXNJblRyYW5zYWN0aW9uO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyB0aGUgZnVuY3Rpb24gd2l0aGluIGEgc2FmZXR5IHdpbmRvdy4gVXNlIHRoaXMgZm9yIHRoZSB0b3AgbGV2ZWxcbiAgICogbWV0aG9kcyB0aGF0IHJlc3VsdCBpbiBsYXJnZSBhbW91bnRzIG9mIGNvbXB1dGF0aW9uL211dGF0aW9ucyB0aGF0IHdvdWxkXG4gICAqIG5lZWQgdG8gYmUgc2FmZXR5IGNoZWNrZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG1ldGhvZCBNZW1iZXIgb2Ygc2NvcGUgdG8gY2FsbC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHNjb3BlIFNjb3BlIHRvIGludm9rZSBmcm9tLlxuICAgKiBAcGFyYW0ge09iamVjdD89fSBhcmdzLi4uIEFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBtZXRob2QgKG9wdGlvbmFsKS5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBIZWxwcyBwcmV2ZW50IG5lZWQgdG8gYmluZCBpbiBtYW55IGNhc2VzLlxuICAgKiBAcmV0dXJuIFJldHVybiB2YWx1ZSBmcm9tIGBtZXRob2RgLlxuICAgKi9cbiAgcGVyZm9ybTogZnVuY3Rpb24obWV0aG9kLCBzY29wZSwgYSwgYiwgYywgZCwgZSwgZikge1xuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAhdGhpcy5pc0luVHJhbnNhY3Rpb24oKSxcbiAgICAgICdUcmFuc2FjdGlvbi5wZXJmb3JtKC4uLik6IENhbm5vdCBpbml0aWFsaXplIGEgdHJhbnNhY3Rpb24gd2hlbiB0aGVyZSAnICtcbiAgICAgICdpcyBhbHJlYWR5IGFuIG91dHN0YW5kaW5nIHRyYW5zYWN0aW9uLidcbiAgICApIDogaW52YXJpYW50KCF0aGlzLmlzSW5UcmFuc2FjdGlvbigpKSk7XG4gICAgdmFyIGVycm9yVGhyb3duO1xuICAgIHZhciByZXQ7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX2lzSW5UcmFuc2FjdGlvbiA9IHRydWU7XG4gICAgICAvLyBDYXRjaGluZyBlcnJvcnMgbWFrZXMgZGVidWdnaW5nIG1vcmUgZGlmZmljdWx0LCBzbyB3ZSBzdGFydCB3aXRoXG4gICAgICAvLyBlcnJvclRocm93biBzZXQgdG8gdHJ1ZSBiZWZvcmUgc2V0dGluZyBpdCB0byBmYWxzZSBhZnRlciBjYWxsaW5nXG4gICAgICAvLyBjbG9zZSAtLSBpZiBpdCdzIHN0aWxsIHNldCB0byB0cnVlIGluIHRoZSBmaW5hbGx5IGJsb2NrLCBpdCBtZWFuc1xuICAgICAgLy8gb25lIG9mIHRoZXNlIGNhbGxzIHRocmV3LlxuICAgICAgZXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgdGhpcy5pbml0aWFsaXplQWxsKDApO1xuICAgICAgcmV0ID0gbWV0aG9kLmNhbGwoc2NvcGUsIGEsIGIsIGMsIGQsIGUsIGYpO1xuICAgICAgZXJyb3JUaHJvd24gPSBmYWxzZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGVycm9yVGhyb3duKSB7XG4gICAgICAgICAgLy8gSWYgYG1ldGhvZGAgdGhyb3dzLCBwcmVmZXIgdG8gc2hvdyB0aGF0IHN0YWNrIHRyYWNlIG92ZXIgYW55IHRocm93blxuICAgICAgICAgIC8vIGJ5IGludm9raW5nIGBjbG9zZUFsbGAuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VBbGwoMCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFNpbmNlIGBtZXRob2RgIGRpZG4ndCB0aHJvdywgd2UgZG9uJ3Qgd2FudCB0byBzaWxlbmNlIHRoZSBleGNlcHRpb25cbiAgICAgICAgICAvLyBoZXJlLlxuICAgICAgICAgIHRoaXMuY2xvc2VBbGwoMCk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMuX2lzSW5UcmFuc2FjdGlvbiA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9LFxuXG4gIGluaXRpYWxpemVBbGw6IGZ1bmN0aW9uKHN0YXJ0SW5kZXgpIHtcbiAgICB2YXIgdHJhbnNhY3Rpb25XcmFwcGVycyA9IHRoaXMudHJhbnNhY3Rpb25XcmFwcGVycztcbiAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IHRyYW5zYWN0aW9uV3JhcHBlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3cmFwcGVyID0gdHJhbnNhY3Rpb25XcmFwcGVyc1tpXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIENhdGNoaW5nIGVycm9ycyBtYWtlcyBkZWJ1Z2dpbmcgbW9yZSBkaWZmaWN1bHQsIHNvIHdlIHN0YXJ0IHdpdGggdGhlXG4gICAgICAgIC8vIE9CU0VSVkVEX0VSUk9SIHN0YXRlIGJlZm9yZSBvdmVyd3JpdGluZyBpdCB3aXRoIHRoZSByZWFsIHJldHVybiB2YWx1ZVxuICAgICAgICAvLyBvZiBpbml0aWFsaXplIC0tIGlmIGl0J3Mgc3RpbGwgc2V0IHRvIE9CU0VSVkVEX0VSUk9SIGluIHRoZSBmaW5hbGx5XG4gICAgICAgIC8vIGJsb2NrLCBpdCBtZWFucyB3cmFwcGVyLmluaXRpYWxpemUgdGhyZXcuXG4gICAgICAgIHRoaXMud3JhcHBlckluaXREYXRhW2ldID0gVHJhbnNhY3Rpb24uT0JTRVJWRURfRVJST1I7XG4gICAgICAgIHRoaXMud3JhcHBlckluaXREYXRhW2ldID0gd3JhcHBlci5pbml0aWFsaXplID9cbiAgICAgICAgICB3cmFwcGVyLmluaXRpYWxpemUuY2FsbCh0aGlzKSA6XG4gICAgICAgICAgbnVsbDtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmICh0aGlzLndyYXBwZXJJbml0RGF0YVtpXSA9PT0gVHJhbnNhY3Rpb24uT0JTRVJWRURfRVJST1IpIHtcbiAgICAgICAgICAvLyBUaGUgaW5pdGlhbGl6ZXIgZm9yIHdyYXBwZXIgaSB0aHJldyBhbiBlcnJvcjsgaW5pdGlhbGl6ZSB0aGVcbiAgICAgICAgICAvLyByZW1haW5pbmcgd3JhcHBlcnMgYnV0IHNpbGVuY2UgYW55IGV4Y2VwdGlvbnMgZnJvbSB0aGVtIHRvIGVuc3VyZVxuICAgICAgICAgIC8vIHRoYXQgdGhlIGZpcnN0IGVycm9yIGlzIHRoZSBvbmUgdG8gYnViYmxlIHVwLlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemVBbGwoaSArIDEpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSW52b2tlcyBlYWNoIG9mIGB0aGlzLnRyYW5zYWN0aW9uV3JhcHBlcnMuY2xvc2VbaV1gIGZ1bmN0aW9ucywgcGFzc2luZyBpbnRvXG4gICAqIHRoZW0gdGhlIHJlc3BlY3RpdmUgcmV0dXJuIHZhbHVlcyBvZiBgdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzLmluaXRbaV1gXG4gICAqIChgY2xvc2VgcnMgdGhhdCBjb3JyZXNwb25kIHRvIGluaXRpYWxpemVycyB0aGF0IGZhaWxlZCB3aWxsIG5vdCBiZVxuICAgKiBpbnZva2VkKS5cbiAgICovXG4gIGNsb3NlQWxsOiBmdW5jdGlvbihzdGFydEluZGV4KSB7XG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgIHRoaXMuaXNJblRyYW5zYWN0aW9uKCksXG4gICAgICAnVHJhbnNhY3Rpb24uY2xvc2VBbGwoKTogQ2Fubm90IGNsb3NlIHRyYW5zYWN0aW9uIHdoZW4gbm9uZSBhcmUgb3Blbi4nXG4gICAgKSA6IGludmFyaWFudCh0aGlzLmlzSW5UcmFuc2FjdGlvbigpKSk7XG4gICAgdmFyIHRyYW5zYWN0aW9uV3JhcHBlcnMgPSB0aGlzLnRyYW5zYWN0aW9uV3JhcHBlcnM7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCB0cmFuc2FjdGlvbldyYXBwZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgd3JhcHBlciA9IHRyYW5zYWN0aW9uV3JhcHBlcnNbaV07XG4gICAgICB2YXIgaW5pdERhdGEgPSB0aGlzLndyYXBwZXJJbml0RGF0YVtpXTtcbiAgICAgIHZhciBlcnJvclRocm93bjtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIENhdGNoaW5nIGVycm9ycyBtYWtlcyBkZWJ1Z2dpbmcgbW9yZSBkaWZmaWN1bHQsIHNvIHdlIHN0YXJ0IHdpdGhcbiAgICAgICAgLy8gZXJyb3JUaHJvd24gc2V0IHRvIHRydWUgYmVmb3JlIHNldHRpbmcgaXQgdG8gZmFsc2UgYWZ0ZXIgY2FsbGluZ1xuICAgICAgICAvLyBjbG9zZSAtLSBpZiBpdCdzIHN0aWxsIHNldCB0byB0cnVlIGluIHRoZSBmaW5hbGx5IGJsb2NrLCBpdCBtZWFuc1xuICAgICAgICAvLyB3cmFwcGVyLmNsb3NlIHRocmV3LlxuICAgICAgICBlcnJvclRocm93biA9IHRydWU7XG4gICAgICAgIGlmIChpbml0RGF0YSAhPT0gVHJhbnNhY3Rpb24uT0JTRVJWRURfRVJST1IpIHtcbiAgICAgICAgICB3cmFwcGVyLmNsb3NlICYmIHdyYXBwZXIuY2xvc2UuY2FsbCh0aGlzLCBpbml0RGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3JUaHJvd24gPSBmYWxzZTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChlcnJvclRocm93bikge1xuICAgICAgICAgIC8vIFRoZSBjbG9zZXIgZm9yIHdyYXBwZXIgaSB0aHJldyBhbiBlcnJvcjsgY2xvc2UgdGhlIHJlbWFpbmluZ1xuICAgICAgICAgIC8vIHdyYXBwZXJzIGJ1dCBzaWxlbmNlIGFueSBleGNlcHRpb25zIGZyb20gdGhlbSB0byBlbnN1cmUgdGhhdCB0aGVcbiAgICAgICAgICAvLyBmaXJzdCBlcnJvciBpcyB0aGUgb25lIHRvIGJ1YmJsZSB1cC5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZUFsbChpICsgMSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLndyYXBwZXJJbml0RGF0YS5sZW5ndGggPSAwO1xuICB9XG59O1xuXG52YXIgVHJhbnNhY3Rpb24gPSB7XG5cbiAgTWl4aW46IE1peGluLFxuXG4gIC8qKlxuICAgKiBUb2tlbiB0byBsb29rIGZvciB0byBkZXRlcm1pbmUgaWYgYW4gZXJyb3Igb2NjdXJlZC5cbiAgICovXG4gIE9CU0VSVkVEX0VSUk9SOiB7fVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zYWN0aW9uO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgVmlld3BvcnRNZXRyaWNzXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbiA9IHJlcXVpcmUoXCIuL2dldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uXCIpO1xuXG52YXIgVmlld3BvcnRNZXRyaWNzID0ge1xuXG4gIGN1cnJlbnRTY3JvbGxMZWZ0OiAwLFxuXG4gIGN1cnJlbnRTY3JvbGxUb3A6IDAsXG5cbiAgcmVmcmVzaFNjcm9sbFZhbHVlczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNjcm9sbFBvc2l0aW9uID0gZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24od2luZG93KTtcbiAgICBWaWV3cG9ydE1ldHJpY3MuY3VycmVudFNjcm9sbExlZnQgPSBzY3JvbGxQb3NpdGlvbi54O1xuICAgIFZpZXdwb3J0TWV0cmljcy5jdXJyZW50U2Nyb2xsVG9wID0gc2Nyb2xsUG9zaXRpb24ueTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXdwb3J0TWV0cmljcztcbiIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgYWNjdW11bGF0ZVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xuXG4vKipcbiAqIEFjY3VtdWxhdGVzIGl0ZW1zIHRoYXQgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQuXG4gKlxuICogVGhpcyBpcyB1c2VkIHRvIGNvbnNlcnZlIG1lbW9yeSBieSBhdm9pZGluZyBhcnJheSBhbGxvY2F0aW9ucy5cbiAqXG4gKiBAcmV0dXJuIHsqfGFycmF5PCo+fSBBbiBhY2N1bXVsYXRpb24gb2YgaXRlbXMuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGUoY3VycmVudCwgbmV4dCkge1xuICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgIG5leHQgIT0gbnVsbCxcbiAgICAnYWNjdW11bGF0ZSguLi4pOiBBY2N1bXVsYXRlZCBpdGVtcyBtdXN0IGJlIG5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZC4nXG4gICkgOiBpbnZhcmlhbnQobmV4dCAhPSBudWxsKSk7XG4gIGlmIChjdXJyZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gbmV4dDtcbiAgfSBlbHNlIHtcbiAgICAvLyBCb3RoIGFyZSBub3QgZW1wdHkuIFdhcm5pbmc6IE5ldmVyIGNhbGwgeC5jb25jYXQoeSkgd2hlbiB5b3UgYXJlIG5vdFxuICAgIC8vIGNlcnRhaW4gdGhhdCB4IGlzIGFuIEFycmF5ICh4IGNvdWxkIGJlIGEgc3RyaW5nIHdpdGggY29uY2F0IG1ldGhvZCkuXG4gICAgdmFyIGN1cnJlbnRJc0FycmF5ID0gQXJyYXkuaXNBcnJheShjdXJyZW50KTtcbiAgICB2YXIgbmV4dElzQXJyYXkgPSBBcnJheS5pc0FycmF5KG5leHQpO1xuICAgIGlmIChjdXJyZW50SXNBcnJheSkge1xuICAgICAgcmV0dXJuIGN1cnJlbnQuY29uY2F0KG5leHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobmV4dElzQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIFtjdXJyZW50XS5jb25jYXQobmV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW2N1cnJlbnQsIG5leHRdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFjY3VtdWxhdGU7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBhZGxlcjMyXG4gKi9cblxuLyoganNsaW50IGJpdHdpc2U6dHJ1ZSAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIE1PRCA9IDY1NTIxO1xuXG4vLyBUaGlzIGlzIGEgY2xlYW4tcm9vbSBpbXBsZW1lbnRhdGlvbiBvZiBhZGxlcjMyIGRlc2lnbmVkIGZvciBkZXRlY3Rpbmdcbi8vIGlmIG1hcmt1cCBpcyBub3Qgd2hhdCB3ZSBleHBlY3QgaXQgdG8gYmUuIEl0IGRvZXMgbm90IG5lZWQgdG8gYmVcbi8vIGNyeXB0b2dyYXBoaWNhbGx5IHN0cm9uZywgb25seSByZWFzb25hYmxlIGdvb2QgYXQgZGV0ZWN0aW5nIGlmIG1hcmt1cFxuLy8gZ2VuZXJhdGVkIG9uIHRoZSBzZXJ2ZXIgaXMgZGlmZmVyZW50IHRoYW4gdGhhdCBvbiB0aGUgY2xpZW50LlxuZnVuY3Rpb24gYWRsZXIzMihkYXRhKSB7XG4gIHZhciBhID0gMTtcbiAgdmFyIGIgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICBhID0gKGEgKyBkYXRhLmNoYXJDb2RlQXQoaSkpICUgTU9EO1xuICAgIGIgPSAoYiArIGEpICUgTU9EO1xuICB9XG4gIHJldHVybiBhIHwgKGIgPDwgMTYpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFkbGVyMzI7XG4iLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqIEBwcm92aWRlc01vZHVsZSBjbG9uZVdpdGhQcm9wc1xuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgUmVhY3RQcm9wVHJhbnNmZXJlciA9IHJlcXVpcmUoXCIuL1JlYWN0UHJvcFRyYW5zZmVyZXJcIik7XG5cbnZhciBrZXlPZiA9IHJlcXVpcmUoXCIuL2tleU9mXCIpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKFwiLi93YXJuaW5nXCIpO1xuXG52YXIgQ0hJTERSRU5fUFJPUCA9IGtleU9mKHtjaGlsZHJlbjogbnVsbH0pO1xuXG4vKipcbiAqIFNvbWV0aW1lcyB5b3Ugd2FudCB0byBjaGFuZ2UgdGhlIHByb3BzIG9mIGEgY2hpbGQgcGFzc2VkIHRvIHlvdS4gVXN1YWxseVxuICogdGhpcyBpcyB0byBhZGQgYSBDU1MgY2xhc3MuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGNoaWxkIGNoaWxkIGNvbXBvbmVudCB5b3UnZCBsaWtlIHRvIGNsb25lXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgcHJvcHMgeW91J2QgbGlrZSB0byBtb2RpZnkuIFRoZXkgd2lsbCBiZSBtZXJnZWRcbiAqIGFzIGlmIHlvdSB1c2VkIGB0cmFuc2ZlclByb3BzVG8oKWAuXG4gKiBAcmV0dXJuIHtvYmplY3R9IGEgY2xvbmUgb2YgY2hpbGQgd2l0aCBwcm9wcyBtZXJnZWQgaW4uXG4gKi9cbmZ1bmN0aW9uIGNsb25lV2l0aFByb3BzKGNoaWxkLCBwcm9wcykge1xuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcoXG4gICAgICAhY2hpbGQucHJvcHMucmVmLFxuICAgICAgJ1lvdSBhcmUgY2FsbGluZyBjbG9uZVdpdGhQcm9wcygpIG9uIGEgY2hpbGQgd2l0aCBhIHJlZi4gVGhpcyBpcyAnICtcbiAgICAgICdkYW5nZXJvdXMgYmVjYXVzZSB5b3VcXCdyZSBjcmVhdGluZyBhIG5ldyBjaGlsZCB3aGljaCB3aWxsIG5vdCBiZSAnICtcbiAgICAgICdhZGRlZCBhcyBhIHJlZiB0byBpdHMgcGFyZW50LidcbiAgICApIDogbnVsbCk7XG4gIH1cblxuICB2YXIgbmV3UHJvcHMgPSBSZWFjdFByb3BUcmFuc2ZlcmVyLm1lcmdlUHJvcHMocHJvcHMsIGNoaWxkLnByb3BzKTtcblxuICAvLyBVc2UgYGNoaWxkLnByb3BzLmNoaWxkcmVuYCBpZiBpdCBpcyBwcm92aWRlZC5cbiAgaWYgKCFuZXdQcm9wcy5oYXNPd25Qcm9wZXJ0eShDSElMRFJFTl9QUk9QKSAmJlxuICAgICAgY2hpbGQucHJvcHMuaGFzT3duUHJvcGVydHkoQ0hJTERSRU5fUFJPUCkpIHtcbiAgICBuZXdQcm9wcy5jaGlsZHJlbiA9IGNoaWxkLnByb3BzLmNoaWxkcmVuO1xuICB9XG5cbiAgLy8gVGhlIGN1cnJlbnQgQVBJIGRvZXNuJ3QgcmV0YWluIF9vd25lciBhbmQgX2NvbnRleHQsIHdoaWNoIGlzIHdoeSB0aGlzXG4gIC8vIGRvZXNuJ3QgdXNlIFJlYWN0RGVzY3JpcHRvci5jbG9uZUFuZFJlcGxhY2VQcm9wcy5cbiAgcmV0dXJuIGNoaWxkLmNvbnN0cnVjdG9yKG5ld1Byb3BzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVdpdGhQcm9wcztcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGNvbnRhaW5zTm9kZVxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgaXNUZXh0Tm9kZSA9IHJlcXVpcmUoXCIuL2lzVGV4dE5vZGVcIik7XG5cbi8qanNsaW50IGJpdHdpc2U6dHJ1ZSAqL1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGdpdmVuIERPTSBub2RlIGNvbnRhaW5zIG9yIGlzIGFub3RoZXIgRE9NIG5vZGUuXG4gKlxuICogQHBhcmFtIHs/RE9NTm9kZX0gb3V0ZXJOb2RlIE91dGVyIERPTSBub2RlLlxuICogQHBhcmFtIHs/RE9NTm9kZX0gaW5uZXJOb2RlIElubmVyIERPTSBub2RlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb3V0ZXJOb2RlYCBjb250YWlucyBvciBpcyBgaW5uZXJOb2RlYC5cbiAqL1xuZnVuY3Rpb24gY29udGFpbnNOb2RlKG91dGVyTm9kZSwgaW5uZXJOb2RlKSB7XG4gIGlmICghb3V0ZXJOb2RlIHx8ICFpbm5lck5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAob3V0ZXJOb2RlID09PSBpbm5lck5vZGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChpc1RleHROb2RlKG91dGVyTm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAoaXNUZXh0Tm9kZShpbm5lck5vZGUpKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5zTm9kZShvdXRlck5vZGUsIGlubmVyTm9kZS5wYXJlbnROb2RlKTtcbiAgfSBlbHNlIGlmIChvdXRlck5vZGUuY29udGFpbnMpIHtcbiAgICByZXR1cm4gb3V0ZXJOb2RlLmNvbnRhaW5zKGlubmVyTm9kZSk7XG4gIH0gZWxzZSBpZiAob3V0ZXJOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuICEhKG91dGVyTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihpbm5lck5vZGUpICYgMTYpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRhaW5zTm9kZTtcbiIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgY29weVByb3BlcnRpZXNcbiAqL1xuXG4vKipcbiAqIENvcHkgcHJvcGVydGllcyBmcm9tIG9uZSBvciBtb3JlIG9iamVjdHMgKHVwIHRvIDUpIGludG8gdGhlIGZpcnN0IG9iamVjdC5cbiAqIFRoaXMgaXMgYSBzaGFsbG93IGNvcHkuIEl0IG11dGF0ZXMgdGhlIGZpcnN0IG9iamVjdCBhbmQgYWxzbyByZXR1cm5zIGl0LlxuICpcbiAqIE5PVEU6IGBhcmd1bWVudHNgIGhhcyBhIHZlcnkgc2lnbmlmaWNhbnQgcGVyZm9ybWFuY2UgcGVuYWx0eSwgd2hpY2ggaXMgd2h5XG4gKiB3ZSBkb24ndCBzdXBwb3J0IHVubGltaXRlZCBhcmd1bWVudHMuXG4gKi9cbmZ1bmN0aW9uIGNvcHlQcm9wZXJ0aWVzKG9iaiwgYSwgYiwgYywgZCwgZSwgZikge1xuICBvYmogPSBvYmogfHwge307XG5cbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgIGlmIChmKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvbyBtYW55IGFyZ3VtZW50cyBwYXNzZWQgdG8gY29weVByb3BlcnRpZXMnKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlXTtcbiAgdmFyIGlpID0gMCwgdjtcbiAgd2hpbGUgKGFyZ3NbaWldKSB7XG4gICAgdiA9IGFyZ3NbaWkrK107XG4gICAgZm9yICh2YXIgayBpbiB2KSB7XG4gICAgICBvYmpba10gPSB2W2tdO1xuICAgIH1cblxuICAgIC8vIElFIGlnbm9yZXMgdG9TdHJpbmcgaW4gb2JqZWN0IGl0ZXJhdGlvbi4uIFNlZTpcbiAgICAvLyB3ZWJyZWZsZWN0aW9uLmJsb2dzcG90LmNvbS8yMDA3LzA3L3F1aWNrLWZpeC1pbnRlcm5ldC1leHBsb3Jlci1hbmQuaHRtbFxuICAgIGlmICh2Lmhhc093blByb3BlcnR5ICYmIHYuaGFzT3duUHJvcGVydHkoJ3RvU3RyaW5nJykgJiZcbiAgICAgICAgKHR5cGVvZiB2LnRvU3RyaW5nICE9ICd1bmRlZmluZWQnKSAmJiAob2JqLnRvU3RyaW5nICE9PSB2LnRvU3RyaW5nKSkge1xuICAgICAgb2JqLnRvU3RyaW5nID0gdi50b1N0cmluZztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlQcm9wZXJ0aWVzO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgY3JlYXRlQXJyYXlGcm9tXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciB0b0FycmF5ID0gcmVxdWlyZShcIi4vdG9BcnJheVwiKTtcblxuLyoqXG4gKiBQZXJmb3JtIGEgaGV1cmlzdGljIHRlc3QgdG8gZGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBcImFycmF5LWxpa2VcIi5cbiAqXG4gKiAgIEEgbW9uayBhc2tlZCBKb3NodSwgYSBaZW4gbWFzdGVyLCBcIkhhcyBhIGRvZyBCdWRkaGEgbmF0dXJlP1wiXG4gKiAgIEpvc2h1IHJlcGxpZWQ6IFwiTXUuXCJcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGRldGVybWluZXMgaWYgaXRzIGFyZ3VtZW50IGhhcyBcImFycmF5IG5hdHVyZVwiOiBpdCByZXR1cm5zXG4gKiB0cnVlIGlmIHRoZSBhcmd1bWVudCBpcyBhbiBhY3R1YWwgYXJyYXksIGFuIGBhcmd1bWVudHMnIG9iamVjdCwgb3IgYW5cbiAqIEhUTUxDb2xsZWN0aW9uIChlLmcuIG5vZGUuY2hpbGROb2RlcyBvciBub2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCkpLlxuICpcbiAqIEl0IHdpbGwgcmV0dXJuIGZhbHNlIGZvciBvdGhlciBhcnJheS1saWtlIG9iamVjdHMgbGlrZSBGaWxlbGlzdC5cbiAqXG4gKiBAcGFyYW0geyp9IG9ialxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaGFzQXJyYXlOYXR1cmUob2JqKSB7XG4gIHJldHVybiAoXG4gICAgLy8gbm90IG51bGwvZmFsc2VcbiAgICAhIW9iaiAmJlxuICAgIC8vIGFycmF5cyBhcmUgb2JqZWN0cywgTm9kZUxpc3RzIGFyZSBmdW5jdGlvbnMgaW4gU2FmYXJpXG4gICAgKHR5cGVvZiBvYmogPT0gJ29iamVjdCcgfHwgdHlwZW9mIG9iaiA9PSAnZnVuY3Rpb24nKSAmJlxuICAgIC8vIHF1YWNrcyBsaWtlIGFuIGFycmF5XG4gICAgKCdsZW5ndGgnIGluIG9iaikgJiZcbiAgICAvLyBub3Qgd2luZG93XG4gICAgISgnc2V0SW50ZXJ2YWwnIGluIG9iaikgJiZcbiAgICAvLyBubyBET00gbm9kZSBzaG91bGQgYmUgY29uc2lkZXJlZCBhbiBhcnJheS1saWtlXG4gICAgLy8gYSAnc2VsZWN0JyBlbGVtZW50IGhhcyAnbGVuZ3RoJyBhbmQgJ2l0ZW0nIHByb3BlcnRpZXMgb24gSUU4XG4gICAgKHR5cGVvZiBvYmoubm9kZVR5cGUgIT0gJ251bWJlcicpICYmXG4gICAgKFxuICAgICAgLy8gYSByZWFsIGFycmF5XG4gICAgICAoLy8gSFRNTENvbGxlY3Rpb24vTm9kZUxpc3RcbiAgICAgIChBcnJheS5pc0FycmF5KG9iaikgfHxcbiAgICAgIC8vIGFyZ3VtZW50c1xuICAgICAgKCdjYWxsZWUnIGluIG9iaikgfHwgJ2l0ZW0nIGluIG9iaikpXG4gICAgKVxuICApO1xufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IHRoZSBhcmd1bWVudCBpcyBhbiBhcnJheSBieSB3cmFwcGluZyBpdCBpbiBhbiBhcnJheSBpZiBpdCBpcyBub3QuXG4gKiBDcmVhdGVzIGEgY29weSBvZiB0aGUgYXJndW1lbnQgaWYgaXQgaXMgYWxyZWFkeSBhbiBhcnJheS5cbiAqXG4gKiBUaGlzIGlzIG1vc3RseSB1c2VmdWwgaWRpb21hdGljYWxseTpcbiAqXG4gKiAgIHZhciBjcmVhdGVBcnJheUZyb20gPSByZXF1aXJlKCdjcmVhdGVBcnJheUZyb20nKTtcbiAqXG4gKiAgIGZ1bmN0aW9uIHRha2VzT25lT3JNb3JlVGhpbmdzKHRoaW5ncykge1xuICogICAgIHRoaW5ncyA9IGNyZWF0ZUFycmF5RnJvbSh0aGluZ3MpO1xuICogICAgIC4uLlxuICogICB9XG4gKlxuICogVGhpcyBhbGxvd3MgeW91IHRvIHRyZWF0IGB0aGluZ3MnIGFzIGFuIGFycmF5LCBidXQgYWNjZXB0IHNjYWxhcnMgaW4gdGhlIEFQSS5cbiAqXG4gKiBJZiB5b3UgbmVlZCB0byBjb252ZXJ0IGFuIGFycmF5LWxpa2Ugb2JqZWN0LCBsaWtlIGBhcmd1bWVudHNgLCBpbnRvIGFuIGFycmF5XG4gKiB1c2UgdG9BcnJheSBpbnN0ZWFkLlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQXJyYXlGcm9tKG9iaikge1xuICBpZiAoIWhhc0FycmF5TmF0dXJlKG9iaikpIHtcbiAgICByZXR1cm4gW29ial07XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIG9iai5zbGljZSgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0b0FycmF5KG9iaik7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVBcnJheUZyb207XG4iLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGNyZWF0ZUZ1bGxQYWdlQ29tcG9uZW50XG4gKiBAdHlwZWNoZWNrc1xuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vLyBEZWZlYXQgY2lyY3VsYXIgcmVmZXJlbmNlcyBieSByZXF1aXJpbmcgdGhpcyBkaXJlY3RseS5cbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCA9IHJlcXVpcmUoXCIuL1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50XCIpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xuXG4vKipcbiAqIENyZWF0ZSBhIGNvbXBvbmVudCB0aGF0IHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIHdoZW4gdW5tb3VudGVkLlxuICpcbiAqIENvbXBvbmVudHMgbGlrZSA8aHRtbD4gPGhlYWQ+IGFuZCA8Ym9keT4gY2FuJ3QgYmUgcmVtb3ZlZCBvciBhZGRlZFxuICogZWFzaWx5IGluIGEgY3Jvc3MtYnJvd3NlciB3YXksIGhvd2V2ZXIgaXQncyB2YWx1YWJsZSB0byBiZSBhYmxlIHRvXG4gKiB0YWtlIGFkdmFudGFnZSBvZiBSZWFjdCdzIHJlY29uY2lsaWF0aW9uIGZvciBzdHlsaW5nIGFuZCA8dGl0bGU+XG4gKiBtYW5hZ2VtZW50LiBTbyB3ZSBqdXN0IGRvY3VtZW50IGl0IGFuZCB0aHJvdyBpbiBkYW5nZXJvdXMgY2FzZXMuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY29tcG9uZW50Q2xhc3MgY29udmVuaWVuY2UgY29uc3RydWN0b3IgdG8gd3JhcFxuICogQHJldHVybiB7ZnVuY3Rpb259IGNvbnZlbmllbmNlIGNvbnN0cnVjdG9yIG9mIG5ldyBjb21wb25lbnRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRnVsbFBhZ2VDb21wb25lbnQoY29tcG9uZW50Q2xhc3MpIHtcbiAgdmFyIEZ1bGxQYWdlQ29tcG9uZW50ID0gUmVhY3RDb21wb3NpdGVDb21wb25lbnQuY3JlYXRlQ2xhc3Moe1xuICAgIGRpc3BsYXlOYW1lOiAnUmVhY3RGdWxsUGFnZUNvbXBvbmVudCcgKyAoXG4gICAgICBjb21wb25lbnRDbGFzcy50eXBlLmRpc3BsYXlOYW1lIHx8ICcnXG4gICAgKSxcblxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50OiBmdW5jdGlvbigpIHtcbiAgICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAnJXMgdHJpZWQgdG8gdW5tb3VudC4gQmVjYXVzZSBvZiBjcm9zcy1icm93c2VyIHF1aXJrcyBpdCBpcyAnICtcbiAgICAgICAgJ2ltcG9zc2libGUgdG8gdW5tb3VudCBzb21lIHRvcC1sZXZlbCBjb21wb25lbnRzIChlZyA8aHRtbD4sIDxoZWFkPiwgJyArXG4gICAgICAgICdhbmQgPGJvZHk+KSByZWxpYWJseSBhbmQgZWZmaWNpZW50bHkuIFRvIGZpeCB0aGlzLCBoYXZlIGEgc2luZ2xlICcgK1xuICAgICAgICAndG9wLWxldmVsIGNvbXBvbmVudCB0aGF0IG5ldmVyIHVubW91bnRzIHJlbmRlciB0aGVzZSBlbGVtZW50cy4nLFxuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lXG4gICAgICApIDogaW52YXJpYW50KGZhbHNlKSk7XG4gICAgfSxcblxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmFuc2ZlclByb3BzVG8oY29tcG9uZW50Q2xhc3MobnVsbCwgdGhpcy5wcm9wcy5jaGlsZHJlbikpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIEZ1bGxQYWdlQ29tcG9uZW50O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUZ1bGxQYWdlQ29tcG9uZW50O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGNyZWF0ZU5vZGVzRnJvbU1hcmt1cFxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4vKmpzbGludCBldmlsOiB0cnVlLCBzdWI6IHRydWUgKi9cblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZShcIi4vRXhlY3V0aW9uRW52aXJvbm1lbnRcIik7XG5cbnZhciBjcmVhdGVBcnJheUZyb20gPSByZXF1aXJlKFwiLi9jcmVhdGVBcnJheUZyb21cIik7XG52YXIgZ2V0TWFya3VwV3JhcCA9IHJlcXVpcmUoXCIuL2dldE1hcmt1cFdyYXBcIik7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xuXG4vKipcbiAqIER1bW15IGNvbnRhaW5lciB1c2VkIHRvIHJlbmRlciBhbGwgbWFya3VwLlxuICovXG52YXIgZHVtbXlOb2RlID1cbiAgRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykgOiBudWxsO1xuXG4vKipcbiAqIFBhdHRlcm4gdXNlZCBieSBgZ2V0Tm9kZU5hbWVgLlxuICovXG52YXIgbm9kZU5hbWVQYXR0ZXJuID0gL15cXHMqPChcXHcrKS87XG5cbi8qKlxuICogRXh0cmFjdHMgdGhlIGBub2RlTmFtZWAgb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gYSBzdHJpbmcgb2YgbWFya3VwLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgU3RyaW5nIG9mIG1hcmt1cC5cbiAqIEByZXR1cm4gez9zdHJpbmd9IE5vZGUgbmFtZSBvZiB0aGUgc3VwcGxpZWQgbWFya3VwLlxuICovXG5mdW5jdGlvbiBnZXROb2RlTmFtZShtYXJrdXApIHtcbiAgdmFyIG5vZGVOYW1lTWF0Y2ggPSBtYXJrdXAubWF0Y2gobm9kZU5hbWVQYXR0ZXJuKTtcbiAgcmV0dXJuIG5vZGVOYW1lTWF0Y2ggJiYgbm9kZU5hbWVNYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbm9kZXMgcmVuZGVyZWQgZnJvbSB0aGUgc3VwcGxpZWQgbWFya3VwLiBUaGVcbiAqIG9wdGlvbmFsbHkgc3VwcGxpZWQgYGhhbmRsZVNjcmlwdGAgZnVuY3Rpb24gd2lsbCBiZSBpbnZva2VkIG9uY2UgZm9yIGVhY2hcbiAqIDxzY3JpcHQ+IGVsZW1lbnQgdGhhdCBpcyByZW5kZXJlZC4gSWYgbm8gYGhhbmRsZVNjcmlwdGAgZnVuY3Rpb24gaXMgc3VwcGxpZWQsXG4gKiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGlmIGFueSA8c2NyaXB0PiBlbGVtZW50cyBhcmUgcmVuZGVyZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBBIHN0cmluZyBvZiB2YWxpZCBIVE1MIG1hcmt1cC5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBoYW5kbGVTY3JpcHQgSW52b2tlZCBvbmNlIGZvciBlYWNoIHJlbmRlcmVkIDxzY3JpcHQ+LlxuICogQHJldHVybiB7YXJyYXk8RE9NRWxlbWVudHxET01UZXh0Tm9kZT59IEFuIGFycmF5IG9mIHJlbmRlcmVkIG5vZGVzLlxuICovXG5mdW5jdGlvbiBjcmVhdGVOb2Rlc0Zyb21NYXJrdXAobWFya3VwLCBoYW5kbGVTY3JpcHQpIHtcbiAgdmFyIG5vZGUgPSBkdW1teU5vZGU7XG4gIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoISFkdW1teU5vZGUsICdjcmVhdGVOb2Rlc0Zyb21NYXJrdXAgZHVtbXkgbm90IGluaXRpYWxpemVkJykgOiBpbnZhcmlhbnQoISFkdW1teU5vZGUpKTtcbiAgdmFyIG5vZGVOYW1lID0gZ2V0Tm9kZU5hbWUobWFya3VwKTtcblxuICB2YXIgd3JhcCA9IG5vZGVOYW1lICYmIGdldE1hcmt1cFdyYXAobm9kZU5hbWUpO1xuICBpZiAod3JhcCkge1xuICAgIG5vZGUuaW5uZXJIVE1MID0gd3JhcFsxXSArIG1hcmt1cCArIHdyYXBbMl07XG5cbiAgICB2YXIgd3JhcERlcHRoID0gd3JhcFswXTtcbiAgICB3aGlsZSAod3JhcERlcHRoLS0pIHtcbiAgICAgIG5vZGUgPSBub2RlLmxhc3RDaGlsZDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5pbm5lckhUTUwgPSBtYXJrdXA7XG4gIH1cblxuICB2YXIgc2NyaXB0cyA9IG5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpO1xuICBpZiAoc2NyaXB0cy5sZW5ndGgpIHtcbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgaGFuZGxlU2NyaXB0LFxuICAgICAgJ2NyZWF0ZU5vZGVzRnJvbU1hcmt1cCguLi4pOiBVbmV4cGVjdGVkIDxzY3JpcHQ+IGVsZW1lbnQgcmVuZGVyZWQuJ1xuICAgICkgOiBpbnZhcmlhbnQoaGFuZGxlU2NyaXB0KSk7XG4gICAgY3JlYXRlQXJyYXlGcm9tKHNjcmlwdHMpLmZvckVhY2goaGFuZGxlU2NyaXB0KTtcbiAgfVxuXG4gIHZhciBub2RlcyA9IGNyZWF0ZUFycmF5RnJvbShub2RlLmNoaWxkTm9kZXMpO1xuICB3aGlsZSAobm9kZS5sYXN0Q2hpbGQpIHtcbiAgICBub2RlLnJlbW92ZUNoaWxkKG5vZGUubGFzdENoaWxkKTtcbiAgfVxuICByZXR1cm4gbm9kZXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlTm9kZXNGcm9tTWFya3VwO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgY3hcbiAqL1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBtYXJrIHN0cmluZyBsaXRlcmFscyByZXByZXNlbnRpbmcgQ1NTIGNsYXNzIG5hbWVzXG4gKiBzbyB0aGF0IHRoZXkgY2FuIGJlIHRyYW5zZm9ybWVkIHN0YXRpY2FsbHkuIFRoaXMgYWxsb3dzIGZvciBtb2R1bGFyaXphdGlvblxuICogYW5kIG1pbmlmaWNhdGlvbiBvZiBDU1MgY2xhc3MgbmFtZXMuXG4gKlxuICogSW4gc3RhdGljX3Vwc3RyZWFtLCB0aGlzIGZ1bmN0aW9uIGlzIGFjdHVhbGx5IGltcGxlbWVudGVkLCBidXQgaXQgc2hvdWxkXG4gKiBldmVudHVhbGx5IGJlIHJlcGxhY2VkIHdpdGggc29tZXRoaW5nIG1vcmUgZGVzY3JpcHRpdmUsIGFuZCB0aGUgdHJhbnNmb3JtXG4gKiB0aGF0IGlzIHVzZWQgaW4gdGhlIG1haW4gc3RhY2sgc2hvdWxkIGJlIHBvcnRlZCBmb3IgdXNlIGVsc2V3aGVyZS5cbiAqXG4gKiBAcGFyYW0gc3RyaW5nfG9iamVjdCBjbGFzc05hbWUgdG8gbW9kdWxhcml6ZSwgb3IgYW4gb2JqZWN0IG9mIGtleS92YWx1ZXMuXG4gKiAgICAgICAgICAgICAgICAgICAgICBJbiB0aGUgb2JqZWN0IGNhc2UsIHRoZSB2YWx1ZXMgYXJlIGNvbmRpdGlvbnMgdGhhdFxuICogICAgICAgICAgICAgICAgICAgICAgZGV0ZXJtaW5lIGlmIHRoZSBjbGFzc05hbWUga2V5cyBzaG91bGQgYmUgaW5jbHVkZWQuXG4gKiBAcGFyYW0gW3N0cmluZyAuLi5dICBWYXJpYWJsZSBsaXN0IG9mIGNsYXNzTmFtZXMgaW4gdGhlIHN0cmluZyBjYXNlLlxuICogQHJldHVybiBzdHJpbmcgICAgICAgUmVuZGVyYWJsZSBzcGFjZS1zZXBhcmF0ZWQgQ1NTIGNsYXNzTmFtZS5cbiAqL1xuZnVuY3Rpb24gY3goY2xhc3NOYW1lcykge1xuICBpZiAodHlwZW9mIGNsYXNzTmFtZXMgPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoY2xhc3NOYW1lcykuZmlsdGVyKGZ1bmN0aW9uKGNsYXNzTmFtZSkge1xuICAgICAgcmV0dXJuIGNsYXNzTmFtZXNbY2xhc3NOYW1lXTtcbiAgICB9KS5qb2luKCcgJyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5qb2luLmNhbGwoYXJndW1lbnRzLCAnICcpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3g7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZGFuZ2Vyb3VzU3R5bGVWYWx1ZVxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIENTU1Byb3BlcnR5ID0gcmVxdWlyZShcIi4vQ1NTUHJvcGVydHlcIik7XG5cbnZhciBpc1VuaXRsZXNzTnVtYmVyID0gQ1NTUHJvcGVydHkuaXNVbml0bGVzc051bWJlcjtcblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgaW50byB0aGUgcHJvcGVyIGNzcyB3cml0YWJsZSB2YWx1ZS4gVGhlIHN0eWxlIG5hbWUgYG5hbWVgXG4gKiBzaG91bGQgYmUgbG9naWNhbCAobm8gaHlwaGVucyksIGFzIHNwZWNpZmllZFxuICogaW4gYENTU1Byb3BlcnR5LmlzVW5pdGxlc3NOdW1iZXJgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIENTUyBwcm9wZXJ0eSBuYW1lIHN1Y2ggYXMgYHRvcE1hcmdpbmAuXG4gKiBAcGFyYW0geyp9IHZhbHVlIENTUyBwcm9wZXJ0eSB2YWx1ZSBzdWNoIGFzIGAxMHB4YC5cbiAqIEByZXR1cm4ge3N0cmluZ30gTm9ybWFsaXplZCBzdHlsZSB2YWx1ZSB3aXRoIGRpbWVuc2lvbnMgYXBwbGllZC5cbiAqL1xuZnVuY3Rpb24gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShuYW1lLCB2YWx1ZSkge1xuICAvLyBOb3RlIHRoYXQgd2UndmUgcmVtb3ZlZCBlc2NhcGVUZXh0Rm9yQnJvd3NlcigpIGNhbGxzIGhlcmUgc2luY2UgdGhlXG4gIC8vIHdob2xlIHN0cmluZyB3aWxsIGJlIGVzY2FwZWQgd2hlbiB0aGUgYXR0cmlidXRlIGlzIGluamVjdGVkIGludG9cbiAgLy8gdGhlIG1hcmt1cC4gSWYgeW91IHByb3ZpZGUgdW5zYWZlIHVzZXIgZGF0YSBoZXJlIHRoZXkgY2FuIGluamVjdFxuICAvLyBhcmJpdHJhcnkgQ1NTIHdoaWNoIG1heSBiZSBwcm9ibGVtYXRpYyAoSSBjb3VsZG4ndCByZXBybyB0aGlzKTpcbiAgLy8gaHR0cHM6Ly93d3cub3dhc3Aub3JnL2luZGV4LnBocC9YU1NfRmlsdGVyX0V2YXNpb25fQ2hlYXRfU2hlZXRcbiAgLy8gaHR0cDovL3d3dy50aGVzcGFubmVyLmNvLnVrLzIwMDcvMTEvMjYvdWx0aW1hdGUteHNzLWNzcy1pbmplY3Rpb24vXG4gIC8vIFRoaXMgaXMgbm90IGFuIFhTUyBob2xlIGJ1dCBpbnN0ZWFkIGEgcG90ZW50aWFsIENTUyBpbmplY3Rpb24gaXNzdWVcbiAgLy8gd2hpY2ggaGFzIGxlYWQgdG8gYSBncmVhdGVyIGRpc2N1c3Npb24gYWJvdXQgaG93IHdlJ3JlIGdvaW5nIHRvXG4gIC8vIHRydXN0IFVSTHMgbW92aW5nIGZvcndhcmQuIFNlZSAjMjExNTkwMVxuXG4gIHZhciBpc0VtcHR5ID0gdmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyB8fCB2YWx1ZSA9PT0gJyc7XG4gIGlmIChpc0VtcHR5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgdmFyIGlzTm9uTnVtZXJpYyA9IGlzTmFOKHZhbHVlKTtcbiAgaWYgKGlzTm9uTnVtZXJpYyB8fCB2YWx1ZSA9PT0gMCB8fFxuICAgICAgaXNVbml0bGVzc051bWJlci5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBpc1VuaXRsZXNzTnVtYmVyW25hbWVdKSB7XG4gICAgcmV0dXJuICcnICsgdmFsdWU7IC8vIGNhc3QgdG8gc3RyaW5nXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHZhbHVlID0gdmFsdWUudHJpbSgpO1xuICB9XG4gIHJldHVybiB2YWx1ZSArICdweCc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGFuZ2Vyb3VzU3R5bGVWYWx1ZTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBlbXB0eUZ1bmN0aW9uXG4gKi9cblxudmFyIGNvcHlQcm9wZXJ0aWVzID0gcmVxdWlyZShcIi4vY29weVByb3BlcnRpZXNcIik7XG5cbmZ1bmN0aW9uIG1ha2VFbXB0eUZ1bmN0aW9uKGFyZykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGFyZztcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgYW5kIGRpc2NhcmRzIGlucHV0czsgaXQgaGFzIG5vIHNpZGUgZWZmZWN0cy4gVGhpcyBpc1xuICogcHJpbWFyaWx5IHVzZWZ1bCBpZGlvbWF0aWNhbGx5IGZvciBvdmVycmlkYWJsZSBmdW5jdGlvbiBlbmRwb2ludHMgd2hpY2hcbiAqIGFsd2F5cyBuZWVkIHRvIGJlIGNhbGxhYmxlLCBzaW5jZSBKUyBsYWNrcyBhIG51bGwtY2FsbCBpZGlvbSBhbGEgQ29jb2EuXG4gKi9cbmZ1bmN0aW9uIGVtcHR5RnVuY3Rpb24oKSB7fVxuXG5jb3B5UHJvcGVydGllcyhlbXB0eUZ1bmN0aW9uLCB7XG4gIHRoYXRSZXR1cm5zOiBtYWtlRW1wdHlGdW5jdGlvbixcbiAgdGhhdFJldHVybnNGYWxzZTogbWFrZUVtcHR5RnVuY3Rpb24oZmFsc2UpLFxuICB0aGF0UmV0dXJuc1RydWU6IG1ha2VFbXB0eUZ1bmN0aW9uKHRydWUpLFxuICB0aGF0UmV0dXJuc051bGw6IG1ha2VFbXB0eUZ1bmN0aW9uKG51bGwpLFxuICB0aGF0UmV0dXJuc1RoaXM6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSxcbiAgdGhhdFJldHVybnNBcmd1bWVudDogZnVuY3Rpb24oYXJnKSB7IHJldHVybiBhcmc7IH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5RnVuY3Rpb247XG4iLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGVtcHR5T2JqZWN0XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBlbXB0eU9iamVjdCA9IHt9O1xuXG5pZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gIE9iamVjdC5mcmVlemUoZW1wdHlPYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5T2JqZWN0O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZXNjYXBlVGV4dEZvckJyb3dzZXJcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBFU0NBUEVfTE9PS1VQID0ge1xuICBcIiZcIjogXCImYW1wO1wiLFxuICBcIj5cIjogXCImZ3Q7XCIsXG4gIFwiPFwiOiBcIiZsdDtcIixcbiAgXCJcXFwiXCI6IFwiJnF1b3Q7XCIsXG4gIFwiJ1wiOiBcIiYjeDI3O1wiXG59O1xuXG52YXIgRVNDQVBFX1JFR0VYID0gL1smPjxcIiddL2c7XG5cbmZ1bmN0aW9uIGVzY2FwZXIobWF0Y2gpIHtcbiAgcmV0dXJuIEVTQ0FQRV9MT09LVVBbbWF0Y2hdO1xufVxuXG4vKipcbiAqIEVzY2FwZXMgdGV4dCB0byBwcmV2ZW50IHNjcmlwdGluZyBhdHRhY2tzLlxuICpcbiAqIEBwYXJhbSB7Kn0gdGV4dCBUZXh0IHZhbHVlIHRvIGVzY2FwZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gQW4gZXNjYXBlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZVRleHRGb3JCcm93c2VyKHRleHQpIHtcbiAgcmV0dXJuICgnJyArIHRleHQpLnJlcGxhY2UoRVNDQVBFX1JFR0VYLCBlc2NhcGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlc2NhcGVUZXh0Rm9yQnJvd3NlcjtcbiIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZmxhdHRlbkNoaWxkcmVuXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB0cmF2ZXJzZUFsbENoaWxkcmVuID0gcmVxdWlyZShcIi4vdHJhdmVyc2VBbGxDaGlsZHJlblwiKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZShcIi4vd2FybmluZ1wiKTtcblxuLyoqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB0cmF2ZXJzZUNvbnRleHQgQ29udGV4dCBwYXNzZWQgdGhyb3VnaCB0cmF2ZXJzYWwuXG4gKiBAcGFyYW0gez9SZWFjdENvbXBvbmVudH0gY2hpbGQgUmVhY3QgY2hpbGQgY29tcG9uZW50LlxuICogQHBhcmFtIHshc3RyaW5nfSBuYW1lIFN0cmluZyBuYW1lIG9mIGtleSBwYXRoIHRvIGNoaWxkLlxuICovXG5mdW5jdGlvbiBmbGF0dGVuU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkLCBuYW1lKSB7XG4gIC8vIFdlIGZvdW5kIGEgY29tcG9uZW50IGluc3RhbmNlLlxuICB2YXIgcmVzdWx0ID0gdHJhdmVyc2VDb250ZXh0O1xuICB2YXIga2V5VW5pcXVlID0gIXJlc3VsdC5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbiAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IHdhcm5pbmcoXG4gICAga2V5VW5pcXVlLFxuICAgICdmbGF0dGVuQ2hpbGRyZW4oLi4uKTogRW5jb3VudGVyZWQgdHdvIGNoaWxkcmVuIHdpdGggdGhlIHNhbWUga2V5LCAnICtcbiAgICAnYCVzYC4gQ2hpbGQga2V5cyBtdXN0IGJlIHVuaXF1ZTsgd2hlbiB0d28gY2hpbGRyZW4gc2hhcmUgYSBrZXksIG9ubHkgJyArXG4gICAgJ3RoZSBmaXJzdCBjaGlsZCB3aWxsIGJlIHVzZWQuJyxcbiAgICBuYW1lXG4gICkgOiBudWxsKTtcbiAgaWYgKGtleVVuaXF1ZSAmJiBjaGlsZCAhPSBudWxsKSB7XG4gICAgcmVzdWx0W25hbWVdID0gY2hpbGQ7XG4gIH1cbn1cblxuLyoqXG4gKiBGbGF0dGVucyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuIEFueSBudWxsXG4gKiBjaGlsZHJlbiB3aWxsIG5vdCBiZSBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0aW5nIG9iamVjdC5cbiAqIEByZXR1cm4geyFvYmplY3R9IGZsYXR0ZW5lZCBjaGlsZHJlbiBrZXllZCBieSBuYW1lLlxuICovXG5mdW5jdGlvbiBmbGF0dGVuQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHt9O1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmbGF0dGVuU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCwgcmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmbGF0dGVuQ2hpbGRyZW47XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZm9jdXNOb2RlXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogSUU4IHRocm93cyBpZiBhbiBpbnB1dC90ZXh0YXJlYSBpcyBkaXNhYmxlZCBhbmQgd2UgdHJ5IHRvIGZvY3VzIGl0LlxuICogRm9jdXMgb25seSB3aGVuIG5lY2Vzc2FyeS5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGUgaW5wdXQvdGV4dGFyZWEgdG8gZm9jdXNcbiAqL1xuZnVuY3Rpb24gZm9jdXNOb2RlKG5vZGUpIHtcbiAgaWYgKCFub2RlLmRpc2FibGVkKSB7XG4gICAgbm9kZS5mb2N1cygpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZm9jdXNOb2RlO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGZvckVhY2hBY2N1bXVsYXRlZFxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIEBwYXJhbSB7YXJyYXl9IGFuIFwiYWNjdW11bGF0aW9uXCIgb2YgaXRlbXMgd2hpY2ggaXMgZWl0aGVyIGFuIEFycmF5IG9yXG4gKiBhIHNpbmdsZSBpdGVtLiBVc2VmdWwgd2hlbiBwYWlyZWQgd2l0aCB0aGUgYGFjY3VtdWxhdGVgIG1vZHVsZS4gVGhpcyBpcyBhXG4gKiBzaW1wbGUgdXRpbGl0eSB0aGF0IGFsbG93cyB1cyB0byByZWFzb24gYWJvdXQgYSBjb2xsZWN0aW9uIG9mIGl0ZW1zLCBidXRcbiAqIGhhbmRsaW5nIHRoZSBjYXNlIHdoZW4gdGhlcmUgaXMgZXhhY3RseSBvbmUgaXRlbSAoYW5kIHdlIGRvIG5vdCBuZWVkIHRvXG4gKiBhbGxvY2F0ZSBhbiBhcnJheSkuXG4gKi9cbnZhciBmb3JFYWNoQWNjdW11bGF0ZWQgPSBmdW5jdGlvbihhcnIsIGNiLCBzY29wZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgYXJyLmZvckVhY2goY2IsIHNjb3BlKTtcbiAgfSBlbHNlIGlmIChhcnIpIHtcbiAgICBjYi5jYWxsKHNjb3BlLCBhcnIpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZvckVhY2hBY2N1bXVsYXRlZDtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRBY3RpdmVFbGVtZW50XG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qKlxuICogU2FtZSBhcyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGJ1dCB3cmFwcyBpbiBhIHRyeS1jYXRjaCBibG9jay4gSW4gSUUgaXQgaXNcbiAqIG5vdCBzYWZlIHRvIGNhbGwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpZiB0aGVyZSBpcyBub3RoaW5nIGZvY3VzZWQuXG4gKlxuICogVGhlIGFjdGl2ZUVsZW1lbnQgd2lsbCBiZSBudWxsIG9ubHkgaWYgdGhlIGRvY3VtZW50IGJvZHkgaXMgbm90IHlldCBkZWZpbmVkLlxuICovXG5mdW5jdGlvbiBnZXRBY3RpdmVFbGVtZW50KCkgLyo/RE9NRWxlbWVudCovIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCB8fCBkb2N1bWVudC5ib2R5O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmJvZHk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRBY3RpdmVFbGVtZW50O1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRFdmVudEtleVxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcblxuLyoqXG4gKiBOb3JtYWxpemF0aW9uIG9mIGRlcHJlY2F0ZWQgSFRNTDUgYGtleWAgdmFsdWVzXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG52YXIgbm9ybWFsaXplS2V5ID0ge1xuICAnRXNjJzogJ0VzY2FwZScsXG4gICdTcGFjZWJhcic6ICcgJyxcbiAgJ0xlZnQnOiAnQXJyb3dMZWZ0JyxcbiAgJ1VwJzogJ0Fycm93VXAnLFxuICAnUmlnaHQnOiAnQXJyb3dSaWdodCcsXG4gICdEb3duJzogJ0Fycm93RG93bicsXG4gICdEZWwnOiAnRGVsZXRlJyxcbiAgJ1dpbic6ICdPUycsXG4gICdNZW51JzogJ0NvbnRleHRNZW51JyxcbiAgJ0FwcHMnOiAnQ29udGV4dE1lbnUnLFxuICAnU2Nyb2xsJzogJ1Njcm9sbExvY2snLFxuICAnTW96UHJpbnRhYmxlS2V5JzogJ1VuaWRlbnRpZmllZCdcbn07XG5cbi8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBsZWdhY3kgYHdoaWNoYC9ga2V5Q29kZWAgdG8gSFRNTDUgYGtleWBcbiAqIE9ubHkgc3BlY2lhbCBrZXlzIHN1cHBvcnRlZCwgYWxsIG90aGVycyBkZXBlbmQgb24ga2V5Ym9hcmQgbGF5b3V0IG9yIGJyb3dzZXJcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQjS2V5X25hbWVzXG4gKi9cbnZhciB0cmFuc2xhdGVUb0tleSA9IHtcbiAgODogJ0JhY2tzcGFjZScsXG4gIDk6ICdUYWInLFxuICAxMjogJ0NsZWFyJyxcbiAgMTM6ICdFbnRlcicsXG4gIDE2OiAnU2hpZnQnLFxuICAxNzogJ0NvbnRyb2wnLFxuICAxODogJ0FsdCcsXG4gIDE5OiAnUGF1c2UnLFxuICAyMDogJ0NhcHNMb2NrJyxcbiAgMjc6ICdFc2NhcGUnLFxuICAzMjogJyAnLFxuICAzMzogJ1BhZ2VVcCcsXG4gIDM0OiAnUGFnZURvd24nLFxuICAzNTogJ0VuZCcsXG4gIDM2OiAnSG9tZScsXG4gIDM3OiAnQXJyb3dMZWZ0JyxcbiAgMzg6ICdBcnJvd1VwJyxcbiAgMzk6ICdBcnJvd1JpZ2h0JyxcbiAgNDA6ICdBcnJvd0Rvd24nLFxuICA0NTogJ0luc2VydCcsXG4gIDQ2OiAnRGVsZXRlJyxcbiAgMTEyOiAnRjEnLCAxMTM6ICdGMicsIDExNDogJ0YzJywgMTE1OiAnRjQnLCAxMTY6ICdGNScsIDExNzogJ0Y2JyxcbiAgMTE4OiAnRjcnLCAxMTk6ICdGOCcsIDEyMDogJ0Y5JywgMTIxOiAnRjEwJywgMTIyOiAnRjExJywgMTIzOiAnRjEyJyxcbiAgMTQ0OiAnTnVtTG9jaycsXG4gIDE0NTogJ1Njcm9sbExvY2snLFxuICAyMjQ6ICdNZXRhJ1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5vcm1hbGl6ZWQgYGtleWAgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGdldEV2ZW50S2V5KG5hdGl2ZUV2ZW50KSB7XG4gIGlmIChuYXRpdmVFdmVudC5rZXkpIHtcbiAgICAvLyBOb3JtYWxpemUgaW5jb25zaXN0ZW50IHZhbHVlcyByZXBvcnRlZCBieSBicm93c2VycyBkdWUgdG9cbiAgICAvLyBpbXBsZW1lbnRhdGlvbnMgb2YgYSB3b3JraW5nIGRyYWZ0IHNwZWNpZmljYXRpb24uXG5cbiAgICAvLyBGaXJlRm94IGltcGxlbWVudHMgYGtleWAgYnV0IHJldHVybnMgYE1velByaW50YWJsZUtleWAgZm9yIGFsbFxuICAgIC8vIHByaW50YWJsZSBjaGFyYWN0ZXJzIChub3JtYWxpemVkIHRvIGBVbmlkZW50aWZpZWRgKSwgaWdub3JlIGl0LlxuICAgIHZhciBrZXkgPSBub3JtYWxpemVLZXlbbmF0aXZlRXZlbnQua2V5XSB8fCBuYXRpdmVFdmVudC5rZXk7XG4gICAgaWYgKGtleSAhPT0gJ1VuaWRlbnRpZmllZCcpIHtcbiAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICB9XG5cbiAgLy8gQnJvd3NlciBkb2VzIG5vdCBpbXBsZW1lbnQgYGtleWAsIHBvbHlmaWxsIGFzIG11Y2ggb2YgaXQgYXMgd2UgY2FuLlxuICBpZiAobmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgIC8vIENyZWF0ZSB0aGUgY2hhcmFjdGVyIGZyb20gdGhlIGBjaGFyQ29kZWAgb3Vyc2VsdmVzIGFuZCB1c2UgYXMgYW4gYWxtb3N0XG4gICAgLy8gcGVyZmVjdCByZXBsYWNlbWVudC5cbiAgICB2YXIgY2hhckNvZGUgPSAnY2hhckNvZGUnIGluIG5hdGl2ZUV2ZW50ID9cbiAgICAgIG5hdGl2ZUV2ZW50LmNoYXJDb2RlIDpcbiAgICAgIG5hdGl2ZUV2ZW50LmtleUNvZGU7XG5cbiAgICAvLyBUaGUgZW50ZXIta2V5IGlzIHRlY2huaWNhbGx5IGJvdGggcHJpbnRhYmxlIGFuZCBub24tcHJpbnRhYmxlIGFuZCBjYW5cbiAgICAvLyB0aHVzIGJlIGNhcHR1cmVkIGJ5IGBrZXlwcmVzc2AsIG5vIG90aGVyIG5vbi1wcmludGFibGUga2V5IHNob3VsZC5cbiAgICByZXR1cm4gY2hhckNvZGUgPT09IDEzID8gJ0VudGVyJyA6IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuICB9XG4gIGlmIChuYXRpdmVFdmVudC50eXBlID09PSAna2V5ZG93bicgfHwgbmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgIC8vIFdoaWxlIHVzZXIga2V5Ym9hcmQgbGF5b3V0IGRldGVybWluZXMgdGhlIGFjdHVhbCBtZWFuaW5nIG9mIGVhY2hcbiAgICAvLyBga2V5Q29kZWAgdmFsdWUsIGFsbW9zdCBhbGwgZnVuY3Rpb24ga2V5cyBoYXZlIGEgdW5pdmVyc2FsIHZhbHVlLlxuICAgIHJldHVybiB0cmFuc2xhdGVUb0tleVtuYXRpdmVFdmVudC5rZXlDb2RlXSB8fCAnVW5pZGVudGlmaWVkJztcbiAgfVxuXG4gIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoZmFsc2UsIFwiVW5leHBlY3RlZCBrZXlib2FyZCBldmVudCB0eXBlOiAlc1wiLCBuYXRpdmVFdmVudC50eXBlKSA6IGludmFyaWFudChmYWxzZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEV2ZW50S2V5O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzIEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldEV2ZW50TW9kaWZpZXJTdGF0ZVxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBUcmFuc2xhdGlvbiBmcm9tIG1vZGlmaWVyIGtleSB0byB0aGUgYXNzb2NpYXRlZCBwcm9wZXJ0eSBpbiB0aGUgZXZlbnQuXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8ja2V5cy1Nb2RpZmllcnNcbiAqL1xuXG52YXIgbW9kaWZpZXJLZXlUb1Byb3AgPSB7XG4gICdBbHQnOiAnYWx0S2V5JyxcbiAgJ0NvbnRyb2wnOiAnY3RybEtleScsXG4gICdNZXRhJzogJ21ldGFLZXknLFxuICAnU2hpZnQnOiAnc2hpZnRLZXknXG59O1xuXG4vLyBJRTggZG9lcyBub3QgaW1wbGVtZW50IGdldE1vZGlmaWVyU3RhdGUgc28gd2Ugc2ltcGx5IG1hcCBpdCB0byB0aGUgb25seVxuLy8gbW9kaWZpZXIga2V5cyBleHBvc2VkIGJ5IHRoZSBldmVudCBpdHNlbGYsIGRvZXMgbm90IHN1cHBvcnQgTG9jay1rZXlzLlxuLy8gQ3VycmVudGx5LCBhbGwgbWFqb3IgYnJvd3NlcnMgZXhjZXB0IENocm9tZSBzZWVtcyB0byBzdXBwb3J0IExvY2sta2V5cy5cbmZ1bmN0aW9uIG1vZGlmaWVyU3RhdGVHZXR0ZXIoa2V5QXJnKSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBzeW50aGV0aWNFdmVudCA9IHRoaXM7XG4gIHZhciBuYXRpdmVFdmVudCA9IHN5bnRoZXRpY0V2ZW50Lm5hdGl2ZUV2ZW50O1xuICBpZiAobmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZSkge1xuICAgIHJldHVybiBuYXRpdmVFdmVudC5nZXRNb2RpZmllclN0YXRlKGtleUFyZyk7XG4gIH1cbiAgdmFyIGtleVByb3AgPSBtb2RpZmllcktleVRvUHJvcFtrZXlBcmddO1xuICByZXR1cm4ga2V5UHJvcCA/ICEhbmF0aXZlRXZlbnRba2V5UHJvcF0gOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0RXZlbnRNb2RpZmllclN0YXRlKG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiBtb2RpZmllclN0YXRlR2V0dGVyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEV2ZW50TW9kaWZpZXJTdGF0ZTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRFdmVudFRhcmdldFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBHZXRzIHRoZSB0YXJnZXQgbm9kZSBmcm9tIGEgbmF0aXZlIGJyb3dzZXIgZXZlbnQgYnkgYWNjb3VudGluZyBmb3JcbiAqIGluY29uc2lzdGVuY2llcyBpbiBicm93c2VyIERPTSBBUElzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge0RPTUV2ZW50VGFyZ2V0fSBUYXJnZXQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIHRhcmdldCA9IG5hdGl2ZUV2ZW50LnRhcmdldCB8fCBuYXRpdmVFdmVudC5zcmNFbGVtZW50IHx8IHdpbmRvdztcbiAgLy8gU2FmYXJpIG1heSBmaXJlIGV2ZW50cyBvbiB0ZXh0IG5vZGVzIChOb2RlLlRFWFRfTk9ERSBpcyAzKS5cbiAgLy8gQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2pzL2V2ZW50c19wcm9wZXJ0aWVzLmh0bWxcbiAgcmV0dXJuIHRhcmdldC5ub2RlVHlwZSA9PT0gMyA/IHRhcmdldC5wYXJlbnROb2RlIDogdGFyZ2V0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEV2ZW50VGFyZ2V0O1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRNYXJrdXBXcmFwXG4gKi9cblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZShcIi4vRXhlY3V0aW9uRW52aXJvbm1lbnRcIik7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbi8qKlxuICogRHVtbXkgY29udGFpbmVyIHVzZWQgdG8gZGV0ZWN0IHdoaWNoIHdyYXBzIGFyZSBuZWNlc3NhcnkuXG4gKi9cbnZhciBkdW1teU5vZGUgPVxuICBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSA6IG51bGw7XG5cbi8qKlxuICogU29tZSBicm93c2VycyBjYW5ub3QgdXNlIGBpbm5lckhUTUxgIHRvIHJlbmRlciBjZXJ0YWluIGVsZW1lbnRzIHN0YW5kYWxvbmUsXG4gKiBzbyB3ZSB3cmFwIHRoZW0sIHJlbmRlciB0aGUgd3JhcHBlZCBub2RlcywgdGhlbiBleHRyYWN0IHRoZSBkZXNpcmVkIG5vZGUuXG4gKlxuICogSW4gSUU4LCBjZXJ0YWluIGVsZW1lbnRzIGNhbm5vdCByZW5kZXIgYWxvbmUsIHNvIHdyYXAgYWxsIGVsZW1lbnRzICgnKicpLlxuICovXG52YXIgc2hvdWxkV3JhcCA9IHtcbiAgLy8gRm9yY2Ugd3JhcHBpbmcgZm9yIFNWRyBlbGVtZW50cyBiZWNhdXNlIGlmIHRoZXkgZ2V0IGNyZWF0ZWQgaW5zaWRlIGEgPGRpdj4sXG4gIC8vIHRoZXkgd2lsbCBiZSBpbml0aWFsaXplZCBpbiB0aGUgd3JvbmcgbmFtZXNwYWNlIChhbmQgd2lsbCBub3QgZGlzcGxheSkuXG4gICdjaXJjbGUnOiB0cnVlLFxuICAnZGVmcyc6IHRydWUsXG4gICdlbGxpcHNlJzogdHJ1ZSxcbiAgJ2cnOiB0cnVlLFxuICAnbGluZSc6IHRydWUsXG4gICdsaW5lYXJHcmFkaWVudCc6IHRydWUsXG4gICdwYXRoJzogdHJ1ZSxcbiAgJ3BvbHlnb24nOiB0cnVlLFxuICAncG9seWxpbmUnOiB0cnVlLFxuICAncmFkaWFsR3JhZGllbnQnOiB0cnVlLFxuICAncmVjdCc6IHRydWUsXG4gICdzdG9wJzogdHJ1ZSxcbiAgJ3RleHQnOiB0cnVlXG59O1xuXG52YXIgc2VsZWN0V3JhcCA9IFsxLCAnPHNlbGVjdCBtdWx0aXBsZT1cInRydWVcIj4nLCAnPC9zZWxlY3Q+J107XG52YXIgdGFibGVXcmFwID0gWzEsICc8dGFibGU+JywgJzwvdGFibGU+J107XG52YXIgdHJXcmFwID0gWzMsICc8dGFibGU+PHRib2R5Pjx0cj4nLCAnPC90cj48L3Rib2R5PjwvdGFibGU+J107XG5cbnZhciBzdmdXcmFwID0gWzEsICc8c3ZnPicsICc8L3N2Zz4nXTtcblxudmFyIG1hcmt1cFdyYXAgPSB7XG4gICcqJzogWzEsICc/PGRpdj4nLCAnPC9kaXY+J10sXG5cbiAgJ2FyZWEnOiBbMSwgJzxtYXA+JywgJzwvbWFwPiddLFxuICAnY29sJzogWzIsICc8dGFibGU+PHRib2R5PjwvdGJvZHk+PGNvbGdyb3VwPicsICc8L2NvbGdyb3VwPjwvdGFibGU+J10sXG4gICdsZWdlbmQnOiBbMSwgJzxmaWVsZHNldD4nLCAnPC9maWVsZHNldD4nXSxcbiAgJ3BhcmFtJzogWzEsICc8b2JqZWN0PicsICc8L29iamVjdD4nXSxcbiAgJ3RyJzogWzIsICc8dGFibGU+PHRib2R5PicsICc8L3Rib2R5PjwvdGFibGU+J10sXG5cbiAgJ29wdGdyb3VwJzogc2VsZWN0V3JhcCxcbiAgJ29wdGlvbic6IHNlbGVjdFdyYXAsXG5cbiAgJ2NhcHRpb24nOiB0YWJsZVdyYXAsXG4gICdjb2xncm91cCc6IHRhYmxlV3JhcCxcbiAgJ3Rib2R5JzogdGFibGVXcmFwLFxuICAndGZvb3QnOiB0YWJsZVdyYXAsXG4gICd0aGVhZCc6IHRhYmxlV3JhcCxcblxuICAndGQnOiB0cldyYXAsXG4gICd0aCc6IHRyV3JhcCxcblxuICAnY2lyY2xlJzogc3ZnV3JhcCxcbiAgJ2RlZnMnOiBzdmdXcmFwLFxuICAnZWxsaXBzZSc6IHN2Z1dyYXAsXG4gICdnJzogc3ZnV3JhcCxcbiAgJ2xpbmUnOiBzdmdXcmFwLFxuICAnbGluZWFyR3JhZGllbnQnOiBzdmdXcmFwLFxuICAncGF0aCc6IHN2Z1dyYXAsXG4gICdwb2x5Z29uJzogc3ZnV3JhcCxcbiAgJ3BvbHlsaW5lJzogc3ZnV3JhcCxcbiAgJ3JhZGlhbEdyYWRpZW50Jzogc3ZnV3JhcCxcbiAgJ3JlY3QnOiBzdmdXcmFwLFxuICAnc3RvcCc6IHN2Z1dyYXAsXG4gICd0ZXh0Jzogc3ZnV3JhcFxufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBtYXJrdXAgd3JhcCBjb25maWd1cmF0aW9uIGZvciB0aGUgc3VwcGxpZWQgYG5vZGVOYW1lYC5cbiAqXG4gKiBOT1RFOiBUaGlzIGxhemlseSBkZXRlY3RzIHdoaWNoIHdyYXBzIGFyZSBuZWNlc3NhcnkgZm9yIHRoZSBjdXJyZW50IGJyb3dzZXIuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5vZGVOYW1lIExvd2VyY2FzZSBgbm9kZU5hbWVgLlxuICogQHJldHVybiB7P2FycmF5fSBNYXJrdXAgd3JhcCBjb25maWd1cmF0aW9uLCBpZiBhcHBsaWNhYmxlLlxuICovXG5mdW5jdGlvbiBnZXRNYXJrdXBXcmFwKG5vZGVOYW1lKSB7XG4gIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoISFkdW1teU5vZGUsICdNYXJrdXAgd3JhcHBpbmcgbm9kZSBub3QgaW5pdGlhbGl6ZWQnKSA6IGludmFyaWFudCghIWR1bW15Tm9kZSkpO1xuICBpZiAoIW1hcmt1cFdyYXAuaGFzT3duUHJvcGVydHkobm9kZU5hbWUpKSB7XG4gICAgbm9kZU5hbWUgPSAnKic7XG4gIH1cbiAgaWYgKCFzaG91bGRXcmFwLmhhc093blByb3BlcnR5KG5vZGVOYW1lKSkge1xuICAgIGlmIChub2RlTmFtZSA9PT0gJyonKSB7XG4gICAgICBkdW1teU5vZGUuaW5uZXJIVE1MID0gJzxsaW5rIC8+JztcbiAgICB9IGVsc2Uge1xuICAgICAgZHVtbXlOb2RlLmlubmVySFRNTCA9ICc8JyArIG5vZGVOYW1lICsgJz48LycgKyBub2RlTmFtZSArICc+JztcbiAgICB9XG4gICAgc2hvdWxkV3JhcFtub2RlTmFtZV0gPSAhZHVtbXlOb2RlLmZpcnN0Q2hpbGQ7XG4gIH1cbiAgcmV0dXJuIHNob3VsZFdyYXBbbm9kZU5hbWVdID8gbWFya3VwV3JhcFtub2RlTmFtZV0gOiBudWxsO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWFya3VwV3JhcDtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXRcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBHaXZlbiBhbnkgbm9kZSByZXR1cm4gdGhlIGZpcnN0IGxlYWYgbm9kZSB3aXRob3V0IGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX1cbiAqL1xuZnVuY3Rpb24gZ2V0TGVhZk5vZGUobm9kZSkge1xuICB3aGlsZSAobm9kZSAmJiBub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICBub2RlID0gbm9kZS5maXJzdENoaWxkO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIEdldCB0aGUgbmV4dCBzaWJsaW5nIHdpdGhpbiBhIGNvbnRhaW5lci4gVGhpcyB3aWxsIHdhbGsgdXAgdGhlXG4gKiBET00gaWYgYSBub2RlJ3Mgc2libGluZ3MgaGF2ZSBiZWVuIGV4aGF1c3RlZC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEByZXR1cm4gez9ET01FbGVtZW50fERPTVRleHROb2RlfVxuICovXG5mdW5jdGlvbiBnZXRTaWJsaW5nTm9kZShub2RlKSB7XG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICAgIHJldHVybiBub2RlLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICB9XG59XG5cbi8qKlxuICogR2V0IG9iamVjdCBkZXNjcmliaW5nIHRoZSBub2RlcyB3aGljaCBjb250YWluIGNoYXJhY3RlcnMgYXQgb2Zmc2V0LlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gcm9vdFxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHJldHVybiB7P29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChyb290LCBvZmZzZXQpIHtcbiAgdmFyIG5vZGUgPSBnZXRMZWFmTm9kZShyb290KTtcbiAgdmFyIG5vZGVTdGFydCA9IDA7XG4gIHZhciBub2RlRW5kID0gMDtcblxuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09IDMpIHtcbiAgICAgIG5vZGVFbmQgPSBub2RlU3RhcnQgKyBub2RlLnRleHRDb250ZW50Lmxlbmd0aDtcblxuICAgICAgaWYgKG5vZGVTdGFydCA8PSBvZmZzZXQgJiYgbm9kZUVuZCA+PSBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgIG9mZnNldDogb2Zmc2V0IC0gbm9kZVN0YXJ0XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG5vZGVTdGFydCA9IG5vZGVFbmQ7XG4gICAgfVxuXG4gICAgbm9kZSA9IGdldExlYWZOb2RlKGdldFNpYmxpbmdOb2RlKG5vZGUpKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQ7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBET0NfTk9ERV9UWVBFID0gOTtcblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NRG9jdW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0aGF0IG1heSBjb250YWluXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhIFJlYWN0IGNvbXBvbmVudFxuICogQHJldHVybiB7Pyp9IERPTSBlbGVtZW50IHRoYXQgbWF5IGhhdmUgdGhlIHJlYWN0Um9vdCBJRCwgb3IgbnVsbC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICBpZiAoIWNvbnRhaW5lcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRSkge1xuICAgIHJldHVybiBjb250YWluZXIuZG9jdW1lbnRFbGVtZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb250YWluZXIuZmlyc3RDaGlsZDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcjtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRUZXh0Q29udGVudEFjY2Vzc29yXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoXCIuL0V4ZWN1dGlvbkVudmlyb25tZW50XCIpO1xuXG52YXIgY29udGVudEtleSA9IG51bGw7XG5cbi8qKlxuICogR2V0cyB0aGUga2V5IHVzZWQgdG8gYWNjZXNzIHRleHQgY29udGVudCBvbiBhIERPTSBub2RlLlxuICpcbiAqIEByZXR1cm4gez9zdHJpbmd9IEtleSB1c2VkIHRvIGFjY2VzcyB0ZXh0IGNvbnRlbnQuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcigpIHtcbiAgaWYgKCFjb250ZW50S2V5ICYmIEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICAgIC8vIFByZWZlciB0ZXh0Q29udGVudCB0byBpbm5lclRleHQgYmVjYXVzZSBtYW55IGJyb3dzZXJzIHN1cHBvcnQgYm90aCBidXRcbiAgICAvLyBTVkcgPHRleHQ+IGVsZW1lbnRzIGRvbid0IHN1cHBvcnQgaW5uZXJUZXh0IGV2ZW4gd2hlbiA8ZGl2PiBkb2VzLlxuICAgIGNvbnRlbnRLZXkgPSAndGV4dENvbnRlbnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCA/XG4gICAgICAndGV4dENvbnRlbnQnIDpcbiAgICAgICdpbm5lclRleHQnO1xuICB9XG4gIHJldHVybiBjb250ZW50S2V5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFRleHRDb250ZW50QWNjZXNzb3I7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb25cbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogR2V0cyB0aGUgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSBzdXBwbGllZCBlbGVtZW50IG9yIHdpbmRvdy5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlcyBhcmUgdW5ib3VuZGVkLCB1bmxpa2UgYGdldFNjcm9sbFBvc2l0aW9uYC4gVGhpcyBtZWFucyB0aGV5XG4gKiBtYXkgYmUgbmVnYXRpdmUgb3IgZXhjZWVkIHRoZSBlbGVtZW50IGJvdW5kYXJpZXMgKHdoaWNoIGlzIHBvc3NpYmxlIHVzaW5nXG4gKiBpbmVydGlhbCBzY3JvbGxpbmcpLlxuICpcbiAqIEBwYXJhbSB7RE9NV2luZG93fERPTUVsZW1lbnR9IHNjcm9sbGFibGVcbiAqIEByZXR1cm4ge29iamVjdH0gTWFwIHdpdGggYHhgIGFuZCBgeWAga2V5cy5cbiAqL1xuZnVuY3Rpb24gZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24oc2Nyb2xsYWJsZSkge1xuICBpZiAoc2Nyb2xsYWJsZSA9PT0gd2luZG93KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICAgIHk6IHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHg6IHNjcm9sbGFibGUuc2Nyb2xsTGVmdCxcbiAgICB5OiBzY3JvbGxhYmxlLnNjcm9sbFRvcFxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGh5cGhlbmF0ZVxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgX3VwcGVyY2FzZVBhdHRlcm4gPSAvKFtBLVpdKS9nO1xuXG4vKipcbiAqIEh5cGhlbmF0ZXMgYSBjYW1lbGNhc2VkIHN0cmluZywgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGh5cGhlbmF0ZSgnYmFja2dyb3VuZENvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmQtY29sb3JcIlxuICpcbiAqIEZvciBDU1Mgc3R5bGUgbmFtZXMsIHVzZSBgaHlwaGVuYXRlU3R5bGVOYW1lYCBpbnN0ZWFkIHdoaWNoIHdvcmtzIHByb3Blcmx5XG4gKiB3aXRoIGFsbCB2ZW5kb3IgcHJlZml4ZXMsIGluY2x1ZGluZyBgbXNgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gaHlwaGVuYXRlKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoX3VwcGVyY2FzZVBhdHRlcm4sICctJDEnKS50b0xvd2VyQ2FzZSgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGh5cGhlbmF0ZTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBoeXBoZW5hdGVTdHlsZU5hbWVcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBoeXBoZW5hdGUgPSByZXF1aXJlKFwiLi9oeXBoZW5hdGVcIik7XG5cbnZhciBtc1BhdHRlcm4gPSAvXm1zLS87XG5cbi8qKlxuICogSHlwaGVuYXRlcyBhIGNhbWVsY2FzZWQgQ1NTIHByb3BlcnR5IG5hbWUsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBoeXBoZW5hdGUoJ2JhY2tncm91bmRDb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kLWNvbG9yXCJcbiAqICAgPiBoeXBoZW5hdGUoJ01velRyYW5zaXRpb24nKVxuICogICA8IFwiLW1vei10cmFuc2l0aW9uXCJcbiAqICAgPiBoeXBoZW5hdGUoJ21zVHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbXMtdHJhbnNpdGlvblwiXG4gKlxuICogQXMgTW9kZXJuaXpyIHN1Z2dlc3RzIChodHRwOi8vbW9kZXJuaXpyLmNvbS9kb2NzLyNwcmVmaXhlZCksIGFuIGBtc2AgcHJlZml4XG4gKiBpcyBjb252ZXJ0ZWQgdG8gYC1tcy1gLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gaHlwaGVuYXRlU3R5bGVOYW1lKHN0cmluZykge1xuICByZXR1cm4gaHlwaGVuYXRlKHN0cmluZykucmVwbGFjZShtc1BhdHRlcm4sICctbXMtJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaHlwaGVuYXRlU3R5bGVOYW1lO1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xuXG4vKipcbiAqIFZhbGlkYXRlIGEgYGNvbXBvbmVudERlc2NyaXB0b3JgLiBUaGlzIHNob3VsZCBiZSBleHBvc2VkIHB1YmxpY2x5IGluIGEgZm9sbG93XG4gKiB1cCBkaWZmLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBkZXNjcmlwdG9yXG4gKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhpcyBpcyBhIHZhbGlkIGRlc2NyaXB0b3Igb2YgYSBDb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRDb21wb25lbnREZXNjcmlwdG9yKGRlc2NyaXB0b3IpIHtcbiAgcmV0dXJuIChcbiAgICBkZXNjcmlwdG9yICYmXG4gICAgdHlwZW9mIGRlc2NyaXB0b3IudHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiBkZXNjcmlwdG9yLnR5cGUucHJvdG90eXBlLm1vdW50Q29tcG9uZW50ID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIGRlc2NyaXB0b3IudHlwZS5wcm90b3R5cGUucmVjZWl2ZUNvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJ1xuICApO1xufVxuXG4vKipcbiAqIEdpdmVuIGEgYGNvbXBvbmVudERlc2NyaXB0b3JgIGNyZWF0ZSBhbiBpbnN0YW5jZSB0aGF0IHdpbGwgYWN0dWFsbHkgYmVcbiAqIG1vdW50ZWQuIEN1cnJlbnRseSBpdCBqdXN0IGV4dHJhY3RzIGFuIGV4aXN0aW5nIGNsb25lIGZyb20gY29tcG9zaXRlXG4gKiBjb21wb25lbnRzIGJ1dCB0aGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbCB3aGljaCB3aWxsIGNoYW5nZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGVzY3JpcHRvclxuICogQHJldHVybiB7b2JqZWN0fSBBIG5ldyBpbnN0YW5jZSBvZiBjb21wb25lbnREZXNjcmlwdG9yJ3MgY29uc3RydWN0b3IuXG4gKiBAcHJvdGVjdGVkXG4gKi9cbmZ1bmN0aW9uIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQoZGVzY3JpcHRvcikge1xuXG4gIC8vIFRPRE86IE1ha2Ugd2FybmluZ1xuICAvLyBpZiAoX19ERVZfXykge1xuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICBpc1ZhbGlkQ29tcG9uZW50RGVzY3JpcHRvcihkZXNjcmlwdG9yKSxcbiAgICAgICdPbmx5IFJlYWN0IENvbXBvbmVudHMgYXJlIHZhbGlkIGZvciBtb3VudGluZy4nXG4gICAgKSA6IGludmFyaWFudChpc1ZhbGlkQ29tcG9uZW50RGVzY3JpcHRvcihkZXNjcmlwdG9yKSkpO1xuICAvLyB9XG5cbiAgcmV0dXJuIG5ldyBkZXNjcmlwdG9yLnR5cGUoZGVzY3JpcHRvcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudDtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBpbnZhcmlhbnRcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gKlxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICogZXhwZWN0aW5nLlxuICpcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gKi9cblxudmFyIGludmFyaWFudCA9IGZ1bmN0aW9uKGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAnTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArXG4gICAgICAgICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLidcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAnSW52YXJpYW50IFZpb2xhdGlvbjogJyArXG4gICAgICAgIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107IH0pXG4gICAgICApO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBpc0V2ZW50U3VwcG9ydGVkXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoXCIuL0V4ZWN1dGlvbkVudmlyb25tZW50XCIpO1xuXG52YXIgdXNlSGFzRmVhdHVyZTtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgdXNlSGFzRmVhdHVyZSA9XG4gICAgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24gJiZcbiAgICBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlICYmXG4gICAgLy8gYWx3YXlzIHJldHVybnMgdHJ1ZSBpbiBuZXdlciBicm93c2VycyBhcyBwZXIgdGhlIHN0YW5kYXJkLlxuICAgIC8vIEBzZWUgaHR0cDovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1kb21pbXBsZW1lbnRhdGlvbi1oYXNmZWF0dXJlXG4gICAgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSgnJywgJycpICE9PSB0cnVlO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhbiBldmVudCBpcyBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGVudmlyb25tZW50LlxuICpcbiAqIE5PVEU6IFRoaXMgd2lsbCBub3Qgd29yayBjb3JyZWN0bHkgZm9yIG5vbi1nZW5lcmljIGV2ZW50cyBzdWNoIGFzIGBjaGFuZ2VgLFxuICogYHJlc2V0YCwgYGxvYWRgLCBgZXJyb3JgLCBhbmQgYHNlbGVjdGAuXG4gKlxuICogQm9ycm93cyBmcm9tIE1vZGVybml6ci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lU3VmZml4IEV2ZW50IG5hbWUsIGUuZy4gXCJjbGlja1wiLlxuICogQHBhcmFtIHs/Ym9vbGVhbn0gY2FwdHVyZSBDaGVjayBpZiB0aGUgY2FwdHVyZSBwaGFzZSBpcyBzdXBwb3J0ZWQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCBpcyBzdXBwb3J0ZWQuXG4gKiBAaW50ZXJuYWxcbiAqIEBsaWNlbnNlIE1vZGVybml6ciAzLjAuMHByZSAoQ3VzdG9tIEJ1aWxkKSB8IE1JVFxuICovXG5mdW5jdGlvbiBpc0V2ZW50U3VwcG9ydGVkKGV2ZW50TmFtZVN1ZmZpeCwgY2FwdHVyZSkge1xuICBpZiAoIUV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSB8fFxuICAgICAgY2FwdHVyZSAmJiAhKCdhZGRFdmVudExpc3RlbmVyJyBpbiBkb2N1bWVudCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgZXZlbnROYW1lID0gJ29uJyArIGV2ZW50TmFtZVN1ZmZpeDtcbiAgdmFyIGlzU3VwcG9ydGVkID0gZXZlbnROYW1lIGluIGRvY3VtZW50O1xuXG4gIGlmICghaXNTdXBwb3J0ZWQpIHtcbiAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGV2ZW50TmFtZSwgJ3JldHVybjsnKTtcbiAgICBpc1N1cHBvcnRlZCA9IHR5cGVvZiBlbGVtZW50W2V2ZW50TmFtZV0gPT09ICdmdW5jdGlvbic7XG4gIH1cblxuICBpZiAoIWlzU3VwcG9ydGVkICYmIHVzZUhhc0ZlYXR1cmUgJiYgZXZlbnROYW1lU3VmZml4ID09PSAnd2hlZWwnKSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgb25seSB3YXkgdG8gdGVzdCBzdXBwb3J0IGZvciB0aGUgYHdoZWVsYCBldmVudCBpbiBJRTkrLlxuICAgIGlzU3VwcG9ydGVkID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSgnRXZlbnRzLndoZWVsJywgJzMuMCcpO1xuICB9XG5cbiAgcmV0dXJuIGlzU3VwcG9ydGVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRXZlbnRTdXBwb3J0ZWQ7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaXNOb2RlXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qKlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBvYmplY3QgaXMgYSBET00gbm9kZS5cbiAqL1xuZnVuY3Rpb24gaXNOb2RlKG9iamVjdCkge1xuICByZXR1cm4gISEob2JqZWN0ICYmIChcbiAgICB0eXBlb2YgTm9kZSA9PT0gJ2Z1bmN0aW9uJyA/IG9iamVjdCBpbnN0YW5jZW9mIE5vZGUgOlxuICAgICAgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIHR5cGVvZiBvYmplY3Qubm9kZVR5cGUgPT09ICdudW1iZXInICYmXG4gICAgICB0eXBlb2Ygb2JqZWN0Lm5vZGVOYW1lID09PSAnc3RyaW5nJ1xuICApKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc05vZGU7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaXNUZXh0SW5wdXRFbGVtZW50XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQHNlZSBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtaW5wdXQtZWxlbWVudC5odG1sI2lucHV0LXR5cGUtYXR0ci1zdW1tYXJ5XG4gKi9cbnZhciBzdXBwb3J0ZWRJbnB1dFR5cGVzID0ge1xuICAnY29sb3InOiB0cnVlLFxuICAnZGF0ZSc6IHRydWUsXG4gICdkYXRldGltZSc6IHRydWUsXG4gICdkYXRldGltZS1sb2NhbCc6IHRydWUsXG4gICdlbWFpbCc6IHRydWUsXG4gICdtb250aCc6IHRydWUsXG4gICdudW1iZXInOiB0cnVlLFxuICAncGFzc3dvcmQnOiB0cnVlLFxuICAncmFuZ2UnOiB0cnVlLFxuICAnc2VhcmNoJzogdHJ1ZSxcbiAgJ3RlbCc6IHRydWUsXG4gICd0ZXh0JzogdHJ1ZSxcbiAgJ3RpbWUnOiB0cnVlLFxuICAndXJsJzogdHJ1ZSxcbiAgJ3dlZWsnOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBpc1RleHRJbnB1dEVsZW1lbnQoZWxlbSkge1xuICByZXR1cm4gZWxlbSAmJiAoXG4gICAgKGVsZW0ubm9kZU5hbWUgPT09ICdJTlBVVCcgJiYgc3VwcG9ydGVkSW5wdXRUeXBlc1tlbGVtLnR5cGVdKSB8fFxuICAgIGVsZW0ubm9kZU5hbWUgPT09ICdURVhUQVJFQSdcbiAgKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1RleHRJbnB1dEVsZW1lbnQ7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaXNUZXh0Tm9kZVxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgaXNOb2RlID0gcmVxdWlyZShcIi4vaXNOb2RlXCIpO1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgb2JqZWN0IGlzIGEgRE9NIHRleHQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gaXNUZXh0Tm9kZShvYmplY3QpIHtcbiAgcmV0dXJuIGlzTm9kZShvYmplY3QpICYmIG9iamVjdC5ub2RlVHlwZSA9PSAzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVGV4dE5vZGU7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgam9pbkNsYXNzZXNcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29tYmluZXMgbXVsdGlwbGUgY2xhc3NOYW1lIHN0cmluZ3MgaW50byBvbmUuXG4gKiBodHRwOi8vanNwZXJmLmNvbS9qb2luY2xhc3Nlcy1hcmdzLXZzLWFycmF5XG4gKlxuICogQHBhcmFtIHsuLi4/c3RyaW5nfSBjbGFzc2VzXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGpvaW5DbGFzc2VzKGNsYXNzTmFtZS8qLCAuLi4gKi8pIHtcbiAgaWYgKCFjbGFzc05hbWUpIHtcbiAgICBjbGFzc05hbWUgPSAnJztcbiAgfVxuICB2YXIgbmV4dENsYXNzO1xuICB2YXIgYXJnTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgaWYgKGFyZ0xlbmd0aCA+IDEpIHtcbiAgICBmb3IgKHZhciBpaSA9IDE7IGlpIDwgYXJnTGVuZ3RoOyBpaSsrKSB7XG4gICAgICBuZXh0Q2xhc3MgPSBhcmd1bWVudHNbaWldO1xuICAgICAgbmV4dENsYXNzICYmIChjbGFzc05hbWUgKz0gJyAnICsgbmV4dENsYXNzKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNsYXNzTmFtZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBqb2luQ2xhc3NlcztcbiIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUga2V5TWlycm9yXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYW4gZW51bWVyYXRpb24gd2l0aCBrZXlzIGVxdWFsIHRvIHRoZWlyIHZhbHVlLlxuICpcbiAqIEZvciBleGFtcGxlOlxuICpcbiAqICAgdmFyIENPTE9SUyA9IGtleU1pcnJvcih7Ymx1ZTogbnVsbCwgcmVkOiBudWxsfSk7XG4gKiAgIHZhciBteUNvbG9yID0gQ09MT1JTLmJsdWU7XG4gKiAgIHZhciBpc0NvbG9yVmFsaWQgPSAhIUNPTE9SU1tteUNvbG9yXTtcbiAqXG4gKiBUaGUgbGFzdCBsaW5lIGNvdWxkIG5vdCBiZSBwZXJmb3JtZWQgaWYgdGhlIHZhbHVlcyBvZiB0aGUgZ2VuZXJhdGVkIGVudW0gd2VyZVxuICogbm90IGVxdWFsIHRvIHRoZWlyIGtleXMuXG4gKlxuICogICBJbnB1dDogIHtrZXkxOiB2YWwxLCBrZXkyOiB2YWwyfVxuICogICBPdXRwdXQ6IHtrZXkxOiBrZXkxLCBrZXkyOiBrZXkyfVxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xudmFyIGtleU1pcnJvciA9IGZ1bmN0aW9uKG9iaikge1xuICB2YXIgcmV0ID0ge307XG4gIHZhciBrZXk7XG4gIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgb2JqIGluc3RhbmNlb2YgT2JqZWN0ICYmICFBcnJheS5pc0FycmF5KG9iaiksXG4gICAgJ2tleU1pcnJvciguLi4pOiBBcmd1bWVudCBtdXN0IGJlIGFuIG9iamVjdC4nXG4gICkgOiBpbnZhcmlhbnQob2JqIGluc3RhbmNlb2YgT2JqZWN0ICYmICFBcnJheS5pc0FycmF5KG9iaikpKTtcbiAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgaWYgKCFvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHJldFtrZXldID0ga2V5O1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGtleU1pcnJvcjtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGtleU9mXG4gKi9cblxuLyoqXG4gKiBBbGxvd3MgZXh0cmFjdGlvbiBvZiBhIG1pbmlmaWVkIGtleS4gTGV0J3MgdGhlIGJ1aWxkIHN5c3RlbSBtaW5pZnkga2V5c1xuICogd2l0aG91dCBsb29zaW5nIHRoZSBhYmlsaXR5IHRvIGR5bmFtaWNhbGx5IHVzZSBrZXkgc3RyaW5ncyBhcyB2YWx1ZXNcbiAqIHRoZW1zZWx2ZXMuIFBhc3MgaW4gYW4gb2JqZWN0IHdpdGggYSBzaW5nbGUga2V5L3ZhbCBwYWlyIGFuZCBpdCB3aWxsIHJldHVyblxuICogeW91IHRoZSBzdHJpbmcga2V5IG9mIHRoYXQgc2luZ2xlIHJlY29yZC4gU3VwcG9zZSB5b3Ugd2FudCB0byBncmFiIHRoZVxuICogdmFsdWUgZm9yIGEga2V5ICdjbGFzc05hbWUnIGluc2lkZSBvZiBhbiBvYmplY3QuIEtleS92YWwgbWluaWZpY2F0aW9uIG1heVxuICogaGF2ZSBhbGlhc2VkIHRoYXQga2V5IHRvIGJlICd4YTEyJy4ga2V5T2Yoe2NsYXNzTmFtZTogbnVsbH0pIHdpbGwgcmV0dXJuXG4gKiAneGExMicgaW4gdGhhdCBjYXNlLiBSZXNvbHZlIGtleXMgeW91IHdhbnQgdG8gdXNlIG9uY2UgYXQgc3RhcnR1cCB0aW1lLCB0aGVuXG4gKiByZXVzZSB0aG9zZSByZXNvbHV0aW9ucy5cbiAqL1xudmFyIGtleU9mID0gZnVuY3Rpb24ob25lS2V5T2JqKSB7XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIG9uZUtleU9iaikge1xuICAgIGlmICghb25lS2V5T2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleU9mO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIG1hcE9iamVjdFxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIEZvciBlYWNoIGtleS92YWx1ZSBwYWlyLCBpbnZva2VzIGNhbGxiYWNrIGZ1bmMgYW5kIGNvbnN0cnVjdHMgYSByZXN1bHRpbmdcbiAqIG9iamVjdCB3aGljaCBjb250YWlucywgZm9yIGV2ZXJ5IGtleSBpbiBvYmosIHZhbHVlcyB0aGF0IGFyZSB0aGUgcmVzdWx0IG9mXG4gKiBvZiBpbnZva2luZyB0aGUgZnVuY3Rpb246XG4gKlxuICogICBmdW5jKHZhbHVlLCBrZXksIGl0ZXJhdGlvbilcbiAqXG4gKiBHcmVwYWJsZSBuYW1lczpcbiAqXG4gKiAgIGZ1bmN0aW9uIG9iamVjdE1hcCgpXG4gKiAgIGZ1bmN0aW9uIG9iak1hcCgpXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmogT2JqZWN0IHRvIG1hcCBrZXlzIG92ZXJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmMgSW52b2tlZCBmb3IgZWFjaCBrZXkvdmFsIHBhaXIuXG4gKiBAcGFyYW0gez8qfSBjb250ZXh0XG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBSZXN1bHQgb2YgbWFwcGluZyBvciBudWxsIGlmIG9iaiBpcyBmYWxzZXlcbiAqL1xuZnVuY3Rpb24gbWFwT2JqZWN0KG9iaiwgZnVuYywgY29udGV4dCkge1xuICBpZiAoIW9iaikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBpID0gMDtcbiAgdmFyIHJldCA9IHt9O1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICByZXRba2V5XSA9IGZ1bmMuY2FsbChjb250ZXh0LCBvYmpba2V5XSwga2V5LCBpKyspO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcE9iamVjdDtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBtZW1vaXplU3RyaW5nT25seVxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBNZW1vaXplcyB0aGUgcmV0dXJuIHZhbHVlIG9mIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIG9uZSBzdHJpbmcgYXJndW1lbnQuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm4ge2Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBtZW1vaXplU3RyaW5nT25seShjYWxsYmFjaykge1xuICB2YXIgY2FjaGUgPSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgIGlmIChjYWNoZS5oYXNPd25Qcm9wZXJ0eShzdHJpbmcpKSB7XG4gICAgICByZXR1cm4gY2FjaGVbc3RyaW5nXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNhY2hlW3N0cmluZ10gPSBjYWxsYmFjay5jYWxsKHRoaXMsIHN0cmluZyk7XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1lbW9pemVTdHJpbmdPbmx5O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIG1lcmdlXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBtZXJnZUludG8gPSByZXF1aXJlKFwiLi9tZXJnZUludG9cIik7XG5cbi8qKlxuICogU2hhbGxvdyBtZXJnZXMgdHdvIHN0cnVjdHVyZXMgaW50byBhIHJldHVybiB2YWx1ZSwgd2l0aG91dCBtdXRhdGluZyBlaXRoZXIuXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBvbmUgT3B0aW9uYWwgb2JqZWN0IHdpdGggcHJvcGVydGllcyB0byBtZXJnZSBmcm9tLlxuICogQHBhcmFtIHs/b2JqZWN0fSB0d28gT3B0aW9uYWwgb2JqZWN0IHdpdGggcHJvcGVydGllcyB0byBtZXJnZSBmcm9tLlxuICogQHJldHVybiB7b2JqZWN0fSBUaGUgc2hhbGxvdyBleHRlbnNpb24gb2Ygb25lIGJ5IHR3by5cbiAqL1xudmFyIG1lcmdlID0gZnVuY3Rpb24ob25lLCB0d28pIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBtZXJnZUludG8ocmVzdWx0LCBvbmUpO1xuICBtZXJnZUludG8ocmVzdWx0LCB0d28pO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBtZXJnZTtcbiIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgbWVyZ2VIZWxwZXJzXG4gKlxuICogcmVxdWlyZXNQb2x5ZmlsbHM6IEFycmF5LmlzQXJyYXlcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoXCIuL2ludmFyaWFudFwiKTtcbnZhciBrZXlNaXJyb3IgPSByZXF1aXJlKFwiLi9rZXlNaXJyb3JcIik7XG5cbi8qKlxuICogTWF4aW11bSBudW1iZXIgb2YgbGV2ZWxzIHRvIHRyYXZlcnNlLiBXaWxsIGNhdGNoIGNpcmN1bGFyIHN0cnVjdHVyZXMuXG4gKiBAY29uc3RcbiAqL1xudmFyIE1BWF9NRVJHRV9ERVBUSCA9IDM2O1xuXG4vKipcbiAqIFdlIHdvbid0IHdvcnJ5IGFib3V0IGVkZ2UgY2FzZXMgbGlrZSBuZXcgU3RyaW5nKCd4Jykgb3IgbmV3IEJvb2xlYW4odHJ1ZSkuXG4gKiBGdW5jdGlvbnMgYXJlIGNvbnNpZGVyZWQgdGVybWluYWxzLCBhbmQgYXJyYXlzIGFyZSBub3QuXG4gKiBAcGFyYW0geyp9IG8gVGhlIGl0ZW0vb2JqZWN0L3ZhbHVlIHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmZiB0aGUgYXJndW1lbnQgaXMgYSB0ZXJtaW5hbC5cbiAqL1xudmFyIGlzVGVybWluYWwgPSBmdW5jdGlvbihvKSB7XG4gIHJldHVybiB0eXBlb2YgbyAhPT0gJ29iamVjdCcgfHwgbyA9PT0gbnVsbDtcbn07XG5cbnZhciBtZXJnZUhlbHBlcnMgPSB7XG5cbiAgTUFYX01FUkdFX0RFUFRIOiBNQVhfTUVSR0VfREVQVEgsXG5cbiAgaXNUZXJtaW5hbDogaXNUZXJtaW5hbCxcblxuICAvKipcbiAgICogQ29udmVydHMgbnVsbC91bmRlZmluZWQgdmFsdWVzIGludG8gZW1wdHkgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0gez9PYmplY3Q9fSBhcmcgQXJndW1lbnQgdG8gYmUgbm9ybWFsaXplZCAobnVsbGFibGUgb3B0aW9uYWwpXG4gICAqIEByZXR1cm4geyFPYmplY3R9XG4gICAqL1xuICBub3JtYWxpemVNZXJnZUFyZzogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PT0gdW5kZWZpbmVkIHx8IGFyZyA9PT0gbnVsbCA/IHt9IDogYXJnO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJZiBtZXJnaW5nIEFycmF5cywgYSBtZXJnZSBzdHJhdGVneSAqbXVzdCogYmUgc3VwcGxpZWQuIElmIG5vdCwgaXQgaXNcbiAgICogbGlrZWx5IHRoZSBjYWxsZXIncyBmYXVsdC4gSWYgdGhpcyBmdW5jdGlvbiBpcyBldmVyIGNhbGxlZCB3aXRoIGFueXRoaW5nXG4gICAqIGJ1dCBgb25lYCBhbmQgYHR3b2AgYmVpbmcgYEFycmF5YHMsIGl0IGlzIHRoZSBmYXVsdCBvZiB0aGUgbWVyZ2UgdXRpbGl0aWVzLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IG9uZSBBcnJheSB0byBtZXJnZSBpbnRvLlxuICAgKiBAcGFyYW0geyp9IHR3byBBcnJheSB0byBtZXJnZSBmcm9tLlxuICAgKi9cbiAgY2hlY2tNZXJnZUFycmF5QXJnczogZnVuY3Rpb24ob25lLCB0d28pIHtcbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgQXJyYXkuaXNBcnJheShvbmUpICYmIEFycmF5LmlzQXJyYXkodHdvKSxcbiAgICAgICdUcmllZCB0byBtZXJnZSBhcnJheXMsIGluc3RlYWQgZ290ICVzIGFuZCAlcy4nLFxuICAgICAgb25lLFxuICAgICAgdHdvXG4gICAgKSA6IGludmFyaWFudChBcnJheS5pc0FycmF5KG9uZSkgJiYgQXJyYXkuaXNBcnJheSh0d28pKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Kn0gb25lIE9iamVjdCB0byBtZXJnZSBpbnRvLlxuICAgKiBAcGFyYW0geyp9IHR3byBPYmplY3QgdG8gbWVyZ2UgZnJvbS5cbiAgICovXG4gIGNoZWNrTWVyZ2VPYmplY3RBcmdzOiBmdW5jdGlvbihvbmUsIHR3bykge1xuICAgIG1lcmdlSGVscGVycy5jaGVja01lcmdlT2JqZWN0QXJnKG9uZSk7XG4gICAgbWVyZ2VIZWxwZXJzLmNoZWNrTWVyZ2VPYmplY3RBcmcodHdvKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHsqfSBhcmdcbiAgICovXG4gIGNoZWNrTWVyZ2VPYmplY3RBcmc6IGZ1bmN0aW9uKGFyZykge1xuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICAhaXNUZXJtaW5hbChhcmcpICYmICFBcnJheS5pc0FycmF5KGFyZyksXG4gICAgICAnVHJpZWQgdG8gbWVyZ2UgYW4gb2JqZWN0LCBpbnN0ZWFkIGdvdCAlcy4nLFxuICAgICAgYXJnXG4gICAgKSA6IGludmFyaWFudCghaXNUZXJtaW5hbChhcmcpICYmICFBcnJheS5pc0FycmF5KGFyZykpKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHsqfSBhcmdcbiAgICovXG4gIGNoZWNrTWVyZ2VJbnRvT2JqZWN0QXJnOiBmdW5jdGlvbihhcmcpIHtcbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgKCFpc1Rlcm1pbmFsKGFyZykgfHwgdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJykgJiYgIUFycmF5LmlzQXJyYXkoYXJnKSxcbiAgICAgICdUcmllZCB0byBtZXJnZSBpbnRvIGFuIG9iamVjdCwgaW5zdGVhZCBnb3QgJXMuJyxcbiAgICAgIGFyZ1xuICAgICkgOiBpbnZhcmlhbnQoKCFpc1Rlcm1pbmFsKGFyZykgfHwgdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJykgJiYgIUFycmF5LmlzQXJyYXkoYXJnKSkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVja3MgdGhhdCBhIG1lcmdlIHdhcyBub3QgZ2l2ZW4gYSBjaXJjdWxhciBvYmplY3Qgb3IgYW4gb2JqZWN0IHRoYXQgaGFkXG4gICAqIHRvbyBncmVhdCBvZiBkZXB0aC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IExldmVsIG9mIHJlY3Vyc2lvbiB0byB2YWxpZGF0ZSBhZ2FpbnN0IG1heGltdW0uXG4gICAqL1xuICBjaGVja01lcmdlTGV2ZWw6IGZ1bmN0aW9uKGxldmVsKSB7XG4gICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgIGxldmVsIDwgTUFYX01FUkdFX0RFUFRILFxuICAgICAgJ01heGltdW0gZGVlcCBtZXJnZSBkZXB0aCBleGNlZWRlZC4gWW91IG1heSBiZSBhdHRlbXB0aW5nIHRvIG1lcmdlICcgK1xuICAgICAgJ2NpcmN1bGFyIHN0cnVjdHVyZXMgaW4gYW4gdW5zdXBwb3J0ZWQgd2F5LidcbiAgICApIDogaW52YXJpYW50KGxldmVsIDwgTUFYX01FUkdFX0RFUFRIKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrcyB0aGF0IHRoZSBzdXBwbGllZCBtZXJnZSBzdHJhdGVneSBpcyB2YWxpZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IEFycmF5IG1lcmdlIHN0cmF0ZWd5LlxuICAgKi9cbiAgY2hlY2tBcnJheVN0cmF0ZWd5OiBmdW5jdGlvbihzdHJhdGVneSkge1xuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICBzdHJhdGVneSA9PT0gdW5kZWZpbmVkIHx8IHN0cmF0ZWd5IGluIG1lcmdlSGVscGVycy5BcnJheVN0cmF0ZWdpZXMsXG4gICAgICAnWW91IG11c3QgcHJvdmlkZSBhbiBhcnJheSBzdHJhdGVneSB0byBkZWVwIG1lcmdlIGZ1bmN0aW9ucyB0byAnICtcbiAgICAgICdpbnN0cnVjdCB0aGUgZGVlcCBtZXJnZSBob3cgdG8gcmVzb2x2ZSBtZXJnaW5nIHR3byBhcnJheXMuJ1xuICAgICkgOiBpbnZhcmlhbnQoc3RyYXRlZ3kgPT09IHVuZGVmaW5lZCB8fCBzdHJhdGVneSBpbiBtZXJnZUhlbHBlcnMuQXJyYXlTdHJhdGVnaWVzKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldCBvZiBwb3NzaWJsZSBiZWhhdmlvcnMgb2YgbWVyZ2UgYWxnb3JpdGhtcyB3aGVuIGVuY291bnRlcmluZyB0d28gQXJyYXlzXG4gICAqIHRoYXQgbXVzdCBiZSBtZXJnZWQgdG9nZXRoZXIuXG4gICAqIC0gYGNsb2JiZXJgOiBUaGUgbGVmdCBgQXJyYXlgIGlzIGlnbm9yZWQuXG4gICAqIC0gYGluZGV4QnlJbmRleGA6IFRoZSByZXN1bHQgaXMgYWNoaWV2ZWQgYnkgcmVjdXJzaXZlbHkgZGVlcCBtZXJnaW5nIGF0XG4gICAqICAgZWFjaCBpbmRleC4gKG5vdCB5ZXQgc3VwcG9ydGVkLilcbiAgICovXG4gIEFycmF5U3RyYXRlZ2llczoga2V5TWlycm9yKHtcbiAgICBDbG9iYmVyOiB0cnVlLFxuICAgIEluZGV4QnlJbmRleDogdHJ1ZVxuICB9KVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1lcmdlSGVscGVycztcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIG1lcmdlSW50b1xuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIG1lcmdlSGVscGVycyA9IHJlcXVpcmUoXCIuL21lcmdlSGVscGVyc1wiKTtcblxudmFyIGNoZWNrTWVyZ2VPYmplY3RBcmcgPSBtZXJnZUhlbHBlcnMuY2hlY2tNZXJnZU9iamVjdEFyZztcbnZhciBjaGVja01lcmdlSW50b09iamVjdEFyZyA9IG1lcmdlSGVscGVycy5jaGVja01lcmdlSW50b09iamVjdEFyZztcblxuLyoqXG4gKiBTaGFsbG93IG1lcmdlcyB0d28gc3RydWN0dXJlcyBieSBtdXRhdGluZyB0aGUgZmlyc3QgcGFyYW1ldGVyLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSBvbmUgT2JqZWN0IHRvIGJlIG1lcmdlZCBpbnRvLlxuICogQHBhcmFtIHs/b2JqZWN0fSB0d28gT3B0aW9uYWwgb2JqZWN0IHdpdGggcHJvcGVydGllcyB0byBtZXJnZSBmcm9tLlxuICovXG5mdW5jdGlvbiBtZXJnZUludG8ob25lLCB0d28pIHtcbiAgY2hlY2tNZXJnZUludG9PYmplY3RBcmcob25lKTtcbiAgaWYgKHR3byAhPSBudWxsKSB7XG4gICAgY2hlY2tNZXJnZU9iamVjdEFyZyh0d28pO1xuICAgIGZvciAodmFyIGtleSBpbiB0d28pIHtcbiAgICAgIGlmICghdHdvLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBvbmVba2V5XSA9IHR3b1trZXldO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1lcmdlSW50bztcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBtaXhJbnRvXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogU2ltcGx5IGNvcGllcyBwcm9wZXJ0aWVzIHRvIHRoZSBwcm90b3R5cGUuXG4gKi9cbnZhciBtaXhJbnRvID0gZnVuY3Rpb24oY29uc3RydWN0b3IsIG1ldGhvZEJhZykge1xuICB2YXIgbWV0aG9kTmFtZTtcbiAgZm9yIChtZXRob2ROYW1lIGluIG1ldGhvZEJhZykge1xuICAgIGlmICghbWV0aG9kQmFnLmhhc093blByb3BlcnR5KG1ldGhvZE5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IucHJvdG90eXBlW21ldGhvZE5hbWVdID0gbWV0aG9kQmFnW21ldGhvZE5hbWVdO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1peEludG87XG4iLCIoZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBtb25pdG9yQ29kZVVzZVxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xuXG4vKipcbiAqIFByb3ZpZGVzIG9wZW4tc291cmNlIGNvbXBhdGlibGUgaW5zdHJ1bWVudGF0aW9uIGZvciBtb25pdG9yaW5nIGNlcnRhaW4gQVBJXG4gKiB1c2VzIGJlZm9yZSB3ZSdyZSByZWFkeSB0byBpc3N1ZSBhIHdhcm5pbmcgb3IgcmVmYWN0b3IuIEl0IGFjY2VwdHMgYW4gZXZlbnRcbiAqIG5hbWUgd2hpY2ggbWF5IG9ubHkgY29udGFpbiB0aGUgY2hhcmFjdGVycyBbYS16MC05X10gYW5kIGFuIG9wdGlvbmFsIGRhdGFcbiAqIG9iamVjdCB3aXRoIGZ1cnRoZXIgaW5mb3JtYXRpb24uXG4gKi9cblxuZnVuY3Rpb24gbW9uaXRvckNvZGVVc2UoZXZlbnROYW1lLCBkYXRhKSB7XG4gIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgZXZlbnROYW1lICYmICEvW15hLXowLTlfXS8udGVzdChldmVudE5hbWUpLFxuICAgICdZb3UgbXVzdCBwcm92aWRlIGFuIGV2ZW50TmFtZSB1c2luZyBvbmx5IHRoZSBjaGFyYWN0ZXJzIFthLXowLTlfXSdcbiAgKSA6IGludmFyaWFudChldmVudE5hbWUgJiYgIS9bXmEtejAtOV9dLy50ZXN0KGV2ZW50TmFtZSkpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtb25pdG9yQ29kZVVzZTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBvbmx5Q2hpbGRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBSZWFjdERlc2NyaXB0b3IgPSByZXF1aXJlKFwiLi9SZWFjdERlc2NyaXB0b3JcIik7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgY2hpbGQgaW4gYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuIGFuZCB2ZXJpZmllcyB0aGF0IHRoZXJlXG4gKiBpcyBvbmx5IG9uZSBjaGlsZCBpbiB0aGUgY29sbGVjdGlvbi4gVGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gb2YgdGhpc1xuICogZnVuY3Rpb24gYXNzdW1lcyB0aGF0IGEgc2luZ2xlIGNoaWxkIGdldHMgcGFzc2VkIHdpdGhvdXQgYSB3cmFwcGVyLCBidXQgdGhlXG4gKiBwdXJwb3NlIG9mIHRoaXMgaGVscGVyIGZ1bmN0aW9uIGlzIHRvIGFic3RyYWN0IGF3YXkgdGhlIHBhcnRpY3VsYXIgc3RydWN0dXJlXG4gKiBvZiBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGNoaWxkcmVuIENoaWxkIGNvbGxlY3Rpb24gc3RydWN0dXJlLlxuICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IFRoZSBmaXJzdCBhbmQgb25seSBgUmVhY3RDb21wb25lbnRgIGNvbnRhaW5lZCBpbiB0aGVcbiAqIHN0cnVjdHVyZS5cbiAqL1xuZnVuY3Rpb24gb25seUNoaWxkKGNoaWxkcmVuKSB7XG4gIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgUmVhY3REZXNjcmlwdG9yLmlzVmFsaWREZXNjcmlwdG9yKGNoaWxkcmVuKSxcbiAgICAnb25seUNoaWxkIG11c3QgYmUgcGFzc2VkIGEgY2hpbGRyZW4gd2l0aCBleGFjdGx5IG9uZSBjaGlsZC4nXG4gICkgOiBpbnZhcmlhbnQoUmVhY3REZXNjcmlwdG9yLmlzVmFsaWREZXNjcmlwdG9yKGNoaWxkcmVuKSkpO1xuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb25seUNoaWxkO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSkiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgcGVyZm9ybWFuY2VcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoXCIuL0V4ZWN1dGlvbkVudmlyb25tZW50XCIpO1xuXG52YXIgcGVyZm9ybWFuY2U7XG5cbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgcGVyZm9ybWFuY2UgPVxuICAgIHdpbmRvdy5wZXJmb3JtYW5jZSB8fFxuICAgIHdpbmRvdy5tc1BlcmZvcm1hbmNlIHx8XG4gICAgd2luZG93LndlYmtpdFBlcmZvcm1hbmNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBlcmZvcm1hbmNlIHx8IHt9O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHBlcmZvcm1hbmNlTm93XG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBwZXJmb3JtYW5jZSA9IHJlcXVpcmUoXCIuL3BlcmZvcm1hbmNlXCIpO1xuXG4vKipcbiAqIERldGVjdCBpZiB3ZSBjYW4gdXNlIGB3aW5kb3cucGVyZm9ybWFuY2Uubm93KClgIGFuZCBncmFjZWZ1bGx5IGZhbGxiYWNrIHRvXG4gKiBgRGF0ZS5ub3coKWAgaWYgaXQgZG9lc24ndCBleGlzdC4gV2UgbmVlZCB0byBzdXBwb3J0IEZpcmVmb3ggPCAxNSBmb3Igbm93XG4gKiBiZWNhdXNlIG9mIEZhY2Vib29rJ3MgdGVzdGluZyBpbmZyYXN0cnVjdHVyZS5cbiAqL1xuaWYgKCFwZXJmb3JtYW5jZSB8fCAhcGVyZm9ybWFuY2Uubm93KSB7XG4gIHBlcmZvcm1hbmNlID0gRGF0ZTtcbn1cblxudmFyIHBlcmZvcm1hbmNlTm93ID0gcGVyZm9ybWFuY2Uubm93LmJpbmQocGVyZm9ybWFuY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBlcmZvcm1hbmNlTm93O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHNldElubmVySFRNTFxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKFwiLi9FeGVjdXRpb25FbnZpcm9ubWVudFwiKTtcblxuLyoqXG4gKiBTZXQgdGhlIGlubmVySFRNTCBwcm9wZXJ0eSBvZiBhIG5vZGUsIGVuc3VyaW5nIHRoYXQgd2hpdGVzcGFjZSBpcyBwcmVzZXJ2ZWRcbiAqIGV2ZW4gaW4gSUU4LlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgc2V0SW5uZXJIVE1MID0gZnVuY3Rpb24obm9kZSwgaHRtbCkge1xuICBub2RlLmlubmVySFRNTCA9IGh0bWw7XG59O1xuXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIC8vIElFODogV2hlbiB1cGRhdGluZyBhIGp1c3QgY3JlYXRlZCBub2RlIHdpdGggaW5uZXJIVE1MIG9ubHkgbGVhZGluZ1xuICAvLyB3aGl0ZXNwYWNlIGlzIHJlbW92ZWQuIFdoZW4gdXBkYXRpbmcgYW4gZXhpc3Rpbmcgbm9kZSB3aXRoIGlubmVySFRNTFxuICAvLyB3aGl0ZXNwYWNlIGluIHJvb3QgVGV4dE5vZGVzIGlzIGFsc28gY29sbGFwc2VkLlxuICAvLyBAc2VlIHF1aXJrc21vZGUub3JnL2J1Z3JlcG9ydHMvYXJjaGl2ZXMvMjAwNC8xMS9pbm5lcmh0bWxfYW5kX3QuaHRtbFxuXG4gIC8vIEZlYXR1cmUgZGV0ZWN0aW9uOyBvbmx5IElFOCBpcyBrbm93biB0byBiZWhhdmUgaW1wcm9wZXJseSBsaWtlIHRoaXMuXG4gIHZhciB0ZXN0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0ZXN0RWxlbWVudC5pbm5lckhUTUwgPSAnICc7XG4gIGlmICh0ZXN0RWxlbWVudC5pbm5lckhUTUwgPT09ICcnKSB7XG4gICAgc2V0SW5uZXJIVE1MID0gZnVuY3Rpb24obm9kZSwgaHRtbCkge1xuICAgICAgLy8gTWFnaWMgdGhlb3J5OiBJRTggc3VwcG9zZWRseSBkaWZmZXJlbnRpYXRlcyBiZXR3ZWVuIGFkZGVkIGFuZCB1cGRhdGVkXG4gICAgICAvLyBub2RlcyB3aGVuIHByb2Nlc3NpbmcgaW5uZXJIVE1MLCBpbm5lckhUTUwgb24gdXBkYXRlZCBub2RlcyBzdWZmZXJzXG4gICAgICAvLyBmcm9tIHdvcnNlIHdoaXRlc3BhY2UgYmVoYXZpb3IuIFJlLWFkZGluZyBhIG5vZGUgbGlrZSB0aGlzIHRyaWdnZXJzXG4gICAgICAvLyB0aGUgaW5pdGlhbCBhbmQgbW9yZSBmYXZvcmFibGUgd2hpdGVzcGFjZSBiZWhhdmlvci5cbiAgICAgIC8vIFRPRE86IFdoYXQgdG8gZG8gb24gYSBkZXRhY2hlZCBub2RlP1xuICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICBub2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5vZGUsIG5vZGUpO1xuICAgICAgfVxuXG4gICAgICAvLyBXZSBhbHNvIGltcGxlbWVudCBhIHdvcmthcm91bmQgZm9yIG5vbi12aXNpYmxlIHRhZ3MgZGlzYXBwZWFyaW5nIGludG9cbiAgICAgIC8vIHRoaW4gYWlyIG9uIElFOCwgdGhpcyBvbmx5IGhhcHBlbnMgaWYgdGhlcmUgaXMgbm8gdmlzaWJsZSB0ZXh0XG4gICAgICAvLyBpbi1mcm9udCBvZiB0aGUgbm9uLXZpc2libGUgdGFncy4gUGlnZ3liYWNrIG9uIHRoZSB3aGl0ZXNwYWNlIGZpeFxuICAgICAgLy8gYW5kIHNpbXBseSBjaGVjayBpZiBhbnkgbm9uLXZpc2libGUgdGFncyBhcHBlYXIgaW4gdGhlIHNvdXJjZS5cbiAgICAgIGlmIChodG1sLm1hdGNoKC9eWyBcXHJcXG5cXHRcXGZdLykgfHxcbiAgICAgICAgICBodG1sWzBdID09PSAnPCcgJiYgKFxuICAgICAgICAgICAgaHRtbC5pbmRleE9mKCc8bm9zY3JpcHQnKSAhPT0gLTEgfHxcbiAgICAgICAgICAgIGh0bWwuaW5kZXhPZignPHNjcmlwdCcpICE9PSAtMSB8fFxuICAgICAgICAgICAgaHRtbC5pbmRleE9mKCc8c3R5bGUnKSAhPT0gLTEgfHxcbiAgICAgICAgICAgIGh0bWwuaW5kZXhPZignPG1ldGEnKSAhPT0gLTEgfHxcbiAgICAgICAgICAgIGh0bWwuaW5kZXhPZignPGxpbmsnKSAhPT0gLTEpKSB7XG4gICAgICAgIC8vIFJlY292ZXIgbGVhZGluZyB3aGl0ZXNwYWNlIGJ5IHRlbXBvcmFyaWx5IHByZXBlbmRpbmcgYW55IGNoYXJhY3Rlci5cbiAgICAgICAgLy8gXFx1RkVGRiBoYXMgdGhlIHBvdGVudGlhbCBhZHZhbnRhZ2Ugb2YgYmVpbmcgemVyby13aWR0aC9pbnZpc2libGUuXG4gICAgICAgIG5vZGUuaW5uZXJIVE1MID0gJ1xcdUZFRkYnICsgaHRtbDtcblxuICAgICAgICAvLyBkZWxldGVEYXRhIGxlYXZlcyBhbiBlbXB0eSBgVGV4dE5vZGVgIHdoaWNoIG9mZnNldHMgdGhlIGluZGV4IG9mIGFsbFxuICAgICAgICAvLyBjaGlsZHJlbi4gRGVmaW5pdGVseSB3YW50IHRvIGF2b2lkIHRoaXMuXG4gICAgICAgIHZhciB0ZXh0Tm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgaWYgKHRleHROb2RlLmRhdGEubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgbm9kZS5yZW1vdmVDaGlsZCh0ZXh0Tm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dE5vZGUuZGVsZXRlRGF0YSgwLCAxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRJbm5lckhUTUw7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgc2hhbGxvd0VxdWFsXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogUGVyZm9ybXMgZXF1YWxpdHkgYnkgaXRlcmF0aW5nIHRocm91Z2gga2V5cyBvbiBhbiBvYmplY3QgYW5kIHJldHVybmluZ1xuICogZmFsc2Ugd2hlbiBhbnkga2V5IGhhcyB2YWx1ZXMgd2hpY2ggYXJlIG5vdCBzdHJpY3RseSBlcXVhbCBiZXR3ZWVuXG4gKiBvYmpBIGFuZCBvYmpCLiBSZXR1cm5zIHRydWUgd2hlbiB0aGUgdmFsdWVzIG9mIGFsbCBrZXlzIGFyZSBzdHJpY3RseSBlcXVhbC5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqQSwgb2JqQikge1xuICBpZiAob2JqQSA9PT0gb2JqQikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBrZXk7XG4gIC8vIFRlc3QgZm9yIEEncyBrZXlzIGRpZmZlcmVudCBmcm9tIEIuXG4gIGZvciAoa2V5IGluIG9iakEpIHtcbiAgICBpZiAob2JqQS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmXG4gICAgICAgICghb2JqQi5oYXNPd25Qcm9wZXJ0eShrZXkpIHx8IG9iakFba2V5XSAhPT0gb2JqQltrZXldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvLyBUZXN0IGZvciBCJ2Ega2V5cyBtaXNzaW5nIGZyb20gQS5cbiAgZm9yIChrZXkgaW4gb2JqQikge1xuICAgIGlmIChvYmpCLmhhc093blByb3BlcnR5KGtleSkgJiYgIW9iakEuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaGFsbG93RXF1YWw7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogR2l2ZW4gYSBgcHJldkRlc2NyaXB0b3JgIGFuZCBgbmV4dERlc2NyaXB0b3JgLCBkZXRlcm1pbmVzIGlmIHRoZSBleGlzdGluZ1xuICogaW5zdGFuY2Ugc2hvdWxkIGJlIHVwZGF0ZWQgYXMgb3Bwb3NlZCB0byBiZWluZyBkZXN0cm95ZWQgb3IgcmVwbGFjZWQgYnkgYSBuZXdcbiAqIGluc3RhbmNlLiBCb3RoIGFyZ3VtZW50cyBhcmUgZGVzY3JpcHRvcnMuIFRoaXMgZW5zdXJlcyB0aGF0IHRoaXMgbG9naWMgY2FuXG4gKiBvcGVyYXRlIG9uIHN0YXRlbGVzcyB0cmVlcyB3aXRob3V0IGFueSBiYWNraW5nIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gcHJldkRlc2NyaXB0b3JcbiAqIEBwYXJhbSB7P29iamVjdH0gbmV4dERlc2NyaXB0b3JcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV4aXN0aW5nIGluc3RhbmNlIHNob3VsZCBiZSB1cGRhdGVkLlxuICogQHByb3RlY3RlZFxuICovXG5mdW5jdGlvbiBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudChwcmV2RGVzY3JpcHRvciwgbmV4dERlc2NyaXB0b3IpIHtcbiAgaWYgKHByZXZEZXNjcmlwdG9yICYmIG5leHREZXNjcmlwdG9yICYmXG4gICAgICBwcmV2RGVzY3JpcHRvci50eXBlID09PSBuZXh0RGVzY3JpcHRvci50eXBlICYmIChcbiAgICAgICAgKHByZXZEZXNjcmlwdG9yLnByb3BzICYmIHByZXZEZXNjcmlwdG9yLnByb3BzLmtleSkgPT09XG4gICAgICAgIChuZXh0RGVzY3JpcHRvci5wcm9wcyAmJiBuZXh0RGVzY3JpcHRvci5wcm9wcy5rZXkpXG4gICAgICApICYmIHByZXZEZXNjcmlwdG9yLl9vd25lciA9PT0gbmV4dERlc2NyaXB0b3IuX293bmVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50O1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgdG9BcnJheVxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xuXG4vKipcbiAqIENvbnZlcnQgYXJyYXktbGlrZSBvYmplY3RzIHRvIGFycmF5cy5cbiAqXG4gKiBUaGlzIEFQSSBhc3N1bWVzIHRoZSBjYWxsZXIga25vd3MgdGhlIGNvbnRlbnRzIG9mIHRoZSBkYXRhIHR5cGUuIEZvciBsZXNzXG4gKiB3ZWxsIGRlZmluZWQgaW5wdXRzIHVzZSBjcmVhdGVBcnJheUZyb20uXG4gKlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb258ZmlsZWxpc3R9IG9ialxuICogQHJldHVybiB7YXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XG4gIHZhciBsZW5ndGggPSBvYmoubGVuZ3RoO1xuXG4gIC8vIFNvbWUgYnJvd3NlIGJ1aWx0aW4gb2JqZWN0cyBjYW4gcmVwb3J0IHR5cGVvZiAnZnVuY3Rpb24nIChlLmcuIE5vZGVMaXN0IGluXG4gIC8vIG9sZCB2ZXJzaW9ucyBvZiBTYWZhcmkpLlxuICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICFBcnJheS5pc0FycmF5KG9iaikgJiZcbiAgICAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJyksXG4gICAgJ3RvQXJyYXk6IEFycmF5LWxpa2Ugb2JqZWN0IGV4cGVjdGVkJ1xuICApIDogaW52YXJpYW50KCFBcnJheS5pc0FycmF5KG9iaikgJiZcbiAgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnIHx8IHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpKSk7XG5cbiAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICB0eXBlb2YgbGVuZ3RoID09PSAnbnVtYmVyJyxcbiAgICAndG9BcnJheTogT2JqZWN0IG5lZWRzIGEgbGVuZ3RoIHByb3BlcnR5J1xuICApIDogaW52YXJpYW50KHR5cGVvZiBsZW5ndGggPT09ICdudW1iZXInKSk7XG5cbiAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICBsZW5ndGggPT09IDAgfHxcbiAgICAobGVuZ3RoIC0gMSkgaW4gb2JqLFxuICAgICd0b0FycmF5OiBPYmplY3Qgc2hvdWxkIGhhdmUga2V5cyBmb3IgaW5kaWNlcydcbiAgKSA6IGludmFyaWFudChsZW5ndGggPT09IDAgfHxcbiAgKGxlbmd0aCAtIDEpIGluIG9iaikpO1xuXG4gIC8vIE9sZCBJRSBkb2Vzbid0IGdpdmUgY29sbGVjdGlvbnMgYWNjZXNzIHRvIGhhc093blByb3BlcnR5LiBBc3N1bWUgaW5wdXRzXG4gIC8vIHdpdGhvdXQgbWV0aG9kIHdpbGwgdGhyb3cgZHVyaW5nIHRoZSBzbGljZSBjYWxsIGFuZCBza2lwIHN0cmFpZ2h0IHRvIHRoZVxuICAvLyBmYWxsYmFjay5cbiAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwob2JqKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBJRSA8IDkgZG9lcyBub3Qgc3VwcG9ydCBBcnJheSNzbGljZSBvbiBjb2xsZWN0aW9ucyBvYmplY3RzXG4gICAgfVxuICB9XG5cbiAgLy8gRmFsbCBiYWNrIHRvIGNvcHlpbmcga2V5IGJ5IGtleS4gVGhpcyBhc3N1bWVzIGFsbCBrZXlzIGhhdmUgYSB2YWx1ZSxcbiAgLy8gc28gd2lsbCBub3QgcHJlc2VydmUgc3BhcnNlbHkgcG9wdWxhdGVkIGlucHV0cy5cbiAgdmFyIHJldCA9IEFycmF5KGxlbmd0aCk7XG4gIGZvciAodmFyIGlpID0gMDsgaWkgPCBsZW5ndGg7IGlpKyspIHtcbiAgICByZXRbaWldID0gb2JqW2lpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvQXJyYXk7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgdHJhdmVyc2VBbGxDaGlsZHJlblxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgUmVhY3RJbnN0YW5jZUhhbmRsZXMgPSByZXF1aXJlKFwiLi9SZWFjdEluc3RhbmNlSGFuZGxlc1wiKTtcbnZhciBSZWFjdFRleHRDb21wb25lbnQgPSByZXF1aXJlKFwiLi9SZWFjdFRleHRDb21wb25lbnRcIik7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKFwiLi9pbnZhcmlhbnRcIik7XG5cbnZhciBTRVBBUkFUT1IgPSBSZWFjdEluc3RhbmNlSGFuZGxlcy5TRVBBUkFUT1I7XG52YXIgU1VCU0VQQVJBVE9SID0gJzonO1xuXG4vKipcbiAqIFRPRE86IFRlc3QgdGhhdDpcbiAqIDEuIGBtYXBDaGlsZHJlbmAgdHJhbnNmb3JtcyBzdHJpbmdzIGFuZCBudW1iZXJzIGludG8gYFJlYWN0VGV4dENvbXBvbmVudGAuXG4gKiAyLiBpdCgnc2hvdWxkIGZhaWwgd2hlbiBzdXBwbGllZCBkdXBsaWNhdGUga2V5JywgZnVuY3Rpb24oKSB7XG4gKiAzLiBUaGF0IGEgc2luZ2xlIGNoaWxkIGFuZCBhbiBhcnJheSB3aXRoIG9uZSBpdGVtIGhhdmUgdGhlIHNhbWUga2V5IHBhdHRlcm4uXG4gKiB9KTtcbiAqL1xuXG52YXIgdXNlclByb3ZpZGVkS2V5RXNjYXBlckxvb2t1cCA9IHtcbiAgJz0nOiAnPTAnLFxuICAnLic6ICc9MScsXG4gICc6JzogJz0yJ1xufTtcblxudmFyIHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4ID0gL1s9LjpdL2c7XG5cbmZ1bmN0aW9uIHVzZXJQcm92aWRlZEtleUVzY2FwZXIobWF0Y2gpIHtcbiAgcmV0dXJuIHVzZXJQcm92aWRlZEtleUVzY2FwZXJMb29rdXBbbWF0Y2hdO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEga2V5IHN0cmluZyB0aGF0IGlkZW50aWZpZXMgYSBjb21wb25lbnQgd2l0aGluIGEgc2V0LlxuICpcbiAqIEBwYXJhbSB7Kn0gY29tcG9uZW50IEEgY29tcG9uZW50IHRoYXQgY291bGQgY29udGFpbiBhIG1hbnVhbCBrZXkuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggdGhhdCBpcyB1c2VkIGlmIGEgbWFudWFsIGtleSBpcyBub3QgcHJvdmlkZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvbmVudEtleShjb21wb25lbnQsIGluZGV4KSB7XG4gIGlmIChjb21wb25lbnQgJiYgY29tcG9uZW50LnByb3BzICYmIGNvbXBvbmVudC5wcm9wcy5rZXkgIT0gbnVsbCkge1xuICAgIC8vIEV4cGxpY2l0IGtleVxuICAgIHJldHVybiB3cmFwVXNlclByb3ZpZGVkS2V5KGNvbXBvbmVudC5wcm9wcy5rZXkpO1xuICB9XG4gIC8vIEltcGxpY2l0IGtleSBkZXRlcm1pbmVkIGJ5IHRoZSBpbmRleCBpbiB0aGUgc2V0XG4gIHJldHVybiBpbmRleC50b1N0cmluZygzNik7XG59XG5cbi8qKlxuICogRXNjYXBlIGEgY29tcG9uZW50IGtleSBzbyB0aGF0IGl0IGlzIHNhZmUgdG8gdXNlIGluIGEgcmVhY3RpZC5cbiAqXG4gKiBAcGFyYW0geyp9IGtleSBDb21wb25lbnQga2V5IHRvIGJlIGVzY2FwZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEFuIGVzY2FwZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBlc2NhcGVVc2VyUHJvdmlkZWRLZXkodGV4dCkge1xuICByZXR1cm4gKCcnICsgdGV4dCkucmVwbGFjZShcbiAgICB1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCxcbiAgICB1c2VyUHJvdmlkZWRLZXlFc2NhcGVyXG4gICk7XG59XG5cbi8qKlxuICogV3JhcCBhIGBrZXlgIHZhbHVlIGV4cGxpY2l0bHkgcHJvdmlkZWQgYnkgdGhlIHVzZXIgdG8gZGlzdGluZ3Vpc2ggaXQgZnJvbVxuICogaW1wbGljaXRseS1nZW5lcmF0ZWQga2V5cyBnZW5lcmF0ZWQgYnkgYSBjb21wb25lbnQncyBpbmRleCBpbiBpdHMgcGFyZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVmFsdWUgb2YgYSB1c2VyLXByb3ZpZGVkIGBrZXlgIGF0dHJpYnV0ZVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiB3cmFwVXNlclByb3ZpZGVkS2V5KGtleSkge1xuICByZXR1cm4gJyQnICsgZXNjYXBlVXNlclByb3ZpZGVkS2V5KGtleSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0geyFzdHJpbmd9IG5hbWVTb0ZhciBOYW1lIG9mIHRoZSBrZXkgcGF0aCBzbyBmYXIuXG4gKiBAcGFyYW0geyFudW1iZXJ9IGluZGV4U29GYXIgTnVtYmVyIG9mIGNoaWxkcmVuIGVuY291bnRlcmVkIHVudGlsIHRoaXMgcG9pbnQuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdpdGggZWFjaCBjaGlsZCBmb3VuZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBVc2VkIHRvIHBhc3MgaW5mb3JtYXRpb24gdGhyb3VnaG91dCB0aGUgdHJhdmVyc2FsXG4gKiBwcm9jZXNzLlxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXG4gKi9cbnZhciB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbCA9XG4gIGZ1bmN0aW9uKGNoaWxkcmVuLCBuYW1lU29GYXIsIGluZGV4U29GYXIsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcbiAgICB2YXIgc3VidHJlZUNvdW50ID0gMDsgIC8vIENvdW50IG9mIGNoaWxkcmVuIGZvdW5kIGluIHRoZSBjdXJyZW50IHN1YnRyZWUuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICB2YXIgbmV4dE5hbWUgPSAoXG4gICAgICAgICAgbmFtZVNvRmFyICtcbiAgICAgICAgICAobmFtZVNvRmFyID8gU1VCU0VQQVJBVE9SIDogU0VQQVJBVE9SKSArXG4gICAgICAgICAgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCBpKVxuICAgICAgICApO1xuICAgICAgICB2YXIgbmV4dEluZGV4ID0gaW5kZXhTb0ZhciArIHN1YnRyZWVDb3VudDtcbiAgICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKFxuICAgICAgICAgIGNoaWxkLFxuICAgICAgICAgIG5leHROYW1lLFxuICAgICAgICAgIG5leHRJbmRleCxcbiAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICB0cmF2ZXJzZUNvbnRleHRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgY2hpbGRyZW47XG4gICAgICB2YXIgaXNPbmx5Q2hpbGQgPSBuYW1lU29GYXIgPT09ICcnO1xuICAgICAgLy8gSWYgaXQncyB0aGUgb25seSBjaGlsZCwgdHJlYXQgdGhlIG5hbWUgYXMgaWYgaXQgd2FzIHdyYXBwZWQgaW4gYW4gYXJyYXlcbiAgICAgIC8vIHNvIHRoYXQgaXQncyBjb25zaXN0ZW50IGlmIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gZ3Jvd3NcbiAgICAgIHZhciBzdG9yYWdlTmFtZSA9XG4gICAgICAgIGlzT25seUNoaWxkID8gU0VQQVJBVE9SICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkcmVuLCAwKSA6IG5hbWVTb0ZhcjtcbiAgICAgIGlmIChjaGlsZHJlbiA9PSBudWxsIHx8IHR5cGUgPT09ICdib29sZWFuJykge1xuICAgICAgICAvLyBBbGwgb2YgdGhlIGFib3ZlIGFyZSBwZXJjZWl2ZWQgYXMgbnVsbC5cbiAgICAgICAgY2FsbGJhY2sodHJhdmVyc2VDb250ZXh0LCBudWxsLCBzdG9yYWdlTmFtZSwgaW5kZXhTb0Zhcik7XG4gICAgICAgIHN1YnRyZWVDb3VudCA9IDE7XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkcmVuLnR5cGUgJiYgY2hpbGRyZW4udHlwZS5wcm90b3R5cGUgJiZcbiAgICAgICAgICAgICAgICAgY2hpbGRyZW4udHlwZS5wcm90b3R5cGUubW91bnRDb21wb25lbnRJbnRvTm9kZSkge1xuICAgICAgICBjYWxsYmFjayh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkcmVuLCBzdG9yYWdlTmFtZSwgaW5kZXhTb0Zhcik7XG4gICAgICAgIHN1YnRyZWVDb3VudCA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgICAgICAgIWNoaWxkcmVuIHx8IGNoaWxkcmVuLm5vZGVUeXBlICE9PSAxLFxuICAgICAgICAgICAgJ3RyYXZlcnNlQWxsQ2hpbGRyZW4oLi4uKTogRW5jb3VudGVyZWQgYW4gaW52YWxpZCBjaGlsZDsgRE9NICcgK1xuICAgICAgICAgICAgJ2VsZW1lbnRzIGFyZSBub3QgdmFsaWQgY2hpbGRyZW4gb2YgUmVhY3QgY29tcG9uZW50cy4nXG4gICAgICAgICAgKSA6IGludmFyaWFudCghY2hpbGRyZW4gfHwgY2hpbGRyZW4ubm9kZVR5cGUgIT09IDEpKTtcbiAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgIHN1YnRyZWVDb3VudCArPSB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChcbiAgICAgICAgICAgICAgICBjaGlsZHJlbltrZXldLFxuICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgIG5hbWVTb0ZhciArIChuYW1lU29GYXIgPyBTVUJTRVBBUkFUT1IgOiBTRVBBUkFUT1IpICtcbiAgICAgICAgICAgICAgICAgIHdyYXBVc2VyUHJvdmlkZWRLZXkoa2V5KSArIFNVQlNFUEFSQVRPUiArXG4gICAgICAgICAgICAgICAgICBnZXRDb21wb25lbnRLZXkoY2hpbGRyZW5ba2V5XSwgMClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGluZGV4U29GYXIgKyBzdWJ0cmVlQ291bnQsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgdHJhdmVyc2VDb250ZXh0XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdmFyIG5vcm1hbGl6ZWRUZXh0ID0gUmVhY3RUZXh0Q29tcG9uZW50KGNoaWxkcmVuKTtcbiAgICAgICAgICBjYWxsYmFjayh0cmF2ZXJzZUNvbnRleHQsIG5vcm1hbGl6ZWRUZXh0LCBzdG9yYWdlTmFtZSwgaW5kZXhTb0Zhcik7XG4gICAgICAgICAgc3VidHJlZUNvdW50ICs9IDE7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICB2YXIgbm9ybWFsaXplZE51bWJlciA9IFJlYWN0VGV4dENvbXBvbmVudCgnJyArIGNoaWxkcmVuKTtcbiAgICAgICAgICBjYWxsYmFjayh0cmF2ZXJzZUNvbnRleHQsIG5vcm1hbGl6ZWROdW1iZXIsIHN0b3JhZ2VOYW1lLCBpbmRleFNvRmFyKTtcbiAgICAgICAgICBzdWJ0cmVlQ291bnQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3VidHJlZUNvdW50O1xuICB9O1xuXG4vKipcbiAqIFRyYXZlcnNlcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAsIGJ1dFxuICogbWlnaHQgYWxzbyBiZSBzcGVjaWZpZWQgdGhyb3VnaCBhdHRyaWJ1dGVzOlxuICpcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5jaGlsZHJlbiwgLi4uKWBcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5sZWZ0UGFuZWxDaGlsZHJlbiwgLi4uKWBcbiAqXG4gKiBUaGUgYHRyYXZlcnNlQ29udGV4dGAgaXMgYW4gb3B0aW9uYWwgYXJndW1lbnQgdGhhdCBpcyBwYXNzZWQgdGhyb3VnaCB0aGVcbiAqIGVudGlyZSB0cmF2ZXJzYWwuIEl0IGNhbiBiZSB1c2VkIHRvIHN0b3JlIGFjY3VtdWxhdGlvbnMgb3IgYW55dGhpbmcgZWxzZSB0aGF0XG4gKiB0aGUgY2FsbGJhY2sgbWlnaHQgZmluZCByZWxldmFudC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIG9iamVjdC5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBUbyBpbnZva2UgdXBvbiB0cmF2ZXJzaW5nIGVhY2ggY2hpbGQuXG4gKiBAcGFyYW0gez8qfSB0cmF2ZXJzZUNvbnRleHQgQ29udGV4dCBmb3IgdHJhdmVyc2FsLlxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgJycsIDAsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRyYXZlcnNlQWxsQ2hpbGRyZW47XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTQgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgdXBkYXRlXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjb3B5UHJvcGVydGllcyA9IHJlcXVpcmUoXCIuL2NvcHlQcm9wZXJ0aWVzXCIpO1xudmFyIGtleU9mID0gcmVxdWlyZShcIi4va2V5T2ZcIik7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZShcIi4vaW52YXJpYW50XCIpO1xuXG5mdW5jdGlvbiBzaGFsbG93Q29weSh4KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHgpKSB7XG4gICAgcmV0dXJuIHguY29uY2F0KCk7XG4gIH0gZWxzZSBpZiAoeCAmJiB0eXBlb2YgeCA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gY29weVByb3BlcnRpZXMobmV3IHguY29uc3RydWN0b3IoKSwgeCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHg7XG4gIH1cbn1cblxudmFyIENPTU1BTkRfUFVTSCA9IGtleU9mKHskcHVzaDogbnVsbH0pO1xudmFyIENPTU1BTkRfVU5TSElGVCA9IGtleU9mKHskdW5zaGlmdDogbnVsbH0pO1xudmFyIENPTU1BTkRfU1BMSUNFID0ga2V5T2YoeyRzcGxpY2U6IG51bGx9KTtcbnZhciBDT01NQU5EX1NFVCA9IGtleU9mKHskc2V0OiBudWxsfSk7XG52YXIgQ09NTUFORF9NRVJHRSA9IGtleU9mKHskbWVyZ2U6IG51bGx9KTtcbnZhciBDT01NQU5EX0FQUExZID0ga2V5T2YoeyRhcHBseTogbnVsbH0pO1xuXG52YXIgQUxMX0NPTU1BTkRTX0xJU1QgPSBbXG4gIENPTU1BTkRfUFVTSCxcbiAgQ09NTUFORF9VTlNISUZULFxuICBDT01NQU5EX1NQTElDRSxcbiAgQ09NTUFORF9TRVQsXG4gIENPTU1BTkRfTUVSR0UsXG4gIENPTU1BTkRfQVBQTFlcbl07XG5cbnZhciBBTExfQ09NTUFORFNfU0VUID0ge307XG5cbkFMTF9DT01NQU5EU19MSVNULmZvckVhY2goZnVuY3Rpb24oY29tbWFuZCkge1xuICBBTExfQ09NTUFORFNfU0VUW2NvbW1hbmRdID0gdHJ1ZTtcbn0pO1xuXG5mdW5jdGlvbiBpbnZhcmlhbnRBcnJheUNhc2UodmFsdWUsIHNwZWMsIGNvbW1hbmQpIHtcbiAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICBBcnJheS5pc0FycmF5KHZhbHVlKSxcbiAgICAndXBkYXRlKCk6IGV4cGVjdGVkIHRhcmdldCBvZiAlcyB0byBiZSBhbiBhcnJheTsgZ290ICVzLicsXG4gICAgY29tbWFuZCxcbiAgICB2YWx1ZVxuICApIDogaW52YXJpYW50KEFycmF5LmlzQXJyYXkodmFsdWUpKSk7XG4gIHZhciBzcGVjVmFsdWUgPSBzcGVjW2NvbW1hbmRdO1xuICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgIEFycmF5LmlzQXJyYXkoc3BlY1ZhbHVlKSxcbiAgICAndXBkYXRlKCk6IGV4cGVjdGVkIHNwZWMgb2YgJXMgdG8gYmUgYW4gYXJyYXk7IGdvdCAlcy4gJyArXG4gICAgJ0RpZCB5b3UgZm9yZ2V0IHRvIHdyYXAgeW91ciBwYXJhbWV0ZXIgaW4gYW4gYXJyYXk/JyxcbiAgICBjb21tYW5kLFxuICAgIHNwZWNWYWx1ZVxuICApIDogaW52YXJpYW50KEFycmF5LmlzQXJyYXkoc3BlY1ZhbHVlKSkpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGUodmFsdWUsIHNwZWMpIHtcbiAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICB0eXBlb2Ygc3BlYyA9PT0gJ29iamVjdCcsXG4gICAgJ3VwZGF0ZSgpOiBZb3UgcHJvdmlkZWQgYSBrZXkgcGF0aCB0byB1cGRhdGUoKSB0aGF0IGRpZCBub3QgY29udGFpbiBvbmUgJyArXG4gICAgJ29mICVzLiBEaWQgeW91IGZvcmdldCB0byBpbmNsdWRlIHslczogLi4ufT8nLFxuICAgIEFMTF9DT01NQU5EU19MSVNULmpvaW4oJywgJyksXG4gICAgQ09NTUFORF9TRVRcbiAgKSA6IGludmFyaWFudCh0eXBlb2Ygc3BlYyA9PT0gJ29iamVjdCcpKTtcblxuICBpZiAoc3BlYy5oYXNPd25Qcm9wZXJ0eShDT01NQU5EX1NFVCkpIHtcbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgT2JqZWN0LmtleXMoc3BlYykubGVuZ3RoID09PSAxLFxuICAgICAgJ0Nhbm5vdCBoYXZlIG1vcmUgdGhhbiBvbmUga2V5IGluIGFuIG9iamVjdCB3aXRoICVzJyxcbiAgICAgIENPTU1BTkRfU0VUXG4gICAgKSA6IGludmFyaWFudChPYmplY3Qua2V5cyhzcGVjKS5sZW5ndGggPT09IDEpKTtcblxuICAgIHJldHVybiBzcGVjW0NPTU1BTkRfU0VUXTtcbiAgfVxuXG4gIHZhciBuZXh0VmFsdWUgPSBzaGFsbG93Q29weSh2YWx1ZSk7XG5cbiAgaWYgKHNwZWMuaGFzT3duUHJvcGVydHkoQ09NTUFORF9NRVJHRSkpIHtcbiAgICB2YXIgbWVyZ2VPYmogPSBzcGVjW0NPTU1BTkRfTUVSR0VdO1xuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICBtZXJnZU9iaiAmJiB0eXBlb2YgbWVyZ2VPYmogPT09ICdvYmplY3QnLFxuICAgICAgJ3VwZGF0ZSgpOiAlcyBleHBlY3RzIGEgc3BlYyBvZiB0eXBlIFxcJ29iamVjdFxcJzsgZ290ICVzJyxcbiAgICAgIENPTU1BTkRfTUVSR0UsXG4gICAgICBtZXJnZU9ialxuICAgICkgOiBpbnZhcmlhbnQobWVyZ2VPYmogJiYgdHlwZW9mIG1lcmdlT2JqID09PSAnb2JqZWN0JykpO1xuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICBuZXh0VmFsdWUgJiYgdHlwZW9mIG5leHRWYWx1ZSA9PT0gJ29iamVjdCcsXG4gICAgICAndXBkYXRlKCk6ICVzIGV4cGVjdHMgYSB0YXJnZXQgb2YgdHlwZSBcXCdvYmplY3RcXCc7IGdvdCAlcycsXG4gICAgICBDT01NQU5EX01FUkdFLFxuICAgICAgbmV4dFZhbHVlXG4gICAgKSA6IGludmFyaWFudChuZXh0VmFsdWUgJiYgdHlwZW9mIG5leHRWYWx1ZSA9PT0gJ29iamVjdCcpKTtcbiAgICBjb3B5UHJvcGVydGllcyhuZXh0VmFsdWUsIHNwZWNbQ09NTUFORF9NRVJHRV0pO1xuICB9XG5cbiAgaWYgKHNwZWMuaGFzT3duUHJvcGVydHkoQ09NTUFORF9QVVNIKSkge1xuICAgIGludmFyaWFudEFycmF5Q2FzZSh2YWx1ZSwgc3BlYywgQ09NTUFORF9QVVNIKTtcbiAgICBzcGVjW0NPTU1BTkRfUFVTSF0uZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICBuZXh0VmFsdWUucHVzaChpdGVtKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChzcGVjLmhhc093blByb3BlcnR5KENPTU1BTkRfVU5TSElGVCkpIHtcbiAgICBpbnZhcmlhbnRBcnJheUNhc2UodmFsdWUsIHNwZWMsIENPTU1BTkRfVU5TSElGVCk7XG4gICAgc3BlY1tDT01NQU5EX1VOU0hJRlRdLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgbmV4dFZhbHVlLnVuc2hpZnQoaXRlbSk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoc3BlYy5oYXNPd25Qcm9wZXJ0eShDT01NQU5EX1NQTElDRSkpIHtcbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgQXJyYXkuaXNBcnJheSh2YWx1ZSksXG4gICAgICAnRXhwZWN0ZWQgJXMgdGFyZ2V0IHRvIGJlIGFuIGFycmF5OyBnb3QgJXMnLFxuICAgICAgQ09NTUFORF9TUExJQ0UsXG4gICAgICB2YWx1ZVxuICAgICkgOiBpbnZhcmlhbnQoQXJyYXkuaXNBcnJheSh2YWx1ZSkpKTtcbiAgICAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gaW52YXJpYW50KFxuICAgICAgQXJyYXkuaXNBcnJheShzcGVjW0NPTU1BTkRfU1BMSUNFXSksXG4gICAgICAndXBkYXRlKCk6IGV4cGVjdGVkIHNwZWMgb2YgJXMgdG8gYmUgYW4gYXJyYXkgb2YgYXJyYXlzOyBnb3QgJXMuICcgK1xuICAgICAgJ0RpZCB5b3UgZm9yZ2V0IHRvIHdyYXAgeW91ciBwYXJhbWV0ZXJzIGluIGFuIGFycmF5PycsXG4gICAgICBDT01NQU5EX1NQTElDRSxcbiAgICAgIHNwZWNbQ09NTUFORF9TUExJQ0VdXG4gICAgKSA6IGludmFyaWFudChBcnJheS5pc0FycmF5KHNwZWNbQ09NTUFORF9TUExJQ0VdKSkpO1xuICAgIHNwZWNbQ09NTUFORF9TUExJQ0VdLmZvckVhY2goZnVuY3Rpb24oYXJncykge1xuICAgICAgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IGludmFyaWFudChcbiAgICAgICAgQXJyYXkuaXNBcnJheShhcmdzKSxcbiAgICAgICAgJ3VwZGF0ZSgpOiBleHBlY3RlZCBzcGVjIG9mICVzIHRvIGJlIGFuIGFycmF5IG9mIGFycmF5czsgZ290ICVzLiAnICtcbiAgICAgICAgJ0RpZCB5b3UgZm9yZ2V0IHRvIHdyYXAgeW91ciBwYXJhbWV0ZXJzIGluIGFuIGFycmF5PycsXG4gICAgICAgIENPTU1BTkRfU1BMSUNFLFxuICAgICAgICBzcGVjW0NPTU1BTkRfU1BMSUNFXVxuICAgICAgKSA6IGludmFyaWFudChBcnJheS5pc0FycmF5KGFyZ3MpKSk7XG4gICAgICBuZXh0VmFsdWUuc3BsaWNlLmFwcGx5KG5leHRWYWx1ZSwgYXJncyk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoc3BlYy5oYXNPd25Qcm9wZXJ0eShDT01NQU5EX0FQUExZKSkge1xuICAgIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBpbnZhcmlhbnQoXG4gICAgICB0eXBlb2Ygc3BlY1tDT01NQU5EX0FQUExZXSA9PT0gJ2Z1bmN0aW9uJyxcbiAgICAgICd1cGRhdGUoKTogZXhwZWN0ZWQgc3BlYyBvZiAlcyB0byBiZSBhIGZ1bmN0aW9uOyBnb3QgJXMuJyxcbiAgICAgIENPTU1BTkRfQVBQTFksXG4gICAgICBzcGVjW0NPTU1BTkRfQVBQTFldXG4gICAgKSA6IGludmFyaWFudCh0eXBlb2Ygc3BlY1tDT01NQU5EX0FQUExZXSA9PT0gJ2Z1bmN0aW9uJykpO1xuICAgIG5leHRWYWx1ZSA9IHNwZWNbQ09NTUFORF9BUFBMWV0obmV4dFZhbHVlKTtcbiAgfVxuXG4gIGZvciAodmFyIGsgaW4gc3BlYykge1xuICAgIGlmICghKEFMTF9DT01NQU5EU19TRVQuaGFzT3duUHJvcGVydHkoaykgJiYgQUxMX0NPTU1BTkRTX1NFVFtrXSkpIHtcbiAgICAgIG5leHRWYWx1ZVtrXSA9IHVwZGF0ZSh2YWx1ZVtrXSwgc3BlY1trXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5leHRWYWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB1cGRhdGU7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKSIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG4vKipcbiAqIENvcHlyaWdodCAyMDE0IEZhY2Vib29rLCBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHdhcm5pbmdcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKFwiLi9lbXB0eUZ1bmN0aW9uXCIpO1xuXG4vKipcbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgd2FybmluZyA9IGVtcHR5RnVuY3Rpb247XG5cbmlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgd2FybmluZyA9IGZ1bmN0aW9uKGNvbmRpdGlvbiwgZm9ybWF0ICkge3ZhciBhcmdzPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywyKTtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgK1xuICAgICAgICAnbWVzc2FnZSBhcmd1bWVudCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBjb25zb2xlLndhcm4oJ1dhcm5pbmc6ICcgKyBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSAge3JldHVybiBhcmdzW2FyZ0luZGV4KytdO30pKTtcbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2FybmluZztcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9SZWFjdCcpO1xuIl19
